6
1
0
2

 
r
a

 

M
6
1

 
 
]

.

C
O
h
t
a
m

[
 
 

1
v
4
3
0
5
0

.

3
0
6
1
:
v
i
X
r
a

Reduced Memory Footprint in

Multiparametric Quadratic Programming

by Exploiting Low Rank Structure

Isak Nielsen and Daniel Axehill∗

March 17, 2016

Abstract

In multiparametric programming an optimization problem which is
dependent on a parameter vector is solved parametrically.
In control,
multiparametric quadratic programming (mp-qp) problems have become
increasingly important since the optimization problem arising in Model
Predictive Control (mpc) can be cast as an mp-qp problem, which is
referred to as explicit mpc. One of the main limitations with mp-qp and
explicit mpc is the amount of memory required to store the parametric
solution and the critical regions. In this paper, a method for exploiting
low rank structure in the parametric solution of an mp-qp problem in
order to reduce the required memory is introduced. The method is based
on ideas similar to what is done to exploit low rank modiﬁcations in
generic qp solvers, but is here applied to mp-qp problems to save memory.
The proposed method has been evaluated experimentally, and for some
examples of relevant problems the relative memory reduction is an order
of magnitude compared to storing the full parametric solution and critical
regions.

Introduction

1
In parametric programming the optimization problem is dependent on a pa-
rameter which can be thought of as input data to the optimization problem [1].
When the optimization problem is dependent on several parameters it is re-
ferred to as multiparametric programming, and one class of such problems that
has proven to be important is multiparametric quadratic programming (mp-
qp) problems. See, e.g., [1] for a survey on parametric programming. In control
the importance of mp-qp has increased since it was shown in [2] that the opti-
mization problem in Model Predictive Control (mpc) can be cast as an mp-qp
problem and solved explicitly.

∗I. Nielsen and D. Axehill are with the Division of Automatic Control, Linköping University,

SE-58183 Linköping, Sweden, isak.nielsen@liu.se, daniel.axehill@liu.se.

mpc is a control strategy where the control input in each sample is computed
as the solution to a constrained ﬁnite-time optimal control (cftoc) problem, [3].
The cftoc problem is solved on-line in each sample of the control loop, which
requires eﬃcient algorithms for solving the optimization problem. Examples of
algorithms where the special structure in mpc problems is exploited are [4–6].
Solving the mp-qp problem that corresponds to the cftoc problem prior to
the on-line execution is referred to as explicit mpc, and the solution is explicitly
given as a function of the parameter. For a strictly convex mp-qp problem,
the parametric solution is a piecewise aﬃne (pwa) function of the parameters
over polyhedral critical regions, [2].
In [2], an algorithm for computing the
solution to the mp-qp is presented. The on-line computational eﬀort consists
of evaluating the pwa function for a given parameter [2], which allows for a
division free implementation of the control law that can be computed within an
a priori known worst case execution time [7].

A commonly used algorithm for improving the on-line process of evaluating
the pwa function is given in [8]. The authors propose an algorithm based on a
binary search tree, which provides evaluation times that are logarithmic in the
number of regions. In [16] a graph traversal algorithm is used to evaluate pwa
functions and the graph is constructed while solving the mp-qp problem. In [9]
the point location problem is solved by the use of linear decision functions, and

However, there are limitations with mp-qp and explicit mpc, and much
focus in research has been spent to overcome these. The main limitations are
the computation of the pwa function and the critical regions, the computation
of a data structure which provides eﬃcient lookup, the memory requirement to
store the parametric solution and the critical regions, and the time consumed to
determine which critical region the parameter belongs to, [2,7–9]. In [2] and [10]
the critical regions and the corresponding optimal active sets are determined by
geometric approaches for exploring the parameter space. The algorithm in [10]
exploits the relation between neighboring critical regions and the optimal active
sets, and it is reported to avoid unnecessary partitioning. In [11] an approach
to solve mp-qp problems by using an implicit enumeration that determines
all possible optimal active sets prior to the construction of the critical regions
is proposed. The algorithm provides a partition of the full parametric space
without unnecessary partitioning. In [12] a method for solving multiparametric
linear complementarity problems is presented. This class of problems include
mp-qp problems, but also extends to more general problems.

An algorithm which combines explicit mpc and online mpc is proposed
in [13]. Here, the main algorithm is similar to a standard active set method
such as the one presented in, e.g., [14], but the search directions are computed
oﬄine for all optimal active sets. For explicit mpc it is shown in [15] that a
pwa function, which is only deﬁned over the regions with non-saturated control
inputs, together with a projection onto a non-convex set can be used to reduce
the memory required to store the explicit solution. The method of implicitly
enumerating all optimal active sets proposed in [11] and the semi-explicit ap-
proach in [13] is combined in [7], where the authors propose an algorithm that
reduces the memory footprint in explicit mpc.

signiﬁcantly better performance in terms of computational time at a small cost
of increased memory has been reported.

Furthermore, the Multiparametric Toolbox (mpt) is an open source Mat-

lab-based toolbox for multiparametric optimization problems, [17].

The main contribution in this paper is the introduction of theory and al-
gorithms for exploiting low rank structure in the parametric solution between
neighboring critical regions for an mp-qp problem. The proposed method can
signiﬁcantly reduce the amount of memory required to store the solution and
critical regions by exploiting that only low rank modiﬁcations of the paramet-
ric solution is obtained when making minor changes to the optimal active sets.
In methods for solving general qp problems, exploiting low rank structure has
been a crucial approach to improve the performance, [14]. However, to the
authors’ knowledge, this has not yet been exploited when storing the solution
to mp-qp problems. The method stores the solution in a tree structure and
can be incorporated directly in already existing mp-qp solvers, or be applied
as a post-processing step to an already existing solution in order to reduce the
required memory. Hence, the approach presented here can be interpreted as a
data compression algorithm. The problem of solving the mp-qp problem has
been considered in previous work by other authors and is outside the scope of
this paper.
+) denotes symmetric positive (semi) deﬁnite matrices
with n columns, Zi,j (cid:44) {i, i + 1, . . . , j} and symbols in sans-serif font (e.g. x)
|S| denotes the cardinality of the set
denote matrices of stacked components.
S.

In this paper Sn

++ (Sn

2 Multiparametric Quadratic Programming
In this section the basics of mp-qp are surveyed, and notation that will be used
in the following sections is introduced. Consider an optimization problem in the
form

where u ∈ Rm is the optimization variable, θ ∈ Rn is the parameter, the cost
function is determined by H ∈ Sm
++ and g ∈ Rn×m, the inequality constraints
are given by G ∈ Rp×m, b ∈ Rp and E ∈ Rp×n, and Θ is a polyhedral set.
The problem (1) is an mp-qp problem with parameter θ, see, e.g., [1, 2]. By
introducing the change of variables z (cid:44) u + H−1gT θ, the problem (1) can be
transformed into the equivalent mp-qp problem

minimize
subject to Gz (cid:22) b + Sθ,

zHz

z

1
2

θ ∈ Θ,

(2)

where S (cid:44) E + GH−1gT ∈ Rp×n. For any choice of parameter θ ∈ Θ, the
problem (2) is a strictly convex qp problem, and the necessary and suﬃcient

minimize
uT Hu + θT gu
subject to Gu (cid:22) b + Eθ,

u

1
2

θ ∈ Θ,

(1)

optimality conditions are given by the Karush-Kuhn-Tucker (kkt) conditions

Hz + GT λ = 0,

(3a)
(3b)
(3c)
(3d)
where λ ∈ Rp are the Lagrange multipliers associated with the inequality con-
straints, [14].

λk (Gkz − bk − Skθ) = 0, k ∈ Z1,p,

Gz (cid:22) b + Sθ,
λ (cid:23) 0,

It is shown in, e.g., [2] that the solution to the mp-qp problem (2) is given

by the pwa function

z∗(θ) = i˛ + Kiθ if θ ∈ Pi, i ∈ Z1,R,

(4)
where i˛ ∈ Rm, Ki ∈ Rm×n deﬁne the parametric solution in the polyhedral
critical region Pi for i ∈ Z1,R. The pwa function (4) and the R critical regions
are computed by solving the mp-qp problem (2) parametrically, basically by
considering all possible combinations of optimal active constraints, which is
explained in, e.g., [2, 10, 11].

2.1 Compute the solution for an optimal active set
For any feasible choice of the parameter θ ∈ Θ, the set of indices of constraints
that hold with equality at the optimum is called the optimal active set. As-
sume that no constraints in the optimal active set are weakly active, i.e., no
constraints k in the optimal active set have λk = 0. How to choose the optimal
active sets in the case of weakly active constraints can be seen in, e.g., [10].
Let the set of all optimal active sets be denoted A, and let the elements in A
be denoted Ai for i ∈ Z1,R. Each optimal active set Ai then corresponds to a
critical region Pi, [10, 11]. Let Ni be the set of inactive constraints, satisfying
Ai ∪ Ni = Z1,p and Ai ∩ Ni = ∅.

To clarify the relation between the optimal active set and the corresponding
solution and critical region, let GAi and GNi be the matrices consisting of the
rows in G indexed by Ai and Ni, respectively, and let the same hold for SAi,
SNi, bAi and bNi. Furthermore, let GAi have full row rank, i.e., the linear
constraint qualiﬁcation (licq) holds for Ai, [10]. Violation of licq is referred
to as primal degeneracy, and if GAiz = bAi + SAiθ are linearly independent this
results in a non full dimensional critical region that in general is a facet between
full dimensional regions [2, 10], and need hence not be considered here. For
any parameter θ ∈ Pi, where Pi corresponds to Ai, the solution to the mp-qp
problem (2) can be computed by parametrically solving the equality constrained
mp-qp problem

minimize

z

1
2

zHz

subject to GAiz = bAi + SAiθ.

(5)

The parametric solution to (5) is an aﬃne function in the parameter θ. Now

deﬁne (cid:101)qi ∈ Rp and (cid:101)Qi ∈ Rp×n as
(cid:40)(cid:101)qi,Ni = 0,
(cid:101)qi,Ai = qi,

(cid:40)(cid:101)Qi,Ni = 0,
(cid:101)Qi (cid:44)
(cid:101)qi (cid:44)
(cid:101)Qi,Ai = Qi,
(cid:1)−1
qi + Qiθ (cid:44) −(cid:0)GAiH−1GTAi

where qi ∈ R|Ai| and Qi ∈ R|Ai|×n are given by

(bAi + SAiθ) .

(6)

(7)

See, e.g., [2] for the details. The ”tilde” notation, introduced in (6), is used to
denote a variable that is related to the p constraints in the mp-qp problem (2),
but with some components trivially zero. The choice of this notation will later
become clear. The parametric primal and dual solution to (5) for θ ∈ Pi is then
given by

λ∗(θ) =(cid:101)qi + (cid:101)Qiθ,

z∗(θ) = i˛ + Kiθ (cid:44) −H−1GTAi

(cid:16)(cid:101)qi,Ai + (cid:101)Qi,Aiθ

(cid:17)

(8a)

(8b)

.

2.2 Compute the critical region for an optimal active set
The critical region is the set of parameters for which the active set Ai is optimal,
i.e., all parameters θ ∈ Θ such that primal and dual feasibility given by (3b)
and (3c), respectively, is retained. By inserting the parametric solution (8) in
the primal and dual feasibility conditions in the kkt conditions (3), the critical
region Pi is deﬁned by

Pi (cid:44)(cid:8)θ∈ Θ| GNi (i˛+Kiθ)(cid:22) bNi +SNiθ, (cid:101)qi,Ai + (cid:101)Qi,Ai θ(cid:23) 0(cid:9),

which is a polyhedron with p hyperplanes, [2]. A double index as in, e.g., (cid:101)qi,Ai
denotes the components in (cid:101)qi indexed by Ai. All hyperplanes in (9) which

are redundant can be removed to obtain a description of Pi with the minimal
number of describing hyperplanes, [2, 10]. Let Hp
i be the indices of
the describing hyperplanes related to the primal and dual feasibility conditions
in (9), respectively. Then the critical region Pi in (9) is equivalent to

(9)

Pi=(cid:8)θ∈ Θ| GHp

(i˛+Kiθ)(cid:22) bHp

i

+SHp

i

i

Storing the parametric solution and the minimal description of the critical re-
gions requires MF real numbers, where

θ(cid:23) 0(cid:9).

i and Hd
+ (cid:101)Qi,Hd
θ, (cid:101)qi,Hd
(cid:0)Hp

i +Hd

i

i

i

(cid:1) (n+1) .

F (cid:44) R(cid:88)

i=1

MF (cid:44) Rm (n+1) + Mcr

F , Mcr

(10)

(11)

3 Low Rank Changes of Parametric Solution
In this section it will be shown how the parametric solution in a neighboring
region can eﬃciently be described by small structured modiﬁcations of the solu-
tion in the ﬁrst region. Stepping over a facet between two neighboring regions
corresponds to adding or removing constraints to the optimal active set, [10].
Hence, an equivalent interpretation is that the parametric solution for one set
of optimal active constraints can be used to describe the solution for an opti-
mal active set where constraints have been added to, or removed from, the ﬁrst
one. For notational convenience the case when only one constraint is added or
removed is presented in this paper. The case for k constraints can be shown
analogously.

3.1 Add one constraint to the optimal active set
Let the solution corresponding to an optimal active set Ai ∈ A be given by (8).
Consider the case when a constraint l ∈ Ni is added, i.e., the active set Aj =
Ai ∪ l is also optimal, and Aj hence corresponds to the critical region Pj.
Theorem 1. Let the parametric solution of (2) for the optimal active set Ai
be given by (8). Then, the solution for Aj = Ai ∪ l with l ∈ Ni is given by

λ∗(θ) =(cid:101)qj + (cid:101)Qjθ (cid:44)(cid:101)qi + (cid:101)Qiθ −(cid:101)dj

(cid:0)cj + vT
j θ(cid:1) ,
(cid:0)cj + vT
j θ(cid:1) ,

(12a)
(12b)

z∗(θ) = j˛ + Kjθ (cid:44) i˛ + Kiθ + fj

where cj ∈ R, vj ∈ Rn, fj ∈ Rm and (cid:101)dj ∈ Rp with (cid:101)dj,Nj = 0, (cid:101)dj,l = −1 and
(cid:101)dj,Ai possibly non-zero.
(cid:21)

Proof. For Aj, the solution to the mp-qp problem (2) is given by (8), but with
index ”j” instead of ”i”. Without loss of generality, let Gl be the last row in GAj .
To compute (7), the matrix inversion lemma (38) in Appendix A.1 is applied to

(cid:21)

(cid:20)W w

GAiH−1GT
GlH−1GT

l

l

.

(13)

(cid:44) GAj H−1GTAj

=

wT w0

The dual parametric solution (8a) for Aj is then given by

(cid:20)GAiH−1GTAi
GlH−1GTAi
(cid:21)

(cid:20)W −1 (bAi + SAiθ)

λ∗
Aj

(θ) = −

(cid:20)W −1w(cid:0)C−1wT W −1 (bAi +SAiθ)−C−1(bl +Slθ)(cid:1)

−C−1wT W −1 (bAi + SAi θ) + C−1 (bl + Slθ)

−

0

(cid:21)

(14)

where C is deﬁned as in Appendix A.1. From (7) and the deﬁnition of W in (13)
it is clear that −W −1 (bAi + SAiθ) = qi + Qiθ. Furthermore, by deﬁning cj and
vj as

cj (cid:44) C−1(cid:0)wT W −1bAi − bl
vj (cid:44) C−1(cid:0)STAi

W −1w − ST

l

(cid:1) ∈ R,
(cid:1) ∈ Rn,

(15a)
(15b)

(cid:17)

(θ), giving

(cid:44) W −1w ∈

From (8b) it can be seen that the primal solution for the optimal active set

the dual solution can compactly be written as (12a), where (cid:101)dj,Ai
R|Ai|, (cid:101)dj,l (cid:44) −1 and (cid:101)dj,Nj
Aj is z∗(θ) = −H−1GTAj
j θ(cid:1)(cid:17)
(cid:0)cj + vT
(cid:0)cj +vT
j θ(cid:1).

(cid:16)(cid:101)qi,Aj + (cid:101)Qi,Aj θ −(cid:101)dj,Aj
+H−1GTAj(cid:101)dj,Aj

(cid:44) 0.
λ∗
Aj
(cid:16)(cid:101)qi,Ai +(cid:101)Qi,Aiθ
z∗(θ) = −H−1GTAj
−H−1GTAi
(cid:17)

(cid:16)(cid:101)qi,Ai+(cid:101)Qi,Aiθ

In the second equality (cid:101)qi,l = 0 and (cid:101)Qi,l = 0 by deﬁnition are used. Using
= i˛+Kiθ from (8b) and deﬁning fj (cid:44) H−1GTAj(cid:101)dj,Aj ∈
−H−1GTAi
Rm, the primal solution (12b) is obtained from (16).
Remark 1. From Theorem 1 it can be seen that the parametric solution in Pj
can be computed as a rank one modiﬁcation of the parametric solution in Pi.
Corollary 1. Let the parametric solution to (2) with Aj = Ai ∪ l be given by
Theorem 1. Then the corresponding critical region Pj is given by (9), but where
the primal and dual feasibility conditions (3b) and (3c) are instead given by

(16)

=

(cid:0)cj + vT
(cid:0)cj + vT

j θ(cid:1) (cid:22) bNj + SNj θ,
j θ(cid:1) (cid:23) 0,

(17a)
(17b)

GNj (i˛ + Kiθ) + (cid:101)fj,Nj
(cid:101)qi,Aj + (cid:101)Qi,Aj θ −(cid:101)dj,Aj
where (cid:101)fj (cid:44) Gfj ∈ Rp with (cid:101)fj,Ai = 0.

Proof. The critical region Pj is given by (9) but with index ”j” instead of ”i”.
Hence, the dual feasibility conditions (17b) follow directly from the dual solu-
tion (12a).

By inserting the primal solution (12b) into the inequality constraints of (2)

and deﬁning (cid:101)fj (cid:44) Gfj gives

(cid:0)cj + vT
j θ(cid:1) (cid:22) b + Sθ ⇐⇒
(cid:0)cj + vT
j θ(cid:1) (cid:22) bNj + SNj θ.
(cid:0)cj + vT

G (i˛ + Kiθ) + Gfj

GNj (i˛ + Kiθ) + (cid:101)fj,Nj

(18)

Here it is used that GAj (i˛ + Kiθ) + GAj fj

j θ(cid:1) = GAj (j˛ + Kjθ) = bAj +
SAj θ by the deﬁnition of Aj. (cid:101)fj,Ai = 0 follows from the deﬁnition of fj, (cid:101)dj, W
and w.
feasibility conditions in Pi, (cid:101)qi,l = 0 and (cid:101)Qi,l = 0. Hence, the new information
Remark 2. Note that GNj (i˛ + Kiθ) (cid:22) bNj + SNj θ are a subset of the primal
in the description of Pj is contained in (cid:101)fj,Nj ∈ R|Nj| and (cid:101)dj,Aj ∈ R|Aj|. Note

that cj and vj are already computed for λ∗(θ) and z∗(θ).

3.2 Remove one constraint from the optimal active set
When a constraint is removed from the optimal active set, the parametric so-
lution and the description of the critical region change in a similar way as in
Section 3.1.
Theorem 2. Let the solution for the optimal active set Aj be given by (8) but
with index ”j” instead of ”i”. Then, the parametric solution for the optimal
active set Ai = Aj\l with l ∈ Aj is given by

λ∗(θ) =(cid:101)qi + (cid:101)Qiθ (cid:44)(cid:101)qj + (cid:101)Qjθ −(cid:101)di

(cid:0)ci + vT
i θ(cid:1) ,
(cid:0)ci + vT
i θ(cid:1) ,

(19a)
(19b)

where ci (cid:44) cj, vi (cid:44) vj, (cid:101)di (cid:44) −(cid:101)dj and fi (cid:44) −fj. Here the variables with index

z∗(θ) = i˛ + Kiθ (cid:44) j˛ + Kjθ + fi

”j” are deﬁned as in Theorem 1.
Proof. First, note that Ai = Aj\l ⇐⇒ Aj = Ai ∪ l. Hence, Theorem 1 applies
for the optimal active set Aj, and by re-order the terms in (12a) it can be seen
that

which, by deﬁning the variables ci (cid:44) cj, vi (cid:44) vj and (cid:101)di (cid:44) −(cid:101)dj gives (19a).

(cid:101)qi + (cid:101)Qiθ =(cid:101)qj + (cid:101)Qjθ +(cid:101)dj

(20)

Furthermore, by re-order the terms in (12b) it follows that

j θ(cid:1) ,
(cid:0)cj + vT
(cid:0)cj + vT
j θ(cid:1) ,

i˛ + Kiθ = j˛ + Kjθ − fj

(21)

which, using ci, vi and deﬁning fi (cid:44) −fj, gives (19b).

Note that, similar to Remark 1, also here the parametric solution for Pi is

a rank one modiﬁcation of the one in Pj.
Corollary 2. Let the parametric solution to (2) with Ai = Aj\l be given by
Theorem 2. Then the corresponding critical region Pi is given by (9), but where
the primal and dual feasibility conditions are instead given by

GNi (j˛ + Kjθ) + (cid:101)fi,Ni
(cid:101)qj,Ai + (cid:101)Qj,Aiθ −(cid:101)di,Ai
where (cid:101)fi (cid:44) Gfi ∈ Rp with (cid:101)fi,Ai = 0.

(cid:0)ci + vT
(cid:0)ci + vT

i θ(cid:1) (cid:22) bNi + SNiθ,
i θ(cid:1) (cid:23) 0,

(22a)
(22b)

(cid:0)ci + vT

i θ(cid:1) (cid:22) bNi + SNiθ.

Proof. The dual feasibility conditions (22b) follow directly from (19a). Fur-
thermore, inserting the primal parametric solution (19b) into the inequality
constraints of the mp-qp problem (2) gives

By using the deﬁnition (cid:101)fi (cid:44) Gfi , (23) gives (22a). (cid:101)fi,Ai = 0 follows by deﬁni-

GNi (j˛ + Kjθ) + GNifi

tion, which concludes the proof.
Remark 3. Similar to Remark 2, the description of Pj is re-used in Pi. Fur-
thermore, Gl (j˛ + Kjθ) = bl + Slθ since l ∈ Aj. Hence, the new information in

the description of Pi is contained in (cid:101)fi,Ni ∈ R|Ni| and (cid:101)di,Ai ∈ R|Ai|.

(23)

4 Memory Eﬃcient Storage Tree
In this section it will be shown how the theory presented in Section 3 can be
utilized repeatedly to store the parametric solutions and critical regions in a
memory eﬃcient manner. The storage of the parametric solution is arranged
into a tree structure, henceforth denoted as the storage tree. The tree structure
is related to the tree in [11] and the graph in [16].
The set A consists of all optimal active sets Ai, i ∈ Z1,R corresponding
to the critical regions Pi, i ∈ Z1,R in the parametric solution of the mp-qp
problem (2), and can be arranged in a tree structure by choosing the root node
r to correspond to Ar ∈ A with r ∈ Z1,R. To simplify the notation, let pa(i),
ch(i) and anc(i) denote the parent, the set of children and the ordered set of
indices of ancestors of node i in the tree, respectively. Furthermore, let desc(i)
denote the descendants of node i, P(i) = i∪ (anc(i)\r) be the ordered set of the
node and the ancestor nodes except the root, and let D be the maximum depth
in the tree.
Deﬁnition 1. The storage tree of a set of optimal active sets A is denoted
T (A, r), where node r is the root node.
Assumption 1. For all nodes i ∈ T (A, r)\r only one constraint is added to,
or removed from, the optimal active set of the parent node pa(i).

The nodes in a storage tree from Def. 1, for which Ass. 1 holds, correspond
to the optimal active sets Ai ∈ A, and they are arranged such that either one
constraint is added or removed in the optimal active set from a parent to a child.
This corresponds to moving across a facet between adjacent critical regions [10].
As mentioned earlier, the case when k constraints are added or removed can be
derived analogously.

Remark 4. The results in Section 3 are not dependent on the tree structure
and hold also for more general graph structures than the one chosen here.

An example with two parameters and a partitioning consisting of 6 critical
regions Pi for i ∈ Z1,6 is seen in Figure 1, and a corresponding storage tree
T (A, 2) is seen in Figure 2. Each critical region Pi corresponds to the optimal
active set Ai ∈ A, where A = {{},{1},{2},{3},{1, 2},{1, 3}}. Hence, P2 is
the critical region for the optimal active set A2 = {1} etc.
In Figure 1, the
hyperplane between, e.g., P2 and P6 corresponds to constraint 3. Hence, moving
from region P2 to P6 by stepping over the shared facet corresponds to adding
constraint 3 to the optimal active set in P2, i.e., A6 = A2 ∪ {3}. In the tree in
Figure 2 the optimal active set A2 = {1} is chosen as root node, and for this tree
it can be seen that, for example, pa(3) = 1, anc(3) = {1, 2}, P(3) = {3, 1} and
ch(2) = {1, 5, 6}. The maximum depth is D = 2. The transition from P2 to P6
corresponds to moving from node 2 to node 6 in the tree by adding constraint
3.
Note that the storage tree is not unique. Here, e.g., the tree T (A, 1) could
also be used, i.e., having the optimal active set {} in the root instead. The choice

θ2

l = 1

P5

P2

P6

P3
P1

P4

l = 2

l = 3

θ1

Figure 1: Example with critical regions Pi for i ∈ Z1,6 in two dimensions. The
three separating hyperplanes correspond to constraints 1, 2 and 3, respectively.
When moving between adjacent critical regions, the constraint corresponding to
the facet is either added or removed from the optimal active set. An example
of a storage tree for this partition is seen in Figure 2.

2 :{1}

5 :{1, 2}

1 :{}

6 :{1, 3}

3 :{2}

4 :{3}

Figure 2: Example of a storage tree for the partitioning in Figure 1,
where each Pi for i ∈ Z1,6 corresponds to an optimal active set in A =
{{},{1},{2},{3},{1, 2},{1, 3}}. The number in front of the ”:”
in each node
corresponds to the index i in A. A ”+” sign at an edge corresponds to adding
a constraint to the child, and a ”-” sign corresponds to removing a constraint.
Note that the tree structure is not unique.

of tree structure will aﬀect the maximum depth of the tree, and hence also the
on-line performance. How to choose the tree to obtain maximum performance
is outside the scope of this work.

Remark 5. The storage tree could either be constructed after all optimal active
sets have been determined, or while building the solution to the mp-qp problem
in the solver.

4.1 Compute the parametric solution and critical region
By storing the full description of the critical region Pr and the parametric
solution r˛ and Kr in the root node and repeating the theory in Section 3, it
can be shown that the parametric solution and description of the critical region
in each node i can be described by a number of low rank modiﬁcations of the
root node. From the deﬁnition of T (A, r) it can be seen that the modiﬁcations
which are used to obtain the solution and the critical region in node i are stored
in the nodes j ∈ P(i), i.e., the nodes along the path from the root node to node
i.
Theorem 3. Let A be the set of optimal active sets for the mp-qp problem (2),
and let T (A, r) be a storage tree for which Ass. 1 holds. Then the parametric
solution for θ ∈ Pi for i ∈ T (A, r) is given by

z∗(θ) = r˛ + Krθ +

(cid:88)

fj

j∈P(i)

(cid:0)cj + vT
j θ(cid:1) ,

where cj, vj and fj are deﬁned as in Theorem 1 or Theorem 2 depending on
the type of edge between node i and pa(i). Furthermore, the critical region Pi is
described by the set of parameters θ ∈ Θ that satisfy the inequalities

(cid:88)
(cid:101)bNi + (cid:101)ANiθ +
(cid:88)
−(cid:101)qr,Ai − (cid:101)Qr,Aiθ +
where(cid:101)b (cid:44) Gr˛ − b and (cid:101)A (cid:44) GKr − S.

j∈P(i)

j∈P(i)

(cid:101)fj,Ni
(cid:101)dj,Ai

(cid:0)cj + vT
(cid:0)cj + vT

j θ(cid:1) (cid:22) 0,
j θ(cid:1) (cid:22) 0,

Proof. Assume that (24) holds for some n ∈ T (A, r) such that ch(n) (cid:54)= ∅. Take
an arbitrary node i ∈ ch(n) where Ai = An ∪ l (or Ai = An\l). Then it follows
from Theorem 1 (or Theorem 2) that the parametric solution is

(24)

(25a)

(25b)

(26)

(cid:88)
i θ(cid:1) = r˛ + Krθ +

j∈P(n)

fj

(cid:0)cj + vT
j θ(cid:1) +
(cid:88)
(cid:0)cj + vT
j θ(cid:1) ,

fj

z∗(θ) = r˛ + Krθ +

(cid:0)ci + vT

fi

j∈P(i)

where it has been used that P(i) = i∪ P(n) since i ∈ ch(n). Since (24) holds for
the root r, and n and i ∈ ch(n) were chosen arbitrary, the relation (24) follows
from induction.

The relations (25) can be shown analogously from Corollary 1 (or Corol-
lary 2) by utilizing that, for the root node r, the dual feasibility conditions (3c)

are −(cid:101)qr − (cid:101)Qrθ (cid:22) 0 and the primal feasibility conditions (3b) are described by
where(cid:101)b (cid:44) Gr˛ − b and (cid:101)A (cid:44) GKr − S.

G (r˛ + Krθ) (cid:22) b + Sθ ⇐⇒ (cid:101)b + (cid:101)Aθ (cid:22) 0,

(27)

Remark 6. The full parametric solution and description of the critical region
is only stored for the root node r. For the rest of the nodes, only the low rank
modiﬁcations are stored.

The method to compute the solution as in Theorem 3 is implemented in
Alg. 1, where the parameter θ and the node i are inputs, and the optimal
solution z∗(θ) is returned.

Algorithm 1 On-line evaluation of parametric solution
1: input θ and i.
2: Initialize z = r˛ + Krθ.
3: for j ∈ P(i) do
4:
5: end for
6: z∗ := z.

(cid:0)cj + vT
j θ(cid:1).

z := z + fj

Corollary 3. To obtain the minimal representation of the critical region Pi,
i and Hd
i need to be used, i.e., Pi can be
only the describing hyperplanes Hp
described by (10) but where the primal and dual feasibility conditions are given
(cid:88)
(cid:101)fj,Hp
by
(cid:88)
(cid:101)dj,Hd

(cid:101)bHp
+ (cid:101)AHp
− (cid:101)Qr,Hd
−(cid:101)qr,Hd

j θ(cid:1) (cid:22) 0,
j θ(cid:1) (cid:22) 0.

(cid:0)cj + vT
(cid:0)cj + vT

(28b)

(28a)

j∈P(i)

θ +

i

i

i

i

θ +

i

i

j∈P(i)

Proof. The corollary follows directly from Theorem 3 since each hyperplane n
in (25) is described only by the components and rows indexed by n in (25).

In Alg. 2 the evaluation of a hyperplane using Corollary 3 is implemented.
The parameter θ, the node i and the hyperplane index n are given as inputs to
the algorithm, and the value of the hyperplane, denoted s, is returned. Note
j θ only has to be computed once
that for a given parameter θ the value of cj + vT

for each Pj when evaluating hyperplanes, and(cid:101)bn + (cid:101)Anθ and −(cid:101)qr,n −(cid:101)Qr,nθ need

only be computed once for each parameter and can be re-used by all nodes.

end for

i then

for j ∈ P(i) do

Initialize s :=(cid:101)bn + (cid:101)Anθ.
(cid:0)cj + vT
j θ(cid:1).
s := s + (cid:101)fj,n
Initialize s := −(cid:101)qr,n − (cid:101)Qr,nθ
(cid:0)cj + vT
j θ(cid:1).
s := s +(cid:101)dj,n

Algorithm 2 On-line evaluation of a hyperplane
1: input θ, i and n.
2: if n ∈ Hp
3:
4:
5:
6:
7: else
8:
9:
10:
11:
12: end if
Remark 7. In algs. 1 and 2 the order of summation can be chosen to facilitate
on-line performance by taking, e.g., memory access into consideration.

for j ∈ P(i) do

end for

4.2 Storing the parametric solution and critical region
From Theorem 3 it follows that computing the parametric solution in node i
only requires the storage of cj ∈ R, vj ∈ Rn and fj ∈ Rm for each node j ∈ P(i).
However, in the root node r the full parametric solution deﬁned by r˛ ∈ Rm and
Kr ∈ Rm×n needs to be stored. In Corollary 3 it is shown that the description of
the critical region in node i only requires the describing hyperplanes. Hence, the
full vectors and matrices in (28) need not be stored, but only the components

and rows of(cid:101)b,(cid:101)qr, (cid:101)A, (cid:101)Qr, (cid:101)fj and (cid:101)dj for j ∈ P(i) that correspond to the describing

hyperplanes.
Furthermore, from Corollary 3 it can be seen that the low rank modiﬁcation
in node i is also used by all descendants desc(i) ⊂ T (A, r). Hence, the entries
and rows with indices corresponding to deﬁning hyperplanes for Pj with j ∈
desc(i) also need to be stored in node i. Let S p
i be the indices of
the hyperplanes corresponding to primal and dual feasibility conditions in the
description of Pi that need to be stored in node i. Then these sets of indices
are

(cid:44) (cid:91)
in (29). Hence, ci ∈ R, vi ∈ Rn, fi ∈ Rm, (cid:101)fi,S p

Here, by deﬁnition, the trivial zeros in (cid:101)fi and (cid:101)di should not be stored when
and (cid:101)di,S d
node r, the vectors r˛ ∈ Rm,(cid:101)bS p
r |×n and (cid:101)Qr,S d
Rm×n, (cid:101)AS p
m (n + 1) +(cid:0)|S p
r|(cid:1) (n + 1) real numbers to be stored. Hence, the total
r| + |S d

∈ R|S p
i |
i | need to be stored for each node i ∈ T (A, r)\r. Storing
i | real numbers. For the root
r | and the matrices Kr ∈
∈ R|S d
r |×n need to be stored. This requires

these for node i requires 1 + n + m + |S p

r |, (cid:101)qr,S d
i | + |S d

i and S d
∈ R|S d

(cid:44) (cid:91)

r ∈ R|S p
∈ R|S d

computing S p

i and S d

r ∈ R|S p

j∈desc(i)∪i

j∈desc(i)∪i

Hp
j , S d

i

Hd
j .

r

r

(29)

i

S p

i

i

i

number MLR of stored real numbers for T (A, r) is

MLR = m (n + R) + Mcr
(R − 1) (1 + n) +

LR, Mcr

(cid:88)

i∈T (A,r)\r

LR (cid:44)(cid:0)|S p
(cid:0)|S p

r|(cid:1) (n + 1) +
i |(cid:1) .

r| + |S d

i | + |S d

(30)

Note that the storage of ci and vi is included in Mcr
LR.
Remark 8. Note that the set of optimal active sets A can be described by several
smaller trees, where the union of the node in the trees corresponds to all optimal
active sets Ai ∈ A for i ∈ Z1,R. In the example presented in Figure 1 and Fig-
ure 2, the partitioning can for example be described by two trees; one containing,
e.g., the nodes 1, 2, 3, 5 and one containing the nodes 4, 6. In this case, there
are two root nodes (one for each tree) where the full solution and description of
the critical region need to be stored, i.e., several trees require more memory to
store the parametric solution and critical regions. Using several trees instead of
one can, if chosen correctly, reduce the maximum depth of each tree and hence
aﬀect the on-line performance. The balancing between the choice of number of
trees and the structure of each tree to reduce the memory requirements and the
on-line performance to evaluate a solution or a hyperplane is probably problem
dependent, and the choice can be made by optimizing the memory reduction and
on-line complexity to ﬁt the requirements of a particular hardware set-up and
problem. How to do this is not investigated in this work.

5 Explicit Model Predictive Control
In linear mpc the input is computed by solving a cftoc problem. A common
formulation of the cftoc problem is

N−1(cid:88)

(cid:0)xT

1
2

minimize

x,u

subject to

(cid:1) +

1
2

t Qxxt + uT

t Quut

xT
N PN xN

t=0
x0 = ¯x
xt+1 = Axt + But, t ∈ Z1,N−1
Hxxt + Huut + h (cid:22) 0, t ∈ Z1,N−1
HxxN + h (cid:22) 0,

(31)

where xt ∈ Rnx is the state vector, ut ∈ Rnu is the control input, ¯x is the initial
state and N is the prediction horizon. The cost function is given by Qx ∈ Snx
+ ,
Qu ∈ Snu
++ and PN ∈ Snx
+ . The equality constraints are the dynamics equations
of the controlled system, and the inequality constraints are constraints on the
states and control inputs.

Similarly to what is shown in [2], the cftoc problem (31) can equivalently

be written in the form of an mp-qp problem (1) by deﬁning the matrices

H (cid:44) Qu + BT QxB ∈ SN nu
G (cid:44) HxB + Hu, b (cid:44) −h, E (cid:44) −HxA, θ (cid:44) ¯x,

++ , g (cid:44) AT QxB,

(32a)
(32b)

where Qx, Qu, A, B, Hx, Hu and h are all deﬁned in (39) in Appendix A.1. By
re-writing the mp-qp problem (1) into (2) and solving it parametrically, the
optimal solution to the cftoc problem is given by u∗(θ) = z∗(θ) − H−1gT θ
where z∗(θ) is the pwa function (4), [2].

Since the cftoc problem is equivalent to an mp-qp problem in the form (2),
the storage of the explicit solution to the cftoc problem can be done using the
theory presented in this paper. Only the ﬁrst control input u∗
0 is used as input
to the plant in the mpc control loop [3], and hence the full parametric solution
does not need to be stored in the case of explicit mpc. Here only the ﬁrst nu
components and rows of i˛ and Ki, respectively, are stored. For the traditional
non-compressed solution this results in that

R(cid:88)

(cid:0)Hp

(cid:1) (n + 1) ,

i + Hd

i

Mmpc

F = Rnu (n + 1) +

(33)

i=1

real numbers are stored. This is a slightly modiﬁed version of MF in (11).
Similarly for the compressed solution, only the low rank modiﬁcations aﬀecting
the ﬁrst nu rows need to be stored in T (A, r). Hence, for the explicit mpc
solution, the number of stored real numbers is

LR = nu (n + R) + Mcr
LR,
which is a slightly modiﬁed version of MLR in (30).

Mmpc

(34)

6 Experimental Evaluation
In this section, the memory requirement for storing the solution and the critical
regions for the proposed method is compared to storing the full solution and
critical regions. The mp-qp problems have been solved using mpt (version ”3.1.2
(R2011a) 28.10.2015”) in Matlab (version ”8.4.0.150421 (R2014b)”). Although
the optimal active sets are computed in the mp-qp solver, it was not possible
to access them in the solution returned by the solver. Hence, they have instead
been retrieved by solving the corresponding qp problem with the Chebychev
center of each critical region as parameter.

6.1 Deﬁning the problems
The comparison has been made for three diﬀerent examples where explicit mpc
controllers are applied to stable lti systems. For the ﬁrst system, referred to
as Problem 1, the continuous system 1/(s + 1)nx which is used in [7] is studied,
and the system has nx states and nu = 1 control inputs. The transfer function
has been discretized using a unit sampling time, the weight matrices are Qx = I
and Qu = I, and the terminal cost PN is chosen as the discrete time lq cost.
The states and control inputs are subject to the constraints

− 10 (cid:22) xt (cid:22) 10, t∈Z0,N , −1 ≤ ut ≤ 1, t∈Z0,N−1.

(35)

After re-writing this explicit mpc problem into an equivalent mp-qp problem as
in Section 5, the problem has n = nx parameters and m = N nu = N variables.
The second and third problems both use a system which is similar to the
one used in, e.g., [18,19]. It consists of nM unit masses which are coupled with
springs and dampers. The spring constant is chosen as 1, the damping constant
as 0, the weight matrices to Qx = 100I and Qu = I and the terminal cost PN is
chosen as the discrete time lq cost. The continuous system is discretized using
the sampling time 0.5 seconds. Two diﬀerent cases have been studied, referred
to as Problem 2 and Problem 3. In Problem 2 the control input is a force acting
between terra ﬁrma and the ﬁrst mass, and in Problem 3 there is also an extra
control input acting as a force applied between the ﬁrst two masses. In both
problems, the states and control inputs are subject to the constraints

− 4(cid:22) xt (cid:22) 4, t∈Z0,N , −0.5 (cid:22) ut (cid:22) 0.5, t∈Z0,N−1.

(36)

Each mass introduces 2 states, and in Problem 2 nu = 1 and in Problem 3 nu = 2
by construction. Hence, by re-writing the mpc problem into the equivalent mp-
qp problem as in Section 5, the corresponding mp-qp problem has n = 2nM
parameters and m = N nu variables.
6.2 Experimental results
The relative memory reduction has been computed for the three problems for
diﬀerent parameter dimensions and prediction horizons, and the results are sum-
marized in tables 1-3. The storage tree T (A, r) is chosen such that the the root
node corresponds to the optimal active set Ar = {}, i.e., the unconstrained min-
imum, and whenever it is possible only one constraint is added to the children
of each node. When the mp-qp problem is deﬁned, all redundant constraints
are removed, giving p number of non-redundant constraints. Furthermore, R is
the number of regions, D is the maximum depth of T (A, r), and

∆cr (cid:44) Mcr
LR
Mcr
F

, ∆ (cid:44) MLR
MF

, ∆mpc (cid:44) Mmpc
LR
Mmpc

F

,

(37)

are the relative reductions in the number of stored real numbers for only the
critical regions, the full solution and the critical regions, and for storing the ﬁrst
nu control inputs and the critical regions, respectively. Hence, for the case of
explicit mpc, ∆mpc determines the total relative memory reduction, whereas for
a full mp-qp problem it is given by ∆. No symmetry or other properties which
are inherited from the explicit mpc problems are exploited in the comparison. In
some cases, for large problems with many parameters and variables the solution
in a few regions are numerically bad. This might be a consequence of diﬃculties
with ﬁnding the correct optimal active set given the critical region.

In Table 1 the result for Problem 1 is seen, and it is clear that the relative
memory reduction becomes increasingly beneﬁcial with the parameter dimen-
sion. For N = 2 and N = 3, the memory is reduced by approximately an order
of magnitude for the parameter dimensions n = 12 and n = 14. The result for
Problem 2 is presented in Table 2, and for this problem the relative memory

Table 1: Experimental results for Problem 1.

n/N
2/2
4/2
6/2
8/2
10/2
12/2
14/2
2/3
4/3
6/3
8/3
10/3
12/3
14/3
2/4
4/4
6/4
8/4
10/4
12/4

p
10
20
28
44
52
66
80
12
24
36
56
66
86
102
14
26
42
66
80
104

R
5
11
45
153
192
255
336
5
13
89
575
1186
1679
2664

5
13
129
1222
4300
5408

D
2
2
2
2
2
2
2
2
3
3
3
3
3
3
2
3
4
4
4
4

∆cr
0.909
0.446
0.258
0.176
0.130
0.107
0.090
0.909
0.476
0.258
0.187
0.139
0.124
0.115
0.909
0.476
0.252
0.207
0.161
0.181

∆

0.729
0.403
0.239
0.167
0.126
0.105
0.088
0.694
0.411
0.234
0.175
0.133
0.119
0.111
0.667
0.400
0.226
0.189
0.151
0.172

∆mpc
0.827
0.431
0.252
0.173
0.129
0.107
0.090
0.827
0.456
0.252
0.184
0.138
0.123
0.114
0.827
0.456
0.246
0.203
0.159
0.179

reduction is an order of magnitude for problems with nM ≥ 6. Table 3 contains
the numerical results for Problem 3, and it can be seen that also for this prob-
lem the relative memory reduction is increased for larger parameter dimensions.
Note that for all evaluated problems the memory required for the storage tree
is lower than for storing the full solution.
7 Conclusions and Future Work
In this paper theory and algorithms for reducing the memory footprint when
storing parametric solutions to mp-qp problems are introduced. This is per-
formed by exploiting low rank structure in the parametric solutions. The struc-
tured changes in the parametric solution between neighboring critical regions
is exploited in a similar way as low rank modiﬁcations is used as a tool to
increase on-line performance in many popular qp methods, but here it is ap-
plied to mp-qp problems to reduce the memory required to store the solutions.
The proposed method stores the solution in a storage tree and can be imple-
mented in already existing solvers for mp-qp problems, or be considered as a
post-processing data compression step. For future work, an extension to other
problem classes such as, e.g., multiparametric linear programming will be in-
vestigated. Furthermore, it will be studied which point location algorithm that
beneﬁts most by using the storage tree introduced in this paper, and also how
to exploit low rank modiﬁcations of, e.g., Cholesky factorizations to improve
the numerical properties.

Table 2: Experimental results for Problem 2.

∆cr
0.392
0.220
0.159
0.131
0.102
0.087
0.082
0.393
0.244
0.169
0.132
0.102
0.086
0.078
0.406
0.275
0.203
0.148
0.111

∆

0.351
0.206
0.153
0.127
0.100
0.086
0.081
0.341
0.222
0.159
0.127
0.100
0.085
0.077
0.336
0.242
0.187
0.140
0.108

∆mpc
0.378
0.217
0.158
0.130
0.102
0.087
0.082
0.379
0.239
0.167
0.131
0.102
0.086
0.078
0.388
0.268
0.200
0.146
0.111

nM /N

2/2
3/2
4/2
5/2
6/2
7/2
8/2
2/3
3/3
4/3
5/3
6/3
7/3
8/3
2/4
3/4
4/4
5/4
6/4

p
28
40
52
64
76
88
100
38
54
70
86
102
118
134
48
68
88
108
128

R
45
161
225
229
238
239
238
127
920
1953
2577
2861
3096
3084
282
2593
9479
18707
24629

D
2
2
2
2
2
2
2
3
3
3
3
3
3
3
4
4
4
4
4

Table 3: Experimental results for Problem 3.

nM /N

2/2
3/2
4/2
5/2
2/3
3/3
4/3
2/4
3/4

p
28
40
52
64
38
54
70
48
68

R
45
161
225
229
127
920
1953
282
2593

D
2
2
2
2
3
3
3
4
4

∆cr
0.392
0.220
0.159
0.131
0.393
0.244
0.169
0.406
0.275

∆

0.351
0.206
0.153
0.127
0.341
0.222
0.159
0.336
0.242

∆mpc
0.378
0.217
0.158
0.130
0.379
0.239
0.167
0.388
0.268

A Appendix
A.1 Linear algebra and deﬁnitions

Consider the symmetric positive deﬁnite matrix

(cid:20)

(cid:21)

.

W w
wT w0

By using the matrix inversion lemma, the inverse of the block matrix is given

by

(cid:20)

(cid:21)−1

(cid:20)

W w
wT w0

=

W −1+W −1wC−1wT W −1 −W −1wC−1

−C−1wT W −1

C−1

where C (cid:44) w0 − wT W −1w ∈ S++.

The matrices in the cftoc problem are deﬁned by

(cid:21)

,

(38)

(39a)

(39b)

(39c)

A

...

 I
 Hx

Anx

0
B
AB


 , B (cid:44)
, Hu (cid:44)

...

...

Hx

A(cid:44)

Hx (cid:44)

 ,
, h (cid:44)

B

Anx−1B Anx−2B ··· B

 Hu

...

Hu

 .

 h

...

h

Qx (cid:44) diag(Qx, ..., Qx, PN ), Qu (cid:44)diag(Qu, ..., Qu),

References
[1] B. Bank, J. Guddat, D. Klatte, B. Kummer, and K. Tammer, Non-linear
parametric optimization, ser. Mathematische Lehrbücher und Monogra-
phien: Mathematische Monographien. Birkhäuser Verlag, 1982.

[2] A. Bemporad, A. Morari, V. Dua, and E. Pistikopoulos, “The explicit linear
quadratic regulator for constrained systems,” Automatica, vol. 38, no. 1, pp.
3 – 20, 2002.

[3] J. Maciejowski, Predictive control with constraints. Prentice Hall, 2002.

[4] H. Jonson, “A Newton method for solving non-linear optimal control prob-
lems with general constraints,” Ph.D. dissertation, Linköpings Tekniska
Högskola, 1983.

[5] C. Rao, S. Wright, and J. Rawlings, “Application of interior-point methods
to model predictive control,” Journal of Optimization Theory and Applica-
tions, vol. 99, no. 3, pp. 723–757, Dec. 1998.

[6] I. Nielsen, D. Ankelhed, and D. Axehill, “Low-rank modiﬁcation of Riccati
factorizations with applications to model predictive control,” in Proceedings
of the 52nd IEEE Conference on Decision and Control, Firenze, Italy, Dec.
2013, pp. 3684–3690.

[7] M. Kvasnica, B. Takács, J. Holaza, and S. D. Cairano, “On region-free ex-
plicit model predictive control,” in Proceedings of the 54th IEEE Conference
on Decision and Control, Osaka, Japan, Dec. 2015, pp. 3669–3674.

[8] P. Tøndel, T. Johansen, and A. Bemporad, “Evaluation of piecewise aﬃne
control via binary search tree,” Automatica, vol. 39, no. 5, pp. 945 – 950,
2003.

[9] A. N. Fuchs, D. Axehill, and M. Morari, “On the choice of the linear decision
functions for point location in polytopic data sets - application to explicit
mpc,” in Proceedings of the 49th IEEE Conference on Decision and Control,
Dec 2010, pp. 5283–5288.

[10] P. Tøndel, T. A. Johansen, and A. Bemporad, “An algorithm for multi-
parametric quadratic programming and explicit MPC solutions,” Automat-
ica, vol. 39, no. 3, pp. 489 – 497, 2003.

[11] A. Gupta, S. Bhartiya, and P. Nataraj, “A novel approach to multipara-
metric quadratic programming,” Automatica, vol. 47, no. 9, pp. 2112–2117,
2011.

[12] C. N. Jones and M. Morrari, “Multiparametric linear complementarity
problems,” in Proceedings of the 45th IEEE Conference on Decision and
Control, Dec 2006, pp. 5687–5692.

[13] F. Borrelli, M. Baotić, J. Pekar, and G. Stewart, “On the computation of
linear model predictive control laws,” Automatica, vol. 46, no. 6, pp. 1035
– 1041, 2010.

[14] J. Nocedal and S. Wright, Numerical Optimization. Springer-Verlag, 2006.

[15] M. Kvasnica, J. Hledík, and M. Fikar, “Reducing the memory footprint of
explicit mpc solutions by partial selection,” in Proceedings of the 51st IEEE
Conference on Decision and Control, Maui, Hawaii, USA, 2012.

[16] M. Herceg, S. Mariethoz, and M. Morari, “Evaluation of piecewise aﬃne
control law via graph traversal,” in Proceeding of the 2013 European Control
Conference, July 2013, pp. 3083–3088.

[17] M. Herceg, M. Kvasnica, C. Jones, and M. Morari, “Multi-Parametric
Toolbox 3.0,” in Proceedings of the European Control Conference, Zürich,
Switzerland, July 17–19 2013, pp. 502–510, http://control.ee.ethz.ch/
~mpt.

[18] Y. Wang and S. Boyd, “Fast model predictive control using online optimiza-
tion,” IEEE Transactions on Control Systems Technology, vol. 18, no. 2,
pp. 267–278, March 2010.

[19] D. Axehill, “Controlling the level of sparsity in MPC,” Systems & Control

Letters, vol. 76, pp. 1–7, 2015.

