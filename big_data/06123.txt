Optimal Lagrange Multipliers for Dependent Rate

1

Allocation in Video Coding

Ana De Abreu Student Member, IEEE, Gene Cheung Senior Member, IEEE, Pascal Frossard Senior

Member, IEEE, Fernando Pereira Fellow, IEEE

6
1
0
2

 
r
a

 

M
9
1

 
 
]

M
M

.
s
c
[
 
 

1
v
3
2
1
6
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

In a typical video rate allocation problem, the objective is to optimally distribute a source rate budget among

a set of (in)dependently coded data units to minimize the total distortion of all units. Conventional Lagrangian

approaches convert the lone rate constraint to a linear rate penalty scaled by a multiplier in the objective, resulting

in a simpler unconstrained formulation. However, the search for the “optimal” multiplier—one that results in a

distortion-minimizing solution among all Lagrangian solutions that satisfy the original rate constraint—remains an

elusive open problem in the general setting.

To address this problem, we propose a computation-efﬁcient search strategy to identify this optimal multiplier

numerically. Speciﬁcally, we ﬁrst formulate a general rate allocation problem where each data unit can be dependently

coded at different quantization parameters (QP) using a previous unit as predictor, or left uncoded at the encoder

and subsequently interpolated at the decoder using neighboring coded units. After converting the original rate-

constrained problem to the unconstrained Lagrangian counterpart, we design an efﬁcient dynamic programming

(DP) algorithm that ﬁnds the optimal Lagrangian solution for a ﬁxed multiplier. Finally, within the DP framework,

we iteratively compute neighboring singular multiplier values, each resulting in multiple simultaneously optimal

Lagrangian solutions, to drive the rates of the computed Lagrangian solutions towards the bit budget. We terminate

when a singular multiplier value results in two Lagrangian solutions with rates below and above the bit budget. In

extensive monoview and multiview video coding experiments, we show that, for ﬁxed target rate constraints, our

DP algorithm and selection of optimal multipliers on average outperform comparable rate control solutions used in

video compression standards such as HEVC that do not skip frames in Y-PSNR.

Lagrangian optimization, video and multiview image coding, rate-distortion (RD) optimization.

Index Terms

A. De Abreu and P. Frossard are with Signal Processing Laboratory (LTS4), Ecole Polytechnique F´ed´erale de Lausanne (EPFL), CH-1015

Lausanne, Switzerland (e-mail: ana.deabreu@epﬂ.ch, pascal.frossard@epﬂ.ch).

G. Cheung is with National Institute of Informatics, 2-1-2, Hitotsubashi, Chiyoda-ku, Tokyo, Japan 101–8430 (e-mail: cheung@nii.ac.jp).
A. De Abreu and F. Pereira are with Instituto Superior T´ecnico - Instituto de Telecomunicac¸ ˜oes (IST-IT), 1049-001, Lisbon, Portugal

(e-mail: fp@lx.it.pt).

I. INTRODUCTION

2

In video coding, rate allocation is the problem of distributing a source bit budget B to a set of (in)dependently
coded data units, v ∈ V o, in order to minimize the distortion of all units. For example, a data unit v can be a
video frame predictively coded at a quantization parameter (QP) qv, using a previous frame as a predictor. Coding

at a larger (coarser) QP requires fewer bits in general but results in a higher quantization distortion. In some

cases, leaving a unit uncoded at the encoder may be a better rate-distortion (RD) decision; the unit is subsequently

interpolated at the decoder using neighboring coded units via techniques such as motion compensated interpolation

(MCI) [1] in monoview video or depth-image based rendering (DIBR) [2, 3] in multiview video when color and

depth maps are available. In these cases, the more general rate allocation problem is to ﬁrst select data units
V ⊆ V o for coding, and then select QPs q = [q1, . . . , q|V|] at which to code the selected units V to minimize the
total distortion D(V, q) subject to a rate constraint R(V, q):

min
V⊆V o,q

D(V, q)

s.t. R(V, q) ≤ B

(1)

To address different variants of the rate allocation problem, Lagrangian approaches—where the lone rate constraint

is ﬁrst converted to a linear rate penalty in the objective scaled by a multiplier λ—are common in the literature

[4–8]. This results in a simpler unconstrained problem:

(Vλ, qλ) = arg min
V⊆V o,q

D(V, q) + λ R(V, q)

(2)

which in general is easier to solve for a ﬁxed multiplier λ [4–8]. However, the Lagrangian relaxed problem (2)

is inherently not the same as the original rate-constrained problem (1); the difference in distortion between their

respective optimal solutions is called a duality gap (see Appendix B and [4]). To minimize this gap, it is imperative

to ﬁnd the “optimal” multiplier λ∗—one that results in a distortion-minimizing solution (Vλ∗, qλ∗) among all
Lagrangian solutions (Vλ, qλ) to (2) for different λ that satisfy R(Vλ, qλ) ≤ B. However, given empirical discrete
rate and distortion functions R(V, q) and D(V, q), the search for this optimal multiplier numerically without
resorting to continuous rate and distortion models [9, 10] remains an open problem in the general setting.

To address this problem, in this paper we propose a computation-efﬁcient search strategy to ﬁnd this optimal

multiplier numerically. Speciﬁcally, we ﬁrst formulate a general rate allocation problem, where each data unit can

be dependently coded at different QPs using a previous coded unit as predictor, or left uncoded at the encoder

for interpolation at the decoder using neighboring coded units as reference. After converting the original rate-

constrained problem to the unconstrained Lagrangian counterpart (2), we design an efﬁcient dynamic programming

(DP) algorithm that ﬁnds the optimal solution to (2) for a ﬁxed λ.

To ﬁnd the optimal multiplier, we iteratively compute neighboring singular multiplier values [4] from the

3

λ , q

λ , q

(1)

λ ) (cid:54)= R(V (2)

computed DP solution; each singular value λ results in multiple simultaneously optimal solutions with different
rates, i.e. R(V (1)
(2)
λ ). We show that singular values alone lead to all Lagrangian solutions
λ∗ ) corresponding to singular value λ∗ with rates
to (2). When we obtain solutions (V (1)
λ∗ , q
R(V (1)
(1)
λ∗ ) is the distortion-minimizing Lagrangian solution, and
declare λ∗ as the optimal multiplier. To the best of our knowledge, no previously proposed Lagrangian multiplier
searches [4–8] provide this theoretical claim in our general setting1.

λ∗ ) and (V (2)
λ∗ , q

λ∗ ), we prove that (V (1)

λ∗ , q

λ∗ , q

(1)

λ∗ ) ≤ B ≤ R(V (2)

λ∗ , q

(2)

(1)

(2)

Experimental results illustrate good performance of our proposed rate allocation algorithm with optimal Lagrange

multiplier selection when data units are independently or predictively coded in both monoview and multiview video

sequence compression. Speciﬁcally, we show that our bit allocation strategy on average outperforms comparable rate

control solutions adopted in the reference softwares of current monoview and multiview video standards, namely

HEVC [11] and 3D-HEVC [12], that do not skip frames in Y-PSNR.

The paper is organized as follows. We ﬁrst review related work in Section II and formulate our dependent rate

allocation problem in Section III. We then describe a DP algorithm that solves the rate-constrained problem optimally

but in exponential time in Section IV. To reduce complexity, we convert the problem to the Lagrangian relaxed

version and propose a corresponding polynomial-time DP algorithm for a ﬁxed multiplier. In Section V, we discuss

an efﬁcient search methodology to identify the optimal multiplier based on the computation of neighboring singular

multiplier values. Finally, we present experimental results and conclusion in Section VI and VII, respectively.

A. Continuous RD Function Modeling

II. RELATED WORK

A simple approach to obtain rate and distortion functions is to apply different QPs to encode each data unit

and compute the resulting rate and distortion values. Then, these empirical RD points are ﬁtted into mathematical

functions for each particular sequence to derive an RD model [13, 14]. However, in these type of models some

parameters have to be estimated for each given video sequence and therefore they cannot be easily generalized.

Alternatively, it is possible to theoretically derive the different parameters of the RD model under simplifying

assumptions. Several RD models using well understood exponential functions have been proposed [9, 10]. [9]

considered both a Laplacian and a Generalized Gaussian (GG) distribution in their RD model for a wavelet video

coding. [10] adopted the Bernoulli Generalized Gaussian (BGG) model for both rate and distortion functions. In

general, these approaches suffer from: i) modeling errors due to idealized model inaccuracy; and ii) continuous

approximation error since the problem (selecting QPs from a ﬁnite set) is inherently discrete. In contrast, we take

an empirical approach and solve the inherent discrete problem of selecting data units and QPs for coding directly,

and thus do not suffer from modeling errors.

1 [4] was a seminal bit allocation work and proposed the ﬁrst singular value search strategy but only for independently coded data units.

4

B. Constrained Formulation via Dynamic Programming

Addressing directly the discrete rate-constrained bit allocation problem, one common approach is DP. For example,

assuming independently coded data units, [15] constructed a tree to represent all possible solutions: a node at a stage
i of the tree represents a particular selection of QPs {q1, . . . , qi} for data unit 1 to i. If two different nodes at the
same stage i have the same accumulated rate from unit 1 to i, then the one with the larger accumulated distortion

would be pruned. As we will show in Section III, the complexity of this type of DP algorithms is pseudo-polynomial

or exponential time. If predictive coding is assumed, complexity is even higher.

To jointly select predictor frames and QoS levels for encoding and protection of different video frames during

network streaming, [16] proposed an integer rounding approach to reduce complexity of a DP algorithm, where

DP tables used to store computed local solutions were scaled down to reduce the number of table entries. The

authors derived a performance bound for the proposed reduced-complexity DP algorithm; however, this bound gets

progressively worse as the scale factor increases.

For multiview, assuming independently coded units, [17] considered a uniform rate allocation among views in

a multiview video system, and proposed a DP-based algorithm to select the views for encoding and transmission

such that the expected distortion among encoded and synthesized views is minimized given a rate budget. This

work is extended in [18] where both the views and the coding rates for each selected view are selected to minimize

distortion in a rate-constrained scenario. Due to high complexity, a greedy DP algorithm was proposed. There is

no performance guarantee for the greedy DP algorithm, however, and thus the obtained solution can be arbitrarily

far from the optimal solution.

C. Discrete Lagrangian Formulation

Instead of the originally posed rate-constrained bit allocation problems, the Lagrangian approach is often used.

[5] proposed a trellis-based algorithm to ﬁnd the optimal Lagrangian solution for predictively coded frames in
traditional monoview video. A suitable Lagrange multiplier was found by sweeping from 0 to ∞; it is not clear
how this can be done efﬁciently, and what is the termination condition when a sufﬁciently good multiplier value

is found. [19] also adopted a Lagrangian approach, where the value of the Lagrange multiplier λ is empirically

modeled as a function of the rate and the distortion when data units are predictively encoded. There is no guarantee

that this ad-hoc approach will result in the optimal multiplier value upon termination, however.

To allocate bits among independent quantizers, [4] deﬁned the notion of singular multiplier values—multipliers

with multiple simultaneously optimal Lagrangian solutions—and proposed to iteratively search through neighboring

singular multiplier values until a terminating condition (resulting rates of Lagangian solutions being very close to bit

budget) is met. Extending [4], [20] addressed a similar rate allocation problem with two rate constraints, also using

the notion of singular values, in order to achieve an optimal distribution of source and channel bits among wavelet

subbands for transmission of scalable video over noisy channels. Our algorithm adopts the singular multiplier value

concept [4] and extends it to the case where data units can be predictively coded or left uncoded entirely for

5

subsequent interpolation at the decoder.

D. Multiview Rate Allocation

Rate allocation problems have also been investigated recently in multiview video coding applications. [7] extended

the trellis optimization approach in [5] to multiview video with predictive coding. The authors considered a system

where views can be skipped at the encoder and eventually synthesized using both texture and depth maps at the

decoder, and optimized only QPs of the texture maps. In a different framework, [8] tackled the bit allocation

problem for both texture and depth data such that the distortion of the camera views and a set of synthetic views,

reconstructed at the decoder, is minimized. The authors optimized both the set of coded views and their QPs and

adopted a trellis-based solution for an effective search of the optimal coding solution. Both [7] and [8] employed

the Lagrangian approach, but no mathematically rigorous strategy was proposed to search for a suitable multiplier

value. We will show that our proposal can be applied to multiview coding scenarios also.

III. RATE ALLOCATION FRAMEWORK

In a classical rate allocation problem, the objective is to minimize the total distortion of a set of data units, each of

which may be independently or predictively coded, subject to a rate budget constraint. We ﬁrst describe the general

coding system under consideration. Then, we formulate a rate-constrained bit allocation problem for predictively

coded data units as a discrete optimization problem. We present examples that show how our formulation can be

applicable in different practical scenarios. Finally, we prove that the formulated problem is NP-hard.

A. System Model

We consider a general coding scenario where we seek to allocate a total bit budget B to an ordered set of V
data units, V o = {1, 2, . . . , V }. Examples include consecutive frames in monoview video, or neighboring views in
a multiview image sequence. We deﬁne V = {v1, v2,··· , vN}, where V ⊆ V o, as the subset of N units selected
for coding, where N ≤ V . We assume that a unit v can be left uncoded at the encoder, and later interpolated at the
decoder using the two surrounding coded units vL and vR, where vL < v < vR and vL, vR ∈ V. As the boundary
units cannot be interpolated at the decoder in the same manner, they are always selected for coding, i.e., v1 = 1

and vN = V are always coded.

Each unit vn ∈ V selected is coded using a QP qvn ∈ Q, where Q is a discrete set of possible QPs for a
given encoder. Denote by qV the set of chosen QPs for the units in V. Assuming that predictive coding is used

6

to code neighboring units, unit vn coded with QP qvn using as predictor unit vn−1 coded with QP qvn−1 has
a rate rvn(vn−1, qvn−1, qvn) and a distortion ∆vn(vn−1, qvn−1, qvn). Note that if vn−1 and vn are not consecutive
data units in V o, then the uncoded intermediate units between coded vn−1 and vn that are interpolated at the
decoder must be included in the distortion computation. Hence distortion term ∆vn(vn−1, qvn−1, qvn) accounts for
the distortion of all interpolated units in the range (vn−1, vn) and the distortion of the coded unit vn. Mathematically,
∆vn(vn−1, qvn−1, qvn) can be written as:

∆vn(vn−1, qvn−1, qvn) =

dv(vn−1, vn, qvn−1, qvn)

(3)

(cid:88)

v∈V o

vn−1<v≤vn
qvn−1 ,qvn∈Q

where dv(.) is the distortion of unit v, v ∈ V o, interpolated using reference units vn−1 and vn coded using QPs
qvn−1 and qvn, respectively. If v = vn, then dv(.) corresponds to the distortion of coded unit vn using vn−1 for
prediction.

The ﬁrst unit v1 in V is independently encoded and its distortion depends only on its own QP. For this particular

case, Eq. (3) can be re-written as:

∆v1(qv1) = dv1(qv1)

(4)

More general deﬁnitions for predictive coding is also possible [5], where the rate and distortion functions depend

on the QPs of all previous coded data units. However, for complexity reasons, we assume that rate rvn and distortion
∆vn depend only on QP qvn−1 of previous unit vn−1 used for prediction. This is a good approximation in practical
predictive coding, as shown in [8].

B. Problem Formulation

With the above deﬁnitions, our objective is to ﬁnd the optimal subset of data units V

along with their corresponding QPs q∗
minimized, subject to a bit budget constraint B. The optimization problem can be deﬁned as follows:

∗ = {v1, v2,··· , vN} ⊆ V o
V = [qv1, qv2,··· , qvN ] such that the aggregate distortion at the decoder is

|V|(cid:88)

n=2

∆v1(qv1) +

∆vn(vn−1, qvn−1, qvn)

∗

, q

(V

∗
V ) = arg minV⊆V o
qvn∈Q

s.t. rv1(qv1) +

|V|(cid:88)

n=2

rvn(vn−1, qvn−1, qvn) ≤ B

(5)

where ∆v1(qv1) and rv1(qv1) are the distortion and rate for the ﬁrst selected unit v1, and ∆vn(.) and rvn(.) are the
distortion and rate for a predictively coded unit vn, as described above.

7

C. Applications

Our formulation in (5) is sufﬁciently general for application to different monoview and multiview video rate

allocation scenarios. We list a few illustrative examples below.

• Scenario I: QP selection for independent coded images. If frames in a monoview video or views in a multiview

image sequence are independently coded for maximum random access [4], then our formulation (5) is applicable

to optimal selection of QPs, where the rate and distortion of each data unit (image) do not depend on the
previous one, i.e., rvn(vn−1, qvn−1, qvn) = rvn(qvn) and ∆vn(vn−1, qvn−1, qvn) = dvn(qvn).

• Scenario II: QP selection for differentially coded images. If each frame in monoview video or view in a

multiview image sequence is differentially coded using a previous predictor frame, then (5) can be used,
where all units in V o are chosen for coding, for optimal selection of QPs [5, 8]. Note that (5) is not applicable
to bi-directional prediction like B-frames.

• Scenario III: Selection of images for coding. If a consistent quality requirement dictates that all images should

be coded at the same pre-deﬁned QP [17], (5) can be used to select a subset of images in monoview video

or views in a multiview image sequence to minimize aggregate distortion that includes interpolated images at

the decoder.

• Scenario IV: Mode selection in a Group of Blocks. Instead of images, data units can represent code blocks in

an image. Given a ﬁxed QP, (5) can be used to select the optimal coding modes for a group of block (GoB)
for a given rate constraint, where Q now represents possible modes a block can take on [21, 22].

D. NP-Hardness Proof

We prove that our formulated bit allocation problem (5) is NP-hard via reduction from a well-known NP-hard

problem—Knapsack (KS) [23]. The binary decision version of KS, which is NP-complete, can be described as

follows:

Binary Decision Problem of KS – Given a set of M items, each with non-negative weight wm and proﬁt cm, and
a knapsack of capacity W , does there exist a subset of items with total weight ≤ W , such that the total proﬁt is
at least ¯C?

To prove NP-hardness of (5), we consider a more speciﬁc problem where each unit v, if chosen for coding, can

only be independently coded at QP q. We reduce the binary decision version of this simpliﬁed problem from the

KS decision problem as follows. First, we construct two boundary units v0 and vM +1 and M intermediate data

units corresponding to M items in KS. The distortion of not coding any intermediate unit is D no matter what

surrounding units are used as reference for interpolation. Coding the two boundary units at QP q results in rate
2 and distortion 0. Coding an intermediate unit v at QP q results in rate wv and distortion D − cv. The binary

8

decision problem is: does there exist a subset V of units selected for coding (each at QP q) such that the distortion
is no larger than M D − ¯C, given a rate budget W + 2? If the answer is yes, then the chosen subset V of units
in the solution, excluding the two boundary units, has a corresponding subset of items in KS with total weight no

larger than W and total proﬁt at least ¯C. Hence the problem is no easier than the KS decision problem, and thus

is also NP-complete. Therefore the optimization version of the problem is NP-hard. Since the speciﬁc problem is

already NP-hard, the more general problem (5) is no easier, and hence is also NP-hard.

IV. DP ALGORITHM FOR LAGRANGIAN PROBLEM

We ﬁrst present an algorithm based on DP that returns an optimal solution to the constrained problem in (5). We

then show that the algorithm complexity is exponential. Next, we present an alternative DP algorithm that solves

the corresponding Lagrangian relaxed problem in polynomial time for a ﬁxed Lagrangian multiplier.

A. Constrained DP Algorithm

To solve the problem in (5) optimally, we derive a DP algorithm that recursively divides the original problem

into smaller sub-problems. When a sub-problem is solved, its solution is stored inside an entry in a DP table, so

that subsequent calls to the same sub-problem can simply look up the solved solution in the table [24].

Denote by Φvn(qvn, ¯B) the minimum distortion sum for data units from vn + 1 to V , given that vn is coded
with QP qvn, and there is an available bit budget of ¯B, ¯B ≤ B, to code the remaining units vn+1, . . . , vN . This
distortion sum Φvn(qvn, ¯B) can be recursively written as:

Φvn (qvn , ¯B) =

min

vn+1∈Vo | vn+1>vn

qvn+1∈Q

∆vn+1(vn, qvn, qvn+1)

+ 1(vn+1 < V ) Φvn+1(qvn+1, ¯B − rvn+1(vn, qvn , qvn+1))

(6)

where 1(c) is an indicator function that returns 1 if the clause c is true, and 0 otherwise.

In words, (6) selects the next unit vn+1 to code at QP qvn+1, resulting in distortion ∆vn+1(vn, qvn, qvn+1) for data
units from vn +1 to vn+1 inclusively. This selection means that the bit budget is reduced to ¯B−rvn+1(vn, qvn, qvn+1)
for coding of the remaining units. If vn+1 = V , meaning it is the right boundary unit in V o, then the recursive
term in (6) is not necessary.

Since the ﬁrst unit v1 = 1 is always selected for coding, the computation in (6) can be solved via the following

initial call:

q1∈Q ∆1(q1) + Φ1(q1, B − r1(q1)),
min

(7)

The complexity of the DP algorithm is bounded by the size of the DP table multiplied by the complexity of

computing each entry: O(V 2Q2B). This is polynomial in B, but B is encoded in log2(B) bits as input to the
algorithm, and thus the algorithm is exponential in the size of the input. The complexity is also called pseudo-

9

polynomial time in the complexity literature [25].

B. Lagrangian DP Algorithm

To reduce the complexity of the constrained DP algorithm in (6), we seek to eliminate the rate dimension B

in the DP table. Towards that goal, we consider a Lagrangian relaxation of our constrained problem in (5), where

we move the rate consideration from the constraint to the objective function, resulting in a rate-distortion (RD)

formulation:

∗

, q

(V

|V|(cid:88)

n=2

∗
V ) = arg minV⊆V o
qvn∈Q

rv1(qv1) +

|V|(cid:88)

n=2

∆v1(qv1) +

∆vn(vn−1, qvn−1, qvn)



+ λ

rvn(vn−1, qvn−1, qvn)

(8)

where the multiplier λ > 0 is a parameter that weighs the importance of rate against distortion.

To solve (8) for a given λ, we follow a similar procedure. We ﬁrst denote Φvn(qvn) as the minimum RD cost for
data units from vn + 1 to V inclusively, given that vn is coded with QP qvn. Φvn(qvn) can be deﬁned recursively
as:

Φvn(qvn) =

vn+1∈Vo | vn+1>vn

min
qvn+1∈Q

∆vn+1(vn, qvn, qvn+1)

+ λ rvn+1(vn, qvn, qvn+1) + 1(vn+1 < V ) Φvn+1(qvn+1)

(9)

Similar analysis as done for the contrained DP algorithm can show that, for a given λ, the algorithm (9) has

complexity O(V 2Q2), which is polynomial time.

We now discuss the relationship between the constrained problem in (5), solvable via (6), and its Lagrangian
relaxed version in (8), solvable via (9). Denote by (Vλ, qλ) an optimal solution of (8) for a given λ, with resulting
distortion and rate D(Vλ, qλ) and R(Vλ, qλ), respectively. One can show that, if there exists a multiplier λ∗ such
that R(Vλ∗, qλ∗) = B, then solution (Vλ∗, qλ∗) is also an optimal solution of (5). The proof is given in Appendix
VII-A for the sake of completeness.

Because R(Vλ, qλ) is discrete, there may not exist a multiplier λ such that R(Vλ, qλ) = B. In this case, we can
pick a value λ = λ1 with a corresponding Lagrangian solution (Vλ1, qλ1), R(Vλ1, qλ1) < B, as an approximate
solution to (5) with the following performance bound. Given two solutions of (8) (Vλ1, qλ1) and (Vλ2, qλ2), using

10

respective multipliers λ1 and λ2, with resulting rates R(Vλ1, qλ1) < B < R(Vλ2, qλ2), the difference in distortion
between Lagrangian solution (Vλ1, qλ1) and the true optimal solution (V o, qo) of (5) is bounded as:

|D(Vλ1, qλ1) − D(V o, qo)| ≤ |D(Vλ1, qλ1) − D(Vλ2, qλ2)|

(10)

The proof is given in Appendix VII-B. Clearly, the bound in (10) is tightest when the difference in distortion

between the two Lagrangian solutions is the smallest. We propose an efﬁcient algorithm to ﬁnd Lagrange multipliers

such that the resulting Lagrangian optimal solutions yield the tightest bound possible with respect to the original

constrained problem.

V. SEARCH FOR THE OPTIMAL LAGRANGE MULTIPLIER

We propose a methodology to identify the “optimal” Lagrange multiplier value via an iterative search. By

“optimal”, we mean a multiplier value that yields a pair of Lagrangian optimal solutions to (8) with the tightest

distortion bound (10) possible with respect to the true optimal solution in (5). We ﬁrst review the notion of singular

value of Lagrange multiplier, introduced in the context of rate allocation problems in [4]. We then discuss our

methodology in the following two subsections (neighboring singular value computation and initialization).

A. Singular Values of Lagrange Multiplier

We ﬁrst observe that because rate R(Vλ, qλ) is discrete, there are distinct λ values at which the optimal solutions
to (8) are not unique; these are called singular values of Lagrange multiplier [4]. As an example, in Fig. 2 where
rate R(Vλ, qλ) of optimal solutions (Vλ, qλ) to (8) is plotted against multiplier λ, we see that at singular value λ1,
).
there are two simultaneous optimal solutions to (8), resulting in two different rates R(V l
Singular multiplier values have two important properties:

) and R(V u

, ql
λ1

, qu
λ1

λ1

λ1

1) Two neighboring singular values share one common optimal solution to (8).

2) Multipliers λ between two neighboring singular values produce the same optimal solution as the shared solution

of the two singular values.

Fig. 1. Rate R(Vλ, qλ) of optimal solution (Vλ, qλ) to (8) as function of multiplier λ. Singular values are λ2, λ∗, λ1, λ0, etc. The singular
value λ∗ produces a pair of Lagrangian solutions (V l
λ∗ ) with the tightest distortion bound (10) with respect to the
optimal solution in (5) with rate constraint B.

λ∗ ) and (V u

λ∗ , qu

λ∗ , ql

 R(V ,q ) 1 2 ⇤ 0R(Vu 1,qu 1)=R(Vl 1,ql 1)R(Vl ⇤,ql ⇤)BR(Vu ⇤,qu ⇤)These two properties are discussed extensively in [4]. As an example, in Fig. 2 neighboring singular values λ∗ and
λ1 share an optimal solution (V l
λ∗) to (8), and multipliers λ between these two singular values will produce the
same optimal solution. These two properties imply the following important corollary: singular values alone produce
all solutions to (8) as λ varies from 0 to ∞. Thus, it is sufﬁcient to examine only Lagrangian solutions of singular
values in order to ﬁnd the best multiplier value.

λ∗, ql

11

λ∗, ql

λ∗, ql

Moreover, it is known [4] that rate R(Vλ, qλ) is monotonically non-increasing with respect to λ as shown in Fig.
2. Suppose now that a singular value λ∗ has corresponding optimal Lagrangian solutions (V l
λ∗, qu
λ∗)
where R(V l
λ∗). That means that any other singular value will yield Lagrangian solutions
with rates either smaller or larger than this pair of solutions due to monotonicity of rate R(Vλ, qλ). Thus this pair
of solutions (V l
λ∗) are the Lagrangian solutions that produce the tightest distortion bound (10)
possible, and λ∗ is the optimal Lagrange multiplier value.

λ∗) ≤ B ≤ R(V u

λ∗) and (V u

λ∗) and (V u

λ∗, qu

λ∗, qu

λ∗, ql

Procedurally, monotonicity also means that in an iterative search for the optimal singular value λ∗, one only
needs to increase / decrease the current λ by examining the rate of the corresponding optimal solution: decrease λ
if R(Vλ, qλ) < B and increase it otherwise.

B. Procedure to compute Neighboring Singular Values

One strategy to search for the optimal singular value is to march through neighboring singular values in the

λ∗, qu

direction of bit budget B until the pair of optimal solutions to (8) corresponding to singular value λ∗, (V l
λ∗)
and (V u
λ∗). For example, in Fig. 2, after testing λ0 then
λ1 successively, we arrive at the optimal singular value λ∗. Thus the challenge is how to compute a neighboring
singular Lagrangian value in the direction of B. We accomplish this by storing auxiliary information as the DP

λ∗), have rates satisfying R(V l

λ∗) ≤ B ≤ R(V u

λ∗, qu

λ∗, ql

λ∗, ql

algorithm (9) is computed for a ﬁxed multiplier λ, in order to identify a neighboring optimal solution to (8) if λ

is increased / decreased appropriately.

Speciﬁcally, we compute a neighboring singular multiplier value within the same DP framework (9) developed

n+1, q∗

to solve (8) as follows. Denote by (v∗
a given λ. Further, denote by Ψvn(qvn) and Υvn(qvn) the distortion and rate of the optimal solution (v∗
vn+1)
to sub-problem Φvn(qvn) respectively. Ψvn(qvn) and Υvn(qvn) can be computed and stored in DP tables as (9) is
being solved recursively; speciﬁcally, they are computed as:

vn+1) the argument that minimizes the sub-problem Φvn(qvn) in (9) for

n+1, q∗

Ψvn(qvn) = ∆v∗n+1(vn, qvn, qv∗n+1) + Ψv∗n+1(qv∗n+1)

Υvn(qvn) = rv∗n+1(vn, qvn, qv∗n+1) + Υv∗n+1(qv∗n+1)

(11)

(12)

12

1) Computing a smaller Singular Value: Suppose ﬁrst that R(Vλ, qλ) < B, and we need to decrease λ in order
to increase R(Vλ, qλ). To ﬁnd the neighboring smaller singular value λ−, where λ− < λ, we know that λ− and λ
share an optimal solution (Vλ, qλ), and that λ− has an additional solution with rate larger than R(Vλ, qλ). This
additional globally optimal solution (Vλ−, qλ−) must contain a new local solution of a sub-problem Φvn(qvn) as λ
decreases. Thus, we seek the closest multiplier λ− to λ, λ− < λ, where there exists a sub-problem Φvn(qvn) with
a new local solution (v
vn+1).

vn+1) whose rate R(v

−
n+1, q−

−
n+1, q−

vn+1) is larger than the previous solution’s R(v∗
vn(qvn), where λ−

n+1, q∗
vn(qvn) <

In particular, for each sub-problem Φvn(qvn) we compute a singular value candidate λ−

λ, as:

λ

−
vn(qvn) = max
v∈V o
v>vn
qv∈Q

Ψvn(qvn) − (∆v(vn, qvn, qv) + Ψv(qv))
(rv(vn, qvn, qv) + Υv(qv)) − Υvn(qvn)

(13)

where the search for the maximization is performed over the set of units and QPs, (v, qv), with a larger resulting

rate:

rv(vn, qvn, qv) + Υv(qv) > Υvn(qvn)

(14)

In other words, λ−

vn(qvn) is the closest multiplier value smaller than λ where the sub-problem Φvn(qvn) results
in a different solution with a larger rate. Geometrically, (13) is computing an RD point on the convex hull to the
right of (v∗

vn+1) with a larger rate. See Fig. 2.

n+1, q∗

The emergence of a new globally optimal solution (Vλ−, qλ−) can stem from any sub-problem Φvn(qvn) as λ
decreases. To identify the ﬁrst sub-problem Φvn(qvn) that results in a new local solution, we compute λ− as the
largest (closest to λ) of all singular value candidates λ−

vn(qvn):

Denote by (v−

n , q−

vn) the argument that maximizes (15). Further, denote by (v

−

λ

=

max

vn∈V o,qvn∈Q λ

−
vn(qvn)

(15)

−
n+1, q−

vn+1) the argument that maximizes

Fig. 2.
(v, qv) with larger rates than current optimal solution (v∗

Illustration of the search of singular value candidate λ−
n+1, q∗

vn (qvn ) for the Φvn (qvn ) sub-problem. The search is done over the points
vn+1 ) (blue region).

(13) for sub-problem Φv−n (q−
solutions.

vn). We show that using λ−, sub-problem Φv−n (q−

vn) has two simultaneously optimal

Lemma 1: Using singular value λ−, sub-problem Φv−n (q−

vn) has two solutions, (v∗

n+1, q∗

vn+1) and (v

−
n+1, q−

vn+1),

that are simultaneously optimal.

13

n , q−

n+1, q∗

−
v−n

Proof: First, because λ− is the largest among all singular value candidates, when multiplier is λ−, sub-problems
vn) still have the same optimal solutions as before when multiplier was λ. This means that except
vn), distortions Ψvn(qvn) and rates Υvn(qvn) for all sub-problems remain the same when multiplier is λ−.
vn+1), optimality of
vn+1) remains smaller than these candidates
(qv−n ) in (13) implies that RD costs
vn+1) are neighboring
n+1, q∗
vn+1), must result

other than Φv−n (q−
for (v−
Consider now sub-problem Φv−n (q−
(v∗
n+1, q∗
(v, qv) when multiplier is now smaller. One can then show that the deﬁnition λ
n+1, q∗
of (v∗
convex-hull points, candidates (v, qv) different from (v
−
in a larger RD cost than (v∗
n+1, q−

vn+1) when multiplier is λ means that the RD cost of (v∗

−
n+1, q−
vn+1) with rates larger than (v∗

vn+1) and (v

vn). For candidates (v, qv) with rates smaller than (v∗

vn+1) are the same. Finally, because (v∗

vn+1) when multiplier is λ−.

n+1, q∗

vn+1) and (v

−
n+1, q−

n+1, q∗

vn+1) and (v

−
n+1, q−

n+1, q∗

We note that the computed λ− in (15) only guarantees that a new local solution has emerged from a sub-problem
Φvn(qvn). The globally optimal solution will not change if the changed sub-problem Φvn(qvn) is not part of the
global solution. However, successive moves to λ− will eventually trigger a change in the global solution, resulting
in a new rate R(Vλ, qλ).

2) Computing a larger Singular Value: Similarly, we can compute the neighboring singular value larger than λ.

The singular value candidate λ+

vn(qvn) larger than λ for each sub-problem Φvn(qvn) is computed as:

λ+
vn(qvn) = min
v∈V o
v>vn
qv∈Q

(∆v(vn, qvn, qv) + Ψv(qv)) − Ψvn(qvn)
Υvn(qvn) − (rv(vn, qvn, qv) + Υv(qv))

(16)

where the search for the minimization is performed over the set of units v and QPs qv with a smaller resulting

rate:

Υvn(qvn) > rv(vn, qvn, qv) + Υv(qv)

Then, the singular value λ+ is the smallest of all singular value candidates λ+

vn(qvn):

λ+ =

vn∈V o,qvn∈Q λ+

min

vn(qvn)

(17)

(18)

3) DP Table Update: From (15) and (18), we know that, given an initial λ value, the neighboring smaller (λ−) or
larger singular value (λ+) can be found with their corresponding solutions using (9). The decision of which direction
we should march to ﬁnd the next singular value is determined by the rate of the computed solution R(Vλ, qλ).

14

Then, we use (9) to update entries in the DP table given new multiplier λ− or λ+. Note that only a subset of
DP table entries need to be updated. Speciﬁcally, since in (9) only candidates (vn+1, qvn+1) where vn+1 > vn are
considered, given a new singular value λ− or λ+ associated with sub-problem Φv−n (qv−n ) or Φv+
n ), only DP
entries (v, q), v < v−
n , require updates using (9). This further reduces the complexity of our algorithm.
4) Complexity Analysis: Computing (13) or (16) for each sub-problem Φv−n (qv−n ) or Φv+
n ) has complexity
O(V Q). There are O(V Q) sub-problems, and hence computing λ− or λ+ is O(V 2Q2). Denote by m the number of
iterations until the optimal singular multiplier value is found. Thus the multiplier search complexity is O(mV 2Q2).
The number of iterations depends on how far from the optimal multiplier is the initial λ value. To reduce the

n or v < v+

n (qv+

n (qv+

number of iterations, we propose a hybrid coarse- / ﬁne-grained multiplier search strategy. First, we perform a

non-singular-value binary search, as done in [4], to produce big changes in λ to approach the optimal multiplier.

When binary search fails to yield new solutions, we apply our ﬁne-grained singular-value search until the optimal
multiplier value is found. The search strategy for the best multiplier λ∗ is summarized in Algorithm 1.

Algorithm 1 Search of the optimal Lagrange multiplier
1: Initialize λ
2: Coarse-grained search: Perform a binary search of λ until no new solutions can be reached.
3: Fine-grained search:
4: Solve (8) via (9) with unique solution R(Vλ, qλ).
5: if R(Vλ, qλ) < B then
Find singular value λ− via (15), with λ− < λ.
6:
λ ← λ−
7:
8: else
Find singular value λ+ via (18), with λ+ > λ.
9:
λ ← λ+
10:
11: end if
12: repeat
13:
14:
15:
16:
17:
18:
19:
20:
21:

λ , qu
λ , qu
Find singular value λ− via (15), with λ− < λ.
λ ← λ−
Find singular value λ+ via (18), with λ+ > λ.
λ ← λ+
λ, ql

else if ¯B < R(V l

λ) < R(V u

Update the DP entries (vj, qvj ) that needs to be modiﬁed, vj < v, when v is associated to λ.
Find simultaneous solutions (V l
if R(V u

λ), where R(V l

λ) and (V u

λ) < ¯B then

λ) then

λ).
λ , qu

λ, ql

λ, ql

λ, ql

end if
22: until R(V l
23: (V l

λ, ql

λ) ≤ ¯B ≤ R(V u

λ , qu
λ)

λ) is the best approximate Lagrangian solution.

15

A. Experimental Setup

VI. EXPERIMENTAL RESULTS

We now demonstrate the performance of our proposed rate allocation algorithm (9) with optimal Lagrange

multiplier selection in monoview and multiview video coding problems. Each data unit represents a full frame in a
monoview video or a view in a multiview video. We consider the monoview video datasets Hall Monitor (352 ×
288, 30fps) [26, 27] and Kimono (1920 × 1080, 24fps), provided by Nakajima Laboratory of the Tokyo Institute of
Technology. Both sequences have a GOP size of 1s, namely 30 frames and 24 frames, respectively. Our algorithm

is used to select frames and corresponding QPs for coding in each GOP.

For the multiview video datasets, we use three sequences: Shark (1920 × 1088, 30fps, 9 views), provided by
NICT for MPEG FTV standardization [28], Undo Dancer (1920 × 1088, 25fps, 5 views) [29] and Soccer Linear2
(1600 × 1200, 60fps, 7 views) [30]. We used a GOP size of 8 frames and an intra-period of 24 frames as deﬁned
under the common test conditions by JCT-3V [31]. Our algorithm is used to select the views to be encoded and their

corresponding QPs; hierarchical B-frames [32] are used in the temporal dimension to exploit temporal redundancy

as done in the standard. A cascading quantization parameter (CQP) strategy [33] is used to assign the QPs to the

frames in the GOPs, where a ∆QP is added to the QP value of the anchor frame to generate the QP values of the
various frames in the GOP. We consider a ∆QP vector equal to {0, 1, 2, 3, 4, 4, 3, 4} for the successive frames in
the GOP, as suggested in the reference software of 3D-HEVC [34].

Since each view consists of a texture and a depth image pair, we use our algorithm to select image pairs for

coding and QPs for the texture images only, while QPs for the depth images are ﬁxed at 30, so that 3D geometry

information are coded accurately for high-quality virtual view synthesis. While QPs for texture and depth images

can be jointly selected for optimal RD performance as done in [8] for static multiview image sequences, in practice

depth images represent only a small fraction of the total bitrate (about 10%), and we optimize only texture image

QPs. We note that extension of our optimization to include selection of multiple QPs for a given data unit is

relatively straightforward and is left for future work.

In our experiments, we compute PSNR of the luminance component (Y-PSNR) for all the decoder-side data units

that are decoded or interpolated if they are left uncoded at the encoder. In particular, to reconstruct uncoded frames

in monoview video sequences we use a popular temporal up-sampling method based on motion estimation [35, 36].

To construct missing views in multiview video sequences, we use a simple depth-image based rendering (DIBR)

[37, 38] method at the decoder where the color pixels from the closest right and left coded views are projected to

the missing intermediate view given per-pixel disparity information provided by the corresponding depth images.

For comparison, we evaluate the performance of the rate control (RC) schemes [11, 12] adopted by the reference

software HM 15.0 [39] of the High Efﬁciency Video Coding (HEVC) standard [32] for monoview video sequences,

16

and by the reference software HTM 13.0 [34] of the 3D extension of HEVC (3D-HEVC) [40] for multiview video.

These solutions only optimize QPs of different frames and do not skip data units at the encoder. For fairness, we

also ﬁx QP of the depth images when RC schemes of the reference software for 3D-HEVC is evaluated, so that

only QPs of the texture images of the multiview video sequences are optimized.

In the following, the performance of our algorithm is illustrated for monoview and multiview video sequences

in two scenarios: (i) when data units are independently coded and (ii) when data units are predictively coded.

B. Independent Coding

We ﬁrst evaluate the performance of competing RC schemes for the case of independently encoded units for
monoview and multiview video sequences. The available set of QPs for the coding units are Q = {25, 26, . . . , 51}
for both cases.

To examine the behaviour of our algorithm, we show in Fig. 3 the relationship between the rate R(Vλ, qλ) of
optimal Lagrangian solutions and Lagrange multiplier λ for the multiview sequences Shark and Undo Dancer.

In particular, we illustrate the iterative multiplier search process to identify, among all Lagrangian solutions to

(8) for any λ, one that minimizes the aggregate distortion subject to a rate budget, which in this case is B =

200kbps. Multiplier λ is initialized to be λ = 0.7 and λ = 0.4 for for the two sequences Shark and Undo Dancer
respectively. The optimal solution (Vλ, qλ) is reached in these two cases at singular value λ = 0.1193 for Shark
(R(Vλ, qλ) = 196.26) and at singular value λ = 0.0673 for Undo Dancer (R(Vλ, qλ) = 199.15). Using (10), the
distortion bound for each sequence can be computed using the two simultaneously optimal solutions at the optimal

singular value, which is 0.01 dB and 0.03 dB for Shark and Undo Dancer, respectively. This shows in practice
that the R(Vλ, qλ) versus multiplier λ plot is dense with samples (i.e., the RD plots of Φvn(qvn) are in general
convex), and the resulting distortion bounds are tight.

To visualize a particular solution, we compare the QP selection for each selected data unit, obtained as the best

solution of our algorithm, to the QP adaptation solution of the RC of HEVC. In Fig. 4a, we show the solutions

for one GOP (from frame 15 to 44) of the Hall Monitor monoview sequence. For these results, we consider a rate

budget of 500kbps, and our algorithm achieves a rate of 490.60kbps and the RC of HEVC a rate of 499.53kbps.

Note that QP = 0 means that the frame is skipped and needs to be reconstructed at the decoder. Most of the frames

that are skipped with our algorithm are the frames between frames 15 and 23, which correspond to the part with

the lowest motion in the GOP under consideration. In addition, it can be seen that our algorithm assigns low QP

values to the frames that are neighbors of the dropped frames, since these neighbors are used as reference frames

in their reconstruction at the decoder. In Fig. 4b, we show Y-PSNR of coded (QP > 0) and interpolated (QP = 0)

frames, for the same experiment as in Fig. 4a. We see that the solution of our algorithm achieves a higher average

17

200

]
s
p
b
k
[

)
λ
q

150

,
λ

V
(
R

100

200

180

160

]
s
p
b
k
[

)
λ
q

,
λ

V
(
R

140

120

100

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.1

λ

(a)

0.3

0.4

0.2

(b)

λ

Fig. 3. Relationship between the rate R(Vλ, qλ) and the Lagrange multiplier λ for the (a) Shark and (b) Undo Dancer multiview video
sequences when views are independently encoded.

P
Q

44

42

40

38

36

34

QPs - Proposed algorithm
QPs - RC HEVC

40

38

36

34

32

30

]

B
d
[

R
N
S
P
-
Y

Y-PSNR - Proposed algorithm
Y-PSNR - RC HEVC

15

20

30

Frames

(a)

40

44

15

20

40

44

30
Frame
(b)

Fig. 4. Frame-by-frame comparison of our proposed algorithm and the RC of HEVC for Hall Monitor monoview video sequence: (a) QP
selection and (b) quality comparison (Y-PSNR) for a rate budget B = 500kbps. R = 490.60kbps and an average Y-PSNR=32.11 dB is
achieved by our solution, and R = 499.53kbps and Y-PSNR=30.50 dB is achieved by the RC of HEVC.

quality compared to the solution of the RC of HEVC, achieving an average Y-PSNR of 32.11dB, while the RC

solution has an average Y-PSNR of 30.50dB.

A view-by-view quality evaluation that results from the QP selection of our algorithm and the RC of 3D-HEVC

is illustrated in Fig. 5. We consider the Shark multiview video sequence and a rate budget of 250 kbps, where

the consumed rate of our algorithm is 245.49 kbps, while the RC of 3D-HEVC uses 242.55 kbps. Our algorithm

solution in this cases does not skip any view at the encoder, and still it achieves a higher average Y-PSNR (30.49

dB) compared to the RC of 3D-HEVC (29.98 dB). Proving that, the good performance of our algorithm does not

reside on its capability of skipping data units at the encoder.

Y-PSNR - Our solution
Y-PSNR - RC 3D-HEVC

18

2

3

4

5

6

7

8

9

B
d
[

R
N
S
P
-
Y

34

32

30

28

1

Fig. 5. View-by-view average quality comparison (Y-PSNR) of our proposed algorithm and the RC of 3D-HEVC for Shark multiview
video sequence.and a rate budget B = 250kbps. R = 245.49kbps and an average Y-PSNR=30.49 dB is achieved by our solution, and
R = 242.55kbps and Y-PSNR=29.98 dB is achieved by the RC of 3D-HEVC.

Tables I and II show the performance of both our rate allocation algorithm and the RC of HEVC, in terms of

average Y-PSNR given a rate budget B for the monoview sequences Hall Monitor and Kimono. We see that our

algorithm always outputs a solution with a rate that is under the rate budget B and achieves a higher quality, with

a Y-PSNR gain of up to 2.34dB. The corresponding visual quality is illustrated in Fig. 6 for Hall Monitor for

frames 15 and 17, when the rate budget is B = 150 kbps. Our algorithm tends to skip frames with low motion,

as frame 17, which are then efﬁciently interpolated at the decoder. This permits to achieve a higher visual quality

than the one of the RC of HEVC that has to use a higher QP value to satisfy the rate budget.

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Hall Monitor MONOVIEW VIDEO SEQUENCE WITH INDEPENDENTLY ENCODED FRAMES.

TABLE I

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
150
200
300
400
500

149.39
198.13
298.88
366.10
490.60

149.96
200.16
300.31
400.09
499.53

26.62
28.60
29.57
30.66
30.79

24.93
25.26
27.29
28.98
30.49

Similarly, Tables III, IV and V show the performance of our algorithm and the RC of 3D-HEVC in terms of

average Y-PSNR, with different rate budgets for the multiview sequences Shark, Undo Dancer and Soccer Linear2.

Although our algorithm has a better performance than the RC of 3D-HEVC in all cases, this gain is smaller than

the monoview sequences. The main reason is that the frame-to-frame differences along the temporal dimension in

monoview videos are relatively smaller, making skipping frames a more attractive option.

19

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Kimono MONOVIEW VIDEO SEQUENCE WITH INDEPENDENTLY ENCODED FRAMES.

TABLE II

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
150
200
300
400
500

149.03
198.80
296.32
391.20
499.61

149.81
200.46
299.97
400.36
502.06

27.44
28.59
29.56
30.03
30.23

26.42
27.20
28.37
29.35
30.17

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF 3D-HEVC,

FOR THE Shark MULTIVIEW VIDEO SEQUENCE WITH INDEPENDENTLY ENCODED VIEWS.

TABLE III

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
175
200
300
400
500

174.41
196.26
287.61
381.54
481.71

162.45
198.75
287.49
389.28
485.13

29.25
29.26
31.08
32.35
33.49

28.22
29.22
30.57
31.51
32.22

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF 3D-HEVC,

FOR THE Undo Dancer MULTIVIEW VIDEO SEQUENCE WITH INDEPENDENTLY ENCODED VIEWS.

TABLE IV

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
175
200
300
400
500

169.15
199.15
280.55
383.05
476.78

169.55
197.32
286.95
380.70
486.15

27.71
28.39
29.57
30.79
31.63

26.99
27.51
28.74
29.69
30.47

C. Predictive Coding

We consider now the predictive coding case, and in particular, an IP P . . . predictive coding structure with one

intra (I) coded data unit and subsequent predictively (P) coded units in each GOP. As the computational complexity

in the rate allocation increases for predictive coding compared to the independent coding case—rate and distortion

terms now depend on previous coded units—we decrease the granularity of the available QPs in the search space
of our algorithm to Q = {25, 28, 31··· , 51}.

For different rate constraints B, Tables VI and VII show the RD performance of our algorithm and the RC of

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF 3D-HEVC,

FOR THE Soccer Linear2 MULTIVIEW VIDEO SEQUENCE WITH INDEPENDENTLY ENCODED VIEWS.

TABLE V

B

Proposed algorithm

RC HEVC

20

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
175
250
300
400
500

172.90
245.98
296.23
395.32
487.4

173.28
249.06
288.82
398.11
482.24

28.15
28.89
29.44
30.30
31.42

27.70
28.99
29.24
30.77
31.03

HEVC for the Hall Monitor and Kimono monoview sequences. We observe that our assumption that the rate and

distortion functions depend only on one reference frame (see Section III-A) sometimes leads to under-estimation of

the coding rate. Thus, we employ a simple post-processing step, where the Lagrangian solution to (9) of a singular

muliplier value λ closest to the budget B with actual aggregate coding rate below the budget is used.

Compared to the independent coding case, in the predictive coding scenario, the RC of HEVC does not lead to

a good performance for the two monoview video sequences considered. This is evident for the Kimono dataset in

Table VII where the rates of some solutions of the RC of HEVC are far above the rate budget constraint (indicated

by an asterisk), particularly at low bit budgets.

We see from Tables VI and VII, that our algorithm typically achieves a better average quality. Moreover, our

algorithm uses a sparser set of QPs than the RC of HEVC, meaning that our results can be improved if the same
set of QPs Q is used by both schemes. Although our algorithm shows good performance on average, the gain of
our algorithm is smaller for predictive coding than for independent coding. This is due to the fact that in predictive

coding skipped frames have higher impact in the overall quality, which is one of the reasons of quality gains for

independently encoded units. Indeed, when frames are skipped at the encoder during predictive coding, the distance

between a coded frame and its reference increases, which reduces the coding performance. However, these results

show that the good performance of our algorithm does not uniquely depend on its capability for skipping data units

at the encoder.

Finally, Tables VIII, IX and X show the performance in terms of rate and average quality of our algorithm and

the RC of 3D-HEVC for the predictive coding of the Shark, Undo Dancer and Soccer Linear2 multiview video

sequences. Compared to the monoview video results presented in Tables VI and VII where the average gain is

lower than 1dB, for predictively coded multiview video sequences better performance is observed, with an average

quality gain higher than 1dB. Moreover, the solution obtained with our algorithm satisﬁes the rate budget most of

the time with our original algorithm, and there is usually no need to use the post-processing step to modify the

21

(a) Frame 15 - Proposed algorithm - QP= 43

(b) Frame 15 - RC HEVC - QP= 47

(c) Frame 17 - Proposed algorithm - Recon-
structed frame

(d) Frame 17 - RC HEVC - QP= 51

Fig. 6. Visual quality illustration for the Hall Monitor monoview video sequence with independently encoded frames when the proposed
algorithm and the RC of HEVC are used (B = 150 kbps). (a) and (b) Show frame 15 encoded according to our proposed algorithm and the
RC of HEVC, respectively. (c) Shows frame 17, that has has been skipped at the encoder and reconstructed at the decoder according to the
proposed algorithm, achieving a higher visual quality compared to the RC of HEVC output in (d).

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Hall Monitor MONOVIEW VIDEO SEQUENCE WITH PREDICTIVELY CODED FRAMES.

TABLE VI

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]

50
75
100
150

47.96
74.82
96.84
148.16

30.06
33.92
34.17
36.26

50.14
75.06
99.89
150.09

29.92
33.70
34.28
36.02

obtained solutions. This is due to the length of the prediction paths. In the case of multiview video, the maximum

length of the (inter-view) prediction path is 9 views (e.g., Shark), compared to 30 and 24 frames (GOP size) in the

Hall Monitor and Kimono monoview video sequences. This means that, for the multiview video case, the effect

of previously coded units in a current predicted unit is much more limited than in monoview video cases, thus

making our assumption of Section III-A more reasonable. In general, from these results we can conclude that when

22

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Kimono MONOVIEW VIDEO SEQUENCE WITH PREDICTIVELY CODED FRAMES.

TABLE VII

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]

75
100
150
200

73.01
97.06
148.34
186.44

27.21
28.40
29.75
30.41

96.44 *
120.00 *
152.44
204.12

28.01
29.02
29.54
30.24

our algorithm is close to the rate budget (i.e., the granularity of the available QPs is not affecting the solution) it

achieves a quality that is generally higher than the one in the RC of 3D-HEVC.

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Shark MULTIVIEW VIDEO SEQUENCE WITH PREDICTIVELY CODED VIEWS.

TABLE VIII

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
100
150
200
300

107.64
147.60
190.59
290.91

98.19
147.25
195.47
297.22

29.15
31.02
32.68
33.51

28.03
29.51
30.69
32.59

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Undo Dancer MULTIVIEW VIDEO SEQUENCE WITH PREDICTIVELY CODED VIEWS.

TABLE IX

B

Proposed algorithm

RC HEVC

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]

50
75
100
150
200

49.93
74.15
76.72
129.81
191.9

25.87
28.23
28.29
30.25
32.12

46.85
74.75
82.22
148.07
194.00

25.32
27.54
27.96
30.47
31.50

VII. CONCLUSION

A new and general solution for the optimal selection of the Lagrange multiplier in Lagrangian-based rate allocation

optimization problems has been presented in this paper. It has been integrated into a general Lagrangian-based

dynamic programming algorithm to efﬁciently solve rate allocation problems in video communication applications.

The potential of our new algorithm has been illustrated in representative compression problems with monoview and

RATE BUDGET B, ACTUAL RATE R AND AVERAGE Y-PSNR VALUE FOR THE PROPOSED ALGORITHM AND FOR THE RC OF HEVC, FOR

THE Soccer Linear2 MULTIVIEW VIDEO SEQUENCE WITH PREDICTIVELY CODED VIEWS.

TABLE X

B

Proposed algorithm

RC HEVC

23

[kbps] R [kbps] Y-PSNR [dB] R [kbps] Y-PSNR [dB]
100
200
250
300
400

93.06
184.08
247.02
289.02
376.14

98.96
180.48
180.48
296.27
396.18

28.06
30.77
30.77
33.27
34.71

26.09
29.72
31.04
32.18
33.53

multiview video sequences, and rate control solutions adopted by the reference softwares, HEVC and 3D-HEVC,

have been used to appreciate the rate distortion performance of our proposed algorithm.

A. Proof of Optimality

We prove here that, if an optimal solution (Vλ∗, qλ∗) to the unconstrained Lagrangian problem corresponding to

multiplier value λ∗ satisﬁes the rate constraint exactly, i.e.,

R(Vλ∗, qλ∗) = B,

(19)

then (Vλ∗, qλ∗) is also the optimal solution to the original constrained problem. The optimality of (Vλ∗, qλ∗)

implies that:

D(Vλ∗ , qλ∗ ) + λ∗R(Vλ∗ , qλ∗ ) ≤ D(V, q) + λ∗R(V, q), ∀V, q

Rearranging the terms, we get:

∗

λ

[R(Vλ∗, qλ∗) − R(V, q)] ≤ D(V, q) − D(Vλ∗, qλ∗)
[B − R(V, q)] ≤ D(V, q) − D(Vλ∗, qλ∗)

λ

∗

Now we restrict our solution space to a subspace S where R(V, q) ≤ B. Then,

0 ≤ λ∗ [B − R(V, q)] ≤ D(V, q) − D(Vλ∗ , qλ∗ ), ∀(V, q) ∈ S

D(Vλ∗ , qλ∗ ) ≤ D(V, q), ∀(V, q) ∈ S

We can thus conclude (Vλ∗, qλ∗) is an optimal solution to the original constrained problem as well. (cid:3)

B. Performance Bound

We prove here the performance bound given in Eq. (10). Let (Vλ1, qλ1) and (Vλ2, qλ2) be two solutions of the

problem in (8) using λ1 and λ2 with resulting rates:

24

R(Vλ1, qλ1) < B < R(Vλ2, qλ2)

(20)

We can derive a performance bound for the feasible solution (Vλ1, qλ1) as follows. Denote by (V

∗, q∗) the
optimal solution to the original constrained problem. By the optimality of the solution (Vλ2, qλ2), we can write:

∗

0 ≤ λ

[R(Vλ2, qλ2) − R(V

∗

∗

, q

)] ≤ D(V
D(Vλ2, qλ2) ≤ D(V

∗

∗

∗

∗

, q

, q

) − D(Vλ2, qλ2)
)

(21)

where the second line is true because B < R(Vλ2, qλ2) and R(V
∗, q∗), we also know that:

(V

∗, q∗) ≤ B. By the optimality of the solution

∗

∗

, q

D(V

) ≤ D(V, q),

∀(V, q) ∈ S

(22)

where, S denotes the set of solutions that have a total rate lower than B. Note that S includes (Vλ1, qλ1), since

R(Vλ1, qλ1) < B. Combining the inequalities in (21) and (22), we can write:

D(Vλ2, qλ2) ≤ D(V

∗

∗

, q

) ≤ D(Vλ1, qλ1)

|D(Vλ1, qλ1) − D(V

which concludes the proof. (cid:3)

∗

∗

, q

)| ≤ |D(Vλ1, qλ1) − D(Vλ2, qλ2)|

(23)

REFERENCES

[1] A. M. Tekalp, Digital Video Processing. Upper Saddle River, NJ, USA: Prentice-Hall, Inc., 1995.

[2] P. S. P. Wang, Pattern Recognition, Machine Intelligence and Biometrics. Springer Publishing Company, Incorporated, 2011.

[3] P. Kauff, N. Atzpadin, C. Fehn, M. M¨uller, O. Schreer, A. Smolic, and R. Tanger, “Depth map creation and image-based rendering for

advanced 3dtv services providing interoperability and scalability,” Image Commun., vol. 22, no. 2, pp. 217–234, Feb. 2007.

[4] Y. Shoham and A. Gersho, “Efﬁcient bit allocation for an arbitrary set of quantizers,” in IEEE Transactions on Acoustics, Speech, and

Signal Processing, vol. 36, no.9, Sept. 1988, pp. 1445–1453.

[5] K. Ramchandran, A. Ortega, and M. Vetterli, “Bit allocation for dependent quantization with applications to multiresolution and MPEG

video coders,” in IEEE Transactions on Image Processing, vol. 3, no.5, Sept. 1994.

25

[6] S. Liu and C.-C. J. Kuo, “Joint temporal-spatial bit allocation for video coding with dependency,” in IEEE Transactions on Circuits

and Systems for Video Technology, vol. 15, no.1, Jan. 2005, pp. 15–26.

[7] J.-H. Kim, J. Garcia, and A. Ortega, “Dependent bit allocation in multiview video coding,” in IEEE International Conference on Image

Processing, Genoa, Italy, Sept. 2005.

[8] G. Cheung, V. Velisavljevic, and A. Ortega, “On dependent bit allocation for multiview image coding with depth-image-based rendering,”

in IEEE Transactions on Image Processing, vol. 20, no.11, Nov. 2011, pp. 3179–3194.

[9] M. Wang and M. van der Schaar, “Operational rate-distortion modeling for wavelet video coders,” IEEE Transactions on Signal

Processing, vol. 54, no. 9, pp. 3505–3517, Sept 2006.

[10] M. Kaaniche, A. Fraysse, B. Pesquet-Popescu, and J.-C. Pesquet, “Accurate rate-distortion approximation for sparse bernoulli-generalized

gaussian models,” in IEEE International Conference on Acoustics, Speech and Signal Processing, May 2014, pp. 2020–2024.

[11] B. Li, H. Li, L. Li, and J. Zhang, “Rate control by r-lambda model for HEVC, JCTVC-K0103,” Joint Collaborative Team on Video

Coding (JCT-VC), Changai, China, Oct. 2012.

[12] W. Lim, H. Jo, and D. Sim, “JCT3V inter-view MV-based rate prediction for rate control of 3D multi-view video coding, JCT3V-F0166,”

Joint Collaborative Team on Video Coding (JCT-VC), Geneva, Switzerland, Oct. 2013.

[13] S. Ma, J. Si, and S. Wang, “A study on the rate distortion modeling for high efﬁciency video coding,” in IEEE International Conference

on Image Processing, Sept 2012, pp. 181–184.

[14] K. Stuhlmuller, N. Farber, M. Link, and B. Girod, “Analysis of video transmission over lossy channels,” IEEE Journal on Selected

Areas in Communications, vol. 18, no. 6, pp. 1012–1032, June 2000.

[15] A. Ortega and K. Ramchandran, “Rate-distortion methods for image and video compression,” IEEE Signal Processing Magazine, vol. 15,

no. 6, pp. 23–50, Nov 1998.

[16] G. Cheung, W.-T. Tan, and C. Chan, “Reference frame optimization for multiple-path video streaming with complexity scaling,” in

IEEE Transactions on Circuits and Systems for Video Technology, vol. 17, no.6, June 2007, pp. 649–662.

[17] A. De Abreu, L. Toni, T. Maugey, N. Thomos, P. Frossard, and F. Pereira, “Multiview video representations for quality-scalable

navigation,” in IEEE Int. Conf. on Visual Communications and Image Processing, Valletta, Malta, Dec. 2014.

[18] A. D. Abreu, L. Toni, N. Thomos, T. Maugey, F. Pereira, and P. Frossard, “Optimal layered representation for adaptive interactive

multiview video streaming,” Journal of Visual Communication and Image Representation, vol. 33, pp. 255 – 264, 2015.

[19] S. Li, C. Zhu, Y. Gao, Y. Zhou, F. Dufaux, and M. Sun, “Lagrangian multiplier adaptation for rate-distortion optimization with

inter-frame dependency,” Circuits and Systems for Video Technology, IEEE Transactions on, vol. 26, no. 1, pp. 117–129, Jan 2016.

[20] G. Cheung and A. Zakhor, “Bit allocation for joint source/channel coding of scalable video,” IEEE Trans. Image Processing, vol. 9,

no. 3, pp. 340–356, Mar 2000.

[21] G. Sullivan and T. Wiegand, “Rate-distortion optimization for video compression,” in IEEE SP Magazine, Nov. 1998.

[22] G. Cheung, “Directed acyclic graph based mode optimization for H.263 video encoding,” in IEEE International Conference on Image

Processing, Thessaloniki, Greece, October 2001.

[23] M. R. Garey and D. S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness. Freeman, 1999.

[24] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to Algorithms, Third Edition, 3rd ed. The MIT Press, 2009.

[25] C. H. Papadimitriou and K. Steiglitz, Combinatorial Optimization: Algorithms and Complexity. Dover, 1998.

[26] Y.-M. Chen, I. Bajic, and P. Saeedi, “Coarse-to-ﬁne moving region segmentation in compressed video,” in Image Analysis for Multimedia

Interactive Services, 2009. WIAMIS ’09. 10th Workshop on, May 2009, pp. 45–48.

[27] Y.-M. Chen and I. Bajic, “Compressed-domain moving region segmentation with pixel precision using motion integration,” in

Communications, Computers and Signal Processing, 2009. PacRim 2009. IEEE Paciﬁc Rim Conference on, Aug 2009, pp. 442–447.

[28] Shark multiview sequence. [Online]. Available: http://www.fujii.nuee.nagoya-u.ac.jp/NICT/NICT.htm

26

[29] D. Rusanovskyy, P. Aﬂaki, and M. M. Hannuksela, “Undo dancer 3DV sequence for purposes of 3DV standardization,” in ISO/IEC

JTC1/SC29/WG11 MPEG2010/ M20028, Geneva, Switzerland, March 2011.

[30] P. Goorts, S. Maesen, M. Dumont, S. Rogmans, and P. Bekaert, “Free viewpoint video for soccer using histogram-based validity maps

in plane sweeping,” in Proceedings of the Ninth International Conference on Computer Vision Theory and Applications (VISAPP 2014).

INSTICC, 2014.

[31] K. Mller and A. Vetro, “Common test conditions of 3DV core experiments, JCT3V-G1100,” Joint Collaborative Team on Video Coding

(JCT-VC), San Jos, US, January 2014.

[32] G. J. Sullivan, J. Ohm, W.-J. Han, and T. Wiegand, “Overview of the high efﬁciency video coding (HEVC) standard,” in IEEE

Transactions on Circuits and Systems for Video Technology, vol. 22, no.12, Dec. 2012.

[33] Y. Liu, Q. Dai, Z. You, and W. Xu, “Rate-prediction structure complexity analysis for multi-view video coding using hybrid genetic

algorithms,” in Proc. SPIE, vol. 6508, 2007, pp. 650 804–650 804–8.

[34] HTM 13.0 software. [Online]. Available: \url{https://hevc.hhi.fraunhofer.de/svn/svn\ 3DVCSoftware/tags/HTM-13.0/}
[35] L. Rakłt, L. Roholm, A. Bruhn, and J. Weickert, “Motion compensated frame interpolation with a symmetric optical ﬂow constraint,”

in Advances in Visual Computing, ser. Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2012, vol. 7431, pp. 447–457.

[36] J. Zhai, K. Yu, J. Li, and S. Li, “A low complexity motion compensated frame interpolation method,” in IEEE International Symposium

on Circuits and Systems, Kobe, Japan, May 2005.

[37] M. Schmeing and X. Jiang, Depth Image Based Rendering, P. S. Wang, Ed. Springer Berlin Heidelberg, 2011.

[38] S. Zinger, L. Do, and P. H. N. de With, “Free-viewpoint depth image based rendering,” Journal Visual Communication and Image

Representation, vol. 21, no. 5-6, pp. 533–541, July 2010.

[39] HM 15.0 software. [Online]. Available: \url{https://hevc.hhi.fraunhofer.de/svn/svn\ HEVCSoftware/branches/HM-15.0-dev/}
[40] K. Muller, H. Schwarz, D. Marpe, C. Bartnik, S. Bosse, H. Brust, T. Hinz, H. Lakshman, P. Merkle, F. Rhee, G. Tech, M. Winken, and

T. Wiegand, “3d high-efﬁciency video coding for multi-view video and depth data,” Image Processing, IEEE Transactions on, vol. 22,

no. 9, pp. 3366–3378, Sept 2013.

