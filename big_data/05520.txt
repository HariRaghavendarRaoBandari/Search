Improved Approximation for Node-Disjoint Paths in Planar Graphs∗

Julia Chuzhoy†

David H. K. Kim‡

Shi Li§

March 18, 2016

Abstract

We study the classical Node-Disjoint Paths (NDP) problem: given an n-vertex graph G and a
collection M = {(s1, t1), . . . , (sk, tk)} of pairs of vertices of G called demand pairs, ﬁnd a maximum-
cardinality set of node-disjoint paths connecting the demand pairs. NDP is one of the most basic
routing problems, that has been studied extensively. Despite this, there are still wide gaps in our
understanding of its approximability: the best currently known upper bound of O(
n) on its ap-
proximation ratio is achieved via a simple greedy algorithm, while the best current negative result
shows that the problem does not have a better than Ω(log1/2−δ n)-approximation for any constant
δ, under standard complexity assumptions. Even for planar graphs no better approximation algo-
rithms are known, and to the best of our knowledge, the best negative bound is APX-hardness.
Perhaps the biggest obstacle to obtaining better approximation algorithms for NDP is that most
√
currently known approximation algorithms for this type of problems rely on the standard multi-
√
n) for NDP, even in planar graphs. In this
commodity ﬂow relaxation, whose integrality gap is Ω(
n) on the approximability of the NDP problem in planar graphs
paper, we break the barrier of O(
and obtain an ˜O(n9/19)-approximation. We introduce a new linear programming relaxation of the
problem, and a number of new techniques, that we hope will be helpful in designing more powerful
algorithms for this and related problems.

√

6
1
0
2

 
r
a

 

M
7
1

 
 
]
S
D
.
s
c
[
 
 

1
v
0
2
5
5
0

.

3
0
6
1
:
v
i
X
r
a

∗An extended abstract is to appear in STOC 2016
†Toyota Technological Institute at Chicago. Email: cjulia@ttic.edu. Supported in part by NSF grant CCF-1318242.
‡Computer Science Department, University of Chicago. Email: hongk@cs.uchicago.edu. Supported in part by NSF
§Department of Computer Science and Engineering, University at Buﬀalo. Part of the work done while the author

grant CCF-1318242.

was at the Toyota Technological Institute at Chicago. Email: shil@buffalo.edu.

1 Introduction

√

n × √

In the Node-Disjoint Paths (NDP) problem, we are given an n-vertex graph G, and a collection
M = {(s1, t1), . . . , (sk, tk)} of pairs of vertices of G, called source-destination, or demand, pairs. The
goal is to route as many of the demand pairs as possible, by connecting each routed pair with a
path, so that the resulting paths are node-disjoint. We denote by NDP-Planar the special case of
√
the problem where the input graph G is planar, and by NDP-Grid the special case where G is the
n)-grid. NDP is one of the most basic problems in the area of graph routing, and it was
(
initially introduced to the area in the context of VLSI design. In addition to being extensively studied
in the area of approximation algorithms, this problem has played a central role in Robertson and
Seymour’s Graph Minor series. When the number of the demand pairs k is bounded by a constant,
Robertson and Seymour [RS90, RS95] have shown an eﬃcient algorithm for the problem, as part of
the series. When k is a part of input, the problem becomes NP-hard [Kar72, EIS76], even on planar
graphs [Lyn75], and even on grid graphs [KvL84]. Despite the importance of this problem, and many
eﬀorts, its approximability is still poorly understood. The following simple greedy algorithm achieves
an O(
n)-approximation [KS04]: while G contains any path connecting any demand pair, choose
the shortest such path P , add P to the solution, and delete all vertices of P from G. Surprisingly,
this elementary algorithm is the best currently known approximation algorithm for NDP, even for
planar graphs. Until recently, this was also the best approximation algorithm for NDP-Grid. On the
negative side, it is known that there is no O(log1/2−δ n)-approximation algorithm for NDP for any
constant δ, unless NP ⊆ ZPTIME(npoly log n) [AZ05, ACG+10]. To the best of our knowledge, the
best negative result for NDP-Planar and for NDP-Grid is APX-hardness [CK15]. Perhaps the biggest
obstacle to obtaining better upper bounds on the approximability of NDP is that the common approach
to designing approximation algorithms for this type of problems is to use the multicommodity ﬂow
√
relaxation, where instead of connecting the demand pairs with paths, we send a (possibly fractional)
multicommodity ﬂow between them. The integrality gap of this relaxation is known to be Ω(
n),
even for planar graphs, and even for grid graphs. In a recent work, Chuzhoy and Kim [CK15] showed
an ˜O(n1/4)-approximation algorithm for NDP-Grid, thus bypassing the integrality gap obstacle for this
restricted family of graphs. The main result of this paper is an ˜O(n9/19)-approximation algorithm for
NDP-Planar. We also show that, if the value of the optimal solution to the NDP-Planar instance is
OPT, then we can eﬃciently route Ω
demand pairs. Our algorithm is motivated by the
work of [CK15] on NDP-Grid, and it relies on approximation algorithms for the NDP problem on a
disc and on a cylinder, that we discuss next.

(cid:16) OPT1/19

(cid:17)

poly log n

We start with the NDP problem on a disc, that we denote by NDP-Disc. In this problem, we are given
a planar graph G, together with a set M of demand pairs as before, but we now assume that G can
be drawn in a disc, so that all vertices participating in the demand pairs lie on its boundary. The
NDP problem on a cylinder, NDP-Cylinder, is deﬁned similarly, except that now we assume that we
are given a cylinder Σ, obtained from the sphere, by removing two disjoint open discs (caps) from
it. We denote the boundaries of the discs by Γ1 and Γ2 respectively, and we call them the cuﬀs of
Σ. We assume that G can be drawn on Σ, so that all source vertices participating in the demand
pairs in M lie on Γ1, and all destination vertices lie on Γ2. Robertson and Seymour [RS86] showed an
algorithm, that, given an instance of the NDP-Disc or the NDP-Cylinder problem, decides whether all
demand pairs in M can be routed simultaneously via node-disjoint paths, and if so, ﬁnds the routing
eﬃciently. Moreover, for each of the two problems, they give an exact characterization of instances for
which all pairs in M can be routed in G. Several other very eﬃcient algorithms are known for both
problems [RLWW96, SAN90]. However, for our purposes, we need to consider the optimization version
of both problems, where we are no longer guaranteed that all demand pairs in M can be routed, and
would like to route the largest possible subset of the demand pairs. We are not aware of any results

1

for these two special cases of the NDP problem. In this paper, we provide O(log k)-approximation
algorithms for both problems.

√

√
n)-approximation algorithm, and the integrality gap of the LP-relaxation is Ω(

Other Related Work. A problem closely related to NDP is the Edge-Disjoint Paths (EDP) prob-
lem. It is deﬁned similarly, except that now the paths chosen to the solution are allowed to share
vertices, and are only required to be edge-disjoint. It is easy to show, by using a line graph of the
EDP instance, that NDP is more general than EDP (though this transformation inﬂates the number
of the graph vertices, so it may not preserve approximation factors that depend on n). This rela-
tionship breaks down in planar graphs, since the resulting NDP instance may no longer be planar.
The approximability status of EDP is very similar to that of NDP: there is an O(
n)-approximation
algorithm [CKS06], and it is known that there is no O(log1/2−δ n)-approximation algorithm for any
constant δ, unless NP ⊆ ZPTIME(npoly log n) [AZ05, ACG+10]. We do not know whether our tech-
niques can be used to obtain improved approximation algorithms for EDP on planar graphs. As in the
√
NDP problem, we can use the standard multicommodity ﬂow LP-relaxation of the problem, in order
to obtain an O(
n)
even in planar graphs. For several special cases of the problem better algorithms are known: Klein-
berg [Kle05], building on the work of Chekuri, Khanna and Shepherd [CKS05, CKS04], has shown
an O(log2 n)-approximation LP-rounding algorithm for even-degree planar graphs. Aumann and Ra-
bani [AR95] showed an O(log2 n)-approximation algorithm for EDP on grid graphs, and Kleinberg
and Tardos [KT98, KT95] showed O(log n)-approximation algorithms for broader classes of nearly-
Eulerian uniformly high-diameter planar graphs, and nearly-Eulerian densely embedded graphs. Re-
cently, Kawarabayashi and Kobayashi [KK13] gave an O(log n)-approximation algorithm for EDP when
the input graph is either 4-edge-connected planar or Eulerian planar. It appears that the restriction
of the graph G to be Eulerian, or nearly-Eulerian, makes the EDP problem signiﬁcantly simpler, and
in particular improves the integrality gap of the LP-relaxation. The analogue of the grid graph for
the EDP problem is the wall graph: the integrality gap of the standard LP-relaxation for EDP on wall
n)-approximation algorithms for EDP on walls
graphs is Ω(
were known. The work of [CK15] gives an ˜O(n1/4)-approximation algorithm for EDP on wall graphs.

√

√

n), and until recently, no better than O(

A variation of the NDP and EDP problems, where small congestion is allowed, has been a subject
of extensive study. In the NDP with congestion (NDPwC) problem, the input is the same as in the
NDP problem, and we are additionally given a non-negative integer c. The goal is to route as many
of the demand pairs as possible with congestion at most c: that is, every vertex may participate in at
most c paths in the solution. EDP with Congestion (EDPwC) is deﬁned similarly, except that now the
congestion bound is imposed on edges and not vertices. The classical randomized rounding technique
of Raghavan and Thompson [RT87] gives a constant-factor approximation for both problems, if the
congestion c is allowed to be as high as Θ(log n/ log log n). A recent line of work [CKS05, R¨ac02,
And10, RZ10, Chu12, CL12, CE13, CC] has lead to an O(poly log k)-approximation for both NDPwC
and EDPwC problems, with congestion c = 2. For planar graphs, a constant-factor approximation with
congestion 2 is known for EDP [SCS11]. All these algorithms perform LP-rounding of the standard
multicommodity ﬂow LP-relaxation of the problem and so it is unlikely that they can be extended to
routing with no congestion.

Our Results and Techniques. Given an instance (G,M) of the NDP problem, we denote by
OPT(G,M) the value of the optimal solution to it. Our ﬁrst result is an approximation algorithm for
NDP-Disc and NDP-Cylinder.

Theorem 1.1 There is an eﬃcient O(log k)-approximation algorithm for the NDP-Disc and the NDP-
Cylinder problems, where k is the number of the demand pairs in the instance.

2

We provide a brief high-level overview of the techniques we use in the proof of Theorem 1.1. We deﬁne
a new intermediate problem, called Demand Pair Selection Problem (DPSP). In this problem, we are
given two disjoint directed paths σ and σ(cid:48), and a set M = {(s1, t1), . . . , (sk, tk)} of pairs of vertices
that we call demand pairs, such that all vertices in {s1, . . . , sk} lie on σ, and all vertices in {t1, . . . , tk}
lie on σ(cid:48). For any pair of vertices v, v(cid:48) ∈ V (σ), we denote v ≺ v(cid:48) if v lies before v(cid:48) on σ, and we
denote v (cid:22) v(cid:48) if v = v(cid:48) or v ≺ v(cid:48). For every pair v, v(cid:48) ∈ V (σ(cid:48)) of vertices, we deﬁne the relationships
v ≺ v(cid:48) and v (cid:22) v(cid:48) similarly. We say that two demand pairs (s, t), (s(cid:48), t(cid:48)) ∈ M cross, if either (i)
{s, t} ∩ {s(cid:48), t(cid:48)} (cid:54)= ∅, or (ii) s ≺ s(cid:48) and t(cid:48) ≺ t, or (iii) s(cid:48) ≺ s and t ≺ t(cid:48). We are also given a set K of
constraints that we describe below. The goal of the DPSP problem is to ﬁnd a maximum-cardinality
subset M(cid:48) ⊆ M of demand pairs, such that no two pairs in M(cid:48) cross, and all constraints in K are
satisﬁed. There are four types of constraints in K, and each constraint is deﬁned by a quadruple
(i, x, y, w), where i ∈ {1, 2, 3, 4} is the constraint type, x, y ∈ V (σ) ∪ V (σ(cid:48)) are vertices, and w is an
integer. In a type-1 constraint (1, x, y, w), we have x, y ∈ V (σ), and the constraint requires that the
number of the demand pairs (s, t) ∈ M(cid:48) with x (cid:22) s (cid:22) y is at most w. Similarly, in a type-2 constraint
(2, x, y, w), we have x, y ∈ V (σ(cid:48)), and the constraint requires that the number of the demand pairs
(s, t) ∈ M(cid:48) with x (cid:22) t (cid:22) y is at most w. If (3, x, y, w) ∈ K is a type-3 constraint, then x ∈ V (σ) and
y ∈ V (σ(cid:48)) must hold. The constraint requires that the number of the demand pairs (s, t) ∈ M(cid:48) with
s (cid:22) x and y (cid:22) t is at most w. Similarly, if (4, x, y, w) ∈ K is a type-4 constraint, then x ∈ V (σ) and
y ∈ V (σ(cid:48)) must hold, and the constraint requires that the number of the demand pairs (s, t) ∈ M(cid:48)
with x (cid:22) s and t (cid:22) y is at most w. We show that both NDP-Disc and NDP-Cylinder reduce to DPSP
with an O(log k) loss in the approximation factor. The reduction from NDP-Disc to DPSP uses the
characterization of routable instances of NDP-Disc due to Robertson and Seymour [RS86]. Finally, we
show a factor-8 approximation algorithm for the DPSP problem.

The main result of our paper is summarized in the following two theorems.
Theorem 1.2 There is an eﬃcient O(n9/19 · poly log n)-approximation algorithm for the NDP-Planar
problem.
Theorem 1.3 There is an eﬃcient algorithm, that, given an instance (G,M) of NDP-Planar, com-
putes a routing of Ω

demand pairs of M via node-disjoint paths in G.

poly log n

(cid:16) (OPT(G,M))1/19

(cid:17)

Notice that when OPT(G,M) is small, Theorem 1.3 gives a much better that ˜O(n9/19)-approximation.
We now give a high-level intuitive overview of the proof of Theorem 1.2. Given an instance (G,M)
of the NDP problem, we denote by T the set of vertices participating in the demand pairs in M,
and we refer to them as terminals. We start with a quick overview of the ˜O(n1/4)-approximation
algorithm of [CK15] for the NDP-Grid problem, since their algorithm was the motivation for this work.
√
The main observation of [CK15] is that the instances of NDP-Grid, for which the multicommodity
n) integrality gap, have terminals close to the grid boundary. When
ﬂow relaxation exhibits the Ω(
all terminals are at a distance of at least Ω(n1/4) from the boundary of the grid, one can ﬁnd an
˜O(n1/4)-approximation via LP-rounding (but unfortunately the integrality gap remains polynomial in
√
n even in this case). When the terminals are close to the grid boundary, the integrality gap of the
n). However, this special case of NDP-Grid can be easily approximated
LP-relaxation becomes Ω(
√
via simple dynamic programming. For example, when all terminals lie on the grid boundary, the
integrality gap of the LP-relaxation is Ω(
n), but a constant-factor approximation can be achieved
via standard dynamic programming. More generally, when all terminals are within distance at most
O(n1/4) from the grid boundary, we can obtain an O(n1/4)-approximation via dynamic programming.
Overall, we partition the demand pairs of M into two subsets, depending on whether the terminals
lie close to or far from the grid boundary, and obtain an ˜O(n1/4)-approximation for each of the two
resulting problem instances separately, selecting the better of the two solutions as our output.

3

This idea is much more diﬃcult to implement in general planar graphs. For one thing, the notion of
the “boundary” of a planar graph is meaningless - any face in the drawing of the planar graph can
be chosen as the outer face. We note that the standard multicommodity ﬂow LP-relaxation performs
poorly not only when all terminals are close to the boundary of a single face (a case somewhat similar
to NDP-Disc), but also when there are two faces F and F (cid:48), and for every demand pair (s, t) ∈ M, s
is close to the boundary of F and t is close to the boundary of F (cid:48) (this setting is somewhat similar
to NDP-Cylinder). The notion of “distance”, when deciding whether the terminals lie close to or far
from a face boundary is also not well-deﬁned, since we can subdivide edges and artiﬁcially modify the
graph in various ways in order to manipulate the distances without signiﬁcantly aﬀecting routings.
Intuitively, we would like to deﬁne the distances between the terminals in such a way that, on the one
hand, whenever we ﬁnd a set M(cid:48) ⊆ M of demand pairs, such that all terminals participating in the
pairs in M(cid:48) are far enough from each other, then we can route a large subset of the demand pairs in
M(cid:48). On the other hand, if we ﬁnd a set M(cid:48)(cid:48) ⊆ M of demand pairs, with all terminals participating in
the pairs in M(cid:48)(cid:48) being close to the boundary of some face (or a pair of faces), then we can ﬁnd a good
approximate solution to instance (G,M(cid:48)(cid:48)) (for example, by reducing the problem to NDP-Disc or NDP-
Cylinder). Since we do not know beforehand which face (or faces) will be chosen as the “boundary” of
the graph, we cannot partition the problem into two sub-problems and employ diﬀerent techniques to
solve each sub-problem as we did for NDP-Grid. Instead, we need a single framework in which both
cases can be handled.

We assume that every terminal participates in exactly one demand pair, and that the degree of every
terminal is 1. This can be achieved via a standard transformation, where we create several copies of
each terminal, and connect them to the original terminal. This transformation may introduce up to
O(n2) new vertices. Since we are interested in obtaining an ˜O(n9/19)-approximation for NDP-Planar,
we denote by N the number of the non-terminal vertices in the new graph G. Abusing the notation,
we denote the total number of vertices in the new problem instance by n. It is now enough to obtain
an ˜O(N 9/19)-approximation for the new problem instance.

Our ﬁrst step is to deﬁne a new LP-relaxation of the problem. We assume that we have guessed
correctly the value OPT of the optimal solution. We start with the standard multicommodity ﬂow
LP-relaxation, where we try to send OPT ﬂow units between the demand pairs, so that the maximum
amount of ﬂow through any vertex is bounded by 1. We then add the following new set of constraints
to the LP: for every subset M(cid:48) ⊆ M of the demand pairs, for every value OPT(G,M(cid:48)) ≤ z ≤ k, the
total amount of ﬂow routed between the demand pairs in M(cid:48) is no more than z. Adding this type of
constraints may seem counter-intuitive. We eﬀectively require that the LP solves the problem exactly,
and naturally we cannot expect to be able to do so eﬃciently. Since the number of the resulting
constraints is exponential in k, and since we do not know the values OPT(G,M(cid:48)), we indeed cannot
solve this LP eﬃciently. In fact, our algorithm does not attempt to solve the LP exactly. Instead,
we employ the Ellipsoid algorithm, that in every iteration produces a potential solution to the LP-
relaxation. We then show an algorithm that, given such a potential solution, either ﬁnds an integral
solution routing ˜Ω(OPT/N 9/19) demand pairs, or it returns some subset M(cid:48) ⊆ M of demand pairs,
whose corresponding LP-constraint is violated. Therefore, we use our approximation algorithm as the
separation oracle for the Ellipsoid algorithm. We are then guaranteed that after poly(n) iterations,
we will obtain a solution routing the desired number of demand pairs, as only poly(n) iterations are
required for the Ellipsoid algorithm in order to ﬁnd a feasible LP-solution.

The heart of the proof of Theorem 1.2 is then an algorithm that, given a potential (possibly infeasible)
solution to the LP-relaxation, either ﬁnds an integral solution routing ˜Ω(OPT/N 9/19) demand pairs,
or returns some subset M(cid:48) ⊆ M of demand pairs, whose corresponding LP-constraint is violated. We
can assume without loss of generality that the fractional solution we are given satisﬁes all the standard
multicommodity ﬂow constraints, as this can be veriﬁed eﬃciently. For simplicity of exposition, we

4

assume that every demand pair in M sends the same amount of w∗ ﬂow units to each other.
We assume for now that the set T of terminals is αWL-well-linked, for αWL = Θ(w∗/ log n) - that is,
for every pair (T (cid:48),T (cid:48)(cid:48)) of disjoint equal-sized subsets of vertices of T , we can connect vertices of T (cid:48)
to vertices of T (cid:48)(cid:48) by at least αWL · |T (cid:48)| node-disjoint paths. We discuss this assumption in more detail
below. We assume that we are given a drawing of G on the sphere. Our ﬁrst step is to deﬁne the
notion of distances between the terminals. In order to do so, we ﬁrst construct enclosures around
them. Throughout the proof, we use a parameter ∆ = OPT2/19. We say that a curve γ on the sphere
is a G-normal curve iﬀ it intersects the drawing of G only at its vertices. The length of such a curve
is the number of vertices of G it contains. An enclosure around a terminal t is a disc Dt containing
t, whose boundary, that we denote by Ct, is a G-normal curve of length exactly ∆, so that at most
O(∆/αWL) terminals lie in Dt. We show an eﬃcient algorithm to construct the enclosures Dt around
the terminals t, so that the following additional conditions hold: (i) if Dt ⊆ Dt(cid:48) for any pair t, t(cid:48) ∈ T
of terminals, then Dt = Dt(cid:48); and (ii) if Dt ∩ Dt(cid:48) = ∅, then there are ∆ node-disjoint paths connecting
the vertices of Ct to the vertices of Ct(cid:48). We now deﬁne the distances between pairs of terminals. For
every pair (t, t(cid:48)) ∈ T , distance d(t, t(cid:48)) is the length of the shortest G-normal curve, connecting a vertex
of Ct to a vertex of Ct(cid:48).
Next, we show that one of the following has to happen: either there is a large collection ˜M ⊆ M of
demand pairs, such that all terminals participating in the pairs in ˜M are at a distance at least Ω(∆)
from each other; or there is a large collection ˜M(cid:48) ⊆ M of demand pairs, and two faces F, F (cid:48) in the
drawing of G (with possibly F = F (cid:48)), such that for every demand pair in ˜M(cid:48), one of its terminals
is within distance at most ˜O(∆) from the boundary of F , and the other is within distance at most
˜O(∆) from the boundary of F (cid:48).
In the former case, we show that we can route a large subset of
the demand pairs in ˜M via node-disjoint paths, by constructing a special routing structure called
a crossbar (this construction exploits well-linkedness of the terminals and the paths connecting the
enclosures). In the latter case, we reduce the problem to NDP-Disc or NDP-Cylinder, depending on the
distance between the faces F and F (cid:48), and employ the approximation algorithms for these problems
demand pairs from ˜M(cid:48) in G. If the resulting number of demand pairs routed
to route ˜Ω
is close enough to OPT, then we return this as our ﬁnal solution. Otherwise, we show that the LP-
constraint corresponding to the set ˜M(cid:48) of demand pairs is violated, or equivalently, the amount of
ﬂow sent by the LP solution between the demand pairs in ˜M(cid:48) is greater than OPT(G, ˜M(cid:48)).
So far we have assumed that the terminals participating in the demand pairs in M are αWL-well-
linked. In general this may not be the case. Using standard techniques, we can perform a well-linked
decomposition: that is, compute a subset U ⊆ V (G) of at most OPT/64 vertices, such that, if we denote
the set of all connected components of G \ U by {G1, . . . , Gr}, and for each 1 ≤ i ≤ r, we denote by
Mi ⊆ Gi the set of the demand pairs contained in Gi, then the terminals participating in the demand
64 OPT.
It is then tempting to apply the algorithm described above to each of the graphs separately. Indeed,
if, for each 1 ≤ i ≤ r, we ﬁnd a set Pi of node-disjoint paths, routing Ω
demand
pairs of Mi in Gi (where Ni denotes the number of the non-terminal vertices in Gi), then we obtain
an O(N 9/19 · poly log n)-approximate solution overall. Assume now that for some 1 ≤ i ≤ r, we ﬁnd
i|/16. Unfortunately, the set
a subset M(cid:48)
M(cid:48)
i of demand pairs does not necessarily deﬁne a violated LP-constraint, since it is possible that
OPT(G,M(cid:48)
i), if the optimal routing uses many vertices of U (and possibly from
some other graphs Gj). In general, the number of vertices in set U is relatively small compared to
OPT, so in the global accounting across all instances (Gi(cid:48),Mi(cid:48)), only a small number of paths can use
the vertices of U . But for any speciﬁc instance (Gi,Mi), it is possible that most paths in the optimal
solution to instance (G,Mi) use the vertices of U . In order to overcome this diﬃculty, we need to

pairs in Mi are αWL-well-linked in Gi. We are then guaranteed that (cid:80)r

i ⊆ Mi of demand pairs, such that OPT(Gi,M(cid:48)
i) >> OPT(Gi,M(cid:48)

(cid:19)
(cid:18)
i=1 OPT(Gi,Mi) ≥ 63

OPT(Gi,Mi)
·poly log n
N 9/19

i

(cid:16) OPT(G, ˜M(cid:48))

(cid:17)

poly(∆)

i) < w∗|M(cid:48)

5

perform a careful global accounting across all resulting instances (Gi,Mi).

Organization We start with preliminaries in Section 2. Section 3 is devoted to the proof of Theo-
rem 1.1. Since this is not our main result, and the proof is somewhat long (though not very diﬃcult),
most of the proof appears in Section B of the Appendix. Sections 4–7 are devoted to the proof of
Theorem 1.2: Section 4 provides an overview of the algorithm and some initial steps; Section 5 intro-
duces the main technical tools that we use: enclosures, shells, and a partition of the terminals into
subsets; and Sections 6 and 7 deal with Case 1 (when many terminals are far from each other) and
Case 2 (when many terminals are close to the boundaries of at most two faces), respectively. We
prove Theorem 1.3 in Section 8, and provide conclusions in Section 9. For convenience, we include in
Section D of the Appendix a table of the main parameters used in the proof of Theorem 1.2.

2 Preliminaries

Given a graph G and a subset U of its vertices, we denote by N (U ) the set of all neighbors of U , that
is, all vertices v ∈ V (G) \ U , such that there is an edge (u, v) ∈ E(G) for some u ∈ U . We say that
two paths P and P (cid:48) are internally disjoint iﬀ for every vertex v ∈ P ∩ P (cid:48), v is an endpoint of both P
and P (cid:48). Given a path P and a subset U of vertices of G, we say that P is internally disjoint from U
iﬀ every vertex in P ∩ U is an endpoint of P . Similarly, P is internally disjoint from a subgraph G(cid:48)
of G iﬀ P is internally disjoint from V (G(cid:48)). Given a graph G and a set M of demand pairs in G, for
every subset M(cid:48) ⊆ M of the demand pairs, we denote by T (M(cid:48)) the set of all vertices participating
in the demand pairs in M(cid:48). For a subset M(cid:48) ⊆ M of the demand pairs, and a sub-graph H ⊆ G, let
OPT(H,M(cid:48)) denote the value of the optimal solution to instance (H,M(cid:48)).
Given a drawing of any planar graph H in the plane, and given any cycle C in H, we denote by D(C)
the unique disc in the plane whose boundary is C. Similarly, if C is a closed simple curve in the plane,
D(C) is the unique disc whose boundary is C. When the graph H is drawn on the sphere, there are
two discs whose boundaries are C. In such cases we will explicitly specify which of the two discs we
refer to. Given any disc D (in the plane or on the sphere), we use D◦ to denote the disc D without
its boundary. We say that a vertex of H belongs to disc D, and denote v ∈ D, if v is drawn inside D
or on its boundary.

Given a planar graph G, drawn on a surface Σ, we say that a curve C in Σ is G-normal, iﬀ it intersects
the drawing of G at vertices only. The set of vertices of G lying on C is denoted by V (C), and the
length of C is (cid:96)(C) = |V (C)|. For any disc D, whose boundary is a G-normal curve, we denote by
V (D) the set of all vertices of G lying inside D or on its boundary.
Deﬁnition 2.1 Let γ, γ(cid:48) be two curves in the plane or on the sphere. We say that γ and γ(cid:48) cross, iﬀ
there is a disc D, whose boundary is a simple closed curve that we denote by β, such that:

• γ ∩ D is a simple open curve, whose endpoints we denote by a and b;
• γ(cid:48) ∩ D is a simple open curve, whose endpoints we denote by a(cid:48) and b(cid:48); and
• a, a(cid:48), b, b(cid:48) ∈ β, and they appear on β in this circular order.

Given a graph G embedded in the plane or on the sphere, we say that two paths P, P (cid:48) in G cross iﬀ
their images cross. Similarly, we say that a path P crosses a curve γ iﬀ the image of P crosses γ.

6

|C|

Sparsest Cut.
In this paper we use the node version of the sparsest cut problem, deﬁned as follows.
Suppose we are given a graph G = (V, E) with a subset T ⊆ V of its vertices called terminals. A
vertex cut is a tri-partition (A, C, B) of V , such that there are no edges in G with one endpoint in
If (A ∪ C) ∩ T , (B ∪ C) ∩ T (cid:54)= ∅, then the sparsity of the cut (A, C, B) is
A and another in B.
min{|A∩T |,|B∩T |}+|C∩T | . The sparsest cut in G with respect to the set T of terminals is a vertex cut
(A, C, B) with (A∪ C)∩T , (B ∪ C)∩T (cid:54)= ∅, whose sparsity is the smallest among all such cuts. Amir,
Krauthgamer and Rao [AKR03] showed an eﬃcient algorithm, that, given any planar graph G with a
set T ⊆ V (G) of terminal vertices, computes a vertex cut (A, C, B) in G, whose sparsity with respect
to T is within a constant factor of the optimal one. We denote this algorithm by AAKR, and the
approximation factor it achieves by αAKR, so αAKR is a universal constant.

In the special case of the sparsest cut problem that we consider in our paper, all terminals have degree
1, and no edge of G connects any pair of terminals. We show that in this case we can compute a
near-optimal solution (A, C, B) to the sparsest cut problem with C∩T = ∅. The proof of the following
observation uses standard techniques and is deferred to the Appendix.
Observation 2.1 Let G be a planar graph and let T ⊆ V (G) be a subset of its vertices called terminals,
with |T | ≥ 3. Assume that the degree of every terminal is 1, and no edge of G connects any pair of
terminals. Then there is an eﬃcient algorithm to compute a vertex cut (A, C, B) in G, whose sparsity
is within a factor αAKR of the optimal one, and C ∩ T = ∅.

Nested Segments. Suppose we are given a graph G, a cycle C in G, and a collection Σ of (not
necessarily disjoint) segments of C, where each segment is either C itself, or a sub-path of C. We say
that Σ is a nested set of segments of C iﬀ for all σ, σ(cid:48) ∈ Σ, either σ ⊆ σ(cid:48), or σ(cid:48) ⊆ σ, or σ and σ(cid:48) are
internally disjoint - that is, every vertex in σ ∩ σ(cid:48) is an endpoint of both segments. We deﬁne a set of
nested segments of a closed curve C, and of a path P in G similarly.

Decomposition of Forests. A directed forest F is a disjoint union of arborescences τ1, . . . , τr for
some r ≥ 1, where in each arborescence τi, all edges are directed towards the root. We use the following
simple claim about partitioning directed forests into collections of paths. Similar decompositions
were used in previous work, see e.g. Lemma 3.5 in [Kle05]. The proof is included in Appendix for
completeness.

a partition R =(cid:8)R1, . . . , R(cid:100)log n(cid:101)(cid:9) of V (F ) into subsets, such that for each 1 ≤ j ≤ (cid:100)log n(cid:101), F [Rj] is

Claim 2.2 There is an eﬃcient algorithm, that, given a directed forest F with n vertices, computes
a collection of disjoint directed paths, that we denote by Pj. Moreover, for all v, v(cid:48) ∈ Rj, if there is a
directed path from v to v(cid:48) in F , then they both lie on the same path in Pj.

Routing on a Disc. Assume that we are given an instance (G,M) of the NDP-Disc problem, where
G is drawn in a disc D whose boundary is denoted by C. We need the following two deﬁnitions.
Deﬁnition 2.2 We say that two demand pairs (s, t), (s(cid:48), t(cid:48)) ∈ M cross iﬀ either {s, t}∩{s(cid:48), t(cid:48)} (cid:54)= ∅, or
(s, s(cid:48), t, t(cid:48)) appear on C in this circular order. We say that the set M of demand pairs is non-crossing
if no two demand pairs in M cross.
Deﬁnition 2.3 Let C be a closed simple curve and M a set of demand pairs with all vertices of T (M)
lying on C. We say that M is an r-split collection of demand pairs with respect to C, iﬀ there is a
partition M1, . . . ,Mr of the demand pairs in M, and there is a partition {σ1, σ2, . . . , σ2r} of C into

7

disjoint segments, such that σ1, . . . , σ2r appear on C in this circular order, and for each 1 ≤ i ≤ r, for
every demand pair (s, t) ∈ Mi, either s ∈ σ2i−1 and t ∈ σ2i, or vice versa.

Finally, the following lemma allows us to partition any set of demand pairs into a small collection of
split sets. The proof appears in the Appendix.

Lemma 2.3 There is an eﬃcient algorithm, that, given a closed simple curve C in the plane and a set
M of κ demand pairs, whose corresponding terminals lie on C, computes a partition M1, . . . ,M4(cid:100)log κ(cid:101)
of M, such that for each 1 ≤ i ≤ 4(cid:100)log κ(cid:101), set Mi is ri-split with respect to C for some integer ri ≥ 0.

Routing on a Cylinder. Assume that we are given an instance (G,M) of the NDP-Cylinder prob-
lem, where Γ1 and Γ2 are the cuﬀs of the cylinder.
Deﬁnition 2.4 We say that a set M(cid:48) ⊆ M of demand pairs is non-crossing if there is an ordering
(si1, ti1), . . . , (sir , tir ) of the demand pairs in M(cid:48), such that si1, si2, . . . , sir are all distinct and appear
in this counter-clock-wise order on Γ1, and ti1, ti2, . . . , tir are all distinct and appear in this counter-
clock-wise order on Γ2.
It is immediate to verify that if we are given any instance (G,M) of NDP-Cylinder, and any set M(cid:48) ⊆ M
of demand pairs that can all be routed via node-disjoint paths in G, then set M(cid:48) is non-crossing.

Tight Concentric Cycles. We start with the following deﬁnition.
Deﬁnition 2.5 Given a planar graph H drawn in the plane and a vertex v ∈ V (H) that is not incident
to the inﬁnite face, min-cycle(H, v) is the cycle C in H, such that: (i) v ∈ D◦(C); and (ii) among all
cycles satisfying (i), C is the one for which D(C) is minimal inclusion-wise.
It is easy to see that min-cycle(H, v) is uniquely deﬁned. Indeed, consider the graph H \ v, and the
face F in the drawing of H \ v where v used to reside. Then the boundary of F contains exactly one
cycle C with D(C) containing v, and C = min-cycle(H, v). We next deﬁne a family of tight concentric
cycles.

Deﬁnition 2.6 Suppose we are given a planar graph H, an embedding of H in the plane, a simple
closed H-normal curve C, and an integral parameter r ≥ 1. A family of r tight concentric cycles
around C is a sequence Z1, Z2, . . . , Zr of disjoint simple cycles in H, with the following properties:

• D(C) (cid:40) D(Z1) (cid:40) D(Z2) (cid:40) ··· (cid:40) D(Zr);
• if H(cid:48) is the graph obtained from H by contracting all vertices lying in D(C) into a super-node

a, then Z1 = min-cycle(H(cid:48), a); and

• for every 1 < h ≤ r, if H(cid:48) is the graph obtained from H by contracting all vertices lying in

D(Zh−1) into a super-node a, then Zh = min-cycle(H(cid:48), a).

We will sometimes allow C to be a simple cycle in H. The family of tight concentric cycles around C
is then deﬁned similarly.

8

Monotonicity of Paths and Cycles. Suppose we are given a planar graph H, embedded into the
plane, a simple H-normal curve C in H, and a family (Z1, . . . , Zr) of tight concentric cycles around
C. Assume further that we are given a set P of κ node-disjoint paths, originating at the vertices of
C, and terminating at some vertices lying outside of D(Zr). We would like to re-route these paths to
ensure that they are monotone with respect to the cycles, that is, for all 1 ≤ h ≤ r, and for all P ∈ P,
P ∩ Zh is a path. We ﬁrst discuss re-routing to ensure monotonicity with respect to a single cycle,
and then extend it to monotonicity with respect to a family of concentric cycles.

Deﬁnition 2.7 Given a graph H, a cycle C and a path P in H, we say that P is monotone with
respect to C, iﬀ P ∩ C is a path.

The proof of the following lemma is deferred to the Appendix.
Lemma 2.4 Let H be a planar graph embedded into the plane, C a simple cycle in H, and P a
collection of κ simple internally node-disjoint paths between two vertices: vertex s lying in D◦(C), and
vertex t (cid:54)∈ D(C), that is incident on the outer face. Assume further that H is the union of C and the
paths in P, and that C = min-cycle(H, s). Then there is an eﬃcient algorithm to compute a set P(cid:48) of
κ internally node-disjoint paths connecting s to t in H, such that every path in P(cid:48) is monotone with
respect to C.

We now deﬁne monotonicity with respect to a family of cycles.
Deﬁnition 2.8 Let H be a graph, Z = (Z1, . . . , Zr) a collection of r disjoint cycles, and P a collection
of node-disjoint paths in H. We say that the paths in P are monotone with respect to Z, iﬀ for every
1 ≤ h ≤ r, every path in P is monotone with respect to Zh.

The following theorem allows us to re-route sets of paths so they become monotone with respect to a
given family of tight concentric cycles. Its proof is a simple application of Lemma 2.4 and is deferred
to the Appendix.

so that the paths of P are internally disjoint from V (C) ∪ V (Y ). Let H(cid:48) = ((cid:83)r

Theorem 2.5 Let H be a planar graph embedded in the plane, C any simple closed H-normal curve
or a simple cycle in H, and Z = (Z1, . . . , Zr) a family of r tight concentric cycles in H around C.
Let Y (cid:40) H be any connected subgraph of H lying completely outside of D(Zr), and let P be a set of κ
node-disjoint paths, connecting a subset A ⊆ V (C) of κ vertices to a subset B ⊆ V (Y ) of κ vertices,
h=1 V (Zh)) ∪ P. Then
there is an eﬃcient algorithm to compute a collection P(cid:48) of κ node-disjoint paths in H(cid:48), connecting
the vertices of A to the vertices of B, so that the paths in P(cid:48) are monotone with respect to Z, and they
are internally node-disjoint from V (C) ∪ V (Y ).

3 Routing on a Disc and on a Cylinder

In this section we prove Theorem 1.1. In order to do so, we deﬁne a new problem, called Demand Pair
Selection Problem (DPSP), and show an 8-approximation algorithm for it. We then show that both
NDP-Disc and NDP-Cylinder reduce to DPSP.

Demand Pair Selection Problem We assume that we are given two disjoint directed paths, σ
and σ(cid:48), and a collection M = {(s1, t1), . . . , (sk, tk)} of pairs of vertices of σ∪ σ(cid:48) that are called demand
pairs, where all vertices of S = {s1, . . . , sk} lie on σ, and all vertices of T = {t1, . . . , tk} lie on σ(cid:48)

9

(not necessarily in this order). We refer to the vertices of S and T as the source and the destination
vertices, respectively. Note that the same vertex of σ may participate in several demand pairs, and
the same is true for the vertices of σ(cid:48). Given any pair a, a(cid:48) of vertices of σ, with a lying before a(cid:48) on σ,
we sometimes denote by (a, a(cid:48)) the sub-path of σ between a and a(cid:48) (that includes both these vertices),
and we will sometimes refer to it as an interval. We deﬁne intervals of σ(cid:48) similarly.
For every pair v, v(cid:48) ∈ V (σ) of vertices, we denote v ≺ v(cid:48) if v lies strictly before v(cid:48) on σ, and we denote
v (cid:22) v(cid:48), if v ≺ v(cid:48) or v = v(cid:48) hold. Similarly, for every pair v, v(cid:48) ∈ V (σ(cid:48)) of vertices, we denote v ≺ v(cid:48) if
v lies strictly before v(cid:48) on σ(cid:48), and we denote v (cid:22) v(cid:48), if v ≺ v(cid:48) or v = v(cid:48) hold. We need the following
deﬁnitions.
Deﬁnition 3.1 Suppose we are given two pairs (a, b) and (a(cid:48), b(cid:48)) of vertices of σ ∪ σ(cid:48), with a, a(cid:48) ∈ σ
and b, b(cid:48) ∈ σ(cid:48). We say that (a, b) and (a(cid:48), b(cid:48)) cross iﬀ one of the following holds: either (i) a = a(cid:48); or
(ii) b = b(cid:48); or (iii) a ≺ a(cid:48) and b(cid:48) ≺ b; or (iv) a(cid:48) ≺ a and b ≺ b(cid:48).
Deﬁnition 3.2 We say that a subset M(cid:48) ⊆ M of demand pairs is non-crossing iﬀ for all distinct
pairs (s, t), (s(cid:48), t(cid:48)) ∈ M(cid:48), (s, t) and (s(cid:48), t(cid:48)) do not cross.
Our goal is to select the largest-cardinality non-crossing subset M(cid:48) ⊆ M of demand pairs, satisfying
a collection K of constraints. Set K of constraints is given as part of the problem input, and consists
of four subsets, K1, . . . ,K4, where constraints in set Ki are called type-i constraints. Every constraint
K ∈ K is speciﬁed by a quadruple (i, a, b, w), where i ∈ {1, 2, 3, 4} is the constraint type, a, b ∈
V (σ ∪ σ(cid:48)), and 1 ≤ w ≤ |M| is an integer.
For every type-1 constraint K = (1, a, b, w) ∈ K1, we have a, b ∈ V (σ) with a ≺ b. The constraint is
associated with the sub-path I = (a, b) of σ. We say that a subset M(cid:48) ⊆ M of demand pairs satisﬁes
K iﬀ the total number of the source vertices participating in the demand pairs of M(cid:48) that lie on I is
at most w.
Similarly, for every type-2 constraint K = (2, a, b, w) ∈ K2, we have a, b ∈ V (σ(cid:48)) with a ≺ b, and the
constraint is associated with the sub-path I = (a, b) of σ(cid:48). A set M(cid:48) ⊆ M of demand pairs satisﬁes
K iﬀ the total number of the destination vertices participating in the demand pairs in M(cid:48) that lie on
I is at most w.
For each type-3 constraint K = (3, a, b, w) ∈ K3, we have a ∈ V (σ) and b ∈ V (σ(cid:48)). The constraint
is associated with the sub-path La of σ between the ﬁrst vertex of σ and a (including both these
vertices), and the sub-path Rb of σ(cid:48) between b and the last vertex of σ(cid:48) (including both these vertices).
We say that a demand pair (s, t) ∈ M crosses K iﬀ s ∈ La and t ∈ Rb. A set M(cid:48) ⊆ M of demand
pairs satisﬁes K iﬀ the total number of pairs (s, t) ∈ M(cid:48) that cross K is bounded by w.
Finally, for each type-4 constraint K = (4, a, b, w) ∈ K4, we also have a ∈ V (σ) and b ∈ V (σ(cid:48)). The
constraint is associated with the sub-path Ra of σ between a and the last vertex of σ (including both
these vertices), and the sub-path Lb of σ(cid:48) between the ﬁrst vertex of σ(cid:48) and b (including both these
vertices). We say that a demand pair (s, t) ∈ M crosses K iﬀ s ∈ Ra and t ∈ Lb. A set M(cid:48) ⊆ M of
demand pairs satisﬁes K iﬀ the total number of pairs (s, t) ∈ M(cid:48) that cross K is bounded by w.
Given the paths σ, σ(cid:48), the set M of the demand pairs, and the set K of constraints as above, the goal in
the DPSP problem is to select a maximum-cardinality non-crossing subset M(cid:48) ⊆ M of demand pairs,
such that all constraints in K are satisﬁed by M(cid:48). The proof of the following theorem is deferred to
the Appendix.

Theorem 3.1 There is an eﬃcient 8-approximation algorithm for DPSP.

10

We then use Theorem 3.1 in order to design O(log k)-approximation algorithms for NDP-Disc and
NDP-Cylinder. The remainder of the proof of Theorem 1.1 appears in Section B of the Appendix.
The algorithm for NDP-Disc exploits the exact characterization of routable instances of the problem
given by Robertson and Seymour [RS86], in order to reduce the problem to DPSP. The algorithm for
NDP-Cylinder reduces the problem to NDP-Disc and DPSP.

4 Algorithm Setup

The rest of this paper mostly focuses on proving Theorem 1.2; we prove Theorem 1.3 using the
techniques we employ for the proof of Theorem 1.2 in Section 8.

We assume without loss of generality that the input graph G is connected - otherwise we can solve
the problem separately on each connected component of G. Let T = T (M). It is convenient for us
to assume that every terminal participates in exactly one demand pair, and that the degree of every
terminal is 1. This can be achieved via a standard transformation of the input instance, where we add
a new collection of terminals, connecting them to the original terminals. This transformation preserves
planarity, but unfortunately it can increase the number of the graph vertices. If the original graph G
contained n vertices, then |M| can be as large as n2, and so the new graph may contain up to n2 + n
vertices, while our goal is to obtain an ˜O(n9/19)-approximation. In order to overcome this diﬃculty,
we denote by N the number of the non-terminal vertices in the new graph G, so N is bounded by the
total number of vertices in the original graph, and by n the total number of all vertices in the new
graph, so n = O(N 2). Our goal is then to obtain an eﬃcient O(N 9/19 · poly log n)-approximation for
the new problem instance. From now on we assume that every terminal participates in exactly one
demand pair, and the degree of every terminal is 1. If (s, t) is a demand pair, then we say that s is the
mate of t, and t is the mate of s. We denote |M| = k. Throughout the algorithm, we deﬁne a number
of sub-instances of the instance (G,M), but we always use k to denote the number of the demand
pairs in this initial instance. We can assume that k > 100, as otherwise we can return a routing of a
single demand pair.

We assume that we are given a drawing of G on the sphere. Throughout the algorithm, we will
sometimes select some face of G as the outer face, and consider the resulting planar drawing of G.

4.1 LP-Relaxations
Let us start with the standard multicommodity ﬂow LP-relaxation of the problem. Let G(cid:48) be the
directed graph, obtained from G by bi-directing its edges. For every edge e ∈ E(G(cid:48)), for each 1 ≤ i ≤ k,
there is an LP-variable fi(e), whose value is the amount of the commodity-i ﬂow through edge e. We
denote by xi the total amount of commodity-i ﬂow sent from si to ti. For every vertex v, let δ+(v) and
δ−(v) denote the sets of its out-going and in-coming edges, respectively. We denote [k] = {1, . . . , k}.
The standard LP-relaxation of the NDP problem is as follows.

11

(LP-ﬂow1)

max

s.t.

i=1 xi

(cid:80)k
(cid:80)
e∈δ+(v) fi(e) =(cid:80)
(cid:80)
(cid:80)
(cid:80)k
i=1 fi(e) ≤ 1

e∈δ+(si) fi(e) = xi

e∈δ+(v)

fi(e) ≥ 0

∀i ∈ [k]

e∈δ−(v) fi(e) ∀i ∈ [k],∀v ∈ V (G
(cid:48)

∀v ∈ V (G
(cid:48)
∀i ∈ [k],∀e ∈ E(G

)

(cid:48)

)

) \ {si, ti}

(ﬂow conservation)

(vertex capacity constraints)

optimal solution, and instead of the objective function, we will add the constraint(cid:80)k
We will make two changes to (LP-ﬂow1). First, we will assume that we know the value X∗ of the
(cid:17)
i=1 xi ≥ X∗. We
can do so using standard methods, by repeatedly guessing the value X∗ and running the algorithm
for each such value. It is enough to show that the algorithm routes Ω
demand pairs,
when the value X∗ is guessed correctly.
Recall that for a subset M(cid:48) ⊆ M of the demand pairs, and a sub-graph H ⊆ G, OPT(H,M(cid:48)) denotes
the value of the optimal solution to instance (H,M(cid:48)). For every subset M(cid:48) ⊆ M of the demand pairs,
we add the constraint that the total ﬂow between all pairs in M(cid:48) is no more than z, for all integers
z between OPT(G,M(cid:48)) and k. We now obtain the following linear program that has no objective
function, so we are only interested in ﬁnding a feasible solution.

N 9/19·poly log n

(cid:16)

X∗

(LP-ﬂow2)

e∈δ+(si) fi(e) = xi

(cid:80)k
(cid:80)
i=1 xi ≥ X∗
e∈δ+(v) fi(e) =(cid:80)
(cid:80)
(cid:80)
(cid:80)k
(cid:80)
i=1 fi(e) ≤ 1
(si,ti)∈M(cid:48) xi ≤ z
fi(e) ≥ 0

e∈δ+(v)

∀i ∈ [k]

e∈δ−(v) fi(e) ∀i ∈ [k],∀v ∈ V (G
(cid:48)

(2)
) \ {si, ti} (ﬂow conservation)(3)
(vertex capacity constraints) (4)

)

∀v ∈ V (G
(cid:48)
∀M(cid:48) ⊆ M,∀z ∈ Z : OPT(G,M(cid:48)
∀i ∈ [k],∀e ∈ E(G
(cid:48)

)

) ≤ z ≤ k

(1)

(5)

(6)

We say that a solution to (LP-ﬂow2) is semi-feasible iﬀ all constraints of types (1)–(4) and (6) are
satisﬁed. Notice that the number of the constraints in (LP-ﬂow2) is exponential in k. In order to solve
it, we will use the Ellipsoid Algorithm with a separation oracle, where our approximation algorithm
itself will serve as the separation oracle. This is done via the following theorem, which is our main
technical result.

Theorem 4.1 There is an eﬃcient algorithm, that, given any semi-feasible solution to (LP-ﬂow2),
demand pairs of M via node-disjoint paths, or
either computes a routing of at least Ω
returns a constraint of type (5), that is violated by the current solution.

We can now obtain an O(cid:0)N 9/19 · poly log n(cid:1)-approximation algorithm for NDP-Planar via the Ellipsoid
(cid:17)

algorithm. In every iteration, we start with some semi-feasible solution to (LP-ﬂow2), and apply the
algorithm from Theorem 4.1 to it.

If the outcome is a solution routing at least Ω

N 9/19·poly log n

(cid:16)

X∗

X∗

N 9/19·poly log n

(cid:16)

(cid:17)

12

demand pairs in M, then we obtain the desired approximate solution to the problem, assuming that
X∗ was guessed correctly. Otherwise, we obtain a violated constraint of type (5), and continue to the
next iteration of the Ellipsoid Algorithm. Since the Ellipsoid Algorithm is guaranteed to terminate
with a feasible solution after a number of iterations that is polynomial in the number of the LP-
variables, this gives an algorithm that is guaranteed to return a solution of value Ω
in
time poly(n). From now on we focus on proving Theorem 4.1.

N 9/19·poly log n

(cid:17)

(cid:16)

X∗

We note that, using standard techniques, we can eﬃciently obtain a ﬂow-paths decomposition of any
semi-feasible solution to (LP-ﬂow2): we can eﬃciently ﬁnd, for every demand pair (si, ti), a collection
Pi of paths, connecting si to ti, and for each path P ∈ Pi, compute a value f (P ), such that:

• For each i ∈ [k],(cid:80)
• For each v ∈ V (G),(cid:80)

• For each i ∈ [k], |Pi| ≤ n; and

(cid:80)

P∈Pi f (P ) = xi;

i∈[k]

P∈Pi:
v∈P

f (P ) ≤ 1.

It is sometimes more convenient to work with the above ﬂow-paths decomposition version of a given
semi-feasible solution to (LP-ﬂow2).

2j < xi ≤ 1

We now assume that we are given some semi-feasible solution (x, f ) to (LP-ﬂow2), and deﬁne a new
fractional solution based on it, where the ﬂow between every demand pair is either 0 or w∗, for some
value w∗ > 0. First, for each demand pair (si, ti) with xi ≤ 1
2k , we set xi = 0 and we set the
corresponding ﬂow values fi(e) for all edges e ∈ E to 0. Since we can assume that X∗ ≥ 1 if the
graph is connected, the total amount of ﬂow between the demand pairs remains at least X∗/2. We
then partition the remaining demand pairs into q = (cid:100)log 2k(cid:101) subsets, where for 1 ≤ j ≤ q, set Mj
2j−1 . There is some index 1 ≤ j∗ ≤ q, such that
contains all demand pairs (si, ti) with 1
the total ﬂow between the demand pairs in Mj∗ is at least Ω(X∗/ log k). Let w∗ = 1
2j . We further
modify the LP-solution, as follows. First, for every demand pair (si, ti) (cid:54)∈ Mj∗, we set xi = 0, and the
corresponding ﬂow values fi(e) for all edges e ∈ E to 0. Next, for every demand pair (si, ti) ∈ Mj∗, we
let βi = w∗/xi, so βi ≤ 1. We set xi = w∗, and the new ﬂow values fi(e) are obtained by scaling the
original values by factor βi. This gives a new solution to (LP-ﬂow2), that we denote by (x(cid:48), f(cid:48)). The
total amount of ﬂow sent in this solution is Ω(X∗/ log k), and it is easy to verify that constraints (2)–
(4) and (6) are satisﬁed. For every demand pair (si, ti) ∈ Mj∗, x(cid:48)
i = w∗, and for all other demand
i ≤ xi. Therefore, if we
(cid:16)
pairs (si, ti), x(cid:48)
i = 0. It is easy to see that for every demand pair (si, ti), x(cid:48)
ﬁnd a constraint of type (5) that is violated by the new solution, then it is also violated by the old
X∗
solution. Our goal now is to either ﬁnd an integral solution routing Ω
demand pairs,
or to ﬁnd a constraint of type (5) violated by the new LP-solution. In particular, if we ﬁnd a subset
M(cid:48) ⊆ Mj∗ of demand pairs, with OPT(G,M(cid:48)) ≤ w∗|M(cid:48)|/2, then set M(cid:48) deﬁnes a violated constraint
of type (5) for (LP-ﬂow2). Since from now on we only focus on demand pairs in Mj∗, for simplicity
we denote M = Mj∗.

N 9/19·poly log n

(cid:17)

4.2 Well-Linked Decomposition

Like many other approximation algorithms for routing problems, we decompose our input instance
into a collection of sub-instances that have some useful well-linkedness properties. Since the routing is
on node-disjoint paths, we need to use a slightly less standard notion of node-well-linkedness, deﬁned
below. Throughout this paper, we use a parameter αWL =

w∗

512·αAKR·log k .

13

Deﬁnition 4.1 Given a graph H and a set T (cid:48) of its vertices, we say that T (cid:48) is αWL-well-linked in
H iﬀ for every pair T1,T2 of disjoint equal-sized subsets of T , there is a set P of at least αWL · |T1|
node-disjoint paths in H, connecting vertices of T1 to vertices of T2.
Deﬁnition 4.2 Given a sub-graph H ⊆ G and a subset M(cid:48) ⊆ M of demand pairs with T (M(cid:48)) ⊆
V (H), we say that (H,M(cid:48)) is a well-linked instance, iﬀ T (M(cid:48)) is αWL-well-linked in H.

The following theorem uses standard techniques, and its proof is deferred to Appendix.

Theorem 4.2 There is an eﬃcient algorithm to compute a collection G1, . . . , Gr of disjoint sub-graphs
of G, and for each 1 ≤ j ≤ r, a set Mj ⊆ M of demand pairs with T (Mj) ⊆ V (Gj), such that:

• For all 1 ≤ j ≤ r, (Gj,Mj) is a well-linked instance;
• For all 1 ≤ j (cid:54)= j(cid:48) ≤ r, there is no edge in G with one endpoint in Gj and the other in Gj(cid:48);

j=1 |Mj| ≥ 63|M|/64; and

• (cid:80)r
• (cid:12)(cid:12)(cid:12)V (G) \(cid:16)(cid:83)r
ﬂow solution and let W =(cid:80)r

j=1 V (Gj)

(cid:17)(cid:12)(cid:12)(cid:12) ≤ w∗·|M|

64

.

For each 1 ≤ j ≤ r, let Wj = w∗|Mj| be the contribution of the demand pairs in Mj to the current
j=1 Wj = Ω(X∗/ log k). Let nj = |V (Gj)|, and let Nj be the number of

the non-terminal vertices in Gj. The main tool in proving Theorem 4.1 is the following theorem.
Theorem 4.3 There is an eﬃcient algorithm, that computes, for every 1 ≤ j ≤ r, one of the following:

(cid:16)

(cid:17)

1. Either a collection P j of node-disjoint paths, routing Ω

in Gj; or

W

1/19
j

/ poly log n

demand pairs of Mj

2. A collection ˜Mj ⊆ Mj of demand pairs, with | ˜Mj| ≥ |Mj|/2, such that OPT(Gj, ˜Mj) ≤

w∗| ˜Mj|/8.

Before we prove Theorem 4.3, we show that Theorem 4.1 follows from it. We apply Theorem 4.3
to every instance (Gj,Mj), for 1 ≤ j ≤ r. We say that instance (Gj,Mj) is a type-1 instance,
if the ﬁrst outcome happens for it, and we say that it is a type-2 instance otherwise. Let I1 =

(cid:8)j | (Gj,Mj) is a type-1 instance(cid:9), and similarly, I2 =(cid:8)j | (Gj,Mj) is a type-2 instance(cid:9). We con-
sider two cases, where the ﬁrst case happens when(cid:80)
Case 1: (cid:80)

j∈I1 Wj ≥ W/2. We show that in this case, our algorithm returns a routing of Ω

j∈I1 Wj ≥ W/2.

(cid:16)

X∗

N 9/19·poly log n

(cid:17)

demand pairs. We need the following lemma, whose proof is deferred to the Appendix. The proof uses
standard techniques: namely, we show that the treewidth of each graph Gj is at least Ω(Wj/ log k),
and so Gj must contain a large grid minor.
Lemma 4.4 For each 1 ≤ j ≤ r, Nj ≥ Ω(W 2
The number of the demand pairs we route in each type-1 instance (Gj,Mj) is then at least:

j / log2 k).

14

(cid:32)

Ω

W

1/19
j

poly log n

(cid:33)

(cid:32)
(cid:32)
(cid:18)

= Ω

= Ω

(cid:33)

(cid:19)

Wj
· poly log n

W

18/19
j

(cid:0)(cid:112)Nj log k(cid:1)18/19 · poly log n

Wj

(cid:33)

Wj

.

1
4

x

= Ω

N 9/19 · poly log n

.

Ω

(7)

X∗

N 9/19·poly log n

Overall, since (cid:80)
(cid:16)
(cid:17)
j∈I1 Wj ≥ W/2, the number of the demand pairs routed is Ω
Case 2: (cid:80)
j∈I2 Wj ≥ W/2. Let M(cid:48) = (cid:83)
(cid:80)r
j=1 |Mj| ≥ |M|
solution, is a valid constraint of (LP-ﬂow2):(cid:88)

˜Mj. Then |M(cid:48)| = (cid:80)

|Mj|
2 ≥
8 . We claim that the following inequality, that is violated by the current LP-

(cid:16)

(cid:17)

=

W

N 9/19·poly log n

| ˜Mj| ≥ (cid:80)

j∈I2

j∈I2

j∈I2

j∈I2

j∈I2

(si,ti)∈M(cid:48)

j=1 V (Gj)

∗|M(cid:48)|/2.

8 ≤ |P∗|

bad if it contains a vertex of V (G) \(cid:16)(cid:83)r
of P∗. Then, on the one hand,(cid:80)

In order to do so, it is enough to prove that OPT(G,M(cid:48)) < w∗|M(cid:48)|/2. Assume otherwise, and let
P∗ be the optimal solution for instance (G,M(cid:48)), so |P∗| ≥ w∗|M(cid:48)|/2. We say that a path P ∈ P∗ is
. The number of such bad paths is bounded by

i ≤ w
(cid:48)
(cid:17)
64 ≤ w∗|M(cid:48)|
the number of such vertices - namely, at most w∗·|M|
2 . Therefore, at least w∗|M(cid:48)|/4
paths in P∗ are good. Each such path must be contained in one of the graphs Gj corresponding to a
| ˆMj| ≥ w∗|M(cid:48)|/4 = w∗(cid:80)
type-2 instance. For each j ∈ I2, let ˆMj ⊆ ˜Mj be the set of the demand pairs routed by good paths
| ˜Mj|/4, while, on the other hand,
since all demand pairs in ˆMj can be routed simultaneously in Gj, for all j ∈ I2, | ˆMj| ≤ w∗| ˜Mj|/8, a
contradiction. We conclude that OPT(G,M(cid:48)) < w∗|M(cid:48)|/2, and (7) is a valid constraint of (LP-ﬂow2).
From now on, we focus on proving Theorem 4.3. Since from now on we only consider one instance
(Gj,Mj), for simplicity, we abuse the notation and denote Gj by G, and Mj by M. As before,
we denote T = T (M). We denote by W = w∗ · |M| the total amount of ﬂow sent between the
demand pairs in the new set M in the LP solution (note that this is not necessarily a valid LP-
solution for the new instance, as some of the ﬂow-paths may use vertices lying outside of Gj). We
use n to denote the number of vertices in G. Value k - the number of the demand pairs in the
original instance - remains unchanged. Our goal is to either ﬁnd a collection of node-disjoint paths
routing Ω(W 1/19/ poly(log(nk))) demand pairs of M in G, or to ﬁnd a collection ˜M ⊆ M of at least
|M|/2 demand pairs, such that OPT(G, ˜M) ≤ w∗| ˜M|/8. We will rely on the fact that all terminals
are αWL-well-linked in G, for αWL = Θ(w∗/ log k). We assume that G is connected, since otherwise
all terminals must be contained in a single connected component of G and we can discard all other
connected components.
We assume that we are given an embedding of the graph G into the sphere. For every pair v, v(cid:48) ∈ V (G)
of vertices, we let dGNC(v, v(cid:48)) be the length of the shortest G-normal curve connecting v to v(cid:48) in this
embedding, minus 1. It is easy to verify that dGNC is a metric: that is, dGNC(v, v) = 0, dGNC(v, v(cid:48)) =
dGNC(v(cid:48), v), and the triangle inequality holds for dGNC. The value dGNC(v, v(cid:48)) can be computed

15

eﬃciently, by solving an appropriate shortest path problem instance in the graph dual to G. Given a
vertex v and a subset U of vertices of G, we denote by dGNC(v, U ) = minu∈U {dGNC(v, u)}. Similarly,
given two subsets U, U(cid:48) of vertices of G, we denote dGNC(U, U(cid:48)) = minu∈U,u(cid:48)∈U(cid:48) {dGNC(u, u(cid:48))}. Finally,
given a G-normal curve C, and a vertex v in G, we let dGNC(v, C) = minu∈V (C) {dGNC(v, u)}.
Over the course of the algorithm, we will sometimes select some face of the drawing of G as the outer
face and consider the resulting drawing of G in the plane. The function dGNC remains unchanged,
and it is only deﬁned with respect to the ﬁxed embedding of G into the sphere.

5 Enclosures, Shells, and Terminal Subsets

In this section we develop some of the technical machinery that we use in our algorithm, and describe
the ﬁrst steps of the algorithm. We start with enclosures around the terminals.

5.1 Constructing Enclosures

Throughout the algorithm, we use a parameter ∆ = (cid:6)W 2/19(cid:7). We assume that W > Ω(∆), since

otherwise W is bounded by a constant, and we can return the routing of a single demand pair. The
goal of this step is to construct enclosures around the terminals, that are deﬁned below. Recall that
G is embedded on the sphere.
Deﬁnition 5.1 An enclosure for terminal t ∈ T is a simple disc Dt containing the terminal t, whose
boundary is denoted by Ct, that has the following properties. (Recall that V (Dt) is the set of all vertices
of G contained in Dt.)

• Ct is a simple closed G-normal curve with (cid:96)(Ct) = ∆;
• |T ∩ V (Dt)| ≤ 4∆/αWL; and
• V (Dt) induces a connected graph in G.

The goal of this section is to prove the following theorem.

Theorem 5.1 There is an eﬃcient algorithm, that constructs an enclosure Dt for every terminal
t ∈ T , such that for all t, t(cid:48) ∈ T :

• If Dt ⊆ Dt(cid:48), then Dt = Dt(cid:48); and
• If Dt ∩ Dt(cid:48) = ∅, then there are ∆ node-disjoint paths between V (Ct) and V (Ct(cid:48)) in G.

Notice that since (cid:96)(Ct) = ∆, every vertex of V (Ct) is an endpoint of a path connecting V (Ct) to
V (Ct(cid:48)). In order to prove the theorem, we need the following two simple claims.

Claim 5.2 Let D be any disc on the sphere, whose boundary C is a simple G-normal curve, such that
1 ≤ |V (D)| < |V (G)| − 1, and G[V (D)] is connected (we allow D to consist of a single point, which
must coincide with a vertex of G). Then we can eﬃciently ﬁnd a disc D(cid:48) with V (D) (cid:40) V (D(cid:48)) and
|V (D(cid:48))| = |V (D)| + 1, such that G[V (D(cid:48))] is a connected graph. Moreover, if C(cid:48) is the boundary of
D(cid:48), then C(cid:48) is a simple G-normal curve with (cid:96)(C(cid:48)) = (cid:96)(C) + 1.

16

Proof: If D consists of a single point corresponding to a vertex v ∈ V (G), then let u be any neighbor
of v in G. It is easy to construct a disc D(cid:48) whose boundary only contains the vertices v and u, and
has all the required properties, with V (D(cid:48)) = {v, u}. We now assume that |V (D)| > 1.
Let u ∈ V (C) be any vertex that has a neighbor in V (G) \ V (D): since G is connected and |V (D)| <
|V (G)|, such a vertex exists. Let u(cid:48) be a vertex lying next to u on C. Then there must be a vertex
v ∈ V (G) \ V (D), such that: (i) edge e = (u, v) belongs to G; and (ii) there is a simple G-normal
curve γ(cid:48) connecting u(cid:48) to v, that intersects G only at its endpoints, and intersects D only at u(cid:48). Let
σ, σ(cid:48) be the two segments of C whose endpoints are u and u(cid:48).
Notice that due to the edge e = (u, v), there is also a G-normal curve γ connecting u to v, that
intersects G only at its endpoints, and intersects D only at u. Let C1 be the concatenation of σ, γ and
γ(cid:48), and let C2 be the concatenation of σ(cid:48), γ and γ(cid:48).
Let x ∈ V (G) \ (V (D) ∪ {v}) be any vertex (such a vertex exists since |V (D)| < |V (G)| − 1), and let
F be any face in the drawing of G∪ C ∪ γ ∪ γ(cid:48) incident on x. We can view the face F as the outer face
of our drawing, to obtain a drawing of G ∪ C ∪ γ ∪ γ(cid:48) in the plane. Using this view, curve C1 deﬁnes
a disc D1 and curve C2 deﬁnes a disc D2 in the plane. Exactly one of these discs contains the disc D
- assume w.l.o.g. that it is D1. We then set D(cid:48) = D1 and C(cid:48) = C1. It is now immediate to verify that
D(cid:48) has all required properties.

Claim 5.3 Let H be any connected planar graph drawn on a sphere, and let s and t be two distinct
vertices of H. Assume that the maximum number of internally node-disjoint paths between s and t
in H is κ. Then we can eﬃciently ﬁnd a simple closed H-normal curve C of length κ on the sphere,
separating s from t, with s, t (cid:54)∈ V (C). Moreover, if U and U(cid:48) denote the sets of vertices lying strictly
on each side of C, then H[U ∪ V (C)] and H[U(cid:48) ∪ V (C)] are both connected.

is the path containing s, so P t

i contains t.

i

i , P t

Proof: By Menger’s theorem, we can eﬃciently ﬁnd a set X ⊆ V (H) \ {s, t} of κ vertices such that
s and t are separated in the graph H \ X.
Let P = {P1, . . . , Pκ} be any set of κ internally node-disjoint paths connecting s to t in H, and let
H(cid:48) be the sub-graph of H obtained by taking the union of the paths in P. The drawing of H(cid:48) on the
sphere consists of κ faces, where the boundary of each face is the union of two distinct paths in P.
We assume that the faces are F1, . . . , Fκ, and we assume without loss of generality that the boundary
of each face Fi is Pi ∪ Pi+1 (and the boundary of Fκ is Pκ ∪ P1). Notice that for each 1 ≤ i ≤ κ,
X contains exactly one internal vertex of Pi, that we denote by xi. Let P s
i be the two paths in
Pi \ {xi}, where P s
Fix some 1 ≤ i ≤ κ, and let Hi ⊆ H be the graph induced by all vertices lying inside Fi or on its
i = Hi \ {xi, xi+1}. Then there is no path in H(cid:48)
boundary. Let H(cid:48)
i+1 to
i+1: such a path would contradict the fact that s is disconnected from t in H \ X.
i ∪ P t
a vertex of P t
Therefore, there is a curve γi, connecting xi to xi+1 inside Fi, that intersects H only at its endpoints.
Curve γi partitions Fi into two subfaces: F (cid:48)
i and F (cid:48)(cid:48)
i and t lying
on the boundary of F (cid:48)(cid:48)
i . Since H is a connected graph, and γi only intersects H at its endpoints,
both subgraphs induced by the vertices lying in F (cid:48)
i and its boundary, are
connected.
We build the curve C by concatenating all curves γi for 1 ≤ i ≤ κ. It is easy to verify that C has all
required properties.

i , with s lying on the boundary of F (cid:48)
i and its boundary, and in F (cid:48)(cid:48)

i connecting a vertex of P s

i ∪ P s

Proof of Theorem 5.1. We show an eﬃcient algorithm to construct the enclosures with the desired
properties. Throughout the algorithm, we maintain a set {Dt}t∈T of enclosures, such that for every
pair t, t(cid:48) ∈ T of terminals, if Dt ⊆ Dt(cid:48), then Dt = Dt(cid:48).

17

The initial set of enclosures is obtained as follows. For each terminal t ∈ T , let D(cid:48)
t be the disc
containing a single point - the image of the vertex t. We apply Claim 5.2 ∆− 1 times to D(cid:48)
t, to obtain
t ⊆ Dt, while |V (Dt)| = ∆.
a disc Dt whose boundary is a simple G-normal curve of length ∆, and D(cid:48)
By Claim 5.2, V (Dt) induces a connected sub-graph in G. Since |V (Dt)| = ∆, Dt is a valid enclosure
for t. While there is a pair t, t(cid:48) of terminals with Dt (cid:40) Dt(cid:48), we set Dt = Dt(cid:48). This ﬁnishes the
deﬁnition of the initial set of enclosures. We then perform a number of iterations. In every iteration,
we consider all pairs t, t(cid:48) of terminals with Dt ∩ Dt(cid:48) = ∅, and check whether there are ∆ node-disjoint
paths connecting the vertices of V (Ct) to the vertices of V (Ct(cid:48)) in G. If so, then we say that (t, t(cid:48)) is
a good pair. If all such pairs are good, then we terminate the algorithm, and output the current set
of enclosures. Otherwise, let (t, t(cid:48)) be a bad pair. Let H be the graph constructed from G, as follows:
we delete all vertices of V (Dt \ Ct), and add a source vertex a to the interior of Dt. We then connect
a to every vertex of V (Ct) with an edge. Similarly, we delete all vertices of V (Dt(cid:48) \ Ct(cid:48)), and add a
destination vertex b to the interior of Dt(cid:48). We then connect b to every vertex of V (Ct(cid:48)).
Let κ ≤ ∆ − 1 be the maximum number of internally node-disjoint paths connecting a to b in H. We
apply Claim 5.3 to ﬁnd an H-normal closed curve C of length κ, separating a from b. Then C deﬁnes
a G-normal curve of length κ, such that, if U and U(cid:48) denote the sets of vertices of G lying strictly on
each side of C, then V (Dt) ⊆ U ∪ V (C); V (Dt(cid:48)) ⊆ U(cid:48)∪ V (C); and both G[U ∪ V (C)] and G[U(cid:48)∪ V (C)]
are connected.
Notice that either |U ∩T | ≤ |T |/2 or |U(cid:48) ∩T | ≤ |T |/2 holds - we assume w.l.o.g. that it is the former.
Let D be the disc whose boundary is C, with Dt ⊆ D. Since (cid:96)(C) < ∆, from the well-linkedness of
the terminals |V (D) ∩ T | ≤ ∆/αWL. We next apply Claim 5.2 to D repeatedly to obtain a disc D(cid:48),
whose boundary C(cid:48) is a simple G-normal curve of length ∆, so that D ⊆ D(cid:48); |V (D(cid:48))| ≤ |V (D)| + ∆,
and G[D(cid:48)] is a connected graph. It is easy to verify that D(cid:48) is a valid enclosure for terminal t. We
replace Dt with D(cid:48). If there is any terminal t(cid:48)(cid:48) with Dt(cid:48)(cid:48) (cid:40) D(cid:48), then we replace Dt(cid:48)(cid:48) with D(cid:48) as well.
t∈T |V (Dt)| increases by at least 1 in every
iteration, and so the number of iterations is bounded by |V (G)|.
(cid:3)

This ﬁnishes the description of an iteration. Notice that(cid:80)

Distances between terminals. For every pair t, t(cid:48) of terminals, we deﬁne the distance d(t, t(cid:48))
between t and t(cid:48) to be the length of the shortest G-normal open curve, with one endpoint in V (Ct)
and another in V (Ct(cid:48)). (Notice that if Dt ∩ Dt(cid:48) (cid:54)= ∅, then d(t, t(cid:48)) = 1). We repeatedly use the following
simple observation (a weak triangle inequality):
Observation 5.4 For all t, t(cid:48), t(cid:48)(cid:48) ∈ T , d(t, t(cid:48)(cid:48)) ≤ d(t, t(cid:48)) + d(t(cid:48), t(cid:48)(cid:48)) + ∆/2.

Proof: Let γ be a G-normal curve of length d(t, t(cid:48)) connecting a vertex of Ct to a vertex of Ct(cid:48), and
let γ(cid:48) be deﬁned similarly for d(t(cid:48), t(cid:48)(cid:48)). Let u, u(cid:48) ∈ V (Ct(cid:48)) be the vertices that serve as endpoints of
γ and γ(cid:48), respectively, and let σ be the shorter of the two segments of Ct(cid:48) between u and u(cid:48), so the
length of σ is at most ∆/2 + 2. By combining γ, σ and γ(cid:48), we obtain a G-normal curve of length at
most d(t, t(cid:48)) + d(t(cid:48), t(cid:48)(cid:48)) + ∆/2, connecting a vertex of Ct to a vertex of Ct(cid:48)(cid:48).

5.2 Constructing Shells
Suppose we are given some terminal t ∈ T and an integer r ≥ 1. In this section we show how to
construct a shell of depth r around t, and explore its properties. Shells play a central role in our
algorithm. In order to construct the shell, we need to ﬁx a plane drawing of the graph G, by choosing
one of the faces Ft of the drawing of G on the sphere as the outer face. The choice of the face Ft will
aﬀect the construction of the shell, but once the face Ft is ﬁxed, the shell construction is ﬁxed as well.

18

We require that for every vertex v on the boundary of Ft, dGNC(v, Ct) ≥ r + 1, and that Ct separates
all vertices on the boundary of Ft from t. We note that when we construct shells for diﬀerent terminals
t, t(cid:48), we may choose diﬀerent faces Ft, Ft(cid:48), and thus obtain diﬀerent embeddings of G into the plane.
We now deﬁne a shell.
Deﬁnition 5.2 Suppose we are given a terminal t ∈ T , a face Ft in the drawing of G on the sphere,
and an integer r ≥ 1, such that for every vertex v on the boundary of Ft, dGNC(v, Ct) ≥ r + 1, and Ct
separates t from the boundary of Ft.
A shell Z r(t) of depth r around t with respect to Ft is a collection Z r(t) = (Z1(t), Z2(t), . . . , Zr(t)) of
r tight concentric cycles around Ct. In other words, all cycles Zh(t) are simple and disjoint from each
other, and the following properties hold. For each 1 ≤ h ≤ r, let D(Zh(t)) be the disc whose boundary
is Zh(t) in the planar drawing of G with Ft as the outer face. Then:

J1. Dt (cid:40) D(Z1(t)) (cid:40) D(Z2(t)) (cid:40) ··· (cid:40) D(Zr(t)); and
J2. for every 1 ≤ h ≤ r, if H is the graph obtained from G by contracting all vertices lying in
D(Zh−1(t)) into a super-node a, then Zh(t) = min-cycle(H, a) (when h = 1, we contract Dt into
a super-node a).

Notice that from this deﬁnition we immediately obtain the following additional properties:

J3. For every 1 ≤ h ≤ r, for every vertex v ∈ V (Zh(t)), there is a G-normal curve of length 2

connecting v to some vertex of V (Zh−1(t)) (or to a vertex of V (Ct) if h = 1).

J4. For every 1 ≤ h ≤ r, for every vertex v ∈ V (Zh(t)), there is a G-normal curve γ(v) of length
h + 1 connecting v to some vertex of V (Ct), so that γ(v) ⊆ D(Zh(t)), and it is internally disjoint
from Zh(t) and Ct.

Let ˜U be the set of all vertices v ∈ V (G) \ V (Dt), such that dGNC(v, Ct) < r + 1. Clearly, G \ ˜U (cid:54)= ∅,
since the vertices on the boundary of Ft do not lie in ˜U . We let Yt be the connected component of
G \ ˜U containing the vertices on the boundary of Ft. The following additional property follows from
the deﬁnition of the shell:

J5. All vertices of Yt lie outside D(Zr(t)).

Indeed, from Property (J4), for each 1 ≤ h ≤ r, Zh(t) ∩ Yt = ∅. Since Yt is connected, Zr(t) must
separate V (Dt) from Yt.

For convenience, we will always denote Z0(t) = Ct and D(Z0(t)) = Dt. Note that Z0(t) is not a cycle
in G – it is a simple closed G-normal curve, and so it is not part of the shell. We build the cycles
Z1(t), . . . , Zr(t) one-by-one, and we maintain the invariant that for each 1 ≤ h ≤ r, (Z1(t), . . . , Zh(t))
is a shell of depth h around t with respect to Ft.
Assume that we have deﬁned Z0(t), . . . , Zh−1(t) for some 1 ≤ h < r, such that the above invariant
holds.
In order to deﬁne Zh(t), consider the drawing of the graph G in the plane with Ft as the
outer face, and delete all vertices lying in D(Zh−1(t)) from it. Consider the face F where the deleted
vertices used to be. Let Γ be the inner boundary of F . Then Γ must contain a single simple cycle
Z, such that D(Zh−1(t)) ⊆ D(Z) (if no such cycle exists, then from Invariant (J4), for some vertex v
on the boundary of Ft, there is a G-normal curve of length at most r + 1 connecting v to Ct, which

19

contradicts the choice of Ft). We let Zh(t) = Z. It is easy to see that the invariant continues to hold.
This ﬁnishes the construction of the shell. We now study its properties.
For each 1 ≤ h ≤ r, we let Uh be the set of all vertices of G lying in D◦(Zh(t)) \ D(Zh−1(t)). Let Rh
be the set of all connected components of G[Uh]. Each connected component R ∈ Rh may have at
most one neighbor in V (Zh(t)) from the deﬁnition of the shell, and it may have a number of neighbors
in V (Zh−1(t)). We say that R ∈ Rh is a type-1 component if it has one neighbor in V (Zh(t)), and at
least one neighbor in V (Zh−1(t)). We denote by u(R) the unique neighbor of R in V (Zh(t)), and we
denote by L(R) the set of the neighbors of R that belong to V (Zh−1(t)). We say that R is a type-2
component, if it has at least one neighbor in V (Zh−1(t)) and no neighbors in V (Zh(t)). In this case,
we let L(R) be the set of the neighbors of R lying in V (Zh−1(t)), and u(R) is undeﬁned. Otherwise,
we say that it is a type-3 component. In this case, it has exactly one neighbor in V (Zh(t)), that we
denote by u(R), and no neighbors in V (Zh−1(t)), so we set L(R) = ∅ (see Figure 1(a)). We sometimes
refer to the vertices in set L(R) as the legs of R.

(a) The three types of components in Rh: R1 is of
type 1, R2 is of type 2, and R3 is of type 3.

(b) Deﬁnitions of vertices u(R) and segments σ(R)

Figure 1: Structure of the shells

Consider now any type-1 or type-2 component R ∈ Rh. For each such component R, we deﬁne a
If |L(R)| = 1, then let σ(R)
segment σ(R) of Zh−1(R) containing all vertices of L(R) as follows.
consist of the unique vertex of L(R). Otherwise, we let σ(R) be the smallest (inclusion-wise) segment
of Zh−1(t) containing all vertices of L(R), such that, if we let C be the union of σ(R) and the outer
boundary of the drawing of G[V (R) ∪ L(R)], then C separates R from t (see Figure 1(b)). Notice
that {σ(R) | R ∈ Rh is of type 1 or 2} is a nested set of segments of Zh−1(t). For consistency, for each
h=1 Rh. We will repeatedly use the

type-3 component R, we deﬁne σ(R) = ∅. We denote R = (cid:83)r

following theorem.
Theorem 5.5 There is an eﬃcient algorithm, that computes, for every 1 ≤ h ≤ r, for every compo-
nent R ∈ Rh, a disc η(R) ⊆ D(Zh(t)), whose boundary, denoted by γ(R), is a simple closed G-normal
curve of length at most 2h + 1 + ∆/2, such that:

1. For all R ∈ R, G[V (R) ∪ L(R)] ⊆ η(R), and, if u(R) is deﬁned, then u(R) ∈ η(R);

2. For all R ∈ R, γ(R) is disjoint from all vertices in(cid:83)

R(cid:48)∈R V (R(cid:48)). In particular, for all R(cid:48) ∈ R,

either R(cid:48) ⊆ η(R), or R(cid:48) lies completely outside η(R); and

3. For all 1 ≤ h ≤ r, for all R, R(cid:48) ∈ Rh, either η(R) ⊆ η(R(cid:48)), or η(R(cid:48)) ⊆ η(R), or η◦(R)∩ η◦(R(cid:48)) =

∅. Moreover, if R(cid:48) ⊆ η(R), then σ(R(cid:48)) ⊆ σ(R).

20

R1R2R3Zh−1(t)Zh(t)Ru(R)σ(R)R￿σ(R￿)Zh(t)Zh−1(t)h

h

h,R2
Proof: We use the planar drawing of G where Ft is the outer face. Fix some 1 ≤ h ≤ r. Let R1
h,
h be the sets of type-1, type-2, and type-3 components of Rh, respectively. For every type-3
and R3
component R ∈ R3
h, we let γ(R) be a simple closed G-normal curve containing a single vertex of G -
vertex u(R), such that the disc η(R), whose boundary is γ(R), contains R, and it is disjoint from all
other components of R.
Consider now any type-1 component R ∈ Rh, and let a(R), a(cid:48)(R) be the endpoints of σ(R). Let H ⊆ G
be obtained from G[V (R) ∪ L(R)], by adding all edges connecting u(R) to V (R) to it. We draw two
G-normal curves, γ1(R) connecting u(R) to a(R), and γ(cid:48)
1(R), connecting u(R) to a(cid:48)(R) on either side
of R, such that the curves γ1(R), γ(cid:48)
1(R) do not contain any other vertices of G, and they follow the
boundary of the drawing of H from the outside. Let γ(cid:48)(R) be the union of γ1(R) and γ(cid:48)
1(R), and let
η(cid:48)(R) be the disc whose boundary is the union of γ(cid:48)(R) and σ(R).
Similarly, given any type-2 component R ∈ Rh, we denote by a(R), a(cid:48)(R) be the endpoints of σ(R).
Let H = G[V (R) ∪ L(R)], and let γ(cid:48)(R) be a simple G-normal curve connecting a(R) to a(cid:48)(R), such
that γ(cid:48)(R) does not contain any other vertices of G, and it follows the boundary of the drawing of H
from the outside. Let η(cid:48)(R) be the disc whose boundary is the union of γ(cid:48)(R) and σ(R).

h, either η(cid:48)(R) ⊆ η(cid:48)(R(cid:48)), or η(cid:48)(R(cid:48)) ⊆ η(cid:48)(R), or the interiors of η(cid:48)(R) and η(cid:48)(R(cid:48)) are disjoint.
h ∪ R2
R1
Moreover, if η(cid:48)(R) ⊆ η(cid:48)(R(cid:48)), then σ(R) ⊆ σ(R(cid:48)). Notice that the curves γ(cid:48)(R) are disjoint from all

Clearly, we can draw the curves(cid:8)γ1(R), γ(cid:48)
vertices in(cid:83)
Let A =(cid:8)a(R), a(cid:48)(R) | R ∈ R1
γ(a) ⊆ D(Zh−1(t)). In particular, γ(a) must be disjoint from all vertices in (cid:83)

(cid:9), so that for all R, R(cid:48) ∈
(cid:9). Recall that from Property (J4), for every vertex a ∈ A, there

(cid:9) ∪(cid:8)γ(cid:48)(R) | R ∈ R2

1(R) | R ∈ R1

R(cid:48)(cid:48)∈R V (R(cid:48)(cid:48)).

h ∪ R2

h

h ∪R2

is a G-normal curve γ(a) of length at most h, connecting a to some vertex v ∈ V (Ct), such that
R∈R V (R), as it must
contain one vertex from each cycle Z1(t), . . . , Zh−1(t), and a vertex of Z0(t). Let Γ = {γ(a) | a ∈ A}.
We can assume without loss of generality that the curves in Γ are non-crossing, and moreover, whenever
two such curves meet, they continue together. In other words, if γ(a)∩γ(a(cid:48)) (cid:54)= ∅, then this intersection
is a simple G-normal curve that contains a vertex of Ct.
We say that a component R ∈ R1
h is good if γ(a(R)) and γ(a(cid:48)(R)) intersect, and we say that it is
bad otherwise. From our assumption, if R is good, then γ(a(R))∩ γ(a(cid:48)(R)) is a curve, connecting some
vertex v to some vertex of Ct. We then let γ(R) be the union of γ(cid:48)(R), the segment of γ(a(R)) from
a(R) to v, and the segment of γ(a(cid:48)(R)) from a(cid:48)(R) to v, and we let η(R) be the disc whose boundary
h, if η(cid:48)(R(cid:48)) ⊆ η(cid:48)(R), then R(cid:48) is also a good
is γ(R). Notice that for every component R(cid:48) ∈ R1
component, and η(R(cid:48)) ⊆ η(R).
For every bad component R ∈ R1
h, we let b(R), b(cid:48)(R) ∈ V (Ct) be the endpoints of γ(a(R)) and
γ(a(cid:48)(R)), respectively, and we let σ(cid:48)(R) be the segment of Ct, whose endpoints are b(R) and b(cid:48)(R),
such that the disc whose boundary is γ(cid:48)(R) ∪ σ(cid:48)(R) ∪ γ(a(R)) ∪ γ(a(cid:48)(R)) does not contain Dt.
Notice that the segments σ(cid:48)(R) for all bad components R form a nested set of intervals on Ct. This is
since their corresponding segments σ(R) are nested, and the curves in Γ are non-crossing. We say that
a bad component R is large, iﬀ σ(cid:48)(R) contains more than ∆/2 + 1 vertices. Let R(cid:48) be the set of all
large bad components of R1
h. Then we can ﬁnd an ordering (R1, R2, . . . , R(cid:96)) of the components
in R(cid:48), so that σ(cid:48)(R1) ⊆ σ(cid:48)(R2) ⊆ ··· ⊆ σ(cid:48)(R(cid:96)).
For every bad component R (cid:54)∈ R(cid:48), we let γ(R) be the union of γ(cid:48)(R), σ(cid:48)(R), γ(a(R)), and γ(a(cid:48)(R)),
and we let η(R) be the disc whose boundary is γ(R). For every bad component R ∈ R(cid:48), we let σ(cid:48)(cid:48)(R)
be the segment of Ct with endpoints b(R) and b(cid:48)(R), that is diﬀerent from σ(cid:48)(R), so the length of
σ(cid:48)(cid:48)(R) is at most ∆/2 + 1. We let γ(R) be the union of γ(cid:48)(R), σ(cid:48)(cid:48)(R), γ(a(R)), and γ(a(cid:48)(R)), and we
let η(R) be the disc whose boundary is γ(R). Notice that in either case, the length of γ(R) is bounded
h(cid:48)=1 Rh(cid:48) have all

by 2h + ∆/2 + 1. It is immediate to verify that the resulting discs η(R) for all R ∈(cid:83)r

h ∪ R2

h ∪ R2

h ∪ R2

21

required properties. Indeed, notice that for all type-1 and type-2 components R ∈ Rh, η(cid:48)(R) ⊆ η(R).
The ﬁrst property then follows from the deﬁnition of η(cid:48)(R). For the third property, η(R) ⊆ η(R(cid:48)) for
R, R(cid:48) ∈ Rh only if η(cid:48)(R) ⊆ η(cid:48)(R(cid:48)), and from the construction of the discs η(cid:48)(R), η(cid:48)(R(cid:48)), this can only
happen if σ(R) ⊆ σ(R(cid:48)). If neither of the discs η(cid:48)(R), η(cid:48)(R(cid:48)) is contained in the other, then they are
internally disjoint, and our construction of the discs η(R), η(R(cid:48)) ensures that these two discs are also
internally disjoint. Finally, consider two components R, R(cid:48) ∈ R. Our construction of the disc η(R)
ensures that γ(R) is disjoint from V (R(cid:48)), and so either R(cid:48) ⊆ η(R), or R(cid:48) ∩ η(R) = ∅. This establishes
the remaining property.

Figure 2: Building η(R). Curve γ(cid:48)(R) is shown in red, and γ(a(R)), γ(a(cid:48)(R)) are shown in blue.

We also need the following observation.
Observation 5.6 For all 1 ≤ h ≤ r, if ˜Uh is the set of vertices of G lying in D(Zh(t)), then G[ ˜Uh] is
connected.

Proof: The proof is by induction on h. Recall that V (Dt) induces a connected sub-graph in G, from
the deﬁnition of the enclosures. Assume now that G[ ˜Uh] is connected for some 0 ≤ h < r. From the
deﬁnition of Zh+1(t), and from the fact that G is a connected graph, it is immediate to verify that
G[ ˜Uh+1] is also connected.

Finally, we need the following observation about the interactions of diﬀerent shells.
Observation 5.7 Let t, t(cid:48) be any pair of terminals, and let r, r(cid:48) > 0 be any integers, such that d(t, t(cid:48)) >
r + r(cid:48) + 1. Let Z r(t) = (Z1(t), . . . , Zr(t)) be a shell of depth r around t with respect to some face Ft,
and let Z r(cid:48)
(t(cid:48)) = (Z1(t(cid:48)) . . . , Zr(cid:48)(t(cid:48))) be a shell of depth r(cid:48) around t(cid:48) with respect to some face Ft(cid:48). Then
for all 1 ≤ h ≤ r and 1 ≤ h(cid:48) ≤ r(cid:48), Zh(t) ∩ Zh(cid:48)(t(cid:48)) = ∅.
Proof: Assume otherwise. Then there is some vertex v ∈ Zh(t) ∩ Zh(cid:48)(t(cid:48)). From Property (J4), there
is a G-normal curve γ(v) of length at most h + 1 ≤ r + 1 connecting v to some vertex of Ct, and
similarly there is a G-normal curve γ(cid:48)(v) of length at most h(cid:48) + 1 ≤ r(cid:48) + 1, connecting v to some vertex
of Ct(cid:48). Combining γ(v) with γ(cid:48)(v), we obtain a G-normal curve of length at most r + r(cid:48) + 1 < d(t, t(cid:48)),
connecting a vertex of Ct to a vertex of Ct(cid:48), a contradiction.

22

DtRZh−1(t)Zh(t)a(R)a￿(R)b￿(R)b(R)(cid:109)

Let t∗ be any terminal in ˜T . For all 1 ≤ i ≤(cid:108)
Observation 5.9 There is some 2 ≤ i ≤(cid:108)

log10/9 n
d(t∗, t) ≤ 8∆i. We use the following simple observation.

(cid:109)

If the claim is false, then for every 2 ≤ i ≤ (cid:108)

log10/9 n

Proof:
Y(cid:100)log10/9 n(cid:101)+1 > n, which is impossible.

Fix some 2 ≤ i ≤ (cid:108)

(cid:109)

+ 1, let Yi contain all terminals t ∈ ˜T with

+ 1, such that |Yi \ Yi−1| ≤ |Yi−1|/9.

(cid:109)

log10/9 n

+ 1, |Yi| ≥ 10|Yi−1|/9, and so

5.3 Terminal Subsets

(cid:16)(cid:108)

(cid:109)

(cid:17)

+ 1

log10/9 n

Let ∆0 = 20
∆ = Θ(∆ log n). Our next step is to deﬁne a family of disjoint subsets
of terminals, so that the terminals within each subset are close to each other, while the terminals
belonging to diﬀerent subsets are far enough from each other. We will ensure that almost all terminals
of T belong to one of the resulting subsets. Following is the main theorem of this section.
Theorem 5.8 There is an eﬃcient algorithm to compute a collection X = {X1, . . . , Xq} of disjoint
subsets of terminals of T , such that:

• for each 1 ≤ i ≤ q, for every pair t, t(cid:48) ∈ Xi of terminals, d(t, t(cid:48)) ≤ ∆0;
• for all 1 ≤ i (cid:54)= j ≤ q, for every pair t ∈ Xi, t(cid:48) ∈ Xj of terminals d(t, t(cid:48)) ≥ 5∆; and

• (cid:80)q

i=1 |Xi| ≥ 0.9|T |.

Proof: We start with X = ∅ and ˜T = T , and perform a number of iterations, each of which adds
one subset of terminals to X , and removes some terminals from ˜T . The iterations are executed while
˜T (cid:54)= ∅, and each iteration is executed as follows.

(cid:16)(cid:108)
(cid:16)(cid:108)

(cid:109)
(cid:109)

(cid:17)
(cid:17)

+ 1

+ 1

log10/9 n

log10/9 n

log10/9 n

terminals to X , where |Yi \ Yi−1| ≤ |Yi−1|/9. Therefore, at the end of the algorithm, (cid:80)

+ 1, such that |Yi \ Yi−1| ≤ |Yi−1|/9. Notice that for every terminal
, and so from Observation 5.4, for any pair t, t(cid:48) ∈ Yi−1 of
t ∈ Yi−1, d(t∗, t) ≤ 8∆
terminals, d(t, t(cid:48)) ≤ 16∆
+ ∆/2 ≤ ∆0. Moreover, if we consider any pair t ∈ Yi−1,
t(cid:48) ∈ ˜T \ Yi of terminals, then d(t, t(cid:48)) ≥ 5∆ must hold, since otherwise, from Observation 5.4, d(t∗, t(cid:48)) ≤
d(t∗, t) + d(t, t(cid:48)) + ∆/2 ≤ 8∆(i − 1) + 5∆ + ∆/2 < 8∆i, contradicting the fact that t(cid:48) (cid:54)∈ Yi. We remove
all terminals of Yi from ˜T , add the set X = Yi−1 to X , and continue to the next iteration.
Notice that in every iteration we discard all terminals in Yi \ Yi−1, and add a set containing |Yi−1|
X∈X |X| ≥
0.9|T |. The remaining properties of the partition are now immediate to verify.
We use a parameter τ = W 18/19. We say that a set X ∈ X of terminals is heavy if w∗|X| ≥ τ , and
we say that it is light otherwise. We say that a demand pair (s, t) is heavy iﬀ both s and t belong to
heavy subsets of terminals in X . We say that it is light if at least one of the two terminals belongs
to a light subset, and the other terminal belongs to some subset in X . Note that a demand pair (s, t)
X∈X X. Let M0 be the set of all
demand pairs that are neither heavy nor light. Then |M0| ≤ 0.2|M|. We say that Case 1 happens if
there are at least 0.1|M| light demand pairs, and we say that Case 2 happens otherwise. Notice that
in Case 2, at least 0.7|M| of the demand pairs are heavy. In the next two sections we handle Case 1
and Case 2 separately.

may be neither heavy nor light, for example, if s or t lie in T \(cid:83)

23

6 Case 1: Light Demand Pairs

(cid:17)

(cid:17)

(cid:17)

τ log n

(cid:17)

(cid:110)

(cid:16) ∆

p∗ log n

(cid:16) ∆
(cid:16) W 2/19 log k

Let ML ⊆ M be the set of all light demand pairs. Recall that |ML| ≥ 0.1|M|. We assume w.l.o.g.
that for every pair (s, t) ∈ ML, t belongs to a light set in X . We let SL, T L ⊆ T be the sets of the
source and the destination vertices of the demand pairs in ML, respectively. Let L ⊆ X be the set
of all light terminal subsets. Recall that we have assumed that every terminal participates in exactly
one demand pair. If (s, t) ∈ M, then we say that s is the mate of t, and t is the mate of s. The goal
of this section is to prove the following theorem.
Theorem 6.1 Let p∗ = Θ
least min

. There is an eﬃcient algorithm, that computes a routing of at

(cid:16) αWL|ML|
(cid:17)(cid:111)

demand pairs via node-disjoint paths in G.

Ω(p∗), Ω

(cid:16) W 1/19

(cid:16) W 1/19

Indeed, since
. Notice also

(cid:17)
(cid:16) αWL|M|
= Ω(cid:0)W 1/19 log k(cid:1). Therefore, the algorithm routes Ω

We ﬁrst show that Theorem 6.1 concludes the proof of Theorem 4.3 for Case 1.
|ML| ≥ 0.1|M|, we get that p∗ = Θ
that Ω
demand pairs via node-disjoint paths. The rest of this section is devoted to proving Theorem 6.1.
Our ﬁrst step is to compute a large subset M0 ⊆ ML of light demand pairs, so that, if we denote by
S0 and T0 the sets of the source and the destination vertices of the demand pairs in M0, then there is
a set Q of |M0| node-disjoint paths connecting the vertices of S0 to a subset of vertices of T L, that we
denote by T (cid:48). Additionally, we ensure that every terminal set X ∈ L, |X ∩ T (cid:48)| ≤ 1, and |X ∩ T0| ≤ 1.
We note that the sets S0 and T (cid:48) do not necessarily form demand pairs. We will eventually route a
subset of the pairs of M0.
Theorem 6.2 There is an eﬃcient algorithm to compute a subset M0 ⊆ ML of κ0 = Θ
demand pairs, and a subset T (cid:48) ⊆ T L of κ0 terminals, such that, if we denote by S0 and T0 the sets of
the source and the destination vertices of the demand pairs in M0, then:

(cid:16) αWL|ML|

= Θ

log n log k

τ log n

= Θ

p∗ log n

= Ω

W 1/19

(cid:17)

(cid:17)

w∗|M|

W 18/19 log n log k

(cid:17)

(cid:16)

log n log k

τ

• There is a set Q of κ0 node-disjoint paths connecting the vertices of S0 to the vertices of T (cid:48); and
• For each set X ∈ L, |X ∩ T (cid:48)| ≤ 1, and |X ∩ T0| ≤ 1.

Proof: Recall that SL and T L are the sets of the source and the destination vertices, respectively, of
the demand pairs in ML.
We build the following directed ﬂow network N . Start with graph G, and bi-direct all its edges. For
every light set X ∈ L, add two vertices: sX , connecting to every vertex s ∈ SL, whose mate t ∈ X,
and tX , to which every vertex t ∈ T L ∩ X is connected. Finally, we add a global source vertex s0,
that connects with directed edges to every vertex sX for X ∈ L, and a global destination vertex t0, to
which every vertex tX with X ∈ L connects. The capacities of s0 and t0 are inﬁnite, the capacities of
all vertices in {sX , tX | X ∈ L} are τ , and all other vertex capacities are unit. Let |SL| = |T L| = ˜k.
We claim that there is an s0–t0 ﬂow of value at least αWL · ˜k in N . Assume otherwise. Then there
is a set Y of vertices, whose total capacity is less than αWL · ˜k, separating s0 from t0 in N . Let A
denote the subset of vertices of {sX | X ∈ L} that lie in Y , and let B = Y ∩ {tX | X ∈ L}. Assume
that |A| = a, |B| = b, and assume for simplicity that a ≥ b (the other case is symmetric). We next
build a set ˜S ⊆ SL of source vertices as follows: for every set X ∈ L with sX ∈ A, we add all vertices
s ∈ SL whose mate belongs to X, to set ˜S (so ˜S contains all vertices s ∈ SL, such that some edge
originating at a vertex of A enters s). Let ˜S(cid:48) = SL \ ˜S. Since each cluster X ∈ X contains at most
τ /w∗ terminals, | ˜S(cid:48)| ≥ ˜k − aτ
w∗ .

24

(cid:108)˜k − aτ

(cid:109)
w∗ ≥ ˜k − aτ

Similarly, we let ˜T ⊆ T L contain all terminals t, such that, if t ∈ X for cluster X ∈ L, then tX ∈ B.
Let ˜T (cid:48) = T L \ ˜T . Then | ˜T (cid:48)| ≥ ˜k − bτ
w∗ , since we assumed that a ≥ b. We discard terminals
from ˜S(cid:48) and ˜T (cid:48) until | ˜S(cid:48)| = | ˜T (cid:48)| =
holds. (We note that ˜k − aτ
w∗ > 0, since the total capacity
of all vertices in A is at most aτ < αWL˜k < w∗˜k, as αWL =
512·αAKR·log k .)
Let Y (cid:48) = Y \ (A ∪ B). Then Y (cid:48) is a subset of vertices of G, and moreover, G \ Y (cid:48) does not contain
any path connecting a vertex of ˜S(cid:48) to a vertex of ˜T (cid:48). Indeed, if G \ Y (cid:48) contains a path P connecting
some vertex s ∈ ˜S(cid:48) to some vertex t(cid:48) ∈ ˜T (cid:48), then it is easy to see that path P can be extended to an
s0–t0 path in N \ Y . Notice that:

w∗

w∗

|Y

(cid:48)| < αWL · ˜k − aτ − bτ ≤ αWL · ˜k − aτ.

But from the well-linkedness of terminals, there must be a set of at least αWL| ˜S(cid:48)| ≥ αWL(˜k − aτ /w∗)
paths connecting the vertices of ˜S(cid:48) to the vertices of ˜T (cid:48). Recall that αWL =

w∗

512·αAKR·log k , and so:

(cid:17)

(cid:16)˜k − aτ

w∗

αWL

= αWL˜k −

aτ

512αAKR log k

> αWL˜k − aτ > |Y

(cid:48)|,

(cid:109)

(cid:108)

(cid:109)

(cid:108)

(cid:17)

αWL˜k/τ

(cid:16) αWL|ML|

. This ﬂow deﬁnes a collection Q of κ0 =

a contradiction. We conclude that there is an s0–t0 ﬂow F of value at least αWL˜k in N .
Let N (cid:48) be a directed ﬂow network deﬁned exactly like N , except that now we set the capacity of every
vertex in {sX , tX | X ∈ L} to 1. By scaling the ﬂow F down by factor τ , we obtain a valid s0–t0 ﬂow in
N (cid:48) of value at least αWL˜k/τ . From the integrality of ﬂow, there is an integral s0–t0 ﬂow in N (cid:48) of value
= Ω(αWL|ML|/τ ) node-disjoint paths
αWL˜k/τ
in graph G, connecting some vertices of SL to some vertices of T L. We let S0 ⊆ SL and T (cid:48) ⊆ T L be
the sets of vertices where the paths of Q(cid:48) originate and terminate, respectively, and we let T0 contain
all mates of the source vertices in S0. We then set M0 to be the set of the demand pairs in which the
vertices of S0 participate. It is easy to verify that for each set X ∈ L, |T (cid:48) ∩ X|,|T0 ∩ X| ≤ 1 from the
deﬁnition of the network N (cid:48).
We assume that |M0| ≥ 1000, as otherwise we can route a single demand pair, and obtain a solution
routing Ω
Recall that every set X ∈ X contains at most one terminal from T0. Since |S0| = |T0|, there is some
set X0 ∈ T0, that contains exactly one terminal t0 ∈ T0, and at most one additional terminal from S0.
We will view t0 as our “center” terminal, and we discard from M0 the demand pairs in which t0 and
the terminal in S0 ∩ X0 (if it exists) participate.
The main tool in our algorithm for Case 1 is a crossbar, that we deﬁne below. Let ∆1 = (cid:98)∆/6(cid:99)
and ∆2 = (cid:98)∆1/3(cid:99). Given a shell Z(t) = (Z1(t), . . . , Z∆1(t)) of depth ∆1 around some terminal t,
we will always denote by D∗(t) = D(Z∆1(t)), and by ˜D(t) = D(Z∆2(t)). We will view the cycles
Z1(t), . . . , Z∆2(t) as the “inner” part of the shell Z(t). The crossbar is deﬁned with respect to some
large enough subset M∗ ⊆ M0 of demand pairs (see Figure 3).
Deﬁnition 6.1 Suppose we are given a subset M∗ ⊆ M0 of demand pairs and an integer p ≥ 1. Let
S∗ and T ∗ be the sets of all source and all destination vertices participating in the demand pairs of
M∗, respectively. A p-crossbar for M∗ consists of:

demand pairs.

τ

• For each terminal t ∈ T ∗∪{t0}, a shell Z(t) of depth ∆1 around t, such that for all t, t(cid:48) ∈ T ∗∪{t0},

D∗(t) ∩ D∗(t(cid:48)) = ∅, and for all s ∈ S∗ and t(cid:48) ∈ T ∗ ∪ {t0}, s (cid:54)∈ D∗(t(cid:48)); and

25

• For each v ∈ S∗ ∪ T ∗, a collection P(v) of paths, such that:

– For each s ∈ S∗, P(s) contains exactly one path, connecting s to a vertex of Ct0;
– For each t ∈ T ∗, P(t) contains exactly p paths, where each path connects a vertex of Ct to

– All paths in P =(cid:83)

a vertex of Ct0; and

v∈S∗∪T ∗ P(v) are node-disjoint from each other.

In order to route a large subset of the demand pairs in M∗, we need a crossbar with slightly stronger
properties, that we call a good crossbar, and deﬁne below.
Deﬁnition 6.2 Given a set M∗ ⊆ M0 of demand pairs, where S∗, T ∗ are the sets of the source and
the destination vertices of the demand pairs in M∗ respectively, and an integer p ≥ 1, a p-crossbar

is a good crossbar, if the following additional properties hold:

(cid:16){Z(t)}t∈T ∗∪{t0} ,{P(v)}v∈S∗∪T ∗

(cid:17)

C1. For all t ∈ T ∗ and all v ∈ (S∗ ∪ T ∗) \ {t}, all paths in P(v) are disjoint from ˜D(t).
C2. For all t ∈ T ∗, all paths in P(t) are monotone with respect to (Z1(t), . . . , Z∆2(t)). Also, for all

v ∈ S∗ ∪ T ∗, all paths in P(v) are monotone with respect to (Z1(t0), . . . , Z∆2(t0)).

C3. We can partition Z∆2(t0) into a collection Σ = {σ(v) | v ∈ S∗ ∪ T ∗} of |S∗| + |T ∗| disjoint

segments, such that for all v, v(cid:48) ∈ S∗ ∪ T ∗ with v (cid:54)= v(cid:48), σ(v) ∩ P(v(cid:48)) = ∅.

Figure 3: A crossbar. The center vertex t0 is shown in blue, the vertices of S∗ in red, and the vertices
of T ∗ in green.

The following theorem shows that, given a p-crossbar in G, where p is large enough, we can route
many demand pairs in M∗.
Theorem 6.3 Suppose we are given a subset M∗ ⊆ M0 of κ demand pairs, where S∗ and T ∗ are
the sets of all source and all destination vertices of the demand pairs in M∗, respectively. Assume
for M∗, and let q =
further that we are given a good p-crossbar
min{∆2,(cid:98)(p − 1)/2(cid:99) ,(cid:100)κ/2(cid:101)}. Then there is an eﬃcient algorithm that routes at least q demand pairs
in M∗ via node-disjoint paths in G.

(cid:16){Z(t)}t∈T ∗∪{t0} ,{P(v)}v∈S∗∪T ∗

(cid:17)

Proof: We can assume without loss of generality that for every terminal t ∈ T ∗, for every path
P ∈ P(t), and for every 1 ≤ j ≤ ∆2, P ∩ Zj(t) consists of a single vertex. In order to see this, recall

26

that for each such terminal t, path P and value j, P ∩ Zj(t) is a path, from Property (C2). We
contract each such path P ∩ Zj(t) into a single vertex. We still maintain a good p-crossbar for M∗
in the resulting graph, and any routing of a subset of the demand pairs in M∗ in the new graph via
node-disjoint paths immediately gives a similar routing of the same subset of the demand pairs in the
original graph. Using a similar reasoning, we assume without loss of generality that for every path

v∈S∗∪T ∗ P(v), for every 1 ≤ j ≤ ∆2, P ∩ Zj(t0) is a single vertex.

P ∈(cid:83)

Let P =(cid:83)

Fix an arbitrary source vertex s ∈ S∗, and consider the unique path P (s) ∈ P(s). For all 1 ≤ j ≤ ∆2,
let vj be the unique vertex in Zj(t0) ∩ P (s), and let ej be the edge of Zj(t0) incident to vj, as we
traverse Zj(t0) starting from vj in the clock-wise direction. Let Rj be the path obtained by deleting ej
from Zj(t0). We view this path as directed in the counter-clock-wise direction along Zj(t0), thinking
of this as the left-to-right direction. Once we process every cycle Zj(t0) for 1 ≤ j ≤ ∆2 in this fashion,
we obtain a collection R1, . . . , R∆2 of paths. Our routing will in fact only use the paths R1, . . . , Rq.
v∈S∗∪T ∗ P(v). For each 1 ≤ j ≤ ∆2, and for each path P ∈ P, let u(P, j) be the unique
vertex in P ∩ Rj. The vertices u(P, ∆2) deﬁne a natural left-to-right ordering O of the paths in P:
for P, P (cid:48) ∈ P, we denote P ≺ P (cid:48) iﬀ u(P, ∆2) lies to the left of u(P (cid:48), ∆2) on R∆2. Notice that, since
the paths of P are monotone with respect to Z1(t0), . . . , Z∆2(t0), for every pair P, P (cid:48) ∈ P of paths
with P ≺ P (cid:48), for every 1 ≤ j ≤ ∆2, u(P, j) lies to the left of u(P (cid:48), j) on Rj. From Property (C3) of
the crossbar, for each terminal v ∈ S∗ ∪ T ∗, all paths in P(v) appear consecutively in the ordering O.
Therefore, we obtain a natural left-to-right ordering O(cid:48) of the terminals: we say that terminal v lies
to the left of terminal v(cid:48) iﬀ for all P ∈ P(v), P (cid:48) ∈ P(v(cid:48)), P ≺ P (cid:48).
We say that a demand pair (s, t) ∈ M∗ is a left-to-right pair, if s appears before t in O(cid:48), and we say
that it is a right-to-left pair otherwise. At least (cid:100)|M∗|/2(cid:101) of the pairs belong to one of these two types,
and we assume w.l.o.g. that at least (cid:100)|M∗|/2(cid:101) of the pairs are of the left-to-right type (otherwise we
reverse the direction of the paths {Rj}∆2
j=1, and the orderings O,O(cid:48)). We discard from M∗ all right-
to-left demand pairs, and we update the sets S∗ and T ∗ accordingly. We discard additional demand
pairs from M∗ as needed, until |M∗| = q holds.
Consider the set S∗ of the source vertices. We assume that S∗ = (s1, . . . , sq), with the sources indexed
where for each 1 ≤ i ≤ q, path P ∗
of paths, that we later modify.
The initial set P∗ of paths is constructed as follows. Fix some 1 ≤ i ≤ q. The initial path P ∗
is the
concatenation of the segment of the unique path P (si) ∈ P(si) from si to u(P, i), and the segment of
Ri from u(P, i) to the last (right-most) vertex of Ri (see Figure 4(a)).
Clearly, all paths in P∗ are node-disjoint, and each path P ∗
i originates at si, but it does not terminate
at ti. We now modify the paths in P∗ in order to ﬁx this. We process the terminals ti ∈ T ∗ in their
right-to-left order (the reverse order of their appearance in O(cid:48)). When we process terminal ti, we will
i terminates at ti, while all paths in P∗ remain disjoint. Intuitively, in order to
ensure that path P ∗
q “around” the terminal ti, using the paths of P(ti) and the q
do so, we send the paths P ∗
innermost cycles of the shell Z(ti).
Formally, throughout the algorithm, we maintain the following invariants:

in the order of their appearance in O(cid:48). We deﬁne a set P∗ = (cid:8)P ∗

(cid:9) of node-disjoint paths,

i connects si to ti. In order to do so, we ﬁrst construct an initial set

i+1, . . . , P ∗

1 , . . . , P ∗

q

i

• The paths in P∗ =(cid:8)P ∗

1 , . . . , P ∗

q

(cid:9) always remain disjoint.

• Once terminal ti is processed, in all subsequent iterations, path P ∗
• Let t(cid:48) be the last terminal processed, and for each 1 ≤ i ≤ q, let vi be the leftmost vertex of Ri
that lies on any path in P(t(cid:48)). Let P (si) be the unique path in P(si). Then if si lies to the left

i connects si to ti.

27

of t(cid:48) in O(cid:48), the current path P ∗
excluding vi).

i contains the segment of Ri between u(P (si), i) and vi (possibly

We now describe an iteration when the terminal ti is processed. Let {Q1, . . . , Q2q+1} be any set of
2q + 1 distinct paths in P(ti), indexed according to their ordering in O (recall that from our deﬁnition
of q, |P(ti)| = p ≥ 2q + 1). We do not modify the paths P ∗
i−1 at this step. Path P ∗
1 , . . . , P ∗
is modiﬁed
as follows. From our invariants, vertex u(Qq+1, i) belongs to P ∗
i . We discard the last segment of P ∗
i
that starts at u(Qq+1, i), and then concatenate the remaining path with the segment of Qq+1 from its
starting point a ∈ Cti to u(Qq+1, i). In this way, we obtain a path originating at si and terminating at
a. Since the sub-graph of G induced by V (D(ti)) is connected, we can extend this path inside D(ti),
so it now terminates at ti.

i

(a) The initial paths, together with the inner shells of the
terminals in T ∗. Recall that for all t ∈ T ∗ and v ∈ S∗∪T ∗
with t (cid:54)= v, all paths in P(v) are disjoint from the inner
shell of t.

(b) Modifying the routing

Figure 4: Constructing the routing

For all i(cid:48) > i, if si(cid:48) lies to the left of ti, then path P ∗
i(cid:48) is modiﬁed to “go around” ti, using the paths
Qi(cid:48), Q2q+2−i(cid:48) (that is, the i(cid:48)th paths from the right and from the left), and the cycle Zi(cid:48)(ti), as follows.
Let Q(cid:48) be the segment of path Qi(cid:48), starting from the unique vertex of Qi(cid:48) ∩ Zi(cid:48)(ti) (that we denote
by x), to vertex u(Qi(cid:48), i(cid:48)). Let Q(cid:48)(cid:48) be the segment of path Q2q+2−i(cid:48), starting from the unique vertex
of Q2q+2−i(cid:48) ∩ Zi(cid:48)(ti) (that we denote by y), to vertex u(Q2q+2−i(cid:48), i(cid:48)). Consider now the two segments
σ, σ(cid:48) of Zi(cid:48)(ti), whose endpoints are x and y. Exactly one of these segments (say σ) is disjoint from
the new path P ∗
i(cid:48) the segment of Ri(cid:48) between u(Qi(cid:48), i(cid:48)) and u(Q2q+2−i(cid:48), i(cid:48)), and
replace it with the concatenation of Q(cid:48), σ and Q(cid:48)(cid:48) (see Figure 4(b)). It is easy to see that all invariants
continue to hold.

i . We remove from P ∗

In order to complete the proof of Theorem 6.1, we prove the following theorem that allows us to
construct a large enough crossbar.

Theorem 6.4 There is an eﬃcient algorithm that either ﬁnds a routing of Ω(κ0) demand pairs of
M0 via node-disjoint paths, or computes a subset M∗ ⊆ M0 of Ω(κ0/ log n) demand pairs, and a good
p-crossbar for M∗, with p = Ω(∆/κ0).

(cid:16) αWL|ML|

τ

(cid:17)
(cid:110)

(cid:16) ∆

. Letting p∗ = κ0
Ω(p∗), Ω

(cid:17)(cid:111)

log n = Ω

(cid:16) αWL|ML|

(cid:17)

τ log n

Recall that κ0 = Θ

, from Theorem 6.3, we can eﬃciently

ﬁnd a routing of at least min
demand pairs, concluding the proof of Theorem 6.1.
The rest of this section is dedicated to proving Theorem 6.4. We do so in two steps. In the ﬁrst step,
we either ﬁnd a routing of Ω(κ0) demand pairs in M0, or compute a large subset M3 ⊆ M0 of demand

p∗ log n

28

pairs, and a p-crossbar with respect to M3 (that may not be good). If the outcome of the ﬁrst step
is the former, then we terminate the algorithm and return the resulting routing. Otherwise, in the
following step, we modify the set M3 and the crossbar in order to obtain the ﬁnal set M∗, and a good
crossbar with respect to M∗.

6.1 Constructing a Basic Crossbar

In this section we prove the following theorem.

Theorem 6.5 There is an eﬃcient algorithm that either computes a routing of Ω(κ0) demand pairs
in M0 via node-disjoint paths, or ﬁnds a subset M3 ⊆ M0 of κ3 = Ω(κ0) demand pairs, and a
p1-crossbar for M3, for p1 = Ω(∆/κ0).

We construct the crossbar in two steps. Let S0, T0 be the sets of all source and all destination vertices
corresponding to the demand pairs in M0, respectively. In the ﬁrst step, we construct a shell Z(t)
of depth ∆1 around every terminal t ∈ T0 ∪ {t0}, so that their corresponding discs D∗(t) are disjoint.
We then select a subset M1 ⊆ M0 of demand pairs, so that, if we denote by S1 and T1 the sets
of all source and all destination vertices of the pairs in M1, respectively, then for all s ∈ S1 and
t(cid:48) ∈ T1 ∪ {t0}, s (cid:54)∈ D∗(t(cid:48)). In the second step, we select a subset M3 ⊆ M1 of demand pairs, and
complete the construction of the crossbar by computing the sets P(v) of paths for all v ∈ T (M3).

Step 1: the Shells. Consider any terminal t ∈ T0 ∪ {t0}, and let t(cid:48) (cid:54)= t be any other terminal in
T0 ∪ {t0}. We let Ft be the face of the drawing of G on the sphere containing the image of t(cid:48). Notice
that from Theorem 6.2, t and t(cid:48) lie in diﬀerent sets of X , and so, from Theorem 5.8, d(t, t(cid:48)) ≥ 5∆. In
particular, for every vertex v on the boundary of Ft, dGNC(v, t) > ∆1 + 1. We can now construct a
shell Z(t) of depth ∆1 around t, with respect to Ft.
Additionally, for every terminal t ∈ T (cid:48), we construct a shell Z(t) of depth ∆1 around t similarly,
letting Ft be the face incident on any terminal t(cid:48) ∈ T (cid:48) \ {t}. This concludes the construction of the
shells. We need the following lemma.
Lemma 6.6 For all t1, t2 ∈ T0 ∪ {t0}, if t1 (cid:54)= t2, then D∗(t1) ∩ D∗(t2) = ∅. Moreover, for all s ∈ S0,
s (cid:54)∈ D∗(t0).

Proof: Let t1, t2 ∈ T0∪{t0} be any two distinct terminals, and assume for contradiction that D∗(t1)∩
D∗(t2) (cid:54)= ∅. We need the following observation.
Observation 6.7 Either Dt2 ⊆ D∗(t1), or Dt1 ⊆ D∗(t2) must hold.
Proof: If D∗(t2) ⊆ D∗(t1), or D∗(t1) ⊆ D∗(t2), then we are done, so assume that neither of these
holds. From Observation 5.7, Z∆1(t1) ∩ Z∆1(t2) = ∅. Since D∗(t1) ∩ D∗(t2) (cid:54)= ∅, the only other
possibility is that the union of the discs D∗(t1), D∗(t2) is the entire sphere, and the boundary of each
disc is contained in the other disc. In particular, Z∆1(t2) ⊆ D∗(t1). We claim that all vertices of
Ct2 must lie in disc D∗(t1). Indeed, assume for contradiction that some vertex v ∈ V (Ct2) does not
lie in D∗(t1). Since all vertices of Z∆1(t2) lie in D∗(t1), there is a G-normal curve γ of length at
most ∆/2 + ∆1 + 2, connecting v to some vertex of Z∆1(t2), and this curve must contain some vertex
v(cid:48) ∈ Z∆1(t1). But then there is a G-normal curve of length at most ∆1 + 1 connecting v(cid:48) to a vertex
of Ct1, so d(t1, t2) ≤ 2∆1 + ∆/2 + 2 < 5∆, a contradiction. Therefore, all vertices of Ct2 appear in
D∗(t1).

29

1 be the terminal we have used to deﬁne the face Ft1, so t(cid:48)

Let t(cid:48)
of the shells, it is easy to see that Dt(cid:48)
Dt2. Moreover, since Dt(cid:48)
enclosures.

1

is disjoint from D∗(t1). If Dt2 (cid:54)⊆ D∗(t1), then t(cid:48)

1 lies outside D∗(t1). From Property (J5)
1 must lie inside
(cid:40) Dt2, contradicting the construction of

∩ D∗(t1) = ∅, we get that Dt(cid:48)

1

1

1

1

1

from Dt2, and clearly Dt(cid:48)

1 lies outside D∗(t1) and Dt(cid:48)

1 be the terminal we have used to deﬁne the face Ft1, so t(cid:48)

that Dt2 ⊆ D∗(t1). Since for all 0 ≤ j, j(cid:48) ≤ ∆1, Zj(t1) ∩ Zj(cid:48)(t2) = ∅, there
We assume w.l.o.g.
must be some index 1 ≤ j ≤ ∆1, such that Dt2 ⊆ D◦(Zj(t1)) \ D(Zj−1(t1)). Let Uj be the set of all
vertices of G lying in D◦(Zj(t1)) \ D(Zj−1(t1)), and let Rj be the set of all connected components in
G[Uj]. Since V (Dt2) induces a connected graph in G, there is some connected component R ∈ Rj,
such that V (Dt2) ⊆ V (R). From Theorem 5.5, there is a G-normal curve γ(R) of length at most
2j + ∆/2 + 1 ≤ 2∆1 + ∆/2 + 1 < ∆, such that the disc D(γ(R)) contains R, and D(γ(R)) ⊆ D∗(t1).
Let t(cid:48)
is disjoint
∩ Dt2 = ∅. But from our
from D∗(t1). Curve γ(R) then separates Dt(cid:48)
construction of enclosures, there is a set of ∆ node-disjoint paths connecting V (Ct2) to V (Ct(cid:48)
), all of
which must intersect γ(R), contradicting the fact that γ(R) contains fewer than ∆ vertices.
Assume now for contradiction that some vertex s ∈ S0 lies in D∗(t0). Recall that s must lie in some
set of X \{X0} (where X0 is the set containing t0), and so d(s, t0) ≥ 5∆. Therefore, for all 1 ≤ j ≤ ∆1,
V (Cs) ∩ V (Zj(t0)) = ∅ must hold. Moreover, D∗(t0) (cid:54)⊆ Ds, since otherwise, from the deﬁnition of
enclosures, Dt0 = Ds and d(t0, s) = 1, a contradiction. Since D∗(t0)∩Ds (cid:54)= ∅, we get that Ds ⊆ D∗(t0).
The rest of the proof follows the same reasoning as before.
We say that a demand pair (s, t) ∈ M0 is a type-1 pair if s ∈ D∗(t), and we say that it is a type-2
demand pair otherwise. Notice that we can route all type-1 demand pairs via node-disjoint paths,
where each pair (s, t) is routed in G[V (D∗(t))] (since from Observation 5.6, this graph is connected).
Therefore, if at least half the demand pairs in M0 are type-1 pairs, then we obtain a routing of Ω(κ0)
demand pairs and terminate the algorithm. We assume from now on that at least κ0/2 demand pairs
in M0 are type-2 demand pairs. We next build a directed conﬂict graph H, that contains a vertex
v(s, t) for each type-2 demand pair (s, t) ∈ M0. There is a directed edge from v(s, t) to v(s(cid:48), t(cid:48)) iﬀ
s ∈ D∗(t(cid:48)). Since the discs {D∗(t)}t∈T0 are mutually disjoint, the out-degree of every vertex of H
is at most 1, and the total average degree of every vertex in H is at most 2. Since |V (H)| ≥ κ0/2,
using standard techniques, we can ﬁnd an independent set I of κ1 = Ω(κ0) vertices in H. We
let M1 = {(s, t) ∈ M0 | v(s, t) ∈ I}. Let S1 and T1 be the sets of source and destination vertices,
respectively, of the demand pairs in M1. Then for all t, t(cid:48) ∈ T1, D∗(t) ∩ D∗(t(cid:48)) = ∅, and for all
s ∈ S1, t(cid:48) ∈ T1, s (cid:54)∈ D∗(t(cid:48)).

1

(cid:16) αWL|M|

(cid:17)

(cid:16) W 1/19

(cid:17)

τ

log k

= Θ

of Ct0.

, while ∆ = Θ(W 2/19). We
Step 2: the Paths. Recall that κ1 = Ω(κ0) = Θ
will assume throughout that κ1 < ∆/12, as otherwise κ0 is bounded by some constant, and routing
a single demand pair is suﬃcient. The following lemma will be used in order to compute the set
M3 ⊆ M1 of the demand pairs.

Lemma 6.8 There is a set P S of (cid:4) κ1
Proof: Assume otherwise. Then there is a set Y of at most(cid:4) κ1

(cid:5) − 1 node-disjoint paths, connecting vertices of S1 to vertices
(cid:5)− 2 vertices, such that G\ Y contains

no path from a vertex of S1 \ Y to a vertex of V (Ct0) \ Y .
Let Q(cid:48) ⊆ Q be a subset of the paths, computed in Theorem 6.2, that connect every terminal s ∈ S1
to some terminal of T (cid:48), so |Q(cid:48)| = κ1. Let Q(cid:48)(cid:48) ⊆ Q(cid:48) be the set of paths that contain no vertices of Y ,
so |Q(cid:48)(cid:48)| ≥ κ1/2 + 2. Recall that the terminals of T (cid:48) all belong to distinct sets of X , and so the discs

2

2

30

{Dt(cid:48)}t(cid:48)∈T (cid:48) are mutually disjoint. Moreover, there is at most one terminal t(cid:48)(cid:48) in T (cid:48) ∩ X0, where X0 ∈ X
is the set containing t0. Then there must be at least one path Q ∈ Q(cid:48)(cid:48), such that, if we denote by
s ∈ S1, t(cid:48) ∈ T (cid:48) its two endpoints, then t(cid:48) (cid:54)∈ X0, and Dt(cid:48) contains no vertex of Y . We now show that
there is a path connecting s to a vertex of Ct0 in G \ Y , leading to a contradiction.
From the construction of enclosures, there is a set P(t(cid:48), t0) of ∆ node-disjoint paths, connecting the
vertices of Ct0 to the vertices of Ct(cid:48). Since we have assumed that κ1 < ∆/12, at least one such path,
say P , is disjoint from Y . Let v(cid:48) be the endpoint of P lying on Ct(cid:48). Assume ﬁrst that s (cid:54)∈ Dt(cid:48). Then
Q must contain a vertex of Ct(cid:48), that we denote by v. Since G[V (Dt(cid:48))] is connected, there is a path
P (cid:48) ⊆ G[V (Dt(cid:48))] connecting v to v(cid:48), and this path is disjoint from Y . The union of Q, P and P (cid:48) then
contains a path connecting s to a vertex of V (Ct0), which is disjoint from Y , a contradiction.
Assume now that s ∈ Dt(cid:48). Then there is a path P (cid:48) ⊆ G[V (Dt(cid:48))], connecting s to v(cid:48). The union
of P and P (cid:48) then contains a path connecting s to a vertex of V (Ct0), which is disjoint from Y , a
contradiction.
Let S2 ⊆ S1 be the set of the source vertices where the paths of P S originate, let T2 ⊆ T1 be the set of
their mates, and let M2 ⊆ M1 be the set of the demand pairs in which the vertices of S2 participate.
Notice that from our choice of t0, there is at most one demand pair (s, t) ∈ M1, where t belongs to
the subset X0 ∈ X containing t0. If such a pair belongs to M1, then we discard it from M1, and
update S1 and T1 accordingly. Let κ2 = |M2|, so κ2 ≥ κ1/2 − 3 ≥ Ω(κ0). We now use the following
theorem to compute the subset M3 of the demand pairs and construct the corresponding paths for
the crossbar.
Theorem 6.9 There is an eﬃcient algorithm to compute a subset M3 ⊆ M2 of (cid:98)κ2/2(cid:99) demand pairs,
and a p-crossbar for M3, where p = Ω(∆/κ2).

Proof: Consider any terminal t ∈ T2, and let X0 ∈ X be the set containing t0. Since t (cid:54)∈ X0,
d(t, t0) ≥ 5∆, and in particular, Dt ∩ Dt0 = ∅. Therefore, there is a set ˜P(t) of ∆ node-disjoint paths,
connecting the vertices of V (Ct) to the vertices of V (Ct0).
We construct a directed ﬂow network N , by starting from G, and bi-directing each of its edges. We
then introduce several new vertices: a global source vertex s∗ of inﬁnite capacity; an additional vertex
vertex ˜s of capacity (cid:98)κ2/2(cid:99), and, for each terminal t ∈ T2 a vertex st of capacity (cid:98)∆/(2κ2)(cid:99). We
connect s∗ to ˜s, and to every vertex in {st}t∈T2. Vertex ˜s in turn connects to every vertex s ∈ S2, and
for each t ∈ T2, vertex st connects to every vertex in V (Ct). Finally, we introduce a global destination
vertex t∗ of inﬁnite capacity, and connect every vertex in V (Ct0) to it. All vertices whose capacities
have not been set so far have capacity 1.

2κ2

t∈T2

ﬂow units on each path in(cid:83)

in ˜P(t) are node-disjoint, the total congestion caused by the ﬂow on paths in(cid:83)

Let B be the total capacity of all vertices in {˜s} ∪ {st}t∈T2. It is easy to see that there is a ﬂow of
2 ﬂow unit along each path in set P S (discarding
value at least B in the resulting network: we send 1
one path if |S2| is odd), and 1
˜P(t) (if the ﬂow through some vertex
st is too high due to the rounding of the capacities down, we simply lower the ﬂow on one of the
corresponding paths in ˜P(t)). Since the paths in P S are node-disjoint, the total ﬂow on these paths
2 on the vertices whose capacity is 1. Since for each t ∈ T2, the paths
causes congestion at most 1
˜P(t) on vertices
whose capacity is 1 is at most 1/2. Therefore, we obtain a valid s∗-t∗ ﬂow of value B. From the
integrality of ﬂow, there is an integral ﬂow of the same value.
This ﬂow gives a collection P 1 of (cid:98)κ2/2(cid:99) paths connecting some vertices of S2 to some vertices of
V (Ct0), and, for each t ∈ T2, a collection P(cid:48)(t) of
paths connecting the vertices of V (Ct) to
the vertices of V (Ct0), such that all paths in P 1 ∪ {P(cid:48)(t) | t ∈ T2} are mutually node-disjoint. We

t∈T2

(cid:107)

(cid:106) ∆

2κ2

31

vertices. Then |M3| = (cid:98)κ2/2(cid:99), and all paths in set P(cid:48) = (cid:83)

let S3 ⊆ S2 be the set of the source vertices where the paths of P 1 originate. For each s ∈ S3, let
P (s) ∈ P 1 be the unique path originating at s, and let P(s) = {P (s)}. Let M3 ⊆ M2 contain all
demand pairs whose source belongs to S3, and let T3 ⊆ T2 be the set of the corresponding destination
P(v) are mutually disjoint. For
v∈S3∪T3
each terminal t ∈ T3, set P(t) contains Ω(∆/κ2) paths, as required.
This concludes the proof of Theorem 6.5. Since p1 = Ω(∆/κ0) and κ3 ≤ κ0, we will assume without
loss of generality that p1 · κ3 < ∆2/24 (otherwise we can lower the value of p1 until the inequality
holds and discard the appropriate number of paths from sets P(t) for t ∈ T3 ∪ {t0}).

6.2 Constructing a Good Crossbar

(cid:16)(cid:83)

t∈T3∪{t0} Z(t),(cid:83)

(cid:17)

In this section, we complete the proof of Theorem 6.4, by modifying the basic crossbar constructed in
P(v)
the previous section, in order to turn it into a good crossbar. Let
be the crossbar constructed in the previous section.
For every terminal t ∈ T3, let At ⊆ V (Ct), Bt ⊆ V (Ct0) be the sets of p1 vertices each, where the
paths of P(t) originate and terminate, respectively. For a source vertex s ∈ S3, we let As contain a
single vertex s, and Bs contain the vertex of V (Ct0) where the unique path in P(s) terminates. Let
v∈S3∪T3 Bv. Then |A| = |B| = |P| = |M3|(p1 + 1) < ∆2/6 from our

v∈S3∪T3 Av and B = (cid:83)

A = (cid:83)

v∈S3∪T3

assumption.

Deﬁnition 6.3 Given two equal-sized disjoint subsets U1, U2 of vertices of G, a U1–U2 linkage is a
set of |U1| node-disjoint paths, connecting the vertices of U1 to the vertices of U2.

(cid:16)(cid:83)

t∈T3∪{t0} Z(t),P(cid:48)(cid:17)

The following observation is immediate from the deﬁnition of a crossbar.
Observation 6.10 Let P(cid:48) be any A–B linkage in G. Then
M3.
Our algorithm consists of three steps. In the ﬁrst step, we re-route the paths in P, so that they become
disjoint from the relevant inner shells, ensuring Property (C1). In the following step, the paths in P
are further re-routed to ensure their monotonicity with respect to the relevant inner shells, obtaining
Property (C2). The set M3 of the demand pairs remains unchanged in these two steps. In the last
step, we carefully select a ﬁnal subset M∗ ⊆ M3 of the demand pairs to ensure Property (C3). We
discard some paths from set P, but the paths themselves are not modiﬁed at this step.

is a p1-crossbar for

Step 1: Disjointness of Paths from Inner Shells
The goal of this step is to modify the paths in set P, in order to ensure Property (C1). In fact, we
will ensure a slightly stronger property that we will use in subsequent steps.
Suppose we are given any A–B linkage P(cid:48). For every terminal t ∈ T3, we let P(cid:48)(t) ⊆ P(cid:48) be the set
of paths originating from the vertices of At, and for every source vertex s ∈ S3, we let P(cid:48)(s) contain
the unique path of P(cid:48) originating at s. We will always view the paths in P(cid:48) as directed from A to
B. Consider now any path P ∈ P(cid:48). Clearly, path P has to cross Z∆1(t0). Let vP be the last vertex
on P that lies on Z∆1(t0), and let eP be the edge immediately preceding vP on P . Let v(cid:48)
P be the
other endpoint of edge eP . Then P \ {eP} consists of two disjoint paths, that we denote by P1 and
P2, respectively, where P1 starts at a vertex of V (Ct) and terminates at v(cid:48)
P , and P2 starts at vP and
terminates at a vertex of V (Ct0).

32

We then denote A(cid:48) = {v(cid:48)
P | P ∈ P(cid:48)}, B(cid:48) = {vP | P ∈ P(cid:48)}, and ˜E = {eP | P ∈ P(cid:48)}. We also denote
2 = {P2 | P ∈ P(cid:48)}. Notice that P(cid:48)
P(cid:48)
1 = {P1 | P ∈ P(cid:48)} and P(cid:48)
2 is a B(cid:48)–
B linkage. Observe that for every terminal t ∈ T3 ∪ {t0}, all vertices of A(cid:48) ∪ B(cid:48) must lie outside
D(Z∆1−1(t)). Also, from our deﬁnitions, every path in P(cid:48)
Remark 6.1 We note that the deﬁnitions of the sets A(cid:48), B(cid:48) of vertices and the set ˜E of edges depend
on the A–B linkage P(cid:48). When we modify the linkage, these sets may change as well.

1 is an A–A(cid:48) linkage, and P(cid:48)

2 is contained in D∗(t0).

We are now ready to deﬁne good A–B linkages.
Deﬁnition 6.4 We say that an A–B linkage P(cid:48) is a good linkage, iﬀ:

• All paths in P(cid:48)
• For every t ∈ T3, if some path P ∈ P(cid:48)

1 are disjoint from ˜D(t0); and
1 ∪ P(cid:48)

vertex of At.

2 intersects ˜D(t), then P ∈ P(cid:48)

1, and it originates at a

(cid:16)(cid:83)

t∈T3∪{t0} Z(t),P(cid:48)(cid:17)

Notice that if P(cid:48) is a good A–B linkage, then
Property (C1). The goal of this step is to prove the following theorem.
Theorem 6.11 There is an eﬃcient algorithm that computes a good A–B linkage P(cid:48).

is a p1-crossbar for M3 that has

and iteratively modify it. Let E1 be the set of all edges that belong to cycles(cid:83)
paths in Q that do not belong to E1, so c(Q) =(cid:80)

The remainder of this step focuses on the proof of Theorem 6.11. In order to prove the theorem, we start
with the A–B linkage P, given by the basic crossbar that we have computed in the previous section,
j=∆2+1 Zj(t).
Given any set Q of node-disjoint paths in G, let c(Q) be the total number of all edges lying on the
P∈Q |E(P ) \ E1|. The following lemma is key to

t∈T3∪{t0}(cid:83)∆1

proving Theorem 6.11.
Lemma 6.12 Let P be any A–B linkage, and assume that it is not a good linkage. Then there is an
eﬃcient algorithm to compute an A–B linkage P(cid:48) with c(P(cid:48)) < c(P).
In order to complete the proof of Theorem 6.11, we start with the original A–B linkage P. While the
current linkage P is not a good one, we apply Lemma 6.12 to it, to obtain another A–B linkage P(cid:48)
with c(P(cid:48)) < c(P). The algorithm terminates when we obtain a good A–B linkage. Since the values
c(P) are integers bounded by |E(G)|, and they decrease by at least 1 in every iteration, the algorithm
is guaranteed to terminate after |E(G)| iterations. It now remains to prove Lemma 6.12.
Proof of Lemma 6.12. Let P be any A–B linkage, and assume that it is not a good linkage. Let
Q = P1 ∪P2, so Q is an (A∪ B(cid:48))–(A(cid:48) ∪ B) linkage in G\ ˜E, and |Q| = 2|M3|(p1 + 1) < 6κ3p1 < ∆2/3
from our assumption. We will use the following simple observation.
Observation 6.13 Let Q(cid:48) be any (A∪ B(cid:48))–(A(cid:48) ∪ B) linkage in G\ ˜E, and let G(cid:48) be the graph obtained
by the union of the paths in Q(cid:48) and the edges of ˜E. Then G(cid:48) contains an A–B linkage P(cid:48). Moreover,
if c(Q(cid:48)) < c(Q), then c(P(cid:48)) < c(P).

Proof: We construct the following auxiliary directed graph ˜G. The vertices of ˜G are A ∪ A(cid:48) ∪ B ∪ B(cid:48).
The edges are deﬁned as follows. First, for every path Q ∈ Q(cid:48), that originates at a vertex v ∈ A ∪ B(cid:48)
and terminates at a vertex u ∈ A(cid:48) ∪ B, we add a directed edge from v to u. Notice that since Q(cid:48) is an
(A ∪ B(cid:48))–(A(cid:48) ∪ B) linkage, this gives a directed matching from the vertices of A ∪ B(cid:48) to the vertices of

33

P , vP ) ∈ ˜E, we add a directed edge from v(cid:48)

A(cid:48) ∪ B. Finally, for every edge eP = (v(cid:48)
P to vP to ˜G. Then
in the resulting graph ˜G, every vertex of A has in-degree 0 and out-degree 1; every vertex of B has
out-degree 0 and in-degree 1, and every vertex of A(cid:48) ∪ B(cid:48) has in-degree and out-degree 1. Therefore,
graph ˜G is a collection of directed paths and cycles, and it must contain an A–B linkage ˜P. By
replacing, for every path P ∈ ˜P, the edges representing the paths of Q(cid:48) on P with the corresponding
paths, we obtain an A–B linkage P(cid:48). Since the edges of ˜E participate in the paths in P, and the paths
of P(cid:48) are contained in graph G(cid:48), it is immediate to verify that c(P(cid:48)) < c(P).
From Observation 6.13, it is now enough to construct an (A ∪ B(cid:48))–(A(cid:48) ∪ B) linkage Q(cid:48) in G \ ˜E, with
c(Q(cid:48)) < c(Q). The following technical claim is central to achieving this.

Claim 6.14 Let H be any planar graph embedded in the plane, such that H is a union of a set
Z = {Z1, . . . , Zh} of disjoint cycles with D(Z1) (cid:40) D(Z2) (cid:40) . . . (cid:40) D(Zh), and a set Q = Q1 ∪ Q2
of r < h node-disjoint paths. Assume that for i ∈ {1, 2}, the paths of Qi originate at a set Ui of
vertices, and terminate at a set U(cid:48)
i of vertices. Assume further that the vertices of U1 lie in D◦(Z1),
while the vertices of U(cid:48)
2 lie outside D(Zh). Let H(cid:48) be the graph obtained from H by deleting,
for every path Q ∈ Q2, every edge and vertex of Q contained in D◦(Z1). Then there is a set Q(cid:48) of r
node-disjoint paths, connecting the vertices of U1 ∪ U2 to the vertices of U(cid:48)

1 ∪ U2 ∪ U(cid:48)

1 ∪ U(cid:48)

2 in H(cid:48).

1 ∪ U(cid:48)

Proof: Let U = U1 ∪ U2 and U(cid:48) = U(cid:48)
2. Assume otherwise. From Menger’s theorem, there is a
set Y of at most r − 1 vertices, such that in H(cid:48) \ Y , no path connects a vertex of U \ Y to a vertex of
U(cid:48) \ Y . Let |Q1| = r1 and |Q2| = r2.
Observe that all paths of Q1 are contained in H(cid:48), so for each path P ∈ Q1, there must be a distinct
vertex yP ∈ Y lying on P . Let Y1 ⊆ Y be the set of all such vertices, so |Y1| = r1.
Let Q∗ ⊆ Q2 be the set of all paths that are disjoint from D◦(Z1), and denote |Q∗| = r∗. Then every
path P ∈ Q∗ is contained in H(cid:48), and as before, Y must contain a distinct vertex yP lying on P . Let
Y2 be the set of all such vertices {yP | P ∈ Q∗}. Since the paths in Q are disjoint, Y1 ∩ Y2 = ∅, and
|Y1| + |Y2| = r1 + r∗. Let Y3 = Y \ (Y1 ∪ Y2), and let Q(cid:48)(cid:48) = Q2 \ Q∗. Then |Y3| ≤ |Q(cid:48)(cid:48)| − 1, and due to
the disjointness of the paths in Q, every path in Q(cid:48)(cid:48) is disjoint from Y1 ∪ Y2. Therefore, there is some
path Q ∈ Q(cid:48)(cid:48), such that Q ∩ Y = ∅. Recall that Q ∩ D◦(Z1) (cid:54)= ∅, and so Q must intersect Z1. Let
v(cid:48), v(cid:48)(cid:48) be the ﬁrst and the last vertices of Q that lie on Z1. Recall that the endpoints of Q lie outside
D(Zh). Let Q(cid:48) be the segment of Q between its ﬁrst endpoint and v(cid:48), and let Q(cid:48)(cid:48) be the segment of Q
between v(cid:48)(cid:48) and its last endpoint. Then both Q(cid:48) and Q(cid:48)(cid:48) are contained in H(cid:48), and each of these paths
intersects every cycle in Z. The number of these cycles is h > r from our assumption. Therefore,
there is some 1 ≤ j ≤ h, such that Zj is disjoint from Y . By combining Zj with Q(cid:48) and Q(cid:48)(cid:48), we obtain
a path connecting a vertex of U \ Y to a vertex of U(cid:48) \ Y in H(cid:48) \ Y , a contradiction.
We are now ready to complete the proof of Lemma 6.12. Let P be the given A–B linkage, and assume
that it is not a good linkage.
Assume ﬁrst that some path P ∈ P1 has a non-empty intersection with ˜D(t0). We let Q1 = P2,
Q2 = P1, and Z = (Z∆2+1(t0), . . . , Z∆1−2(t0)). Observe that |Z| = ∆1− ∆2− 2 ≥ ∆2 > 24p1κ3 > |Q|,
the paths in Q1 originate at the vertices of Ct0, that lie in D◦(Z∆2+1), and terminate at the vertices
of B(cid:48), that lie outside D(Z∆1−2(t0)) (after we reverse them), while the paths of Q2 originate and
terminate outside D(Z∆1−2(t0)) (we also reverse them). From our assumption, at least one path in
Q2 intersects D◦(Z∆2+1). Let H be the graph obtained by the union of the cycles in Z and the paths
in Q. Since the edges of ˜E cannot lie on the cycles of Z, H ⊆ G\ ˜E. We can now apply Claim 6.14 to
obtain a new (A ∪ B(cid:48))–(A(cid:48) ∪ B) linkage Q(cid:48) in graph G \ ˜E. Moreover, since we delete all edges lying
on the paths of Q2 that belong to D◦(Z∆2+1(t0)), it is easy to verify that c(Q(cid:48)) < c(Q).
Assume now that there is some path P ∈ Q, and some terminal t ∈ T3, such that P intersects ˜D(t),

34

but it does not originate at a vertex of At. Let Q1 ⊆ P1 be the set of all paths originating from the
vertices of At, and let Q2 = Q \ Q1. It is easy to verify that we can apply Claim 6.14 as before, to
obtain a new (A ∪ B(cid:48))–(A(cid:48) ∪ B) linkage Q(cid:48) in graph G \ ˜E, with c(Q(cid:48)) < c(Q).
Using Observation 6.13, we can now obtain an A–B linkage P(cid:48) with c(P(cid:48)) < c(P).

(cid:3)

Step 2: Monotonicity with Respect to Inner Shells
In this step we further modify the paths in set P, in order to ensure Property (C2). As before, given
a good A–B linkage P(cid:48), for every terminal t ∈ T3 we denote by P(cid:48)(t) ⊆ P(cid:48) the set of paths originating
at the vertices of At, and for each s ∈ S3, we let P(cid:48)(s) ⊆ P(cid:48) contain the unique path originating at s.
We deﬁne the sets A(cid:48), B(cid:48) of vertices, the set ˜E of edges, and the sets P(cid:48)
2 of paths with respect to
P(cid:48) exactly as before.
Deﬁnition 6.5 We say that a good A–B linkage P(cid:48) is perfect if all paths in P(cid:48) are monotone with
respect to Z1(t0), . . . , Z∆2(t0), and for all t ∈ T3, all paths in P(cid:48)(t) are monotone with respect to
Z1(t), . . . , Z∆2(t).
In this step we prove the following theorem, that immediately gives a p1-crossbar for M3 with Prop-
erties (C1) and (C2).
Theorem 6.15 There is an eﬃcient algorithm, that, given a good A–B linkage P, computes a perfect
A–B linkage P(cid:48).

1,P(cid:48)

2 in H, such that the paths in P(cid:48)

2. Observe that ˜P remains a good linkage.

Proof: Our ﬁrst step is to re-route the paths in P2, so that they become monotone with respect
to Z1(t0), . . . , Z∆2(t0). Recall that from our deﬁnition, the paths of P2 originate from the set B(cid:48) ⊆
V (Z∆1(t0)) of vertices, terminate at the set B ⊆ V (Ct0) of vertices, and they are internally disjoint
from V (Z∆1(t0)) ∪ V (Ct0). Let Z = {Z1(t0), . . . , Z∆2(t0)}, C = Ct0, and Y = Z∆1(t0). Recall that
from the construction of the shells, Z is a set of ∆2 tight concentric cycles around C. Let H be the
graph obtained by the union of the cycles in Z and the set P2 of paths. We use Theorem 2.5 to obtain a
new B(cid:48)–B linkage P(cid:48)
2 are monotone with respect to Z1(t0), . . . , Z∆2(t0).
Moreover, since the paths in P1 are disjoint from the graph H, the paths in P(cid:48)
2 ∪ P1 remain disjoint.
Let ˜P be the new A–B linkage, obtained by concatenating the paths in P1, the edges of ˜E, and the
paths in P(cid:48)
For each terminal t ∈ T3, let ˜P(t) ⊆ ˜P be the set of paths originating from the vertices of At. For
every terminal t ∈ T3, we now re-route the paths in ˜P(t), as follows. We let Z = {Z1(t), . . . , Z∆2(t)}
and C = Ct. As before, Z is a set of ∆2 tight concentric cycles around C. We let Y be the sub-graph
of G induced by V (Dt0). Let H(cid:48) be the graph obtained by the union of the cycles in Z and the set
˜P(t) of paths. Let H be the union of H(cid:48) and G[Y ]. Then the paths in ˜P(t) originate at the vertices of
At lying on Ct, terminate at the vertices of Y , and are internally disjoint from C ∪ Y . Moreover, since
˜P is a good linkage, all paths in ˜P \ ˜P(t) are disjoint from graph H(cid:48). Using Theorem 2.5, we can ﬁnd a
new set P(cid:48)(t) of p1 disjoint paths in graph H(cid:48), connecting vertices of V (Ct) to vertices of V (Ct0). The
paths in P(cid:48)(t) are guaranteed to be disjoint from all paths in ˜P \ P(cid:48)(t), and they remain monotone
with respect to Z1(t0), . . . , Z∆2(t0), since the paths in ˜P(t) had this property, and D∗(t)∩ D∗(t0) = ∅.
They also remain disjoint from all discs ˜D(t(cid:48)) for all t(cid:48) ∈ T3 distinct from t. We replace the paths
of ˜P(t) with the paths of P(cid:48)(t) in ˜P, obtaining a new good A–B linkage, and continue to the next
iteration. The ﬁnal set P(cid:48) of paths is obtained from ˜P once all terminals of T3 are processed.

35

Step 3: Ensuring Property (C3)

(cid:16)(cid:83)

t∈T3∪{t0} Z(t),P(cid:17)

P(cid:48)(cid:48)(t)(cid:1) ∪(cid:0)(cid:83)

s∈S4

P(cid:48)(s)(cid:1).

, that has properties (C1) and (C2).

So far we have constructed a p1-crossbar
In this step we will discard some demand pairs from M3, and some paths from sets P(t) for terminals
t ∈ T3, so that the resulting set M∗ of the demand pairs, together with the shells around their
destination vertices, and the resulting set P∗ of paths give a good crossbar. We do not alter the paths
themselves, so Properties (C1) and (C2) will continue to hold.
Consider some path P ∈ P, and recall that P is monotone with respect to Z1(t0), . . . , Z∆2(t0). Let P (cid:48)
be the sub-path of P , starting from its ﬁrst vertex (that lies in A), and terminating at the ﬁrst vertex
of P that lies on Z∆2(t0). Let P(cid:48) = {P (cid:48) | P ∈ P}. As before, for every terminal t ∈ T3, we denote
by P(cid:48)(t) ⊆ P(cid:48) the set of paths originating at the vertices of At, and for each s ∈ S3, we denote by
P(cid:48)(s) ⊆ P(cid:48) the set containing the unique path originating from s. Let e∗ be any edge of Z∆2(t0), and
let R∗ be the path Z∆2(t0) \ e∗. We prove the following theorem.
Theorem 6.16 There is an eﬃcient algorithm to compute a subset M4 ⊆ M3 of Ω(κ3/ log n) demand
pairs, and to select, for each terminal t ∈ T (M4) ∩ T3 a subset P(cid:48)(cid:48)(t) ⊆ P(cid:48)(t) of Ω(p1) paths, such
that there is a partition Σ = {σ(v) | v ∈ T (M4)} of R∗ into disjoint segments, where for each t ∈
T (M4)∩ T3, the paths in P(cid:48)(cid:48)(t) are disjoint from R∗ \ σ(t), while for each s ∈ T (M4)∩ S3, the unique
path in P(cid:48)(s) is disjoint from R∗ \ σ(s).
Let S4 and T4 denote the sets of all source and all destination vertices of the demand pairs in M4.

Let P(cid:48)(cid:48) =(cid:0)(cid:83)

t∈T4

In other words, Theorem 6.16 ensures that for each terminal t ∈ T4, the endpoints of the paths in P(cid:48)(cid:48)(t)
appear on R∗ consecutively, with respect to the endpoints of all paths in P(cid:48)(cid:48). It is now immediate
to complete the construction of the good crossbar for M4. For every path P ∈ P(t) for all t ∈ T4,
we include P in set P∗ only if the corresponding path P (cid:48) ∈ P(cid:48) belongs to P(cid:48)(cid:48). Since the paths in P
are monotone with respect to Z1(t0), . . . , Z∆2(t0), it is easy to see that Property (C3) is satisﬁed in
the resulting crossbar, and we obtain a good p∗-crossbar for M4, with p∗ = Ω(p1) = Ω(∆/κ0), and
|M4| = Ω(κ0/ log n), as required. We now focus on the proof of Theorem 6.16.
Proof of Theorem 6.16. Let G(cid:48) be the graph obtained from G, after removing all vertices and edges
∆2(t0). Observe that all paths in P(cid:48) are still contained in G(cid:48). We view the face of G(cid:48) where
lying in D◦
t0 used to reside as the outer face. Therefore, for each terminal t ∈ T3, the paths of P(cid:48)(t) now connect
the vertices of V (Ct) to the vertices lying on the boundary of the outer face.
Consider any destination vertex t ∈ T3, and let Q ⊆ P(cid:48)(t) be any subset of its corresponding paths,
with |Q| > 2. Let σ be the shortest sub-path of R∗, containing all endpoints of the paths in Q. Taking
the union of σ, Q and Z∆2(t), we obtain a new auxiliary graph H(t,Q). Let γ(t,Q) be the closed curve
serving as the outer boundary of this graph, and let D(t,Q) be the disc whose boundary is γ(t,Q).
Given two destination vertices t, t(cid:48) ∈ T3 with t (cid:54)= t(cid:48), and any two subsets Q(t) ⊆ P(cid:48)(t) and Q(t(cid:48)) ⊆
P(cid:48)(t(cid:48)) of paths, notice that the discs D(t,Q(t)) and D(t(cid:48),Q(t(cid:48))) are either completely disjoint from
each other, or one is contained in the other. We say that there is a conﬂict between (t,Q(t)) and
(t(cid:48),Q(t(cid:48))) in the latter case. We also say that there is a conﬂict between (t,Q(t)) and a source vertex
s ∈ S3, if s ∈ D(t,Q(t)).
Let ˜M1 = M3. Over the course of this step, we will deﬁne a series of subsets of demand pairs,
˜M3 ⊆ ˜M2 ⊆ ˜M1, where | ˜M3| = Ω(| ˜M1|/ log n). For each 1 ≤ i ≤ 3, we will denote by ˜Si and
˜Ti the sets of the source and the destination vertices of the pairs in ˜Mi, respectively. Our ﬁnal
set of the demand pairs will be M∗ = ˜M3. For every terminal t ∈ T (M∗), we will deﬁne a series

36

of subsets of paths Q3(t) ⊆ Q2(t) ⊆ Q1(t), where we let Q1(t) = P(cid:48)(t), and we will ensure that
|Q3(t)| = Ω(|Q1(t)|) = Ω(p1). Moreover, we will ensure that for all t, t(cid:48) ∈ ˜T3, there is no conﬂict
between (t,Q3(t)) and (t(cid:48),Q3(t(cid:48))), and for all s ∈ ˜S3 and t ∈ ˜T3, there is no conﬂict between (t,Q3(t))
and s.
Our ﬁrst step is to eliminate all conﬂicts between the destination vertices in ˜T1. We build a graph F ,
whose vertex set is ˜T1, and there is a directed edge (t(cid:48), t) iﬀ (i) t (cid:54)= t(cid:48); (ii) D(t(cid:48),Q1(t(cid:48))) ⊆ D(t,Q1(t));
and (iii) there is no terminal t(cid:48)(cid:48) ∈ ˜T1 \ {t, t(cid:48)} with D(t(cid:48),Q1(t(cid:48))) ⊆ D(t(cid:48)(cid:48),Q1(t(cid:48)(cid:48))) ⊆ D(t,Q1(t)). It is
easy to see that F is a directed forest.

We use Claim 2.2, to obtain a partition (cid:8)R1, . . . , R(cid:100)log n(cid:101)(cid:9) of V (F ) into subsets, such that, for each

1 ≤ j ≤ (cid:100)log n(cid:101), F [Rj] is a collection Yj of disjoint paths, and if vertices v, v(cid:48) ∈ Rj lie on two distinct
paths in Yj, then neither is a descendant of the other in F .
Clearly, there is an index 1 ≤ j ≤ (cid:100)log n(cid:101), with |Rj| ≥ | ˜T1|/(cid:100)log n(cid:101). We let ˜M2 ⊆ ˜M1 be the set of
the demand pairs whose destination vertices lie in Rj, and we deﬁne the sets ˜S2 and ˜T2 of source and
destination vertices accordingly. For each t ∈ ˜T2, we now deﬁne a subset Q2(t) ⊆ Q1(t) of paths, to
ensure that there are no conﬂicts between the terminals in ˜T2.
Recall that F [Rj] = Yj is a collection of paths, and for vertices v, v(cid:48) ∈ Rj, if there is a directed path
from v to v(cid:48) in F , then v, v(cid:48) lie on the same path in Yj. Therefore, if t, t(cid:48) do not lie on the same path in
Yj, there is no conﬂict between (t,Q1(t)) and (t(cid:48),Q1(t(cid:48))). So we only need to resolve conﬂicts between
terminals lying on the same path of Yj.
Let P = (t1, t2, . . . , tr) be any such directed path. Then D(t1,Q1(t1)) ⊆ D(t2,Q1(t2)) ⊆ ··· ⊆
D(tr,Q1(tr)). Disc D(tr−1,Q1(tr−1)) partitions the paths in Q1(tr) into two subsets, that go on each
side of the disc. By discarding the paths in one of these two subsets (the one containing fewer paths),
we can eliminate the conﬂict between tr and the remaining terminals on path P . Therefore, there is
a subset Q2(tr) ⊆ Q1(tr), containing at least |Q1(tr)|/2 paths, such that (tr,Q2(tr)) has no conﬂict
with (ti,Q1(ti)) for any 1 ≤ i < r. We process all other terminals t ∈ P similarly, obtaining a subset
Q2(t) ⊆ Q1(t) of paths, where |Q2(t)| ≥ |Q1(t)|/2, and for all t, t(cid:48) ∈ P with t (cid:54)= t(cid:48), there is no conﬂict
between (t,Q2(t)) and (t(cid:48),Q2(t(cid:48))).
This completes the deﬁnition of the set ˜M2 of demand pairs, and the corresponding sets Q2(t) of
paths for t ∈ ˜T2. Our next step is to eliminate conﬂicts between pairs (t,Q2(t)) for t ∈ ˜T2 and the
sources s ∈ ˜S2. For every demand pair (s, t) ∈ ˜M2, if there is a conﬂict between (t,Q2(t)) and s,
then we can discard a subset of at most half the paths from Q2(t) in order to eliminate this conﬂict.
The resulting set of paths is denoted by Q3(t). Therefore, we will assume from now on that for every
demand pair (s, t) ∈ ˜M2, there is no conﬂict between (t,Q3(t)) and s.

, and there is a directed

Finally, we build a conﬂict graph H, whose vertex set is

edge (vs,t, vs(cid:48),t(cid:48)) iﬀ there is a conﬂict between s and (t(cid:48),Q3(t(cid:48))). Since the discs {D(t,Q3(t))}t∈ ˜T2
are
all disjoint, every vertex vs,t has at most one out-going edge. Therefore, every vertex-induced sub-
graph of H has at least one vertex whose total degree (counting the incoming and the outgoing edges)
is at most 2. Using standard techniques, we can ﬁnd an independent set I of vertices in H, with
|I| = Ω(|V (H)|). Our ﬁnal set ˜M3 of demand pairs contains all pairs (s, t) with vs,t ∈ I. We deﬁne
the sets ˜S3 and ˜T3 of the source and the destination vertices accordingly, and the sets Q3(t) for the
destination vertices t ∈ ˜T3 remain the same. From the above discussion, for each t, t(cid:48) ∈ ˜T3 with t (cid:54)= t(cid:48),
there is no conﬂict between (t,Q3(t)) and (t(cid:48),Q3(t(cid:48))), and for all s ∈ ˜S3, t(cid:48) ∈ ˜T3, there is no conﬂict
between (t(cid:48),Q3(t(cid:48))) and s. For every source vertex s ∈ ˜S3, the set Q3(s) contains the same path as
the original set P(cid:48)(s).
(cid:3)

(cid:110)

vs,t | (s, t) ∈ ˜M2

(cid:111)

37

7 Case 2: Heavy Demand Pairs.

In this case, we assume that at least 0.7|M| demand pairs are heavy. Let H = {X1, . . . , Xq} ⊆ X
be the collection of all heavy subsets of terminals, so q ≤ 2W/τ , and let Mh be the set of all heavy
demand pairs, so for all (s, t) ∈ Mh, both s and t lie in the sets of H.
We partition the set Mh of demand pairs into q2 subsets, where for 1 ≤ i, j ≤ q, set Mi,j contains all
demand pairs (s, t) with s ∈ Xi and t ∈ Xj (notice that it is possible that i = j). We then ﬁnd an
approximate solution to each resulting problem separately. The main theorem of this section is the
following.
Theorem 7.1 There is an eﬃcient algorithm, that for each 1 ≤ i, j ≤ q, computes a subset M(cid:48)
i,j ⊆
Mi,j of at least 5|Mi,j|/6 demand pairs, and a collection Pi,j of node-disjoint paths routing a subset
of the demand pairs in M(cid:48)
, for some universal
constants c1 and c2.

i,j in G, with |Pi,j| ≥ min

Before we prove this theorem, we show that it concludes the proof of Theorem 4.3 for Case 2. Let set
(i,j)∈π Mi,j.
Since the total number of heavy demand pairs is at least 0.7|M|, it is easy to verify that | ˜M| ≥ 0.6|M|.
We apply Theorem 7.1, to compute, for each (i, j) ∈ π, the subset M(cid:48)
i,j ⊆ Mi,j of at least 5|Mi,j|/6
demand pairs and the corresponding set Pi,j of paths routing a subset of the demand pairs in M(cid:48)
i,j.

π contain all pairs (i, j) with 1 ≤ i, j ≤ q, such that |Mi,j| ≥ 0.1|M|/q2, and let ˜M =(cid:83)
Let ˜M(cid:48) ⊆ ˜M be the set of all demand pairs in(cid:83)
i,j| ≥ (cid:88)

5|Mi,j|/6 = 5| ˜M|/6 ≥ |M|/2.

(cid:110) OPT(G,M(cid:48)

(i,j)∈π M(cid:48)

αWL·|M(cid:48)
c2∆2
0

i,j )
0 log3 n ,

| ˜M(cid:48)| =

(cid:88)

i,j. Then:

|M(cid:48)

c1∆8

(cid:111)

i,j|

(i,j)∈π

(i,j)∈π

If, for any (i, j) ∈ π, we obtain a solution with |Pi,j| ≥
set Pi,j as our ﬁnal solution.

Substituting ∆0 = O(∆ log n), ∆ =(cid:6)W 2/19(cid:7), q = O(W/τ ), and τ = W 18/19, we get that:

213·αAKR·c1c2q2∆8

W

0 log3 n·log k , then we return the

(cid:18)
(cid:32)
(cid:32)

|Pi,j| ≥ Ω

≥ Ω

= Ω

(cid:19)

(cid:33)

W τ 2

W 2∆8 log11 n log k

W 36/19

W · W 16/19 log11 n log k

(cid:33)

.

W 1/19

log11 n log k

Otherwise, for all (i, j) ∈ π, the resulting solution |Pi,j| <
0 log3 n·log k . We then return
the subset ˜M(cid:48) of demand pairs. As observed above, | ˜M(cid:48)| ≥ |M|/2, so it is now enough to show that
OPT(G, ˜M(cid:48)) ≤ w∗| ˜M(cid:48)|/8.
Assume otherwise, and let P∗ be a solution to instance (G, ˜M(cid:48)), routing a subset M∗ ⊆ ˜M(cid:48) of at
least w∗| ˜M(cid:48)|/8 ≥ w∗|M|/16 demand pairs. Then there is a pair of indexes (i, j) ∈ π, such that
16q2 . From Theorem 7.1, we compute a set Pi,j of
|M∗∩M(cid:48)
16q2 . Therefore, OPT(G,M(cid:48)
i,j|
0 log3 n , or |Pi,j| ≥ αWL·|M(cid:48)
paths, routing a subset of demand pairs of M(cid:48)

i,j) ≥ w∗|M|
i,j, with either |Pi,j| ≥ OPT(G,M(cid:48)

i,j| ≥ w∗|M|

213·αAKR·c1c2q2∆8

c2∆2
0

c1∆8

i,j )

W

.

38

In the former case,

|Pi,j| ≥ OPT(G,M(cid:48)
i,j)
0 log3 n
while in the latter case, observe that |M(cid:48)
˜M . Therefore,

c1∆8

≥

w∗|M|
16c1q2∆8

0 log3 n

=

W
16c1q2∆8

0 log3 n

,

i,j| ≥ 5|Mi,j|/6 ≥ |M|/(12q2) from the deﬁnition of π and

|Pi,j| ≥ αWL · |M(cid:48)
i,j|

c2∆2
0

≥

w∗ · |M|

12 · 512 · αAKR · c2q2∆2

0 log k

>

213 · αAKR · c1c2q2∆8

W

0 log2 n log k

,

a contradiction.
From now on we focus on proving Theorem 7.1. We ﬁx a pair of indices 1 ≤ i, j ≤ q. In order to simplify
the notation, we denote Mi,j by N , Xi by X and Xj by Y . Our goal is to compute a subset N (cid:48) ⊆ N
of at least 5|N|/6 demand pairs, together with a set P of at least min
disjoint paths, routing a subset of the demand pairs in N (cid:48). Let x ∈ X and y ∈ Y be any pair
of terminals. Recall that for every terminal t ∈ T (N ) ∩ X, d(t, x) ≤ ∆0, and for every terminal
t ∈ T (N )∩Y , d(t, y) ≤ ∆0. We consider two subcases. The ﬁrst subcase happens when d(x, y) > 5∆0,
and otherwise the second subcase happens. Note that the second subcase includes the case where
X = Y .

(cid:16) OPT(G,N (cid:48))

(cid:16) αWL|N (cid:48)|

(cid:17)(cid:111)

0 log3 n

(cid:110)

(cid:17)

, Ω

∆2
0

∆8

Ω

7.1 Subcase 2a: d(x, y) > 5∆0
In this case, we set N (cid:48) = N . We will compute a set P of at least Ω
node-disjoint paths,
routing a subset of the demand pairs in N . We start by deﬁning a simpler special case of the problem,
and show that we can ﬁnd a good approximation algorithm for this special case. The special case is
somewhat similar to routing on a cylinder, and we solve it by reducing it to this setting. We then
show that the general problem in Case 2a reduces to this special case.

0 log n

∆6

(cid:16) OPT(G,N )

(cid:17)

A Special Case

Suppose we are given a connected planar graph ˆG embedded on the sphere, and two disjoint simple
cycles Z, Z(cid:48) in ˆG. Suppose also that we are given a set ˆM of demand pairs, where all source vertices
lie on Z and all destination vertices lie on Z(cid:48) (we note that the same vertex may participate in a
number of demand pairs). Let D(Z), D(Z(cid:48)) be two discs with boundaries Z and Z(cid:48), respectively, so
that D(Z) ∩ D(Z(cid:48)) = ∅. Assume additionally that we are given a closed ˆG-normal curve C of length
at most ∆, that is contained in D◦(Z), so that for every vertex v ∈ Z, there is a ˆG-normal curve γ(v)
of length at most 2∆0 connecting v to a vertex of C, and γ(v) is internally disjoint from Z and C.
Similarly, assume that we are given a closed ˆG-normal curve C(cid:48) of length at most ∆, that is contained
in D◦(Z(cid:48)), so that for every vertex v(cid:48) ∈ Z(cid:48) there is a ˆG-normal curve γ(v(cid:48)) of length at most 2∆0,
connecting v(cid:48) to a vertex of C(cid:48), and γ(v(cid:48)) is internally disjoint from Z(cid:48) and C(cid:48) (see Figure 5). This
ﬁnishes the deﬁnition of the special case. The following theorem shows that we can obtain a good
approximation for it.
Theorem 7.2 There is an eﬃcient algorithm, that, given any instance ( ˆG, ˆM) of the NDP problem
as above, computes a solution of value at least Ω

(cid:16) OP T ( ˆG, ˆM)

(cid:17)

.

∆2

0 log n

39

Figure 5: The special case, with the terminals shown in red.

(cid:17)

log n

(cid:17)

.

(cid:16) OPT( ˆG, ˆM)

(cid:16) OPT( ˆG(cid:48), ˆM)

Proof: The algorithm is very simple: we reduce the problem to routing on a cylinder, by creating two
holes in the sphere. The ﬁrst hole is D(Z): we delete all edges and vertices that appear inside the disc,
except for the edges and the vertices of Z. The second hole is D(Z(cid:48)): we similarly delete all edges and
vertices that lie inside the disc, except for those lying on its boundary. Let ˆG(cid:48) be the resulting graph.
We then apply the O(log n)-approximation algorithm for NDP-Cylinder to the resulting problem, to
obtain a routing of at least Ω
demand pairs. In order to complete the analysis of the
algorithm, it is enough to prove that OPT( ˆG(cid:48), ˆM) ≥ Ω
Notice that we can assume without loss of generality that all curves in set {γ(v) | v ∈ V (Z)} are
mutually non-crossing, and moreover, whenever two curves meet, they continue together. In other
words, for all v, v(cid:48) ∈ V (Z), γ(v) ∩ γ(v(cid:48)) is a contiguous curve that has a vertex of C as its endpoint.
We make a similar assumption for curves in {γ(v) | v ∈ V (Z(cid:48))}.
Consider the optimal solution to instance ( ˆG, ˆM), and let P0 be the set of paths in this solution. We
will gradually modify the set P0 of paths, to obtain path sets P1,P2, . . ., until we obtain a feasible
solution to instance ( ˆG(cid:48), ˆM). For every i ≥ 0, we will denote by ˆMi the set of the demand pairs
routed by Pi, and by κi its cardinality. Recall that κ0 = OPT( ˆG, ˆM). We assume that κ0 ≥ 512∆2
0, as
otherwise a solution routing a single demand pair gives the desired approximation, and such a solution
exists in ˆG(cid:48), as it must be connected.
We delete from P0 all paths that use the vertices of C or C(cid:48). Since both curves have length at most
∆, we delete at most 2∆ paths in this step. Let P1 be the resulting set of paths, and ˆM1 the set of
the demand pairs routed by P1.
Our next step is to build a conﬂict graph H. Its set of vertices, V (H) =
. There
is a directed edge from v(s, t) to v(s(cid:48), t(cid:48)), iﬀ the path P (s, t) ∈ P1 routing the pair (s, t) contains
a vertex of V (γ(s(cid:48))) ∪ V (γ(t(cid:48))), and we say that there is a conﬂict between (s, t) and (s(cid:48), t(cid:48)) in this
case. Since we assume that the paths in P1 are node-disjoint, and since |V (γ(s(cid:48)))|,|V (γ(t(cid:48)))| ≤ 2∆0
for all (s(cid:48), t(cid:48)) ∈ ˆM1, the in-degree of every vertex in H is at most 4∆0. Therefore, the average degree
(including the incoming and the outgoing edges) of every induced sub-graph of H is at most 8∆0, and
there is an independent set I ⊆ V (H) of cardinality at least
Let ˆM2 be the set of all demand pairs (s, t) with v(s, t) ∈ I, and let P2 ⊆ P1 be the set of paths
routing the demand pairs in ˆM2. Recall that the paths in P2 are disjoint from C ∪ C(cid:48). Moreover, if
P (s, t) ∈ P2 is the path routing the pair (s, t) ∈ ˆM2, then for every demand pair (s(cid:48), t(cid:48)) (cid:54)= (s, t) in
ˆM2, path P (s, t) is disjoint from both γ(s(cid:48)) and γ(t(cid:48)). It is now easy to verify that the demand pairs
in ˆM2 are non-crossing, that is, we can ﬁnd an ordering ˆM2 = {(s1, t1), . . . , (sκ2, tκ2)} of the demand
pairs in ˆM2, so that s1, . . . , sκ2 appear in this counter-clock-wise order on Z, while t1, . . . , tκ2 appear
in this clock-wise order on Z(cid:48).

v(s, t) | (s, t) ∈ ˆM1

|P1|
8∆0+1 ≥ |P0|

16∆0

in H.

(cid:110)

(cid:111)

∆2
0

40

CZZ￿C￿(cid:106) κ2

8∆0

≥ |P0|

512∆2
0

32∆0

(cid:107)− 1, and let ˆM3 = {(s8∆0r, t8∆0r) | 1 ≤ r ≤ κ3}. In other words, we space the demand

r | 1 ≤ r ≤ κ3}. The crux of the analysis is the following lemma.

Let κ3 =
pairs in ˆM2 out, by adding one in 8∆0 such pairs to ˆM3. Let P3 ⊆ P2 be the set of paths routing
the demand pairs in M3, so |P3| ≥ |P2|
. Our ﬁnal step is to show that all demand pairs
in ˆM3 can be routed in graph ˆG(cid:48) via node-disjoint paths. In order to do so, for each such demand
pair (s8∆0r, t8∆0r), we deﬁne a segment µr of Z containing s8∆0r, and a segment µ(cid:48)
r of Z(cid:48) containing
t8∆0r, as follows. For convenience, denote 8∆0r by (cid:96). The ﬁrst segment, µr, is simply the segment of
Z from s(cid:96)−4∆0 to s(cid:96)+4∆0−1, as we traverse Z in the counter-clock-wise order. The second segment, µ(cid:48)
r,
is the segment of Z from t(cid:96)−4∆0 to t(cid:96)+4∆0−1, as we traverse Z(cid:48) in the clock-wise order. It is immediate
to verify that all segments of Z in {µr | 1 ≤ r ≤ κ3} are mutually disjoint, and the same holds for all
segments of Z(cid:48) in {µ(cid:48)
Lemma 7.3 Let (s8∆0r, t8∆0r) ∈ M3 be any demand pair, and let P ∈ P3 be the path routing it. Then
P ∩ Z ⊆ µr, and P ∩ Z(cid:48) ⊆ µ(cid:48)
r.
Before we prove this lemma, we show that we can use it to obtain a routing of the demand pairs in ˆM3
in graph ˆG(cid:48) via node-disjoint paths. Let (s(cid:96), t(cid:96)) ∈ ˆM3 be any demand pair (where (cid:96) = 8∆0r for some
1 ≤ r ≤ κ3), and let P(cid:96) be the path routing (s(cid:96), t(cid:96)) in P3, that we view as directed from s(cid:96) towards
t(cid:96). Clearly, P(cid:96) intersects both µr and µ(cid:48)
r. Let v(cid:96) be the last vertex of P(cid:96) lying on µr. Then there is
some other vertex appearing on P(cid:96) after v(cid:96) that belongs to µ(cid:48)
(cid:96) be the ﬁrst such vertex on
(cid:96). Let P ∗
P(cid:96), and we let P (cid:48)
(cid:96) be the path obtained as follows: we
(cid:96) to v(cid:48)
start with a segment of µr between s(cid:96) and v(cid:96); we then follow P (cid:48)
(cid:96), and ﬁnally we use a segment
r between v(cid:48)
of µ(cid:48)
(cid:96) and t(cid:96). From Lemma 7.3, it is immediate to verify that the resulting paths in set
(cid:96) | (cid:96) = 8∆0r; 1 ≤ r ≤ κ3} are completely disjoint, contained in ˆG(cid:48), and they route all demand pairs
{P ∗
in ˆM3. It now remains to prove Lemma 7.3.
Proof: Fix some demand pair (s8∆0r, t8∆0r) ∈ M3, and let P ∈ P3 be the path routing it. We show
that P ∩ Z ⊆ µr. The proof that P ∩ Z(cid:48) ⊆ µ(cid:48)
r is symmetric. For convenience, we denote 8∆0r by (cid:96)
from now on.
Assume otherwise, and let v be the ﬁrst vertex on P that belongs to Z \ µr. Let P (cid:48) be the sub-path
of P from its ﬁrst vertex to v. Consider the planar embedding of ˆG, where we ﬁx any face contained
in D(Z(cid:48)) as the outer face. In this planar embedding, denote by Y the union of D(C), γ(s(cid:96)), P (cid:48), and
γ(v), and let R be the outer boundary of Y (notice that P (cid:48) may intersect γ(s(cid:96)), and that γ(s(cid:96)), γ(v)
are not necessarily disjoint).

(cid:96) be the segment of P(cid:96) between v(cid:96) and v(cid:48)

r. We let v(cid:48)

Figure 6: Constructing the curve R

Notice that, since there are no conﬂicts in P2, curve R does not cross any curve in C(cid:48)∪{γ(th) | 1 ≤ h ≤ κ2},
and so all destination vertices of the demand pairs in ˆM2 lie on the outside of R. Let S1 =

41

vP￿s￿γ(s￿)γ(v)CZµr{s(cid:96)−4∆0, . . . , s(cid:96)−1}, and S2 = {s(cid:96)+1, . . . , s(cid:96)+4∆0−1}. Denote Γ1 = {γ(si) | si ∈ S1} and Γ2 = {γ(si) | si ∈ S2}.
Since the curves in set {γ(u) | u ∈ V (Z)} are non-crossing, if σ, σ(cid:48) are the two segments of Z whose
endpoints are s(cid:96) and v, then all vertices of S1\{v} lie on one of the segments (say σ), while all vertices
of S2 \{v} lie on the other segment. Moreover, since path P (cid:48) cannot cross any curve in Γ1 ∪ Γ2, either
all sources of S1, or all sources of S2 lie inside the curve R - let us assume that it is the former.

All sources of S1 are separated by R from their destinations vertices, and yet all corresponding demand
pairs are routed by P2. Therefore, at least 4∆0 − 2 paths in P2 must cross the curve R. Recall that
none of these paths can cross C, P (cid:48), or γ(s(cid:96)). Therefore, all these paths must cross γ(v). But since
the length of γ(v) is at most 2∆0, and the paths are node-disjoint, this is impossible.

Completing the Proof

We now complete the proof of Theorem 7.1 for Case 2a, by reducing it to the special case deﬁned
above.
We assume that OPT(G,N ) > 213∆4
0, since otherwise we can route a single demand pair and obtain a
valid solution. We denote by S and T the sets of all source and all destination vertices of the demand
pairs in N , respectively.
Our ﬁrst step is to construct shells Z(x) = (Z1(x), . . . , Z2∆0(x)) and Z(y) = (Z1(y), . . . , Z2∆0(y))
of depth 2∆0 around x and y, respectively. We would like to ensure that disc D(Z2∆0(x)) contains
all terminals of X and no terminals of Y , and similarly, disc D(Z2∆0(y)) contains all terminals of
In order to ensure this, when constructing the shell Z(x), we let the
Y and no terminals of X.
face Fx (that is viewed as the outer face in the plane embedding of G when constructing the shell)
be the face incident on the terminal y, and similarly we let Fy be the face incident on x (recall
that d(x, y) > 5∆0, so this choice of faces is consistent with the requirement that the shell depth
is bounded by min{dGNC(v, Cx)} − 1 over all vertices v lying on the boundary of Fx). Let Z(x) =
(Z1(x), . . . , Z2∆0(x)) and Z(y) = (Z1(y), . . . , Z2∆0(y)) be the resulting shells.

Claim 7.4 Disc D(Z2∆0(x)) contains all terminals of X and no terminals of Y , and similarly, disc
D(Z2∆0(y)) contains all terminals of Y and no terminals of X. Moreover, D(Z2∆0(x))∩D(Z2∆0(y)) =
∅.

Proof: Let t ∈ X be any terminal, and assume for contradiction that t (cid:54)∈ D(Z2∆0(x)). Recall that
d(x, t) ≤ ∆0, and so there is a G-normal curve γ of length at most ∆0, connecting some vertex v ∈ Ct
to some vertex u ∈ Cx. Then every vertex v(cid:48) ∈ Ct has a G-normal curve γ(v(cid:48)) of length at most ∆0 +∆
connecting it to u. Therefore, all vertices of Ct lie in the disc D(Z∆0+∆(x)) (if some vertex v(cid:48) ∈ Ct
does not lie in this disc, then there are ∆0 + ∆ disjoint cycles separating v(cid:48) from u, a contradiction).
We conclude that all vertices of Ct lie in disc D(Z2∆0(x)), but t does not lie in that disc. This can
only happen if the outer face Fx ⊆ Dt, meaning that y lies in Dt. But then, from our deﬁnition of
enclosures, d(t, y) = 1 must hold. However, t ∈ X, y ∈ Y , and X (cid:54)= Y , so d(t, y) ≥ 5∆ from the
deﬁnition of the family X of sets of terminals, a contradiction. We conclude that all terminals of X
lie in disc D(Z2∆0(x)). Using a similar reasoning, all terminals of Y lie in disc D(Z2∆0(y)).
In order to complete the proof of the theorem it is now enough to show that D(Z2∆0(x))∩D(Z2∆0(y)) =
∅. Observe that from Property (J5) of the shells, the vertices of V (Dy) all lie outside the disc
D(Z2∆0(x)), as all such vertices belong to the connected component Yx. Therefore, y ∈ D(Z2∆0(y)) \
D(Z2∆0(x)), and similarly x ∈ D(Z2∆0(x)) \ D(Z2∆0(y)), so neither of the two discs is contained in
the other. Assume for contradiction that the intersection of the two discs is non-empty. Observe ﬁrst

42

that the boundaries of the two discs cannot intersect. Indeed, assume otherwise, and let v be any
vertex lying in Z2∆0(x) ∩ Z2∆0(y). Then there are G-normal curves γ and γ(cid:48) of length at most 2∆0
each, connecting v to a vertex of Cx and a vertex of Cy, respectively, implying that d(x, y) ≤ 4∆0,
a contradiction. Therefore, all vertices of Z2∆0(y) must lie inside the disc D(Z2∆0(x)). However, the
vertices of Cy lie outside D(Z2∆0(x)), and at least one such vertex v can be connected to some vertex
of Z2∆0(y) with a G-normal curve of length at most 2∆0 + 1. This curve must intersect Z2∆0(x) at
some vertex that we denote by u, and u can be in turn connected to a vertex of Cx by a G-normal
curve of length at most 2∆0 + 1, implying that d(x, y) < 5∆0, a contradiction.

For consistency of notation, we will denote Z0(x) = Cx and Z0(y) = Cy, even though both Cx and Cy
are G-normal curves and not cycles.

h(cid:48)=0 V (Zh(cid:48)(y)). For each 1 ≤ h ≤ 2∆0, let Uh be the set
of vertices lying in D◦(Zh(x)) \ D(Zh−1(x)), and let Rh be the set of all connected components of
G[Uh]. For each 1 ≤ h(cid:48) ≤ 2∆0, we deﬁne U(cid:48)
h(cid:48) and R(cid:48)
h(cid:48) with respect to the shell Z(y) similarly. Let

Let U = (cid:83)2∆0
R =(cid:83)2∆0

h=0 V (Zh(x)), and let U(cid:48) = (cid:83)2∆0
h=1 Rh and let R(cid:48) =(cid:83)2∆0

h(cid:48)=1 R(cid:48)
h(cid:48).

Our next step is to deﬁne a mapping β : S → 2U of all source vertices in S to subsets of vertices of U ,
and a mapping β(cid:48) : T → 2U(cid:48)
of all destination vertices in T to subsets of vertices of U(cid:48). Every vertex
in S ∪ T will be mapped to a subset of at most three vertices. We will then replace each demand pair
(s, t) with the set β(s) × β(cid:48)(t) of demand pairs. Eventually, for every pair 0 ≤ h, h(cid:48) ≤ 2∆0 of indices,
we will deﬁne a subset ˜Mh,h(cid:48) of the new demand pairs, containing all pairs whose sources lie on Zh(x)
and destinations lie on Zh(cid:48)(y), to obtain an instance of the special case, that will then be solved using
Theorem 7.2.
We start by deﬁning the mapping of the sources. For every source s ∈ S, we will also deﬁne a curve
Γ(s) that we will use later in our analysis. First, for every source vertex s ∈ S ∩ U , we set β(s) = {s},
and we let Γ(s) contain the vertex s only. Next, ﬁx any vertex v∗ ∈ Cx. For every source vertex
s ∈ V (Dx) \ V (Cx), we set β(s) = {v∗}, and Γ(s) = Cx. Finally, consider some component R ∈ Rh,
for some 1 ≤ h ≤ 2∆0, and let s ∈ S ∩ V (R) be any source lying in R. If |L(R)| ≤ 2, then we let
β(s) = L(R) ∪ {u(R)} if u(R) is deﬁned, and β(s) = L(R) otherwise.
If |L(R)| > 2, then we let
β(s) = {v}, where v is a leg of R, such that v is not an endpoint of σ(R) (so it is not the ﬁrst and not
the last leg of R). We then let Γ(s) be the outer boundary γ(R) of the disc η(R) given by Theorem 5.5.
Recall that the length of Γ(s) is bounded by 4∆0 + ∆/2 + 1 < 5∆0. Notice that for every source s ∈ S,
we now have deﬁned a G-normal curve Γ(s) of length at most 5∆0. An important property of this
curve is that the disc whose boundary is Γ(s) cannot contain any demand pair in N , as the disc itself
is contained in D(Z2∆0(x)). We deﬁne the mapping β(cid:48) : T → 2U(cid:48)
, and the corresponding curves Γ(t)
for the destination vertices t ∈ T similarly.

(s,t)∈N β(s) × β(cid:48)(t). In the following two theorems, we show that the problems (G,N ) and

(G, ˜M) are equivalent to within relatively small factors.
Theorem 7.5 There is an eﬃcient algorithm, that, given any solution to instance (G, ˜M), that routes
κ demand pairs, ﬁnds a solution to instance (G,N ), routing at least

demand pairs.

Let ˜M =(cid:83)

κ

21∆0

Proof: Let P0 be any collection of disjoint paths in graph G, routing a subset ˜M0 ⊆ ˜M of κ demand
pairs. We assume that κ ≥ 21∆0, as otherwise we can return a routing of a single demand pair in N .
For every demand pair (˜s, ˜t) ∈ ˜M0, let (s, t) be any corresponding demand pair in N , that is, ˜s ∈ β(s)
and ˜t ∈ β(cid:48)(t).

, and there is a directed edge
We build a conﬂict graph H, whose vertex set is
from v(˜s1, ˜t1) to v(˜s2, ˜t2) iﬀ the unique path P (˜s1, ˜t1) ∈ P0 routing the pair (˜s1, ˜t1) intersects Γ(s2)

v(˜s, ˜t) | (˜s, ˜t) ∈ ˜M0

(cid:111)

(cid:110)

43

κ

in H.

21∆0

(cid:111)

(cid:110)

or Γ(t2) (in which case we say that there is a conﬂict between (˜s1, ˜t1) and (˜s2, ˜t2)). Since all paths in
P0 are node-disjoint, and all curves Γ(s), Γ(t) have lengths at most 5∆0, the in-degree of every vertex
in H is at most 10∆0. Therefore, we can eﬃciently compute an independent set I of size at least
20∆0+1 ≥ κ

Let ˜M1 = (cid:8)(˜s, ˜t) | v(˜s, ˜t) ∈ I(cid:9), and let P1 ⊆ P0 be the set of paths routing the demand pairs in

(s, t) | (˜s, ˜t) ∈ ˜M1

˜M1. Let M(cid:48) =
. It is now enough to show that all demand pairs in M(cid:48) can be
routed in G. Consider any demand pair (˜s, ˜t) ∈ ˜M1, and let P ∈ P1 be the path routing (˜s, ˜t). We
will extend the path P , so it connects s to t. Notice that if s ∈ U , then s = ˜s. Assume now that
s (cid:54)∈ U . If s ∈ V (Dx) \ V (Cx), then ˜s ∈ V (Cx). Since G[V (Dx)] is a connected graph, we can extend
path P inside the disc Dx, so it now originates at s. As Γ(s) = Cx, no other source of a demand
pair in ˜M1 may lie on Cx, and no other path in P1 contains a vertex of Dx. Finally, assume that
s ∈ V (R) for some component R ∈ R. Since the disc whose boundary is Γ(s) contains R, all vertices
of L(R), and u(R) (if such is deﬁned), no other path in P1 may contain a vertex of L(R) ∪ {u(R)}.
Moreover, since no demand pair in ˜M is contained in the disc whose boundary is Γ(s), no other path
in P1 may intersect R. We extend the path P inside R, so it now originates at s. We perform the
same transformation to path P to ensure that it terminates at t. It is easy to see that the resulting
collection of paths is disjoint.
Theorem 7.6 OPT(G, ˜M) ≥ OPT(G,N )

21∆0

.

21∆0

in H.

Proof: Let P0 be the set of paths in the optimal solution to instance (G,N ), and let M0 be the set
of the demand pairs they route.
As before, we deﬁne a conﬂict graph H, whose vertex set is {v(s, t) | (s, t) ∈ M0}, and there is a
directed edge from v(s1, t1) to v(s2, t2) iﬀ the unique path P (s1, t1) ∈ P0 routing the pair (s1, t1)
intersects Γ(s2) or Γ(t2) (in which case we say that there is a conﬂict between (s1, t1) and (s2, t2)).
Since all paths in P0 are node-disjoint, and all curves Γ(s), Γ(t) have lengths at most 5∆0, the in-
degree of every vertex in H is at most 10∆0. Therefore, there is an independent set I of size at least
OPT(G,N )
20∆0+1 ≥ OPT(G,N )
Let M1 = {(s, t) | v(s, t) ∈ I}, and let P1 ⊆ P0 be the set of paths routing the demand pairs in M1.
We show that we can route |M1| demand pairs of ˜M in G via node-disjoint paths. Let S1 and T1 be
the sets of all source and all destination vertices of the pairs in M1, respectively.
Consider any source vertex s ∈ S1. We say that s is a good source vertex if s ∈ U , or s belongs to
some component R ∈ R, such that |L(R)| ≤ 2. Otherwise, s is a bad source vertex. Notice that if s
is a good source vertex, then the path P ∈ P1 that originates at s must contain a vertex s(cid:48) ∈ β(s):
if s ∈ U , then β(s) = {s}; otherwise, if s ∈ R for some component R ∈ R with |L(R)| ≤ 2, then
β(s) = L(R) ∪ {u(R)} if u(R) is deﬁned, and β(s) = L(R) otherwise. In either case, in order to enter
R, path P has to visit a vertex of β(s). Therefore, if s is a good source vertex, then some vertex s(cid:48) ∈ P
belongs to β(s). Similarly, we say that a destination vertex t ∈ T1 is a good destination vertex if t ∈ U(cid:48)
or t belongs to some component R(cid:48) ∈ R(cid:48) with |L(R(cid:48))| ≤ 2. Otherwise, it is a bad destination vertex.
As before, if t is a good destination vertex, then the path P ∈ P1 terminating at t must contain some
vertex t(cid:48) ∈ β(t).
We transform the paths in P1 in two steps, to ensure that they connect demand pairs in ˜M. In the
ﬁrst step, for every path P ∈ P1 originating at a good source s ∈ S1, we truncate P at the ﬁrst vertex
s(cid:48) ∈ β(s), so it now originates at s(cid:48). Similarly, if P terminates at a good destination vertex t ∈ T1, we
truncate P at the last vertex t(cid:48) ∈ β(t), so it now terminates at t(cid:48). Let P(cid:48)
1 be the resulting set of paths.
Notice that the paths in P(cid:48)

1 remain node-disjoint.

44

21∆0

1 were node-disjoint.

In order to complete our transformation, we need to take care of bad source and destination vertices.
Let s ∈ S1 be any bad destination vertex. If s ∈ V (Dx) \ V (Cx), then let Qs be any path connecting
s to the unique vertex s(cid:48) ∈ β(s), so that Qs ⊆ Dx. Such a path exists, since G[V (Dx)] is connected.
Otherwise, s ∈ R for some component R ∈ R with |L(R)| ≥ 3. Recall that in this case, β(s) contains
a unique vertex, that we denote by s(cid:48), which is a leg of R, and it is not one of the endpoints of σ(R).
We then let Q(s) be any path connecting s to s(cid:48) in the sub-graph of G induced by V (R) ∪ {s(cid:48)}. We
deﬁne paths Q(t) for bad destination vertices t ∈ T1 similarly. By concatenating the paths in {Q(s)}
for all bad source vertices s ∈ S1, P(cid:48)
1, and {Q(t)} for all bad destination vertices t ∈ T1, we obtain the
desired collection ˜P of at least OPT(G,N )
paths, routing demand pairs in ˜M. It now only remains to
show that the paths in ˜P are disjoint. Recall that the paths in P(cid:48)
Consider some bad source vertex s ∈ S1, and let P ∈ P(cid:48)
1 be the path originating at s. We show that
Q(s) is disjoint from all paths in P(cid:48)
1\{P}, and it is disjoint from all other paths Q(s1) for s1 ∈ S1\{s}.
Assume ﬁrst that s ∈ V (Dx) \ V (Cx). Then Γ(s) = Cx, and so no other path in P1 (and hence in
P(cid:48)
1) can contain a vertex of Dx. It follows that Q(s) is disjoint from all paths in P(cid:48)
1 \ {P}. It is also
disjoint from all other paths Q(s1) for s1 ∈ S1 \ {s}, since in order for Q(s1) to intersect Dx, vertex
s1 must lie on Cx, and this is impossible.
Assume now that s ∈ V (R) for some R ∈ R. Recall that the disc whose boundary is Γ(s) contains
R ∪ L(R). Since no other path in P(cid:48)
1 may intersect Γ(s), and no demand pair is contained in the disc
whose boundary is Γ(s), no other path in P(cid:48)
1 intersects R ∪ L(R), and so all such paths are disjoint
from Q(s). Consider now some other bad source vertex s1 ∈ S1. Note that s1 cannot lie in R, since in
this case the path of P(cid:48)
1 originating at s1 would have crossed Γ(s). Therefore, s1 must lie in some other
component R(cid:48) ∈ R. Then the only way for Q(s) and Q(s1) to intersect is when s(cid:48) = s(cid:48)
1. In particular,
R, R(cid:48) should both belong to some set Rh for 1 ≤ h ≤ 2∆0. But since the segments {σ(R) | R ∈ Rh}
are nested, due to the way we chose the mappings β(s) and β(s1), this is impossible.
We can similarly prove that for each bad destination vertex t ∈ T1, if P (cid:48) ∈ P(cid:48)
at t, then Q(t) is disjoint from all paths in P(cid:48)
a bad destination vertex. Altogether, this proves that the paths in ˜P are disjoint.
For each 0 ≤ h, h(cid:48) ≤ 2∆0, let ˜Mh,h(cid:48) ⊆ ˜M be the set of all demand pairs (˜s, ˜t) with ˜s ∈ Zh(x) and
˜t ∈ Zh(cid:48)(y).
If h = 0 or h(cid:48) = 0, then, since |V (Cx)|,|V (Cy)| ≤ ∆, OPT(G, ˜Mh,h(cid:48)) ≤ ∆. We route any demand
pair in ˜Mh,h(cid:48) to obtain a factor-∆ approximation to the problem (G, ˜Mh,h(cid:48)). If both h, h(cid:48) > 0, then
we apply Theorem 7.2 to obtain a collection Ph,h(cid:48) of at least Ω
disjoint paths, routing
demand pairs in ˜Mh,h(cid:48). We then take the best among all resulting solutions.

1 is the path terminating
1 \ {P (cid:48)}, and from all paths Q(t1), where t1 ∈ T1 \ {t} is

(cid:19)

(cid:110)

(cid:111)

∆2

(cid:18) OPT(G, ˜Mh,h(cid:48) )
(cid:17)
(cid:16) OPT(G,N )

0 log n

∆3
0

˜Mh,h(cid:48) | 0 ≤ h, h(cid:48) ≤ 2∆0

Notice that
0 ≤ h, h(cid:48) ≤ 2∆0 of indices with OPT(G, ˜Mh,h(cid:48)) ≥ OPT(G, ˜M)
routing of at least Ω

(cid:16) OPT(G,N )

demand pairs.

(cid:17)

(2∆0+1)2 ≥ Ω

∆6

0 log n

partition the set ˜M of demand pairs, and so there is a pair

. Therefore, we obtain a

7.2 Subcase 2b: d(x, y) ≤ 5∆0

We again start by deﬁning a special case of the problem, which is similar to the problem of routing
on a disc. We show an approximation algorithm for this special case that reduces it to the problem of
routing on a disc, and we later use this special case in order to handle the general problem in Case 2b.

45

A Special Case

Suppose we are given a connected planar graph ˆG embedded on the sphere, a cycle Z in ˆG, and a
set ˆM of demand pairs, such that each terminal of T ( ˆM) lies on Z. Assume additionally that we
are given a closed ˆG-normal curve C of length at most ∆, that is disjoint from Z. Let D(Z) be the
disc whose boundary is Z, which contains C. Assume further that for every vertex v ∈ Z, there is a
ˆG-normal curve γ(v) of length at most 16∆0 connecting v to a vertex of C, so that γ(v) is contained
in D(Z) and it is internally disjoint from C. This ﬁnishes the deﬁnition of the special case.

Next, we reduce this special case to routing on a disc, by creating a hole in the sphere. The hole
is D◦(Z), so we delete all edges and vertices that appear inside D(Z), except for the edges and the
vertices of Z. Let ˆG(cid:48) be the resulting graph. We can now apply the O(log n)-approximation algorithm
for NDP-Disc to the resulting problem, to obtain a routing of at least Ω
demand pairs.
In order to complete the analysis of the algorithm, we prove that OPT( ˆG(cid:48), ˆM) ≥ Ω

(cid:17)
(cid:16) OPT( ˆG, ˆM)

(cid:16) OPT( ˆG(cid:48), ˆM)

(cid:17)

log n

.

∆2

0 log n

Theorem 7.7 OPT( ˆG(cid:48), ˆM) ≥ Ω

(cid:16) OPT( ˆG, ˆM)

(cid:17)

∆2

0 log n

.

(cid:110)

(cid:111)

Proof: As before, we can assume without loss of generality that all curves in set {γ(v) | v ∈ V (Z)}
are mutually non-crossing, and for all v, v(cid:48) ∈ V (Z), γ(v)∩ γ(v(cid:48)) is a contiguous curve that has a vertex
of C as its endpoint.
Consider the optimal solution to instance ( ˆG, ˆM), and let P0 be the set of paths in this solution.
As before, we will gradually modify the set P0 of paths, to obtain path sets P1,P2, . . ., until we
obtain a feasible solution to instance ( ˆG(cid:48), ˆM). For every i ≥ 0, we will denote by ˆMi the set of the
demand pairs routed by Pi, and by κi its cardinality. Recall that κ0 = OPT( ˆG, ˆM). We assume that
κ0 ≥ 213∆2
0 log n, as otherwise a solution routing a single demand pair gives the desired approximation,
and such a solution exists in ˆG(cid:48), as it must be connected.
We delete from P0 all paths that use the vertices of C. Since C contains at most ∆ vertices, we delete
at most ∆ paths in this step. Let P1 be the resulting set of paths, and ˆM1 the set of the demand
pairs routed by P1.
Our next step is to build a conﬂict graph H, almost exactly as before. The set of vertices is V (H) =
v(s, t) | (s, t) ∈ ˆM1
. There is a directed edge from v(s, t) to v(s(cid:48), t(cid:48)), iﬀ the path P (s, t) ∈ P1
routing the pair (s, t) contains a vertex of V (γ(s(cid:48))) ∪ V (γ(t(cid:48))), and we say that there is a conﬂict
between (s, t) and (s(cid:48), t(cid:48)) in this case. Since we assume that the paths in P1 are node-disjoint, and
since |V (γ(s(cid:48)))|,|V (γ(t(cid:48)))| ≤ 16∆0 for all (s(cid:48), t(cid:48)) ∈ ˆM1, the in-degree of every vertex in H is at most
32∆0. As before, there is an independent set I ⊆ V (H) of cardinality at least
in H.
Let ˆM2 be the set of all demand pairs (s, t) with v(s, t) ∈ I, and let P2 ⊆ P1 be the set of paths
routing the demand pairs in ˆM2. Recall that the paths in P2 are disjoint from C. Moreover, if
P (s, t) ∈ P2 is the path routing the pair (s, t) ∈ ˆM2, then for every demand pair (s(cid:48), t(cid:48)) (cid:54)= (s, t) in
ˆM2, path P (s, t) is disjoint from both γ(s(cid:48)) and γ(t(cid:48)). It is now easy to verify that the demand pairs
in ˆM2 are non-crossing with respect to the cycle Z.
We now depart from the proof of Theorem 7.2. We use Lemma 2.3, in order to compute a partition
(N1, . . . ,N4(cid:100)log n(cid:101)) of the set ˆM2 of the demand pairs, so that for all 1 ≤ a ≤ 4(cid:100)log n(cid:101), set Na is
ra-split, for some ra ≥ 0. Then there must be an index 1 ≤ a ≤ 4(cid:100)log n(cid:101), such that |Na| ≥ | ˆM2|
4(cid:100)log n(cid:101) ≥
. We let ˆM3 = Na, and P3 ⊆ P2 the set of paths routing the demand pairs in ˆM3.
Ω
We then denote ra by ρ, and the partition of ˆM3 associated with the deﬁnition of the ρ-split set of

32∆0+1 ≥ |P0|
|P1|

(cid:16) |P0|

(cid:17)

∆0 log n

64∆0

46

demand pairs by M1, . . . ,Mρ. We also denote by Σ = (σ1, . . . , σ2ρ) the corresponding partition of Z
into intervals. We assume without loss of generality that for all 1 ≤ z ≤ ρ, all source vertices of the
demand pairs in Mz lie on σ2z−1, and all corresponding destination vertices lie on σ2z.
Let I1 contain all indices 1 ≤ z ≤ ρ, with |Mz| ≤ 128∆0, and let I2 contain all remaining indices. If
demand pairs, as
follows: for each z ∈ I1, we route any demand pair in Mz via the segment σ2z−1∪ σ2z of Z. Therefore,
Mz, and we
let P4 ⊆ P3 be the set of paths routing the demand pairs in ˆM4. For all z ∈ I2, we denote |Mz| by
κz
4.

(cid:80)
we assume from now on that(cid:80)

(cid:16) |P0|
(cid:17)
. We denote ˆM4 =(cid:83)

|Mz| ≥ | ˆM3|/2, then we can obtain a routing of at least

(cid:16) |P0|

|Mz| ≥ | ˆM3|

2 ≥ Ω

| ˆM3|
256∆0

≥ Ω

(cid:17)

∆0 log n

z∈I2

z∈I1

z∈I2

0 log n

∆2

(cid:110)

(cid:111)

4

64∆0

4

256∆0

64∆0r, tz

5

z∈I2 κz

256∆0

(sz

1, tz

, tz
κz
4

)

≥ Ω

∆2

0 log n

≥ κ4

256∆0

64∆0r, tz

1, . . . , sz
κz
4

(cid:106) κz

1), . . . , (sz
κz
4

r ⊆ σ2z−1 and ˜µz

64∆0r) | 1 ≤ r ≤ κz

r, is the segment of Z from sz

r | z ∈ I2, 1 ≤ r ≤ κz

64∆0r), we deﬁne two segments µz

The rest of the proof is very similar to the rest of the proof of Theorem 7.2, except that now we
deal with each subset Mz for z ∈ I2 of the demand pairs separately. Fix some z ∈ I2, and denote
. Since the demand pairs in Mz are non-crossing, and due to the
Mz =
deﬁnition of the ρ-split instance, we can assume without loss of generality that sz
, . . . , tz
1
appear in this counter-clock-wise order on Z. Let κz
We then let ˆMz contain all demand pairs (sz
64∆0r, tz
κz
z∈I2
4

.
ˆMz.
. We now show that all
demand pairs in ˆM5 can be routed in graph ˆG(cid:48). This is done similarly to the proof of Theorem 7.2.

(cid:107) − 1. Since κz
5, and we let ˆM5 =(cid:83)
(cid:17)
(cid:16) κ0
5 =
64∆0r), for 1 ≤ r ≤ κz
(cid:9) of demand pairs. For each

Notice that κ5 = | ˆM5| = (cid:80)
Fix some z ∈ I2, and consider the set ˆMz =(cid:8)(sz

, tz
κz
4
4 ≥ 128∆0, κz
5 ≥ κz
z∈I2

5 ≥ (cid:80)

64∆0r) ∈ ˆMz, if P ∈ P5 is the path

64∆0r) ∈ ˆMz be some demand pair, with 1 ≤ r ≤ κz

r ⊆ σ2z of Z, as follows.
(cid:96)−32∆0 to
r, is the segment
(cid:96)+32∆0−1, as we traverse Z(cid:48) in the clock-wise order. It is immediate to verify that
5} are mutually disjoint. We use the following analogue
r, ˜µz

such demand pair (sz
For brevity of notation, denote 64∆0r by (cid:96). The ﬁrst segment, µz
sz
(cid:96)+32∆0−1, as we traverse Z in the counter-clock-wise order. The second segment, ˜µz
(cid:96)−32∆0 to tz
of Z from tz
all segments of Z in {µz
of Lemma 7.3.
Lemma 7.8 For every z ∈ I2, for every demand pair (sz
routing this pair, then P ∩ Z ⊆ µz
We can now use this lemma to re-route the paths in P5, similarly to the proof of Theorem 7.1. Fix
some z ∈ I2, and let (sz
5. For simplicity, we
denote (cid:96) = 64∆0r. Let P(cid:96) be the path routing this demand pair in P5, that we view as directed from
s(cid:96) towards t(cid:96). Clearly, P(cid:96) intersects both µz
r. Then
r. We let v(cid:48)
there is some other vertex appearing on P(cid:96) after v(cid:96) that belongs to ˜µz
(cid:96) be the ﬁrst such
vertex on P(cid:96), and we let P (cid:48)
(cid:96) be the path obtained as
(cid:96) to v(cid:48)
follows: we start with a segment of µz
(cid:96), and ﬁnally we use
r between v(cid:48)
a segment of ˜µz
(cid:96) . From Lemma 7.8, it is immediate to verify that we obtain a set of
node-disjoint paths routing all demand pairs in ˆM5 in graph ˆG(cid:48). It now remains to prove Lemma 7.8.
Proof: Fix some z ∈ I2, and consider some demand pair (sz
64∆0r) ∈ ˆMz. Let P ∈ P5 be
the path routing this pair. We partition the cycle Z into two segments: σ containing σ2z−1 and σ(cid:48)
containing σ2z arbitrarily, so σ now contains all source vertices, and σ(cid:48) now contains all destination
vertices of the pairs in Mz. It is enough to show that P ∩ σ ⊆ µz
r. We prove that
P ∩ σ ⊆ µz
Assume for contradiction that P ∩ σ (cid:54)⊆ µz
where we view P as directed from sz
(cid:96) to tz

r, and let v be the ﬁrst vertex on P that belongs to σ \ µz
r,
(cid:96) . Let P (cid:48) be the sub-path of P from its ﬁrst vertex to v.

(cid:96). Let P ∗
(cid:96) and v(cid:96); we then follow P (cid:48)

(cid:96) be the segment of P(cid:96) between v(cid:96) and v(cid:48)

r. Let v(cid:96) be the last vertex of P(cid:96) lying on µz

r. The proof that P ∩ σ(cid:48) ⊆ ˜µz

r and P ∩ σ(cid:48) ⊆ ˜µz

r is symmetric.

r between sz

r ∪ ˜µz
r.

64∆0r, tz

64∆0r, tz

r and ˜µz

(cid:96) and tz

64∆0r, tz

47

Consider the planar embedding of ˆG, where we ﬁx any face lying outside of D(Z) as the outer face.
(cid:96) ), P (cid:48), and γ(v), and let R be the outer
In this planar embedding, denote by Y the union of D(C), γ(sz
boundary of Y (see Figure 7).

(cid:96)+1, . . . , sz

(cid:96)+32∆0−1

i ) | sz

(cid:9), and

(cid:96) , tz

, and so, since both sz

(cid:110)
S2 = (cid:8)sz

(cid:96) , lie on one side of R. Let S1 =(cid:8)sz

(cid:96)}(cid:111)
(cid:9). Denote Γ1 = {γ(sz

Figure 7: Constructing the curve R. The segments σ and σ(cid:48) of Z are shown in blue and green,
respectively. We omit the superscript z for brevity of notation.
Notice that, since there are no conﬂicts in P4, curve R does not cross any curve in the set C ∪
γ(t) | t ∈ T ( ˆM4) \ {sz
(cid:96) and v lie on σ, all destination vertices of the
demand pairs in Mz, except for possibly tz
i ∈ S2}. Since the
i ∈ S1} and Γ2 = {γ(sz
curves in set {γ(u) | u ∈ V (Z)} are non-crossing, if β, β(cid:48) are the two segments of Z whose endpoints
are s(cid:96) and v, then all vertices of S1\{v} lie on one of the segments (say β), while all vertices of S2\{v}
lie on the other segment. Moreover, since path P (cid:48) cannot cross any curve in Γ1 ∪ Γ2, the vertices of
S1 \ {v} lie on one side of R, and the vertices of S2 \ {v} lie on the other side of R. Therefore, either
all vertices of S1 \ {v} are separated by R from all destination vertices of the demand pairs in Mz
(cid:96) ), or the same holds for S2 \ {v} - we assume without loss of generality that it
(except for possibly tz
is the former.
All sources of S1\{v} are then separated by R from their destinations vertices, and yet all corresponding
demand pairs are routed by P2. Therefore, at least 32∆0 − 2 paths in P2 must cross the curve R.
Recall that none of these paths can cross C, P (cid:48), or γ(sz
(cid:96) ). Therefore, all these paths must cross γ(v).
But since the length of γ(v) is at most 16∆0, and the paths are node-disjoint, this is impossible.

(cid:96)−32∆0, . . . , sz
i ) | sz

(cid:96)−1

The rest of the proof follows the same strategy as the proof for Case 2a, but it is somewhat more
involved. We break it into three steps. In the ﬁrst step, we construct a single shell around the vertex
x. In the second step, we map the terminals to the cycles of the shell. In the ﬁnal step, we reduce the
problem to the special case, by constructing a cycle Z and mapping a subset of the terminals to the
vertices of Z.
We assume that OPT(G,N ) > 213∆4
a valid solution.

0, since otherwise we can route a single demand pair and obtain

Step 1: the Shell
In this step we construct a shell Z(x) = (Z1(x), . . . , Zh(x)) of depth h ≤ 8∆0 around x. We ﬁrst give
a high-level explanation of why the construction of the shell in this case is more challenging than that
in Case 2a, and motivate our construction. Recall that given such a shell Z(x), we have deﬁned, for all
1 ≤ h(cid:48) ≤ h, a set Uh(cid:48) of vertices contained in D◦(Zh(cid:48)(x))\ D(Zh(cid:48)−1(x)), and a set Rh(cid:48) of all connected

48

vP￿s￿γ(s￿)γ(v)C˜µrt￿µrσσ￿components of G[Uh(cid:48)]. For all 1 ≤ h(cid:48) ≤ h, for every component R ∈ Rh(cid:48), we have deﬁned the disc
η(R) (given by Theorem 5.5), whose boundary γ(R) served as the curve Γ(t) for all terminals t lying
in R. In Case 2a, discs η(R) had the important property that no demand pair in N is contained in
η(R). This ensured that whenever a path routing any demand pair in N intersects R, such a path
must also cross γ(R). This latter property was crucial in ensuring that, after we map all terminals to
the vertices of the shell, the solution value does not change by much. Unfortunately, in Case 2b this
is no longer true, and it is possible that discs η(R), and even the components R themselves, contain
many demand pairs from N . We get around this problem as follows. We construct the shell around x
carefully, to ensure that the total number of the terminals contained in each such disc η(R) is relatively
small. We say that a pair of terminals is bad if there is a path connecting these terminals, which is
completely contained in some disc η(R), and it is good otherwise. As long as bad terminal pairs exist
in our graph, we iteratively route one such pair inside the corresponding disc η(R), and discard all
other terminals lying in this disc. Since the total number of the terminals contained in each disc is
relatively small, the number of the terminals we discard at this step is relatively small compared to
the number of the demand pairs we route. If we manage to route a large enough number of demand
pairs in this step, then we terminate the algorithm and return this solution. Otherwise, we let N (cid:48) be
the subset of the demand pairs that have not been routed or discarded yet. Then |N (cid:48)| is suﬃciently
large relatively to |N|, and we have now achieved the property that for all components R, any path
connecting a demand pair in N (cid:48) that intersects R must also cross γ(R). We now proceed to describe
the shell construction. Let τ∗ = 64∆0/αWL, and let T be the set of all terminals participating in the
demand pairs in N .
For all integers i > 0, let Si be the set of all vertices v (cid:54)∈ Dx, with dGNC(v, V (Cx)) ≥ i. We say that
a connected component R of G[Si] is heavy iﬀ R contains more than τ∗ terminals of T . Let i∗ be the
largest integer, such that G[Si∗] contains at least one heavy connected component, and let R∗ be any
such component. We need the following easy observation.
Observation 7.9 i∗ ≤ 8∆0 − ∆ − 4.
Proof: Assume otherwise and let h = 8∆0 − ∆ − 4. Then there is some connected component
R of G[Sh], containing more than τ∗ terminals of T . Let t ∈ V (R) ∩ T be any such terminal.
If
t ∈ X, then d(t, x) ≤ ∆0. If t ∈ Y , then d(t, y) ≤ ∆0, and d(x, y) ≤ 5∆0, so from Observation 5.4,
d(t, x) ≤ 6∆0 + ∆/2 + 1. Therefore, some vertex v ∈ Ct has a G-normal curve of length at most
6∆0 + ∆/2 + 1 connecting it to a vertex of Cx, and so every vertex in Ct has a G-normal curve of
length at most 6∆0 + ∆/2 + 1 + ∆/2 + 1 < 8∆0 − ∆ − 4 connecting it to a vertex of Cx. Therefore,
V (Ct) ⊆ V (G) \ Sh, while t ∈ Sh. Since V (Ct) separates V (Dt) from all remaining vertices of G,
and R is a connected component of G[Sh], it follows that R ⊆ V (Dt). But Dt contains fewer than τ∗
terminals from the deﬁnition of enclosures, a contradiction.
Let κ = |T ∩ R∗|, so κ > τ∗. The following observation will be useful in order to bound the number
of terminals contained in each disc η(R). The proof follows immediately from the well-linkedness of
the terminals.

Observation 7.10 Let D be any disc, whose boundary γ is a G-normal curve of length less than
16∆0. Assume further that at least κ/4 terminals lie outside of D. Then D contains at most τ∗
terminals of T .
We now provide some further intuition. Let h(cid:48) = i∗−1, and consider a shell Z(x) = (Z1(x), . . . , Zh(cid:48)(x))
of depth h(cid:48) around x, where we let Fx be any face incident on a vertex of R∗. We can then deﬁne, for
each 1 ≤ h(cid:48)(cid:48) ≤ h(cid:48), the set Rh(cid:48)(cid:48) of connected components of the graph induced by all vertices lying in
h(cid:48)(cid:48)=1 Rh(cid:48)(cid:48), and use Theorem 5.5 in order to compute the discs

D◦(Zh(cid:48)(cid:48)(x)) \ D(Zh(cid:48)(cid:48)−1(x)), set R =(cid:83)h(cid:48)

49

η(R) for the components R ∈ R. Moreover, since all vertices of R∗ lie outside each such disc η(R),
from Observation 7.10, each such disc contains at most τ∗ terminals. The problem is that R∗ may still
contain many terminals, while we need to ensure that most of the terminals lie in the components of
R. We get around this problem by extending the shell, and adding two outer cycles to it. First, we
consider the outer boundary Γ of the graph R∗ (in the drawing where the face containing x is viewed
as the outer face), and carefully select some cycle C ∈ Γ, so that, if we add C as the outer-most cycle
to the shell Z(x), by setting Zh(cid:48)+1(x) = C, then for every component R ∈ Rh(cid:48)+1, we still maintain
the property that the corresponding disc η(R) contains at most τ∗ terminals. Finally, we take care of
the terminals contained in the disc D(C), that currently do not lie in any component of R. The idea
is to carefully select one vertex ˜u ∈ V (C), and to attach a new cycle C(cid:48) to ˜u, that lies “inside” cycle
C, and is then added to the shell as the outermost cycle, so Zh(cid:48)+2(x) = C(cid:48). We then view the face
whose boundary is C(cid:48) as the face Fx in the shell construction. Therefore, once ˜u is selected and cycle
C(cid:48) is added to the drawing of G, both the construction of the shell, and the construction of the discs
η(R) for R ∈ R are ﬁxed. We would like to select ˜u in such a way that each resulting disc η(R) for
R ∈ Rh(cid:48)+2 contains at most τ∗ terminals. We achieve this by discarding a small number of terminals
and their corresponding demand pairs. We now describe the construction more formally.
Consider the graph R∗, and its drawing in the plane, induced by the drawing of G on the sphere,
where we view the face where x used to be as the outer face. Let Γ be the boundary of the outer face
in this drawing of R∗, and let C be the set of all simple cycles in Γ. Let H be the block-decomposition
of Γ. That is, the set V (H) of vertices consists of two subsets: set V1 of cut vertices of Γ, and set V2,
containing a vertex vB for every block B (a maximal 2-connected component) of Γ. We add an edge
(u, vB) between vertices u ∈ V1 and vB ∈ V2 iﬀ u ∈ V (B). It is easy to see that graph H is a tree,
and we root it at any vertex. We next deﬁne weights for the vertices of H. In order to do so, every
terminal in T ∩ R∗ will contribute a weight of 1 to one of the vertices of V2, and the weight of every
vertex in V2 is then the total weight contributed to it. The weights of all vertices in V1 are 0. Consider
some terminal t ∈ T ∩ R∗. If there is some simple cycle C ⊆ Γ, such that t ∈ D(C), then t contributes
the weight of 1 to the vertex vB, where B = C (if t belongs to several such cycles, then we select one
of these cycles arbitrarily). Otherwise, t ∈ V (Γ), and there is some vertex vB ∈ V2, such that block
B consists of a single edge e, and t is one of its endpoints. Among all such vertices vB, we choose one
arbitrarily, and contribute the weight of t to vB.
For every subgraph H(cid:48) ⊆ H, the weight of H(cid:48) is the total weight of all vertices in H(cid:48). Clearly, the
weight of H is κ. We need the following simple claim.
Claim 7.11 There is some vertex u∗ ∈ V (H), such that, if we root H at u∗, then for every child u(cid:48)
of u∗, the weight of the sub-tree of H rooted at u(cid:48) is at most κ/2.

Proof: We root H at any vertex v, and set u = v. We then iterate. If the current vertex u has a
child u(cid:48), such that the total weight of all vertices contained in the sub-tree of H rooted at u(cid:48) is more
than κ/2, then we move u to u(cid:48). It is easy to see that when this procedure terminates, we will ﬁnd
the desired vertex u∗.
Consider the vertex u∗ computed by the above claim. If u∗ ∈ V1, then let v∗ = u∗. Otherwise, u∗ = vB
for some vertex vB ∈ V2, then let v∗ be any vertex of B. We assume without loss of generality that v∗
lies on some simple cycle C ⊆ Γ: otherwise, we create an artiﬁcial cycle C = (v∗, u1, u2), where u1 and
u2 are two new vertices. If v∗ lies on several such cycles, then we let C be any one of them. Notice
that every connected component of R∗ \ V (D(C)) contains at most κ/2 terminals, and has exactly one
neighbor in V (C).
Let ˜u be some vertex in V (C) (that we will select later). We then add a new cycle C(cid:48) = (v1, v2, v3),
containing all new vertices, and an edge e = (˜u, v1), and draw C(cid:48) inside C (we later specify the precise

50

components R ∈(cid:83)h+1

location of this drawing). Let G(cid:48) = G ∪ C(cid:48) ∪ {e}. We let Fx be the face in the drawing of G(cid:48) on the
sphere, whose boundary is C(cid:48). Letting h = i∗, we construct a shell Z(x) = (Z1(x), . . . , Zh(x)) of depth
h = i∗ ≤ 8∆0 − ∆ − 4 around x, with respect to Fx. As before, we use Z0(x) to denote Cx. Notice
that from our construction, Zh(x) = C. We note that the choice of the vertex ˜u ∈ V (C) to which the
cycle C(cid:48) is attached does not aﬀect the construction of the shell: for any such choice, the shell will be
the same. Notice also that the addition of the new cycles does not aﬀect the routings. So abusing the
notation we denote G(cid:48) by G.
For every 1 ≤ h(cid:48) ≤ h, we let Uh(cid:48) be the set of all vertices in D◦(Zh(cid:48)(x)) \ D(Zh(cid:48)−1(x)), and let Rh(cid:48)
be the set of all connected components of G[Uh(cid:48)]. We let Uh+1 be the set of all vertices lying outside
D(Zh(x)) in the planar embedding of G where Fx is the outer face (equivalently, Uh+1 is the set of
all vertices lying in disc D◦(C) in the planar embedding of G where the face containing x is viewed
as the outer face), and denote by Rh+1 the set of all connected components of G[Uh+1]. We will view
the components in Rh+1 as type-2 components with respect to the shell. For each such component
R ∈ Rh+1, we let L(R) ⊆ V (C) be the set of the neighbors of the vertices of R, and we leave u(R)
undeﬁned. We need the following simple observation.
Observation 7.12 For each R ∈ Rh+1, |V (R) ∩ T | ≤ τ∗.
Proof: Assume otherwise, and let R ∈ Rh+1 be any component with |R ∩ T | > τ∗. We claim that all
vertices of R lie in Si∗+1. Indeed, recall that all vertices of R∗ lie in Si∗, and C ⊆ R∗ is a cycle separating
R from all vertices of V (G) \ Si∗. Therefore, for every vertex v ∈ V (R), dGNC(v, V (Cx)) ≥ i∗ + 1 and
v ∈ Si∗+1. But then R is a heavy connected component in G[Si∗+1], contradicting the choice of i∗.
Notice that once ˜u and the face Fx are ﬁxed, we can deﬁne, for every component R ∈ Rh+1, the
segment σ(R) of the cycle C = Zh(x) exactly as before, and we can deﬁne the discs η(R) for all
h(cid:48)=1 Rh(cid:48) using Theorem 5.5. (It may be convenient to think of C(cid:48) as the outer-most
cycle of the shell; that is, we add C(cid:48) to the shell as Zh+1(x)). The main theorem summarizing the
current step is the following.
Theorem 7.13 There is an eﬃcient algorithm to compute a vertex ˜u ∈ V (C), a drawing of the
cycle C(cid:48), and a subset T (cid:48) ⊆ T of at most 4τ∗ terminals, such that, in the resulting shell Z(x) =
h(cid:48)=1 Rh(cid:48), the resulting disc η(R) contains at most τ∗
terminals of T \ T (cid:48).
We emphasize that the shell Z = (Z1(x), . . . , Zh(x)) and the sets Rh(cid:48) of components, for 1 ≤ h(cid:48) ≤ h+1
do not depend on our choice of the vertex ˜u or the drawing of C(cid:48). Similarly, the discs η(R) for
components R lying in sets Rh(cid:48), for 1 ≤ h(cid:48) ≤ h, given by Theorem 5.5, are also independent of the
choice of ˜u or the drawing of C(cid:48) inside C. The choice of ˜u only inﬂuences the discs η(R) for R ∈ Rh+1,
and so our goal is to select ˜u and T (cid:48), and to draw C(cid:48) inside C in a way that ensures that each such
disc η(R) contains few terminals of T \ T (cid:48).
Proof: Our ﬁrst step processes the components of Rh+1 and to select the vertex ˜u ∈ V (C). For this
step, we will think of G as being embedded on the sphere. Let κ(cid:48) be the number of the terminals of T
V (R)
to T (cid:48), and terminate the algorithm, setting ˜u to be any vertex of C, and drawing C(cid:48) anywhere inside
C, so the resulting drawing of G is planar. (We show below that this choice satisﬁes the conditions of
the theorem). Therefore, we assume from now on that κ(cid:48) ≥ 4τ∗, and in particular |Rh+1| ≥ 1.
Throughout the algorithm, we maintain a partition of Rh+1 into two subsets: R(cid:48), containing all
components we have processed, and R(cid:48)(cid:48), containing all remaining components. At the beginning,
R(cid:48) = ∅ and R(cid:48)(cid:48) = Rh+1.

contained in the components of Rh+1. If κ(cid:48) ≤ 4τ∗, then we add all terminals of T ∩(cid:16)(cid:83)

(Z1(x), . . . , Zh(x)), for each component R ∈ (cid:83)h+1

(cid:17)

R∈Rh+1

51

Consider any component R ∈ R(cid:48)(cid:48). Recall that all neighbors of the vertices of R must lie on C from
our construction, and we denoted the set of these vertices by L(R).

We say that R is a good component, iﬀ there is a segment µ(R) of C containing all vertices of L(R),
whose endpoints, denoted by a1(R) and a2(R) belong to L(R), and there is a G-normal curve γ(cid:48)(R),
whose endpoints are a1(R) and a2(R), such that γ(cid:48)(R) is internally disjoint from V (G), and the
following holds: let η(cid:48)(R) be the disc, whose boundary is µ(R) ∪ γ(cid:48)(R), with R ⊆ η(cid:48)(R). Then for all
R(cid:48) ∈ R(cid:48)(cid:48) with R(cid:48) (cid:54)= R, R(cid:48) is disjoint from η(cid:48)(R) (intuitively, these are the components that lie closest
to C; see Figure 8).

Figure 8: Good components are shown in red, and their corresponding curves γ(cid:48)(R) in green

Claim 7.14 If |R(cid:48)(cid:48)| ≥ 2, then there are at least two good components in R(cid:48)(cid:48).

Proof: Let µ be the shortest segment of C, such that for some R ∈ R(cid:48)(cid:48), L(R) ⊆ µ. Let ˜R ⊆ R(cid:48)(cid:48) be
the set of all components R with L(R) ⊆ µ. If, for any component R ∈ ˜R, |L(R)| ≥ 3, then from the
deﬁnition of µ it is easy to see that R is a good component. If any component R ∈ ˜R has |L(R)| = 1,
then µ contains a single vertex - the unique vertex of L(R), and it is easy to see that R is a good
component. Otherwise, every component in ˜R has |L(R)| = 2. We then let R be the component that
lies closest to µ. In other words, we choose the unique component R ∈ ˜R, such that for some vertex
v ∈ V (R), there is a curve γ connecting v to an inner point of µ, so that γ does not contain any
vertices of G except for v, and it does not intersect the edges of G. It is immediate to verify that R is
a good component. We conclude that there is at least one good component R ∈ R(cid:48)(cid:48), with L(R) ⊆ µ.
Let a, a(cid:48) be the endpoints of µ, and let µ(cid:48) be the other segment of C whose endpoints are a and a(cid:48).
Since |R(cid:48)(cid:48)| ≥ 2, there is at least one component R(cid:48) (cid:54)= R in R(cid:48)(cid:48), with L(R(cid:48)) ⊆ µ(cid:48). As before, we let µ(cid:48)(cid:48)
be the shortest (inclusion-wise) segment of µ(cid:48), such that for some component R(cid:48)(cid:48) ∈ R(cid:48)(cid:48), L(R(cid:48)(cid:48)) ⊆ µ(cid:48)(cid:48).
Let ˜R(cid:48) be the set of all components R(cid:48)(cid:48) (cid:54)= R in R(cid:48)(cid:48) with L(R(cid:48)(cid:48)) ⊆ µ(cid:48)(cid:48). Using the same arguments as
above, we can ﬁnd a second good component in R(cid:48)(cid:48).
We are now ready to describe our algorithm. We start with R(cid:48)(cid:48) = Rh+1 and R(cid:48) = ∅. Recall that
|R(cid:48)(cid:48)| ≥ 1 must hold. While |R(cid:48)(cid:48)| ≥ 2, let R, R(cid:48) ∈ R(cid:48)(cid:48) be two distinct good components in R(cid:48)(cid:48).
Notice that T ∩ η(cid:48)(R) and T ∩ η(cid:48)(R(cid:48)) are completely disjoint. Therefore, either |T ∩ η(cid:48)(R)| ≤ κ(cid:48)/2, or
|T ∩ η(cid:48)(R(cid:48))| ≤ κ(cid:48)/2. We assume without loss of generality it is the former. We then move R from R(cid:48)(cid:48)
to R(cid:48), and continue to the next iteration.
Notice that in every iteration of the algorithm, |R(cid:48)(cid:48)| decreases by 1. The algorithm terminates when
|R(cid:48)(cid:48)| = 1. Let R be the remaining component in R(cid:48)(cid:48). We set T (cid:48) = T ∩ V (R), and we set ˜u to be any
vertex of L(R). Recall that from Observation 7.12, |T (cid:48)| ≤ τ∗. We then add the cycle C(cid:48) that attaches
to ˜u with an edge e to G, and we draw C(cid:48) inside C, so it is drawn next to the edge e. We then obtain
a drawing of the resulting graph in the plane where the outer face Fx is the face whose boundary is

52

C(cid:48). We construct the shells, and discs η(R) for R ∈(cid:83)h+1

h(cid:48)=1 Rh(cid:48) as described above. From the choice
of ˜u, the drawing of C(cid:48), and the construction of the discs η(R), for every R ∈ R(cid:48), η(cid:48)(R) ⊆ η(R), and
η(R) ∩ (D(C(cid:48)) \ D(C)) = η(cid:48)(R). Therefore, for each R ∈ R(cid:48), at least κ(cid:48)/2 terminals of T (cid:48) lie outside
η(R). The following claim will ﬁnish the proof of the theorem.
Claim 7.15 For all 1 ≤ h(cid:48) ≤ h + 1, for all R ∈ Rh(cid:48), η(R) contains at most τ∗ terminals of T \ T (cid:48).
Proof: Fix some 1 ≤ h(cid:48) ≤ h + 1 and R ∈ Rh(cid:48). From our construction, the length of the boundary of
η(R) is bounded by 2h + 3 + ∆/2 ≤ 2(8∆0 − ∆) + ∆/2 < 16∆0.
Assume ﬁrst that h(cid:48) < h. Then all vertices of T ∩R∗ lie outside D(Zh(cid:48)(x)), and since η(R) ⊆ D(Zh(cid:48)(x)),
they also lie outside η(R). From Observation 7.10, η(R) contains at most τ∗ terminals of T .
Assume now that h(cid:48) = h. Notice that for every component R(cid:48) ∈ Rh, either R(cid:48) is disjoint from R∗,
or R(cid:48) ⊆ R∗. In the latter case, R(cid:48) is a type-1 or a type-3 component (see Figure 1(a)), as all type-2
components are disconnected from R∗ in G[Si∗]. Recall that R(cid:48) ∈ Rh is contained in η(R) only if
σ(R(cid:48)) ⊆ σ(R), and this can only happen if R(cid:48) is a type-2 component. Let ˜R ⊆ Rh be the set of all
components contained in η(R). Then at most one of these components R(cid:48) ∈ ˜R may be contained in
R∗ - and if such a component exists, then R(cid:48) = R. Our construction of the cycle C and the choice of
Fx guarantee that R(cid:48) contains at most κ/2 + 1 terminals of T ∩ V (R∗), and so at least κ/2 − 1 ≥ κ/4
terminals lie outside η(R). Since the length of γ(R) is less than 16∆0, from Observation 7.10, η(R)
contains at most τ∗ terminals of T .
Finally, assume that h(cid:48) = h + 1. If κ(cid:48) ≤ 4τ∗, then V (R) ∩ (T \ T (cid:48)) = ∅. Therefore, we assume that
κ(cid:48) > 4τ∗. If R ∩ (T \ T (cid:48)) (cid:54)= ∅, then R was added to R(cid:48) at some iteration of the algorithm. From
the above discussion, at least κ(cid:48)/2 ≥ 2τ∗ terminals of T lie outside of η(R), while the length of the
boundary of η(R) is less than 16∆0. From the well-linkedness of the terminals, η(R) contains at most
τ∗ terminals of T .
We partition N into two subsets: set M0 contains all demand pairs in which the terminals of T (cid:48)
participate, together with all demand pairs for which either terminal lies in Dx. Then |M0| ≤ 4τ∗ +
4∆/αWL ≤ 5τ∗ (we have used the deﬁnition of enclosures to bound the number of the demand pairs
of the latter kind, and the fact that τ∗ = 64∆0/αWL). Let M1 contain the remaining demand pairs,
h(cid:48)=1 Rh(cid:48). As we noted before, we would like to ensure that for every component R ∈ R
that contains a terminal of T (M1), whenever a path P routing a demand pair in M1 intersects R, it
must cross γ(R) - the boundary of η(R). We achieve this property by routing a subset of the demand
pairs, and discarding some additional demand pairs, in the following theorem.
Theorem 7.16 There is an eﬃcient algorithm to compute a partition (N0,N1,N2) of M1, and a
collection P∗ of node-disjoint paths routing at least |N1|/(h + 1) demand pairs in N1 in graph G, such
that:

and let R =(cid:83)h+1

• |N0| ≤ τ∗|N1|; and
• for every component R ∈ R with R∩T (N2) (cid:54)= ∅, for every path P routing a demand pair in N2,

P (cid:54)⊆ η◦(R).

Proof: We start with N0 = N1 = ∅, P = ∅, and N2 = M1. Throughout the algorithm, we say
that a component R ∈ R is a live component iﬀ R ∩ T (N2) (cid:54)= ∅. While there is any demand pair
(s, t) ∈ N2, and any live component R ∈ R, such that some path P connecting s to t is contained
in η◦(R), we do the following. We add P to P, and we move (s, t) from N2 to N1. We say that the

53

component R is responsible for P , and we say that P is a level-h(cid:48) path if R ∈ Rh(cid:48). Next, for every
live component R(cid:48) ∈ Rh(cid:48), such that P intersects η◦(R(cid:48)), we move all demand pairs (s(cid:48), t(cid:48)) ∈ N2 with
{s(cid:48), t(cid:48)}∩ η◦(R(cid:48)) (cid:54)= ∅ from N2 to N0. The crux of the analysis of this algorithm is in the following claim.
Claim 7.17 In every iteration of the algorithm, the number of the demand pairs moved to N0 is at
most τ∗.

Proof: Consider some iteration of the algorithm, where a path P that belongs to level h(cid:48) was added
to P, and let R ∈ Rh(cid:48) be the component responsible for it. Recall that P ⊆ η◦(R), and recall that
Theorem 5.5 guarantees that all discs η(R(cid:48)) for R(cid:48) ∈ Rh(cid:48) are laminar: that is, for R(cid:48), R(cid:48)(cid:48) ∈ Rh(cid:48),
either η(R(cid:48)) ⊆ η(R(cid:48)(cid:48)), or η(R(cid:48)(cid:48)) ⊆ η(R(cid:48)), or η◦(R(cid:48)) ∩ η◦(R(cid:48)(cid:48)) = ∅. Let R(cid:48) ⊆ Rh(cid:48) be the set of all live
components R(cid:48) with P ∩ η◦(R(cid:48)) (cid:54)= ∅. Since P ⊆ η◦(R), there is some component R(cid:48) ∈ R(cid:48), such that
P ⊆ η◦(R(cid:48)), and for every component R(cid:48)(cid:48) ∈ R(cid:48), η◦(R(cid:48)(cid:48)) ⊆ η◦(R(cid:48)). Therefore, all demand pairs moved
in this step from N2 to N0 have at least one terminal lying in η◦(R(cid:48)), and from Theorem 7.13, their
number is bounded by τ∗.
Therefore, once the algorithm terminates, |N0| ≤ τ∗|N1| must hold. Moreover, for every component
R ∈ R with R ∩T (N2) (cid:54)= ∅, for every path P routing a demand pair in N2, P (cid:54)⊆ η◦(R). Consider now
the set P of paths. Each of these paths belongs to one of h + 1 levels, and so there is a subset P∗ ⊆ P
of paths that belong to the same level, say h(cid:48), such that |P∗| ≥ |P|/(h + 1). The paths in P∗ route a
subset of the demand pairs in N1, and it is now enough to show that they are node-disjoint. Assume
for contradiction otherwise, and let P, P (cid:48) ∈ P∗ be two distinct paths that are not disjoint. Assume
that P was added to P before P (cid:48). Let R(cid:48) ∈ Rh(cid:48) be the component responsible for P (cid:48), so P (cid:48) ⊆ η◦(R(cid:48)),
and R(cid:48) was live when R was processed. Then path P must intersect η◦(R(cid:48)), and so all demand pairs
that have a terminal in η◦(R(cid:48)), including the demand pair routed by P (cid:48), should have been removed
from N2 during the iteration when P was added to P, a contradiction.
Recall that τ∗ = 64∆0/αWL. We now consider two cases. First, if |P∗| ≥ |N| · αWL
, then we return
N (cid:48) = N and P∗ as the set of paths routing a subset of the demand pairs in N (cid:48). Therefore, we assume
from now on that |P∗| < |N| · αWL

. Let N (cid:48)(cid:48) = M0 ∪ N0 ∪ N1, and let N (cid:48) = N \ N (cid:48)(cid:48) = N2. Then:

213∆2
0

213∆2
0

+ 1)|N1|
+ 1)(h + 1)|P∗|

∗
∗
∗ · |P∗|
· |N|αWL

0

213∆2
0

∗
∗

+ (τ

|N (cid:48)(cid:48)| ≤ 5τ
≤ 5τ
+ (τ
≤ 16∆0τ
≤ 1024∆2
αWL
≤ |N|

.

6

(cid:16) OPT(G,N (cid:48))

(cid:17)

Therefore, |N (cid:48)| ≥ 5|N|/6. From now on, our goal is to ﬁnd a set P of paths, routing Ω
demand pairs in N (cid:48). From the above discussion, the demand pairs in N (cid:48) have the following property.

0 log3 n

∆8

P1. For every component R ∈ R with R ∩ T (N (cid:48)) (cid:54)= ∅, if P is any path routing any demand pair in

N (cid:48), then P (cid:54)⊆ η◦(R).

except that now we crucially exploit Property (P1). Let T (cid:48) = T (N (cid:48)), and let U =(cid:83)h

Step 2: Mapping the Terminals. This step is almost identical to the similar step in Case 2a,
h(cid:48)=1 V (Zh(cid:48)(x)) be

54

the set of all vertices lying on the cycles of the shell. Our next step is to deﬁne a mapping β : T (cid:48) → 2U
of the terminals t ∈ T (cid:48) to subsets β(t) of at most three vertices of U . For every terminal t ∈ T (cid:48), we
also deﬁne a corresponding G-normal curve Γ(t), as before.
The mapping β and the curves Γ(t) are deﬁned as follows. First, for every terminal t ∈ T (cid:48) ∩ U , we set
β(t) = {t}, and we let Γ(t) contain the vertex t only. For all remaining terminals t ∈ T (cid:48), t must lie
in some component R ∈ R. If |L(R)| ≤ 2, then we let β(t) = L(R) ∪ {u(R)} if u(R) is deﬁned, and
β(t) = L(R) otherwise. If |L(R)| > 2, then we let β(t) = {v}, where v is a leg of R, which is not an
endpoint of σ(R) (in other words, v is not the ﬁrst and not the last leg of R). We then let Γ(t) be the
boundary γ(R) of the disc η(R) given by Theorem 7.13. Recall that the length of Γ(t) is bounded by
2h + ∆/2 + 3 < 16∆0, as h ≤ 8∆0 − ∆ − 4.

(s,t)∈N (cid:48) β(s) × β(t). In the following two theorems, we relate the values of the solutions to

problems (G,N (cid:48)) and (G, ˜M).
Theorem 7.18 There is an eﬃcient algorithm, that, given any solution to instance (G, ˜M), that
routes κ demand pairs, ﬁnds a solution to instance (G,N (cid:48)), routing at least Ω

demand pairs.

(cid:16) κ

Let ˜M =(cid:83)

(cid:17)

∆0

Proof: Let P0 be any collection of disjoint paths in graph G, routing a subset ˜M0 of κ demand pairs
in ˜M. We assume that κ ≥ 64∆0, as otherwise we can return a routing of a single demand pair in
N (cid:48). For every demand pair (˜s, ˜t) ∈ ˜M0, let (s, t) be any corresponding demand pair in N (cid:48), that is,
˜s ∈ β(s) and ˜t ∈ β(t).

(cid:110)

(cid:111)

κ

in H.

64∆0

v(˜s, ˜t) | (˜s, ˜t) ∈ ˜M0

(cid:110)

(cid:111)

We build a conﬂict graph H, whose vertex set is
, and there is a directed edge
from v(˜s1, ˜t1) to v(˜s2, ˜t2) iﬀ the unique path P (˜s1, ˜t1) ∈ P0 routing the pair (˜s1, ˜t1) intersects Γ(s2)
or Γ(t2) (in which case we say that there is a conﬂict between (˜s1, ˜t1) and (˜s2, ˜t2)). Since all paths in
P0 are node-disjoint, and all curves Γ(s), Γ(t) have lengths at most 16∆0 each, the in-degree of every
vertex in H is at most 32∆0. Therefore, we can eﬃciently compute an independent set I of size at
least

Let ˜M1 =(cid:8)(˜s, ˜t) | v(˜s, ˜t) ∈ I(cid:9), and let P1 ⊆ P0 be the set of paths routing the demand pairs in ˜M1.

32∆0+1 ≥ κ

(s, t) | (˜s, ˜t) ∈ ˜M1

Let M(cid:48) =
. It is now enough to show that all demand pairs in M(cid:48) can be routed
in G. Consider any demand pair (˜s, ˜t) ∈ ˜M1, and let P ∈ P1 be the path routing (˜s, ˜t). We will
extend the path P , so it connects s to t, by appending two paths: Q(˜s) connecting ˜s to s, and Q(˜t)
connecting ˜t to t, to it. If s ∈ U , then s = ˜s, and we deﬁne Q(˜s) = ∅. Assume now that s (cid:54)∈ U , and
let R ∈ R be the component in which s lies. Let Q(˜s) be any path that starts from ˜s, terminates at
s, and except for its ﬁrst edge, is contained in R. We deﬁne the path Q(˜t) similarly. Let P∗ be the
set of paths obtained by concatenating the paths in P1 with the paths in
.
Then the paths in P∗ route all demand pairs in M(cid:48), so |P∗| ≥ κ
the paths in P∗ are node-disjoint. We do so in the following claim.
Claim 7.19 The paths in P∗ are node-disjoint.

Q(˜s), Q(˜t) | (˜s, ˜t) ∈ ˜M1

. It is now enough to prove that

(cid:110)

(cid:111)

64∆0

Proof: Observe that all endpoints of all paths of P1 are distinct. We ﬁrst prove that for all ter-
minals ˜t, ˜t(cid:48) ∈ T ( ˜M1), with ˜t (cid:54)= ˜t(cid:48), paths Q(˜t) and Q(˜t(cid:48)) are node-disjoint. Assume otherwise. Then
Q(˜t), Q(˜t(cid:48)) (cid:54)= ∅, and t, t(cid:48) (cid:54)∈ U . Let t, t(cid:48) ∈ T ( ˜M(cid:48)) be the terminals corresponding to ˜t and ˜t(cid:48), respectively,
so Q(˜t) connects ˜t to t, and Q(˜t(cid:48)) connects ˜t(cid:48) to t(cid:48). Let R, R(cid:48) ∈ R be the components to which t and t(cid:48)
belong, respectively. Recall that except for its ﬁrst edge, Q(˜t) is contained in R, and the same holds
for Q(˜t(cid:48)) and R(cid:48). Since ˜t (cid:54)= ˜t(cid:48), but Q(˜t)∩ Q(˜t(cid:48)) (cid:54)= ∅, we get that R = R(cid:48). But then ˜t(cid:48) ∈ L(R)∪{u(R)},

55

and so it lies in η(R). Let P (cid:48) be the path of P1, such that ˜t(cid:48) is an endpoint of P (cid:48), and let ˜s(cid:48) be its other
endpoint. Since Γ(t) = γ(R), and set P1 is conﬂict-free, path P (cid:48) cannot intersect γ(R). Therefore, ˜s(cid:48)
must belong to η◦(R). Let s(cid:48) be the terminal in T (M(cid:48)) corresponding to ˜s(cid:48), so path Q(˜s(cid:48)) connects ˜s(cid:48)
to s(cid:48). We claim that if Q(˜s(cid:48)) (cid:54)= ∅, then Q(˜s(cid:48)) is also contained in η◦(R). Indeed, if Q(˜s(cid:48)) (cid:54)= ∅, then s(cid:48)
belongs to some component R(cid:48)(cid:48) ∈ R, and ˜s(cid:48) ∈ L(R(cid:48)(cid:48)) ∪ {u(R(cid:48)(cid:48))}. But since ˜s(cid:48) ∈ η◦(R), and since γ(R)
is a G-normal curve disjoint from V (R(cid:48)(cid:48)), R(cid:48)(cid:48) ⊆ η◦(R) must hold. We conclude that Q(˜s(cid:48)) is contained
in η◦(R). By concatenating Q(˜s(cid:48)), P (cid:48) and Q(˜t(cid:48)), we obtain a path P , connecting s(cid:48) to t(cid:48), where P is
contained in η◦(R), violating Property (P1). We conclude that paths Q(˜t) and Q(˜t(cid:48)) are node-disjoint.
It is now enough to show that for every terminal ˜t ∈ T ( ˜M1), and for every path P ∈ P1, such that
˜t is not an endpoint of P , Q(˜t) is disjoint from P . Assume otherwise, and let ˜s(cid:48), ˜t(cid:48) be the endpoints
of the path P . Since we have assumed that Q(˜t) ∩ P (cid:54)= ∅, Q(˜t) (cid:54)= ∅, and so the vertex t ∈ T (M(cid:48))
serving as the other endpoint of Q(˜t) must lie in some component R ∈ R. Notice that since the paths
in P1 have no conﬂicts, P is disjoint from γ(R), and so it must be contained in η◦(R). Using the same
reasoning as above, we conclude that if Q(˜s(cid:48)) (cid:54)= ∅, then it is contained in η◦(R), and the same holds for
Q(˜t(cid:48)). Therefore, there is a path P , obtained by concatenating P (cid:48), Q(˜s(cid:48)) and Q(˜t(cid:48)), connecting the pair
(s(cid:48), t(cid:48)) ∈ N (cid:48), with P (cid:48) ⊆ η◦(R), contradicting Property (P1). Since the paths in P1 are node-disjoint,
it is now immediate to see that the paths in P∗ must also be node-disjoint.

Theorem 7.20 OPT(G, ˜M) ≥ OPT(G,N (cid:48))

64∆0

.

64∆0

in H.

32∆0+1 ≥ OPT(G,N (cid:48))

Proof: Let P0 be the set of paths in the optimal solution to instance (G,N (cid:48)), and let M0 be the set
of the demand pairs they route. We can assume that |M0| ≥ 64∆0, as otherwise we can route a single
demand pair in ˜M.
As before, we deﬁne a conﬂict graph H, whose vertex set is {v(s, t) | (s, t) ∈ M0}, and there is a
directed edge from v(s1, t1) to v(s2, t2) iﬀ the unique path P (s1, t1) ∈ P0 routing the pair (s1, t1)
intersects Γ(s2) or Γ(t2) (in which case we say that there is a conﬂict between (s1, t1) and (s2, t2)).
Since all paths in P0 are node-disjoint, and all curves Γ(s), Γ(t) have lengths at most 16∆0 each, the
in-degree of every vertex in H is at most 32∆0. Therefore, we can eﬃciently compute an independent
set I of size at least OPT(G,N (cid:48))
Let M1 = {(s, t) | v(s, t) ∈ I}, and let P1 ⊆ P0 be the set of paths routing the demand pairs in M1.
We show that we can route |M1| demand pairs of ˜M in G via node-disjoint paths. Let T1 be the sets
of all terminals participating in the pairs in M1.
Consider any terminal t ∈ T1. We say that t is a good terminal if t ∈ U , or t belongs to some component
R ∈ R, such that |L(R)| ≤ 2. Otherwise, t is a bad terminal. Notice that if t is a good terminal,
then the path P ∈ P1 that contains t as its endpoint must contain a vertex t(cid:48) ∈ β(t): if t ∈ U , then
β(t) = {t}; otherwise, if t ∈ R for some component R ∈ R with |L(R)| ≤ 2, then β(t) = L(R)∪{u(R)}
if u(R) is deﬁned, and β(t) = L(R) otherwise. In either case, in order to enter R, path P has to visit
a vertex of β(t) (it is impossible that P ⊆ R due to Property (P1)). Therefore, if t is a good terminal,
then some vertex t(cid:48) ∈ P belongs to β(t).
We transform the paths in P1 in two steps, to ensure that they connect demand pairs in ˜M. In the
ﬁrst step, for every path P ∈ P1 originating at a good terminal s ∈ T1, we truncate P at the ﬁrst
vertex s(cid:48) ∈ β(s), so it now originates at s(cid:48). Similarly, if P terminates at a good terminal t ∈ T1, we
truncate P at the last vertex t(cid:48) ∈ β(t), so it now terminates at t(cid:48). Let P(cid:48)
1 be the resulting set of paths.
Notice that the paths in P(cid:48)
In order to complete our transformation, we need to take care of bad terminals. Let t ∈ T1 be any

1 remain node-disjoint.

56

bad terminal. Then t ∈ R for some component R ∈ R with |L(R)| ≥ 3. Recall that in this case, β(t)
contains a unique vertex, that we denote by t(cid:48), which is a leg of R, and it is not one of the endpoints of
σ(R). We then let Q(t) be any path connecting t to t(cid:48) in the sub-graph of G induced by V (R) ∪ {t(cid:48)}.
By concatenating the paths in {Q(t)} for all bad terminals t ∈ T1, and the paths in P(cid:48)
1, we obtain a
collection ˜P of at least OPT(G,N (cid:48))
paths, routing demand pairs in ˜M. It now only remains to show
that the paths in ˜P are disjoint. Recall that the paths in P(cid:48)
Claim 7.21 The paths in ˜P are node-disjoint.

1 were node-disjoint.

64∆0

Proof: Consider ﬁrst some pair t1, t2 of bad terminals. We show that the paths Q(t1) and Q(t2) are
disjoint. Let P1 and P2 be the paths in P(cid:48)
1, for which t1 and t2 serve as endpoints, respectively. Let
2 ∈ P1 be the path corresponding to P2, that is, P2 is a sub-path of P (cid:48)
P (cid:48)
2.
Recall that t1 ∈ R for some R ∈ R, and recall that the disc whose boundary is Γ(t1) contains R∪L(R).
2 cannot cross γ(R) since the paths in P1 are are conﬂict-free, and it is not contained in η◦(R),
Path P (cid:48)
since that would violate Property (P1). Therefore, path P (cid:48)
2 lies completely outside η(R), and so does
path P2. Let R(cid:48) ∈ R be the component to which t2 belongs. Then R(cid:48) ∩ η(R) = ∅ must also hold,
since γ(R) cannot intersect R(cid:48), from Theorem 5.5. From our deﬁnition of β(t) for bad terminals t,
β(t1) (cid:54)= β(t2), and each such set contains exactly one vertex. It is now easy to see that Q(t1) and
Q(t2) are disjoint.
Consider now some bad terminal t ∈ T1, and let P ∈ P(cid:48)
1 be any path, such that t is not an endpoint
of P . We next show that Q(t) is disjoint from P . Let t(cid:48), t(cid:48)(cid:48) be the endpoints of path P , and let R ∈ R
be the component containing t. Let P (cid:48) ∈ P1 be the path corresponding to P , so P ⊆ P (cid:48). Path P (cid:48)
cannot intersect γ(R) since the paths in P1 are conﬂict-free, and it is not contained in η◦(R) due to
Property (P1). Therefore, P (cid:48), and hence P , lie completely outside η(R). Since Q(t) ⊆ η(R), we get
that Q(t) ∩ P = ∅. Since the paths in P(cid:48)
1 are node-disjoint, it is now immediate to verify that the
paths in ˜P are node-disjoint as well.
For all 1 ≤ h(cid:48), h(cid:48)(cid:48) ≤ h, we let ˜Mh(cid:48),h(cid:48)(cid:48) be the set of all demand pairs (˜s, ˜t) ∈ ˜M with ˜s ∈ Zh(cid:48)(x) and
˜t ∈ Zh(cid:48)(cid:48)(x). Since h ≤ 16∆0, we obtain the following corollary.
Corollary 7.22 There are some 1 ≤ h(cid:48), h(cid:48)(cid:48) ≤ h, such that OPT(G, ˜Mh(cid:48),h(cid:48)(cid:48)) ≥ Ω
, and for
any solution to instance (G, ˜Mh(cid:48),h(cid:48)(cid:48)), routing κ demand pairs, we can eﬃciently obtain a solution to
instance (G,N (cid:48)), routing Ω(κ/∆0) demand pairs.

(cid:16) OPT(G,N (cid:48))

(cid:17)

∆3
0

It is now enough to prove the following theorem.
Theorem 7.23 There is an eﬃcient algorithm, that for all 1 ≤ h(cid:48), h(cid:48)(cid:48) ≤ h computes a set Ph(cid:48),h(cid:48)(cid:48) of
disjoint paths, routing Ω

(cid:18) OPT(G, ˜Mh(cid:48),h(cid:48)(cid:48) )

demand pairs of ˜Mh(cid:48),h(cid:48)(cid:48) in G.

(cid:19)

∆4

0 log3 n

Step 3: Reduction to Routing on a Disc.
In this step, we complete the proof of Theorem 7.1 by
proving Theorem 7.23. We ﬁx some 1 ≤ h(cid:48), h(cid:48)(cid:48) ≤ h. If h(cid:48) = h(cid:48)(cid:48), then all terminals of T ( ˜Mh(cid:48),h(cid:48)(cid:48)) lie on
Zh(cid:48)(x), and we obtain an instance of the special case, with Z = Zh(cid:48)(x), C = Cx and ˆM = ˜Mh(cid:48),h(cid:48)(cid:48). We
let ˆG(cid:48) be the graph obtained from G by deleting all vertices and edges lying in D◦(Zh(cid:48)), and apply the
O(log n)-approximation algorithm for NDP-Disc to the resulting instance ( ˆG(cid:48), ˆM). From Theorem 7.7,
OPT( ˆG(cid:48), ˆM) ≥ Ω
demand pairs
(cid:54)= h(cid:48)(cid:48) from now on. We assume without loss of generality
of ˜Mh(cid:48),h(cid:48)(cid:48). Therefore, we assume that h(cid:48)

(cid:18) OPT(G, ˜Mh(cid:48),h(cid:48)(cid:48) )

(cid:16) OPT(G, ˆM)

, and so overall we obtain a routing of Ω

(cid:19)

0 log2 n

(cid:17)

∆2

∆2

0 log n

57

that h(cid:48) < h(cid:48)(cid:48), and that all source vertices of ˜Mh(cid:48),h(cid:48)(cid:48) lie on Zh(cid:48)(x) and all destination vertices of ˜Mh(cid:48),h(cid:48)(cid:48)
lie on Zh(cid:48)(cid:48)(x).
In order to simplify the notation, we denote ρ = h(cid:48)(cid:48)−h(cid:48)+1, and we denote cycles Zh(cid:48)(x), Zh(cid:48)+1(x), . . . , Zh(cid:48)(cid:48)(x)
by ˜Z1, ˜Z2, . . . , ˜Zρ, respectively. We also denote ˜Mh(cid:48),h(cid:48)(cid:48) by ˜M, and the sets of all source and all destina-
tion vertices of the demand pairs in ˜M by ˜S and ˜T , respectively. We assume that OPT(G, ˜M) ≥ 500∆4
0,
since otherwise routing a single demand pair of ˜M is suﬃcient. We also assume that for all 1 ≤ i < ρ,
no edge connects a vertex of ˜Zi to a vertex of ˜Zi+1, since we can subdivide each such edge with a
vertex.
For convenience of notation, for each 1 ≤ i < ρ, we denote the set of vertices of G lying in D◦( ˜Zi+1) \
D( ˜Zi) by ˜Ui, and we denote by ˜Ri the set of all type-1 connected components of G[ ˜Ui]. Let R ∈ ˜Ri
be any such connected component. Recall that we have deﬁned a segment σ(R) of ˜Zi containing
all vertices of L(R). We view σ(R) as directed in the counter-clock-wise direction of ˜Zi, and we let
u(cid:48)(R) ∈ L(R) be the ﬁrst vertex of σ(R). We then deﬁne χ(R) to be any path that connects u(cid:48)(R) to
u(R), such that all inner vertices of χ(R) belong to R.
The idea of the proof is to construct a collection Q of special paths, connecting the vertices of ˜Z1
to the vertices of ˜Zρ, that we call staircases. We use the paths in Q, in order to map all the source
vertices in ˜S to some vertices of ˜Zρ. We then reduce the problem to routing on a disc, by creating a
hole D◦( ˜Zρ) in the sphere, so that all terminals participating in the new set ˆM of demand pairs lie
on the boundary ˜Zρ of the hole.
In order to deﬁne the staircases, it will be convenient to work with a directed graph G(cid:48), obtained from
a sub-graph of G, as follows. First, we add the cycles ˜Z1, ˜Z2, . . . , ˜Zρ to G(cid:48), and for each such cycle ˜Zi,
we direct all its edges in the counter-clock-wise direction along ˜Zi. Next, for each 1 ≤ i < ρ, for each
component R ∈ ˜Ri, we add the path χ(R) to G(cid:48), and direct all its edges so that the path is directed
from u(cid:48)(R) to u(R). We are now ready to deﬁne a staircase.
A staircase is simply a directed path in G(cid:48), connecting some vertex of ˜Z1 to some vertex of ˜Zρ, which is
internally disjoint from ˜Zρ. Observe that we can decompose any such staircase Q into 2ρ− 2 segments
µ1(Q), χ1(Q), . . . , µρ−1(Q), χρ−1(Q), where for 1 ≤ i < ρ, µi(Q) is a directed sub-path of ˜Zi (possibly
consisting of a single vertex), and χi(Q) = χ(R) for some R ∈ ˜Ri.
For every vertex v ∈ V ( ˜Z1), we build a special staircase Q(v), as follows. Intuitively, we will try to
minimize the lengths of the segments µi(Q(v)). Denote v = v1. For each 1 ≤ i < ρ, we now deﬁne the
segments µi(Q(v)) and χi(Q(v)), and the vertex vi+1 ∈ V ( ˜Zi+1), which is the last vertex of χi(Q(v)),
assuming that we are given the vertex vi ∈ ˜Zi. We let µi(Q(v)) be the shortest directed segment of ˜Zi,
i, such that for some component R ∈ ˜Ri, u(cid:48)(R) = v(cid:48)
starting from vi, that terminates at some vertex v(cid:48)
i.
If R ∈ ˜Ri is a unique component with this property, then we set χi(Q(v)) = χ(R). Otherwise, let
R(cid:48) ⊆ ˜Ri be the set of all components R with u(cid:48)(R) = v(cid:48)
i. Intuitively, we would like to set χi = χ(R∗),
where R∗ is the ﬁrst component of R(cid:48) in the counter-clock-wise order (see Figure 9). In order to deﬁne
R∗ formally, we need the following observation.
Observation 7.24 There is some component R ∈ ˜Ri, such that R (cid:54)∈ R(cid:48).

Proof: From our assumption, there is a set P of at least 500∆4
0 node-disjoint paths, connecting the
vertices of ˜S to the vertices of ˜T in G. For every path P ∈ P, let vP be the ﬁrst vertex of P lying on
˜Zi+1. Since we have assumed that no edge connects a vertex of ˜Zi to a vertex of ˜Zi+1, there must be
some component R(cid:48) ∈ ˜Ri, such that vP = u(R(cid:48)), and moreover, P must contain some vertex of L(R(cid:48)).
We say that R(cid:48) is responsible for P . Notice that each component of Ri may be responsible for at most
one path in P.

58

i}, and so the components

contiguous set of vertices on γ, and all vertices that lie on γ belong to(cid:83)
the shortest segment of γ, containing all vertices of(cid:83)

Notice that for all components R(cid:48) ∈ R(cid:48), except for maybe one, L(R) = {v(cid:48)
of R(cid:48) may be responsible for at most two paths in P. But |P| ≥ 500∆4
We draw a closed G-normal curve γ ⊆ D◦( ˜Zi+1) \ D( ˜Zi), so that for each R(cid:48) ∈ ˜Ri, γ ∩ V (R(cid:48)) is a
V (R(cid:48)). We then let σ∗ be
R(cid:48)∈R(cid:48) V (R(cid:48)), and no other vertices (in particular,
the vertices of all components in Ri \ R(cid:48) do not lie on σ∗). Let v∗ be the ﬁrst vertex on σ∗ in the
counter-clock-wise direction, and let R∗ ∈ R(cid:48) be the unique component containing v∗. Finally, we set
χi(Q(v)) = χ(R∗). The ﬁnal staircase Q(v) is a concatenation of the paths in {µi(Q(v)), χi(Q(v))}ρ−1
i=1 .
Each such staircase Q(v) deﬁnes an undirected path in graph G, that we also denote by Q(v), and we
do not distinguish between them.

0, so ˜Ri \ R(cid:48) (cid:54)= ∅.

R(cid:48)∈ ˜Ri

Figure 9: A staircase Q(v) in graph G.

We will use the following lemma in order to bound the number of paths in the optimal solution
intersecting any staircase Q(v).
Lemma 7.25 Let P∗ be any set of node-disjoint paths, connecting a subset of the demand pairs in
˜M. Then for each v ∈ V ( ˜Z1), the number of paths in P∗ that intersect Q(v) is at most O(∆2
0).

of ˜T is contained in (cid:83)

Proof: For simplicity of notation, denote Q = Q(v). We construct a collection D of at most 3ρ ≤
O(∆0) discs, such that for each disc η ∈ D, its boundary is a G-normal curve of length at most
O(∆0). We ensure that every vertex v(cid:48) ∈ V (Q) is contained in some disc η ∈ D, and no terminal
η∈D η◦. It is then easy to see that every path P ∈ P∗ that intersects Q must
also contain at least one vertex on the boundary of some disc in D, and, since the total length of all
boundaries of the discs in D is bounded by O(∆2
For simplicity of notation, for all 1 ≤ i < ρ, we denote µi(Q) by µi, and χi(Q) by χi. We let vi, v(cid:48)
i be the
ﬁrst and the last vertex of µi, respectively, and we let Ri ∈ ˜Ri be the component with χ(Ri) = χi(Q),
i = u(cid:48)(Ri) (see Figure 10). We start with D = ∅. For each 1 ≤ i < ρ, we
so that vi+1 = u(Ri), and v(cid:48)
add at most three discs to D.
Fix some 1 ≤ i < ρ. We ﬁrst add to D the disc η(Ri), given by Theorem 5.5. Notice that this
disc contains all vertices of χi(Q), and its boundary is a G-normal curve of length O(∆0). Let R(cid:48)
be the set of all type-1 and type-2 components R of G[ ˜Ui], such that vi is an inner vertex of σ(R).
σ(R1) ⊆ σ(R2) ⊆ ··· ⊆ σ(Rq). Notice that among all components in R(cid:48), only Rq may be a type-1

Since the segments in {σR | R ∈ R(cid:48)} form a nested set, we can assume that R(cid:48) =(cid:8)R1, . . . , Rq(cid:9) with

0) paths in P∗ intersect Q.

0), at most O(∆2

59

vi ⊆ µi be the segment of µi between v∗

i = vi. Let µ(cid:48)
i , containing all vertices of µ(cid:48)

component, and the remaining components are type-2 components. If R(cid:48) (cid:54)= ∅, then we let v∗
i be the
i ∈ µi, and we add the disc η(Rq) to
last vertex on σ(Rq) in the counter-clock-wise direction, so v∗
D. Otherwise, we let v∗
i (see Figure 10).
Notice that all vertices of µi \ µ(cid:48)
i are contained in the discs we have already added to D. Our ﬁnal
step is to add a disc η∗
i, that is deﬁned as follows. From our construction
of the staircases and the set R(cid:48), if R is a component of G[ ˜Ui], and some inner vertex of µ(cid:48)
i belongs to
L(R), then R is a type-2 component, and σ(R) ⊆ µ(cid:48)(R). Therefore, we can draw a G-normal curve
i , so that γi is contained in D◦( ˜Zi+1) \ D( ˜Zi), and it is internally disjoint
γi with endpoints v(cid:48)
from all vertices of G. From Property (J4) of shells, we can construct curves γ, γ(cid:48) that connect v(cid:48)
i and
i , respectively, to some vertices a, a(cid:48) ∈ Cx, so that γ, γ(cid:48) ⊆ D( ˜Zi), and the length of each curve is
v∗
bounded by i ≤ 8∆0. Combining γi, γ, γ(cid:48), and one of the segments of Cx with endpoints a and a(cid:48), we
obtain a closed curve γ∗
i , contains all
vertices of µ(cid:48)

i of length O(∆0), such that the disc η∗

i , whose boundary is γ∗

i and v(cid:48)

i and v∗

i. We then add η∗

i to D.

Figure 10: Constructing the disc η∗

i . The staircase is shown in red.

(cid:110)

It is easy to verify that all vertices of µi ∪ χi lie in the discs η(Ri), η(Rq), η∗
i , and for each such disc,
its boundary is a G-normal curve of length at most O(∆0). Moreover, from our construction, none of
these discs contains a vertex of Zρ, except as part of its boundary. We conclude that every vertex of
Q belongs to some disc η ∈ D, the boundary of each such disc is a G-normal curve of length at most
O(∆0). Every path P ∈ P∗ intersecting Q must intersect the boundary of at least one disc in D, and
since |D| = O(∆0), the number of such paths is bounded by O(∆2
0).
Consider now the set Q =
of staircases. Notice that once a pair of staircases meet,
they always continue together. Therefore, we can partition the set Q of staircases into equivalence
classes Q1, . . . ,Qλ, where two staircases belong to the same class iﬀ they terminate at the same vertex.
From the above discussion, staircases belonging to distinct equivalence classes must be disjoint. For
each such set Qj, let Vj ⊆ V ( ˜Z1) be the set of all vertices where the staircases of Qj originate. We
also need the following lemma.
Lemma 7.26 Let P∗ be any set of node-disjoint paths, connecting a subset of the demand pairs in
˜M. Then for each 1 ≤ j ≤ λ, the number of paths in P∗ that originate at the vertices of Vj is at most
O(∆2

Q(v) | v ∈ V ( ˜Z1)

(cid:111)

0).

Proof: Fix some 1 ≤ j ≤ λ, and let P(cid:48) ⊆ P∗ be the set of paths originating at the vertices of Vj.
We assume that Qj = {Q1, . . . , Qr}, and the endpoints of the paths Qi that belong to Vj appear
consecutively in this order on ˜Z1. Let v1, vr ∈ Vj be the vertices where the paths Q1 and Qr originate.
From Property (J4) of shells, we can construct G-normal curves γ, γ(cid:48), connecting v1 and vr, respec-
tively, to some vertices a, a(cid:48) of Cx, so that the length of each such curve is bounded by h(cid:48) ≤ 8∆0,
and both curves are contained in D( ˜Z1). We claim that every path in P(cid:48) must contain a vertex of

60

˜Zi˜Zi+1viv⇤iv0iRiRqCx⌘⇤i(cid:17)

log n

(cid:110)
(s(cid:48), t) | (s, t) ∈ ˜M(cid:111)
(cid:16) OPT( ˆG, ˆM)

V (γ) ∪ V (γ(cid:48)) ∪ V (Q1) ∪ V (Qr) ∪ V (Cx). Indeed, consider the curve γ∗ obtained by the union of the
images of Q1 and Qr, the curves γ and γ(cid:48), and one of the segments of Cx with endpoints a and a(cid:48).
Then for every path of P(cid:48), its source lies inside or on the curve γ∗, and its destination lies either on γ∗
(when the destination is the common endpoint of all paths in Qj), or outside the curve γ∗. Therefore,
every path in P(cid:48) must contain a vertex of V (γ) ∪ V (γ(cid:48)) ∪ V (Q1) ∪ V (Qr) ∪ V (Cx). Since γ, γ(cid:48) and Cx
0) paths in P∗ may intersect
contain O(∆0) vertices each, and since from Lemma 7.25 at most O(∆2
Q1 and Qr, we get that |P(cid:48)| ≤ O(∆0)2.
We are now ready to complete our reduction. For every source vertex s ∈ ˜S, let s(cid:48) be the ver-
tex of ˜Zρ that serves as the other endpoint of path Q(s). We deﬁne a new set of demand pairs
ˆM =
. Notice that (G, ˆM) is now an instance of the special case, where we use
Z = ˜Zρ and C = Cx. We construct a graph ˆG from G, by creating a hole D◦( ˜Zρ) in the sphere,
and removing from G all edges and vertices that lie in the interior of D( ˜Zρ). We then apply the
O(log n)-approximation algorithm for NDP-Disc to the resulting problem, to obtain a routing of at
least Ω
, and so we ob-
demand pairs of ˆM in graph ˆG. Notice that
tain a set P of disjoint paths, routing of Ω
for all 1 ≤ j ≤ λ, if we denote by bj the unique vertex where all staircases of Qj terminate, then at
most one demand pair in which bj participates is routed by P. We construct a set Q(cid:48) ⊆ Q of staircases
as follows. For every demand pair (s(cid:48), t) ∈ ˆM routed by P, we select one source vertex s ∈ ˜S with
(s, t) ∈ ˜M, such that the staircase Q(s) terminates at s(cid:48), and we add Q(s) to Q(cid:48). Notice that all
staircases in Q(cid:48) are disjoint from each other, since all of them belong to diﬀerent sets Qj.
Since the paths in P do not use any vertices in the interior of D( ˜Zρ), we can combine them with the
paths in Q(cid:48), to obtain a routing of Ω
demand pairs of ˜M in graph G. In order to complete
the proof of Theorem 7.23, it is now enough to show that OPT(G, ˆM) ≥ Ω
the following claim.
Claim 7.27 OPT(G, ˆM) ≥ Ω

demand pairs. From Theorem 7.7, OPT( ˆG, ˆM) ≥ Ω

(cid:16) OPT(G, ˜M)

(cid:16) OPT(G, ˆM)

(cid:16) OPT(G, ˆM)

(cid:16) OPT(G, ˆM)

(cid:16) OPT(G, ˜M)

. We do so in

∆2

0 log2 n

∆2

0 log2 n

(cid:17)

∆2
0

(cid:17)

∆2

0 log n

(cid:17)

(cid:17)

(cid:17)

.

∆2
0

(cid:111)

(cid:110)

v(s, t) | (s, t) ∈ ˜M0

Proof: Let P0 be a set of paths routing κ0 = OPT(G, ˜M) demand pairs of ˜M in G. We show that we
0) demand pairs of ˆM in G. Let ˜M0 ⊆ ˜M be the set of the demand pairs routed by
can route Ω(κ0/∆2
set P0. For each demand pair (s, t) ∈ ˜M0, let P (s, t) ∈ P0 be the path routing this demand pair. We
, and there is a directed edge from
build a conﬂict graph H, whose vertex set is
v(s1, t1) to v(s2, t2) iﬀ one of the following happens: either (i) s1 and s2 both belong to the same set
Vj, for 1 ≤ j ≤ λ; or (ii) path P (s2, t2) intersects Q(s1). From Lemmas 7.25 and 7.26, the in-degree
of every vertex in H is at most O(∆2
0) vertices
in H. We let ˜M1 = {(s, t) | v(s, t) ∈ I}, and we let P1 ⊆ P0 be the set of paths routing the demand
pairs in ˜M1.
Let ˆM(cid:48) ⊆ ˆM contain, for every demand pair (s, t) ∈ ˜M1, the pair (s(cid:48), t). It is now enough to show that
all demand pairs in ˆM(cid:48) can be routed in G. Let Q(cid:48) contain all staircases Q(s), where s participates
in some demand pair in ˜M1. Then all staircases in Q(cid:48) are disjoint from each other, since they all
belong to diﬀerent sets Qj, for 1 ≤ j ≤ λ. Moreover, for each staircase Q(s) ∈ Q(cid:48), all paths in
P1 \ {P (s, t)} are disjoint from Q(s). By concatenating the paths in P1 and the staircases in Q(cid:48), we
obtain a collection of node-disjoint paths routing all demand pairs in ˆM(cid:48)

0). Therefore, there is an independent set I of Ω(κ0/∆2

61

8 Proof of Theorem 1.3

(cid:16) (X∗)1/19

(cid:17)

We perform a transformation to instance (G,M) as before, to ensure that every terminal participates
in at most one demand pair, and the degree of every terminal is 1. The number of vertices in the
new instance is bounded by 2n2, and abusing the notation we denote this number by n. We use the
following analogue of Theorem 4.1.

Theorem 8.1 There is an eﬃcient algorithm, that, given any semi-feasible solution to (LP-ﬂow2),
demand pairs in M via node-disjoint paths, or

either computes a routing of at least Ω
returns a constraint of type (5), that is violated by the current solution.

poly log n

(cid:16) (X∗)1/19

(cid:17)

We show that the above theorem implies Theorem 1.3. The Ellipsoid Algorithm, in every iteration,
applies the above theorem to the current semi-feasible solution (x, f ) to (LP-ﬂow2). If the outcome is a

(cid:17)

poly log n

(cid:16) (OPT(G,M))1/19

solution routing at least Ω
demand pairs, then we obtain the desired routing, assuming that
X∗ = OPT is guessed correctly. Otherwise, we obtain a violated constraint of type (5), and continue
to the next iteration of the Ellipsoid Algorithm. The algorithm is guaranteed to terminate with a
feasible solution after a number of iterations that is polynomial in the number of the LP-variables,
so we obtain an eﬃcient algorithm, that returns a solution routing Ω
demand pairs.
We now focus on proving Theorem 8.1.
We again process the fractional solution (x, f ) to obtain a new fractional solution (x(cid:48), f(cid:48)), where every
demand pair sends either 0 or w∗ ﬂow units, in the same way as described in Section 4. We let M(cid:48) ⊆ M
denote the set of the demand pairs (si, ti) with non-zero ﬂow value x(cid:48)
i in this new solution. As before,
the total ﬂow between the demand pairs in M(cid:48) is at least Ω(X∗/ log k) in the new solution, and, if
we ﬁnd a subset M(cid:48)(cid:48) ⊆ M(cid:48) of demand pairs with OPT(G,M(cid:48)(cid:48)) ≤ w∗|M(cid:48)(cid:48)|/2, then set M(cid:48)(cid:48) deﬁnes a
violated constraint of type (5) for (LP-ﬂow2). Therefore, we focus on set M(cid:48) and for simplicity denote
M = M(cid:48).

We decompose the input instance (G,M) into a collection of well-linked instances (cid:8)(Gj,Mj)(cid:9)r
Mj to the current ﬂow solution and let W =(cid:80)r

using Theorem 4.2. For each 1 ≤ j ≤ r, let Wj = w∗|Mj| be the contribution of the demand pairs in

j=1 Wj = Ω(X∗/ log k).

poly log n

j=1

Theorem 4.3 guarantees that for each 1 ≤ j ≤ r, we can obtain one of the following:

w∗| ˜Mj|/8.

1. Either a collection P j of node-disjoint paths, routing Ω(W

/ poly log n) demand pairs of Mj

1/19
j

in Gj; or

2. A collection ˜Mj ⊆ Mj of demand pairs, with | ˜Mj| ≥ |Mj|/2, such that OPT(Gj, ˜Mj) ≤

We say that instance (Gj,Mj) is a type-1 instance, if the ﬁrst outcome happens for it, and we say

that it is a type-2 instance otherwise. Let I1 = (cid:8)j | (Gj,Mj) is a type-1 instance(cid:9), and similarly,
I2 =(cid:8)j | (Gj,Mj) is a type-2 instance(cid:9). We consider two cases, where the ﬁrst case happens when
(cid:80)
j∈I1 Wj ≥ W/2, and the second case when (cid:80)
(cid:83)

In the second case, we let M(cid:48) =
˜Mj, and by the same reasoning as in Section 4, the following inequality, that is violated by the

j∈I2 Wj ≥ W/2.

j∈I2

current LP-solution, is a valid constraint of (LP-ﬂow2):

(cid:88)

(si,ti)∈M(cid:48)

i ≤ w
(cid:48)

x

∗|M(cid:48)|/2.

62

(cid:18) W 1/19

We now focus on Case 1, where the number of paths routed for each instance (Gj,Mj) with j ∈ I1
j∈I1 Wj ≥ W/2 = Ω (X∗/ log k), the total number of paths
is at least |P j| = Ω
routed is:

poly log n

j

(cid:19)
. Since (cid:80)
|P j| ≥(cid:88)
(cid:88)
≥(cid:88)
(cid:32)
(cid:32)

j∈I1

j∈I1

j∈I1

= Ω

= Ω

(cid:33)

W

1/19
j

poly log n

(cid:32)
(cid:18)

Ω

Ω

(cid:19)

Wj

W 18/19 · poly log n

(cid:33)
(cid:33)

.

W 1/19

poly log n
(X∗)1/19
poly log n

9 Conclusion and Open Problems

In this paper we showed the ﬁrst approximation algorithm for the NDP-Planar problem, whose approx-
imation factor breaks the Ω(n1/2) barrier of the multicommodity ﬂow LP-relaxation. We introduce a
number of new techniques, that we hope will be helpful in obtaining better approximation algorithms
for this problem. We note that our initial motivation came from the improved approximation algo-
rithm for NDP-Grid of [CK15]. Even though adapting their main idea to the more general setting
of planar graphs is technically challenging, we believe that the work of [CK15] on the much simpler
and better structured grid graphs helped crystallize the main conceptual idea that eventually lead
to this result. Therefore, we believe that studying the NDP-Grid problem can be very helpful in un-
derstanding the more general NDP-Planar problem. The best current approximation algorithm for
NDP-Grid achieves an ˜O(n1/4)-approximation, and it seems likely that this approximation ratio can
be improved. We leave open the question of whether the techniques introduced in this paper can help
improve the O(n1/2)-approximation factor of [CKS06] for EDP on planar graphs. Finally, we remark
that the complexity of the NDP-Disc and the NDP-Cylinder problems is still not well-understood: we
provide an O(log k)-approximation algorithm for both problems, and we are not aware of any results
that prove that the optimization versions of NDP-Disc or NDP-Cylinder are NP-hard. We note that
the EDP problem is known to be NP-hard for both these settings [Nav12], but we are not aware of any
approximation algorithms for it.

References

[ACG+10] Matthew Andrews, Julia Chuzhoy, Venkatesan Guruswami, Sanjeev Khanna, Kunal Tal-
war, and Lisa Zhang. Inapproximability of edge-disjoint paths and low congestion routing
on undirected graphs. Combinatorica, 30(5):485–520, 2010.

[AKR03]

Eyal Amir, Robert Krauthgamer, and Satish Rao. Constant factor approximation of
vertex-cuts in planar graphs. In Proceedings of the thirty-ﬁfth annual ACM symposium
on Theory of computing, pages 90–99. ACM, 2003.

[And10]

Matthew Andrews. Approximation algorithms for the edge-disjoint paths problem via
Raecke decompositions. In Proceedings of IEEE FOCS, pages 277–286, 2010.

63

[AR95]

[AZ05]

[CC]

[CE13]

[Chu12]

[CK15]

[CKS04]

[CKS05]

[CKS06]

[CL12]

[DH05]

[EIS76]

[Kar72]

[KK13]

Yonatan Aumann and Yuval Rabani. Improved bounds for all optical routing. In Proceed-
ings of the sixth annual ACM-SIAM symposium on Discrete algorithms, SODA ’95, pages
567–576, Philadelphia, PA, USA, 1995. Society for Industrial and Applied Mathematics.

Matthew Andrews and Lisa Zhang. Hardness of the undirected edge-disjoint paths prob-
lem. In STOC, pages 276–283. ACM, 2005.

Chandra Chekuri and Julia Chuzhoy. Half-integral all-or-nothing ﬂow. Unpublished
Manuscript.

Chandra Chekuri and Alina Ene. Poly-logarithmic approximation for maximum node
disjoint paths with constant congestion. In Proc. of ACM-SIAM SODA, 2013.

Julia Chuzhoy. Routing in undirected graphs with constant congestion. In Proc. of ACM
STOC, pages 855–874, 2012.

Julia Chuzhoy and David H. K. Kim. On approximating node-disjoint paths in grids.
In Naveen Garg, Klaus Jansen, Anup Rao, and Jos´e D. P. Rolim, editors, Approxima-
tion, Randomization, and Combinatorial Optimization. Algorithms and Techniques, AP-
PROX/RANDOM 2015, August 24-26, 2015, Princeton, NJ, USA, volume 40 of LIPIcs,
pages 187–211. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2015.

Chandra Chekuri, Sanjeev Khanna, and F Bruce Shepherd. Edge-disjoint paths in pla-
nar graphs. In Foundations of Computer Science, 2004. Proceedings. 45th Annual IEEE
Symposium on, pages 71–80. IEEE, 2004.

Chandra Chekuri, Sanjeev Khanna, and F. Bruce Shepherd. Multicommodity ﬂow, well-
linked terminals, and routing problems. In Proc. of ACM STOC, pages 183–192, 2005.

√
Chandra Chekuri, Sanjeev Khanna, and F. Bruce Shepherd. An O(
n) approximation and
integrality gap for disjoint paths and unsplittable ﬂow. Theory of Computing, 2(1):137–
146, 2006.

Julia Chuzhoy and Shi Li. A polylogarithimic approximation algorithm for edge-disjoint
paths with congestion 2. In Proc. of IEEE FOCS, 2012.

Erik D. Demaine and Mohammad Taghi Hajiaghayi. Graphs excluding a ﬁxed minor have
grids as large as treewidth, with combinatorial and algorithmic applications through bidi-
mensionality. In Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete
Algorithms, SODA 2005, Vancouver, British Columbia, Canada, January 23-25, 2005,
pages 682–689. SIAM, 2005.

Shimon Even, Alon Itai, and Adi Shamir. On the complexity of timetable and multicom-
modity ﬂow problems. SIAM J. Comput., 5(4):691–703, 1976.

R. Karp. Reducibility among combinatorial problems.
editors, Complexity of Computer Computations, pages 85–103. Plenum Press, 1972.

In R. Miller and J. Thatcher,

Ken-Ichi Kawarabayashi and Yusuke Kobayashi. An O(log n)-approximation algorithm
for the edge-disjoint paths problem in Eulerian planar graphs. ACM Trans. Algorithms,
9(2):16:1–16:13, March 2013.

64

[Kle05]

[KS04]

[KT95]

[KT98]

[KvL84]

[Lyn75]

[Nav12]

[R¨ac02]

Jon Kleinberg. An approximation algorithm for the disjoint paths problem in even-degree
planar graphs. In Proceedings of the 46th Annual IEEE Symposium on Foundations of
Computer Science, FOCS ’05, pages 627–636, Washington, DC, USA, 2005. IEEE Com-
puter Society.

Stavros G. Kolliopoulos and Cliﬀord Stein. Approximating disjoint-path problems using
packing integer programs. Mathematical Programming, 99:63–87, 2004.

Jon M. Kleinberg and ´Eva Tardos. Disjoint paths in densely embedded graphs. In Proceed-
ings of the 36th Annual Symposium on Foundations of Computer Science, pages 52–61,
1995.

Jon M. Kleinberg and ´Eva Tardos. Approximations for the disjoint paths problem in
high-diameter planar networks. J. Comput. Syst. Sci., 57(1):61–73, 1998.

MR Kramer and Jan van Leeuwen. The complexity of wire-routing and ﬁnding minimum
area layouts for arbitrary vlsi circuits. Advances in computing research, 2:129–146, 1984.

James F. Lynch. The equivalence of theorem proving and the interconnection problem.
SIGDA Newsl., 5(3):31–36, September 1975.

Guyslain Naves. The hardness of routing two pairs on one face. Mathematical program-
ming, 131(1-2):49–69, 2012.

Harald R¨acke. Minimizing congestion in general networks. In Proc. of IEEE FOCS, pages
43–52, 2002.

[RLWW96] Heike Ripphausen-Lipa, Dorothea Wagner, and Karsten Weihe. Linear-time algorithms for
disjoint two-face paths problems in planar graphs. International Journal of Foundations
of Computer Science, 07(02):95–110, 1996.

[RS86]

[RS90]

[RS95]

Neil Robertson and Paul D Seymour. Graph minors. vi. disjoint paths across a disc.
Journal of Combinatorial Theory, Series B, 41(1):115–138, 1986.

N. Robertson and P. D. Seymour. Outline of a disjoint paths algorithm. In Paths, Flows
and VLSI-Layout. Springer-Verlag, 1990.

Neil Robertson and Paul D Seymour. Graph minors. XIII. the disjoint paths problem.
Journal of Combinatorial Theory, Series B, 63(1):65–110, 1995.

[RST94]

Neil Robertson, Paul D. Seymour, and Robin Thomas. Quickly excluding a planar graph.
J. Comb. Theory, Ser. B, 62(2):323–348, 1994.

[RT87]

[RZ10]

[SAN90]

Prabhakar Raghavan and Clark D. Tompson. Randomized rounding: a technique for
provably good algorithms and algorithmic proofs. Combinatorica, 7:365–374, December
1987.

Satish Rao and Shuheng Zhou. Edge disjoint paths in moderately connected graphs. SIAM
J. Comput., 39(5):1856–1887, 2010.

Hitoshi Suzuki, Takehiro Akama, and Takao Nishizeki. Finding steiner forests in planar
In Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algo-
graphs.
rithms, SODA ’90, pages 444–453, Philadelphia, PA, USA, 1990. Society for Industrial
and Applied Mathematics.

65

[SCS11]

Lo¨ıc Seguin-Charbonneau and F. Bruce Shepherd. Maximum edge-disjoint paths in planar
graphs with congestion 2. In Proceedings of the 2011 IEEE 52Nd Annual Symposium on
Foundations of Computer Science, FOCS ’11, pages 200–209, Washington, DC, USA,
2011. IEEE Computer Society.

A Proofs Omitted from Section 2

|C|

A.1 Proof of Observation 2.1
For every terminal t ∈ T , let vt ∈ V (G) be the unique neighbor of t in G. Let (A, C, B) be the cut
computed by algorithm AAKR, whose sparsity β =
min{|A∩T |,|B∩T |}+|C∩T | is within factor αAKR of the
optimal one. If β > 1, then we replace cut (A, C, B) with the cut (∅,T , V (G) \ T ), obtaining a cut of
sparsity 1, and continue with our algorithm, so we assume that β ≤ 1 from now on. While C ∩T (cid:54)= ∅,
let t ∈ C ∩ T be any terminal in C.
If |A∩T | < |B∩T |, then we move t from C to A, and if vt (cid:54)∈ C, we add vt to C. Let (A(cid:48), C(cid:48), B(cid:48)) be the
resulting tri-partition of V (G). It is easy to see that (A(cid:48), C(cid:48), B(cid:48)) is a valid vertex cut, and |C(cid:48)| ≤ |C|,
while min{|A(cid:48) ∩ T |,|B(cid:48) ∩ T |} + |C(cid:48) ∩ T | = min{|A ∩ T |,|B ∩ T |} + |C ∩ T |, so the sparsity of the cut
does not increase.
The case where |B ∩ T | < |A ∩ T | is dealt with similarly.
Finally, assume that |A∩T | = |B∩T |. If vt ∈ A, then we move t from C to A, and otherwise we move t
from C to B. Let (A(cid:48), C(cid:48), B(cid:48)) be the resulting tri-partition of V (G). It is easy to see that (A(cid:48), C(cid:48), B(cid:48)) is
a valid vertex cut, and |C(cid:48)| = |C|− 1. It is also easy to verify that min{|A(cid:48) ∩ T |,|B(cid:48) ∩ T |} +|C(cid:48)∩T | ≥
min{|A ∩ T |,|B ∩ T |} + |C ∩ T | − 1, and min{|A(cid:48) ∩ T |,|B(cid:48) ∩ T |} + |C(cid:48) ∩ T | > 0 hold. Since β ≤ 1,
the sparsity of the cut does not increase. Once we process all terminals in set C in this fashion, we
obtain a ﬁnal vertex cut (A, C, B) whose sparsity is at most β, and C ∩ T = ∅.

A.2 Proof of Claim 2.2
We compute a partition R(τ ) for every tree τ ∈ F separately. The partition is computed in iterations,
where in the jth iteration we compute the set Rj(τ ) ⊆ V (τ ) of vertices, together with the corresponding
collection Pj(τ ) of paths. For the ﬁrst iteration, if τ contains a single vertex v, then we add this vertex
to R1(τ ) and terminate the algorithm. Otherwise, for every leaf v of τ , let P (v) be the longest directed
path of τ , starting at v, that only contains degree-1 and degree-2 vertices, and does not contain the
root of τ . We then add the vertices of P (v) to R1(τ ), and the path P (v) to P1(τ ). Once we process
all leaf vertices of τ , the ﬁrst iteration terminates. It is easy to see that all resulting vertices in R1(τ )
induce a collection P1(τ ) of disjoint paths in τ , and moreover if v, v(cid:48) ∈ R1(τ ), and there is a path from
v to v(cid:48) in τ , then v, v(cid:48) lie on the same path in P1(τ ). We then delete all vertices of R1(τ ) from τ .
The subsequent iterations are executed similarly, except that the tree τ becomes smaller, since we
delete all vertices that have been added to the sets Rj(τ ) from the tree.
It is now enough to show that this process terminates after (cid:100)log n(cid:101) iterations. In order to do so, we
can describe each iteration slightly diﬀerently. Before each iteration starts, we contract every edge e of
the current tree, such that at least one endpoint of e has degree 2 in the tree, and e is not incident on
the root of τ . We then obtain a tree in which every inner vertex (except possibly the root) has degree
at least 3, and delete all leaves from this tree. The number of vertices remaining in the contracted
tree after each such iteration therefore decreases by at least factor 2. It is easy to see that the number

66

by (cid:100)log n(cid:101). For each 1 ≤ j ≤ (cid:100)log n(cid:101), we then let Rj =(cid:83)T ∈F Rj(T ).

of iteration in this procedure is the same as the number of iterations in our algorithm, and is bounded

A.3 Proof of Lemma 2.3
We denote by T the set of all vertices participating in the demand pairs in M, and we refer to them
as terminals. Consider any demand pair (s, t) ∈ M, and let σ(s, t), σ(cid:48)(s, t) be the two segments of C
whose endpoints are s and t. We assume without loss of generality that |σ(s, t) ∩ T | ≤ |σ(cid:48)(s, t) ∩ T |,
and we denote δ(s, t) = |σ(s, t) ∩ T | − 1. By possibly renaming the terminals s and t, we assume
that s appears before t on σ(s, t) as we traverse it in counter-clock-wise direction along C. Our ﬁrst
step is to partition the demand pairs in M into (cid:100)log κ(cid:101) subsets N1, . . . ,N(cid:100)log κ(cid:101), as follows. For each
1 ≤ i ≤ (cid:100)log κ(cid:101), Ni contains all demand pairs (s, t) with 2i−1 ≤ δ(s, t) < 2i. In order to complete the
proof of the lemma, it is enough to show that for each 1 ≤ i ≤ (cid:100)log κ(cid:101), we can partition Ni into four
sets of demand pairs, each of which is r-split, for some integer r.
Fix some 1 ≤ i ≤ (cid:100)log κ(cid:101), and assume that T = {v1, . . . , v2κ}, where the vertices are indexed in the
circular order of their appearance on C. We let A contain all vertices vj, where j = 1 modulo 2i−1.
For convenience, we denote A = {a1, . . . , az}, and we assume that the vertices of A appear in this
circular order on C, with a1 = v1. If |A| = 1, then |T | ≤ 2i−1, and so δ(s, t) ≤ 2i−2 for all (s, t) ∈ M,
and Ni = ∅. If |A| = 2, then let β, β(cid:48) be the two segments of C between a1 and a2, where β contains
a1 but not a2, and β(cid:48) contains a2 but not a1. Then for every pair (s, t) ∈ Ni, one of the two terminals
lies on β and the other on β(cid:48), and so Ni is 1-split. We assume from now on that z ≥ 3.
For each 1 ≤ j ≤ z − 1, let βj be the segment of C from aj and aj+1, as we traverse C in the counter-
clock-wise order, so that βj includes aj but excludes aj+1. We let βz be the segment of C from az to
a1, as we traverse C in the counter-clock-wise order, so that βz includes az, but not a1. Then for every
segment βj with 1 ≤ j < z, |βj ∩ T | = 2i−1, while |βz ∩ T | ≤ 2i−1. Notice that for every demand pair
(s, t) ∈ Ni, one of the following must happen: either (i) s ∈ βj, t ∈ βj+1 for some 1 ≤ j ≤ z, where we
treat z + 1 as 1; or (ii) s ∈ βz, t ∈ β2; or (iii) s ∈ βz−1, t ∈ β1.
i , contains all pairs (s, t) ∈ Ni
We are now ready to partition Ni into four subsets. The ﬁrst subset, N 1
i , contains all pairs (s, t) ∈ Ni, with s ∈ βz, t ∈ β1 ∪ β2.
with s ∈ βz−1, t ∈ β1. The second set, N 2
It is immediate to verify that each of these two sets is 1-split. The third set, N 3
i , contains all pairs
i ), where s ∈ βj, for an odd index 1 ≤ j < z. This set is (cid:98)z/2(cid:99)-split, with the
(s, t) ∈ Ni \ (N 1
i , contains all pairs (s, t) ∈ Ni\(N 1
i ∪N 3
segments β1, . . . , βz giving the splitting. The last set, N 4
i ).
i , s ∈ βj for an even index 1 ≤ j < z. Overall,
This set is similarly (cid:98)z/2(cid:99)-split, since for all (s, t) ∈ N 4
we obtain a partition of M into 4(cid:100)log κ(cid:101) sets, each of which is r-split for some integer r.

i ∪ N 2

i ∪N 2

A.4 Proof of Lemma 2.4
Consider any path P ∈ P. A sub-path Q of P is called a bump, if the two endpoints of Q lie on C,
and all the intermediate vertices of Q do not lie on C (notice that Q may be simply an edge of C).
Since path P is simple, a bump Q cannot contain s.

We now deﬁne a shadow of a bump Q. If Q is an edge of C, then the shadow of Q is Q itself. Assume
now that Q is not an edge of C. Let u, v ∈ V (C) be the two endpoints of Q, and let σ, σ(cid:48) be the two
segments of C with endpoints u and v. Let C1 be the union of σ and Q, and C2 the union of σ(cid:48) and
Q. Then one of the two corresponding discs, D(C1) and D(C2) contains s - we assume that it is the
latter disc. We then let σ be the shadow of Q on C (see Figure 11).
We note that all inner points on the image of Q must lie outside D◦(C), as otherwise, we can ﬁnd a cycle

67

Figure 11: A bump Q and its shadow

C(cid:48) in H with D(C(cid:48)) containing s and D(C(cid:48)) (cid:40) D(C), contradicting the fact that C = min-cycle(H, s).
We obtain the following two simple observations.
Observation A.1 Let P ∈ P be any path, and let R be the longest segment of P , starting from s and
terminating at a vertex of C, such that R does not contain any vertex of C as an inner vertex. Let
v ∈ V (C) be the endpoint of R, and let R(cid:48) be the sub-path of P from v to t. Then every point p on
the image of R(cid:48) lies outside D◦(C).

Proof: If any such point p lies in D◦(C), then for some bump Q of P , some inner point on the image
of Q lies in D◦(C), and this is impossible, as observed above.
Observation A.2 Let P, P (cid:48) ∈ P be two distinct paths, let Q be a bump on P , and let Q(cid:48) be a bump
on P (cid:48). Then the shadows of Q and Q(cid:48) are node-disjoint.

Proof: Let σ be the shadow of Q, and let a, b be its endpoints. Let σ(cid:48) be the shadow of Q(cid:48), and let a(cid:48), b(cid:48)
be its endpoints. Since the inner points of the images of both Q and Q(cid:48) lie outside D◦(C), and their
endpoints are all distinct, if σ and σ(cid:48) are not disjoint, then either σ (cid:40) σ(cid:48), or σ(cid:48) (cid:40) σ. Assume without
loss of generality that the latter is true. Let A be the disc whose boundary is σ ∪ Q. Then t (cid:54)∈ A,
but some vertex of P (cid:48) lies in A. Let R(cid:48) be the longest sub-path of P (cid:48) starting from s and terminating
at a vertex of C, such that R(cid:48) is internally disjoint from C. Then there is a vertex v(cid:48) ∈ V (Q(cid:48)), that
does not lie on R(cid:48). Let R(cid:48)(cid:48) be the sub-path of P (cid:48) from v(cid:48) to t. Then path R(cid:48)(cid:48) originates in disc A and
terminates outside A. But it can only leave A by traveling inside D◦(C), which is impossible from
Observation A.1.
We now re-route each path P ∈ P, as follows. Let u and v be the ﬁrst and the last vertex of P
that belong to C, respectively. Let ˜P be the union of the shadows of all bumps of P . Then ˜P is a
path, contained in C, that contains u and v. Let ˜P (cid:48) be a simple sub-path of ˜P connecting u to v,
and let P (cid:48) be obtained by concatenating the segment of P from s to u, ˜P (cid:48), and the segment of P
from v to t. Notice that path P (cid:48) is monotone with respect to C, and all paths in the resulting set
P(cid:48) = {P (cid:48) | P ∈ P} are internally node-disjoint by Observation A.2.

A.5 Proof of Theorem 2.5
We perform r iterations. At the beginning of the hth iteration, for 1 ≤ h ≤ r, we assume that we are
given a set Ph−1 of κ node-disjoint paths in H(cid:48), connecting the vertices of A to the vertices of B, so
that the paths in Ph−1 are internally disjoint from V (C)∪ V (Y ), and they are monotone with respect
to Z1, . . . , Zh−1. The output of iteration h is a set Ph of κ node-disjoint paths in H(cid:48), connecting the
vertices of A to the vertices of B, so that the paths in Ph are internally disjoint from V (C) ∪ V (Y ),

68

CQstexecuted as follows. Let H(cid:48)(cid:48) be the graph obtained by starting with H(cid:48)(cid:48) = ((cid:83)r

and they are monotone with respect to Z1, . . . , Zh. The output of the algorithm is the set Pr of paths
computed in the last iteration. For simplicity of notation, we denote Z0 = C, even though C is not a
cycle of H.
We start with P0 = P. It is immediate to see that this is a valid input to iteration 1. Assume now
that we are given a set Ph−1 of paths, which is a valid input to iteration h. The iteration is then
h=0 V (Zh)) ∪ Ph−1,
and then contracting all vertices lying in D(Zh−1) into a source vertex s(cid:48), and all vertices of B into
a destination vertex t(cid:48). Since B ⊆ V (Y ), where Y is a connected sub-graph of G, Y ∩ D(Zr) = ∅,
and the paths in Ph−1 are internally disjoint from V (Y ), graph H(cid:48)(cid:48) is a planar graph. Moreover,
Zh = min-cycle(H(cid:48)(cid:48), s(cid:48)) from the deﬁnition of tight concentric cycles. We consider the drawing of H(cid:48)(cid:48)
in the plane where t(cid:48) is incident on the outer face. It is easy to see that Zh = min-cycle(H(cid:48)(cid:48), s(cid:48)) still
holds with respect to this new drawing of H(cid:48)(cid:48).
From Lemma 2.4, there is a set Q of κ internally node-disjoint paths in H(cid:48)(cid:48), connecting s(cid:48) to t(cid:48), that
are monotone with respect to Zh. In order to construct the set Ph of paths, let P ∈ Ph−1 be any path,
and let vP be the last vertex of P lying on Zh−1. Let P (cid:48) be the sub-path of P starting from vP and
terminating at the endpoint of P lying in B. Notice that from the monotonicity of the paths in Ph−1
with respect to Z1, . . . , Zh−1, there are exactly κ edges leaving the vertex s(cid:48) in H(cid:48)(cid:48), each edge lying on
a distinct path P ∈ Ph−1. If edge e is leaving s(cid:48) in H(cid:48)(cid:48), and e lies on P , then it is incident on vP , and
so exactly one path of Q originates at vP . We denote this path by QP . For each path P ∈ Ph−1, we
let P ∗ be the path obtained from P by replacing P (cid:48) with QP . Notice that, since the paths in Ph−1
are internally disjoint from B, exactly κ edges are incident on t(cid:48) in graph H(cid:48), each of which is incident
on a distinct vertex of B in H. It is now easy to verify that the set Ph contains κ node-disjoint paths,
connecting the vertices of A to the vertices of B, and the paths in Ph are internally disjoint from
V (C)∪ V (Y ) and monotone with respect to Z1, . . . , Zh. We return Pr as the output of the algorithm.

B Proofs Omitted from Section 3

B.1 Proof of Theorem 3.1

The following deﬁnition and observation allow us to slightly relax the problem.
Deﬁnition B.1 Let c ≥ 1 be an integer, and let M(cid:48) ⊆ M be a subset of the demand pairs. Given a
constraint K = (i, a, b, w) of type 1 or 2, we say that M(cid:48) violates K by a factor of at most c, iﬀ the
number of the demand pairs (s, t) ∈ M(cid:48) with either s or t lying in (a, b) is at most cw. Likewise, given
a constraint K = (i, a, b, w) of type 3 or 4, we say that M(cid:48) violates K by a factor of at most c iﬀ the
number of the demand pairs in M(cid:48) crossing K is at most cw.
Observation B.1 There is an eﬃcient algorithm, that, given a DPSP instance (σ, σ(cid:48),M,K) and a
non-crossing set M(cid:48) ⊆ M of demand pairs that violates every constraint in K by a factor of at most
c, for any integer c > 1, computes a subset M(cid:48)(cid:48) ⊆ M(cid:48) of at least |M(cid:48)|/c demand pairs, satisfying all
constraints in K.

Proof: Assume that M(cid:48) = {(sj1, tj1), . . . , (sjz , tjz )}, where sj1 ≺ ··· ≺ sjz and tj1 ≺ ··· ≺ tjz . Let
M(cid:48)(cid:48) = {(sj(cid:96), tj(cid:96)) | 1 ≤ (cid:96) ≤ z and (cid:96) ≡ 1 mod c}. Clearly, M(cid:48)(cid:48) ⊆ M(cid:48) and |M(cid:48)(cid:48)| ≥ |M(cid:48)|/c. We now
claim that all constraints in K are satisﬁed by M(cid:48)(cid:48).
Indeed, consider any constraint K = (i, a, b, w) ∈ K. Assume ﬁrst that K is a type-1 constraint. Then
at most cw demand pairs in M(cid:48) have a source vertex in the interval (a, b). It is easy to see that the

69

number of the demand pairs of M(cid:48)(cid:48) that have a source vertex in the interval (a, b) is at most w. If
K is a type-2 constraint, the argument is similar. Assume now that K is a type-3 constraint (the
case where it is a type-4 constraint is symmetric). Let MK ⊆ M(cid:48) be the set of all demand pairs of
M(cid:48) crossing K. The key observation is that the demand pairs of MK appear consecutively in the
ordered set M(cid:48). Since |MK| ≤ cw, it is easy to see that |M(cid:48)(cid:48) ∩ MK| ≤ w, and so set M(cid:48)(cid:48) satisﬁes the
constraint K.
Let r = (cid:100)log |M|(cid:101), and for 1 ≤ j ≤ r + 1, set Wj = 2j. We partition the constraints of K into r levels,
where for 1 ≤ j ≤ r, the jth level contains all constraints (i, a, b, w) with Wj−1 ≤ w < 2 · Wj−1 = Wj.
For all 1 ≤ i ≤ 4 and 1 ≤ j ≤ r, we denote by S (i)
the set of all type-i constraints that belong to level

j

j. Let Sj =(cid:83)4

i=1 S (i)

j be the set of all level-j constraints.

Our algorithm employs dynamic programming. It is convenient to view the algorithm as constructing
r dynamic programming tables - one for each level. Consider some level 1 ≤ j ≤ r. Let I = (x, y) ⊆ σ,
I(cid:48) = (x(cid:48), y(cid:48)) ⊆ σ(cid:48) be a pair of intervals. We say that it is a good level-j pair if the following conditions
hold for every level-j constraint K = (i, a, b, w) ∈ Sj:

C1. if K is a type-1 constraint, then I is not contained in (a, b);
C2. if K is a type-2 constraint, then I(cid:48) is not contained in (a, b);
C3. if K is a type-3 constraint, then either I is not contained in La, or I(cid:48) is not contained in Rb; and
C4. if K is a type-4 constraint, then either I is not contained in Ra, or I(cid:48) is not contained in Lb.

For each 1 ≤ j ≤ r, let Pj denote the set of all good level-j pairs of intervals. The level-j dynamic
programming table, Πj contains an entry Πj[I, I(cid:48)] for every good level-j pair (I, I(cid:48)) ∈ Pj of intervals.
The entry will either remain empty, or it will contain a collection of non-crossing demand pairs from
M of cardinality exactly Wj, whose sources lie in I and destinations lie in I(cid:48).
We now describe an eﬃcient algorithm that computes the entries of the dynamic programming tables.
We start with j = 1. For every pair (I, I(cid:48)) ∈ P1 of good level-1 intervals, if there are two distinct
non-crossing demand pairs (s, t), (s(cid:48), t(cid:48)) ∈ M with s, s(cid:48) ∈ I and t, t(cid:48) ∈ I(cid:48), then we set Π1[I, I(cid:48)] =
{(s, t), (s(cid:48), t(cid:48))}. Otherwise, we set Π1[I, I(cid:48)] = ∅.
Assume now that we have constructed the tables for levels 1, . . . , j − 1, and consider the level-j table,
for some 1 < j ≤ r, and its entry Πj(I, I(cid:48)) for some good level-j pair (I, I(cid:48)) ∈ Pj of intervals, where
If there exist two pairs of vertices u, v ∈ I and u(cid:48), v(cid:48) ∈ I(cid:48) such that
I = (x, y) and I(cid:48) = (x(cid:48), y(cid:48)).
u ≺ v, u(cid:48) ≺ v(cid:48), and both Πj−1[(x, u), (x(cid:48), u(cid:48))] and Πj−1[(v, y), (v(cid:48), y(cid:48))] are non-empty, then we set
Πj[I, I(cid:48)] = Πj−1[(x, u), (x(cid:48), u(cid:48))] ∪ Πj−1[(v, y), (v(cid:48), y(cid:48))]. Otherwise, we set Πj[I, I(cid:48)] = ∅. This completes
the description of the algorithm that computes the entries of the dynamic programming tables. We
now proceed to analyze it, starting with the following easy observations.
Observation B.2 For all 1 ≤ j ≤ r and (I, I(cid:48)) ∈ Pj, either |Πj[I, I(cid:48)]| = 0 or |Πj[I, I(cid:48)]| = Wj.

Proof: The proof is by induction on j. Clearly, the claim holds for j = 1 and all (I, I(cid:48)) ∈ P1
by our construction. Consider now some j > 1, and assume that the claim holds for all values
j(cid:48) < j. Consider some entry Πj(I, I(cid:48)) of the level-j dynamic programming table. Our algorithm either
sets Πj[I, I(cid:48)] = ∅ or Πj[I, I(cid:48)] = Πj−1[(x, u), (x(cid:48), u(cid:48))] ∪ Πj−1[(v, y), (v(cid:48), y(cid:48))]. The latter only happens
when both Πj−1[(x, u), (x(cid:48), u(cid:48))], Πj−1[(v, y), (v(cid:48), y(cid:48))] are non-empty, and so by the induction hypothesis,
|Πj−1[(x, u), (x(cid:48), u(cid:48))]|,|Πj−1[(v, y), (v(cid:48), y(cid:48))]| = Wj−1, giving us |Πj[I, I(cid:48)]| = 2 · Wj−1 = Wj.

70

Observation B.3 For all 1 ≤ j ≤ r and (I, I(cid:48)) ∈ Pj, Πj[I, I(cid:48)] is a non-crossing subset of the demand
pairs in M, where every (s, t) ∈ Tj[I, I(cid:48)] has s ∈ I and t ∈ I(cid:48).

Proof: The proof is again by induction on j. Clearly, the claim holds for j = 1 and all (I, I(cid:48)) ∈ P1
from our construction. Consider now some level j > 1 and assume that the claim holds for levels
1, . . . , (j − 1). Let (I, I(cid:48)) ∈ Pj be a good level-j pair of intervals, with I = (x, y) and I(cid:48) = (x(cid:48), y(cid:48)).
The claim trivially holds when Πj[I, I(cid:48)] = ∅, so we assume that Πj[I, I(cid:48)] = Πj−1[(x, u), (x(cid:48), u(cid:48))] ∪
Πj−1[(v, y), (v(cid:48), y(cid:48))], where x (cid:22) u ≺ v (cid:22) y and x(cid:48) (cid:22) u(cid:48) ≺ v(cid:48) (cid:22) y(cid:48). From the induction hypothesis,
no two demand pairs from Πj−1[(x, u), (x(cid:48), u(cid:48))] can cross, and the same holds for the demand pairs of
Πj−1[(v, y), (v(cid:48), y(cid:48))]. Since every demand pair (s, t) ∈ Πj−1[(x, u), (x(cid:48), u(cid:48))] has s ∈ (x, u), t ∈ (x(cid:48), u(cid:48)),
and every demand pair (s(cid:48), t(cid:48)) ∈ Πj−1[(v, y), (v(cid:48), y(cid:48))] has s(cid:48) ∈ (v, y), t(cid:48) ∈ (v(cid:48), y(cid:48)), it is immediate to
verify that no pair of demands (s, t) ∈ Πj−1[(x, u), (x(cid:48), u(cid:48))] and (s(cid:48), t(cid:48)) ∈ Πj−1[(v, y), (v(cid:48), y(cid:48))] can cross,
and for every demand pair (s, t) ∈ Tj[I, I(cid:48)], s ∈ I and t ∈ I(cid:48) holds.
Observation B.4 For all 1 ≤ j ≤ r and (I, I(cid:48)) ∈ Pj, the set Πj[I, I(cid:48)] of demand pairs violates every
constraint in K by at most factor 4.

2], and Πj(cid:48)[I3, I(cid:48)

Proof: Fix some 1 ≤ j ≤ r and (I, I(cid:48)) ∈ Pj, and consider the corresponding table entry Πj[I, I(cid:48)].
The claim holds trivially when |Πj[I, I(cid:48)]| = 0, so we assume that |Πj[I, I(cid:48)]| = Wj. Consider some
j(cid:48) , for some level 1 ≤ j(cid:48) ≤ r. if j(cid:48) ≥ j, then w ≥ Wj−1 must hold, while
constraint K = (i, a, b, w) ∈ S (i)
|Πj[I, I(cid:48)]| = Wj, so the constraint is violated by the factor of at most 4.
Consider now the case where j(cid:48) < j. Assume ﬁrst that i = 1. Note that Πj[I, I(cid:48)] is the union of exactly
2j−j(cid:48)
non-empty level-j(cid:48) table entries, each of which contains a set of demand pairs of cardinality
exactly Wj(cid:48). Let R be the set of all these level-j(cid:48) table entries. We claim that there are at most two
table entries Πj(cid:48)( ˆI, ˆI(cid:48)) ∈ R with ˆI ∩ (a, b) (cid:54)= ∅. Indeed, assume for contradiction that there are 3 such
distinct entries in R, say Πj(cid:48)[I1, I(cid:48)
3], with I1 ∩ (a, b), I2 ∩ (a, b), I3 ∩ (a, b) (cid:54)= ∅.
Then at least one of the intervals I1, I2, I3 must be contained in (a, b), violating our condition for
good level-j(cid:48) pairs of intervals. We conclude that the number of the demand pairs in Πj[I, I(cid:48)] with a
source vertex in (a, b) is bounded by 2 · Wj(cid:48) = 4 · Wj(cid:48)−1 ≤ 4 · w. The proof for the case where i = 2 is
analogous.
Assume now that K is a type-3 constraint. As before, Πj[I, I(cid:48)] is the union of exactly 2j−j(cid:48)
non-empty
level-j(cid:48) table entries, each of which stores a set of demand pairs of cardinality exactly Wj(cid:48). Let R
be the set of these level-j(cid:48) table entries. We claim that there are at most two entries Πj(cid:48)( ˆI, ˆI(cid:48)) ∈ R,
with ˆI ∩ La (cid:54)= ∅ and ˆI(cid:48) ∩ Rb (cid:54)= ∅. Indeed, assume otherwise, and let Πj(cid:48)[I1, I(cid:48)
1], Πj(cid:48)[I2, I(cid:48)
3] be
three distinct entries in R, such that for each 1 ≤ (cid:96) ≤ 3, I(cid:96) ∩ La (cid:54)= ∅ and I(cid:48)
(cid:96) ∩ Rb (cid:54)= ∅. Assume that
I1, I2, I3 appear on σ in this order, and recall that from our construction they are disjoint. Then it is
easy to see that I2 ⊆ La and I(cid:48)
2 ⊆ Rb must hold, contradicting our deﬁnition of good level-j(cid:48) pairs of
terminals. Therefore, there are at most two entries Πj(cid:48)( ˆI, ˆI(cid:48)) ∈ R, with ˆI ∩ La (cid:54)= ∅ and ˆI(cid:48) ∩ Rb (cid:54)= ∅.
Demand pairs participating in solutions corresponding to other entries in R cannot cross K, and so
the number of the demand paris crossing K is at most 2 · Wj(cid:48) = 4 · Wj(cid:48)−1 ≤ 4 · w. The case where K
is a type-4 constraint is treated similarly.

1], Πj(cid:48)[I2, I(cid:48)

2], Πj(cid:48)[I3, I(cid:48)

From the discussion so far, every entry of every dynamic programming table contains a non-crossing
set of demand pairs, that violates every constraint of K by at most factor 4. Let ˜M be the largest-
cardinality set of demand pairs stored in any entry any of the tables, and let OPT be the value of the
optimal solution to the DPSP problem instance. The following theorem is central to our analysis.
Theorem B.5 If OPT ≥ 2, then | ˜M| ≥ OPT/2.

71

We can now apply Observation B.1 to compute a subset ˜M(cid:48) ⊆ ˜M of at least | ˜M|/4 ≥ OPT/8 non-
crossing demand pairs satisfying all constraints in K (if | ˜M| = 0, then OPT ≤ 1 must hold, and ﬁnding
an optimal solution is trivial). In order to complete the proof of Theorem 3.1, it now remains to prove
Theorem B.5.
Proof of Theorem B.5. Denote κ = OPT, and let M∗ = {(s1, t1), . . . , (sκ, tκ)} be the optimal
solution to the DPSP instance, where s1 ≺ . . . ≺ sκ and t1 ≺ . . . ≺ tκ. Let r(cid:48) be the largest value for
which κ/Wr(cid:48) ≥ 1 (this is well-deﬁned since we have assumed that OPT ≥ 2). Let M∗∗ ⊆ M∗ contain
the ﬁrst Wr(cid:48) demand pairs of M∗, so |M∗∗| ≥ |M∗|/2. We will show that some entry of the level-r(cid:48)
dynamic programming table stores a solution whose cardinality is at least Wr(cid:48).
For every level 1 ≤ j ≤ r(cid:48), we deﬁne a partition Sj of M∗∗ into 2r(cid:48)−j subsets, each containing exactly
Wj consecutive demand pairs from M∗∗. For every set S ∈ Sj of the partition, we deﬁne a pair
(I(S), I(cid:48)(S)) of intervals, with I(S) ⊆ σ and I(cid:48)(S) ⊆ σ(cid:48), as follows. Let (s, t), (s(cid:48), t(cid:48)) be the ﬁrst and
the last demand pairs of S, respectively (this is well-deﬁned since the demand pairs are non-crossing).
Then I(S) = (s, s(cid:48)) and I(cid:48)(S) = (t, t(cid:48)). We denote by Qj the resulting collection of 2r(cid:48)−j pairs of
2 = ∅. We need the
intervals. Note that for every pair (I1, I(cid:48)
following claim.
Claim B.6 For every 1 ≤ j ≤ r(cid:48), every pair (I, I(cid:48)) ∈ Qj of intervals is a good level-j pair.

2) ∈ Qj, I1 ∩ I2 = ∅ and I(cid:48)

1), (I2, I(cid:48)

1 ∩ I(cid:48)

Proof: Fix some 1 ≤ j ≤ r(cid:48) and some pair (I, I(cid:48)) ∈ Qj of intervals. From our deﬁnition of the pairs
of intervals in Qj, there are exactly Wj demand pairs (s, t) in M∗ with s ∈ I and t ∈ I(cid:48). Consider any
level-j constraint K = (i, a, b, w) ∈ Sj, and recall that Wj−1 ≤ w < Wj must hold.
Assume ﬁrst that K is a type-1 constraint. Then I cannot be contained in (a, b), since then M∗
would have Wj > w demand pairs whose sources lie in I, and hence in (a, b). The analysis for type-2
constraints is similar.
Assume now that K is a type-3 constraint, and assume for contradiction that I ⊆ La and I(cid:48) ⊆ Rb.
Then M∗ has Wj > w demand pairs (s, t) with s ∈ I and t ∈ I(cid:48), each of which crosses the constraint
K, a contradiction. The case where K is a type-4 constraint is proved similarly.
From the above claim, for all 1 ≤ j ≤ r(cid:48) and (I, I(cid:48)) ∈ Qj, there is an entry Πj[I, I(cid:48)] in the level-j
dynamic programming table. It is now enough to show that each such entry contains a solution of
cardinality Wj.
Claim B.7 For each 1 ≤ j ≤ r(cid:48), for every pair (I(S), I(cid:48)(S)) ∈ Qj of intervals, entry Πj[I(S), I(cid:48)(S)]
contains a solution of value Wj.

Proof: The proof is by induction on j. The claim clearly holds for j = 1, since there are two distinct
non-crossing demand pairs (s, t), (s(cid:48), t(cid:48)) with s, s(cid:48) ∈ I(S), t, t(cid:48) ∈ I(cid:48)(S) - the two demand pair lying in
S. Assume now that the claim holds for levels 1, . . . , j − 1, for some 1 < j ≤ r(cid:48), and we would like to
prove it for j.
Our deﬁnition of the partitions S(cid:96) of M∗∗ ensures that there are exactly two distinct sets S1, S2 ∈ Sj−1,
with S1, S2 ⊆ S (and in fact S1 ∪ S2 = S). From the induction hypothesis, the entries of Πj−1
corresponding to pairs (I(S1), I(cid:48)(S1)) and (I(S2), I(cid:48)(S2)) each contain Wj−1 demand pairs, and so
Πj[I(S), I(cid:48)(S)] must contain Wj demand pairs.
Recall that Sr(cid:48) contains a single set of demand pairs - the set M∗∗. We conclude that the corresponding
entry of the level-r(cid:48) dynamic programming table contains Wr(cid:48) ≥ OPT/2 demand pairs.
(cid:3)

72

B.2 Approximation Algorithm for NDP-Disc

In this section we prove Theorem 1.1 for NDP-Disc. The proof builds on the work of Robertson and
Seymour [RS86], who gave a precise characterization of the instances NDP-Disc, where all demand
pairs can be routed simultaneously. Many of the deﬁnitions below are from [RS86]. Let Σ be a disc,
whose boundary is denoted by Γ, and let G be any graph drawn on Σ. Suppose we are given a set
M = {(s1, t1), . . . , (sk, tk)} of pairs of vertices of G, called demand pairs, and let T be the set of all
vertices participating in the demand pairs in M, that we refer to as terminals. We identify the graph
G with its drawing. A region of G is a connected component of Σ \ G. We say that the drawing of
G is semi-proper if no inner point on an image of an edge of G lies on Γ, and we say that it is proper
with respect to M, if additionally V (G) ∩ Γ = T .
Suppose we are given a planar graph G, together with a set M of demand pairs, such that G is drawn
properly (with respect to M) on Σ. Let W be a set of points on Γ, constructed as follows. First, we
add to W all points corresponding to the vertices of T . Next, for every segment β of Γ\T , we add one
arbitrary point p ∈ β to W . A vertex v of G is peripheral if v ∈ Γ, and a region of G is peripheral, if it
contains a segment of Γ \ T . Given two points x, y ∈ W , we denote by ∆M(x, y) the total number of
the demand pairs (s, t) ∈ M, where either {s, t} ∩ {x, y} (cid:54)= ∅, or s and t belong to diﬀerent segments
of Γ \ {x, y}. We need the following deﬁnition.
Deﬁnition B.2 Given G, M and W as above, for any x, y ∈ W , an (x, y)-chain is a sequence
A1, A2, . . . , Ar, such that:

• for all 1 ≤ i < r, one of Ai, Ai+1 is a vertex of G, the other is a region, and they are incident;
• if A1 is a vertex then A1 = x; if A1 is a region then x ∈ A1;
• similarly, if Ar is a vertex then Ar = y, and if Ar is a region then y ∈ Ar; and
• for all 1 ≤ i ≤ r, Ai is peripheral if and only if i = 1 or i = r.

The length of an (x, y)-chain is the number of its terms that are vertices. The redundancy of an
(x, y)-chain is its length minus ∆M(x, y).

The following theorem, proved by Roberston and Seymour [RS86] characterizes routable sets of demand
pairs for the NDP-Disc problem.

Theorem B.8 (Theorem 3.6 in [RS86]) Let G be a planar graph properly drawn on a disc Σ, with
respect to a set M of demand pairs, and let W be deﬁned as above. Then there is a set of node-disjoint
paths, routing all demand pairs in M if and only if: (i) M is a non-crossing set of demand pairs; and
(ii) for all x, y ∈ W , every (x, y)-chain has a non-negative redundancy. Moreover, there is an eﬃcient
algorithm to determine whether these conditions hold, and if so, to ﬁnd a routing of the demand pairs
in M.

Notice that if G is a graph drawn on a disc Σ, such that all terminals appear on the boundary Γ of the
disc, then, by slightly altering Γ, we can ensure that the drawing of G is proper with respect to M.
Therefore, we assume from now on that we are given a proper drawing ϕ of G on Σ with respect to
M. We prove Theorem 1.1 for NDP-Disc in three steps. In the ﬁrst step, we prove a stronger version
of the theorem for the case where G is connected and the set M of terminals is 1-split. In the second
step, we prove the theorem for the case where G is 2-connected, and we make no assumptions on the
demand pairs. In the third step we prove the theorem without any additional assumptions.

73

B.2.1 Special Case: G is Connected and M is 1-Split

In this section, we prove the following theorem.
Theorem B.9 There is an eﬃcient algorithm, that, given a connected planar graph G with a set M
of demand pairs, and a proper drawing of G on the disc Σ with respect to M, where M is 1-split with
respect to the disc boundary, computes a routing of OPT(G,M)/8 demand pairs of M via node-disjoint
paths in G.
Recall that if M is 1-split with respect to the boundary Γ of the disc Σ, then we can partition Γ into
two disjoint segments, σ and σ(cid:48), such that for every demand pair (s, t) ∈ M, one of the vertices s, t
lies on σ, and the other on σ(cid:48). We assume without loss of generality that all source vertices of the
demand pairs in M lie on σ, and all destination vertices lie on σ(cid:48). Let T be the set of all vertices
participating in the demand pairs in M, that we refer to as terminals. We denote by S and T the
sets of the source and the destination vertices of the demand pairs in M, respectively. As before, we
construct a set W of points: start with W = T ; then for every segment of Γ \ T , add one arbitrary
point of that segment to W .

The idea is to reduce this problem to the DPSP problem. We let ˜σ be a directed path, whose vertices
correspond to the points of W ∩ σ, ordered in their counter-clock-wise order on Γ. We let ˜σ(cid:48) be a
directed path, whose vertices correspond to the points of W ∩ σ(cid:48), ordered in their clock-wise order on
Γ. Therefore, all vertices of S lie on ˜σ, and all vertices of T lie on ˜σ(cid:48). Moreover, M(cid:48) is a non-crossing
set of demand pairs with respect to ˜σ and ˜σ(cid:48) iﬀ it is non-crossing with respect to Γ.
Suppose we are given any pair (x, y) of vertices of W . Let γ(x, y) denote the shortest G-normal curve
connecting x to y in the drawing of G on Σ, so that γ(x, y) is contained in the disc Σ. Curve γ(x, y)
can be found eﬃciently by considering the graph G(cid:48) dual to G, deleting the vertex corresponding to
the outer face of G from it, and computing shortest paths between appropriately chosen vertices of G(cid:48)
(that correspond to the faces of G incident on x and y). Let (cid:96)(x, y) be the length of γ(x, y). Notice
that, since G is connected, if ∆M(x, y) ≥ 1, then (cid:96)(x, y) ≥ 1. We now construct a collection K of
constraints of the DPSP probem, as follows.
For every pair x, y of vertices of W ∩ ˜σ, with ∆M(x, y) ≥ 1, we add a type-1 constraint (1, x, y, (cid:96)(x, y))
to K. Similarly, for every pair x, y of vertices of W ∩ ˜σ(cid:48), with ∆M(x, y) ≥ 1, we add a type-2 constraint
(2, x, y, (cid:96)(x, y)) to K. For every pair x ∈ W ∩ ˜σ, y ∈ W ∩ ˜σ(cid:48) of vertices, with ∆M(x, y) ≥ 1, we add
a type-3 constraint (3, x, y, (cid:96)(x, y)) and a type-4 constraint (4, x, y, (cid:96)(x, y)) to K. This ﬁnishes the
deﬁnition of the DPSP problem instance. The following observation is immediate.
Observation B.10 Let M(cid:48) ⊆ M be any set of demand pairs that can be routed via disjoint paths in
G. Then M(cid:48) is a valid solution to the DPSP problem instance.
We apply the 8-approximation algorithm for the DPSP problem, to obtain a set M(cid:48) of non-crossing
demand pairs (with respect to ˜σ and ˜σ(cid:48)) satisfying all constraints in K, with |M(cid:48)| ≥ |OPT(G,M)|/8.
As observed above, the pairs in M(cid:48) are non-crossing with respect to Γ. It now only remains to show
that all demand pairs in M(cid:48) can be routed in G. The algorithm from Theorem B.8 can then be used
to ﬁnd the routing. The following theorem will ﬁnish the proof of Theorem B.9.
Theorem B.11 Let M(cid:48) ⊆ M be a set of non-crossing demand pairs (with respect to ˜σ and ˜σ(cid:48)), that
satisfy all constraints in K. Then all demand pairs in M(cid:48) can be routed in G.
Proof: Let T (cid:48) = T (M(cid:48)), and let ϕ be the current proper drawing of G with respect to M. Notice
that ϕ is not necessarily a proper drawing of G with respect to M(cid:48), since the vertices of T \T (cid:48) may lie

74

1 and A(cid:48)

r, as follows.

1, A2, . . . , Ar−1, A(cid:48)

r = Ar, and we let y(cid:48) = A(cid:48)

1 = A1, and we let x(cid:48) = A(cid:48)

on Γ. We can obtain a proper drawing ϕ(cid:48) of G with respect to M(cid:48) by moving all such terminals inside
the disc, so they no longer lie on Γ. It is immediate to verify that the demand pairs in M(cid:48) remain
non-crossing with respect to Γ in the new drawing.
As before, we construct a set W (cid:48) of points of Γ, by ﬁrst adding all points corresponding to the terminals
of T (cid:48) to W (cid:48). Additionally, for every segment β of Γ\T (cid:48), we add an arbitrary point of β to W (cid:48). It now
remains to show that for every pair x, y of points in W (cid:48), for every (x, y)-chain in ϕ(cid:48), the redundancy
of the chain (with respect to M(cid:48)) is non-negative.
Assume otherwise. Let x, y ∈ W (cid:48) be any pair of points, and let A = (A1, . . . , Ar) be an x-y chain in
the drawing ϕ(cid:48), such that the redundancy of A is negative. We modify the chain A, by replacing A1
and Ar with elements A(cid:48)
If A1 is a vertex of T (cid:48), then we let A(cid:48)
1. Otherwise, A1 is a region of G
in the drawing ϕ(cid:48). Let v = A2, so v ∈ V (G). Then v must lie on a boundary of some peripheral
region R of G in the drawing ϕ. Let A(cid:48)
1 = R, let β(R) be the segment of Γ that serves as part of
the boundary of the region R, and let x(cid:48) ∈ W be the point lying on the interior of β(R). Similarly,
if Ar is a vertex of T (cid:48), then we let A(cid:48)
r. Otherwise, Ar is a region of G in
the drawing ϕ(cid:48). Let v(cid:48) = Ar−1, so v(cid:48) ∈ V (G). Then v(cid:48) must lie on a boundary of some peripheral
region R(cid:48) of G of the drawing ϕ. Let A(cid:48)
r = R(cid:48), let β(R(cid:48)) be the segment of Γ that serves as part of
the boundary of the region R(cid:48), and let y(cid:48) ∈ W be the point lying on the interior of β(R). We then
obtain a sequence A(cid:48) = (A(cid:48)
r) (it may not be a valid chain for the drawing ϕ, since
some of the elements Ai, for 1 < i < r(cid:48), may be peripheral with respect to ϕ). We can then construct
a G-normal curve γ(cid:48) in the original drawing ϕ of G, connecting x(cid:48) to y(cid:48), such that γ(cid:48) ∩ V (G) only
contains the vertices that participate in A(cid:48), and γ(cid:48) is contained in Σ. Let (cid:96) denote the length of the
chain A, and let ∆ = |∆M(cid:48)(x, y)|. We can assume that ∆ ≥ 1, since otherwise it is immediate to
verify that ∆ ≤ (cid:96). Then (cid:96)(x(cid:48), y(cid:48)) ≤ (cid:96), from the deﬁnition of (cid:96)(x(cid:48), y(cid:48)). Notice that one of the segments
of Γ \ {x, x(cid:48)} contains no terminals of T (cid:48), and the same holds for one of the segments of Γ \ {y, y(cid:48)}.
We now consider three cases.
Assume ﬁrst that both x(cid:48) and y(cid:48) lie on ˜σ. Then pair (s, t) ∈ ∆M(cid:48)(x, y) iﬀ s belongs to the sub-path
(x(cid:48), y(cid:48)) of ˜σ. Since we assumed that ∆ ≥ 1, we get that ∆M(x(cid:48), y(cid:48)) ≥ 1, so constraint (1, x(cid:48), y(cid:48), (cid:96)(x(cid:48), y(cid:48)))
belongs to K, and we get that ∆ ≤ (cid:96)(x(cid:48), y(cid:48)) ≤ (cid:96), a contradiction.
The case where x(cid:48), y(cid:48) ∈ ˜σ(cid:48) is dealt with similarly.
Assume now that x(cid:48) ∈ ˜σ and y(cid:48) ∈ ˜σ(cid:48). As before, since we assumed that ∆ ≥ 1, we get that ∆M(x(cid:48), y(cid:48)) ≥
1. Consider the two corresponding type-3 and type-4 constraints K = (3, x(cid:48), y(cid:48), (cid:96)(x(cid:48), y(cid:48))), K(cid:48)(cid:48) =
(4, x(cid:48), y(cid:48), (cid:96)(x(cid:48), y(cid:48))) ∈ K. Let Lx(cid:48), Rx(cid:48) be the segments of ˜σ from its ﬁrst endpoint to x(cid:48), and from
x(cid:48) to its last endpoint, respectively, where both segments include x(cid:48). Deﬁne segments Ly(cid:48), Ry(cid:48) of ˜σ(cid:48)
similarly. Recall that a demand pair (s, t) crosses K iﬀ s ∈ Lx(cid:48) and t ∈ Ry(cid:48), and it crosses K(cid:48) iﬀ s ∈ Rx(cid:48)
and t ∈ Ly(cid:48). Let M1 ⊆ M(cid:48) be the set of the demand pairs crossing K, and let M2 ⊆ M(cid:48) be the set of
the demand pairs crossing K(cid:48). Since M(cid:48) is a non-crossing set of demand pairs, it is easy to verify that
either M1 \ {(x(cid:48), y(cid:48))} = ∅, or M2 \ {(x(cid:48), y(cid:48))} = ∅. We assume without loss of generality that it is the
latter. Notice that if (x(cid:48), y(cid:48)) ∈ M(cid:48), then it belongs to both M1 and M2. Constraint (3, x(cid:48), y(cid:48), (cid:96)(x(cid:48), y(cid:48)))
then ensures that |M1 ∪ M2| ≤ |M1| ≤ (cid:96)(x(cid:48), y(cid:48)) ≤ (cid:96). It is easy to verify that ∆M(cid:48)(x, y) ⊆ M1 ∪ M2,
and so ∆ ≤ (cid:96), a contradiction.

B.2.2 Special Case: G is 2-connected

The goal of this section is to prove the following theorem.

75

Theorem B.12 There is an eﬃcient algorithm, that, given any 2-connected planar graph G, and a
set M of k demand pairs for G, such that G is properly drawn on a disc with respect to M, returns
an O(log k)-approximate solution to problem (G,M).

j ⊆ M(cid:48)

j ⊆ Mj of demand pairs, with |M(cid:48)

j contain any demand pair from M(cid:48)

Ω(OPT(G,Mj)). Since(cid:80)r

j of demand pairs, as follows. If |M(cid:48)
1, tj

j. Otherwise, we assume that M(cid:48)

j=1 OPT(G,Mj) ≥ OPT(G,M), we get that(cid:80)r

j=1 |M(cid:48)
(cid:16)
j| ≥ (cid:80)r
Ω(OPT(G,M)). It is now enough to prove that all demand pairs in M(cid:48)(cid:48) =(cid:83)r

Proof: Let |M| = k, and let z = 4(cid:100)log k(cid:101). We use Lemma 2.3 to compute a partition M1, . . . ,Mz
of M into z disjoint subsets, so that for each 1 ≤ i ≤ z, Mi is ri-split for some integer ri. We prove
the following lemma.
Lemma B.13 There is an eﬃcient algorithm, that, given an index 1 ≤ i ≤ z, computes a solution to
instance (G,Mi) routing Ω(OPT(G,Mi)) demand pairs.
Theorem B.12 then easily follows from Lemma B.13, since there is some index 1 ≤ i ≤ z, for which
OPT(G,Mi) = Ω(OPT(G,M)/ log k). In the rest of this section, we focus on proving Lemma B.13.
For simplicity, we denote Mi by M and ri by r. We assume that we are given a partition {M1, . . . ,Mr}
of M, and a collection σ1, . . . , σ2r of disjoint segments of Γ, such that for all 1 ≤ j ≤ r, for every
demand pair (s, t) ∈ Mj, s ∈ σ2j−1 and t ∈ σ2j.
Clearly, for each 1 ≤ j ≤ r, set Mj is 1-split. Therefore, we can use the algorithm from Section B.2.1 in
order to compute a set Pj of disjoint paths, routing a subset M(cid:48)
j| ≥
j| ≥ Ω(OPT(G,M)).
(cid:17)
j| ≤ 3, then we
For every 1 ≤ j ≤ r, we compute a subset M(cid:48)(cid:48)
let M(cid:48)(cid:48)
,
qj )
where the vertices sj
qj appear in this counter-clock-wise order on σ2j−1. We then add to
j|) ≥
j=1 Ω(|M(cid:48)
M(cid:48)(cid:48)
j can be routed
in G. It is easy to verify that the demand pairs in M(cid:48)(cid:48) are non-crossing, since for each 1 ≤ j ≤ r,
j are non-crossing, and pairs that belong to diﬀerent sets Mj cannot cross.
the demand pairs in M(cid:48)
Let T (cid:48)(cid:48) = T (M(cid:48)(cid:48)), and let ϕ(cid:48)(cid:48) is a proper drawing of G in Σ with respect to M(cid:48)(cid:48), obtained from the
original drawing ϕ by moving all terminals of T \ T (cid:48)(cid:48) to the interior of the disc. We deﬁne a set W of
points on Γ as before: it contains all terminals of T (cid:48)(cid:48), and for every segment of Γ \ T (cid:48)(cid:48), W contains an
arbitrary point in the interior of the segment.
Let (x, y) ∈ W be any pair of points, and let A = (A1, A2, . . . , Ap) be any (x, y)-chain. Let (cid:96) denote
the length of A. It is now enough to prove that |∆M(cid:48)(cid:48)(x, y)| ≤ (cid:96). Assume ﬁrst that for some 1 ≤ j ≤ z,
x, y ∈ σ2j−1 ∪ σ2j. Then ∆M(cid:48)(cid:48)(x, y) only contains demand pairs from M(cid:48)(cid:48)
j . Since all demand pairs in
M(cid:48)(cid:48)
Assume now that x ∈ σ2j−1 ∪ σ2j and y ∈ σ2j(cid:48)−1 ∪ σ2j(cid:48) for some j (cid:54)= j(cid:48). Then ∆M(cid:48)(cid:48)(x, y) only
contains demand pairs from M(cid:48)(cid:48)
j(cid:48). Let
N (cid:48)
1 = ∆M(cid:48)(x, y) ∩ M(cid:48)
j(cid:48) can be routed in
G via node-disjoint paths, |N (cid:48)
j(cid:48) of demand pairs,
2|/2, 1}. Since graph G is 2-vertex connected, we can
|N1| ≤ max{|N (cid:48)
assume that either |∆M(cid:48)(cid:48)(x, y)| ≤ 1, or (cid:96) ≥ 2. In the former case, (cid:96) ≥ |∆M(cid:48)(cid:48)(x, y)| since the graph is
connected. In the latter case, we are now guaranteed that |∆M(cid:48)(cid:48)(x, y)| = |N (cid:48)

a), where a = 1 modulo 3. Notice that (cid:80)r

2 = ∆M(cid:48)(x, y) ∩ M(cid:48)
2| ≤ (cid:96). From our selection of the sets M(cid:48)(cid:48)

j(cid:48). Since both M(cid:48)

j and M(cid:48)
j , M(cid:48)(cid:48)

j can be routed in G via node-disjoint paths, |∆M(cid:48)(cid:48)(x, y)| ≤ (cid:96).

j(cid:48). Let N1 = ∆M(cid:48)(cid:48)(x, y) ∩ M(cid:48)(cid:48)

j and N2 = ∆M(cid:48)(cid:48)(x, y) ∩ M(cid:48)(cid:48)

1, sj
j all demand pairs (sj

2, . . . , sj
a, tj

j ∪ M(cid:48)(cid:48)
j, and let N (cid:48)
1|,|N (cid:48)

j =

(sj

1), . . . , (sj

qj , tj

j=1 |M(cid:48)(cid:48)

j=1 M(cid:48)(cid:48)

1|/2, 1}, and |N2| ≤ max{|N (cid:48)

1| + |N (cid:48)

2| ≤ (cid:96).

B.2.3 The General Case

In this section, we complete the proof of Theorem 1.1 for NDP-Disc. We assume that the input graph
G is connected, since otherwise we can solve the problem separately on each connected component of

76

G.

We use a block-decomposition of G. Recall that a block of G is a maximal 2-node-connected component
of G. A block-decomposition of G is a tree τ , whose vertex set consists of two subsets, V (τ ) = V1 ∪ V2,
where V1 is the set of all cut-vertices of G, and V2 contains a vertex vB for every block B of G. There
is an edge between a vertex u ∈ V1 and vB ∈ V2 iﬀ u ∈ vB. We choose an arbitrary vertex r ∈ V1 as
the root of τ . We assume that the value of the optimal solution is at least 10, as otherwise we can
route a single demand pair. We then discard from M all demand pairs in which r participates – this
changes the value of the optimal solution by at most 1.

Over the course of the algorithm, we will gradually change the tree τ , by deleting vertices from it.
Given any vertex u in the current tree τ , we let τu denote the subtree of τ rooted at u, and we let Gu
be the subgraph of G induced by the union of all blocks B with vB ∈ V (τu). For every block B, we
denote by p(B) the unique vertex of B that serves as the parent of the vertex vB in τ . As the tree τ
changes, so do the trees τu and the graphs Gu.

B ⊆ M of demand pairs, so that eventually, {MB,M(cid:48)

If any block B of G contains all the terminals, then we can apply the algorithm from Theorem B.12 to
instance (B,M) of NDP-Disc to obtain an O(log k)-approximate solution. Otherwise, for every block
B, if we denote by Γ(B) the set of all cut vertices of G that belong to B, and by T (B) the set of all
terminals lying in B, then we can draw B inside a disc, so that the vertices of Γ(B) ∪ T (B) lie on its
boundary.
We gradually construct a solution P to the NDP-Disc instance (G,M), starting from P = ∅. Through-
out the algorithm, we ensure that all paths in P are disjoint from the vertices of Gr, where r is the
root vertex of τ , and Gr is computed with respect to the current tree τ . Clearly, the invariant holds
at the beginning of the algorithm.
We maintain a collection B of blocks, that is initialized to B = ∅. For every block B ∈ B, we will deﬁne
two subsets, MB,M(cid:48)
B | B ∈ B} is a partition of
M.
In every iteration, we consider all vertices vB ∈ V2 that belong to the current tree τ , such that
GvB \ p(B) contains at least one demand pair (s, t) ∈ M. Among all such vertices, we choose one that
is furthest from the root of the tree, breaking ties arbitrarily. Let vB be the selected vertex. We add
B to B, and we deﬁne two new subsets of demand pairs MB,M(cid:48)
B, as follows. Set MB contains all
demand pairs (s, t) with s, t ∈ GvB \ p(B). Set M(cid:48)
B contains all demand pairs (s, t) with exactly one of
s, t lying in GvB \ p(B), while the other terminal must belong to Gr. Notice that any path connecting
any demand pair in M(cid:48)
Next, we construct a new instance of the NDP-Disc problem, on the graph B. The corresponding set
of demand pairs, that we denote by NB, is deﬁned as follows. Consider any demand pair (s, t) ∈ MB.
We deﬁne a new demand pair (s(cid:48), t(cid:48)) representing (s, t), with s(cid:48), t(cid:48) ∈ V (B), and deﬁne two paths: Q(s)
connecting s to s(cid:48), and Q(t) connecting t to t(cid:48). If s ∈ V (B), then we let s(cid:48) = s, and Q(s) = {s}.
Otherwise, we let s(cid:48) ∈ V1 be the unique child of the vertex vB in τ , such that s ∈ Gs(cid:48). Notice that s(cid:48)
must be a vertex of B. We then let Q(s) be any simple path connecting s to s(cid:48) in graph Gs(cid:48). We deﬁne
the vertex t(cid:48) ∈ B, and a path Q(t) connecting t to t(cid:48) similarly. Notice that it is possible that s(cid:48) = t(cid:48).
Let NB = {(s(cid:48), t(cid:48)) | (s, t) ∈ MB} be the resulting set of demand pairs. All vertices participating in the
demand pairs in NB belong to B. Consider the NDP instance (B,N ). It is immediate to verify that
we can draw B in a disc, so that all vertices participating in the demand pairs in M(B) lie on the
boundary of the disc, and clearly B is 2-connected. We need the following immediate observation.
Observation B.14 OPT(B,NB) ≥ OPT(G,MB).

B must use the vertex p(B).

77

Proof: Let ˜P be the optimal solution to instance OPT(G,MB). We can assume that all paths in ˜P
are simple. Let P ∈ ˜P be any such path, and assume that P connects some demand pair (s, t) ∈ MB.
Then it is easy to see that s(cid:48), t(cid:48) ∈ P , and moreover, the segment of P between s(cid:48) and t(cid:48) is contained
in B. By appropriately truncating every path in ˜P, we can obtain a solution to instance (B,NB) of
the NDP problem of the same value.

Since B is 2-vertex connected, and can be drawn in a disc with all vertices participating in the
demand pairs in NB lying on the disc boundary, we can apply the algorithm from Theorem B.12
to instance (B,NB), to compute a set P(B) of node-disjoint paths, routing a subset of at least
Ω(OPT(B,NB)/ log k) demand pairs of MB in B. We can assume that |P(B)| ≥ 1, since otherwise
we can route any demand pair in NB. We would like to ensure that all paths in P(B) avoid the
vertex p(B). If |P(B)| = 1, then, since B is 2-vertex connected, we can re-route the unique path in
P(B) inside B, so that its endpoints remain the same, but it avoids the vertex p(B) (since GvB \ p(B)
contains at least one demand pair, we can ensure that the endpoints of the path are distinct from p(B)).
Otherwise, we discard from P(B) the path that uses vertex p(B), if such exists. By concatenating the
paths in P(B) with the paths in {Q(s), Q(t) | (s, t) ∈ M(B)}, we obtain a collection P(cid:48)(B) of at least
Ω(OPT(B,N )/ log k) node-disjoint paths, connecting demand pairs in M(B). We add the paths in
P(cid:48)(B) to P, and delete from τ all vertices of τvB . Since we have ensured that the paths in P(cid:48)(B) are
disjoint from p(B), the invariant that the paths in P are disjoint from the new graph Gr continues
to hold. The algorithm terminates when no demand pair (s, t) ∈ M is contained in Gr. We claim
that the resulting collection {M(B),M(cid:48)(B) | B ∈ B} of sets of demand pairs partitions M. Indeed,
consider any demand pair (s, t) ∈ M, and consider the last iteration i when both s, t ∈ Gr. Let vB be
the vertex that was processed in the following iteration. If both s, t ∈ GvB \p(B), then (s, t) was added
to MB. Otherwise, exactly one of s, t belongs to GvB \ p(B), while the other belongs to Gr, so (s, t)
was added to M(cid:48)
B. We now obtain a set P of disjoint paths, routing a subset of vertices in M. We
show that |P| ≥ Ω(OPT(G,M)/ log k). Let P∗ be the optimal solution to instance OPT(G,M), and
let M∗ be the set of the demand pairs routed by P∗. For every block B ∈ B, let ˜M(B) = M∗ ∩ MB,
and let ˜M(cid:48)
From Observation B.14, set P(cid:48)(B) of paths routes at least Ω(OPT(B,NB)/ log k) ≥ Ω(OPT(G,MB)/ log k) ≥
other hand, as observed above, for every block B ∈ B, | ˜M(cid:48)
pairs in ˜M(cid:48)

Ω(| ˜MB|/ log k) demand pairs. Therefore, |P| = (cid:80)
|P| ≥(cid:80)

B∈B |P(cid:48)(B)| ≥ (cid:80)

B = M∗ ∩ M(cid:48)
B.

B contain vertex p(B)), while |P(cid:48)(B)| ≥ 1. Therefore, |P| ≥ (cid:80)

B∈B Ω(| ˜MB|/ log k). On the
B| ≤ 1 (since all paths routing the
B|. Overall,

B∈B | ˜M(cid:48)

B∈B Ω((| ˜MB| + | ˜M(cid:48)

B|)/ log k) = Ω(|M∗|/ log k).

B.3 Approximation Algorithm for NDP-Cylinder

In this section we prove Theorem 1.1 for NDP-Cylinder. Recall that in the NDP-Cylinder problem, we
are given a cylinder Σ, obtained from the sphere, by removing two open discs from it. We denote the
boundaries of the two discs by Γ1 and Γ2, respectively. We assume that we are given a graph G, drawn
on Σ, and a set M of demand pairs. We denote by S and T the sets of all source and all destination
vertices participating in the demand pairs in M. We say that a drawing of G is proper with respect
to S and T iﬀ the vertices of S lie on Γ1, the vertices of T lie on Γ2, and no other edges or vertices of
G intersect Γ1 or Γ2. We can assume without loss of generality that we are given a proper drawing of
the input graph G on Σ with respect to S and T . We also assume that the graph G is connected, as
otherwise we can solve the problem for each connected component of G separately. We assume that we
know the value OPT of the optimal solution to instance (G,M), and a demand pair (s∗, t∗) ∈ M that
is routed by some optimal solution to instance (G,M). We can make these assumptions by solving
the problem for every possible value of OPT between 1 and |M|, and every choice of (s∗, t∗) ∈ M. It
is enough to show that the algorithm returns the desired solution when the value OPT and the pair

78

(s∗, t∗) are guessed correctly. We can also assume that OPT > 10, since otherwise routing a single
demand pair gives a desired solution.

We deﬁne a set W1 of points on Γ1, as follows. First, we add to Γ1 all points corresponding to the
vertices of S. Next, for every segment of Γ1 \ W1, we add an arbitrary point on the segment to W1.
We deﬁne a set W2 of points on Γ2 similarly, using T instead of S. Our ﬁrst step is to compute the
shortest G-normal curve γ∗ ⊆ Σ, connecting a point of W1 to a point of W2. We consider two cases.
Assume ﬁrst that the length of γ∗ is less than OPT/2. Then we can cut the cylinder Σ along the
curve γ∗, deleting from G all vertices lying on γ∗, to obtain a disc Σ(cid:48), and a drawing of G on Σ(cid:48),
where all terminals of S ∪ T lie on the boundary of the disc. It is easy to see that the value of the
optimal solution of the resulting problem instance is at least OPT/2. We can now apply the O(log k)-
approximation algorithm for NDP-Disc from Section B.2 to obtain an O(log k)-approximate solution
to the new NDP-Disc instance, which in turn gives an O(log k)-approximate solution to the original
instance of NDP-Cylinder.
We assume from now on that the length of γ∗ is at least OPT/2. We reduce the problem to DPSP.
Let σ be cycle, whose vertices are W1, and they are connected in the order of their appearance on Γ1.
We delete the edge of σ incident on s∗, that appears after s∗ in the counter-clock-wise traversal of Γ1,
and direct all edges of the resulting path away from s∗. We deﬁne a path σ(cid:48) similarly - start with the
cycle, whose vertices are W2, and they are connected in the order of their appearance on Γ2. Delete
the edge incident on t∗, that appears after t∗ in the counter-clock-wise traversal of Γ2, and direct all
edges of the resulting path away from t∗. Our next step is to deﬁne a set K of constraints for the
DPSP problem instance. The instance we construct will only contain type-1 and type-2 constraints.
Let a∗ be the last vertex of σ. The ﬁrst constraint that we add to K is (1, s∗, a∗, OPT/2). This
constraint ensures that overall we will not attempt to route more than OPT/2 demand pairs.
Consider now any pair x, y ∈ W1 of points. Let β1(x, y) and β2(x, y) be the two segments of Γ1 whose
endpoints are x and y. For i ∈ {1, 2}, we let (cid:96)i(x, y) be the smallest number of vertices that need to
be removed from G, in order to disconnect all vertices of βi(x, y)∩ S from the vertices of T - this value
can be computed eﬃciently using standard minimum cut algorithms. Let wi = (cid:96)i(x, y). We assume
w.l.o.g. that x lies before y on σ. If s∗ is not an inner vertex on βi(x, y), then we add the constraint
(1, x, y, wi) to K. Otherwise, we add two constraints: (1, s∗, x, wi) and (1, y, a∗, wi) to K. For every
pair of points (x, y) ∈ W1, we therefore add at most three type-1 constraints to K.
We process all pairs of points (x, y) ∈ W2, and add corresponding type-2 constraints to K similarly,
except that we use t∗ instead of s∗. This ﬁnishes the description of the DPSP instance. We start with
the following easy observation.
Observation B.15 Let P∗ be the optimal solution to the NDP instance (G,M), such that (s∗, t∗) is
routed by P∗, and let M∗ be the set of the demand pairs routed by P∗. Let M∗∗ ⊆ M∗ be any subset
of (cid:98)|M∗|/2(cid:99) demand pairs. Then M∗∗ is a feasible solution to the DPSP instance (σ, σ(cid:48),M,K).

Proof: Since we assume that the demand pair (s∗, t∗) is routed by P∗, and since the demand pairs
in M∗ must be non-crossing with respect to Γ1 and Γ2, due to the way in which we have deﬁned the
paths σ and σ(cid:48), set M∗∗ must be non-crossing with respect to σ and σ(cid:48).
Recall that we have added the constraint (1, s∗, a∗,|OPT|/2) to K, where s∗ and a∗ are the endpoints
of σ. Since |M∗∗| ≤ |M∗|/2 = |OPT|/2, set M∗∗ satisﬁes this constraint.
Consider now any pair (x, y) of points in W1, and ﬁx some i ∈ {1, 2}. Since set M∗ of demand pairs
is routable in G, the number of the source vertices of the demand pairs in M∗ that lie on βi(x, y) is
at most (cid:96)i, as the value of the minimum cut separating the vertices of S ∩ βi(x, y) from the vertices

79

of T is (cid:96)i. It is now easy to verify that all type-1 constraints in K corresponding to the pair (x, y) are
satisﬁed by M∗, and hence by M∗∗. Type-2 constraints are dealt with similarly.
Our next step is to use the algorithm from Theorem 3.1, in order to compute a set M(cid:48) ⊆ M of
non-crossing (with respect to σ and σ(cid:48)) demand pairs, satisfying all constraints in K, with |M(cid:48)| ≥
Ω(OPT(G,M)/ log k). We assume that M(cid:48) = {(s1, t1), . . . , (sr, tr)}, where s1, . . . , sr appear in this
circular order on Γ1, and if (s∗, t∗) ∈ M(cid:48), then s1 = s∗. If |M(cid:48)| ≤ 10, then a routing of a single demand
pair gives a feasible solution to the NDP problem instance and achieves the desired approximation
ratio. Therefore, we assume that |M(cid:48)| > 10. We let M(cid:48)(cid:48) contain all demand pairs (sj, tj), where j = 0
modulo 8, and 1 ≤ j ≤ r. Notice that M(cid:48)(cid:48) excludes the pair (s∗, t∗). Let S(cid:48)(cid:48) and T (cid:48)(cid:48) be the sets of the
source and the destination vertices of the demand pairs in M(cid:48)(cid:48). We need the following theorem.
Theorem B.16 There is a set P of |S(cid:48)(cid:48)| node-disjoint paths in G, connecting the vertices of S(cid:48)(cid:48) to
the vertices of T (cid:48)(cid:48).
We prove Theorem B.16 below, after we complete the proof of Theorem 1.1 using it. Denote |M(cid:48)(cid:48)| =
κ∗, and recall that from our constraints, κ∗ ≤ |OPT|/4. Our ﬁrst step is to construct a collection
Z = (Z1, . . . , Zκ∗) of κ∗ tight concentric cycles around Γ1, where we consider a planar drawing of G,
whose outer face contains Γ2. In order to do so, we denote Γ1 = Z0, and perform κ∗ iteration, where
in the ith iteration we construct the cycle Zi. In order to execute the ith iteration, for 1 ≤ i ≤ κ∗, we
contract D(Zi−1) into a single vertex s, to obtain a new graph Hi. We view the face of Hi containing
Γ2 as the outer face in the planar drawing of Hi, and we then let Zi = min-cycle(H, s). Since the length
of the shortest G-normal curve connecting a point of Γ1 to a point of Γ2 is at least |OPT|/2 > κ∗, it
is easy to verify that we can successfully complete the construction of the set Z of κ∗ cycles, so that
all cycles are disjoint from the vertices lying on Γ2.
Our next step is to re-route the paths in P, so that they become monotone with respect to Z. In
order to do so, we construct a graph H, as follows. We start with the union of the paths in P and
the cycles in Z. We then add a new cycle Y connecting the vertices of T (cid:48)(cid:48) in the order in which they
appear on Γ2. We can now use Theorem 2.5 to ﬁnd a collection P(cid:48) of κ∗ node-disjoint paths in H,
connecting vertices of S(cid:48)(cid:48) to vertices of T (cid:48)(cid:48), that are monotone with respect to Z. It is easy to see that
the paths of P(cid:48) are contained in G.
We assume that P(cid:48) = {P1, P2, . . . , Pκ∗}, and for each 1 ≤ i ≤ κ∗, we denote by ai ∈ S(cid:48)(cid:48) and bi ∈ T (cid:48)(cid:48)
the endpoints of Pi. We assume that a1, a2, . . . , aκ∗ appear in this circular order on Γ1. Consider the
source vertex a1 ∈ S(cid:48)(cid:48), and let (a1, b1+z) ∈ M(cid:48)(cid:48) be the demand pair in which a1 participates. We
can assume without loss of generality that z ≤ κ∗/2, since if this is not the case, we can re-order the
vertices a1, . . . , aκ∗ in the opposite direction around Γ1. Observe that for all 1 ≤ j ≤ (cid:98)κ∗/2(cid:99), pair
(aj, bj+z) ∈ M(cid:48)(cid:48), since the demand pairs in M(cid:48)(cid:48) are non-crossing. We now show how to route all
demand pairs in {(aj, bj+z)}1≤z≤(cid:98)κ∗/2(cid:99). Fix some 1 ≤ j ≤ (cid:98)κ∗/2(cid:99). We view the paths in P(cid:48) as directed
from S(cid:48)(cid:48) to T (cid:48)(cid:48). Let P (cid:48)
j be the sub-path of Pj from aj to the ﬁrst vertex vj of Pj lying on Zκ∗−j+1.
Let P (cid:48)(cid:48)
j+z of Pj+z lying on Zκ∗−j+1 to bj+z. Finally,
let Qj be the segment of Zκ∗−j+1 between vj to v(cid:48)
j+z, that intersects the paths Pj, Pj+1, . . . , Pj+z, but
no other paths of P(cid:48). By combining P (cid:48)
j , connecting aj to bj+z.
We then set P∗ =
. It is immediate to verify that the paths in P∗ are node-disjoint.
Therefore, we obtain a solution routing Ω(OPT(G,M)) demand pairs in M. It now only remains to
prove Theorem B.16.

j+z be the sub-path of Pj+z, from the last vertex v(cid:48)

j | 1 ≤ j ≤ z
P ∗

j, P (cid:48)(cid:48)

j+z and Qj, we obtain a path P ∗

(cid:110)

(cid:111)

Proof of Theorem B.16. Assume for contradiction that there is no such set of paths. Denote
|S(cid:48)(cid:48)| = κ and recall that κ < OPT/2. Then there is a set Y of at most κ − 1 vertices, so that
G \ Y contains no path connecting a vertex of S to a vertex of T . Consider the drawing of G on the

80

separates from Γ2 in the cylinder Σ. Then(cid:83)

sphere Σ(cid:48)(cid:48), obtained from the drawing of G on the cylinder Σ, by adding back the two caps with the
boundaries Γ1 and Γ2. We can then construct a simple closed G-normal curve γ of length at most
κ − 1 in Σ(cid:48)(cid:48), so that all vertices of S(cid:48)(cid:48) lie in one of the discs of Σ(cid:48)(cid:48) with boundary γ, and all vertices of
T (cid:48)(cid:48) lie on the other disc (but the vertices of S(cid:48)(cid:48) and T (cid:48)(cid:48) may lie on γ). Notice that γ has to cross Γ1
or Γ2. Indeed, otherwise, since there are OPT node-disjoint paths connecting the vertices of Γ1 to the
vertices of Γ2, all such paths would have to cross γ, and so the length of γ should be at least OPT > κ,
a contradiction. Moreover, since the length of the shortest G-normal curve connecting a point of Γ1
to a point of Γ2 is at least OPT/2 > κ, curve γ may not intersect both Γ1 and Γ2. We assume without
loss of generality that γ crosses Γ1, and not Γ2.
Let R be the set of segments of γ, obtained by deleting all points of γ that lie outside the cylinder
Σ (that is, the points that lie in the interior of the cap whose boundary is Γ1). All curves in R are
mutually disjoint. For each curve γ(cid:48) ∈ R, let S(γ(cid:48)) ⊆ S(cid:48)(cid:48) be the set of the source vertices that γ(cid:48)
γ(cid:48)∈R S(γ(cid:48)) = S(cid:48)(cid:48) must hold, and so there must be some
curve γ∗ ∈ R, such that the length of γ∗ is less than |S(γ∗)|. Let (cid:96)∗ denote the length of γ∗.
Let x(cid:48), y(cid:48) be the endpoints of the curve γ∗, so x(cid:48), y(cid:48) ∈ Γ1. If x(cid:48) ∈ W1, then we let x = x(cid:48). Otherwise, we
let x be the closest to x(cid:48) point of W1 \ S(cid:48)(cid:48) on Γ1. We deﬁne point y(cid:48) for y similarly. Consider the two
segments β1(x, y) and β2(x, y) of Γ1, whose endpoints are x and y. One of the segments, say β1(x, y)
must contain all points of S(γ∗). Since the vertices lying on γ∗ separate all vertices of S(γ∗) from the
vertices of T , (cid:96)1(x, y) ≤ (cid:96)∗. Assume without loss of generality that x lies before y on σ.
Assume ﬁrst that s∗ does not lie on β1(x, y), and consider the corresponding constraint K = (1, x, y, w1) ∈
K. As observed above, w1 ≤ (cid:96)∗. Due to the way we have selected the subset M(cid:48)(cid:48) ⊆ M(cid:48) of the demand
pairs, we are guaranteed that |S(γ∗)| ≤ w1/2 ≤ (cid:96)∗, a contradiction.
Assume now that s∗ lies on β1(x, y). Using the same reasoning as above, w1 ≤ (cid:96)∗. Let β(cid:48)
1 be the
segments of β1(x, y) between x and s∗, and between s∗ and y, respectively, where the last segment
excludes s∗. Let ∆1, ∆(cid:48)
1 respectively, that
participate in the demand pairs in M(cid:48). Since the constraints (1, s∗, x, w1) and (1, y, a∗, w1) belong to
1 ≤ 2(cid:96)∗. Due to the way we have selected the subset M(cid:48)(cid:48) ⊆ M(cid:48) of the demand pairs, we
K, ∆1 + ∆(cid:48)
are guaranteed that |S(γ∗)| ≤ max{w1, 1} ≤ (cid:96)∗, a contradiction.
(cid:3)

1 be the number of the source vertices lying on β1 and β(cid:48)(cid:48)

1, β(cid:48)(cid:48)

C Proofs Omitted from Section 4

512·log k . The algorithm is iterative and maintains a set U of vertices. We start with U = ∅,

C.1 Proof of Theorem 4.2
Let τ = w∗
and in every iteration we add vertices to U . The algorithm terminates when no vertices have been
added to U in an iteration. Each iteration is executed as follows:
Let H denote the set of all connected components of G \ U , and for each H ∈ H, let TH ⊆ T (M)
denote the set of all terminals contained in V (H). For each H ∈ H with |V (H) ∩ TH| > 3, we use
Observation 2.1 to compute a vertex cut (A, C, B) in H whose sparsity ϕ with respect to TH is within
a factor αAKR from the value of the sparsest cut, and C ∩ TH = ∅. If ϕ < τ , then we add the vertices
of C to U . This ﬁnishes the description of the iteration execution.
Consider the set {G1, . . . , Gr} of all components of G \ U once the algorithm terminates. For all

1 ≤ j ≤ r, let Mj = {(si, ti) ∈ M | si, ti ∈ V (Gj)}. The algorithm output is(cid:8)(Gj,Mj)(cid:9)r

j=1.

Clearly, the algorithm is eﬃcient and terminates after at most n + 1 iterations, since the size of U

81

|Z|

min{|TH∩A(cid:48)|,|TH∩B(cid:48)|} <

αWL|T (cid:48)|

(cid:17)(cid:12)(cid:12)(cid:12) ≤ w∗·|M|

64

(cid:12)(cid:12)(cid:12)V (G) \(cid:16)(cid:83)r

increases after each iteration, except for the last one. It is easy to see that no edge connects a vertex
of Gj to a vertex of Gj(cid:48) for any 1 ≤ j (cid:54)= j(cid:48) ≤ r, from the deﬁnition of the graphs Gj.
We now verify that for all 1 ≤ j ≤ r, (Gj,Mj) is a well-linked instance. Fix some 1 ≤ j ≤ r, and let
T (cid:48),T (cid:48)(cid:48) ⊆ T (Mj) be two disjoint equal-sized subsets of T (Mj). Assume for contradiction that there
are fewer than αWL · |T (cid:48)| node-disjoint paths in Mj connecting the vertices of T (cid:48) to the vertices of
T (cid:48)(cid:48). Then by Menger’s Theorem, there exists a set Z ⊆ V (Gj) of fewer than αWL · |T (cid:48)| vertices in Gj,
such that there is no path from T (cid:48) to T (cid:48)(cid:48) in Gj \ Z. Note that we may assume that Z ∩ T (Mj) = ∅.
Otherwise, since the terminals have degree 1 and form an independent set in G, we may simply
replace each terminal in Z with its unique neighbor. Consider a vertex cut (A(cid:48), C(cid:48), B(cid:48)) of Gj, deﬁned
as follows: C(cid:48) = Z, A(cid:48) is the union of the vertices of all components of Gj \ Z intersecting T (cid:48), and
B(cid:48) = V (Gj) \ (A(cid:48) ∪ C(cid:48)). This is a valid vertex cut, with T (cid:48) ⊆ A(cid:48) and T (cid:48)(cid:48) ⊆ B(cid:48). The sparsity of cut
(A(cid:48), C(cid:48), B(cid:48)) with respect to T (Mj) is at most
min{|T (cid:48)|,|T (cid:48)(cid:48)|} = αWL. Therefore,
the algorithm from Observation 2.1 should have returned a cut of sparsity less than αAKR · αWL = τ , a
contradiction.
We now show that |U| =
. Consider a single iteration of the algo-
rithm. Let H be any component of G \ U , and let TH be the set of all terminals contained in V (H).
Suppose the algorithm computes a vertex cut (A, C, B) in H with respect to TH of sparsity ϕ < τ , and
adds the vertices of C to U . Assume without loss of generality that |A∩TH| ≤ |B∩TH|. Since we have
|C|
|A∩TH| . Moreover, since ϕ < τ , |C| < τ ·|A∩TH|
assumed that C ∩TH = ∅, the sparsity of the cut ϕ =
must hold. We charge the value of τ to every terminal in A∩TH , so that the total amount charged to
the terminals of A∩TH is τ ·|A∩TH| ≥ |C|. This charging scheme is repeated whenever a set of vertices
is added to U throughout the diﬀerent iterations and components considered by the algorithm. Note
that a terminal may be charged during multiple iterations, but at most once per iteration. Clearly,
the sum of the total charges to all of the terminals is at least |U|. Also, each terminal t ∈ T (M)
can be charged at most (cid:98)log 2k(cid:99) times, since whenever t is charged and U is updated, the number of
terminals in the component containing t in G \ U falls by at least a factor 2. Therefore, the total
charge to all terminals is at most τ · |T (M)| · log 2k ≤ ( w∗
, and |U|
is also bounded by this amount.

Finally, we verify that (cid:80)r
current LP-solution sends w∗ ﬂow units between si and ti. Let ˜M = M\(cid:16)(cid:83)r

512·log k ) · (log 2k) · |T (M)| ≤ w∗·|M|

j=1 |Mj| ≥ 63|M|/64. Recall that for each demand pair (si, ti) ∈ M, the
. If (si, ti) ∈ ˜M,
, | ˜M| ≤ |M|
64 ,

then all of the w∗ ﬂow units between si and ti must pass through U . Since |U| ≤ w∗·|M|
and the theorem follows.

j=1 Mj(cid:17)

j=1 V (Gj)

64

64

C.2 Proof of Lemma 4.4

We use the notion of treewidth, which is usually deﬁned via tree decompositions. A tree decomposition
of a graph H consists of a tree τ and a collection {βv ⊆ V (H)}v∈V (τ ) of vertex subsets, called bags,
such that the following two properties are satisﬁed: (i) for each edge (a, b) ∈ E(H), there is some
node v ∈ V (τ ) with both a, b ∈ βv and (ii) for each vertex a ∈ V , the set of all nodes of τ whose
bags contain a form a non-empty connected subtree of τ . The width of a given tree decomposition is
maxv∈V (τ ) {|βv|} − 1, and the treewidth of a graph H, denoted by tw(H), is the width of a minimum-
width tree decomposition for H.
Claim C.1 For each 1 ≤ j ≤ r, tw(Gj) ≥

Wj

212·αAKR·log k .

82

We ﬁrst prove the lemma assuming Claim C.1.
treewidth contains a large grid as a minor [RST94, DH05]. We use the following theorem.

It is well known that any planar graph of large

Theorem C.2 (Theorem 1.2 in [DH05]) For any ﬁxed graph H, every H-minor-free graph of
treewidth w has an (Ω(w) × Ω(w)) grid as a minor.
Therefore, in particular, every planar graph of treewidth w contains an (Ω(w) × Ω(w)) grid as a
minor. So Gj must contain a grid minor of size (Ω(Wj/ log k) × Ω(Wj/ log k)). Since all terminals
have degree 1 in G, the number of the non-terminal vertices, Nj ≥ Ω(W 2
j / log2 k). It now remains to
prove Claim C.1.
Proof of Claim C.1. For convenience, we let κ = |T (Mj)|. Assume for contradiction that tw(Gj) <
212·αAKR·log k . Note that τ cannot
212·αAKR·log k and consider a tree decomposition τ of width less than
212·αAKR·log k , since Wj = w∗ · κ/2 and w∗ < 1. For any given subtree τ(cid:48)
be a singleton vertex, as κ >
u∈V (τ(cid:48)) βu. We say that a vertex v ∈ V (τ ) is good iﬀ every component of G \ βv

of τ , we let β(τ(cid:48)) =(cid:83)

Wj

Wj

Wj

contains at most κ/2 terminals.

Claim C.3 There is a good vertex in τ .

Proof: Note that for a vertex v ∈ V (τ ), if τ1, . . . , τ(cid:96) are the connected subgraphs of τ \ {v}, then
every connected component C of Gj \ βv must have V (C) ⊆ β(τp) \ βv for some 1 ≤ p ≤ (cid:96). Also note
that the sets {β(τ1) \ βv, . . . , β(τ(cid:96)) \ βv} are pairwise vertex disjoint.
Root the tree τ at any vertex v0, and start with v = v0. While the current vertex v has a child vi,
such that the sub-tree τi of τ rooted at vi has |(β(τi) \ βv) ∩ T (Mj)| > |T (Mj)|/2, we set v = vi, and
continue to the next iteration. It is immediate to verify that when the algorithm terminates, the ﬁnal
vertex v is good.
Let v ∈ V (τ ) be a good vertex, and let C1, . . . , Ca denote the connected components of Gj \ βv. For
all 1 ≤ p ≤ a, let κp = |T (Mj) ∩ Cp|. Note that |βv| ≤
213·αAKR·log k ≤ κ/4, and hence
p=1 κp ≥ 3κ/4. We claim that there exist two disjoint subsets T (cid:48),T (cid:48)(cid:48) ⊆ T (Mj) \ βv
such that |T (cid:48)| = |T (cid:48)(cid:48)| = (cid:100)κ/8(cid:101), while T (cid:48) and T (cid:48)(cid:48) are separated by βv in Gj. Let 1 ≤ b < a be the
(cid:17)
p=b+1 κp ≥
p=b+1 Cp ∩ T (Mj)
,

|T (Mj) \ βv| =(cid:80)a
p=1 κp ≥ κ/8. Then(cid:80)b
smallest index for which(cid:80)b
(3/4 − 5/8)κ = κ/8. We then let T (cid:48) ⊆ (cid:16)(cid:83)b

p=1 κp ≤ (1/8 + 1/2)κ = 5κ/8, and so(cid:80)a

(cid:17)
p=1 Cp ∩ T (Mj)

and T (cid:48)(cid:48) ⊆ (cid:16)(cid:83)a

212·αAKR·log k =

respectively, be subsets of size (cid:100)κ/8(cid:101), so T (cid:48) ∩ T (cid:48)(cid:48) = ∅, and βv separates T (cid:48) from T (cid:48)(cid:48) in Gj.
Since the terminals are αWL-well-linked in Gj, there is a set of at least αWL · |T (cid:48)| =
512·αAKR·log k ≥
212·αAKR·log k node-disjoint paths from T (cid:48) to T (cid:48)(cid:48) in Gj. Since T (cid:48) and T (cid:48)(cid:48) are separated
212·αAKR·log k =
by βv in G\ βv, each path must intersect at least one distinct vertex of βv. However, we have assumed
that |βv| <
(cid:3)

212·αAKR·log k , a contradiction.

w∗·|T (cid:48)|

w∗·κ

w∗·κ

Wj

Wj

Wj

83

αWL

∆

(cid:6)W 2/19(cid:7)

∆0 Θ(∆ log n)

τ

∆1

∆2

W 18/19
(cid:98)∆/6(cid:99)
(cid:98)∆1/3(cid:99)

D Table of Parameters

w∗

512·αAKR·log k = Θ(w∗/ log k) well-linkedness parameter, where k is the number

of the demand pairs in the original instance.

Minimum distance between terminals in distinct terminal
sets of X .
Maximum distance between terminals in each terminal set
of X .
Threshold for light and heavy clusters in X
Depth of shells in Case 1

Depth of inner shells in Case 1

84

