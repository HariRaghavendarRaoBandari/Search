6
1
0
2

 
r
a

M
2

 

 
 
]

O
L
.
s
c
[
 
 

1
v
8
5
6
0
0

.

3
0
6
1
:
v
i
X
r
a

Nesting Depth of Operators in Graph Database Queries: Expressiveness

Vs. Evaluation Complexity

M. Praveen and B. Srivathsan˚

Chennai Mathematical Institute, India

Abstract

Designing query languages for graph structured data is an active ﬁeld of research, where expressiveness and
eﬃcient algorithms for query evaluation are conﬂicting goals. To better handle dynamically changing data, recent
work has been done on designing query languages that can compare values stored in the graph database, without
hard coding the values in the query. The main idea is to allow variables in the query and bind the variables to
values when evaluating the query. For query languages that bind variables only once, query evaluation is usually
NP-complete. There are query languages that allow binding inside the scope of Kleene star operators, which
can themselves be in the scope of bindings and so on. Uncontrolled nesting of binding and iteration within one
another results in query evaluation being Pspace-complete.

We deﬁne a way to syntactically control the nesting depth of iterated bindings, and study how this aﬀects
expressiveness and eﬃciency of query evaluation. The result is an inﬁnite, syntactically deﬁned hierarchy of
expressions. We prove that the corresponding language hierarchy is strict. Given an expression in the hierarchy,
we prove that it undecidable to check if there is a language equivalent expression at lower levels. We prove
that evaluating a query based on an expression at level i can be done in Σi in the polynomial time hierarchy.
Satisﬁability of quantiﬁed Boolean formulas can be reduced to query evaluation; we study the relationship
between alternations in Boolean quantiﬁers and the depth of nesting of iterated bindings.

1

Introduction

Graph structures representing data have found many applications like semantic web [17, 10], social networks [19] and
biological networks [12]. Theoretical models of such data typically have a graph with nodes representing entities
and edges representing relations among them. One reason for the popularity of these models is their ﬂexibility
in handling semi-structured data. While traditional relational databases impose rigid structures on the relations
between data elements, graph databases are better equipped to handle data in which relations are not precisely
known and/or developing dynamically.

A fundamental query language for such models is Regular Path Queries (RPQs), which is now part of the
W3C recommendation [18]. An RPQ consists of a regular expression over the ﬁnite alphabet labeling the edges
of the graph. Suppose a communication network is modeled by a graph, where nodes represent servers and edges
labeled ℓ represent links between them. Evaluating the RPQ ℓ˚ on this graph results in the set of pairs of nodes
between which there exists a route. Suppose each link has a priority and we need pairs of connected nodes where all
intermediate links have the same priority. We can hard code the set of priorities in the query. If the set of priorities
is not static, a querying mechanism which avoids hard coding is better. Theoretically, the querying language needs
to compare data values (priorities, in the preceding example) for equality, without hard coding the values in its
syntax. In generic frameworks, there is no a priori bound on the number of data values and they are considered to
be elements of an inﬁnite domain. Graph databases with data values are called data graphs.

˚Both the authors are partially funded by a grant from Infosys Foundation.

1

One way to design querying languages for data graphs is to extend RPQs using frameworks that handle words
on inﬁnite alphabets [15, 14, 11, 22]. Expressiveness and eﬃcient algorithms for query evaluation are conﬂicting
goals for designing such languages. We study a feature common to many of these languages, and quantify how
it aﬀects the trade-oﬀ between expressiveness and complexity of query evaluation. Variable ﬁnite automata [9]
and parameterized regular expressions [2] are conservative extensions of classical automata and regular expressions.
They have variables, which can be bound to letters of the alphabet at the beginning of query evaluation. The
query evaluation problem is NP-complete for these languages. Regular expressions with binding (REWBs) [14] is
an extended formalism where binding of variables to values can happen inside a Kleene star, which can itself be
inside another binding operator and so on. Allowing binding and iteration to occur inside each other’s scope like
this results in the query evaluation problem being Pspace-complete. Here we study how the expressiveness and
complexity of query evaluation vary when we syntactically control the depth of nesting of iterated bindings.

Contributions

1. We syntactically classify REWBs according to the depth of nesting of iterated bindings.

2. The resulting hierarchy of data languages is strict, and so is the expressiveness of queries.

3. It is undecidable to check if a given REWB has a language equivalent one at lower levels.

4. An REWB query in level i can be evaluated in Σi in the polynomial time hierarchy.

5. For lower bounds, we consider quantiﬁed Boolean formulas with some restrictions on quantiﬁcations and

reduce their satisﬁability to query evaluation, with some restrictions on the queries.

For proving strictness of the language hierarchy, we build upon ideas from the classic star height hierarchy [8].
Universality of REWBs is known to be undecidable [16, 11]. We combine techniques from this proof with tools
developed for the language hierarchy to prove the third result above. The Σi upper bound for query evaluation
involves complexity theoretic arguments based on the same tools. In the reductions from satisﬁability of quantiﬁed
Boolean formulas to the query evaluation problem, the relation between the number of alternations (in the Boolean
quantiﬁers) and the depth of nesting (of iterated bindings in REWBs) is not straight forward. We examine this
relation closely in the framework of parameterized complexity theory, which is suitable for studying the eﬀect of
varying the structure of input instances on the complexity.

Related work The quest for eﬃcient evaluation algorithms and expressive languages to query graph databases,
including those with data values, is an active area of research; [1] is a recent comprehensive survey. Numerous
formalisms based on logics and automata exist for handling languages over inﬁnite alphabets [20].
In [15], the
suitability of these formalisms as query languages has been studied, zeroing in on register automata mainly for
reasons of eﬃcient evaluation. The same paper introduced regular expressions with memory and proved that
they are equivalent to register automata. REWBs [14] have slightly less expressive power but have better scoping
structure for the binding operator. Properties of these expressions have been further studied in [11]. In [13], XPath
has been adapted to query data graphs. Pebble automata have been adapted to work with inﬁnite alphabets in [16].
A strict language hierarchy based on the number of pebbles allowed in pebble automata has been developed in [21].
Many questions about comparative expressiveness of register and pebble automata are open [16]. Fixed-point logics
can be used to deﬁne languages over inﬁnite alphabets [4]. These logics can use the class successor relation, which
relates two positions with the same data value if no intermediate position carries the same value. Expressiveness of
these logics increase [6, 5], when the number of alternations between standard successor relation and class successor
relation increase.

2 Preliminaries

2.1 Data Languages and Querying Data Graphs

We follow the notation of [14]. Let Σ be a ﬁnite alphabet and D a countably inﬁnite set. The elements of D
are called data values. A data word is a ﬁnite string over the alphabet Σ ˆ D. We will write a data word as

2

d1˘`a2
`a1

d2˘ . . .`an

dn˘, where each ai P Σ and di P D. A set of data words is called a data language.

An extension of standard regular expressions, called regular expressions with binding (REWB), has been deﬁned
in [14]. Here, data values are compared using variables. For instance, Óx in the expression a Óx pa˚ ¨ arx“sq binds
the ﬁrst data value to x. The condition rx“s checks whether the last data value equals the one stored in x.

For a set tx1, x2, . . . , xku of variables, the set of conditions Ck is the set of Boolean combinations of x“
i and
for i P t1, . . . , ku. A data value d P D and a partial valuation ν : tx1, . . . , xku Ñ D satisﬁes the condition x“
i

i ) if νpxiq “ d. The satisfaction for other Boolean operators are standard.

x‰
i
(written as d, ν |ù x“

Deﬁnition 2.1 (Regular expressions with binding (REWB) [14]). Let Σ be a ﬁnite alphabet and tx1, . . . , xku a set
of variables. Regular expressions with binding over Σrx1, . . . , xks are deﬁned inductively as:
r :“ ε | a | arcs | r `
r | r ¨ r | r˚ | a Óx prq where a P Σ is a letter in the alphabet and c P Ck is a condition on the variables.

We call Óx the binding operator.

In the expression a Óx prq, the expression r is said to be the scope of the
binding Óx. A variable x in an expression is bound if it occurs in the scope of a binding Óx. Otherwise it is free.
We write fv prq to denote the set of free variables in r and rpxq to denote that x is the sequence of all free variables.
The semantics of an REWB rpxq over the variables tx1, . . . , xku is deﬁned with respect to a partial valuation
ν : tx1, . . . , xku Ñ D of the variables. A valuation ν is compatible with rpxq if νpxq is deﬁned.

Deﬁnition 2.2 (Semantics of REWB). Let rpxq be an REWB over Σrx1, . . . , xks and let ν : tx1, . . . , xku Ñ D be
a valuation of variables compatible with rpxq. The language of data words Lpr, νq deﬁned by rpxq with respect to ν
is given as follows:

r Lpr, νq

ε

tεu

r1 ` r2 Lpr1, νq Y Lpr2, νq

r Lpr, νq

r Lpr.νq

a

t`a
d˘ | d P Du

r1 ¨ r2 Lpr1, νq ¨ Lpr2, νq

arcs
r˚
1

t`a
d˘ | d, ν |ù cu

pLpr1, νqq˚

d1˘` b

d1˘` a

d2˘` b

d2˘ ¨ ¨ ¨` a

dn˘` b
dn˘.

where νrxi Ñ ds denotes the valuation which is the same as ν except for xi which is mapped to d. An REWB r

d˘ u ¨ Lpr1, νrxi Ñ dsq

a Óxi pr1q ŤdPDt `a
deﬁnes the data language Lprq “ Ťν compatible with r Lpr, νq.
same data value. The REWB pa Óx pbrx“sqq˚ deﬁnes the set of data words of the form ` a

For example, the REWB a Óx pbrx“s˚q deﬁnes the set of data words of the form ab˚ with all positions having the

Regular expressions with binding can be used as query languages for certain kinds of graphs in which edges

contain labels from an inﬁnite domain.

Deﬁnition 2.3 (Data graphs). A data graph G over a ﬁnite alphabet Σ and an inﬁnite set of data values D is a
pair pV, Eq where V is a ﬁnite set of vertices, and E Ď V ˆ Σ ˆ D ˆ V is a set of edges which carry labels from
Σ ˆ D.

A regular data path query is of the form Q “ x

rÝÑ y where r is an REWB. Evaluating Q on a data graph G
results in the set QpGq of pairs of nodes xu, vy such that there exists a data path from u to v and the sequence
of labels along the data path forms a data word in Lprq. Computing the result of a regular data path query on a
data graph is known to be Pspace-complete [14]. For convenience, we sometimes identify the query Q with the
expression r and write rpGq for QpGq. A query r1 is said to be contained in another query r2 if for every data
graph G, r1pGq Ď r2pGq. It is known from [11, Proposition 3.5] that a query r1 is contained in the query r2 iﬀ
Lpr1q Ď Lpr2q. Hence, if a class E2 of REWBs is more expressive than the class E1 in terms of deﬁning data
languages, E2 can also express more regular data path queries than E1.

2.2 Parameterized Complexity

The size of queries are typically small compared to the size of databases. To analyze the eﬃciency of query
evaluation algorithms, the size of the input can be naturally split into the size of the query and the size of the

3

database. Parameterized complexity theory is a formal framework for dealing with such problems. An instance of
a parameterized problem is a pair px, kq, where x is an encoding of the input structure on which the problem has
to be solved (e.g., a transition system and a LTL speciﬁcation), and k is a parameter associated with the input
(e.g., the size of the LTL speciﬁcation). A parameterized problem is said to be in the parameterized complexity
class Fixed Parameter Tractable (FPT) if there is a computable function f : N Ñ N , a constant c P N and an
algorithm to solve the problem in time f pkq|x|c. Given a transition system T and an LTL formula ψ, there is an
algorithm to check if T satisﬁes ψ in time polynomial in 2|ψ||T |. Hence, the LTL model checking problem is in
FPT, when parameterized by the size of the LTL formula.

For reasons we explain, the query evaluation problem is unlikely to be in FPT, when parameterized by the size
of the regular data path query. There are many parameterized complexity classes that are unlikely to be in FPT.
The ones important here are W[SAT], W[P], AW[SAT] and AW[P]. To place parameterized problems in these
classes, we use FPT-reductions.

Deﬁnition 2.4 (FPT reductions). A FPT reduction from a parameterized problem Q to another parameterized
problem Q1 is a mapping R such that:

1. For all instances px, kq of parameterized problems, px, kq P Q iﬀ Rpx, kq P Q1.

2. There exists a computable function g : N Ñ N such that for all px, kq, say with Rpx, kq “ px1, k1q, we have

k1 ď gpkq.

3. There exist a computable function f : N Ñ N and a constant c P N such that R is computable in time

f pkq|x|c.

3 Nesting Depth of Iterated Bindings and Expressive Power

A binding Óx along with a condition rx“s or rx‰s is used to constrain the possible data values that can occur at
certain positions in a data word. A binding inside a star — an iterated binding — imposes the constraint arbitrarily
many times. For instance, the expression r1 :“ pa1 Óx1 pb1rx“
1 sqq˚ deﬁnes data words in pa1b1q˚ where every a1
has the same data value as the next b1. We now deﬁne a syntactic mechanism for controlling the nesting depth
of iterated bindings. The restrictions result in an inﬁnite hierarchy of expressions. The expressions at level i are
generated by Fi in the grammar below, deﬁned by induction on i.

F0 ::“ ε | a | arcs | F0 ` F0 | F0 ¨ F0 | F ˚
0
Ei ::“ Fi´1 | Ei ` Ei | Ei ¨ Ei | a Óxj pEiq
Fi ::“ Ei | Fi ` Fi | Fi ¨ Fi | F ˚
i

where i ě 1, a P Σ, c is a condition in Ck and xj P tx1, . . . , xku. Intuitively, Ei can add bindings over iterations
(occurring in Fi´1) and Fi can add iterations over bindings (occurring in Ei). The nesting depth of iterated bindings
in an expression in Fi is therefore i. The union of all expressions at all levels equals the set of REWBs. In this
paper, we use subscripts to denote the levels of expressions and superscripts to denote diﬀerent expressions in a
level: so e1

5 is some expression in E5, f 2

3 is some expression in F3.

We now give a sequence of expressions triuiě1 such that each ri is in Fi but no language equivalent expression
exists in Fi´1. For technical convenience, we use an unbounded number of letters from the ﬁnite alphabet and an
unbounded set of variables. The results can be obtained with a constant number of letters and variables.

Deﬁnition 3.1. Let ta1, b1, a2, b2, . . . u be an alphabet and tx1, x2, . . . u a set of variables. We deﬁne r1 to be
pa1 Óx1 pb1rx“

1 sqq˚. For i ě 2, deﬁne ri :“ pai Óxi pri´1birx“

i sqq˚.

From the syntax, it can be seen that each ri is in Fi. To show that Lpriq cannot be deﬁned by any expression
in Fi´1, we will use an “automaton view” of the expression, as this makes pigeon-hole arguments simpler. No

4

automata characterizations are known for REWBs in general; the restrictions on the binding and star operators in
the expressions of a given level help us build speciﬁc automata in stages.

i , e2

i , . . . , ek

Without loss of generality, we will consider expressions where the bound variables are diﬀerent from the free
variables in all sub-expressions. An expression f 1
i can be seen as a standard regular expression over an alphabet
consisting of some expressions in Ei, say te1
i u. When i “ 0, the alphabet consists of letters a and arcs
occurring in the expression. Using the conversion to non-deterministic ﬁnite automata, the expression f 1
i can be
seen as a ﬁnite automaton whose transitions are labeled with sub-expressions in Ei if i ě 1 and with letters of the
form a and arcs when i “ 0. We will denote this automaton by Apf 1
i can be seen as
an automaton in which each transition contains either a sub-expression in Fi´1 or a letter with a binding, that is,
a Óx. We denote this automaton by Ape1
i q. Free variables
in the expression become free variables in the corresponding automata. As we have assumed that bound variables
and free variables are diﬀerent, the scopes would be respected in the automata. The semantics of expressions can
now be viewed as runs of the corresponding automata. More details about semantics can be found in Appendix A.
We will prove that Lpriq cannot be deﬁned by any expression in Ei (and hence not by any expression in Fi´1).
We ﬁrst deﬁne the following sequence of words, which will be used in the proof. Let tdrj1, j2s P D | j1, j2 P N u be
a set of data values such that drj1, j2s ‰ drj1

i q. Since there is no ˚ used, there are no cycles in Ape1

i q. Similarly, an expression e1

2y. For every n ě 1, deﬁne the words:

1, j1

1, j1
2s if xj1, j2y ‰ xj1
dr1, 2n2s˙
dr1, 2n2s˙ˆ b1

dr1, 1s˙ ¨ ¨ ¨ ˆ a1

u1,n :“ ˆ a1
ui,n :“ ˆ ai

dr1, 1s˙ˆ b1
dri, 1s˙ui´1,nˆ bi

dri, 1s˙ ¨ ¨ ¨ ˆ ai

dri, 2n2s˙ui´1,nˆ bi

dri, 2n2s˙

for all i ě 2

In order to prove that Lpriq cannot be deﬁned by any expression in Ei, we will show the following property:
if ui,n occurs as a sub-word of a word w in the language of a “suﬃciently small” expression e1
i , then the same
expression accepts a word where some aj and a matching bj have diﬀerent data values. Let Mismatch i,n be the
set of all data words obtained from ui,n by modifying the data values so that there exist two positions p, p1 with

p ă p1 and a j ď i such that: p contains `aj

d˘ and p1 contains `bj

p1, bj does not occur in the word. For an expression e, let |Apeq| and |fv peq| denote the number of states in the
automaton Apeq and the number of free variables in e respectively.

d1˘ with d ‰ d1; moreover between positions p and

Lemma 3.2. Let e1
expression e of e1
Lpe1

i , νq for some ui,n P Mismatch i,n

i be an expression and let n P N be greater than p|Apeq| ` 1q and p|fv peq| ` 1q for every sub-
i , νq ùñ xui,nz P

i q and let x, z be data words. Then: xui,nz P Lpe1

i . Let ν be a valuation of fv pe1

Proof idea. By induction on i. Suppose xui,nz P Lpe1
i q| ă n, the range of ν can have at most pn´ 1q
data values. The run of Ape1
i q on xui,nz consists of at most n transitions, since the automaton is acyclic and has
at most n states. Each of the (at most) n transitions reads some sub-word in the language of some sub-expression
i´1, while the whole word consists of 2n2 occurrences of aiui´1,nbi. Hence, at least one sub word consists of 2n
f 1
occurrences of aiui´1,nbi. A run of Apf 1

i´1q on such a sub-word is shown below.

i , νq. Since |fv pe1

x1

ai ui´1,n bi

ai ui´1,n bi

ai ui´1,n bi

ai ui´1,n bi

ai ui´1,n bi

ai ui´1,n bi

z1

e1
i´1

e2
i´1

¨ ¨ ¨

es´2
i´1

es´1
i´1

es
i´1

q1

0

q1

1

q1

2

q1
s´3

q1
s´2

q1
s´1

q1
s

By the time this run starts, Ape1
i q can add at most n new data values to the range of the valuation ν (due to
transitions with Óx) and so the range of ν can have at most p2n ´ 1q distinct data values. Every transition of this
run reads sub-words in the language of some sub-expression ej
i´1. If some transition of this run reads an entire sub-
word ui´1,n (as in transition q1
2), then we can create a mismatch inside this ui´1,n by induction hypothesis.
Otherwise, none of the transitions read an ai and the corresponding bi together (as in q1
s´1 in the ﬁgure).
None of the bis is compared with the corresponding ai, so the data value of one of the bis can be changed to create

s´2 ÝÑ q1

1 ÝÑ q1

5

a mismatch. The resulting data word will be accepted provided the change does not result in a violation of some
condition. Since the range of the valuation has at most p2n ´ 1q distinct values, one of the 2n bis is safe for changing
the data value.

Theorem 3.3. For any i, the language Lpriq cannot be deﬁned by any expression in Ei.

Proof. Suppose ri is equivalent to an expression e1
i . Pick an n bigger than |Apeq| and |fv peq| for every sub-
expression e of ei. The word ui,n belongs to Lpriq and hence Lpe1
i q. By Lemma 3.2, we know that if this is the
case, then ui,n P Lpriq for some word ui,n P Mismatch i,n. But Lpriq cannot contain words with a mismatch. A
contradiction.

Given an expression at some level, it is possible that its language is deﬁned by an expression at lower levels.

Next we show that it is undecidable to check this.

Theorem 3.4. Given an expression in Fi`1, checking if there exists a language equivalent expression in Fi is
undecidable.

Proof idea. By reduction from Post’s Correspondence Problem (PCP). The basic idea is from the proof of undecid-
ability of universality of REWBs and related formalisms [16, 14]. For an instance tpu1, v1q, . . . , pun, vnqu of PCP,
a solution (if it exists) can be encoded by a data word of the form w1#ri#w2, where w1 is made up of ui’s, w2 is
made up of vi’s and ri is from Deﬁnition 3.1. To ensure that such a data word indeed represents a solution, we
need to match up the ui’s in w1 with the vi’s in w2, which can be done through matching data values. Consider
the language of data words of the form w1
2 that are not solutions of the given PCP instance. This language
can be deﬁned by an expression ∆ in Ei`1, which compares data values in the left of #ri# with those on the right
side, to catch mismatches. We can prove that no equivalent expression exists in lower levels, using techniques used
in Lemma 3.2. On the other hand, if the given PCP instance does not have a solution, no data word encodes a
solution, so the given language is deﬁned by Σ˚riΣ˚, which is in Fi.

1#ri#w1

4 Complexity of Query Evaluation

In this section, we will study how the depth of nesting of iterated bindings aﬀects the complexity of evaluating
queries. An instance of the query evaluation problem consists of a data graph G, an REWB e, a valuation ν for
fv peq and a pair xu, vy of nodes in G. The goal is to check if u is connected to v by a data path in Lpe, νq.

4.1 Upper Bounds

An expression in Fi can be thought of as a standard regular expression (without data values) over the alphabet of
its sub-expressions. This is the main idea behind our upper bound results. The main result proves that evaluating
queries in Ei can be done in Σi in the polynomial time hierarchy.

Lemma 4.1. With an oracle for evaluating Ei queries, Fi queries can be evaluated in polynomial time.

in Ei. For every j, add an edge labeled ej

Proof idea. Suppose the query f 1
i
e1
i , . . . , em
i
in the evaluation of ej
a standard regular expression over the ﬁnite alphabet te1
standard automata theoretic techniques.

is to be evaluated on the data graph G and f 1

i on G. Evaluating the sub-expressions can be done with the oracle. Now f 1

i consists of the sub-expressions
i between those pairs xv1, v2y of nodes of G for which xv1, v2y is
i can be treated as
i u, and can be evaluated in polynomial time using

i , . . . , em

Theorem 4.2. For queries in Ei, the evaluation problem belongs to Σi.

6

Proof idea. Since bindings in Ei are not iterated, each binding is performed at most once. The data value for each
variable is guessed non-deterministically. The expression can be treated as a standard regular expression over its
sub-expressions and the guessed data values. The sub-expressions are in Fi´1, which can be evaluated in polynomial
time (Lemma 4.1) with an oracle for evaluating queries in Ei´1. This argument will not work in general for arbitrary
REWBs — bindings that are nested deeply inside iterations and other bindings may occur more than polynomially
many times.

Next we consider the query evaluation problem with the size of the query as the parameter. An instance of
the parameterized weighted circuit satisﬁability problem consists of a Boolean circuit and the parameter k P N .
The goal is to check if the circuit can be satisﬁed by a truth assignment of weight k (i.e., one that sets exactly k
propositional atoms to true). The class W[P] is the set of all parameterized problems which are FPT-reducible to
the weighted circuit satisﬁability problem.

Theorem 4.3. Evaluating REWB queries in E1, parameterized by the size of the query is in W[P].

Proof idea. It is proved in [3, Lemma 7, Theorem 8] that a parameterized problem is in W[P] iﬀ there is a non-
deterministic Turing machine that takes an instance px, kq and decides the answer within f pkq|x|c steps, of which at
most f pkq log |x| are non-deterministic (for some computable function f and a constant c). Such a Turing machine
exists for evaluating REWB queries in E1, using the steps outlined in the proof idea of Theorem 4.2.

Thus, the number of non-deterministic steps needed to evaluate an E1 query depends only logarithmically on the
size of the data graph. It is also known that W[P] is contained in the class para-NP — the class of parameterized
problems for which there are deterministic algorithms taking instances px, kq and computing an equivalent instance
of the Boolean satisﬁability problem in time f pkq|x|c. Hence, we can get an eﬃcient reduction to the satisﬁability
problem, on which state of the art sat solvers can be run. Many hard problems in planning fall into this category
[7].

We next consider the parameterized complexity of evaluating queries at higher levels. The parameterized class
uniform-XNL is the class of parameterized problems Q for which there exists a computable function f : N Ñ N
and a non-deterministic algorithm that, given a pair px, kq, decides if px, kq P Q in space at most f pkq log |x| [3,
Proposition 18].

Theorem 4.4. Evaluating REWB queries, with size of the query as parameter, is in uniform-XNL.

Proof idea. Let k be the size of the query e1
i to be evaluated, on a data graph with n nodes. Suppose a pair of
nodes is connected by a data path w in Lpe1
i q.
i can only occur inside its Fi´1 sub-expressions.
Hence w consists of at most k sub-paths, each sub-path wj in the language of some sub-expression f j
i´1. When
f j
i´1 is considered as a standard regular expression over its sub-expressions (in Ei´1), there are no bindings. By
a standard pigeon hole principle argument, we can infer that wj consists of at most kn sub-paths, each one in
the language of some sub-expression e1
i´1. This argument can be continued to prove that w is of length at most
pk2nqi. The existence of such a path can be guessed and veriﬁed by a non-deterministic Turing machine in space
Opik2 log nq.

Iterations in e1

4.2 Lower Bounds

We obtain our lower bounds by reducing various versions of the Boolean formula satisﬁability problem to query
evaluation. We begin by describing a schema for reducing the problem of evaluating a Boolean formula on a
given truth assignment to the problem of evaluating a query on a data graph. The basic ideas for the gadgets we
construct below are from [14, proofs of Proposition 2, Theorem 5]. We will need to build on these ideas to address
ﬁner questions about the complexity of query evaluation.

Suppose the propositional atoms used in the Boolean formula are among tpr 1, . . . , pr nu. We use pr 1, . . . , pr n

also as data values. An edge labeled ` pv

data values po and ne appear on edges labeled with the letter pn?, to indicate if a propositional atom appears

pr j˘ indicates the propositional atom pr j occurring in a sub-formula. The

7

positively or negatively. The symbol ˚ denotes an arbitrary data value diﬀerent from all others. We will assume
that the Boolean formula is in negation normal form, i.e., negation only appears in front of propositional atoms.
This restriction does not result in loss of generality, since any Boolean formula can be converted into an equi-
satisﬁable one in negation normal form with at most linear blowup in the size. The data graph is a series parallel
digraph with a source and a sink, deﬁned as follows by induction on the structure of the Boolean formula.

• Positively occurring propositional atom pr j: ¨

p b
˚q
ÝÝÑ ¨

ppn ?
po q
ÝÝÝÑ ¨

p pv
pr jq
ÝÝÝÑ ¨

p e
˚q
ÝÝÑ ¨.

• Negatively occurring propositional atom pr j: ¨

˚q
p b
ÝÝÑ ¨

ne q
ppn ?
ÝÝÝÑ ¨

p pv
pr jq
ÝÝÝÑ ¨

˚q
p e
ÝÝÑ ¨.

• φ1 ^ ¨ ¨ ¨ ^ φr: inductively construct the data graphs for the conjuncts, then do a standard serial composition,

by fusing the sink of one graph with the source of the next one.

• φ1 _ ¨ ¨ ¨ _ φr: inductively construct the data graphs for the disjuncts, then do a standard parallel composition,

by fusing all the sources into one node and all the sinks into another node.

• After the whole formula is handled, the source of the resulting graph is fused with the sink of the following

graph: ¨

poq
p a
ÝÝÑ ¨

neq
p a
ÝÝÑ ¨.

Let Gφ denote the data graph constructed above for formula φ. The data graph Gφ is shown below for φ “
ppr 1 _  pr 2q ^ pppr 2 ^ pr 3q _ p pr 1 ^ pr 4qq.

` a
po˘

` a
ne˘

po ˘ ` pv
`pn?
pr 1˘
pr 2˘ `e
` b
˚˘
˚˘ `pn?
ne ˘ ` pv

po ˘ ` pv
`pn?
pr 2˘
` b
˚˘ `pn?
ne ˘ ` pv
pr 1˘

`e
˚˘
`e
˚˘

` b
˚˘
` b
˚˘

po ˘ ` pv
`pn?
pr 3˘
pr 4˘ `e
˚˘
po ˘ ` pv
`pn?

The query uses x1, . . . , xk to remember the propositional atoms that are set to true.

eeval rks :“ a Óxpo pa Óxne p
pos ¨ pv rx“

pbppn?rx“

1 _ ¨ ¨ ¨ _ x“

k s ` pn?rx“

ne s ¨ pv rx‰

1 ^ ¨ ¨ ¨ ^ x‰

k sqeq˚ qq .

(1)

Lemma 4.5. Let φ be a Boolean formula over the propositional atoms pr 1, . . . , pr n and ν : tx1, . . . , xku Ñ
tpr 1, . . . , pr n, ˚u be a valuation. The source of Gφ is connected to its sink by a data path in Lpeeval rks, νq iﬀ φ
is satisﬁed by the truth assignment that sets exactly the propositions in tpr 1, . . . , pr nu X Rangepνq to true.

Proof idea. The two bindings in the beginning of eeval rks forces xpo , xne to contain po, ne respectively. A positively

˚q
p e
ÝÝÑ ¨, which can only be in
occurring propositional atom generates a data path of the form ¨
the language of the expression b ¨ pn?rx“
k se. This forces pr j to be contained in one of x1, . . . , xk.
Similar arguments works for negatively occurring atoms. Rest of the proof is by induction on the structure of the
formula.

1 _ ¨ ¨ ¨ _ x“

pos ¨ pv rx“

po q
ppn ?
ÝÝÝÑ ¨

˚q
p b
ÝÝÑ ¨

p pv
pr jq
ÝÝÝÑ ¨

Theorem 4.6. For queries in E1, the evaluation problem is NP-hard.

Proof idea. To check if a Boolean formula φ is satisﬁable, evaluate the query a Óx1 a Óx2 ¨ ¨ ¨ a Óxn eevalrns on the

data graph ¨

p a
pr 1{˚q
ÝÝÝÝÑ ¨

p a
pr 2{˚q
ÝÝÝÝÑ ¨ ¨ ¨

` a
pr j˘ and another with `a
˚˘.

pr n{˚q
p a
ÝÝÝÝÝÑ ¨ ´ Gφ Ñ ¨. Here,

p a
pr j {˚q
ÝÝÝÝÑ denotes two edges in parallel, one labeled with

8

Evaluating queries in E1 is NP-complete, evaluating REWB queries in general is Pspace-complete and evaluat-
ing queries in Ei is in Σi. We have not been able to obtain a corresponding Σi lower bound. REWBs with bounded
depth of nesting of iterated bindings do not seem to be powerful enough to simulate Σi computations. We take a
closer look at this in the framework of parameterized complexity.

We now extend our satisﬁability-to-query evaluation schema to handle Boolean quantiﬁers. Let PR “ tpr 1, . . . , pr nu

be a set of propositional atoms. To handle existential Boolean quantiﬁers, we build a new graph and a query. These
gadgets build on earlier ideas to bring out the diﬀerence in the role played by the data graph and the query while
pr nq
p a1
ÝÝÝÑ
reducing satisﬁability to query evaluation. The new graph GrDk{PRs ˝ G, is as follows: ¨
¨ ´ G Ñ ¨. We assume that the letter a1 is not used inside G, which is equal to Gφ for some Boolean formula φ.
The new query erDks ˝ e is deﬁned as follows:

pr 2q
p a1
ÝÝÝÑ ¨ ¨ ¨

pr 1q
p a1
ÝÝÝÑ ¨

erDks ˝ e :“ a˚

1 a1 Óx1 a˚

1 a1 Óx2 a˚

1 ¨ ¨ ¨ a˚

1 a1 Óxk a˚
1 e

(2)

where e “ eevalrks for some k P N .

We now give a parameterized lower bound for evaluating E1 queries. An instance of the weighted satisﬁability
problem consists of a Boolean formula (not necessarily in Conjunctive Normal Form) and a parameter k P N . The
goal is to check if the formula is satisﬁed by a truth assignment of weight k. The class W[SAT] is the set of all
parameterized problems that are FPT-reducible to the weighted satisﬁability problem.

Lemma 4.7. Let φ be a Boolean formula over the set PR of propositions and k P N . We can construct in
polynomial time a data graph G and an REWB e1

1 satisfying the following conditions.

1. The source of G is connected to its sink by a data path in Lpe1

1q iﬀ φ has a satisfying assignment of weight k.

2. The size of e1

1 depends only on k.

Proof idea. The required data graph is GrDk{PRs ˝ Gφ and e1

1 is erDks ˝ eeval rks. The data path ¨

pr 1q
p a1
ÝÝÝÑ ¨

pr 2q
p a1
ÝÝÝÑ

pr nq
p a1
ÝÝÝÑ ¨ in the graph GrDk{PRs ˝ Gφ has to be in the language of a˚

¨ ¨ ¨
1 . This
induces a valuation ν1 which maps tx1, . . . , xku injectively into PR, denoting the k propositions that are set to true.
With this the data path continues from the source of Gφ to its sink. Rest of the proof follows from Lemma 4.5.

1 a1 Óxk a˚

1 a1 Óx1 a˚

1 a1 Óx2 a˚

1 ¨ ¨ ¨ a˚

Theorem 4.8. Evaluating REWB queries in E1, parameterized by the size of the query is hard for W[SAT] under
FPT reductions.

Proof. The reduction given in Lemma 4.7 is a FPT reduction from the weighted satisﬁability problem to the
problem of evaluating E1 queries , parameterized by the size of the query.

Finally we extend our gadgets to handle universal Boolean quantiﬁers. These gadgets build upon the previous
ideas and bring out the role of nested iterated bindings when satisﬁability is reduced to query evaluation. We
would ﬁrst like to check if the source of some graph G is connected to its sink by a data path in the language of
some REWB e, for every possible injective valuation ν : tx1, . . . , xku Ñ PR. We will now design some data graphs
and expressions to achieve this. Let skip be a letter not used in G. The data graphs G0, . . . , Gk are as shown in
Figure 1. The expressions e0, . . . , ek are deﬁned as follows.

e0 :“ e ` ă1ďiăjďk

skiprx“

i ^ x“
j s

ei :“ bipai Óxi pei´1airx“

i sqciq˚

(3)

The nesting depth of iterated bindings in the expression ei is one more than that of ei´1.

Suppose ν is a partial valuation of some variables, whose domain does not intersect with tx1, . . . , xku. We
denote by νrtx1, . . . , xku Ñ PRs the set of valuations ν1 that extend ν such that domainpν1q “ domainpνq Y
tx1, . . . , xku and tν1px1q, . . . , ν1pxkqu Ď PR. We additionally require that ν1 is injective on tx1, . . . , xku when we
write νrtx1, . . . , xku 1:1ÝÝÑ PRs.

9

`skip
pr n˘

`skip
pr 1˘

G

` ai
pr 1˘

` ai
pr 2˘

` ai
pr n˘

ci

ci

Gi´1

` ai
pr n˘

` ai
pr n´1˘

` ai
pr 1˘

bi

ci

Figure 1: Data graphs G0 (left) and Gi (right)

Lemma 4.9. Let i P t1, . . . , ku and νi be a valuation for fv peiqztx1, . . . , xiu. The source of Gi is connected to its
sink by a data path in Lpei, νiq iﬀ for every ν P νirtx1, . . . , xiu Ñ PRs, there is a data path in Lpe0, νq connecting
the source of G0 to its sink.

Proof idea. The data path has to begin with bi` ai
path has to traverse Gi´1 using ei´1. At the sink of Gi´1, the path is forced to take ` ai

pr 1˘ in the language of biai Óxi, forcing xi to store pr 1. Then the
pr 1˘ci to satisfy the condition

in airx“

i sci. This forces the path to start again in ` ai

pr 2˘ and so on.

We write Gr@k{PRs ˝ G and er@ks ˝ e to denote the graph Gk and REWB ek constructed above. We implicitly
assume that the variables x1, . . . , xk are not bound inside e. We can always rename variables to ensure this. If e is
in Ei, then er@ks ˝ e is in Fi`k´1.

Lemma 4.10. Let ν be a valuation for fv peqztx1, . . . , xku for some REWB e. The source of Gr@k{PRs ˝ G is
connected to its sink by a data path in Lper@ks ˝ e, νq iﬀ for all ν1 P νrtx1, . . . , xku 1:1ÝÝÑ PRs, the source of G is
connected to its sink by a data path in Lpe, ν1q.

Proof idea. Lemma 4.9 ensures that there is a path wν1 in Lpe0, ν1q connecting the source of G0 to its sink for every
valuation ν1 P νrtx1, . . . , xku Ñ PRs. From Figure 1, wν1 can either be a skip edge, or a path through G. By
deﬁnition, e0 allows a skip edge to be taken only when two variables among x1, . . . , xk have the same data value.
Hence for valuations ν1 that are injective on tx1, . . . , xku, wν1 is in Lpe, ν1q.

If φ is a partially quantiﬁed Boolean formula with the propositional atoms in PR occurring freely, we write
DkPR φ to denote that atoms in PR are existentially quantiﬁed with the constraint that exactly k of them should be
set to true. We write @kPR φ to denote that atoms in PR are universally quantiﬁed and that only those assignments
that set exactly k of the atoms to true are to be considered. An instance of the weighted quantiﬁed satisﬁability
problem consists of a Boolean formula φ over the set PR of propositional atoms, a partition PR1, . . . , PRℓ of PR
and numbers k1, . . . , kℓ. The goal is to check if pDk1PR1@k2 PR2 ¨ ¨ ¨ φq is true.

Lemma 4.11. Given an instance of the weighted quantiﬁed satisﬁability problem, We can construct in polynomial
time a data graph G and an REWB e1

1`k2`k4`¨¨¨ satisfying the following conditions.

1. The source of G is connected to its sink by a data path in Lpe1

1`k2`k4`¨¨¨q iﬀ the given instance of the weighted

quantiﬁed satisﬁability problem is a yes instance.

2. The size of e1

1`k2`k4`¨¨¨ depends only on k1, . . . , kℓ.

Proof idea. The required data graph G is GrDk1{PR1s ˝ Gr@k2{PR2s ˝ ¨ ¨ ¨ ˝ Gφ and the required REWB e1
1`k2`k4`¨¨¨
is erDk1s ˝ er@k2s ˝ ¨ ¨ ¨ ˝ eeval rk1 ` ¨ ¨ ¨ ` kℓs. We assume that ˝ associates to the right, so G1 ˝ G2 ˝ G3 is G1 ˝ pG2 ˝ G3q
and e1 ˝ e2 ˝ e3 is e1 ˝ pe2 ˝ e3q. Correctness follows from Lemma 4.10 and Lemma 4.5.

10

The weighted quantiﬁed satisﬁability problem is parameterized by ℓ ` k1 ` ¨ ¨ ¨ ` kℓ. The class AW[SAT] is the

set of parameterized problems that are FPT-reducible to the weighted quantiﬁed satisﬁability problem.

Theorem 4.12. Evaluating REWB queries, parameterized by the size of the query is hard for AW[SAT] under
FPT reductions.

Proof. The reduction given in Lemma 4.11 is a FPT reduction from the weighted quantiﬁed satisﬁability problem
to the problem of evaluating REWB queries, with query size as the parameter.

5 Summary and Discussion

We have proved that increasing the depth of nesting of iterated bindings in REWBs increase expressiveness. Given
an REWB, it is undecidable to check if its language can be deﬁned with another REWB with smaller depth of
nesting of iterated bindings. The complexity of query evaluation problems are summarized in the following table,
followed by a list of technical challenges to be overcome for closing the gaps.

Query level Evaluation

Parameterized complexity, query size is parameter

NP-complete
E1
Ei, i ą 1
(?1), Σi upper bound
Unbounded Pspace-complete [14]

(?2) W[SAT] lower bound, W[P] upper bound
(?3)
(?4) AW[SAT] lower bound, uniform-XNL upper bound

1. Suppose we want to check the satisﬁability of a Σ2 Boolean formula over pne ` nuq propositional atoms of
which the ﬁrst ne atoms are existentially quantiﬁed and the last nu are universally quantiﬁed. With currently
known techniques, reducing this to query evaluation results in an REWB in Epnu`1q. Hence, with bounded
nesting depth, we cannot even prove a Σ2 lower bound.

2. Weighted formula satisﬁability, complete for W[SAT], can be simulated with series-parallel graphs. Queries

in E1 do not seem to be powerful enough for weighted circuits.

3. Without parameterization, the Σi upper bound is obtained by an oracle hierarchy of NP machines. With
parameterization, an oracle hierarchy of W[P] machines does not correspond to any parameterized complexity
class. See [3, Section 4] for discussions on subtle points which make classical complexity results fail in
parameterized complexity.

4. As in point 2, here one might hope for a AW[P] lower bound, which is quantiﬁed weighted circuit satisﬁability
(stronger than AW[SAT], which is quantiﬁed weighted formula satisﬁability). Even if this improvement can
be made, there is another classical complexity result not having analogous result in parameterized complexity:
not much is known about the relation between parameterized alternating time bounded class (AW[P]) and
parameterized space bounded class (uniform-XNL).

Acknowledgements The authors thank Partha Mukhopadhyay and Geevarghese Philip for helpful discussions
about polynomial time hierarchy and parameterized complexity theory.

References

[1] P. Barcel´o. Querying graph databases. In Proceedings of PODS, pages 175–188, New York, NY, USA, 2013.

ACM.

[2] P. Barcel, J. Reutter, and L. Libkin. Parameterized regular expressions and their languages. Theoretical

Computer Science, 474:21–45, 2013.

11

[3] Yijia Chen, J. Flum, and M. Grohe. Bounded nondeterminism and alternation in parameterized complexity

theory. In Computational Complexity, 2003, pages 13–29, 2003.

[4] T. Colcombet and A. Manuel. Generalized data automata and ﬁxpoint logic. In FSTTCS, volume 29 of LIPIcs,

pages 267–278, Dagstuhl, Germany, 2014. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.

[5] T. Colcombet and A. Manuel. Combinatorial expressions and lower bounds. In STACS, volume 30 of LIPIcs,

pages 249–261, Dagstuhl, Germany, 2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.

[6] T. Colcombet and A. Manuel. Fragments of ﬁxpoint logic on data words. In FSTTCS, volume 45 of LIPIcs,

pages 98–111, Dagstuhl, Germany, 2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.

[7] R. De Haan, M. Kronegger, and A. Pfandler. Fixed-parameter tractable reductions to sat for planning. In
Proceedings of the 24th International Conference on Artiﬁcial Intelligence, IJCAI’15, pages 2897–2903. AAAI
Press, 2015.

[8] L. C. Eggan. Transition graphs and the star-height of regular events. Michigan Math. J., 10(4):385–397, 1963.

[9] O. Grumberg, O. Kupferman, and S. Sheinvald. Variable automata over inﬁnite alphabets. In A-H. Dediu,
H. Fernau, and C. Martn-Vide, editors, Language and Automata Theory and Applications, volume 6031 of
LNCS, pages 561–572. Springer Berlin Heidelberg, 2010.

[10] C. Gutierrez, C. Hurtado, and A. Mendelzon. Foundations of semantic web databases. JCSS, 77(3):520–541,

2011.

[11] E.V. Kostylev, J.L. Reutter, and D. Vrgoˇc. Containment of data graph queries. In ICDT, pages 131–142, 2014.

[12] U. Leser. A query language for biological networks. Bioinformatics, 21(suppl 2):ii33–ii39, 2005.

[13] L. Libkin, W. Martens, and D. Vrgoˇc. Querying graph databases with xpath. In ICDT, pages 129–140, New

York, NY, USA, 2013. ACM.

[14] L. Libkin, T. Tan, and D. Vrgoˇc. Regular expressions with binding over data words for querying graph

databases. In DLT, volume 7907 of LNCS, pages 325–337, 2013.

[15] L. Libkin and D. Vrgoˇc. Regular path queries on graphs with data. In ICDT, pages 74–85, 2012.

[16] F. Neven, T. Schwentick, and V. Vianu. Finite state machines for strings over inﬁnite alphabets. ACM Trans.

Comput. Logic, 5(3):403–435, 2004.

[17] J. P´erez, M. Arenas, and C. Gutierrez. Semantics and complexity of SPARQL. ACM Trans. Database Syst.,

34(3), 2009.

[18] W3C Recommendation. Sparql 1.1 query language. 21 March 2013.

[19] R. Ronen and O. Shmueli. Soql: A language for querying and creating data in social networks. In ICDE, pages

1595–1602, 2009.

[20] L. Segouﬁn. Automata and logics for words and trees over an inﬁnite alphabet. In Z. ´Esik, editor, Proceedings

of CSL, volume 4207 of LNCS, pages 41–57, Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.

[21] T. Tan. Graph reachability and pebble automata over inﬁnite alphabets. ACM Trans. Comput. Logic,

14(3):19:1–19:31, 2013.

[22] D. Vrgo. Using variable automata for querying data graphs. Information Processing Letters, 115(3):425–430,

2015.

12

A Details of Section 3

This section contains complete proofs and explanations from Section 3. We start with the semantics of the automaton
view of expressions.

A.1 Automata View of Expressions

i q. Let ν be a valuation of fv pf 1

i q. A run of Apf 1
i q

Consider an expression f 1

over a data word w “ `a1

i , and its corresponding automaton Apf 1
d1˘`a2

dn˘ given valuation ν is as follows:
wm´1ÝÝÝÝÝÑ qm´1
w1ÝÝÝÑ q1

d2˘ . . .`an

w2ÝÝÝÑ ¨ ¨ ¨

q0

wmÝÝÝÑ qm

where:

• q0 is an initial state,

• w “ w1w2 . . . wm,

• if i “ 0 then m “ n and for each j, we have wj “ `aj

aj rcs

dj˘. Moreover, for each j, there exists a transition

qj´1

ajÝÝÝÑ qj or qj´1

ÝÝÝÝÑ qj such that dj, ν |ù c,

• if i ą 0, then for each j there exists a transition qj´1

ej
iÝÝÑ qj such that wj P Lpej

i , νq.

i q has an accepting run given valuation ν. Notice that if f 1

The run is accepting if qm is an accepting state of the automaton. The language LpApf 1

i q, νq is the set of words
for which Apf 1
i , the scope of variables bound
in e1
i . This is reﬂected in the
automaton view. In the runs, we do not keep track of the valuations of variables bound inside the Ei sub-expressions.
i q on a data word w is deﬁned as:

i . Hence the valuation of those variables need not be carried over to e2

i and a valuation ν of its free variables, the run of Ape1

Given an expression e1

i end inside e1

i “ e1

i ¨ e2

pq0, ν0q w1ÝÝÝÑ pq1, ν1q w2ÝÝÝÑ ¨ ¨ ¨

wm´1ÝÝÝÝÝÑ pqm´1, νm´1q wmÝÝÝÑ pqm, νmq

where

• q0 is an initial state,

• each wj is a data word such that w “ w1w2 . . . wm,

• each νj is a valuation of variables with ν0 “ ν,

• for each j, either wj “ `a

d˘ and there is a transition qj´1

f j
i´1ÝÝÝÝÑ qj with wj P Lpf j

transition qj´1

i´1, νj´1q, and νj “ νj´1

aÓxÝÝÝÑ qj and νj “ νj´1rx Ñ ds, or there is a

The notion of acceptance and language LpApe1
can be shown by an induction on i.

i q, νq are deﬁned in a way similar to the Fi case. The following lemma

Lemma A.1. For every expression f 1
i , and for every valuation ν of fv pf 1
are equal. Similarly for expressions e1
i .

i q, the languages Lpf 1

i , νq and LpApf 1

i q, νq

For any expression e, the size of Apeq is deﬁned as the number of states present.

13

A.2 Strictness of the Hierarchy

Using the semantics of the automata developed above, we will give a full proof of Lemma 3.2.
Lemma 3.2. Let e1
sub-expression e of e1
xui,nz P Lpe1

i be an expression and let n P N be greater than p|Apeq| ` 1q and p|fv peq| ` 1q for every
i . Let ν be a valuation of fv pe1
i , νq ùñ

i q and let x, z be data words. Then: xui,nz P Lpe1

i , νq for some ui,n P Mismatch i,n.

Proof. We proceed by an induction on i. We start with the base case. Suppose xu1,nz P Lpe1
e1
1 with maxp|Ape1

1q|q ă n. The automaton Ape1

1q has an accepting run of the following form:

1q|, |fv pe1

1, νq for some expression

Run ρ1 :

pq0, ν0q w1ÝÝÝÑ pq1, ν1q w2ÝÝÝÑ ¨ ¨ ¨

wm´1ÝÝÝÝÝÑ pqm´1, νm´1q wmÝÝÝÑ pqm, νmq

where xu1,nz “ w1w2 . . . wm. Recall that automata for E1-expressions are acyclic, so states cannot repeat in a run.
Since the number of states is strictly less than n and u1,n contains 2n2 occurrences of a1b1, there is some wp which
contains 2n occurrences of a1b1:

a1

dr1, j ` 1s˙ˆ
ˆ

b1

dr1, j ` 1s˙ . . .ˆ

a1

dr1, j ` ns˙ˆ

b1

dr1, j ` 2ns˙

Then by deﬁnition of runs of Ape1

1q:

• there is a transition qp´1

f 1
0ÝÑ qp in Ape1

1q with wp P Lpf 1

0 , νp´1q and

• valuation νp equals νp´1 since the transition qp´1 ÝÑ qp does not contain a binding.

Note that the valuation νp´1 contains bindings to the free variables and the variables bound along the run ρ1.
As no state repeats in the run ρ1, the length of the run is strictly less than n and hence the number of bindings
that could have occurred till position p is strictly less than n. Moreover, we know that the number of free variables
in e1

i is bounded by n. Therefore there can be at most 2n ´ 1 distinct data values in Rangepνp´1q.
Note that by assumption n is strictly bigger than |Apf 1

0 q|. Let us now zoom in to the accepting run

0 q| and |fv pf 1

of Apf 1

0 q on the sub-word wp.

Run σ1 :

w1
1ÝÝÝÑ q1
1

q1
0

w1

2ÝÝÝÑ ¨ ¨ ¨

w1
s´1ÝÝÝÝÑ q1

s´1

w1
sÝÝÝÑ q1
s

aÝÝÑ q1

arcs

1w1

2 . . . w1

with wp “ w1
ÝÝÝÑ qj
with letter a denoting either a1 or b1. Note that there can be no further bindings in this level F0. So, each condition
arcs in a transition can check for equality or inequality with respect to data values in Rangepνp´1q. Consider the

s. Each transition reads a single letter: that is, it is of the form q1

j or qj´1

j´1

transitions reading b1. As there are at most 2n ´ 1 data values in Rangepνp´1q, there is some ` b1
that dr1, j1s is diﬀerent from all values in Rangepνp´1q. Therefore, changing dr1, j1s in ` b1

dr1,j1s˘ in wp such
dr1,j1s˘ to a new data value
d1r1, j1s R Rangepνp´1q will give a data word which continues to satisfy all conditions occurring in the run σ1 of
Apf 1
0 q. The run ρ1 is oblivious to this change. This is because there are no bindings in σ1 and hence the valuation
νp is the same as νp´1. Hence the same run ρ1 of Ape1
1q accepts this modiﬁed word. Observe that in this word there
is a mismatch between an a1 and the consecutive b1 occurring in u1,n and is of the form xu1,nz as required by the
lemma. This proves the lemma for the base case i “ 1.

We will now prove the induction step. Assume that the lemma is true for some i ´ 1. We will now prove it for
i with the value n being an upper
i q on xui,nz:

i. Consider the word xui,nz. Suppose it belongs to Lpe1
bound on |Apeq| ` 1 and |fv peq| ` 1 for every subexpression e of e1

i . Let ρi be the accepting run of Ape1

i , νq for some expression e1

Run ρi :

pq0, ν0q w1ÝÝÝÑ pq1, ν1q w2ÝÝÝÑ ¨ ¨ ¨

wm´1ÝÝÝÝÝÑ pqm´1, νm´1q wmÝÝÝÑ pqm, νmq

14

with xui,nz “ w1w2 . . . wm. Since the automaton Ape1
i q is acyclic, no state can repeat in ρi. As the number of
states is less than n and ui,n contains 2n2 occurrences of aiui´1,nbi, some wp contains 2n occurrences of the block
aiui´1,nbi:

ai

dri, j ` 1s˙ui´1,nˆ
ˆ

bi

dri, j ` 1s˙ ¨ ¨ ¨ ˆ

ai

dri, j ` 2ns˙ui´1,nˆ

bi

dri, j ` 2ns˙

Then, by deﬁnition of runs of Ape1

i q:

• there is a transition qp´1

• νp “ νp´1.

f 1
i´1ÝÝÝÑ qp in Ape1

i q with wp P Lpf 1

i´1, νp´1q and

Due to the same reasons as those seen in the base case, Rangepνp´1q contains at most 2n ´ 1 distinct data

values. Consider the run of Apf 1

i´1q on wp given valuation νp´1:

Run σi :

w1
1ÝÝÝÑ q1
1

q1
0

w1

2ÝÝÝÑ ¨ ¨ ¨

w1
s´1ÝÝÝÝÑ q1

s´1

w1
sÝÝÝÑ q1
s

where wp “ w1
If some w1

2 . . . w1
s.

1w1
j contains ui´1,n entirely, then this w1

j belongs to the language of Lpe1

e1
i´1. This is as per the deﬁnition of runs of Fi automata. Additionally, e1
i´1 is a subexpression of e1
satisﬁes the condition that n is bigger than |Apeq| ` 1 and |fv peq| ` 1 for every subexpression e of e1
then use the induction hypothesis to infer that there is a mismatched word in Lpe1
w1

j with this mismatched word to obtain the same runs σi and ρi, thus proving the lemma for this case.

i´1, νp´1q for some expression
i and hence
i´1. We can
i´1, νp´1q. Hence we can replace

Otherwise, no w1

j contains both ` ai

distinct data values, there is one ` bi

dri,js˘ and ` bi
i´1 be the sub-expression in the transition q1

dri,js˘ of a block aiui´1,nbi. As Rangepνp´1q has at most 2n ´ 1
dri,js˘ such that dri, js is not present in Rangepνp´1q. Let this be present in w1

k,
and let ek
i´1, νp´1q. Consider a fresh data value
d1 R Rangepνp´1q and which is diﬀerent from every data value in w1
k to this
fresh data value d1. The modiﬁed word belongs to Lpek
i´1, νp´1q (this can be shown by a structural induction for
general REWBs). Therefore the run σi holds for the word wp with w1
k modiﬁed to this new word. Moreover, as
discussed in the base case, the run ρi is not aﬀected by this change as the valuation νp is the same as νp´1. This
gives a word with a mismatch between an ai and the corresponding bi that is accepted by e1
i , thereby proving the
lemma.

k. Change all occurrences of dri, js in w1

k´1 ÝÑ q1

k with w1

k P Lpek

A.3 Undecidability of Membership at a Given Level

This section is devoted to proof of the following theorem.
Theorem 3.4. Given an expression in Fi`1, checking if there exists an equivalent expression in Fi is undecidable.

The basic idea is from the proof of undecidability of universality of REWBs and related formalisms [16, 14].
If a given REWB is universal, i.e., accepts all data words, then there is a language equivalent expression that
does not use any binding. The undecidability of universality can hence be interpreted to mean that determining
the usefulness of bindings in an expression is undecidable. We combine this insight with results we have obtained
for the expressions ri in the previous sub-section to prove Theorem 3.4. We proceed by a reduction from Post’s
Correspondence Problem (PCP). An instance of PCP is a set tpu1, v1q, pu2, v2q, . . . , pun, vnqu of pairs of words over
a ﬁnite alphabet ΣP CP . A solution to this instance is a sequence l1, l2, . . . , lm with each lj P t1, . . . , nu such that
ul1 ul2 . . . ulm “ vl1 vl2 . . . vlm.

15

Suppose we are given an instance tpu1, v1q, pu2, v2q, . . . , pun, vnqu of PCP. We will encode a solution l1, . . . , lm

to this instance by a set of data words of the form:

θ1 ˆ#

d1˙ z ˆ#

d2˙ θ2

where:

• z P Lpriq, with ri being the expression in Deﬁnition 3.1,

• θ1 is the data word:

ˆ$l1
h1˙ˆα1

1 ˙ . . .ˆαp

p ˙ˆ$l2

h2˙ˆαp`1

p ` 1˙ . . . ˆ$lm

r ˙
hm˙ . . .ˆαr

where the word αs . . . αt between $lj and $lj`1 equals the word ulj ,

• θ2 is the data word:

ˆ$l1
h1˙ˆβ1

1 ˙ . . .ˆβq

q ˙ˆ$l2

h2˙ˆ βq`1

q ` 1˙ . . . ˆ$lm

r ˙
hm˙ . . .ˆβr

where the word βs . . . βt between $lj and $lj`1 equals the word vlj ,

• the data values t1, . . . , r, d1, d2, h1, . . . , hmu are all distinct.

We will ﬁrst construct an expression ∆ that accepts all words of the form w1` #

that the part w1# #w2 does not satisfy the conditions mentioned above. The expression ∆ will be in Ei`1. We
will then reason that this expression will have an equivalent expression in Fi iﬀ PCP has no solution.

d2˘w2 with z P Lpriq such

d1˘z` #

Let Γ denote the ﬁnite alphabet ΣP CP Y t$1, . . . , $n, #u. We will now exhaustively reason about the situations

when a word w1` #

above.

d1˘z`#

d2˘w2 is not an encoding of the PCP solution. This will give us the expression ∆ mentioned

• Projection of the word on to the ﬁnite alphabet is not of the form p$1u1 ` ¨ ¨ ¨ ` $nunq˚ # z # p$1v1 `
¨ ¨ ¨ ` $nvnq˚. Let φ1 and φ2 be the regular expressions denoting the complement of p$1u1 ` ¨ ¨ ¨ ` $nunq˚ and
p$1v1 ` ¨ ¨ ¨ ` $nvnq˚ respectively. The required expression that accepts words with a mistake in the ﬁnite alphabet
is φ1 # ri # Γ˚ ` Γ˚ # ri # φ2. Note that this expression is at the same level as ri since ri is not in the scope
of any binding.

• Words where the data values are not according to the encoding. Firstly, words of the form ¨ ¨ ¨`#

where d or d1 repeat. Expression accepting words where d repeats is given by:

d˘ z `#

d1˘ ¨ ¨ ¨

pΓ˚a Óx p Γ˚ #rx“s q ri Γ˚ ` Γ˚# Óx p ri Γ˚arx“s Γ˚qq

ăaPΓ

A similar expression can be given for the case where d1 repeats. Since these expressions add a binding over ri, they
are in Ei`1.

• Words of the form ¨ ¨ ¨`˚
form ¨ ¨ ¨ # z # ¨ ¨ ¨`˚
d˘ ¨ ¨ ¨`˚
ăa,bPΓ

d˘ ¨ ¨ ¨`˚
d˘ ¨ ¨ ¨ where values repeat after # z #

d˘ ¨ ¨ ¨ # z # ¨ ¨ ¨ where a data value repeats before the # z # and words of the

pΓ˚a Óx p Γ˚ brx“s Γ˚q # ri # Γ˚ ` Γ˚ # ri # Γ˚a Óx p Γ˚ brx“s Γ˚qq

• Note that in the encoding of the solution, the data values in the jth dollar symbol before and after # z #
need to be the same. We will now consider words where this is not true. Let us ﬁrst look at words where the
mismatch occurs either in the ﬁrst dollar symbol or in the last dollar symbol.

ă$,$1Pt$1,...,$nu

p$ Óx pΓ˚ # ri # $1rx‰sq Γ˚ ` Γ˚$ Óx p Σ˚

P CP # ri # Γ˚ $1rx‰s qΣ˚

P CP q

16

Suppose the ﬁrst dollar symbols to the left and right of #z# have the same data value, and so do the last dollar
symbols. In this case, if there some j such that the jth dollar symbol to the left and right of #z# have diﬀerent
data values, the data word is of the following form.

¨ ¨ ¨ˆδ1

d˙ Σ˚

P CP ˆδ2

d1˙ ¨ ¨ ¨ # z # ¨ ¨ ¨ˆδ3

d˙ Σ˚

P CP ˆδ4

d2˙ ¨ ¨ ¨

where δ1, δ2, δ3, δ4 P t$1, . . . , $nu and d1 ‰ d2. There is a data value d occurring with a dollar on both sides, and
the data values attached with next dollar symbols on the two sides do not match. The expression for such words is
given by:

ăδ1,...,δ4Pt$1,...,$nu

pΓ˚ δ1 Óx p Σ˚

P CP δ2 Óy p Γ˚ # ri # Γ˚ δ3rx“s Σ˚

P CP δ4ry‰s q q Γ˚q

• Now we will consider words where the mismatch of data values occurs in a non-dollar position. We start

with the expression for words with a mismatch in the ﬁrst or last non-dollar position:

ă

δ1,δ2Pt$1,...,$nu,a,bPΣP CP

δ1 a Óx pΓ˚ # ri # δ2 brx‰sqΓ˚ ` Γ˚a Óx p# ri # Γ˚ brx‰sq

For detecting mismatch at an intermediate position, we resort to the same idea as in the previous case. We consider
words of the form:

¨ ¨ ¨ˆα1

d ˙ pε ` δ1q ˆα2

d1˙ ¨ ¨ ¨ # ri # ¨ ¨ ¨ˆα3

d ˙ pε ` δ2q ˆα4

d2˙ ¨ ¨ ¨

The expression for such words is given by:

δ1,δ2Pt$1,...,$nu,α1,...,α4PΣP CP

ă

Γ˚α1 Óx ppε ` δ1q α2 Óy pΓ˚#ri#Γ˚α3rx“s pε ` δ2q α4ry‰sqqΓ˚

• We are now left with words where the data values on every corresponding position before and after # z #
match. Among these words, the non-solutions are the ones where for a particular data value occurring on both
sides of # z #, the corresponding letters do not match. The expression for such words is given by:

Γ˚ γ1 Óx p Γ˚ # ri # Γ˚ γ2rx“s q Γ˚

ăγ1‰γ2

The required expression ∆ is the sum of all the above expressions. Note that ∆ has a binding made on the left
side of # ri # that is checked on the right side. This makes expression ∆ to fall in Ei`1 as expression ri is in Fi.

Lemma A.2. The expression ∆ has an equivalent expression in Fi iﬀ the given PCP instance has no solution.

Proof. Suppose PCP instance has no solution. Then all words of the form w1 # z # w2 with w1, w2 P Γ˚ and
z P Lpriq are in the language of the expression ∆. Therefore an equivalent expression for ∆ is Γ˚ # ri # Γ˚. This
expression is in Fi as the expression ri is in Fi.

Suppose PCP instance has a solution. Let us assume that ∆ has an equivalent expression f 1

this leads to a contradiction. For technical convenience, let us assume that f 1
free variables can be handled in a similar way). Let n be a natural number such that |Apf 1
θ1 # ui,n # θ2 that encodes the solution of the PCP instance. Let θ1
modifying the last data value to a fresh data value not occurring in θ1 # ui,n # θ2. Then, θ1 # ui,n # θ1
encode any solution and hence belongs to Lp∆q. Let us now look at the run of Apf 1

i . We will show that
i has no free variables (the case with
i q| ă n. Consider a word
2 be a new data word obtained from θ2 by
2 does not
i q on the word θ1 # ui,n # θ1
2:

q0

w1ÝÝÝÑ q1

w2ÝÝÝÑ ¨ ¨ ¨

wm´1ÝÝÝÝÝÑ qm´1

wmÝÝÝÑ qm

17

where w1w2 . . . wm “ θ1 # ui,n # θ1
2.

i q, there is some subexpression e1

If some wp contains ui,n entirely, then by deﬁnition of runs of Apf 1

i and a word
i q. Note that we assumed that there are no free variables. Then, by Lemma 3.2
i q where ui,n contains a mismatch. However, by deﬁnition of ∆, this is not possible.
2 lie in diﬀerent wj: in particular,
2 and moreover does not contain any part of θ1. Hence, data
i q for
i . Changing the last data value of wm back to the value in θ2 will result in a word which is
i q. This shows that the same run of
i q can accept θ1 # ui,n # θ2 which encodes a solution of the PCP instance. Therefore the expression supposed

xui,nz such that xui,nz P Lpe1
there is a word xui,nz P Lpe1
Therefore no wp can contain ui,n entirely. This would then imply that θ1 and θ1
the last part of the run wm contains the last letter in θ1
values in θ1
some subexpression e2
an automorphic copy of wm and hence this modiﬁed word should also lie in Lpe2
Apf 1
to be equivalent to ∆ accepts a solution of the PCP instance. A contradiction.

2 are never compared with those in θ1. Note that by the deﬁnition of runs, the word wm P Lpe2

The above lemma proves Theorem 3.4. The expression ∆ is in Ei`1 (and hence in Fi`1). Checking if it has an

equivalent expression in Fi is undecidable as this can encode PCP.

B Details of Section 4

B.1 Upper Bounds

We ﬁrst introduce some normal forms for expressions in Ei. Let Ui be the set of REWBs generated by the grammar
Ui ::“ Fi´1 | Ui ¨ Ui | a Óx pUiq. An expression in Ei is said to be in Union Normal Form (UNF) if it is of the form
u1
i ` u2
i is an expression in Ui for every j P t1, . . . , ru. From the semantics of REWBs, we infer
that binding and concatenation distribute over union. By repeatedly applying this fact to any expression in Ei, we
get the following result.

i , where uj

i ` ¨ ¨ ¨ ` ur

Proposition B.1. For every expression e1
such that |Apuj

i q| ď |Ape1

i q| for every j P t1, . . . , ru.

i in Ei, there exists a language equivalent one u1

i ` u2

i ` ¨ ¨ ¨ ` ur

i in UNF

Lemma 4.1. With an oracle for evaluating Ei queries, Fi queries can be evaluated in polynomial time.

i be the query to be evaluated and ν be the given valuation for fv pf 1

i of f 1

i , check if xv1, v2y P e1

i q. For
i rνspGq by calling the oracle.

Proof. Let G be the given data graph, f 1
every pair xv1, v2y of nodes in G and every sub-expression e1
Draw an edge labeled e1

Perform the standard product construction of Apf 1

in Ei as a single letter). A pair xv, v1y belongs to f 1
where qf and q0 are some ﬁnal and initial states of Apf 1

i from v1 to v2 iﬀ the oracle answers positively. Call the resulting data graph G1.

i q with G1 (this can be done since G1 also treats sub-expressions
i rνspGq iﬀ pv1, qf q is reachable from pv, q0q in the product system,

i q respectively.

For the case of F0, the only sub-expressions that can not be handled directly by standard automata are those
of the form arcs. Given the evaluation ν, such expressions can be evaluated in linear time. Hence, in this case, the
above procedure takes polynomial time without any oracle.

Theorem 4.2. For queries in Ei, the evaluation problem belongs to Σi.

Proof. By induction on i. For the base case i “ 1, let e1
for the free variables of e1
expression e2
by recursion on the structure of u1

1 be the given expression and let ν be the given valuation
1. We begin by non-deterministically choosing one of the sub-expressions for every sub-
1rνspGq, we proceed

1 in U1. Now, to check if xv, v1y P u1

1. This will result in an expression u1

1 of e1

1 ` e3

1 as follows.

• To check if xv1, v2y P pu2

1 ¨ u3

1qrνspGq, we non-deterministically guess a node v3 and recursively check that

xv1, v3y P u2

1rνspGq and xv3, v2y P u3

1rνspGq.

• To check if xv1, v2y P a Óx pu2

data value d of the a-labeled edge from v1 to v3. Next we recursively check that xv3, v2y P u2

1qrνspGq, we non-deterministically choose an a-successor v3 of v1 and note the
1rνrx Ñ dsspGq.

18

• To check if xv1, v2y P f 1

0 rνspGq for some expression f 1

0 in F0, we proceed as in the proof of Lemma 4.1.

Next we inductively assume that evaluating expressions in Ei is in Σi. To evaluate expressions in Ei`1, we
proceed in the same way as in the base case. The only diﬀerence is in the case where we have to check xv1, v2y P
f 1
i rνspGq for some expression f 1
in Fi. From Lemma 4.1, this can be done in polynomial time with an oracle for
i
evaluating expressions in Ei. Since, by induction hypothesis, the oracle itself is in Σi, we conclude that evaluating
expressions in Ei`1 is in Σi`1.

Lemma B.2. Suppose e1
valuation for fv pe1
is such a data path of length at most pk2nqi.

i is an expression in Ei, with |Apeq| ď k for every sub-expression e of e1

i . Let ν be a
i , νq connecting v1 to v2 in a data graph with n nodes, then there

i q. If there is a data path in Lpe1

0 , the automaton Apf 1

Proof. By induction on i. For the base case i “ 1, we begin by giving short witnesses for subexpressions of e1
1. For
a subexpression f 1
0 q will have at most k states. Since the valuation does not change, we can
infer from standard pumping arguments that if a data path in the language of f 1
0 connects v1 to v2, there is such
a data path of length at most kn. Next we consider e1
1, we infer
from Proposition B.1 that there is an expression u1
1 that contains w in its language. The path w may be split into
sub-paths, each of which is in the language of some sub-expression of u1
1q| ď k,
the number of such sub-expressions, and hence the number of sub-paths in w, is at most k. We have already seen
that each sub-path can be replaced by one of length at most kn. Hence, the total length of the path is at most k2n.

1. For every data path w in the language of e1

1 or a Óx. Since |Apu1

1, of the form f 1

The induction step is similar, contributing a multiplicative factor of k2n. Hence the result follows.

Theorem 4.3. Evaluating REWB queries in E1, parameterized by the size of the query is in W[P].

Proof. We will use [3, Lemma 7, Theorem 8], which give machine characterizations for problems in W[P]. They
prove that a parameterized problem is in W[P] iﬀ there is a non-deterministic Turing machine that takes an instance
px, kq and decides the answer within f pkq|x|c steps, of which at most f pkq log |x| are non-deterministic (for some
computable function f and a constant c). Such a Turing machine exists for evaluating REWB queries in E1. In such
queries, every binding in the query is performed at most once in a path (since bindings are not iterable). Hence, the
machine can ﬁrst non-deterministically choose the data values for each binding in the query in the allowed number
of non-deterministic steps. Then the expression can be treated as a standard regular expression, by substituting
the guessed data values for the bindings. The set of data values found in the data graph can be considered as a
ﬁnite alphabet and evaluation can be done in polynomial time using standard automata theoretic techniques.

Just like we get W[P] from W[SAT] by replacing formulas with circuits, we get AW[P] from AW[SAT] by
replacing formulas with circuits. It has been proved in [3, Theorem 17] that a parameterized problem is in AW[P]
iﬀ there is an alternating Turing machine that takes an instance px, kq and decides the answer within f pkq|x|c steps,
of which at most f pkq log |x| are existential or universal (let us call such machines AW[P] machines). We have
seen in Theorem 4.3 that evaluating REWB queries in E1 can be done by non-deterministic Turing machines with
bounded non-determinism (let us call them W[P] machines). As we did in Theorem 4.2, we can evaluate REWB
queries in Ei using an oracle hierarchy of height i, consisting of W[P] machines. In complexity theory, an oracle
hierarchy of NP machines is known to be equivalent to an alternating Turing machine. It is tempting to draw
an analogous conclusion in parameterized complexity theory, saying that an oracle hierarchy of W[P] machines is
equivalent to an AW[P] machine. However, we have not been able to prove such an equivalence for the following
reason. In order to simulate oracle calls in an alternating machine, one generally needs as many non-deterministic
steps as the number of calls to the oracle. In the oracle hierarchy of W[P] machines, the number of calls to an
oracle may be polynomial in the size of the input, but the number of non-deterministic steps allowed in AW[P]
machines is logarithmic in the size of the input. We refer the interested reader to [3, Section 4] for some discussions
on how some results in complexity theory fail in parameterized complexity theory.

For the query evaluation problem, we do not have upper bounds in parameterized alternating time bounded

classes. However, we can get an upper bound in uniform-XNL, a parameterized space bounded class.
Theorem 4.4. Evaluating REWB queries, with size of the query as parameter, is in uniform-XNL.

19

Proof. We give a space bounded non-deterministic algorithm. Suppose n is the size of the data graph and k is the
size of the expression and a pair of nodes is connected by a data path in the language of the expression. We know
from Lemma B.2 that there is such a data path of length at most ppgpkqq2nqk, where gpkq is an upper bound on
|Apeq| for any REWB e of size k. A non-deterministic algorithm can guess and verify such a data path. It would
have to store a counter to keep track of the length of the path, a valuation for variables in the expression and a
node of the graph. All this needs space at most Oppgpkqq2 log nq.

B.2 Lower Bounds

Let φ be a Boolean formula over the propositional atoms pr 1, . . . , pr n and ν : tx1, . . . , xku Ñ
Lemma 4.5.
tpr 1, . . . , pr n, ˚u be a valuation. The source of Gφ is connected to its sink by a data path in Lpeevalrks, νq iﬀ φ is
satisﬁed by the truth assignment that sets exactly the propositions in tpr 1, . . . , pr nu X Rangepνq to true.

Proof. By induction on the structure of the Boolean formula. Suppose φ is a positively occurring atom pr j, satisﬁed
˚q
p b
ÝÝÑ

by the truth assignment. Hence, the data value pr j is in tνpx1q, . . . , νpxkqu. So the data path ¨

neq
p a
ÝÝÑ ¨

p a
poq
ÝÝÑ ¨

ppn ?
po q
ÝÝÝÑ ¨

p pv
pr jq
ÝÝÝÑ ¨

k se, νq, giving the desired data path in Gφ.
¨
Conversely, suppose that the source of Gφ is connected to its sink by a data path in Lpeevalrks, νq. Since eeval rks

pos ¨ pv rx“

1 _ ¨ ¨ ¨ _ x“

p e
˚q
ÝÝÑ ¨ is in Lpa Óxpo a Óxne b ¨ pn?rx“

neq
p a
ÝÝÑ ¨, xpo, xne will have the values po, ne respectively. To

begins with a Óxpo a Óxne and Gφ begins with ¨
po q
ppn ?
ÝÝÝÑ ¨

˚q
p b
ÝÝÑ ¨

poq
p a
ÝÝÑ ¨
p pv
pr jq
ÝÝÝÑ ¨

k se, νq.
reach the sink of Gφ, the data path ¨
This implies that the data value pr j is in tνpx1q, . . . , νpxkqu, which in turn implies that φ is satisﬁed by the
truth assignment. The argument is similar for a negatively occurring propositional atom. The induction steps are
standard arguments based on the semantics of Boolean formulas.

pos ¨ pv rx“

1 _ ¨ ¨ ¨ _ x“

˚q
p e
ÝÝÑ ¨ has to be in Lpb ¨ pn?rx“

Theorem 4.6. For queries in E1, the evaluation problem is NP-hard.

Proof. We will reduce the satisﬁability problem for Boolean formulas to the query evaluation problem. Suppose φ
is a Boolean formula over the propositional atoms pr 1, . . . , pr n. The data graph is as follows.

` a
pr 1˘
`a
˚˘

u

` a
pr 2˘
`a
˚˘

` a
pr n˘
`a
˚˘

Gφ

v

The ellipse at the end denotes the data graph Gφ corresponding to the Boolean formula φ, along with its source and
and sink nodes. The query to be evaluated on this is a Óx1 a Óx2 ¨ ¨ ¨ a Óxn eeval rns. To avoid too many parenthesis,
we have not shown the scope of bindings. The scope of every binding extends till the end of the expression. We
claim that the pair xu, vy is in the result of the query iﬀ φ is satisﬁable. Indeed, suppose xu, vy is in the result of
the query. The data path from u to v will have two parts. The ﬁrst one in Lpa Óx1 a Óx2 ¨ ¨ ¨ a Óxnq from u to
the source of Gφ, resulting in a valuation ν : tx1, . . . , xnu Ñ tpr 1, . . . , pr n, ˚u. The second part is in Lpeevalrns, νq,
connecting the source of Gφ to its sink. From Lemma 4.5, φ is satisﬁed by the truth assignment that sets pr j to
true iﬀ νpxj q “ pr j. Conversely, suppose φ is satisﬁed by some truth assignment α : tpr 1, . . . , pr nu Ñ ttrue, falseu.

Consider the data path from u to the source of Gφ that takes the edge labeled ` a
the edge labeled `a

pr j˘ if αppr jq “ true and takes
˚˘ otherwise. This path is in Lpa Óx1 a Óx2 ¨ ¨ ¨ a Óxnq and results in a valuation ν such that

Rangepνq X tpr 1, . . . , pr nu is precisely the set of propositional atoms set to true by the truth assignment α. Since
this truth assignment satisﬁes φ, we conclude from Lemma 4.5 that the path can be continued from the source of
Gφ to its sink.

20

The gadgets we present before Lemma 4.7 in the main paper build on earlier ideas and bring out the diﬀerence
in the roles played by the data graph and the query, when reducing satisﬁability to query evaluation. We begin
with an observation about the REWB eevalrks.

Deﬁnition B.3 (Indistinguishable variables). The variables x1, . . . , xk are said to be indistinguishable in an REWB
e if they are free in e and for every condition c appearing in e, for every data value d and every pair of valuations
ν and ν1 with tνpx1q, . . . , νpxkqu “ tν1px1q, . . . , ν1pxkqu, we have d, ν |ù c iﬀ d, ν1 |ù c.

The variables x1, . . . , xk are indistinguishable in eevalrks. The intuition is that eeval rks treats the set tνpx1q, . . . , νpxkqu

as the set of propositional atoms that are set to true. Any valuation ν1 with tν1px1q, . . . , ν1pxkqu “ tνpx1q, . . . , νpxkqu
will have the same meaning, as far as eevalrks is concerned.

Suppose PR “ tpr 1, . . . , pr nu is a set of propositional atoms and x1, . . . , xk are variables indistinguishable in
some REWB e. We would like to check if the source of some graph G is connected to its sink by a data path in the
language of e, for some injective valuation ν : tx1, . . . , xku Ñ PR. The data graph GrDk{PRs ˝ G and the expression
erDks ˝ e deﬁned in the main paper have been designed to achieve this.

Suppose ν is a valuation of some variables, whose domain does not intersect with tx1, . . . , xku. We denote by
νrtx1, . . . , xku 1:1ÝÝÑ PRs the set of valuations ν1 that extend ν such that domainpν1q “ domainpνq Y tx1, . . . , xku, ν1
is injective on tx1, . . . , xku and tν1px1q, . . . , ν1pxkqu Ď PR.

Lemma B.4. Suppose x1, . . . , xk are indistinguishable in the REWB e and ν is a valuation for fv peqztx1, . . . , xku.
The source of GrDk{PRs˝G is connected to its sink by a data path in LperDks˝e, νq iﬀ there exists ν1 P νrtx1, . . . , xku 1:1ÝÝÑ
PRs and a data path in Lpe, ν1q connecting the source of G to its sink.

Proof. Suppose the source of GrDk{PRs ˝ G is connected to its sink by a data path in LperDks ˝ e, νq. When this
path reaches the source of G, the updated valuation ν1 is in νrtx1, . . . , xku 1:1ÝÝÑ PRs. Hence, the continuation of the
path from the source of G to its sink is in Lpe, ν1q.

Conversely, suppose there exists ν1 P νrtx1, . . . , xku 1:1ÝÝÑ PRs and the source of G is connected to its sink by a
data path in Lpe, ν1q. There is a data path w1 from the source of GrDk{PRs ˝ G to the source of G in Lpa˚
1 a1 Óx1
1 q, resulting in a valuation ν2 P νrtx1, . . . , xku 1:1ÝÝÑ PRs such that tν2px1q, . . . , ν2pxkqu “
1 a1 Óx2 a˚
a˚
tν1px1q, . . . , ν1pxkqu. Since x1, . . . , xk are indistinguishable in e, we infer that the source of G is connected to its
sink by a data path w2 in Lpe, ν2q. The two data paths w1 and w2 can be concatenated to get a data path in
LperDks ˝ e, νq connecting the source of GrDk{PRs ˝ G to its sink.

1 a1 Óxk a˚

1 ¨ ¨ ¨ a˚

Lemma 4.7.
polynomial time a data graph G and an REWB e1

Let φ be a Boolean formula over the set PR of propositions and k P N . We can construct in

1 satisfying the following conditions.

1. The source of G is connected to its sink by a data path in Lpe1

1q iﬀ φ has a satisfying assignment of weight k.

2. The size of e1

1 depends only on k.

Proof. The required data graph is GrDk{PRs ˝ Gφ and e1
and Lemma 4.5.

1 is erDks ˝ eevalrks. The correctness follows from Lemma B.4

Lemma 4.9. Let i P t1, . . . , ku and νi be a valuation for fv peiqztx1, . . . , xiu. The source of Gi is connected to its
sink by a data path in Lpei, νiq iﬀ for every ν P νirtx1, . . . , xiu Ñ PRs, there is a data path in Lpe0, νq connecting
the source of G0 to its sink.

1 sqc1q˚. Suppose there is a data path
Proof. By induction on i. For the base case, we have e1 “ b1pa1 Óx1 pe0a1rx“
w P Lpe1, ν1q connecting the source of G1 to its sink. We see from Figure 1 that w has to start from the edge labeled
pr 1˘, assigning pr 1 to x1. Then w has to go from the source of G0 to its sink using a sub-path
pr 1˘, in order to satisfy the

b1, followed by ` a1
in Lpe0, ν1rx1 Ñ pr 1sq. From the sink of G0, w is forced to take the edge labeled ` a1

1 s. The next letter of w is c1, which leads to a node from where the only outgoing edge is labeled with

condition rx“

21

` a1
pr 2˘. This forces w to have a sub-path from the source to the sink of G0 in Lpe0, ν1rx1 Ñ pr 2sq. We can similarly
infer that for every j P t1, . . . , nu, w has sub-paths in Lpe0, ν1rx1 Ñ pr jsq connecting the source of G0 to its sink.
Conversely, suppose that for every j P t1, . . . , nu, there is a data path wj P Lpe0, ν1rx1 Ñ pr jsq connecting the
source of G0 to its sink. The data path b1p` a1
pr j˘c1qjPt1,...,nu P Lpe1, ν1q connects the source of G1 to its sink.

The induction step is similar to the base case.

pr j˘wj` a1

Lemma 4.10. Let ν be a valuation for fv peqztx1, . . . , xku for some REWB e. The source of Gr@k{PRs ˝ G is
connected to its sink by a data path in Lper@ks ˝ e, νq iﬀ for all ν1 P νrtx1, . . . , xku 1:1ÝÝÑ PRs, the source of G is
connected to its sink by a data path in Lpe, ν1q.

Proof. Suppose the source of Gr@k{PRs ˝ G is connected to its sink by a data path in Lper@ks ˝ e, νq. We infer
from Lemma 4.9 that for all ν1 P νrtx1, . . . , xku Ñ PRs, there is a data path wν1 from the source of G0 to its sink
in Lpe0, ν1q. For any such ν1 that is injective on tx1, . . . , xku, wν1 can not have skip edges. The reason is that e0
enforces ν1pxiq “ ν1pxj q for some distinct i, j P t1, . . . , ku in order to take a skip edge, but this is not possible for
ν1 if it is injective on tx1, . . . , xku. Hence, for extensions ν1 that are injective on tx1, . . . , xku, the source of G is
connected to its sink by a data path in Lpe, ν1q.

Conversely, suppose that for all ν1 P νrtx1, . . . , xku 1:1ÝÝÑ PRs, the source of G is connected to its sink by a data
path in Lpe, ν1q. This data path also connects the source of G0 to its sink, and is in Lpe0, ν1q. For valuations
ν1 P νrtx1, . . . , xku Ñ PRs that are not injective on tx1, . . . , xku, there is a data path in Lpe0, ν1q connecting
the source of G0 to its sink, which uses one of the skip edges from the source of G0 to its sink. Hence, for all
ν1 P νrtx1, . . . , xku Ñ PRs, there is a data path in Lpe0, ν1q connecting the source of G0 to its sink. We conclude
from Lemma 4.9 that the source of Gr@k{PRs ˝ G is connected to its sink by a data path in Lper@ks ˝ e, νq.

Lemma 4.11. Given an instance of the weighted quantiﬁed satisﬁability problem, We can construct in polynomial
time a data graph G and an REWB e1

1`k2`k4`¨¨¨ satisfying the following conditions.

1. The source of G is connected to its sink by a data path in Lpe1

1`k2`k4`¨¨¨q iﬀ the given instance of the weighted

quantiﬁed satisﬁability problem is a yes instance.

2. The size of e1

1`k2`k4`¨¨¨ depends only on k1, . . . , kℓ.

Proof. The required data graph G is GrDk1{PR1s ˝ Gr@k2{PR2s ˝ ¨ ¨ ¨ ˝ Gφ and the required REWB e1
1`k2`k4`¨¨¨ is
erDk1s ˝ er@k2s ˝ ¨ ¨ ¨˝ eevalrk1 ` ¨ ¨ ¨` kℓs. We assume that ˝ associates to the right, so G1 ˝ G2 ˝ G3 is G1 ˝ pG2 ˝ G3q and
e1 ˝ e2 ˝ e3 is e1 ˝ pe2 ˝ e3q. Suppose that the source of G is connected to its sink by a data path in Lpe1
1`k2`k4`¨¨¨q.
Lemma B.4 ensures that there exists an injective valuation ν1 : tx1, . . . , xk1 u Ñ PR1 such that the source of
Gr@k2{PR2s ˝ ¨ ¨ ¨ ˝ Gφ is connected to its sink by a data path in Lper@k2s ˝ ¨ ¨ ¨ ˝ eevalrk1 ` ¨ ¨ ¨ ` kℓs, ν1q. Then
Lemma 4.10 ensures that for all ν2 P ν1rtxk1`1, . . . , xk1`k2 u 1:1ÝÝÑ PR2s, the source of GrDk3{PR3s ˝ ¨ ¨ ¨ ˝ Gφ is
connected to its sink by a data path in LperDk3s ˝ ¨ ¨ ¨ ˝ eeval rk1 ` ¨ ¨ ¨ kℓs, ν2q. This argument can be repeated ℓ
times to cover all alternations in the Boolean quantiﬁers. Finally, Lemma 4.5 ensures that the truth assignments
corresponding to the valuations all satisfy the Boolean formula φ. The converse direction is similar.

22

