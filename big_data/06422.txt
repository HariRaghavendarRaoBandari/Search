6
1
0
2

 
r
a

 

M
1
2

 
 
]

O
L
.
s
c
[
 
 

1
v
2
2
4
6
0

.

3
0
6
1
:
v
i
X
r
a

Parity Game Reductions

Sjoerd Cranen1, Jeroen J.A. Keiren2,3, and Tim A.C. Willemse1

1Department of Computer Science and Mathematics, Eindhoven University of

Technology, PO Box 513, 5600MB Eindhoven, The Netherlands,

s.cranen,t.a.c.willemse@tue.nl

2Open University of the Netherlands, Faculty of Management, Science & Technology,

PO Box 2960, 6401 DL Heerlen, The Netherlands, Jeroen.Keiren@ou.nl

3Radboud University, Institute for Computing and Information Sciences, Nijmegen,

The Netherlands

Abstract

Parity games play a central role in model checking and satisﬁability
checking. Solving parity games is computationally expensive, among oth-
ers due to the size of the games, which, for model checking problems,
can easily contain 109 vertices or beyond. Equivalence relations can be
used to reduce the size of a parity game, thereby potentially alleviating
part of the computational burden. We reconsider (governed) bisimulation
and (governed) stuttering bisimulation, and we give detailed proofs that
these relations are equivalences, have unique quotients and they approx-
imate the winning regions of parity games. Furthermore, we present game-
based characterisations of these relations. Using these characterisations
our equivalences are compared to relations for parity games that can be
found in the literature, such as direct simulation equivalence and delayed
simulation equivalence. To complete the overview we develop coinduct-
ive characterisations of direct- and delayed simulation equivalence and we
establish a lattice of equivalences for parity games.

1 Introduction

We study preorders and equivalences deﬁned on parity games. Such games
are turn-based graph games between two players taking turns pushing a token
along the vertices of a ﬁnitely coloured graph. These players, called even and
odd , strive to optimise the parity of the dominating colour occurring inﬁn-
itely often in a play. Parity games appear in the core of various foundational
results such as Rabin’s proof of the decidability of a monadic second-order the-
ory. Solving parity games is a computationally expensive but key step in many
model checking algorithms [17, 47, 48] and synthesis and supervisory control
algorithms [3, 4, 20].

Parity game solving enjoys a special status among combinatorial optimisa-
tion problems, being one of the rare problems in the intersection of the UP and
coUP classes [33] that is not known to be in P. Despite the continued research
eﬀort directed to it, resulting in numerous algorithms for solving parity games,
see, e.g., [7, 8, 34, 35, 41, 45, 46, 47, 49, 52], no polynomial time algorithm has
yet been found.

1

Orthogonally to the algorithmic improvements, heuristics and static analyses
have been devised that may speed up solving, or fully solve parity games that
occur in practice [19, 30, 31]. Such heuristics work particularly well for veri-
ﬁcation problems, which give rise to games with only few diﬀerent priorities.
In a similar vein, heuristics based on the intimate ties between temporal logics
and bisimulation relations are often exploited to speed-up model checking. First
minimising a state space by computing the equivalence quotient and only then
analysing this quotient can be an eﬀective strategy, see e.g. [36].

Given the close connection between parity game solving and model checking,
a promising heuristic in this setting is to minimise a game prior to solving it.
Of course, this requires that the winning regions of the original game can be
recovered cheaply from the winning regions of the minimised game. Moreover,
minimisation makes sense only for equivalence relations that strike a favourable
balance between their power to compress the game graph and the computational
complexity of quotienting with respect to the equivalence relation.
Indeed,
in [14, 39] we showed that quotienting using standard strong bisimilarity and
stuttering equivalence allow to solve parity games that could not be solved
otherwise. Despite the immense reductions that can be obtained, the results
were mixed and, apart from a number of cases that become solvable, there was
on average no clear gain from using such relations. It should be noted that the
stuttering equivalence experiments in [14, 15] were conducted using the Groote-
Vaandrager algorithm [28] which runs in O(mn), where m is the number of
edges and n is the number of states. A recent improvement on this algorithm,
described in [29], may very well mean the scale tips in favour of using stuttering
equivalence minimisation prior to solving a parity game, as experiments using
this O(m log n) algorithm have shown speed-ups of several orders of magnitude
compared to the O(mn) algorithm.

Similar observations can be made for governed bisimilarity [37] (also known
as idempotence-identifying bisimilarity in [39] and governed stuttering bisimil-
arity [15], which weaken strong bisimilarity and stuttering equivalence, respect-
ively, by taking the potentials of players into account. Quotienting for the latter
relations relies on the claim that the relations are equivalences.

As a side-note, simulation and bisimulation relations, tailored to parity
games, may lead to insights into the core of the parity game solving prob-
lem. Indeed, in e.g. [32], Janin relies on diﬀerent types of simulations to provide
uniform proofs when showing the existence of winning strategies; at the same
time he suggests simulation relations may ultimately be used to solve games
eﬃciently.

In this paper, we revisit the notions of (governed) bisimilar-
Contributions.
ity and (governed) stuttering bisimilarity for parity games from [14, 15, 37, 39].
We give formal proofs that they are indeed equivalence relations and, equally
important, that they approximate the winning regions of a parity game, sub-
stantiating our claims in the aforementioned papers. Showing that the relations
are indeed equivalence relations is technically rather involved, and slight over-
sights are easily made, see e.g. [5], and the added complexity of working in a
setting with two players complicates matters signiﬁcantly.

We furthermore study how our equivalence relations are related to two other
notions that have been studied in the context of parity games, viz. direct simula-

2

tion and delayed simulation [22] and the latter’s even and odd -biased versions. A
complicating factor is the fact that these relations have only game-based deﬁn-
itions, whereas our equivalences are deﬁned coinductively. We mend this by
providing alternative coinductive deﬁnitions for direct simulation and delayed
simulation, inspired by [42], and we show that these coincide with their game-
based deﬁnitions. Likewise, we give game-based deﬁnitions for our coinductively
deﬁned relations, drawing inspiration from [9, 51], thereby oﬀering a more op-
erational view on our relations.

Finally, we show that, contrary to (even- and odd-biased) delayed simulation
equivalence, direct simulation equivalence, governed bisimilarity and governed
stuttering bisimilarity have unique quotients.

In logic, bisimulation has been used to characterise the sub-
Related work.
family of ﬁrst-order logic that is deﬁnable in modal logic [6], and which fragment
of monadic second-order logic is captured by the modal µ-calculus. Bisimulation
and simulation-like relations, called consistent correlations [50] and consistent
consequence [24] for PBESs, a ﬁxpoint-logic based framework which is closely
related to parity games, were imperative to prove the soundness of the syntax-
based static analysis techniques described in [13, 38, 43, 44]. Various simula-
tion relations have been used successfully for minimising Büchi automata, see
e.g. [11, 18, 40].

In the context of process theory, there is an abundance of diﬀerent simula-
tion and bisimulation relations, allowing to reason about the powers of diﬀerent
types of observers of a system’s behaviour, see [26, 27]. Coinductive deﬁnitions
of weak behavioural equivalences such as stuttering equivalence (which is, es-
sentially, the same as branching bisimulation for labelled transition systems) are
commonplace, see [27] for a comprehensive overview. Typically, these deﬁnitions
rely on the transitive closure of the transition relation. As argued by Namjoshi
[42], local reasoning typically leads to simpler arguments. He therefore intro-
duced well-founded bisimulation, a notion equivalent to stuttering bisimulation
which solely relies on local reasoning by introducing a well-founded order into
the relation. Still, at its basis, well-founded bisimulation only serves to show the
reachability of some pair of related vertices. In our coinductive characterisation
of the delayed simulation of [22], we use Namjoshi’s ideas. However, we need to
factor in that in delayed simulation each step on one side must be matched by
exactly one step on the simulating side.

There are only a few documented attempts that provide game-based deﬁn-
itions for weak behavioural equivalences. Yin et al. describe branching bisim-
ulation games for normed process algebra [51]. A game-based characterisation
of divergence-blind stuttering bisimulation was provided by Bulychev et al. [9].
Neither of these deﬁnitions is easily extended to the setting of governed stut-
tering bisimulation for parity games. In particular, the latter deﬁnition is only
sound for transition systems that are free of divergences and requires a separate
preprocessing step to deal with these. For governed stuttering bisimulation, it is
unclear how the parity game should be preprocessed, so instead we incorporate
divergence into the game-based deﬁnition as a ﬁrst-class citizen.

Structure of the paper. Parity games are introduced in Section 2. In Sec-
tion 3, we introduce notation that facilitates us to deﬁne preorders and equival-

3

ences on parity games and we state several basic results concerning this notation.
A technical overview of the relations studied in the remainder of the paper, and
how these are related is presented in Section 4. In Section 5 we study direct
simulation, delayed simulation and its biased versions and in Section 6 we study
governed bisimulation and governed stuttering bisimulation. Quotienting, for
all involved equivalences that admit unique quotients, is discussed in Section 7
and in Section 8 we return to, and substantiate, the overview we presented in
Section 4. We wrap up with conclusions and an outlook for future work in
Section 9.

2 Parity Games

A parity game is a two-player graph game, played by two players even and odd
(denoted (cid:3) and (cid:3)) on a total directed graph in which the vertices are partitioned
into two sets, one for each player, and in which a natural priority is assigned to
every vertex. The game is played by placing a token on some initial vertex, and
if the token is on a vertex owned by player even, then she moves the token to a
successor of the current vertex (likewise for vertices owned by odd ). The game
is formally deﬁned as follows.

Deﬁnition 1 (Parity game). A parity game is a directed graph (V, →, Ω, P),
where

• V is a ﬁnite set of vertices,

• → ⊆ V × V is a total edge relation (i.e., for each v ∈ V there is at least

one w ∈ V such that (v, w) ∈ →),

• Ω : V → N is a priority function that assigns priorities to vertices,

• P : V → { (cid:3) , (cid:3)} is a function assigning vertices to players.

Instead of (v, w) ∈→ we typically write v → w, and we write v• for the set
{w ∈ V | v → w}.
If i is a player, then ¬i denotes the opponent of i, i.e.,
¬ (cid:3) = (cid:3) and ¬(cid:3) = (cid:3) . The function P induces a partitioning of V into a set of
vertices V (cid:3) owned by player even and a set of vertices V(cid:3) owned by player odd ;
we use P and V (cid:3) , V(cid:3) interchangeably. The reward order on natural numbers
is deﬁned such that n 4 m if n is even and m is odd; or n and m are even
and n ≤ m, or n and m are odd and m ≤ n. Note that n ≺ m means that n
is better than m for player even. Notions min and max are always used with
respect to the standard ordering on natural numbers. Finally, we remark that
the assumption that the edge relation is total only serves to simplify the theory
described in this paper. All results can be generalised to deal with the situation
in which one of the players is unable to move.

Paths. A sequence of vertices v0 . . . vn for which vm → vm+1 for all m < n is a
path. The concatenation p1p2 of paths p1 and p2 is again a path, provided there
is a step from the last vertex in p1 to the ﬁrst vertex in p2. Inﬁnite paths are
deﬁned in a similar manner. We use p[j] to denote the j th vertex in a path p,

4

counting from 0. The set of paths of length n starting in v is deﬁned inductively
for n ≥ 1 as follows:

Π1(v) ∆= {v}

Πn+1(v)

∆
= {pu | p ∈ Πn(v) ∧ p[n] → u}

The set of inﬁnite paths starting in v is denoted Πω(v), and the set of both
ﬁnite and inﬁnite paths starting in v is deﬁned as follows:

Π(v) ∆= Πω(v) ∪ [n∈N

Πn(v)

Plays and their winners. A game starts by placing a token on some vertex
v ∈ V . Players move the token indeﬁnitely according to the following simple
if the token is on some vertex v, player P(v) moves the token to some
rule:
vertex w such that v → w. The result is an inﬁnite path p in the game graph;
we refer to this inﬁnite path as a play. The parity of the lowest priority that
occurs inﬁnitely often on p deﬁnes the winner of the play. If this priority is
even, then player (cid:3) wins, otherwise player (cid:3) wins.

Strategies. A strategy for player i is a partial function σ : V ∗ → V , that is
deﬁned only for paths ending in a vertex owned by player i and determines the
next vertex to be played onto. The set of strategies for player i in a game G is
denoted S∗
if G is clear from the context. If a strategy yields
the same vertex for every pair of paths that end in the same vertex, then the
strategy is said to be memoryless. The set of memoryless strategies for player i
in a game G is denoted SG,i , abbreviated to Si when G is clear from the context.
A memoryless strategy is usually given as a partial function σ : V → V.

G,i , or simply S∗

i

A strategy σ ∈ S∗

i allows a path p of length n, denoted σ (cid:13) p, if and
only if for all j < n − 1 it is the case that if σ is deﬁned for p[0] . . . p[j], then
p[j + 1] = σ(p[0] . . . p[j]). The deﬁnition of consistency is extended to inﬁnite
paths in the obvious manner. We generalise the deﬁnition of Π to paths allowed
by a strategy σ; formally, we deﬁne:

σ(v) ∆= {p ∈ Πn(v) | σ (cid:13) p}
Πn

The deﬁnition for inﬁnite paths is generalised in the same way and denoted
Πω
σ(v), i.e., the set of all ﬁnite and
inﬁnite paths starting in v and allowed by σ.

σ (v). By Πσ(v) we denote Πω

σ (v) ∪Sn∈N Πn

A strategy σ ∈ S∗
i

is said to be a winning strategy from a vertex v if and
only if i is the winner of every path allowed by σ. A vertex is won by player i
if i has a winning strategy from that vertex.

It is well-known that parity games are determined,
Solving parity games.
i.e. that each vertex in a game is won by exactly one player, and if a winning
strategy for a player exists from a vertex, then also a memoryless strategy exists.
This is summarised in the following theorem.

Theorem 1 (Memoryless determinacy [16]). For every parity game there is
a unique partition (W (cid:3) , W(cid:3)) such that winning strategies σ (cid:3) ∈ S∗
from W (cid:3)
(cid:3)

5

and σ(cid:3) ∈ S∗
memoryless strategy ψi ∈ Si winning from Wi exists.

(cid:3) from W(cid:3) exist. Furthermore, if σi ∈ S∗
i

is winning from Wi a

The problem of solving a parity game is deﬁned as the problem of computing

the winning partition (W (cid:3) , W(cid:3)) of a parity game.

3 Notation

In the remainder of this paper we frequently need to reason about the concept of
a player being able to force play towards a set of vertices. We introduce notation
that facilitates such reasoning and we provide some lemmata that express basic
properties of parity games in terms of this extended notation. Throughout this
section, we ﬁx a parity game (V, →, Ω, P). Furthermore, we let T, U ⊆ V be
subsets of vertices in the game.

Given a memoryless strategy σ, we introduce a single-step relation σ→ ⊆→

that contains only those edges allowed by σ:

σ→ ∆= {(v, u) | (v, u) ∈→ and if σ(v) is deﬁned σ(v) = u}

In line with v → u, we write v σ→ u if (v, u) ∈ σ→. Abstracting from the
speciﬁc strategy, we write v i → u iﬀ player i has a memoryless strategy σ such
that v σ→ u.

We introduce special notation to express which parts of the graph can be
reached from a certain node. We use v 7→U T to denote that there is a ﬁnite
path v0 . . . vn, for some n, such that v = v0, vn ∈ T and for all j < n, vj ∈ U .
Conversely, v 7→U denotes the existence of an inﬁnite path v0 v1 . . . for which
v = v0 and for all j, vj ∈ U .

We extend this notation to restrict this reachability analysis to plays that
can be enforced by a speciﬁc player. We say that strategy σ forces the play from
v to T via U , denoted v σ7→U T , if and only if for all plays p starting in v such
that σ (cid:13) p, there exists an n such that p[n] ∈ T and p[j] ∈ U for all j < n. Note
that, in particular, v σ7→U T if v ∈ T . Similarly, strategy σ forces the play to
diverge in U from v, denoted v σ7→U , if and only if for all such plays p, p[j] ∈ U
for all j.

Finally, if we are not interested in a particular strategy, but only in the
existence of a strategy for a player i via which certain parts of the graph are
reachable from v, we replace σ by i in our notation to denote an existential
quantiﬁcation over memoryless strategies:

v i7→U T ∆= ∃σ ∈ Si : v σ7→U T

v i 7→U

∆= ∃σ ∈ Si : v σ7→U

The lemma below shows that rather than using memoryless strategies, one may,
if needed, use arbitrary strategies when reasoning about v i7→U T .
Lemma 1. ∃σ ∈ Si : v σ7→U T iﬀ ∃σ ∈ S∗
Proof. Observe that the implication from left to right holds by deﬁnition. So as-
sume that for some σ ∈ S∗
i , we have v σ7→U T . Note that v σ7→U T iﬀ v σ7→U\T T .
The truth value of the latter predicate does not depend on priorities of the ver-
tices and only depends on the edges that originate in U \ T . Therefore, the truth
value of this predicate will not change if we apply the following transformation
to our graph:

i : v σ7→U T .

6

• for all u ∈ T , replace all outgoing edges by a single edge u → u.

• set the priorities for all u ∈ T to even iﬀ i = (cid:3) and the priorities of all

other vertices to odd iﬀ i = (cid:3) .

Since v σ7→U\T T , vertex v is won by i in the resulting graph. As parity games
are memoryless determined, i must have a memoryless strategy to move from
U \ T to T in the resulting graph. Hence there is some σ′ ∈ Si such that
v σ′ 7→U\T T in the resulting graph, but then also v σ′ 7→U\T T in the original
graph, and hence also the required v σ′ 7→U T .

The complement of these relations is denoted by a slashed version of the
corresponding arrow, e.g., ¬v i 7→U T can be written v i6
7→U T . We extend the
transition relation of the parity game to sets and to sets of sets in the usual way,
i.e., if T is a set of vertices, and U is a set of vertex sets, then

v → T ∆= ∃u ∈ T : v → u

v → U ∆= v →[ U

All other arrow notation is extended in the same way; if a set of sets U is given
as a parameter, it is interpreted as the union of U.

The notation v i7→U T is closely related to the notion of attractor sets [41]. To
formalise this correspondence, we generalise the attractor set deﬁnition along
the lines of the generalisation used for the computation of the Until
in the
alternating-time temporal logic ATL [2].

Deﬁnition 2 (Attractor set). We deﬁne UAttr

i (T ) as UAttr ω

i (T ) where:

UAttr 0
i (T )
UAttr n+1

i

∆= T

(T ) ∆= UAttr n

i (T )

∪ {v ∈ U | P(v) = i ∧ ∃v′ ∈ v• : v′ ∈ UAttr n
∪ {v ∈ U | P(v) 6= i ∧ ∀v′ ∈ v• : v′ ∈ UAttr n

i (T )}
i (T )}

The attractor set as deﬁned in [41] is obtained for U = V . In essence, the
i(T ) captures the subset of U ∪ T from which i can force
attractor set UAttr
the game to T ⊆ V , by staying within U until T is reached. Note that Attr
i(T ′).
is a monotone operator; i.e.
The correspondence between our ‘forcing’ arrow notation and the (generalised)
attractor is given by the following lemma.

for T ⊆ T ′ we have UAttr

i(T ) ⊆ UAttr

Lemma 2. Let U, T ⊆ V . Then v i7→U T iﬀ v ∈ UAttr
Proof. We ﬁrst introduce some additional notation. Let v i7→n
there is a σ ∈ Si such that for all p ∈ Πn+1
p[m] ∈ T , and p[j] ∈ U for all j < m. Note that v i 7→ω
now use induction to prove u i7→n
property then follows.

U T denote that
(v), there is some m ≤ n such that
U T iﬀ v i 7→U T . We can
i (T ) for all u. The required

U T iﬀ u ∈ UAttr n

i(T ).

σ

The base case, n = 0, follows instantly. For n = m + 1, our induction
i (T ) for all u. We distinguish two

U T iﬀ u ∈ UAttr m

hypothesis yields u i7→m
cases: P(u) = i and P(u) 6= i.

Suppose P(u) = i, and assume u ∈ UAttr n+1

i

i (T ), or, since P(u) = i, u ∈ {v ∈ U | ∃v′ ∈ v• : v′ ∈ UAttr n

(T ). Then, by deﬁnition,
i (T )}.

u ∈ UAttr n
But then this is equivalent to

u ∈ UAttr n

i (T ) or v′ ∈ UAttr n

i (T ) for some v′ ∈ u•.

(*)

7

By our induction hypothesis, (*) is equivalent to u i7→n
U T for some
v′ ∈ u•. But since i then has a strategy to play u → v′, this is again equivalent
to

U T or v′

i 7→n

u i7→n

U T or u i7→n+1

U
T and u i7→n+1

U

T

(†)

U T implies u i7→n+1

Since u i7→n
T ,
we ﬁnd that (†) is equivalent to the desired u i7→n+1
T , which ﬁnishes the proof
for the case P(u) = i. The case for P(u) 6= i uses a similar line of reasoning;
the only diﬀerence is that we do not need to identify a strategy for player i.

U T or u i7→n+1

T implies u i7→n

U

U

U

We are now ready to formalise some intuitions using our notation. One of
the most basic properties we expect to hold is that a player can force the play
towards some given set of vertices, or otherwise her opponent can force the play
to the complement of that set.

In the following lemmas, let v ∈ V , U, T, T ′ ⊆ V and i a player.

Lemma 3. v i 7→U T ∨ v ¬i7→U V \ T.
Proof. We prove the equivalent v i6
v i 6
Therefore, we immediately ﬁnd that v ¬i 7→U V \ T.

7→U T =⇒ v ¬i 7→U V \ T. Assume that
7→U T . Observe that it follows directly that v 6∈ T , and hence v ∈ V \ T .

In a similar train of thought, we expect that if from a single vertex, each
player can force play towards some target set, then the players’ target sets must
overlap.

Lemma 4.

v i 7→U T ∧ v ¬i7→U T ′ =⇒

∃u ∈ T, u′ ∈ T ′ : u = u′ ∨ u ∈ U ∨ u′ ∈ U.

Proof. Assume v i7→U T ∧ v ¬i 7→U T ′. Then there must be strategies σ ∈ Si and
σ′ ∈ S¬i such that v σ7→U T ∧ v σ′ 7→U T ′. Let σ and σ′ be such, and consider
a play p such that σ (cid:13) p and σ′ (cid:13) p. For this play, there must be m and n
such that p[m] ∈ T ∧ ∀j < m : p[j] ∈ U , and p[n] ∈ T ′ ∧ ∀j < n : p[j] ∈ U .
If m = n, then this witnesses ∃u ∈ T, u′ ∈ T ′ : u = u′.
If m < n, then
p[m] ∈ T ∧ p[m] ∈ U , and if n < m, then p[n] ∈ T ′ ∧ p[n] ∈ U .

The above lemmata reason about players being able to reach sets of vertices.
The following lemma is essentially about avoiding sets of vertices: it states that
if one player can force divergence within a set, then this is the same as saying
that the opponent cannot force the play outside this set.

7→U V \ U

Lemma 5. v i 7→U ⇐⇒ v ¬i 6
Proof. Again, note that the truth values of v i 7→U and v ¬i 6
7→U V \U only depend
on edges that originate in U , and that these truth values do not depend on
priorities at all. Therefore, the truth value of these predicates will not change
if we apply the following transformations to our graph:

• For all u ∈ V \ U , replace all outgoing edges by a single edge u → u.

• Make the priorities of all vertices in U such that they are even iﬀ i = (cid:3) ,

and the priorities of all other vertices odd iﬀ i = (cid:3) .

In the resulting graph, player i wins if and only if v i7→U , and player ¬i wins if
and only if v ¬i7→U V \ U . Since parity games are determined, i.e. v can only
be won by one player, the desired result follows.

8

Next, we formalise the idea that if a player can force the play to a ﬁrst set
of vertices, and from there he can force the play to a second set of vertices, then
he must be able to force the play to that second set.

Lemma 6. (v i7→U T ∧ ∀u ∈ T : u i7→U T ′) =⇒ v i 7→U T ′
Proof. By Lemma 2, ∀u ∈ T : u i7→U T ′ implies T ⊆ UAttr
icity of Attr we have UAttr
UAttr
v i 7→U T we ﬁnd v ∈ UAttr
Lemma 2, yields the desired v i 7→U T ′.

i (T ′), we thus have UAttr

i(UAttr
i(T ) ⊆ UAttr

i (T ) ⊆ UAttr

i (T ′). By monoton-
i (T ′)). Since UAttr
i (T ′)) =
i (T ′). By the same token, from
i (T ′) which, by

i (UAttr

i (T ). Combined, we ﬁnd v ∈ UAttr

Finally, we state two results that relate a player’s capabilities to reach a
set of vertices to the capabilities of the vertices that are able to leave a set of
vertices in a single step.

Lemma 7. Let S = {u ∈ U | u• ∩ T 6= ∅} and v /∈ T . Then v i 7→U T implies
Vi ∩ S 6= ∅ or for some u ∈ S, u• ⊆ T .

Proof. Assume v i 7→U T and suppose Vi ∩ S = ∅. Assume that for all u ∈ S, not
u• ⊆ T . Then UAttr
i (T ) = T follows from S ⊆ V¬i . Since v /∈ T this implies
v /∈ UAttr
7→U T . Contradiction. So there is
some u ∈ S such that u• ⊆ T .

i(T ). By Lemma 2 we then have v i 6

Lemma 8. For v ∈ U , v i 7→U T implies v i 7→U T ′ whenever T ′ ⊆ T and w• ⊆
U ∪ T ′ for all w ∈ U .

Proof. Choose σ ∈ Si such that v σ7→U T , and let p be a path for which p[0] =
v ∈ U and σ (cid:13) p. Then for some j > 0, p[j] ∈ T and p[k] ∈ U for all k < j. Since
p[j − 1]• ⊆ U ∪ T ′, also p[j] ∈ T ′ and therefore v σ7→U T ′. Thus v i7→U T ′.

4 A Lattice of Parity Game Relations

In the rest of this paper, we study relations on parity games. We forego a formal
treatment and present an overview of the studied relations and how these are
related in this section.

4.1 Relations

Let R be a relation over a set V , i.e. R ⊆ V × V . For v, w ∈ V we write
v R w to denote (v, w) ∈ R. For a relation R and vertex v ∈ V we deﬁne v R ∆=
{w ∈ V | v R w}, and likewise R v ∆= {w ∈ V | w R v}. We also generalise

this notation to sets of vertices such that, for U ⊆ V , U R ∆= Su∈U u R, and
R U ∆=Su∈U R u.

A relation R is a preorder if it is reﬂexive and transitive. If, in addition, R
is symmetric, then it is an equivalence relation. Note that for an equivalence
relation R, and vertex v ∈ V , we have v R = R v. In this case we also write
∆= {v ∈ V | v R w}, and call this the equivalence class of v under R. By
[v]R
abuse of notation, for a subset V ′ ⊆ V , we write [V ′]R for the set of equivalence
classes with respect to V , i.e. the set {[v]R | v ∈ V ′}. The set of equivalence
classes of V under R is denoted V/R , and deﬁned as {[v]R | v ∈ V }.

9

4.2 Introducing a Lattice of Equivalences

Preorders for parity games are particularly (and perhaps only) interesting if
they allow one to approximate the winning regions of a game. A preorder R
approximates the winning region of a game if, whenever v R w, and player even
has a winning strategy from v, then she also has a winning strategy from w.
For equivalence relations, this requirement is stronger and often more useful:
we require that if v R w, then even has a winning strategy from v if and only if
she has a winning strategy from w. The ﬁnest natural equivalence relation on
V is graph isomorphism, denoted ∼=.

Deﬁnition 3 (Isomorphism). Let (V, →, Ω, P) be a parity game. Vertices v, w ∈
V are isomorphic, denoted v ∼= w iﬀ φ(v) = w for some bijection φ : V → V
that satisﬁes, for all ¯v ∈ V :

• Ω(¯v) = Ω(φ(¯v)),

• P(¯v) = P(φ(¯v)), and

• ¯v → ¯v′ if and only if φ(¯v) → φ(¯v′).

The coarsest sensible equivalence on parity games is the equivalence induced
by the determinacy of parity games, viz. the equivalence that exactly relates
only and exactly those vertices won by the same player.

Deﬁnition 4 (Winner equivalence). Let (V, →, Ω, P) be a parity game. Vertices
v, w ∈ V are winner equivalent, denoted v ∼w w iﬀ v and w are won by the
same player.

Deciding winner equivalence of parity games is equivalent to paritioning the

vertices in the parity game into winning sets.

Winner equivalence and isomorphism are the extreme points in the lattice
of equivalence relations shown in Figure 1. Between the extremal points in the
lattice of Figure 1 we list the other parity game equivalences that we study in
more detail in the subsequent sections:

• Strong bisimilarity (↔) [37, 39], see Section 6.1;

• Strong direct simulation equivalence (≡sd), see Section 5.1;

• Direct simulation equivalence (≡d ) [22, 23, 24], see Section 5.1;

• Delayed simulation equivalence (≡de ) [22], see Section 5.2;

• Delayed simulation equivalence, even-biased (≡e

de ) [22], see Section 5.2.1;

• Delayed simulation equivalence, odd -biased (≡o

de ) [22], see Section 5.2.1;

• Governed bisimilarity (↔) [37, 39], see Section 6.1;

• Stuttering bisimilarity (≃) [14], see Section 6.1;

• Governed stuttering bisimilarity (∼) [15], see Section 6.2;

10

∼=

1

↔

2

↔

2

≃

7

∼

4

2

≡sd

4

3

≡d

5

5

≡o
de

6

≡e
de

6

≡de

6

8

∼w

1. Theorem 18, page 36;

2. Theorem 19, page 37;

3. Theorem 20, page 37;

4. Theorem 21, page 37;

5. Theorem 23, page 38;

6. Theorem 24, page 38;

7. Theorem 27, page 39;

8. Theorem 28, page 41;

Figure 1: Lattice of equivalences for parity games. The numbers on the edges
refer to the legend shown to the right, which in turn refers to the theorems that
witness the existence of the edge.

In the lattice, an arrow from one equivalence to the other indicates that the
ﬁrst equivalence is ﬁner than the latter. The number on an arrow refers to the
theorem in this paper that claims this strictly ﬁner-than relation between the
equivalences.

The original deﬁnitions of the equivalences listed above vary in nature.
Strong-, governed-, stuttering-, and governed stuttering bisimilarity are deﬁned
coinductively, whereas direct simulation and all variations of delayed simulation
are deﬁned as simulation games. Furthermore, the direct- and delayed simula-
tion games deﬁne a preorder, whereas the others deﬁne an equivalence relation;
the preorders are lifted to equivalence relations in the standard way.

5 Direct and Delayed Simulation Equivalence

We introduce the direct simulation preorder and the induced direct simulation
equivalence in Section 5.1.
In Section 5.2, we recall the delayed simulation
preorder, the induced delayed simulation equivalence and two biased versions
of the delayed simulation preorder and equivalence. Throughout these sections,
we assume that G = (V, →, Ω, P) is an arbitrary parity game.

5.1 Direct Simulation and Direct Simulation Equivalence

Direct simulation for parity games is one of the most basic preorders studied
for parity games. It is diﬃcult to trace the exact origins of the deﬁnition, but
it was suggested (though not formally deﬁned) in [22] and appeared earlier in
the setting of alternating Büchi automata [23]. We here follow the game-based
deﬁnition as given in [24].

11

1

v0

1

v1

1

v2

0

v3

Figure 2: Parity game with v0 ⊑d v1, v0 ⊑d v2, v2 ⊑d v0, and for all vi, vi ⊑d vi.

Deﬁnition 5 (Direct simulation game). The direct simulation game is played
on conﬁgurations drawn from V × V , and it is played in rounds. A round of the
game proceeds as follows:

1. The players move from (v, w) according to the rules in Table 1;

2. Play continues in the next round from the newly reached position.

An inﬁnite play (v0, w0), (v1, w1), . . . is won by Duplicator if Ω(vj) = Ω(wj ) for
all j, i.e., Duplicator was able to mimic every move from Spoiler with a move
to a vertex with equal priority. In all other cases Spoiler wins the play.

We say that v is directly simulated by w, denoted v ⊑d w whenever Duplic-

ator has a winning strategy from (v, w) in the direct simulation game.

P(v) P(w)

1st move

plays on

2nd move

plays on

(cid:3)
(cid:3)
(cid:3)
(cid:3)

(cid:3)

(cid:3)
(cid:3)

(cid:3)

S
S
D
S

v
v
w
w

D
S
D
D

w
w
v
v

Table 1: Allowed moves in a (bi)simulation game.

Example 1. In the parity game in Figure 2, v0 ⊑d v1. Observe that from
(v0, v1), Duplicator can choose both successors in the direct simulation game.
We do not have v1 ⊑d v0, since from conﬁguration (v1, v0), Spoiler ’s move
v1 → v3 cannot be matched from v0. Note that additionally we have v0 ⊑d v2
and v2 ⊑d v0.

Direct simulation is a preorder: reﬂexivity is easily seen to hold (Duplicator
can follow a copy-cat strategy), but transitivity is more involved. In the setting
of alternating Büchi automata, direct simulation was shown to be transitive us-
ing strategy composition, see [21, 23]. Following essentially the same technique
one can show transitivity of direct simulation for parity games. We use the dir-
ect simulation preorder to obtain direct simulation equivalence in the standard
way.

Deﬁnition 6 (Direct simulation equivalence [22, 24]). Vertices v and w are
direct simulation equivalent, denoted v ≡d w, iﬀ v ⊑d w and w ⊑d v.

The alternative coinductive deﬁnition of direct simulation which we present
next, allows for a more straightforward proof of transitivity. Our deﬁnition
below was taken from [25], where it is also referred to as governed simulation.

12

Deﬁnition 7 (Direct simulation relation [25]). A relation R ⊆ V × V is a direct
simulation if and only if v R w implies

• Ω(v) = Ω(w);

• if v ∈ V (cid:3) , then for each v′ ∈ v•, w (cid:3) → v′ R;
• if v ∈ V(cid:3), then w (cid:3) → v• R.

We say that vertex v is directly simulated by w, denoted v ≤d w, if and only if
there is a direct simulation relation R such that v R w.

The theorem below states that the game-based and coinductive deﬁnitions

of direct simulation coincide.

Theorem 2. For all v, w ∈ V , we have v ≤d w if and only if v ⊑d w.

Proof. We prove both implications separately.

⇒ We prove that from a pair of vertices v ≤d w the game can always be
played such that we again end up in related vertices after one round in
the direct simulation game. Since Ω(v) = Ω(w), it immediately follows
that Duplicator has a winning strategy in the direct simulation game, and
hence v ⊑d w.
Let v, w be such that v ≤d w. We distinguish two cases:

– v ∈ V (cid:3) . Then Spoiler ﬁrst chooses some v → v′. Since v ≤d w, we
know that w (cid:3) → v′ ≤d, hence if w ∈ V (cid:3) , Duplicator can choose a
successor w → w′ such that v′ ≤d w′, and if w ∈ V(cid:3), all successors
w → w′ that Spoiler may choose are such that v′ ≤d w′.

– v ∈ V(cid:3). Then w (cid:3) → v• ≤d, so if w ∈ V (cid:3) , there exist w → w′ and
v → v′ such that v′ ≤d w′, and Duplicator can play such that he
In case w ∈ V(cid:3), then for all w → w′ there exists a
picks those.
v → v′ such that v′ ≤d w′. Since Spoiler plays ﬁrst on w, Duplicator
can match with the appropriate v → v′.

⇐ We prove that ⊑d is a direct simulation relation.

Let v, w be arbitrary such that v ⊑d w. Consider a winning strategy
for Duplicator in the direct simulation game from (v, w). Observe that
Ω(v) = Ω(w) follows trivially. We again distinguish two cases:

– v ∈ V (cid:3) . Then Spoiler ﬁrst chooses some v → v′. If w ∈ V (cid:3) , then
Duplicator matches this with some w → w′ according to his strategy.
Since Duplicator ’s strategy is winning from (v, w), it is also winning
from (v′, w′), hence v′ ⊑d w′.
If w ∈ V(cid:3), any choice of successor
w → w′ that Spoiler makes is such that v′ ⊑d w′. In both cases we
have shown w (cid:3) → v′ ⊑d .

– v ∈ V(cid:3). If w ∈ V (cid:3) , Duplicator plays both on v, say v → v′, and on
w, say w → w′, such that v′ ⊑d w′. If w ∈ V(cid:3), Spoiler plays ﬁrst on
w, say w → w′, and given this choice, Duplicator responds according
to his strategy with v → v′ such that v′ ⊑d w′. Since Duplicator ’s
strategy is winning, he is able to match any choice made by Spoiler .
In both cases the strategy witnesses w (cid:3) → v• ⊑d .

13

Given that both deﬁnitions of direct simulation coincide, we can now say
that v and w are direct simulation equivalent, i.e. v ≡d w, if and only if v ≤d w
and w ≤d v.

Proposition 1. The relations ≤d and ≡d are a preorder and an equivalence
relation, respectively. Moreover, ≤d itself is a direct simulation relation.

Proof. One can check that for direct simulation relations R and S, the relation
R ◦ S, deﬁned as v (R ◦ S) w iﬀ there is some u such that v R u and u S w, is
again a direct simulation relation.

If we impose an additional constraint on direct
Strong Direct Simulation.
simulation, viz. we do not allow to relate vertices owned by diﬀerent players, we
obtain a notion that resembles alternating reﬁnement [1]. Clearly, this notion
again is a preorder. We write v ≤sd w iﬀ there is some strong direct simulation
relation that relates v and w, and we write v ≡sd w iﬀ v ≤sd w and w ≤sd v.
Note that in the parity game in Figure 2, we still have v0 ≡sd v2, but v0 6≤sd v1.

5.2 Delayed simulation

Direct simulation equivalence is limited in its capability to relate vertices. The
reason for this is that in each step of the simulation game, Duplicator is required
to match with a move to a vertex with exactly the same priority. Following
Etessami et al. [18], in [22], a more liberal notion of simulation called delayed
simulation is considered. In this notion matching may be delayed. The idea is
that in the winning condition of a play of a parity game, only the priorities that
occur inﬁnitely often are of importance. Therefore, intuitively it is allowed to
delay matching a given (dominating) priority for a ﬁnite number of rounds.

The delayed simulation game is, like the direct simulation game, played on
an arena consisting of conﬁgurations that contain a pair of vertices. These
conﬁgurations are now extended with a third parameter which is used to keep
track of the obligation that still needs to be met by Duplicator .

An obligation in a delayed simulation game is either a natural number or the
symbol X; the latter is used to indicate the absence of obligations. We denote
the set of obligations by K. Given two priorities and an existing obligation, a
new obligation is obtained using the function γ : N × N × K → K, where:

if m 4 n
min{n, m} otherwise

γ (n, m, X) =(X
γ (n, m, k) =


X

if m 4 n and(n odd and n ≤ k, or

m even and m ≤ k

min{n, m, k} otherwise

By abuse of notation we will typically write γ (v, w, k), for vertices v, w ∈ V and
obligation k ∈ K, to denote γ (Ω(v), Ω(w), k).

The intuition behind this update is as follows. Either, with the new pri-
orities, the pending obligation is fulﬁlled, and the new conﬁguration does not
give rise to a new obligation, in which case the result is X. Otherwise the new
obligation is the minimum of the priorities passed to the function, or the current

14

0

v0

1

v1

0

v2

Figure 3: Parity game in which all vertices are delay simulation equivalent.

obligation. This signiﬁes the most signiﬁcant obligation that still needs to be
met by Duplicator . Note that there are two ways to fulﬁl the pending obligation.
Either the ﬁrst argument renders the pending obligation superﬂuous since it is
smaller and odd, or the second argument is such that it matches the pending
obligation.

Deﬁnition 8 (Delayed simulation game [22]). A delayed simulation game is
a game played by players Spoiler and Duplicator on an arena consisting of
positions drawn from V × V and obligations taken from K. The game is played
in rounds. Assuming (v, w) is the current position, and k the current obligation,
a round of the game proceeds as follows:

1. Spoiler and Duplicator propose moves v → v′ and w → w′ according to

the rules in Table 1.

2. The game continues from (v′, w′) with obligation γ (v′, w′, k).

An inﬁnite play (v0, w0, k0), (v1, w1, k1), . . . is won by Duplicator iﬀ kj = X for
inﬁnitely many j. This means that Duplicator was always able to eventually
fulﬁl all pending obligations. In all other cases Spoiler wins the game.

We say that v is delayed simulated by w, denoted v ⊑de w just whenever
Duplicator has a winning strategy from (v, w) with obligation γ (v, w, X) in the
delayed simulation game.

Example 2. In the parity game in Figure 3, vi ⊑de vj for all i, j. Observe that,
with respect to direct simulation, vertices cannot be related to each other.

Delayed simulation is, like direct simulation, a preorder. The proof thereof is
substantially more involved than the proof that direct simulation is a preorder,
requiring an analysis of 24 cases, some of which are rather intricate. For details,
we refer to [21]; we here only repeat this result.

Proposition 2. The relation ⊑de is a preorder.

We obtain delayed simulation equivalence in the standard way.

Deﬁnition 9 (Delayed simulation equivalence [22]). Vertices v and w are delayed
simulation equivalent, denoted v ≡de w, iﬀ v ⊑de w and w ⊑de v.

Next, we give an alternative, coinductive deﬁnition for delayed simulation.
Since the moves in the game for delayed simulation and direct simulation match,
one may expect that such a characterisation can be obtained by a more-or-less
straightforward enhancement of the direct simulation relation. This is partly
true:
indeed, the moves of the game are captured in a way similar to how
this is done for direct simulation. However, the winning condition of delayed
simulation requires that inﬁnitely often all obligations are met. This requires

15

‘non-local’ reasoning that must somehow be captured through a coinductive
argument. Meeting an obligation is typically a progress property, requiring an
inductive argument rather than a coinductive argument.

To combine both aspects in a single, coinductive deﬁnition, we draw inspir-
ation from Namjoshi’s notion of well-founded bisimulation [42]. Well-founded
bisimulation is a relation which is equivalent to stuttering equivalence, but which
permits local reasoning by introducing a well-foundedness criterion. We use a
similar well-foundedness requirement in our coinductive deﬁnition, ensuring pro-
gress is made towards fulﬁlling obligations. This moreover requires, as can be
expected, that our coinductive relation ranges not only over pairs of vertices but
also over obligations. For a relation R ⊆ V × K × V , we write v Rk w if v and
w are related under pending obligation k. The well-foundedness restriction thus
enables us to express that v Rk w holds if we can build a coinductive argument
that ultimately depends on pairs of vertices v′, w′ related under obligation X;
viz. v′ RX w′.

Deﬁnition 10 (Well-founded delayed simulation). A relation R ⊆ V ×K ×V is
a well-founded delayed simulation iﬀ there is a well-founded order <· on V ×V ×K
such that for all v, w ∈ V and k ∈ K for which v Rk w holds, also:

• v ∈ V (cid:3)

implies for all v′ ∈ v•, w (cid:3) →{w′ ∈ V | ℓ = γ (v′, w′, k) ∧ v′ Rℓ

w′ ∧ (k = X ∨ (v′, w′, ℓ)<·(v, w, k))};

• v ∈ V(cid:3) implies w (cid:3) →{w′ ∈ V | ∃v′ ∈ v• : ℓ = γ (v′, w′, k) ∧ v′ Rℓ w′ ∧

(k = X ∨ (v′, w′, ℓ)<·(v, w, k))}.

Vertex v is well-founded delayed simulated by w, denoted v ≤de w, iﬀ there
exists a well-founded delayed simulation R such that v Rγ (v,w,X) w.

In the remainder of this section we show that this deﬁnition is equivalent to

the game-based deﬁnition.

Lemma 9. For v, w ∈ V , v ≤de w implies v ⊑de w.

Proof. We prove the stronger statement that if there is a well-founded delayed
simulation R such that v Rγ (v,w,k) w. for k ∈ K, then Duplicator has a strategy
to win the delayed simulation game from (v, w, γ (v, w, k)). The result then fol-
lows immediately from the observation that v Rγ (v,w,X) w, and hence Duplicator
wins the game from (v, w, γ (v, w, X)).

We ﬁrst show that Duplicator has a strategy to move between positions
(v, w) with obligation k for which v Rk w to positions (v′, w′) and obligation k′
for which v′ Rk′
w′. Assume that v Rk w. We distinguish four cases based on
the owner of v and w.

• (v, w) ∈ V (cid:3) × V (cid:3) .

In the delayed simulation game, this corresponds
to the vertex (v, w, k), in which Spoiler is to move ﬁrst. Spoiler ﬁrst
plays an arbitrary move v → v′. By deﬁnition of the well-founded delayed
simulation, there is w → w′ such that v′ Rγ (v′,w′,k) w′; Duplicator matches
with this w′.

• (v, w) ∈ V (cid:3) × V(cid:3). In the delayed simulation game, from position (v, w, k),
Spoiler is to make both moves, so there is no Duplicator strategy to be
deﬁned. Observe that well-founded delayed simulation guarantees that for
all v → v′ and w → w′, v′ Rγ (v′,w′,k) w′.

16

• (v, w) ∈ V(cid:3) × V (cid:3) . Duplicator plays twice in the delayed simulation game.
According to the well-founded delayed simulation, there exist v → v′ and
w → w′ such that v′ Rγ (v′,w′,k) w′. Duplicator plays such moves.

• (v, w) ∈ V(cid:3) × V(cid:3).

In the delayed simulation game, Spoiler is to move
ﬁrst, say w → w′. From the well-founded delayed simulation, we ﬁnd that
for all such moves, there exists some v → v′ such that v′ Rγ (v′,w′,k) w′.
Duplicator plays to this w′.

It remains to be shown that for all conﬁgurations (v, w, k) such that v Rk w,
this Duplicator -strategy is, indeed, winning for Duplicator . Observe that it suf-
ﬁces to show that, if k 6= X, eventually a conﬁguration (v′, w′, X) is reached.
This follows, since in every round in the game above moves are made from
(v, w, k) to (v′, w′, k′) such that (v′, w′, k′)<·(v, w, k). Since <· is a well-founded
order, this can only be repeated ﬁnitely many times, and eventually all obliga-
tions are met.

Before we show the converse, we ﬁrst show that a winning strategy for player
Duplicator in the delayed simulation game induces a well-founded order on those
conﬁgurations won by Duplicator .

Lemma 10. The winning strategy for Duplicator in the delayed simulation
game induces a well-founded order on V × V × K for those (v, w, k) for which
Duplicator wins position (v, w) with obligation k.

Proof. Observe that the delayed simulation game has a Büchi winning condition.
Hence those conﬁgurations in the game play that Duplicator can win, can be
won using a memoryless strategy. For the remainder of the proof, ﬁx such a
winning memoryless strategy.

For each position (v, w) and obligation k that is won by Duplicator , we
extract a ﬁnite tree from the solitaire game that is induced by Duplicator ’s
strategy by taking the (inﬁnite) unfolding of the game starting in (v, w, k), and
pruning each branch at the ﬁrst node with obligation X. Since the strategy is
Duplicator -winning, this tree is ﬁnite. Furthermore, if (v, w, k) appears in the
tree of a diﬀerent conﬁguration, the subtree rooted in (v, w, k) in that particular
subtree is identical to the tree of (v, w, k).

These trees determine a well-founded order <· when we set (v′, w′, ℓ)<·(v, w, k)
iﬀ the height of the tree rooted in (v′, w′, ℓ) is less than that of the tree rooted
in (v, w, k).

The following corollary immediately follows from the existence of the well-

founded order.

Corollary 1. In the delayed simulation game, for every position (v, w) with ob-
ligation k from which Duplicator has a winning strategy, if the game proceeds ac-
cording to this strategy to some position (v′, w′) with obligation ℓ = γ (v′, w′, k),
we have k = X or (v′, w′, ℓ)<·(v, w, k).

Finally, we show that any delayed simulation is also a well-founded delayed

simulation.

Lemma 11. For v, w ∈ V , v ⊑de w implies v ≤de w.

17

Proof. Let R ⊆ V × K × V be such that v Rk w if Duplicator wins the delay
simulation game from (v, w) with obligation k. Observe that, in particular, since
v ⊑de w, we have v Rγ (v,w,X) w. We show that R is a well-founded delayed
simulation.

For conﬁgurations (v, w) with obligation k, Duplicator has a winning strategy.
Since the delay simulation game has a Büchi winning condition, Duplicator also
has a memoryless winning strategy. For the remainder of the proof, ﬁx this
strategy. Observe that a well-founded order on conﬁgurations won by Duplic-
ator exists, according to Lemma 10.

Next we show that this relation satisﬁes the transfer conditions. Let v, w, k

be arbitrary, such that v Rk w. We distinguish four cases.

• (v, w) ∈ V (cid:3) ×V (cid:3) . According to Deﬁnition 8, for all moves v → v′ made by
Spoiler , Duplicator matches with a move w → w′, and the game continues
from conﬁguration (v′, w′) with obligation ℓ = γ (v′, w′, k). Since Duplic-
ator ’s strategy is winning from (v, w) with obligation k, the strategy is
also winning from (v′, w′) with obligation ℓ hence v′ Rℓ w′. Furthermore,
if k 6= X we have (v′, w′, ℓ)<·(v, w, k) according to Corollary 1.

• (v, w) ∈ V (cid:3) × V(cid:3). For all moves v → v′ and w → w′ made by Spoiler , the
game continues from conﬁguration (v′, w′) with obligation ℓ = γ (v′, w′, k)
from which again Duplicator ’s strategy is winning, hence v′ Rℓ w′, and
again we have (v′, w′, ℓ)<·(v, w, k) if k 6= X according to Corollary 1.

• (v, w) ∈ V(cid:3) × V (cid:3) . Duplicator plays a move w → w′ and v → v′ and
continues from (v′, w′) with obligation ℓ = γ (v′, w′, k), from which her
strategy is again winning, hence v′ Rℓ w′. Using the same argument as
before, also (v′, w′, ℓ)<·(v, w, k) if k 6= X according to Corollary 1.

• (v, w) ∈ V(cid:3) × V(cid:3). For all moves w → w′ made by Spoiler , Duplicator ’s
strategy matches with some v → v′ such that Duplicator wins from (v′, w′)
with obligation ℓ = γ (v′, w′, k). Again (v′, w′, ℓ)<·(v, w, k) if k 6= X, hence
w → (cid:3) {w′ ∈ V | ∃v → v′ : ℓ = γ (v′, w′, k) ∧ v′ Rℓ w′ ∧ (k = X ∨
(v′, w′, ℓ)<·(v, w, k))}.

In each of the cases above, the requirements for well-founded delayed simulation
are satisﬁed, hence R is a well-founded delayed simulation relation, and v ≤de
w.

The following theorem, stating that delayed simulation and well-founded

delay simulation coincide, now follows directly.

Theorem 3. For all v, w ∈ V we have v ⊑de w if and only if v ≤de w.

Proof. Follows immediately from lemmata 9 and 11.

5.2.1 Biased delayed simulations.

As observed in [22], quotienting is problematic for delayed simulation: no sens-
ible deﬁnition of quotienting appears to exist such that it guarantees that the
quotient is again delayed simulation equivalent to the original game. Fritz and
Wilke ‘mend’ this by introducing two variations (so called biased delayed simula-
tions) on delayed simulation which do permit some form of quotienting although
these are not unique. We brieﬂy describe these variations below.

18

Even-biased delayed simulation. The even-biased delayed simulation game,
and its coinductive variant, are identical to their delayed simulation and well-
founded delayed simulation counterparts. The only diﬀerence lies in the update
function on obligations. Given two priorities and an existing obligation, a new
obligation is obtained using the update function γe : N × N × K → K, where:

k

γe(n, m, k) =


if m 4 n, n odd, n ≤ k,
and (m odd or k < m)
otherwise

γ (n, m, k)

We again abbreviate γe(Ω(v), Ω(w), k) by γe(v, w, k).

Using the new update function in the delayed simulation game ensures that
a pending obligation is only changed back to X by a small even priority; a small
odd priority does not change the obligation. We say that v is even-biased delayed
simulated by w, denoted v ⊑e
de w iﬀ Duplicator has a winning strategy from
(v, w) with obligation γe(v, w, X) in the even-biased delayed simulation game.
Likewise, we obtain well-founded, even-biased delayed simulation by repla-
cing all occurrences of γ by γe in Deﬁnition 10. Vertex v is well-founded, even-
biased delayed simulated by w, denoted v ≤e
de w, iﬀ there exists a well-founded,
even-biased delayed simulation preorder R such that v Rγ e(v,w,X) w.

Odd-biased delayed simulation. Odd-biased delayed simulation is deﬁned
in a similar way as the even-biased delayed simulation. Instead of small even
priorities leading to an update of a pending obligation, small odd priorities lead
to a change in the obligation. Given two priorities and an existing obligation,
a new obligation is obtained using the update function γo : Ω × Ω × K → K,
where:

γo(n, m, k) =


k

if m 4 n, m even, m ≤ k,
and (n even or k < n)

γ (n, m, k) otherwise

The game-based and coinductive deﬁnitions are analogous to the even-biased
version.

6 Governed Bisimulation and Governed Stutter-

ing Bisimulation

In this section we consider essentially two notions of bisimulation for parity
games, and some derived notions. First, in Section 6.1, we introduce governed
bisimulation, which was studied under various guises in e.g. [24, 37, 39]. Gov-
erned bisimulation is, as we demonstrate in that section, closely related to direct
simulation. Next, in Section 6.2, governed stuttering bisimulation [12, 15, 37] is
introduced.

6.1 Governed bisimulation

Our deﬁnition of governed bisimulation, as presented below, is based on the one
from [39] where it is deﬁned in the closely related setting of Boolean equation

19

0 v1

1

1

v3

v4

0

v6

0

1

2

v0

v2

v5

Figure 4: Parity game in which v2 and v3 are governed bisimilar. Vertices v0,
v1 and v6 are direct simulation equivalent. Vertices v0 and v6 are governed
bisimilar but not strong direct simulation equivalent. Vertices v0 and v1 are
strong direct simulation equivalent, but not governed bisimilar.

systems; because of its capabilities to relate conjunctive and disjunctive equa-
tions, it was dubbed idempotence identifying bisimulation. It was rephrased for
parity games in [37] and there named governed bisimulation.

Deﬁnition 11 (Governed bisimulation). A symmetric relation R ⊆ V × V is a
governed bisimulation iﬀ v R w implies

• Ω(v) = Ω(w);

• if P(v) 6= P(w), then v′ R w′ for all v′ ∈ v• and w′ ∈ w•;

• for all v′ ∈ v• there is some w′ ∈ w• such that v′ R w′.

Vertices v and w are said to be governed bisimilar, denoted v ↔ w, if and only
if there is a governed bisimulation R such that v R w.

Example 3. In the parity game in Figure 4, we have for all i, vi ↔ vi, and
furthermore, v2 ↔ v3 and v0 ↔ v6. Observe that we have v0 ≡d v1, where
v0 ≤d v1 is witnessed by relation R1 = {(vi, vi) | 0 ≤ i ≤ 5} ∪ {(v0, v1)}, and
v1 ≤d v0 is witnessed by R2 = {(vi, vi) | 0 ≤ i ≤ 5} ∪ (v1, v0), (v4, v2), (v4, v3)}.
We do, however, not have v0 ↔ v1, since the latter would require v4 to be related
to v2, but from v4 the step v2 → v5 cannot be mimicked.

Governed bisimulation is such that vertices owned by diﬀerent players can
only be related whenever all their successors are. It turns out that this is exactly
what is obtained when imposing a symmetry requirement on direct simulation.
As a result, we have the following theorem.

Theorem 4. We have v ↔ w iﬀ there is a symmetric direct simulation relation
R such that v R w.

Proof. We prove both implications separately.

⇒ Let R be a governed bisimulation, and let v, w be arbitrary such that
v R w. Since R is symmetric, it suﬃces to show that R is a direct
simulation.

– Ω(v) = Ω(w) follows immediately.

20

– Suppose v ∈ V (cid:3) . Let v′ ∈ v•. In case w ∈ V(cid:3) we have v′ R w′ for all
w′ ∈ w• If w ∈ V (cid:3) , there is some w′ ∈ w• such that v′ R w′. Both
cases lead to the desired w (cid:3) → v′ R.

– Suppose v ∈ V(cid:3). We again distinguish two cases. In case w ∈ V (cid:3) we
have for all v′ ∈ v• and w′ ∈ w•, v′ R w′, i.e. w (cid:3) → v• R. Suppose
w ∈ V(cid:3). Pick an arbitrary w′ ∈ w•. Since R is symmetric, also
w R v. Hence, there exists a v′ ∈ v• such that w′ R v′, which implies
v′ R w′. Thus, both cases lead to w (cid:3) → v• R.

⇐ Let R be a symmetric direct simulation relation. Pick arbitrary v, w for

which v R w.

– Ω(v) = Ω(w) follows immediately.
– Suppose P(v) 6= P(w). Because R is symmetric, we may assume,
without loss of generality, that v ∈ V (cid:3) and w ∈ V(cid:3). Pick an arbitrary
v′ ∈ v•. Since R is a direct simulation, we ﬁnd w (cid:3) → v′ R. As
w ∈ V(cid:3), we thus ﬁnd that v′ R w′ for all w′ ∈ w•.

– Let v′ ∈ v•. By the previous case, it suﬃces to consider only the
case that P(v) = P(w). Suppose v, w ∈ V (cid:3) . Then w (cid:3) → v′ R; i.e.
there is some w′ ∈ w• such that v′ R w′. Now assume v, w ∈ V(cid:3).
By symmetry, we have w R v. Then we have v (cid:3) → w• R. Thus,
for every v′′ ∈ w• there is some w′ ∈ w• such that w′ R v′′.
In
particular, we have w′ R v′ for some w′ ∈ w•. By symmetry, we then
also have v′ R w′ for some w′ ∈ w•.

As a consequence, we immediately ﬁnd that governed bisimilarity is an equi-

valence relation.

Theorem 5. ↔ is an equivalence relation on parity games.

Proof. Follows from combining Theorem 4 and Proposition 1.

Additionally, we immediately obtain a game-based deﬁnition for governed
bisimulation: we only need to require that Spoiler can switch to a symmetric
position in the game play.

Deﬁnition 12 (Governed bisimulation game). The governed bisimulation game
is played on conﬁgurations drawn from V × V , and it is played in rounds. A
round of the game proceeds as follows:

1. Spoiler chooses (u0, u1) ∈ {(v, w), (w, v)};

2. The players move from (u0, u1) according to the rules in Table 1

3. Play continues in the next round from the newly reached position.

An inﬁnite play (v0, w0), (v1, w1), . . . is won by Duplicator if Ω(vj) = Ω(wj ) for
all j, i.e., Duplicator was able to mimic every move from Spoiler with a move
to a vertex with equal priority. In all other cases Spoiler wins the play.

We write v ≡g w whenever Duplicator has a winning strategy from (v, w) in

the governed bisimulation game.

Theorem 6. For all v, w ∈ V , we have v ↔ w if and only if v ≡g w.

Proof. Along the lines of the proof of Theorem 2.

21

If we again impose the additional constraint on gov-
Strong Bisimulation.
erned bisimulation that we do not allow to relate vertices owned by diﬀerent
players, we obtain a notion called strong bisimulation [37]. The derived notion
of strong bisimilarity, denoted v ↔ w and deﬁned as v ↔ w iﬀ there is some
strong bisimulation relation that relates v and w, is an equivalence relation.

6.2 Governed stuttering bisimulation

The (bi)simulation games discussed so far all have in common that the game-
play proceeds in ‘lock-step’: Duplicator must match every move proposed by
Spoiler with a proper countermove. In a sense, this ignores the fact that the
parity condition is not sensitive to ﬁnite repetitions of priorities but only cares
about inﬁnite repetitions. The insensitivity of the parity condition to ﬁnite
repetitions is reminiscent to the notion of stuttering in process theory. Indeed,
as we demonstrate in what follows, governed bisimulation can be weakened such
that it becomes insensitive to ﬁnite stuttering, but remains sensitive to inﬁnite
stuttering. The resulting relation is called governed stuttering bisimulation.

Essentially, governed stuttering bisimulation is obtained by porting stutter-
ing equivalence for Kripke structures to the setting of parity games. Intuitively,
governed stuttering bisimulation requires that a move from a vertex v to v′ is
matched by a ﬁnite (and potentially empty) sequence of moves from w, through
vertices that remain related to v, to arrive at some w′ that is related to v′. In
addition, every divergent play from a vertex v (i.e. a play that remains conﬁned
to a single equivalence class) should be matched with a divergent play from a
related vertex w.

Details, however, are subtle.

In stuttering equivalence it suﬃces to have
the ability to move or diverge and match such moves or divergences with some
move or a divergence. In contrast, in the parity game setting we are concerned
with player’s capabilities. Only moves and divergences that can be forced by a
player count, and matching of such moves and divergences must be done through
moves or divergences that the same player can force. Figure 5 illustrates some
of these concepts. While in the depicted parity game there is an inﬁnite play
that passes through the two left-most vertices with priority 0, neither even nor
odd can force such an inﬁnite play. As a result, we may ignore such inﬁnite
plays, and in this sense, the abilities (for both players) from those two vertices
are no diﬀerent from the abilities both players have from the two right-most
vertices with priority 0.

v0

v1

0

0

1

v2

0

0

v3

v4

Figure 5: Equal priorities are related by ∼. Neither player can force play to
visit only vertices with priority 0.

The deﬁnition of governed stuttering bisimulation presented below is based

22

on [12, 15]. For our deﬁnition, we strongly rely on our notation to denote that
a player is able to ‘force play’.

Deﬁnition 13 (Governed stuttering bisimulation). Let R ⊆ V × V be an
equivalence relation. Then R is a governed stuttering bisimulation if and only
if v R w implies

a) Ω(v) = Ω(w);

b) v → C implies w P(v)7→R C, for all C ∈ V/R \ {[v]R }.

c) v i7→R implies w i 7→R for i ∈ { (cid:3) , (cid:3)}.

Vertices v and w are governed stuttering bisimilar, denoted v ∼ w, iﬀ a governed
stuttering bisimulation R exists such that v R w.

Example 4. The parity game in Figure 5 nicely illustrates the key properties
for vj in {v0, v1, v3, v4} we have neither
of governed stuttering bisimulation:
7→∼ nor vj (cid:3)7→∼. Furthermore, for all these vertices, both players can force
vj (cid:3)
the game to reach vertex v2. Therefore, all vertices with the same priorities are
related by ∼. Also note that the vertices with priority 0 are not related by, e.g.,
governed bisimulation since the latter is sensitive to counting, and v0 and v1
can reach multiple equivalence classes.

Proving that governed stuttering bisimilarity is an equivalence relation that
is again a governed stuttering bisimulation relation is technically involved. In
particular, all standard proof techniques for doing so break down or become
too complex to manage. Instead of a large monolithic proof of the result, we
proceed in small steps by gradually rephrasing the above deﬁnition to one that
is ultimately more easily seen to be an equivalence. Our ﬁrst step in this dir-
ection is to remove the asymmetry in clause b) of the deﬁnition of governed
stuttering bisimulation. Before we do so, we state a useful lemma that allows
us to strengthen the conclusion of Lemma 7.

Lemma 12. Let R be a governed stuttering bisimulation. Let U ⊆ V/R \ {[v]R}.

Proof. Let v be such that v → U for some U ⊆ V/R \ {[v]R}. Suppose u → C for
some C /∈ U ∪ {[v]R}. Since v ∼ u, by Deﬁnition 13, we have v P(u)7→R C. But

If v• ⊆S U, then u• \ [v]R ⊆S U for all u ∈ [v]R.
v• ⊆S U and C /∈ U so v P(u)6

7→R C. Contradiction.

Theorem 7. Let R ⊆ V × V and v, w ∈ V . Then R is a governed stuttering
bisimulation iﬀ R is an equivalence relation and v R w implies:

a) Ω(v) = Ω(w);

b) v i7→R C iﬀ w i7→R C for all i ∈ { (cid:3) , (cid:3)}, C ∈ V/R \ {[v]R};

c) v i7→R iﬀ w i 7→R for all i ∈ { (cid:3) , (cid:3)}.

Proof. The proof for the implication from right to left follows immediately.
We focus on the implication from left to right. Assume that R is a governed
stuttering bisimulation. We prove the second condition only; the other two
conditions follow immediately from Deﬁnition 13 and symmetry of R. Let i be an
arbitrary player and assume that v i 7→R C for given v ∈ V and C ∈ V/R \ {[v]R}.
Let S = {u ∈ [v]R | u• ∩ C 6= ∅}. We distinguish two cases.

23

• Case Vi ∩ S 6= ∅. Let u ∈ S ∩ Vi . Since u → C, w i 7→R C follows from

Deﬁnition 13.

• Case S ⊆ V¬i . By Lemma 7, there is a u ∈ S for which u• ⊆ C and by
Lemma 12 (for U = {C}), u• \ [v]R ⊆ C for all u ∈ [v]R. Furthermore, by
Lemma 5, v i7→R C implies v ¬i6
7→R and
by Lemma 5, w i 7→R V \ [v]R. But since u• ⊆ C ∪ [v]R for all u, the desired
w i 7→R C follows from Lemma 8.

7→R. Then, by Deﬁnition 13, w ¬i 6

While the above alternative characterisation of governed stuttering bisimu-
lation is now fully symmetric, the restriction on the class C that is considered
in clause b) turns out to be too strong to facilitate an insightful proof that ∼ is
an equivalence relation. We therefore further generalise this clause such that it
is phrased in terms of sets of classes.

A perhaps surprising side-result of this generalisation is that the divergence
requirement of clause c) becomes superﬂuous. Note that this generalisation
is not trivial, as v i7→R {C1, C2} is in general neither equivalent to saying that
v i 7→R C1 and v i 7→R C2, nor v i 7→R C1 or v i7→R C2.

Theorem 8. Let R ⊆ V × V and v, w ∈ V . Then R is a governed stuttering
bisimulation iﬀ R is an equivalence relation and v R w implies:

a) Ω(v) = Ω(w);

b) v i7→R U iﬀ w i 7→R U for all i ∈ { (cid:3) , (cid:3)}, U ⊆ V/R \ {[v]R}.

Proof. We show that the second condition is equivalent to the conjunction of
the last two conditions in Theorem 7. We split the proof into an if -part and an
only-if -part.

⇐ The second condition from Theorem 7 is equivalent to the second condition
above if we let U range only over singleton sets (if v i 7→R C, take U = {C}).
The third condition is equivalent to the second condition above, where
U = V/R \ {[v]R}. This can be seen by appealing to Lemma 5.

⇒ Let R be a governed stuttering bisimulation and let v, w ∈ V such that
v R w. Assume that v i 7→R U for some U ⊆ V/R \ {[v]R}. Let S = {u ∈
[v]R | u → U}. By Lemma 7, either S ∩ Vi 6= ∅ or there is some u ∈ S
such that u• ⊆ U. We consider both cases separately.

– Case S ∩ Vi 6= ∅. Pick some u from this set. There is a class C ∈ U
such that u → C (in particular, u i7→R C since u ∈ Vi ). By Theorem 7
then also w i 7→R C, from which w i 7→R U follows immediately.

– Case S ∩ Vi = ∅. Then u• ⊆ U for some u ∈ S, but then, by
Lemma 12, t• \ [v]R ⊆ U for all t ∈ [v]R. From v i 7→R U we derive,
using Lemma 5, that not v ¬i 7→R. By Theorem 7 it follows that not
w ¬i7→R , and by Lemma 5 again w i 7→R V \[v]R. Since for all t ∈ [v]R,

t• ⊆ [v]R ∪S U andS U ⊆ V \ [v]R, by Lemma 8, also w i 7→R U.

In the previous theorem, we lifted the notion of forcing play via the current
equivalence class towards a target class, to the notion of forcing a play via the
current equivalence class towards a set of target classes. This is still not suﬃcient

24

for easily proving transitivity of governed stuttering bisimulation. Therefore, in
the theorem below, we introduce a ﬁnal generalisation; rather than forcing play
towards a set of target classes via the current equivalence class, we now allow
the play to be forced to that set via a set of equivalence classes.

Theorem 9. Let R ⊆ V × V and v, w ∈ V . Then R is a governed stuttering
bisimulation iﬀ R is an equivalence relation and v R w implies:

a) Ω(v) = Ω(w);

b) v i7→U T iﬀ w i 7→U T for all i ∈ { (cid:3) , (cid:3)}, U, T ⊆ V/R such that [v]R ∈ U

and [v]R /∈ T .

Proof. We show that the second condition is equivalent to the second condition
in Theorem 8. We split the proof into an if -case and an only-if -part.

⇐ The second condition from Theorem 8 is equivalent to the second condition

above if we ﬁx U = {[v]R}.

⇒ Let R be a governed stuttering bisimulation and let i, v, w, U and T be
as described. Assume that v i 7→U T ; under this assumption we will prove
that w i 7→U T . The proof for the implication in the other direction is
completely symmetric. Let σ ∈ Si be such that v σ7→U T and consider the
set of paths originating in v that are allowed by σ. All these paths must

have a preﬁx v . . . v′, u such that v, . . . , v′ /∈S T but u ∈S T . Call these

preﬁxes the σ-preﬁxes of v.

We proceed by induction on the length of the longest such preﬁx. If the
longest preﬁx has length 2, then all preﬁxes have length 2, implying that
v i→ T . In particular, v i7→R T and by Theorem 8 also w i 7→R T , which
proves w i7→U T .
As the induction hypothesis, assume that if u R u′, u σ7→U T and the
longest σ-preﬁx of u is shorter than the longest σ-preﬁx of v, then u′
i7→U T .
Note that every σ-preﬁx p of v must have a ﬁrst position n such that
p[n] /∈ [v]R . Collect all these p[n] in a set U , and notice that for all u ∈ U ,
also u σ7→U T . Furthermore, v σ7→R U .

By Theorem 8, w i 7→R[U ]R . Now consider an arbitrary u′ ∈ S[U ]R . Be-

cause there is some u ∈ U such that u R u′, its longest σ-preﬁx is shorter
than the longest σ-preﬁx of v, and because u σ7→U T for such u, we can
use the induction hypothesis to derive that u′
The above in particular implies two facts: w i7→U [U ]R , and u′

i 7→U T for

i 7→U T .

all u′ ∈ S[U ]R . Using these, we can now apply Lemma 6 to conclude

w i 7→U T .

With this last characterisation, it is now straightforward to prove that gov-
erned stuttering bisimilarity is an equivalence relation. We do so by showing
that the transitive closure of the union of two governed stuttering bisimulations
R and S is again a governed stuttering bisimulation. The generalisation from
classes to sets of classes allows us to view equivalence classes in (R ∪ S)∗ as
the union of sets of equivalence classes of R (or S), giving us an easy way to
compare the eﬀect of the second requirement of Theorem 9 on (R ∪ S)∗ with its
eﬀect on R and S.

25

Theorem 10. ∼ is an equivalence relation.

Proof. We show that (R ∪ S)∗ is a governed stuttering bisimulation if R and S
are, by showing that (R∪S)∗ satisﬁes the conditions of Theorem 9 if R and S do.
If v, w ∈ V are related under (R ∪ S)∗, then there exists a sequence of vertices
u0, . . . , un such that v R u0 S . . . R un S w (the strict alternation between
the two relations can always be achieved because R and S are reﬂexive). By
transitivity of = we then have Ω(v) = Ω(w), so the ﬁrst property is satisﬁed.

For the second property, assume that v i7→U T for some i ∈ { (cid:3) , (cid:3)} and some
U, T ⊆ V/(R∪S)∗ such that [v](R∪S)∗ ∈ U and [v](R∪S)∗ /∈ T . We need to prove
that w i 7→U T . Note that R and S both reﬁne (R ∪ S)∗, so we can ﬁnd sets

UR ⊆ V/R and US ⊆ V/S such thatS UR =S US =S U. Because v i 7→U T , also

v i 7→UR T , and by Theorem 9 then u0 i 7→UR T , which is equivalent to u0 i7→US T .
By a simple inductive argument we now arrive at w i7→US T , which is equivalent
to w i 7→U T .

As a side-result of the proof of Theorem 10, we ﬁnd that the union of all
governed stuttering bisimulations is again a governed stuttering bisimulation,
which coincides with governed stuttering bisimilarity.

In order to better understand the diﬀerences between governed stuttering
bisimulation and, e.g. delayed simulation equivalence, we next provide a game-
based characterisation of the relation. While in this new game, Spoiler and Du-
plicator still move according to the same rules as in the delayed simulation game,
Duplicator now has more freedom to choose a new conﬁguration: she can now
also choose to ‘roll-back’ one of the proposed moves. This allows her to postpone
matching a move. Of course, such moves may not be postponed indeﬁnitely, so
some additional mechanism is needed to keep track of Duplicator ’s progress so
as to prevent Duplicator from becoming too powerful. For this, we use a system
of challenges and rewards: a †-challenge indicates Duplicator decided to match
a move by Spoiler by not moving; a X-reward indicates Duplicator matched a
move by Spoiler by making a countermove, and a challenge (k, u) taken from
{0, 1} × V indicates that Duplicator is in the process of matching a move to
vertex u. We let C denote the set of challenges ({0, 1} × V ) ∪ {†, X}.

Deﬁnition 14 (Governed Stuttering bisimulation game). The governed stut-
tering bisimulation game is played on an arena of conﬁgurations drawn from
(V × V ) × C, and it is played in rounds. A round of the game starting in a
conﬁguration ((v, w), c) proceeds as follows:

1. Spoiler chooses to play from (u0, u1) ∈ {(v, w), (w, v)};

2. the players move from (u0, u1) to (t0, t1) according to the rules in Table 1;

3. Duplicator selects a new conﬁguration drawn from the following set:

{((t0, t1), X), ((u0, t1), γ (c, (0, t0), v, u0)), ((t0, u1), γ (c, (1, t1), w, u1))}

where update γ is deﬁned as follows:

γ (c, c′, u, t) =


if Spoiler played on t, u = t and c ∈ {†, X, c′}

c′
X if u 6= t, or Spoiler played on t and c /∈ {†, X, c′}
†

otherwise

26

An inﬁnite play ((v0, w0), c0), ((v1, w1), c1), . . . is won by Duplicator if and
only if Ω(vj) = Ω(wj ) for all j and ck = X for inﬁnitely many k. Duplicator
wins the governed stuttering bisimulation game for a position (v, w) iﬀ she has
a strategy that wins all plays starting in conﬁguration ((v, w), X).

We write v ≡g,st w whenever Duplicator wins the governed stuttering bisim-

ulation game for position (v, w).

Observe that in the governed stuttering game, Duplicator earns, as explained
before, a X reward whenever she continues playing in the position determined
at the end of step 2. However, she also earns a X whenever Spoiler decides to
drop a pending challenge or, in step 1 of a round, switch positions. The example
below illustrates some of the intricacies in the game play.

Example 5. Consider the parity game depicted in Figure 5. In this parity game,
all vertices with priority 0 are related by ∼. The game illustrates why Duplicator
gains a X reward whenever Spoiler does not respect a pending challenge. This
can be seen as follows: consider the game starting in ((v1, v3), X) and suppose
Spoiler decides to play v1 → v2. The only suitable response by Duplicator is
to play v3 → v4. New conﬁgurations ((v2, v4), X) and ((v2, v3, X)) are not an
option for Duplicator since he immediately loses due to the diﬀerent priorities
of v2 and v4 or v3 respectively. The new conﬁguration chosen by Duplicator will
hence be ((v1, v3), (0, v2)), challenging Spoiler to play v1 → v2 again in the next
round. From this conﬁguration, if Spoiler indeed plays v1 → v2, Duplicator can
match with v4 → v2, and play stays in ((v2, v2), X) indeﬁnitely, leading to a win
from duplicator. Now, let us consider what happens if Spoiler plays v1 → v0
instead. Spoiler did not respect the challenge, and Duplicator matches with
v4 → v3, and we end up in ((v1, v3), X) again. If Duplicator would not have
earned a Xreward in this case, play would have ended up in ((v1, v3), (0, v0))
instead, and, if in the next round Spoiler again ignores the challenge, play
can alternate indeﬁnitely between ((v1, v3), (0, v0)) and ((v1, v4), (0, v2)), which
would result in a win for Spoiler . This is undesirable since we already observed
that v1, v3 and v4 are governed stuttering bisimilar.

For the remainder of this section we turn our attention to proving that the
governed stuttering bisimulation game and governed stuttering bisimulation co-
incide. Our next result states that whenever vertices v, w are governed stutter-
ing bisimilar, Duplicator wins all plays starting in conﬁguration ((v, w), X). We
sketch the main ideas behind the proof; details can be found in the Appendix.

Proposition 3. For all v, w ∈ V if v ∼ w then v ≡g,st w.

Proof. The proof proceeds by showing that Duplicator has a strategy that en-
sures 1) that plays allowed by this strategy move along conﬁgurations of the
form ((u0, u1), c) for which u0 ∼ u1 and 2) Duplicator never gets stuck playing
according to this strategy and 3) there is a strictly decreasing measure between
two consecutive non-X conﬁgurations on any play allowed by this strategy. To-
gether, this implies that Duplicator has a winning strategy for conﬁgurations
((v, w), X).

We next establish that vertices related through the governed stuttering
bisimulation game are related by governed stuttering bisimulation. A straight-
forward proof thereof is hampered by the fact that any purported governed

27

stuttering bisimulation relation is, by deﬁnition, required to be an equivalence
relation. However, proving that the governed stuttering bisimulation game in-
duces an equivalence relation is rather diﬃcult. The strategy employed to prove
the stated result is to use contraposition; this requires showing that for any given
pair of non-governed stuttering bisimilar vertices we can construct a strategy
that is winning for Spoiler . Note that we can do so because the governed stut-
tering bisimulation game has a Büchi winning condition, which implies the game
is determined. This strategy is based on a ﬁxpoint characterisation of governed
stuttering bisimilarity, given below.

Deﬁnition 15. Let R ⊆ V × V be an equivalence relation on V . The predicate
transformer F : V × V → V × V is deﬁned as follows:

F (R) = {(v, w) ∈ R | Ω(v) = Ω(w) ∧ ∀i ∈ { (cid:3) , (cid:3)}, U, T ⊆ V/R :

[v]R ∈ U ∧ [v]R /∈ T =⇒ v i 7→U T ⇔ w i7→U T }

The predicate transformer F has the following properties.

Lemma 13. F (R) is an equivalence relation for any equivalence relation R on
V .

Proof. Let R be an equivalence relation over V . Reﬂexivity of F (R) follows
from the fact that R is reﬂexive. Symmetry of F (R) follows from symmetry of
R and from the fact that for all (v, w) ∈ R we have [v]R = [w]R. For transitivity,
we observe that for all pairs (u, v), (v, w) ∈ F (R) and all U, T for which [u]R ∈ U
and [u]R /∈ T , if u i7→U T then also v i 7→U T . Since [u]R = [v]R, we immediately
conclude w i 7→U T . The implication from right to left follows from symmetric
arguments. Thus, F (R) is an equivalence relation.

Lemma 14. F is a monotone operator on the complete lattice of equivalence
relations on V .

Proof. By the previous lemma, it follows that F is an operator on the lattice of
equivalence relations on V . We next show that the operator is monotone. Let
R, S be arbitrary equivalences on V . Suppose R ⊆ S, and consider some pair
(v, w) ∈ F (R). From this, it follows that Ω(v) = Ω(w). Let i ∈ { (cid:3) , (cid:3)}, U, T ⊆
V/S, such that [v]S ∈ U and [v]S /∈ T . Deﬁne ¯U as the set {[u]R | [u]S ∈ U} and
deﬁne ¯T as the set {[u]R | [u]S ∈ T }. Since (v, w) ∈ F (R), we have:

v i7→ ¯U

¯T ⇔ w i 7→ ¯U

¯T

Since S ¯U =S U and S ¯T =S U, we immediately have:

v i7→U T ⇔ w i 7→U T

This proves that (v, w) ∈ F (S). Thus F is a monotone operator.

Corollary 2. We have ∼ = νF .

Proof. Follows from the fact that for R = νF and νF = F (νF ) the deﬁnition
of F reduces to the deﬁnition of governed stuttering bisimulation.

We ﬁnally state our completeness result. Again, we only outline the main

steps of the proof; details can be found in the Appendix.

28

Proposition 4. For all v, w ∈ V if v ≡g,st w then v ∼ w.

Proof. We essentially prove the contrapositive of the statement, i.e.
for all
v, w ∈ V , if v 6∼ w, then also v 6≡g,st w. Let v 6∼ w. By Corollary 2, then also
(v, w) /∈ νF . By the Tarski-Kleene ﬁxpoint approximation theorem, we thus

have (v, w) /∈ Tk≥1

that for all k ≥ 1:

F k(V ×V ). Using induction, one can prove, for Rk =Tl≤k Rl,

Spoiler wins the governed stuttering bisimulation game
for all conﬁgurations ((u0, u1), c) for which (u0, u1) /∈ Rk

(IH)

For the inductive case, one can construct a strategy for Spoiler that guarantees
he never gets stuck and for which every play allowed by the strategy either 1)
visits some conﬁguration ((t0, t1), c′) for which the induction hypothesis applies,
or 2) is such that there are only a ﬁnite number of X rewards along the play.

Propositions 3 and 4 lead to the following theorem.

Theorem 11. For all v, w ∈ V we have v ∼ w iﬀ v ≡g,st w.

Stuttering Bisimulation. When we impose the additional constraint on gov-
erned stuttering bisimulation that we do not allow to relate vertices owned by
diﬀerent players, we obtain a notion called stuttering bisimulation [14]. The
derived notion of stuttering bisimilarity, denoted v ≃ w and deﬁned as v ≃ w
iﬀ there is some stuttering bisimulation relation that relates v and w, is an
equivalence relation.

7 Quotienting

Simulation and bisimulation equivalences are often used to reduce the size of
graphs by factoring out vertices that are equivalent, i.e. by computing quotient
structures. This can be particularly interesting if computationally expensive
algorithms must be run on the graph: whenever the analysis such algorithms
perform on the graphs are insensitive to (bi)simulation equivalence, they can be
run on the smaller quotient structures instead. In our setting, the same reas-
oning applies: typically, parity game solving is expensive and it may therefore
pay oﬀ to ﬁrst compute a quotient structure and only then solve the resulting
quotient structure.

In this section, we show that most of the (bi)simulation relations we studied
in the previous two sections have unique quotient structures. A fundamental
property of quotienting is that the resulting quotient structure of a game should
again be equivalent to the original game. This requires that we lift the equi-
valences deﬁned on game graphs to equivalences between two diﬀerent game
graphs. We do so in the standard way.

Deﬁnition 16. Let Gj = (Vj , →j, Ωj, Pj), for j = 1, 2, be arbitrary parity
games. We say that G1 ∼ G2, for an equivalence relation ∼ deﬁned on the
vertices of a parity game, whenever in the disjoint union of G1 and G2, for all
v1 ∈ V1 there is some v2 ∈ V2 such that v1 ∼ v2 and for all ¯v2 ∈ V2 there is
some ¯v1 ∈ V1 such that ¯v1 ∼ ¯v2.

29

7.1 Simulation Equivalence Quotients

Quotienting for delayed simulation equivalence is, as observed in [21, 22], prob-
lematic, and only the biased versions admit some form of quotienting. However,
the quotients for biased delayed simulation equivalences are not unique, see also
Lemma 3.5 in [21]. We therefore only consider quotienting for direct simulation
equivalence.

The equivalence classes of direct simulation equivalence determine the set
of vertices of the quotient structure. Deﬁning the transition relation of the
quotient structure is a bit more subtle. As observed in [10], a unique quotient
structure of simulation equivalence for Kripke structures exists, but requires
that vertices have no transitions to a pair of vertices, one of which is sometimes
referred to as a ‘little brother’ of the other one (a vertex that is simulated by,
but not equivalent to the other vertex).

While in the setting of Kripke structures, only transitions to maximal suc-
cessor vertices must be retained, depending on the owner of the source vertex,
we need to consider maximal or minimal successor vertices.

Deﬁnition 17. Let V ′ ⊆ V be an arbitrary non-empty set of vertices. An
element v is:

• minimal among V ′ iﬀ for all u ∈ V ′ for which u ≤d v, also v ≤d u;

• maximal among V ′ iﬀ for all u ∈ V ′ for which v ≤d u, also u ≤d v.

For a given vertex v, a successor v′ ∈ v• is in the set min≤d (v) iﬀ v′ is minimal
among v•; likewise, v′ ∈ v• is in the set max≤d (v) iﬀ v′ is maximal among v•.

Since ≤d is a preorder, min≤d (v) and max≤d (v) are non-empty sets.
An additional complication in deﬁning a unique quotient structure is that a
single equivalence class may contain vertices owned by even and vertices owned
by odd . It turns out that the owner of such equivalence classes can be chosen
arbitrarily: we prove that such classes have a unique successor equivalence class.
For equivalence classes with exactly one successor, we can assign a unique owner;
we choose to assign such classes to player even.

Deﬁnition 18 (Direct simulation equivalence quotient). The direct simulation
equivalence quotient of (V, →, Ω, P) is the structure (V/≡d , →′, Ω′, P ′), where,
for C, C′ ∈ V/≡d :

• Ω′(C) = min{Ω(v) | v ∈ C},

• P ′(C) =((cid:3) if C ⊆ V(cid:3) and for all u ∈ C, |[min≤d (u)]≡d | > 1
• C →′ C′ iﬀ (∀v ∈ C : ∃v′ ∈ min≤d (v) : v′ ∈ C′

: ∃v′ ∈ max≤d (v) : v′ ∈ C′

∀v ∈ C ∩ V (cid:3)

(cid:3)

otherwise

if C ⊆ V(cid:3)
otherwise

Observe that it is not obvious that →′ is a total edge relation. The lemma

below allows us to establish that this is the case.

Lemma 15. Let C ∈ V/≡d . Then:

30

• If C ⊆ V(cid:3) then [min≤d (v)]≡d = [min≤d (w)]≡d for all v, w ∈ C,

• If C ⊆ V (cid:3)

then [max≤d (v)]≡d = [max≤d (w)]≡d for all v, w ∈ C,

• If C 6⊆ V(cid:3) and C 6⊆ V (cid:3)

then for all v ∈ C ∩ V (cid:3) and w ∈ C ∩ V(cid:3) we have

[max≤d (v)]≡d = [min≤d (w)]≡d .

Proof. We prove the ﬁrst and the third statement; the proof for the second
statement is analogous to that of the ﬁrst.

• Suppose C ⊆ V(cid:3). Pick v, w ∈ C. Let v′ ∈ min≤d (v). Since v′ ∈ v• and
w ≤d v, we have w′ ≤d v′ for some w′ ∈ w•. This implies that there is
some w′′ ∈ min≤d (w) such that w′′ ≤d v′; for, if w′ /∈ min≤d (w), then
there must be some w′′ ∈ min≤d (w) such that w′′ ≤d w′. But then also
w′′ ≤d v′.
We next show that also v′ ≤d w′′. Since v ≤d w and w′′ ∈ w• we have
v′′ ≤d w′′ for some v′′ ∈ v•. Since w′′ ≤d v′ and v′′ ≤d w′′, we have
v′′ ≤d v′. But since v′ ∈ min≤d(v), this implies v′ ≡d v′′. But from
v′ ≤d v′′ and v′′ ≤d w′′ we obtain v′ ≤d w′′.
Hence, v′ ≡d w′′ for some w′′ ∈ min≤d (w).

• Suppose P(v) 6= P(w) for some v, w ∈ C. Pick v, w ∈ C such that v ∈ V (cid:3)
and w ∈ V(cid:3). Since w ≤d v, there must be w′ ∈ w• and v′ ∈ v• such that
w′ ≤d v′. Fix such v′ and w′. Since v ≤d w we ﬁnd that for all v′′ ∈ v•
and w′′ ∈ w• we have v′′ ≤d w′′. In particular, v′ ≤d w′. So v′ ≡d w′.
Next, since for all w′′ ∈ w• we have v′ ≤d w′′ and v′ ≡d w′, we also
have w′ ≤d w′′ for all w′′ ∈ w•. But this implies w′ ∈ min≤d (w), and, in
particular, |[min≤d (w)]≡d | = 1. Likewise, we can deduce v′ ∈ max≤d(v)
and |[max≤d(v)]≡d | = 1.
We thus ﬁnd [max≤d (v)]≡d = {[v′]≡d } = {[w′]≡d } = [min≤d (w)]≡d .

As a consequence of the above lemma, we obtain the following two results:
Corollary 3. Let (V/≡d , →′, Ω′, P ′) be a direct simulation equivalence quotient
of some parity game (V, →, Ω, P). Then for all C, C′ ∈ V/≡d :

• if C ⊆ V(cid:3) and for some v ∈ C, v′ ∈ C′ also v′ ∈ min≤d (v), then C →′ C′.
6= ∅ and for some v ∈ C ∩ V (cid:3) , v′ ∈ C′ also v′ ∈ max≤d (v), then

• if C ∩ V (cid:3)
C →′ C′.

Corollary 4. The direct simulation reduced quotient structure associated to a
parity game (V, → Ω, P) is again a parity game.

We next establish that the direct simulation quotient of a parity game is

equivalent to the original parity game.
Theorem 12. Let G = (V, →, Ω, P) be a parity game and Gq = (V/≡d , →′
, Ω′, P ′) its direct simulation quotient. Then Gq ≡d G.

Proof. We ﬁrst prove Gq ≤d G. Let H ⊆ V/≡d × V be the relation H = {(C, v) |
∃w ∈ C : w ≤d v}. We prove H is a direct simulation relation. Let C, v be
arbitrary such that (C, v) ∈ H. By deﬁnition, there is some w ∈ C such that
w ≤d v. For the remainder of this proof, we ﬁx such a w. Clearly, Ω′(C) = Ω(v)
follows directly from w ≤d v and the fact that for all u, u′ ∈ C we have Ω(u) =
Ω(u′). We next prove the transfer condition. For this, we distinguish four cases.

31

• Case P(C) = (cid:3) and P(v) = (cid:3). Let v′ ∈ v•. Since v′ ∈ v•, also w′ ≤d v′
for some w′ ∈ w•. Let w− ∈ min≤d (w) such that w− ≤d w′. Then by
Corollary 3, C → [w−]≡d . Moreover, by transitivity, w− ≤d v′, so we have
([w−]≡d , v′) ∈ H, as required.

• Case P(C) = (cid:3) and P(v) = (cid:3) . Note that P(C) = (cid:3) implies C ⊆ V(cid:3); hence
P(w) = (cid:3). But then for some w′ ∈ w•, v′ ∈ v•, we have w′ ≤d v′. Let
v′, w′ be such. Then again for some w− ∈ min≤d (w) satisfying w− ≤d w′
we have C → [w−]≡d and by transitivity, we have ([w−]≡d , v′) ∈ H.

• Case P(C) = (cid:3) and P(v) = (cid:3) . Pick C′ ∈ C•. We must show that
(C′, v′) ∈ H for some v′ ∈ v•. Since P(C) = (cid:3) , there must be some
u ∈ C ∩ V (cid:3) ; pick such a u. Since u ≡d w ≤d v, for all u′ ∈ u• ∩ C′ there
is some v′ ∈ v• such that u′ ≤d v′. Hence, there is some v′ ∈ v• such that
(C′, v′) ∈ H.

• Case P(C) = (cid:3) and P(v) = (cid:3). Pick C′ ∈ C•. We must show that
(C′, v′) ∈ H for all v′ ∈ v•. Then the argument is similar to the previous
case.

Next, to prove G ≤d Gq, we show that H ⊆ V × V/≡d , given by H = {(v, C) |
∃w ∈ C : v ≤d w}, is a direct simulation relation. Let C, v be arbitrary such
that (v, C) ∈ H. By deﬁnition, there is some w ∈ C such that v ≤d w. We again
ﬁx such a w. Following similar arguments as above, Ω′(C) = Ω(v). We again
prove the transfer condition by distinguishing four cases.

• Case P(C) = (cid:3) and P(v) = (cid:3) . Pick v′ ∈ v•. We must show that

(v′, C′) ∈ H for some C′ ∈ C•. We distinguish two cases.

– Case C ⊆ V (cid:3) . Since v ≤d w, also v′ ≤d w′ for some w′ ∈ w•.
Consider w+ ∈ max≤d (w) such that w′ ≤d w+. Then by Corollary 3,
C → [w+]≡d . By transitivity v′ ≤d w′ ≤d w+; hence (v′, [w+]≡d ) ∈
H.

– Case C ∩ V(cid:3) 6= ∅ and C ∩ V (cid:3)

6= ∅. Then, by Lemma 15, C → C′ for
some unique C′. Fix this C′. Let u ∈ C ∩ V(cid:3). Then u′ ∈ C′ for some
u′ ∈ u•. Pick such a u′. Since u ≡d w, also v ≤d u. As a result,
v′ ≤d u′. Therefore (v′, C′) ∈ H.

• Case P(C) = (cid:3) and P(v) = (cid:3). We must show that (v′, C′) ∈ H for some

v′ ∈ v•, C′ ∈ C•. Then the argument is similar to the previous case.

• Case P(C) = (cid:3) and P(v) = (cid:3) . Let v′ ∈ v• and C′ ∈ C•. Since v ≤d w
and P(w) = (cid:3), we have v′ ≤d w′ for all w′ ∈ w• ∩ C′. Therefore also
(v′, C′) ∈ H.

• Case P(C) = (cid:3) and P(v) = (cid:3). Let C′ ∈ C• and let w′ ∈ w• ∩ C′. Since
v ≤d w, there must be some v′ ∈ v• such that v′ ≤d w′. Fix this v′. Then
also (v′, C′) ∈ H.

We ﬁnally prove that the quotient is unique.

Theorem 13. Let G, G′ be two parity games and let Gq and G′
q be their direct
simulation equivalence quotients, respectively. Then G ≡d G′ iﬀ the two struc-
tures Gq = (V/≡d , →q, Ωq, Pq) and G′

q) are isomorphic.

q = (V ′

/≡d , →′

q, Ω′

q, P ′

32

Proof. The proof that isomorphism of Gq and G′
q implies G ≡d G′ follows essen-
tially from Theorem 12 and that isomorphic structures are also direct simulation
equivalent.

The proof that G ≡d G′ implies that Gq and G′

q are isomorphic structures
follows the following steps. Assume that G ≡d G′. Let f ⊆ V ′
/≡d × V/≡d
be deﬁned as (C′, C) ∈ f iﬀ C′ ≡d C. Note that for all (C′, C) ∈ f we have
Ω′

q(C′) = Ωq(C).

We ﬁrst show that f is a total bijective function from V ′

/≡d to V/≡d . For
injectivity and functionality of f we reason as follows. Suppose f is not func-
tional. Then there is some v′ ∈ V ′ and two v, ¯v ∈ V such that [v]≡d 6= [¯v]≡d ,
([v′]≡d , [v]≡d ) ∈ f and ([v′]≡d , [¯v]≡d ) ∈ f . Then by deﬁnition, v′ ≡d v and
v′ ≡d ¯v. But then also v ≡d ¯v, contradicting that [v]≡d 6= [¯v]≡d . So f is func-
tional. The proof that f −1 is a function from V/≡d to V ′
/≡d is similar. We may
therefore conclude that f is an injective function.

For surjectivity of f , we observe that by deﬁnition of G ≡d G′, for each v ∈ V
there is some v′ ∈ V ′ such that v ≡d v′. Hence, for each [v]≡d ∈ V/≡d there is
/≡d such that ([v′]≡d , [v]≡d ) ∈ f . Similarly, we can show that
some [v]≡d ∈ V ′
f −1 is surjective and therefore f is total bijection.

We next prove that P ′

q(C) = (cid:3) whereas Pq(f (C)) = (cid:3)

q(C) = Pq(f (C)). Towards the contrary, assume that
P ′
(cid:3) and for all v ∈ C
we have | min≤d(v)| > 1, and there is some w ∈ f (C) satisfying either w ∈ V (cid:3) ,
or | min≤d (w)| = 1. Let w ∈ f (C) be such and pick an arbitrary v ∈ C. We
distinguish two cases.

for some C. Then C ⊆ V ′

• Case w ∈ V (cid:3) . Since w ≡d f (C) ≡d C ≡d v we have w ≤d v in particular.
Pick an arbitrary w′ ∈ w•. Then, since P(v) = (cid:3), we have w′ ≤d v′
for all v′ ∈ v•; more speciﬁcally, we have w′ ≤d v′
2 for
v′
1, v′
2 are minimal elements,
2 ≡d w′.
we thus also have v′
But from this we obtain v′

2 ≤d w′ and hence v′
2. Contradiction.

1 ≤d w′ and v′
1 ≡d v′

2 ∈ min≤d (v) such that v′

1 and w′ ≤d v′

1 ≡d w′ and v′

2. Since v′

1 6≡d v′

1, v′

• Case | min≤d (w)| = 1. Without loss of generality we may assume that
1, v′
2 ∈
2 ∈ w•
2 be such; without loss of
2 are
1 and
2 are

w ∈ V(cid:3). Since w ≡d f (C) ≡d C ≡d v we also have w ≤d v. Let v′
min≤d (v) be such that v′
1, w′
2 ≤d v′
such that w′
generality, we may assume that w′
minimal, we ﬁnd that v′
2. But because v′
2 ≡d w′
v′
minimal we have |[min≤d (w)]≡d | ≥ 2. Contradiction.

1, w′
2 are minimal. Since v′

2. Then there must be some w′

2 and hence v′
2. Since w′

1, v′
1 ≡d w′
1 and w′

1 and v′
2 we have w′

2. Let w′
1 and w′

1 ≤d w′
1 6≡d v′

1 and w′

2 ≤d w′

1 6≡d w′

1 ≤d v′

1 6≡d v′

Hence, P ′

q(C) = Pq(f (C)).

q C′ but
Finally, we prove that C →′
not f (C) →q f (C′). Assume P ′
q(C) =
Pq(f (C)) = (cid:3) is similar. Since C ≡d f (C), there must be some D such that
f (C) →q D and C′ ≤d D. But then also C →′
q C′′ and D ≤d C′′ for some C′′.
Then C′ ≤d C′′. Distinguish two cases:

q C′ iﬀ f (C) →q f (C′). Suppose C →′
q(C) = Pq(f (C)) = (cid:3) . The case where P ′

• Case C′ = C′′. Then f (C′) = f (C′′) = D, contradicting our assumption

that f (C) 6→q f (C′).

• Case C′ 6= C′′. Then we have C →′

q C′ and C →′

this means that vertices in C′ are not maximal. Hence, G′
a transition C →′

q C′.

q C′′ and C′ ≤d C′′. But
q does not have

33

Corollary 5. The direct simulation equivalence quotient of G is a unique (up-to
isomorphism) parity game direct simulation equivalent to G.

7.2 Governed Bisimulation and Governed Stuttering Bisim-

ulation Quotients

We ﬁrst deﬁne the governed bisimilarity quotients and claim some elementary
results of these. We then deﬁne the governed stuttering bisimilarity quotient.

Deﬁnition 19 (Governed bisimulation quotient). The governed bisimulation
quotient of (V, →, Ω, P) is the structure (V/↔, →′, Ω′, P ′), where, for C, C′ ∈ V/↔:

• Ω′(C) = min{Ω(v) | v ∈ C},

• P ′(C) =((cid:3) if C ⊆ V(cid:3) and for all u ∈ C, |[u•]↔| > 1

otherwise

(cid:3)

• C →′ C′ if and only if ∀v ∈ C : ∃v′ ∈ v• : v′ ∈ C′

Theorem 14. Let G = (V, →, Ω, P) be a parity game and Gq = (V/↔, →′, Ω′, P ′)
be its governed bisimulation quotient. Then G ↔ G′.

Proof. Follows from the fact that the relation R = {(v, C), (C, v) | v ∈ C}, is a
governed bisimulation relation.

Theorem 15. Let G, G′ be two parity games and let Gq and G′
q be their direct
simulation equivalence quotients, respectively. Then G ↔ G′ iﬀ the two structures
Gq = (V/↔, →q, Ωq, Pq) and G′

q) are isomorphic.

q = (V ′

/↔, →′

q, Ω′

q, P ′

Proof. Similar to the proof of Theorem 13.

Corollary 6. The governed bisimulation quotient of G is a unique (up-to iso-
morphism) parity game that is governed bisimilar to G.

We next deﬁne the governed stuttering bisimulation quotient.

It requires
some subtlety to properly deal with divergences and ensure that a unique player
is assigned to an equivalence class.

Deﬁnition 20 (Governed stuttering bisimulation quotient). The governed stut-
tering bisimulation quotient of (V, →, Ω, P) is the structure (V/∼, →′, Ω′, P ′),
where, for C, C′ ∈ V/∼:

• Ω′(C) = min{Ω(v) | v ∈ C},

(cid:3) otherwise

if for all v ∈ C, v (cid:3)

• P ′(C) =( (cid:3)
• C →′ C′ if and only if (∃i ∈ { (cid:3) , (cid:3)} : ∀v ∈ C : v i 7→∼

∃i ∈ { (cid:3) , (cid:3)} : ∀v ∈ C : v i 7→∼ C′

if C = C′
if C 6= C′

7→∼, or for some v ∈ C, C′ 6= C, v (cid:3) → C′

Theorem 16. Let G = (V, →, Ω, P) be a parity game and Gq = (V/∼, →′, Ω′, P ′)
be its governed stuttering bisimulation quotient. Then G ∼ Gq.

34

Proof. Consider the relation R ⊆ (V ∪ V/∼) × (V ∪ V/∼), deﬁned as follows:

R = {(v, C), (C, v), (v, w), (C, C) | v, w ∈ C}

Then R is a governed stuttering bisimulation relation. Note that R is an equi-
valence relation. It thus suﬃces to prove that R meets the remaining conditions
of governed stuttering bisimulation. We do so by proving that R is a governed
stuttering bisimulation for the following cases: v R w, C R C′, v R C and
C R v. Observe that for v, w ∈ V we have v R w iﬀ in G we have v ∼ w, and
for C, C′ ∈ V/∼ we have C R C′ iﬀ C = C′. As a result, for these cases R is
immediately a governed stuttering bisimulation relation. We therefore focus on
the cases v R C and C R v. Both cases are addressed separately.

Suppose that v R C. We reason as follows:

• By deﬁnition, Ω(v) = Ω′(C) as all w ∈ C are such that Ω(w) = Ω(v).

• Suppose v → C′ for some C′ ∈ V/R \ {[v]R}. Then by deﬁnition of ∼ we

have w P(v)7→∼ C′ for all w ∈ C and therefore C →′ C′.

– Case P(v) = (cid:3) . Since for all w ∈ C we have w (cid:3)

7→∼ C′, there is some
w ∈ C such that w (cid:3) → C′ and therefore P ′(C) = (cid:3) . Because C →′ C′,
also C (cid:3)

7→R C′.

– Case P(v) = (cid:3). Suppose P ′(C) = (cid:3). Since C →′ C′, also C (cid:3)7→R C′.
Next, suppose P ′(C) = (cid:3) . Then there must be some w ∈ C and some
C′′ 6= C such that w (cid:3) → C′′, as w (cid:3)
7→∼ would conﬂict with w (cid:3)7→∼ C′.
Let w be such. We also have w (cid:3)7→∼ C′. This can only be the case if
P(w) = (cid:3) and w• ⊆ C′. But then C′ is the only successor of C, i.e.
C →′ C′′ implies C′′ = C′, and therefore C (cid:3)7→R C′.

• Suppose v i 7→R. Then w i7→R for all w ∈ C. But then also C →′ C.

– Case i = (cid:3) . Then also P ′(C) = (cid:3) and since C →′ C, also C i 7→R.
If P ′(C) = (cid:3), then, since C →′ C, also C i 7→R.
– Case i = (cid:3).

P ′(C) = (cid:3) , then also v (cid:3)
C′ 6= C contradicts u (cid:3)7→∼. But v (cid:3)
all C′ such that C →′ C′, we have C′ = C. Hence, also C i 7→R.

If
7→∼, since u (cid:3) → C′ for some u ∈ C and
7→∼ and v (cid:3)7→∼ implies that for

Assume that C R v. We now reason as follows:

• Ω′(C) = Ω(v) follows from the same arguments as before.

• Suppose C →′ C′ for some C′ 6= C. Then there is some i ∈ { (cid:3) , (cid:3)} such

that for all w ∈ C, we have w i 7→∼ C′. We distinguish two cases.

– Assume P ′(C) = (cid:3) .

∗ Case i = (cid:3) . Then v (cid:3)
∗ Case i = (cid:3). Hence, for all w ∈ C, we have w (cid:3)7→∼ C′. Since
6= C, such that

7→∼ follows immediately since v ∈ C.

P ′(C) = (cid:3) , there must be some w ∈ C, C′′
w (cid:3) → C′′, since w (cid:3)
7→∼ contradicts w (cid:3)7→∼ C′.
Let w be such, and observe that w (cid:3)
the case if C′′ = C′, and from w (cid:3)
v (cid:3)

7→∼ C′

7→∼ C′′. This can only be
7→∼ C′′ and C′′ = C′ we obtain

35

– Assume P ′(C) = (cid:3). Observe that this implies that i = (cid:3), since, if
7→∼ C′, which means there is
i = (cid:3) , then for all w ∈ C, we have w (cid:3)
some w ∈ C for which w (cid:3) → C′. This contradicts P ′(C) = (cid:3). So,
It then immediately follows that for all w ∈ C, we have
i = (cid:3).
w (cid:3)7→∼ C′, and in particular v (cid:3)7→∼ C′.

• Assume that C i 7→R. We distinguish two cases.

– Case i = (cid:3) . Observe that P ′(C) = (cid:3) . Suppose that P ′(C) = (cid:3),
7→R implies that for all C′ such that C →′ C′ we have C′ = C
7→∼. This

then C (cid:3)
and therefore, for all w ∈ C we have both w (cid:3)7→∼ and w (cid:3)
contradicts P ′(C) = (cid:3), hence P ′(C) = (cid:3) .
7→∼ for all w ∈ C.
Now, towards a contradiction, assume that w (cid:3)
Because P ′(C) = (cid:3) , there must be some w ∈ C such that w (cid:3) → C′
for some C′
7→∼ but C →′ C, we
must have w (cid:3)7→∼. This contradicts w (cid:3) → C′. So there must be
some w ∈ C such that w (cid:3)
7→∼ and therefore
v (cid:3)

6= C. Let w be such. Since w (cid:3)

7→∼. But then also v (cid:3)

7→R.

6= C. Hence, for all w ∈ C we have w (cid:3)

– Case i = (cid:3). Suppose P ′(C′) = (cid:3) . Because C (cid:3)7→R we ﬁnd that
7→∼ and

C 6→′ C′ for C′
w (cid:3)7→∼; in particular, v (cid:3)7→R.
Next, assume that P ′(C′) = (cid:3). Then there must be some w ∈ C such
7→∼ for all w ∈ C. Then C →′ C can
that w (cid:3)
only be because for all w ∈ C we have w (cid:3)7→∼. In particular, v (cid:3)7→∼
and therefore v (cid:3)7→R.

7→∼. Consequently w (cid:3)

Theorem 17. Let G, G′ be two parity games and let Gq and G′
q be their direct
simulation equivalence quotients, respectively. Then G ∼ G′ iﬀ the two structures
Gq = (V/∼, →q, Ωq, Pq) and G′

q) are isomorphic.

q = (V ′

/∼, →′

q, Ω′

q, P ′

Proof. Again similar to the proof of Theorem 13.

Corollary 7. The governed stuttering bisimulation quotient of G is a unique
(up-to isomorphism) parity game that is governed stuttering bisimilar to G.

8 A Comparison of Discriminating Power

In this section, we compare the discriminative power of each of the equivalences
discussed in the preceding sections, essentially justifying the lattice we illus-
trated in Section 4. This permits us to assess the reductive power of each of
the studied equivalences that admit (unique) quotienting. For each of the equi-
valences we show which other equivalences it strictly reﬁnes. Incomparability
results are described separately.

We ﬁrst focus on proving the right-hand side of the lattice we presented
in Section 4. That is, we ﬁrst compare isomorphism, strong bisimilarity and
governed bisimilarity and then focus on the various simulation equivalences.

Theorem 18. Isomorphism is strictly ﬁner than strong bisimilarity.

Proof. Clearly, every pair of isomorphic parity games is a pair of strong bisimilar
parity games. Strictness follows from a standard example:

36

6
6
6
6
1

v2

0

v1

1

v3

Figure 6: Parity game which is minimal with respect to strong bisimilarity.
Vertices v2 and v3 are governed bisimilar.

0

0

0

Clearly, both vertices in the left parity game are strongly bisimilar to the ver-
tex in the right parity game, and vice versa. However, these vertices are not
isomorphic.

The following theorem relates strong bisimilarity to stuttering equivalence,
governed bisimulation and strong direct simulation equivalence, and except for
the comparison to governed bisimulation it is essentially the counterpart of the
classical theorems in the setting of Kripke structures.

Theorem 19. Strong bisimilarity is strictly ﬁner than strong direct simula-
tion equivalence, stuttering bisimulation equivalence and governed bisimulation
equivalence.

Proof. We sketch each of the reﬁnements:

• Every strong bisimulation relation is a direct simulation relation. Since
such a relation is symmetric, every pair of parity games related via strong
bisimilarity is also related via strong direct simulation equivalence. Strict-
ness follows from the parity game in Figure 4, in which v0 and v1 are strong
direct simulation equivalent but not strongly bisimilar.

• Every strong bisimulation relation is a stuttering bisimulation relation,
this follows directly from the deﬁnitiions. Strictness follows from the parity
game in Figure 5, in which v3 and v4 are stuttering bisimilar, but not
strongly bisimilar.

• Every strong bisimulation relation is a governed bisimulation relation, this
follows directly from the deﬁnitions. Strictness follows from the parity
game in Figure 6, which is minimal modulo strong bisimilarity, but vertices
v2 and v3 are governed bisimilar.

We next state, without proof, a result that essentially follows by deﬁnition.

Theorem 20. Strong direct simulation equivalence strictly reﬁnes direct simu-
lation equivalence.

The following reﬁnement results follow a line of reasoning similar to the ones

seen before.

Theorem 21. Governed bisimulation equivalence strictly reﬁnes direct simula-
tion equivalence and governed stuttering bisimulation equivalence.

Proof. We again sketch both reﬁnements.

37

• Reﬁnement follows directly from the observation that a governed bisimu-
lation is a symmetric direct simulation. Strictness follows from examples
similar to those discriminating strong bisimilarity and simulation equival-
ence.

• It follows from the deﬁnitions that every governed bisimulation is also a
governed stuttering bisimulation. The strictness of the reﬁnement follows
from the example in Figure 5 in which all vertices with priority 0 are
governed stuttering bisimilar, but none are governed bisimilar.

Theorem 22. Governed bisimulation equivalence and strong direct simulation
equivalence are incomparable.

Proof. This follows from the parity game in Figure 4 in which vertices v0 and
v6 are governed bisimilar, but not strong direct simulation equivalent. Fur-
thermore, v0 and v1 are strong direct simulation equivalent, but not governed
bisimilar.

To the best of our knowledge, the (elementary) result that direct simulation is
strictly ﬁner than (biased) delayed simulation has not been formally established.
We therefore give a brief proof here.

Theorem 23. Direct simulation equivalences is strictly ﬁner than even- and
odd-biased delayed simulation equivalence.

Proof. Let G = (V, →, Ω, P) be a parity game, with v, w ∈ V such that v ≡d w.
Observe that v ≤d w and w ≤d v. We prove that also v ⊑e
de v and
both cases for ⊑o
de follow the exact same line of reasoning. As a result, we ﬁnd
that v ≡e

de w; w ⊑e

de w and v ≡o

de .

Observe that D has a winning strategy in the direct simulation game from
(v, w). Therefore, in each round of the game, Duplicator was able to mimic
Spoiler ’s move by a move to a vertex with equal priority. If Duplicator plays
the same strategy in the delayed simulation game, this gives rise to plays with
obligation X in every conﬁguration that is reached.

Strictness follows straightforwardly from the observation that the (biased)
delayed simulation relations can relate vertices with diﬀerent priorities, whereas
direct simulation cannot.

The results relating (biased) delay simulations to each other and to winner

equivalence were proven by Fritz and Wilke [22].

Theorem 24. Even- and odd-biased delay simulation are incomparable, and
both are strictly ﬁner than delay simulation equivalence. Delay simulation equi-
valence in turn is strictly ﬁner than winner equivalence.

This completes the results underlying the right-hand side of the lattice we

presented in Section 4.

We next focus on the left-hand side of the lattice.

Theorem 25. Stuttering bisimilarity is incomparable to governed bisimilarity,
strong direct simulation, direct simulation and all delayed simulation variations.

38

Proof. In the parity game in Figure 5, v3 and v4 are stuttering bisimilar but
they cannot be related under governed bisimilarity, (strong) direct simulation
equivalence, nor any of the delayed simulation equivalences. For the other dir-
ection, consider vertices v0, v1 and v6 from the parity game in Figure 4. None
of these vertices are stuttering bisimilar, whereas v0 and v6 are governed bisim-
ilar, v0 and v1 are strong direct simulation equivalent, and all three are direct
simulation equivalent, and therefore also delay simulation equivalent.

Theorem 26. Governed stuttering bisimilarity is incomparable to strong direct
simulation, direct simulation and all delayed simulation variations.

Proof. Along the same lines as the proof of Theorem 25.

Theorem 27. Stuttering bisimilarity strictly reﬁnes governed stuttering bisim-
ilarity.

Proof. It follows from the deﬁnitions that every stuttering bisimulation is also
a governed stuttering bisimulation. Strictness follows from the parity game in
Figure 5 in which v0 and v1 are governed stuttering bisimilar, but not stuttering
bisimilar.

To complete the lattice, we next move to showing that governed stuttering
bisimilarity is strictly ﬁner than winner equivalence. In order to prove this result,
we must ﬁrst lift the concept of governed stuttering bisimilarity to paths.

Paths of length 1 are equivalent if the vertices they consist of are equivalent.
If paths p and q are equivalent, then pv ∼ q iﬀ v is equivalent to the last vertex
in q, and pv ∼ qw iﬀ v ∼ w. An inﬁnite path p is equivalent to a path q if for
all ﬁnite preﬁxes of p there is an equivalent preﬁx of q and vice versa.

Lemma 16. Let (V, →, P, Ω) be a parity game, and let (V/∼, →′, P ′, Ω′) be its
quotient. Let v ∈ V , and C ∈ V/∼ such that v ∈ C. For all players i, and all
σ ∈ Si there is some ψ ∈ S∗
σ (v)
such that p ∼ q.

i such that for all q ∈ Πω

ψ(C) there is a p ∈ Πω

Proof. Deﬁne an arbitrary complete ordering <· on vertices, and deﬁne the fol-
lowing for ﬁnite paths q starting in C, where min<· ∅ is deﬁned to be ⊥:

next(q) = min
<·

{v′ ∈ V | ∃p ∈ Πσ(v) : p ∼ q ∧ p σ→ v′ ∧ pv′ 6∼ q}

div(q) = ∃p ∈ Πω

σ (v) : p ∼ q

We next show that it is possible to deﬁne a strategy ψ ∈ S∗

i for ﬁnite plays

q = C . . . C′ such that if q ∼ p for some p ∈ Πσ(v), then:

(ψ(q) = C′

ψ(q) = [next(q)]∼

if div(q) and C′ →′ C′
otherwise.

Let p ∈ Πσ(v) be such that q ∼ p for q = C . . . C′ and assume P ′(C′) = i. In
case div(q) and C′ →′ C′, then obviously ψ(q) can be deﬁned as C′. We proceed
to show that if ¬div(q) or C′
6→′ C′, then 1) next(q) 6= ⊥, and 2) we can set
ψ(q) = [next(q)]∼. We show the ﬁrst by distinguishing two cases:

Case ¬div(q), then it follows straightforwardly that next(q) 6= ⊥.

39

Case C′ 6→′ C′. Because C′ is a vertex is a quotient graph, C′

7→∼. Consider
the path p ∈ Πσ(v) for which p ∼ q, and assume that p is of the form
¯pu. Since ¯pu ∼ q, also u ∼ C′ and hence u i6
7→∼. Then by Lemma 5,
u ¬i7→∼ V \ [u]∼. Let σ′ ∈ S¬i be such that u σ′ 7→∼ V \ [u]∼ and consider
the unique path rv′ ∈ Πσ′ (u) such that σ (cid:13) rv′, σ′ (cid:13) rv′, r ∼ u and
v′ ∈ V \ [u]∼. Then pr ∈ Πσ(v) is such that pr ∼ q, pr σ→ v′ and prv′ 6∼ q.
Hence, next(q) 6= ⊥.

i 6

Next, we show that we can set ψ(q) = [next(q)]∼. Since next(q) 6= ⊥, there must
be some v . . . v′v′′ ∈ Πσ(v) such that v′′ = next(q), v . . . v′ ∼ q and v′ 6∼ v′′. Since
v′ ∼ C′ and v′ → [v′′]∼, also C′
P(v′)7→∼[v′′]∼. As C′ is a vertex in a quotient
graph, this implies C′

P(v′)→[v′′]∼. Hence, we can set ψ(q) = [next(q)]∼.

Now we have shown that it is always possible to deﬁne a strategy adhering
to the restrictions above, let ψ be such a strategy. We show using induction on
n that for all n

∀q ∈ Πn

ψ(C) : ∃p ∈ Πσ(v) : p ∼ q.

For n = 0, this is trivial, because v ∼ C. For n = m + 1, assume as the induction
ψ (C) : ∃¯p ∈ Πσ(v) : ¯p ∼ ¯q. Let q ∈ Πn
hypothesis that ∀¯q ∈ Πm
ψ(C) and let
C′, C′′ ∈ V/∼ and ¯q ∈ Πm
ψ (C) such that ¯q = C . . . C′ and q = ¯qC′′. Distinguish
cases on the player who owns C′.

Case P ′(C′) = i. Then C′′ = ψ(¯q). The induction hypothesis yields some ¯p ∈
Πσ(v) such that ¯p ∼ ¯q, therefore C′′ = C′ if div(¯q) and C′ →′ C′, and
otherwise C′′ = [next(¯q)]∼.
If C′ = C′′, then div(¯q), so there must be some p ∈ Πω
and therefore also some p ∈ Πσ(v) such that p ∼ q.
If C′′ = [next(¯q)]∼, there must be some p ∈ Πσ(v) such that p = p′v′ and
p′ ∼ ¯q and v′ ∼ C′′. By deﬁnition, p ∼ q for such p.

σ (v) such that p ∼ q

Case P ′(C′) 6= i. From the induction hypothesis, obtain a ¯p ∈ Πσ(v) such that
¯p ∼ ¯q. Without loss of generality we may assume that ¯p is ﬁnite. Note
that C′ → [C′′]∼. We distinguish two cases.

¬i7→∼[C′′]∼. So let σ′ ∈ S¬i be such that v′

• Case C′ = C′′. Then we have ¯p ∼ ¯qC′′.
• Case C′ 6= C′′. Let v′ be the last vertex in ¯p. Because ¯p ∼ ¯q, also
σ′ 7→∼[C′′]∼. Now
v′
consider an inﬁnite path ¯pp such that σ (cid:13) ¯pp and σ′ (cid:13) ¯pp. For some
index k ≥ 0, it must be the case that pk ∼ C′′ and pl ∼ C′ for all
l < k. So ¯pp0 . . . pk ∼ q.

Finally, we prove that for all q ∈ Πω
σ (v) such that p ∼ q.
Let q ∈ Πω
ψ(C). Then by the above, we ﬁnd that there is some p ∈ Πσ(v).
Suppose p is ﬁnite and p = ¯pv′ for some vertex v′. Since q is a path through the
quotient graph, q must be of the form ¯qCω for some C ∼ v′.

ψ(C) there is a p ∈ Πω

• Case P ′(C) = i. Then ψ(¯qC) = C, and thus div(¯qC) by deﬁnition of ψ. But

then there must be some p′ ∈ Πω

σ (v) such that p′ ∼ ¯qC ∼ q.

• Case P ′(C) 6= i. Since C →′ C we have C ¬i 7→∼ and since v′ ∼ C, also
¬i7→∼. Then there is an inﬁnite
σ′ (v′) such that σ (cid:13) p′ and p′ ∼ v′. But then σ ¯pp′ and

¬i7→∼. Let σ′ ∈ S¬i be such that v′

v′
path p′ ∈ Πω
q ∼ ¯pp′.

40

Theorem 28. Governed stuttering bisimularity strictly reﬁnes winner equival-
ence.

Proof. Let G = (V, →, P, Ω) be a parity game, and let v, w ∈ V such that v ∼ w.
Let (V/∼, →′, P ′, Ω′) be the governed stuttering bisimulation quotient of G, and
let C ∈ V/∼ be such that w ∼ C . By transitivity of ∼, also v ∼ C . Now suppose
that player i has a winning strategy σ from v. Then by Lemma 16, i has a
strategy ψ from C such that for every play q ∈ Πψ(C) there is a play p ∈ Πσ(v)
such that p ∼ q. Because the priorities occurring inﬁnitely often on such p and
q are the same, ψ is also winning for i. If ¬i had a winning strategy σ′ from w,
then we could repeat this argument to construct a winning strategy for ¬i from
C, but this would be contrary to the fact that parity games are determined.
Therefore, w must also be won by player i.

9 Conclusion

Preorders and equivalences for parity games have been studied on a number of
occasions, see [12, 14, 15, 21, 22, 32, 37]. A major motivation for some of these
is that they provide the prospect of simplifying games prior to solving them.
In this paper, we reconsidered several of the parity game relations previously
deﬁned by us, viz.
(governed) bisimulation and (governed) stuttering bisim-
ulation. More speciﬁcally, we gave detailed proofs showing that our relations
are equivalences, they have unique parity game quotients and they approximate
the winning regions of parity games. Furthermore, we showed that our coin-
ductively deﬁned equivalence relations admit game-based deﬁnitions; the latter
facilitated the comparison of our equivalences to the game-based deﬁnitions of
relations for parity games found in the literature. For the latter relations, we
additionally gave coinductive deﬁnitions. Finally, we showed that, unlike e.g.
delayed simulation or any of its biased versions, our equivalence relations give
rise to unique quotients.

There are several natural continuations of this research. First, the exper-
iments that were conducted in [15, 37] showed that parity games that could
not be solved become solvable by preprocessing the games using an O(mn)
stuttering bisimulation minimisation algorithm or an O(mn2) governed stut-
tering bisimulation minimisation algorithm; the overall gain in speed otherwise
was not signiﬁcant.
It would be worthwhile to establish whether this is still
true when using the O(m log n) stuttering equivalence minimisation algorithm
of [29]. Moreover, it would be interesting to see whether the O(mn2) time com-
plexity of governed stuttering bisimulation can be reduced using ideas from [29].
Similarly, we believe that our coinductive rephrasing of delayed simulation will
help to devise a more eﬃcient algorithm for computing it, using a partition
reﬁnement approach.

Finally, an interesting line of investigation is to see whether the incomparable
notions of governed stuttering bisimulation and delayed simulation equivalence
can be married. Given that we have established game-based and coinductive
deﬁnitions for both relations, deﬁning such a relation now seems within reach.
The resulting relation would be closer to winning equivalence and perhaps even
shed light on ways to eﬃciently solve parity games in general.

41

References

[1] R. Alur, T. A. Henzinger, O. Kupferman, and M. Y. Vardi. Alternating
reﬁnement relations. In Proc. CONCUR’98, volume 1466 of LNCS, pages
163–178. Springer, 1998.

[2] R. Alur, T.A. Henzinger, and O. Kupferman. Alternating-time temporal

logic. J. ACM, 49(5):672–713, September 2002.

[3] A. Arnold, A. Vincent, and I. Walukiewicz. Games for synthesis of control-

lers with partial observation. Theor. Comput. Sci., 303(1):7–34, 2003.

[4] A. Arnold and I. Walukiewicz. Nondeterministic controllers of non-
deterministic processes. In Logic and Automata, volume 2 of Texts in Logic
and Games, pages 29–52. Amsterdam University Press, 2008.

[5] T. Basten. Branching bisimilarity is an equivalence indeed! Inf. Proc. Let.,

58(3):141–147, 1996.

[6] J. van Benthem. Correspondence theory. In D. Gabbay and F. Guenthner,
editors, Handbook of Philosophical Logic, volume II, pages 167–248. 1984.

[7] H. Björklund, S. Sandberg, and S.G. Vorobyov. A discrete subexponential
In Proc. STACS’03, volume 2607 of LNCS,

algorithm for parity games.
pages 663–674. Springer, 2003.

[8] H. Björklund and S.G. Vorobyov. Combinatorial structure and random-
ized subexponential algorithms for inﬁnite games. Theor. Comput. Sci.,
349(3):347–360, 2005.

[9] P.E. Bulychev, I.V. Konnov, and V.A. Zakharov. Computing (bi)simulation
relations preserving CTL*-X for ordinary and fair kripke structures. Insti-
tute for System Programming, Russian Academy of Sciences, Mathematical
Methods and Algorithms, 12, 2007.

[10] D. Bustan and O. Grumberg. Simulation-based minimization. ACM Trans.

Comput. Log., 4(2):181–206, apr 2003.

[11] L. Clemente. Büchi automata can have smaller quotients.

In IC-
ALP’11, volume 6756 of Lecture Notes in Computer Science, pages 258–270.
Springer, 2011.

[12] S. Cranen. Getting the point: obtaining and understanding ﬁxpoints in
model checking. PhD thesis, Eindhoven University of Technology, Eind-
hoven, 2015.

[13] S. Cranen, M. Gazda, J.W. Wesselink, and T.A.C. Willemse. Abstraction

in Fixpoint Logic. ACM Trans. Comput. Logic, 16(4):29:1–29:39, 2015.

[14] S. Cranen, J.J.A. Keiren, and T.A.C. Willemse. Stuttering mostly speeds
up solving parity games. In Proc. NFM’11, volume 6617 of LNCS, pages
207–221. Springer, 2011.

[15] S. Cranen, J.J.A. Keiren, and T.A.C. Willemse. A cure for stuttering parity
games. In Proc. ICTAC’12, volume 7521 of LNCS, pages 198–212. Springer,
2012.

42

[16] E.A. Emerson and C.S. Jutla. Tree automata, mu-calculus and determin-

acy. In Proc. FOCS’91, pages 368–377. IEEE Computer Society, 1991.

[17] E.A. Emerson, C.S. Jutla, and A.P. Sistla. On model checking for the µ-
calculus and its fragments. Theor. Comput. Sci., 258(1-2):491–522, May
2001.

[18] K. Etessami, Th. Wilke, and R.A. Schuller. Fair simulation relations, parity
games, and state space reduction for büchi automata. SIAM J. Comput.,
34(5):1159–1175, 2005.

[19] O. Friedmann and M. Lange. Solving parity games in practice. In Proc.

ATVA’09, volume 5799 of LNCS, pages 182–196. Springer, 2009.

[20] O. Friedmann and M. Lange. Deciding the unguarded modal µ-calculus.

Journal of Applied Non-Classical Logics, 23(4):353–371, 2013.

[21] C. Fritz. Simulation-Based Simpliﬁcation of omega-Automata. PhD thesis,

Christian-Albrechts-Universität zu Kiel, 2005.

[22] C. Fritz and T. Wilke. Simulation relations for alternating parity automata
and parity games. In Proc. DLT’06, volume 4036 of LNCS, pages 59–70.
Springer, 2006.

[23] C. Fritz and Th. Wilke. State space reductions for alternating büchi
In Proc. FSTTCS’02, volume 2556 of LNCS, pages 157–168.

automata.
Springer, 2002.

[24] M.W. Gazda and T.A.C. Willemse. Consistent consequence for boolean
equation systems. In Proc. SOFSEM’12, volume 7147 of LNCS, pages 277–
288. Springer, 2012.

[25] M.W. Gazda and T.A.C. Willemse. On parity game preorders and the logic
of matching plays. In Proc. SOFSEM’16, volume 9587 of LNCS, pages 277–
289. Springer, 2016.

[26] R.J. van Glabbeek. The linear time - branching time spectrum. In Proc.

CONCUR ’90, volume 458 of LNCS, pages 278–297. Springer, 1990.

[27] R.J. van Glabbeek. The linear time - branching time spectrum II. In Proc.

CONCUR’93, volume 715 of LNCS, pages 66–81. Springer, 1993.

[28] J.F. Groote and F.W. Vaandrager. An eﬃcient algorithm for branching
bisimulation and stuttering equivalence. In Proc. ICALP’90, volume 443
of LNCS, pages 626–638. Springer, 1990.

[29] J.F. Groote and A. Wijs. An O(m log n) algorithm for stuttering equival-
ence and branching bisimulation. Technical report, January 2016. arXiv:
1601.01478.

[30] M. Huth, J.H.-P. Kuo, and N. Piterman. Fatal attractors in parity games.
In Proc. FOSSACS’13, volume 7794 of LNCS, pages 34–49. Springer, 2013.

[31] M. Huth, J.H.-P. Kuo, and N. Piterman. Static analysis of parity games:
Alternating reachability under parity. In Semantics, Logics, and Calculi,
volume 9560 of LNCS, pages 159–177. Springer, 2016.

43

[32] D. Janin. A contribution to formal methods: games, logic and automata,

December 2005. Habilitation thesis.

[33] M. Jurdziński. Deciding the winner in parity games is in UP ∩ co-UP. Inf.

Proc. Let., 68(3):119–124, 1998.

[34] M. Jurdziński. Small progress measures for solving parity games. In Proc.

STACS’00, volume 1770 of LNCS, pages 290–301. Springer, 2000.

[35] M. Jurdziński, M. Paterson, and U. Zwick. A Deterministic Subexponential
Algorithm for Solving Parity Games. In Proc. SODA’06, pages 117–123.
ACM/SIAM, 2006.

[36] J.P. Katoen, T. Kemna, I.S. Zapreev, and D.N. Jansen. Bisimulation
In Proc.

minimisation mostly speeds up probabilistic model checking.
TACAS’07, volume 4424 of LNCS, pages 76–92. Springer, 2007.

[37] J.J.A. Keiren. Advanced Reduction Techniques for Model Checking. PhD

thesis, Eindhoven University of Technology, 2013.

[38] J.J.A. Keiren, J.W. Wesselink, and T.A.C. Willemse. Liveness analysis for
parameterised Boolean equation systems. In Proc. ATVA’14, volume 8837
of LNCS, pages 219–234. Springer, 2014.

[39] J.J.A. Keiren and T.A.C. Willemse. Bisimulation Minimisations for
In Proc . HVC’09, volume 6405 of LNCS.

Boolean Equation Systems.
Springer, 2011.

[40] R. Mayr and L. Clemente. Advanced automata minimization. In POPL’13,

pages 63–74. ACM, 2013.

[41] R. McNaughton. Inﬁnite games played on ﬁnite graphs. Annals of Pure

and Applied Logic, 65(2):149–184, 1993.

[42] K.S. Namjoshi. A simple characterization of stuttering bisimulation. In
Proc. FSTTCS’97, volume 1346 of LNCS, pages 284–296. Springer, 1997.

[43] S. Orzan, J.W. Wesselink, and T.A.C. Willemse. Static analysis techniques
for parameterised Boolean equation systems. In Proc. TACAS’09, volume
5505 of LNCS, pages 230–245. Springer, 2009.

[44] S. Orzan and T.A.C. Willemse. Invariants for Parameterised Boolean Equa-

tion Systems. Theor. Comput. Sci., 411(11-13):1338–1371, 2010.

[45] V. Petersson and S.G. Vorobyov. A Randomized Subexponential Algorithm

for Parity Games. Nordic Journal of Computing, 8(3):324–345, 2001.

[46] S. Schewe. Solving parity games in big steps. In Proc. FSTTCS’07, volume

4855 of LNCS, pages 449–460. Springer, 2007.

[47] P. Stevens and C. Stirling. Practical model checking using games. In Proc.

TACAS’98, volume 1384 of LNCS, pages 85–101. Springer, 1998.

[48] C. Stirling. Bisimulation, modal logic and model checking games. Logic

Journal of IGPL, 7(1):103–124, 1999.

44

[49] J. Vöge and M. Jurdziński. A discrete strategy improvement algorithm
for solving parity games. In Proc. CAV’00, volume 1855 of LNCS, pages
202–215. Springer, 2000.

[50] T.A.C. Willemse. Consistent correlations for parameterised Boolean equa-
tion systems with applications in correctness proofs for manipulations. In
Proc. CONCUR’10, volume 6269 of LNCS, pages 584–598. Springer, 2010.

[51] Q. Yin, Y. Fu, C. He, M. Huang, and X. Tao. Branching bisimilarity
checking for PRS. In Proc. ICALP’14, volume 8573 of LNCS, pages 363–
374. Springer, 2014.

[52] W. Zielonka. Inﬁnite games on ﬁnitely coloured graphs with applications to
automata on inﬁnite trees. Theor. Comput. Sci., 200(1-2):135 – 183, 1998.

A Detailed proofs of Propositions 3 and 4

Before we address Propositions 3 and 4, we ﬁrst repeat the deﬁnition of the
variant function we will use in the proof of Proposition 3 and we state three
lemmata that characterise properties of this variant function.

Deﬁnition 21 (Governed stuttering bisimulation game measure). We deﬁne
a measure with respect to ∼ for a conﬁguration ((u0, u1), c) in the governed
stuttering bisimulation game as follows:

m(u0, u1, c) ∆=

(0, 0)
(∞, 0)
(expel(uj, u1−j), 0)
(0, exit(uj, u1−j, t))

if c = X
if c = † ∧ ∃v0 ∈ u•
if c = † ∧ ∀v ∈ u•
if c = (j, t)

1 : v0 ∼ u0 ∧ v1 ∼ u1

0, v1 ∈ u•
j : uj 6∼ v




where expel(u0, u1) denotes the number of steps before P(u0)’s opponent is
forced from [u0]∼ and exit(u0, u1, u2) denotes the number of steps it takes for
P(u0) to force play to [u2]∼ from u1. Formally, we have:

expel(u0, u1) ∆= dist ¬P(u0),[u0]∼(u1, V \ [u0]∼)
exit(u0, u1, u2) ∆= dist P(u0),[u0]∼(u1, [u2]∼)

where for U, T ⊆ V and v ∈ U :

dist i,U (v, T )

∆

=(min{n | v ∈ UAttr n

∞

i (T )} if v i 7→U T
otherwise

Measures are ordered lexicographically, i.e. (m0, m1) < (n0, n1) iﬀ m0 < n0 ∨
(m0 = n0 ∧ m1 < n1).

We ﬁrst prove some basic properties for the function m.

Lemma 17. For u, v ∈ V , (u ∼ v ∧ m(u, v, †) = (m0, m1)) =⇒ m0 > 0.

45

Proof. First, observe that (apart from c = †), the conditions in the second and
third clause of the deﬁnition of m are complementary. Furthermore observe that,
for all u0, u1 such that u0 ∼ u1, we have expel(u0, u1) > 0 since u1 6∈ V \ [u0]∼.
The result then immediately follows.

Lemma 18. Let U, T ⊆ V , such that U ∩ T = ∅ and let u ∈ U . For all players
i, if u i7→U T then dist i,U (u, T ) > min{dist i,U (v, T ) | u → v ∧ v ∈ U ∪ T }.
Proof. Assume u i7→U T and let n = dist i,U (u, T ). Hence u ∈ UAttr n
u 6∈ UAttr n−1
by a case distinction on P(u).

i (T ) and
(T ). Observe that n > 0 since u ∈ U and U ∩ T = ∅. We proceed

i

• P(u) = i. Since n is such that u /∈ UAttr n−1

(T ), we have ∃v ∈ u• : v ∈
(T ). Let v be such, and observe that dist i,U (v, T ) ≤ n − 1 < n.

UAttr n−1
The result then follows immediately.

i

i

• P(u) 6= i. As n is such that u /∈ UAttr n−1

(T ), we have ∀v ∈ u• : v ∈
(T ). Hence ∀v ∈ V : u → v =⇒ dist i,U (v, T ) ≤ n − 1 < n.

UAttr n−1
Again the result follows immediately.

i

i

We also prove the following stronger result in case u is owned by the oppon-

ent.

Lemma 19. Let U, T ⊆ V , such that U ∩T = ∅ and u ∈ U ∩V¬i . Then u i7→U T
implies dist i,U (u, T ) > max{dist i,U (v, T ) | u → v ∧ v ∈ U ∪ T }.

Proof. Let u ∈ U ∩ V¬i such that u i7→U T . Suppose n = dist i,U (u, T ). Then
u ∈ UAttr n
(T ),
hence ∀v ∈ u• : dist i,U (v, T ) ≤ n − 1 < n; furthermore, such v are in U ∪ T , and
the result follows immediately.

(T ). Since u /∈ Vi , ∀v ∈ u• : v ∈ UAttr n−1

i (T ) and u 6∈ UAttr n−1

i

i

Proposition 5. For all v, w ∈ V if v ∼ w then v ≡g,st w.

Proof. We prove for all governed stuttering bisimilar vertices v ∼ w that there
is a Duplicator winning strategy in the governed stuttering bisimulation game
from conﬁguration ((v, w), X).

We show this by constructing a Duplicator -strategy that moves between
governed stuttering bisimilar vertices, and that makes sure that from every
conﬁguration ((v, w), c), within a ﬁnite number of steps another conﬁguration
((v′, w′), X) is reached. As a consequence, the Duplicator -strategy is such that
it passes through conﬁgurations with reward X inﬁnitely often, hence the Du-
plicator strategy is winning.

Formally, we preserve the invariant Φ which is the conjunction of the follow-

ing for conﬁgurations ((u0, u1), c):

• u0 ∼ u1,

• c = (j, t) implies uj 6∼ t,

• c = (0, u) implies (u0, u1) ∈ V (cid:3) × V ,

• c = (1, u) implies (u0, u1) ∈ V × V(cid:3).

46

0, u′

In addition, we prove that from every conﬁguration ((u0, u1), c), a conﬁg-
uration ((u′
1), X) is reached within a ﬁnite number of steps by showing
that m is a variant function. That is, if, in a round, we move from conﬁg-
uration ((u0, u1), c) to conﬁguration ((u′
1), c′) with c 6= X and c′ 6= X, then
m(u0, u1, c) > m(u′

0, u′

0, u′

1, c′).

From these two observations, the result immediately follows. Note that ini-
tially we are in a conﬁguration ((v, w), X); hence Φ is satisﬁed trivially. Suppose
the game has reached a conﬁguration ((u0, u1), c) satisfying Φ. In step 1 of the
round, Spoiler chooses to play from (t0, t1), taken from (u0, u1) or (u1, u0). We
remark that if Spoiler decides to play from (u1, u0), then, regardless of step 2,
any pending challenge or † will be replaced by a X at the end of step 3. For
this case, we therefore do not need to argue that m decreases.

We distinguish cases based on which player can force a divergence in the coin-
ductive deﬁnition and consider Duplicator ’s options in step 2 and 3 of the round,
1), c′)
and prove that Duplicator can always arrive in a new conﬁguration ((t′
that satisﬁes Φ and for which, if c′ 6= X and c 6= X, m(t0, t1, c) > m(t′
1, c′).

0, t′
0, t′

• t0 (cid:3)

7→∼ and t0 (cid:3)7→∼. This case is trivial, as in that case exactly one

(reachable) equivalence class exists.

• t0 (cid:3)

7→∼ and t0 (cid:3)6

7→∼. Since t0 ∼ t1 also t1 (cid:3)

7→∼. We distinguish cases

based on the owners of the vertices.

– P(t0) = P(t1) = (cid:3) . Spoiler plays t0 → w0.

∗ Case there is some w1 ∈ t•

1 such that w0 ∼ w1. Then Duplicator

plays to such a w1. The new conﬁguration is ((w0, w1), X).

∗ Case there is no w1 ∈ t•

1 such that w0 ∼ w1. Then Duplicator

1 for which w1 ∼ t1 with minimal m(t0, w1, (0, w0));

plays to a w1 ∈ t•
the existence of a w1 ∼ t1 follows from t1 (cid:3)
New conﬁguration:
new conﬁguration is ((t0, w1), (0, w0)), and else ((t0, w1), X).
Progress: we demonstrate m(t0, w1, (0, w0)) < m(t0, t1, c) for c ∈
{†, (0, w0)}. In case c = † this follows from Lemma 17. In case
c = (0, w0), this follows from Lemmata 18 and 19.

if c ∈ {X, †, (0, w0)} and u0 = t0 then the

7→∼.

– P(t0) = P(t1) = (cid:3). Spoiler plays t1 → w1. Since t1 (cid:3)

satisfy t1 ∼ w1. The same holds for all w0 ∈ t•
play arbitrary t0 → w0.
New conﬁguration: ((w0, w1), X)

7→∼, all w1 ∈ t•
1
0. Duplicator can thus

– P(t0) = (cid:3) , P(t1) = (cid:3). Spoiler plays t0 → w0 and t1 → w1. Since

t1 (cid:3)

7→∼, also w1 ∼ t1. We distinguish two further cases.

∗ Case w0 ∼ w1.

New conﬁguration: ((w0, w1), X).

∗ Case w0 6∼ t0.

if c ∈ {X, †, (0, w0)} and u0 = t0 then the
New conﬁguration:
new conﬁguration is ((t0, w1), (0, w0)); else the new conﬁguration
is ((t0, w1), X). Observe that t0 ∼ w1.
Progress: we demonstrate m(t0, w1, (0, w0)) < m(t0, t1, c) for c ∈
{†, (0, w0)}. In case c = † this follows from Lemma 17. In case
c = (0, w0), this follows from Lemmata 18 and 19.

47

– P(t0) = (cid:3), P(t1) = (cid:3) . Duplicator plays t1 → w1 such that w1 ∼ t1

and t0 → w0. Such a w1 exists because t1 (cid:3)
New conﬁguration: ((w0, w1), X).

7→∼.

• t0 (cid:3)7→∼ and t0 (cid:3)

previous one.

7→∼. So, as before, t1 (cid:3)7→∼. This case is dual to the

• t0 (cid:3)

7→∼ and t0 (cid:3)6

7→∼. We consider the owners of t0 and t1.

– P(t0) = P(t1) = (cid:3) . Spoiler plays t0 → w0. We distinguish two cases.
1 for which w0 ∼ w1. Duplicator plays

∗ Case there is some w1 ∈ t•
t1 → w1 such that w0 ∼ w1.
New conﬁguration: ((w0, w1), X).

∗ Case there is no w1 ∈ t•

1 for which w0 ∼ w1.

· Case t0 ∼ w0. Then for all w1 ∈ t•

1, w1 6∼ t1.

New conﬁguration: ((w0, t1), †) if c ∈ {X, †} and u0 = t0;
otherwise ((w0, t1), X).
Progress: we must show m(t0, w1, †) < m(t0, t1, †). This
follows from Lemma 19.

· Case t0 6∼ w0. Duplicator plays t1 → w1 such that t1 ∼ w1

if c ∈ {X, †, (0, w0)} and u0 = t0 then

and m(t0, w0, (0, w0)) is minimal.
New conﬁguration:
conﬁguration ((t0, w1), (0, w0)) and else ((t0, w1), X).
Progress: we must show m(t0, w1, (0, w0)) < m(t0, t1, †) for
c ∈ {†, (0, w0)}. In case c = † this follows from Lemma 17.
In case c = (0, w0), this follows from Lemmata 18 and 19.

– P(t0) = P(t1) = (cid:3). Spoiler plays t1 → w1.

∗ Case there is some w0 ∈ t•
t0 → w0 such that w0 ∼ w1.
New conﬁguration: ((w0, w1), X).

0 for which w0 ∼ w1. Duplicator plays

∗ Case there is no w0 ∈ t•

0 for which w0 ∼ w1.

· Case t1 ∼ w1. Then for all w0 ∈ t•

0, w0 6∼ t0. Duplicator

plays some arbitrary t0 → w0.
New conﬁguration: ((t0, w1), †) if c ∈ {X, †} and u1 = t1;
otherwise ((t0, w1), X).
Progress: we must show m(w0, t1, †) < m(t0, t1, †). This
follows from Lemma 19.

· Case t1 6∼ w1. Duplicator plays t0 → w0 such that t0 ∼ w0

if c ∈ {X, †, (1, w1)} and u1 = t1 then

and m(w0, t0, (1, w1)) is minimal.
New conﬁguration:
conﬁguration ((w0, t1), (1, w1)) and else ((w0, t1), X).
Progress: we must show m(w0, t1, (1, w1)) < m(t0, t1, c) for
c ∈ {†, (1, w1)}. In case c = † this follows from Lemma 17.
In case c = (1, w1), this follows from Lemmata 18 and 19.

– P(t0) = (cid:3) , P(t1) = (cid:3). Spoiler plays t0 → w0 and t1 → w1. In case
w0 6∼ w1 then either t0 ∼ w0 or t1 ∼ w1. We distinguish three cases:

∗ Case w0 ∼ w1.

New conﬁguration: ((w0, w1), X).

48

6
6
∗ Case w0 6∼ w1 and t0 ∼ w0.

New conﬁguration: ((w0, t1), (1, w1)) if c ∈ {X, †, (1, w1)} and
u1 = t1; otherwise ((w0, t1), X).
Progress: we must show m(w0, t1, (1, w1)) < m(t0, t1, c) for c ∈
{†, (1, w1)}. In case c = † this follows from Lemma 17. In case
c = (1, w1) this follows from Lemmata 18 and 19.

∗ Case w0 6∼ w1 and t1 ∼ w1.

New conﬁguration: ((t0, w1), (0, w0)) if c ∈ {X, †, (0, w0)} and
u0 = t0; otherwise ((t0, w1), X).
Progress: we must show m(t0, w1, (0, w0)) < m(t0, t1, c) for c ∈
{†, (0, w0)}. In case c = † this follows from Lemma 17. In case
c = (0, w0) this follows from Lemmata 18 and 19.

– P(t0) = (cid:3), P(t1) = (cid:3) .

∗ Case there are w0 ∈ t•

0 and w1 ∈ t•
Duplicator plays to such w0 and w1.
New conﬁguration: ((w0, w1), X).

1 such that w0 ∼ w1. Then

∗ Case there are no w0 ∈ t•

0 and w1 ∈ t•

1 such that w0 ∼ w1.

· case there is some w0 ∈ t•

0 such that w0 ∼ t0. Then Duplic-
ator plays to w0 that is such while minimising m(w0, t1, †).
New conﬁguration: ((w0, t1), †) if u1 = t1; else ((w0, t1), X).
Progress: we ﬁrst show that u1 = t1 implies c ∈ {†, X}.
Towards a contradiction, assume c = (0, t) for some t. By
our invariant, this implies (t0, t1) ∈ V (cid:3) × V . Since (u0, u1) ∈
{(t0, t1), (t1, t0)} and u1 = t1 we have u0 = t0. But then
both u0 ∈ V(cid:3) and u0 ∈ V (cid:3) . Contradiction. Towards another
contradiction, assume c = (1, t) for some t. By our invariant,
this implies (t0, t1) ∈ V × V(cid:3). This contradicts u1 = t1 since
P(u1) = (cid:3) .
It therefore suﬃces to show m(w0, t1, †) < m(t0, t1, †). This
follows from the fact that we minimised m(w0, t1, †) and
Lemmata 18 and 19.

· case there is some w1 ∈ t•

1 such that w1 ∼ t1. Then Duplic-
ator plays to w1 that is such while minimising m(t0, w1, †).
New conﬁguration: ((t0, w1), †) if u0 = t0; else ((t0, w1), X).
Progress: using arguments, similar to those in the previous
case, it follows that c ∈ {†, X}.
It therefore suﬃces to show m(t0, w1, †) < m(t0, t1, †). This
follows from the fact that we minimised m(t0, w1, †) and
Lemmata 18 and 19.

We next focus on proving that every pair of vertices related through the
governed stuttering bisimulation game are in fact governed stuttering bisimilar.

Proposition 6. For all v, w ∈ V if v ≡g,st w then v ∼ w.

for all v, w ∈ V ,
Proof. We prove the contrapositive of the statement, i.e.
if v 6∼ w, then also v 6≡g,st w. Let v 6∼ w. By Corollary 2, then also
(v, w) /∈ νF . By the Tarski-Kleene ﬁxpoint approximation theorem, we thus
F k(V × V ). Let Rk denote the relation F k(V × V ); i.e., Rk

have (v, w) /∈ Tk≥1

49

is the relation obtained by applying the operator F k-times. Note that because

of monotonicity, Rk = Tl≤k Rl. We next prove, using induction, that for all

k ≥ 1:

Spoiler wins the governed stuttering bisimulation game
for all conﬁgurations ((u0, u1), c) for which (u0, u1) /∈ Rk

(IH)

• Base case k = 1. Observe that R1 = {(v, w) ∈ V × V | Ω(v) = Ω(w)}.
Spoiler wins the governed stuttering bisimulation game for all conﬁgur-
ations ((u0, u1), c) satisfying (u0, u1) /∈ R1: all plays starting in such a
conﬁguration trivially violate Duplicator ’s winning condition.

• Inductive step. Assume that the statement holds for some k ≥ 1. Pick
an arbitrary position (u0, u1) for which (u0, u1) /∈ Rk+1 and let c be an
arbitrary challenge/reward. We must show that Spoiler wins the governed
stuttering bisimulation game for these. Recall that we have Rk+1 ⊆ Rk.
If (u0, u1) /∈ Rk, then by the induction hypothesis, Spoiler wins the gov-
erned stuttering bisimulation game from conﬁguration ((u0, u1), c).
Observe that by deﬁnition of F , we have for all (v, w) ∈ Rk \ Rk+1 that
there are i ∈ { (cid:3) , (cid:3)} and U, T ⊆ V/Rk for which

[v]Rk ∈ U \ T but not v i 7→U T ⇔ w i7→U T .

(*)

Let i, U, T be such that (*). We focus on the case i = (cid:3) ; the case that
i = (cid:3) is fully dual. Assume that v i7→U T and not w i 7→U T ; the case in
which not v i 7→U T but w i 7→U T is symmetric. Note that we can assume
that T ∩ U = ∅, as v i7→U T iﬀ v i 7→U \T T for any U, T . We may therefore
also simplify U \ T to U.
Let σ ∈ Si be the (memoryless) strategy underlying v i7→U T . Using σ,
we construct a winning strategy for Spoiler for conﬁguration ((v, w), c).
We ﬁrst show that Spoiler can invariantly move between conﬁgurations
((t0, t1), c) that satisfy the following property Φ:

If [t0]Rk = [t1]Rk then

t0 σ7→U T but not t1 i7→U T
c = (0, t) implies t0 ∈ V (cid:3) and t0 σ→ t
c = (1, t) implies t1 ∈ V(cid:3), t ∈ t•

1 and not t i7→U T




Let ((t0, t1), c) be a conﬁguration for which Φ holds. For all such conﬁg-
urations Spoiler ’s move in step 1 of a round is to play from (t0, t1); i.e.
Spoiler does not switch positions. We distinguish three main cases, show-
ing that Duplicator has no other option than to choose a new conﬁguration
that satisﬁes Φ.

1. Case c ∈ {†, X}. We furthermore distinguish cases based on the

players of t0 and t1.

– Case P(t0) = P(t1) = (cid:3) . Since t0 σ7→U T , Spoiler proposes to
move from t0 to σ(t0). Duplicator proposes u1 ∈ t•
1. Observe
that not u1 i 7→U T . Duplicator then can propose to continue in:
((σ(t0), u1), X), ((t0, u1), (0, σ(t0))), or ((σ(t0), t1), †). Clearly,
all new conﬁgurations satisfy Φ.

50

– Case P(t0) = P(t1) = (cid:3). Spoiler proposes to move from t1 to
u1 such that not u1 i7→U T . Such u1 exists. Duplicator proposes
u0 ∈ t•
0. Observe that t0 σ→ u0. Duplicator then proposes to
continue in: ((u0, u1), X), ((t0, u1), †), or ((u0, t1), (1, u1)). All
new conﬁgurations satisfy Φ.

– Case P(t0) = (cid:3) , P(t1) = (cid:3). Since t0 σ7→U T Spoiler proposes to
move from t0 to σ(t0) and from t1 to u1 such that not u1 i7→U T .
Note that such u1 exists. Duplicator then proposes to continue
in: ((σ(t0), u1), X), ((t0, u1), (0, σ(t0))), or ((σ(t0), t1), (1, u1)).
Again, all new conﬁgurations satisfy Φ.

– Case P(t0) = (cid:3), P(t1) = (cid:3) . Duplicator proposes to move from
t1 to u1 and from t0 to u0. Since i = (cid:3) , we have t0 σ→ u0 and
because of Φ, we have not u1 i 7→U T . Duplicator then proposes
to continue in: ((u0, u1), X), ((t0, u1), †), or ((u0, t1), †). All new
conﬁgurations satisfy Φ.

2. Case c = (0, t). Because of Φ, we have t0 σ7→U T and P(t0) = (cid:3) .
Then Spoiler plays from conﬁguration (t0, t1). We furthermore dis-
tinguish cases based on the owner of t1.

– Case P(t1) = (cid:3) . Spoiler proposes to move from t0 to t. Du-
plicator proposes u1 ∈ t•
1. Observe that not u1 i 7→U T . Duplic-
ator then proposes to continue in: ((t, u1), X), ((t0, u1), (0, t)),
or ((t, t1), †)

– Case P(t1) = (cid:3). Spoiler proposes to move from t0 to t and
from t1 to u1 such that not u1 i 7→U T . Such u1 exists. Duplic-
ator then proposes to continue in: ((t, u1), X), ((t0, u1), (0, t)),
or ((t, t1), X)

In both cases, the new rounds satisfy Φ

3. Case c = (1, t). Because of Φ, we have not t1 σ7→U T and P(t1) =
(cid:3). Then Spoiler plays from conﬁguration (t0, t1). We furthermore
distinguish cases based on the owner of t0.

– Case P(t0) = (cid:3) . Spoiler proposes to move from t0 to σ(t0)
and from t1 to t. Duplicator then proposes to continue in:
((σ(t0), t), X), ((t0, t), X), or ((σ(t0), t1), (1, t)).

– Case P(t0) = (cid:3). Spoiler proposes to move from t1 to t. Du-
0. Observe that t0 σ→ u0. Duplic-
((u0, t), X), ((t0, t), †), or

plicator proposes u0 ∈ t•
ator then proposes to continue in:
((u0, t1), (1, t)).

We next observe that for any (t0, t1) for which t0, t1 meet the premiss
of Φ, but not the conclusion, Spoiler can, in a single round, move to a
conﬁguration that either does not meet Φ’s premiss or to one that meets
Φ’s conclusion. More speciﬁcally, suppose that [t0]Rk = [t1]Rk but one of
the following holds:

1. t1 σ7→U T but not t0 i 7→U T ;
2. c = (0, t) implies t0 /∈ V (cid:3) or not t0 σ→ t;
3. c = (1, t) implies t1 /∈ V(cid:3), t /∈ t•

1, or t i 7→U T .

51

Whenever we are in case 1, Spoiler switches positions in step 1 of a round
and follows the strategy outlined above. Whenever we are in case 2 or 3,
Spoiler drops challenge c in step 1 and plays as if c ∈ {†, X}. In all three
cases, Duplicator is rewarded a X as the new challenge at the end of the
round and Φ holds trivially.

Summarising, we ﬁnd that for conﬁgurations ((t0, t1), c) for which both (*)
and Φ hold, Spoiler can move to another conﬁguration that either meets
Φ or is such that Φ’s premiss is violated. For conﬁgurations ((t0, t1), c)
for which (*) but not Φ holds, Spoiler can move in a single round to a
conﬁguration for which she can henceforth maintain Φ as an invariant or
for which Φ’s premiss is violated.

We ﬁnally argue that when Spoiler plays according to the above strategy,
she wins all plays. Observe that we only need to show this for all inﬁnite
plays that pass only through positions (u, t) for which (u, t) ∈ Rk; for those
plays that at some point pass along a position (u, t) /∈ Rk, our induction
hypothesis yields a winning strategy for Spoiler .

Let (v0, w0) (v1, w1) (v2, w2) . . . be an inﬁnite sequence of positions on an
inﬁnite play π that is allowed by Spoiler ’s strategy, such that for all l,
[vl]Rk = [wl]Rk . Towards a contradiction, assume that Duplicator wins π.
Observe that [vl]Rk = [wl]Rk implies that Ω(vl) = Ω(wl) for all (vl, wl) ∈
Rk \ Rk+1; therefore we can only arrive at a contradiction by showing that
Duplicator earns a ﬁnite number of X rewards along π.
By invariant Φ, for all positions (vl, wl), for l ≥ 1, we have vl σ7→U T .
Let δ(vl, wl) denote the length of the longest path from vl to reach T
when playing according to σ. Note that δ is ﬁnite and decreases along
the positions in π, but never reaches 0, as all vertices remain in U. This
means that for some m, we have δ(vm, wm) = δ(vn, wn) for all n ≥ m. Fix
this m. Moreover, there must be some u such that:

u σ7→U T ∧ ∀n ≥ m : ∀(vn, wn) ∈ π : vn = u

But this means that, once Spoiler ’s strategy reaches the position contain-
ing u, all remaining X’s earned by Duplicator must be due to Spoiler
switching positions or discarding a challenge in step 1 of each new round.
As we explained, Spoiler switches positions and/or drops a challenge only
in the ﬁrst round when starting in a conﬁguration that does not satisfy Φ;
she never does so afterwards. Therefore, Duplicator earns no X rewards
when π reaches a conﬁguration containing a position with u. But then
Duplicator earns only a ﬁnite number of X rewards along π, contradicting
the assumption that Duplicator wins π.

Therefore, Spoiler has a strategy to win any conﬁguration ((u0, u1), c) for
which (u0, u1) /∈ Rk.

52

