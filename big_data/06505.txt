6
1
0
2

 
r
a

 

M
2
2

 
 
]
h
p
-
t
n
a
u
q
[
 
 

2
v
5
0
5
6
0

.

3
0
6
1
:
v
i
X
r
a

Characterizations of symmetrically partial

Boolean functions with exact quantum

query complexity

Daowen Qiu∗, Shenggen Zheng†

Department of Computer Science, Sun Yat-sen University, Guangzhou 510006, China

Abstract

n(x) = 1 for |x| = n/2, DJ k

An exact quantum algorithm requires its output to be correct cer-
tainly, and this kind of algorithms has been studied mostly in the
query model since the discoveries of Deutsch-Jozsa algorithm and the
solution of Simon’s problem. In this article, we prove the optimal ex-
act quantum query complexity for a generalized Deutsch-Jozsa prob-
lem and characterize the symmetrically partial Boolean functions in
terms of exact quantum query complexity. More speciﬁcally, (1) we
give an optimal exact quantum query algorithm with complexity k + 1
for computing the symmetrically partial Boolean function DJ k
n de-
ﬁned as: DJ k
n(x) = 0 for |x| in the set
{0, 1, . . . , k, n − k, n − k + 1, . . . , n}, and it is undeﬁned for the rest
cases, where n is even, |x| is the Hamming weight of x. The case of
k = 0 is the well-known Deutsch-Jozsa problem. (2) We prove that any
symmetrically partial Boolean function f has exact quantum 1-query
complexity if and only if f can be computed by the Deutsch-Jozsa
algorithm. (3) We also discover the optimal exact quantum 2-query
complexity for solving a variant of the Deutsch-Jozsa problem, i.e.
distinguishing between inputs of Hamming weight {⌊n/2⌋,⌈n/2⌉} and
Hamming weight in the set {0, n} for all odd n. We further discuss the
optimal exact quantum algorithms for distinguishing between inputs of
two diﬀerent Hamming weights k and l. (4) We provide an algorithm
to determine the degree of any symmetrically partial Boolean function.

Key words: exact quantum query algorithms, Deutsch-Jozsa prob-

lems, query complexity, Boolean functions, promise problems

AMS subject classiﬁcation. 68Q12, 05E05, 06E30, 81P68

∗Corresponding author. E-mail address: issqdw@mail.sysu.edu.cn (D. Qiu).
†Also as the ﬁrst author and corresponding author.
E-mail address:

zheng-

shg@mail2.sysu.edu.cn (S. Zheng).

1

1

Introduction

Quantum computing models can be divided into bounded-error and exact
versions in terms of their outputs. A bounded-error model means that the
mistake probability for any output cannot be beyond an error value given
a priori, and an exact model requires its outputs be fully correct always,
without any error allowed. Exact quantum computing models have been
studied in the frameworks of quantum ﬁnite automata [7, 34] and particularly
quantum query models (for example, [24, 15, 36, 16, 38, 6, 3]).

The quantum query models are the quantum analog to the classical
Boolean decision tree models, so they are also called quantum decision tree
models and are at least as powerful as the classical decision tree models [16].
The implementation procedure of a quantum decision tree model is exactly
a quantum query algorithm, and it can be roughly described as:
it starts
with a ﬁxed starting state |ψsi of a Hilbert H and will perform the sequence
of operations U0, Ox, U1, . . . , Ox, Ut, where Ui’s are unitary operators that
do not depend on the input x but the query Ox does. This leads to the ﬁnal
state |ψfi = UtOxUt−1 ··· U1OxU0|ψsi. The result is obtained by measuring
the ﬁnal state |ψfi.
A quantum query algorithm A exactly computes a Boolean function f
if its output equals f (x) with probability 1, for all input x. A computes
with bounded-error f if its output equals f (x) with probability at least 2
3 ,
for all input x. The exact quantum query complexity denoted by QE(f )
is the minimum number of queries used by any quantum algorithm which
computes f (x) exactly for all input x.

For the bounded-error case, quantum query algorithms have been inves-
tigated extensively and deeply (for example, [44, 33, 45, 14, 2, 23, 26, 28, 43,
8, 18] and the references therein), and some of them have either polynomial
speed-up over classical algorithms for computing total Boolean functions.
The exact quantum query algorithms for computing total Boolean functions
also have been studied [19, 29, 35, 25, 37, 38, 6, 3, 46], but the best known
quantum speed-up was QE(f ) = O(D(f )0.8675...) by Ambainis [3], and the
other quantum speed-up was just a factor of 2, i.e., QE(f ) = D(f )
, where
2
D(f ) denotes the minimum number of queries used by any classical deter-
ministic query algorithm.

However, for computing partial Boolean functions, there can be an expo-
nential separation between exact quantum and classical deterministic query
complexity, and the ﬁrst result was the well-known Deutsch-Jozsa algorithm
[24]. Deutsch-Jozsa problem [24] can be described as a partial Boolean func-
n(x) = 1 for |x| = n
tion DJ 0

n : {0, 1}n → {0, 1} deﬁned as: n is even, and DJ 0

2

2

n : {0, 1}n → {0, 1} deﬁned as DJ 0

and DJ 0
n(x) = 0 for |x| = 0 or n, and the other cases are undeﬁned, where
|x| is the Hamming weight of x. Deutsch-Jozsa problem has attracted a
lot of research and discussion (for example, [20, 38, 9]), and the physical
realization was implemented in [42]. Montanaro, Jozsa, and Mitchison [38]
generalized the Deutsch-Jozsa problem to another partial Boolean function,
say DJ 1
n(x) = 0 for
|x| = 0, 1, n − 1, n. Also, Montanaro et al [38] designed an exact quantum
2-query algorithm to compute it by using an analytical method.
Ambainis [1] showed that almost all total Boolean functions have high
approximate degree, so, we are also interested in partial Boolean functions
with lower degree. Indeed, partial Boolean functions have also been called
as promise problems [27, 30], and both symmetric Boolean function and
partial Boolean functions have had important applications in cryptography
(for example, [22, 27, 30]).

n except for DJ 1

1.1 Deﬁnitions
Let f be a Boolean function from D ⊆ {0, 1}n to {0, 1}. If D = {0, 1}n,
then f is called a total Boolean function. Otherwise, f is called a partial
Boolean function or a promise problem [27, 30] and D is referred to as the
domain of deﬁnition or promised set.

A (partial) Boolean function f is called symmetric if f (x) only depends
on the Hamming weight of x, i.e., |x|. Some characteristics of the symmetric
Boolean functions were given in, for example, [22]. Some common symmetric
functions over {0, 1}n are listed as follows.

• ORn(x) = 1 if and only if |x| ≥ 1;
• AN Dn(x) = 1 if and only if |x| = 1;
• P ARIT Yn(x) = 1 if and only if |x| is odd;
• M AJn(x) = 1 if and only if |x| > n/2;
• EXACT k
• T HRESHOLDk

n (x) = 1 if and only if |x| = k, where 0 ≤ k ≤ n;

n(x) = 1 if and only if |x| ≥ k, where 0 ≤ k ≤ n.

Remark 1. In [17], partially symmetric Boolean functions were studied and
the deﬁnition is: For a subset J ⊆ [n] := {1, . . . , n}, a function f : {0, 1}n →
{0, 1} is J-symmetric if permuting the labels of the variables of J does not
change the function. So, a partially symmetric Boolean function is a total
function but its symmetric property is partial. If J = [n], then it is exactly
an symmetric Boolean function.

3

n and DJ1

So, diﬀerent from partially symmetric Boolean functions [17], the func-
n above are called symmetrically partial Boolean functions,

tions DJ0
and the exact deﬁnition can be described as follows.
Deﬁnition 1. Let f : {0, 1}n → {0, 1} be a partial Boolean function, and
let D ⊆ {0, 1}n be its domain of deﬁnition. If for any x ∈ D and for any
y ∈ {0, 1}n with |x| = |y|, it holds that y ∈ D and f (x) = f (y), then f is
called an symmetrically partial Boolean function. When D = {0, 1}n, f is
an symmetric function.

Sometimes we call “Boolean functions” as “functions” if no confusion
results. Clearly, if f : {0, 1}n → {0, 1} is an symmetrically partial function,
then its domain of deﬁnition has the version {x : |x| = k1, k2, . . . , kl} for
some 0 ≤ ki ≤ n with i = 1, 2, . . . , l.
Isomorphism is useful in the study of query complexity, and two partial
functions f and g over {0, 1}n are isomorphic if they are equal up to nega-
tions and permutations of the input variables, and negation of the output
variable.
Fact 1. For any two partial functions f, g over {0, 1}n, if they are isomor-
phic, then they have the same (exact) quantum query complexity.

A′(x) = (¬)AU1U0(x),

Proof. Let g(x) = (¬)f (π((¬)x1, (¬)x2, . . . , (¬)xn)) where π is a permuta-
tion. Suppose that there is a t-queries quantum algorithm A that computes
f (x), and let A(x) represent the output (0 or 1) for input x. Now for any x
in the domain of deﬁnition of g, we consider the following t-queries quantum
algorithm A′:

(1)
where U0(x) = ((¬)x1, (¬)x2, . . . , (¬)xn) and U1(x) = π(x). It is clear that
A′ computes exactly function g.
Remark 2. Given an symmetrically partial function f : {0, 1}n → {0, 1},
with the domain D of deﬁnition, it can be equivalently described by a vector
(b0, b1, . . . , bn) ∈ {0, 1,∗}n+1, where f (x) = b|x|, i.e.
bk is the value of
f (x) when |x| = k, and f (x) is ‘undeﬁned’ for b|x| = ∗.
In the interest
of simplicity, sometimes we will use the vector to denote an symmetrically
partial function in this article.

Concerning the n-bit symmetrically partial functions, it is clear that the

following functions are isomorphic to each other:

• (b0, b1, . . . , bn);

4

• (bn, bn−1, . . . , b0);
• (¯b0, ¯b1, . . . , ¯bn);
• (¯bn, ¯bn−1, . . . , ¯b0).
We need to introduce some complexity measures for symmetrically par-

tial functions.

Deﬁnition 2. Let f be a partial function with a domain of deﬁnition
D ⊆ {0, 1}n. For 0 ≤ ε < 1/2, we say a real multilinear polynomial p
approximates f with error ε if:

mum degree among all real multilinear polynomials that approximate f with
error ε.

(1) |p(x) − f (x)| ≤ ε for all x ∈ D;
(2) 0 ≤ p(x) ≤ 1 for all x ∈ {0, 1}n.
The approximate degree of f with error ε, denoted bygdegε(f ), is the mini-
Clearly, if ε = 0, then gdeg0(f ) is the exact degree of f . Furthermore,
if D = {0, 1}n, i.e. f is a total function, then the exact degree of f is
exactly the degree of f as usual [16], denoted by deg(f ). In the interest of
simplicity, sometimes we just identity gdeg0(f ) with deg(f ) for any partial

Boolean function f , since no confusion leads.

1.2 Preliminaries
Let input x = x1 ··· xn ∈ {0, 1}n for some ﬁxed n. We will consider a Hilbert
space H with basis states |i, ji for i ∈ {0, 1, . . . , n} and j ∈ {1,··· , m}
(where m can be chosen arbitrarily). A query Ox to an input x ∈ {0, 1}n
will be formulated as the following unitary transformation:

• Ox|0, ji = |0, ji;
• Ox|i, ji = (−1)xi|i, ji for i ∈ {1, 2,··· , n}.
A quantum query algorithm A which uses t queries for an input x consists
of a sequence of unitary operators U0, Ox, U1, . . . , Ox, Ut, where Ui’s do not
depend on the input x and the query Ox does. The algorithm will start
in a ﬁxed starting state |ψsi of H and will perform the above sequence of
operations. This leads to the ﬁnal state

|ψfi = UtOxUt−1 ··· U1OxU0|ψsi.

(2)

5

The ﬁnal state is then measured with a measurement {M0, M1}. For an
input x ∈ {0, 1}n, we denote A(x) the output of the quantum query al-
gorithm A. Obviously, P r[A(x) = 0] = kM0|ψfik2 and P r[A(x) = 1] =
kM1|ψfik2 = 1 − P r[A(x) = 0]. We say that the quantum query algorithm
A computes f within an error ε if for every input x ∈ {0, 1}n it holds that
P r[A(x) = f (x)] ≥ 1 − ε. If ε = 0, we says that the quantum algorithm
is exact. For more details on quantum query complexity, we may refer to
[16, 15, 38, 3].

Quantum query models are one of most important computing model in
quantum computing. In this complexity models [16], an algorithm is charged
for “queries” to the input bits, while any intermediate computation is con-
sidered as free. For many functions one can obtain large quantum speed-
ups in the case algorithms are allowed a constant small probability of error
(bounded error). As the most famous example, Grover’s algorithm [33]
computes the n-bit OR function with O(√n) queries in the bounded-error
mode, while any classical algorithm needs Ω(n) queries. The model of exact
quantum query, where the algorithms must output the correct answer with
certainty for every possible input, seems to be more intriguing [12, 19, 24].
It is much more diﬃcult to come up with exact quantum algorithms that
outperform classical determistic algorithms.

In the exact quantum query complexity, it was recognized that the best
quantum speed-up for computing total functions was by a factor of 2 for
many years [29].
In a breakthrough result, Ambainis has presented the
ﬁrst example of a Boolean function f : {0, 1}n → {0, 1} for which exact
quantum algorithms have superlinear advantage over classical deterministic
algorithms [3]. Based on the results in [38, 6], Ambainis, Gruska, and Zheng
[5] have veriﬁed that exact quantum algorithms have certain advantage for
most of Boolean functions.

Ambainis et al [6] have developed optimal exact quantum algorithms for
computing functions EXACT k
n, which are to deter-
mine whether an n-bit string has Hamming weight exactly k and to deter-
mine whether an n-bit string has Hamming weight at least k. The complex-
ity is:

n and T HRESHOLDk

n ) = max(k, n − k);

• QE(EXACT k
• QE(T HRESHOLDk
If f is allowed to be a partial function, the Deutsch-Jozsa algorithm [24]
proved that there can be an exponential separation between exact quantum
and classical deterministic query complexity. Some generalizations [38, 21,

n) = max(k, n − k + 1).

6

47, 34] of the Deutsch-Jozsa problem were also investigated, and we will
indicate them carefully if there exist relations to our results.

1.3 Our main results

A general generalization of Deutsch-Jozsa problem is the following symmet-
rically partial function:

DJk

n(x) =(cid:26) 1

0

if |x| = n/2,
if |x| ≤ k or |x| ≥ n − k,

(3)

where n is even and 0 ≤ k < n/2.
it equals the problem given by Montanaro et al [38].

Clearly, when k = 0, it is the Deutsch-Jozsa problem, and when k = 1,

Our ﬁrst main result is as follows.

Theorem 1. The exact quantum query complexity of DJk

n satisﬁes:

QE(DJk

n) = k + 1.

However, the classical deterministic query complexity for DJk

n is:

D(DJk

n) = n/2 + k + 1.

(4)

(5)

[38] designed an exact quantum
Remark 3. When k = 1, Montanaro et al.
2-query algorithm to compute it, and their method is somewhat complicated
for deriving a unitary operator from solving a system of equations, but the
optimality with 2-query was not veriﬁed. Our result also shows the algorithm
by Montanaro et al [38] is optimal.

A natural question is what common characters are for the Boolean func-
tions with the same exact quantum query complexity? Due to the impor-
tance and simplicity of symmetric functions, here we consider the case of
exact quantum 1-query complexity for all symmetrically partial functions.
Therefore, the question is what can be solved with exact quantum 1-
query complexity? Notably, Aaronson, Ambainis, Iraids, and Kokainis [4]
recently proved that a partial Boolean function f is computable by a 1-query
quantum algorithm with error bounded by ε < 1/2 if and only if f can be
approximated by a degree-2 polynomial with error bounded by ε′ < 1/2.

We can pose the question more precisely: if an exact quantum 1-query
algorithm A computes an symmetrically partial function f , then, can any
symmetrically partial function g with QE(g) = 1 be computed by A? Our
second main result answers this question as follows.

7

Theorem 2. Any symmetrically partial Boolean function f has QE(f ) = 1
if and only if f can be computed by the Deutsch-Jozsa algorithm.

Therefore, all symmetrically partial Boolean functions having exact quan-
tum 1-query complexity can be computed by the Deutsch-Jozsa algorithm.

1.4 Organization

The remainder of this article is organized as follows. In Section 2 we study
the representation of symmetrically partial Boolean functions with multilin-
ear polynomials, and give a method for ﬁnding the approximate (and exact)
degree of symmetrically partial Boolean functions. Then in Section 3 we
investigate the exact quantum and classical deterministic query complex-
ity of a generalized Deutsch-Jozsa problem, that is, the function DJk
n, and
we present an optimal exact quantum (k + 1)-query algorithm to compute
DJk
n, but its classical deterministic query complexity is n/2 + k + 1. After
that, in Section 4 we give all symmetrically partial Boolean functions with
exact degree 1 or 2 in the sense of isomorphism. By combining the results
of Section 4, in Section 5 we study the exact quantum query complexity
for symmetrically partial Boolean functions with exact degree 1 or 2, and
in particular, we present all symmetrically partial Boolean functions with
exact quantum 1-query complexity as well as prove that these function can
be computed by the Deutsch-Jozsa algorithm. In addition, we in Section 6
study further the exact quantum query complexity for some symmetrically
partial Boolean functions, and Section 7 proposes some problems for further
study.

2 Degree of polynomials for symmetrically partial

functions

First we study the exact degree of symmetrically partial functions. We can
use the method of symmetrization [39] to prove the following lemma.
Lemma 1. For any symmetrically partial function f over {0, 1}n with do-
main of deﬁnition D, suppose fdeg0(f ) ≤ d. Then there exists a real multi-
linear polynomial q representing f and q can be written as
where ci ∈ R, Vi = Σj1j2...ji∈{1,2,...,n}ixj1xj2...xji where any j1j2...ji ∈ {1, 2, ..., n}i
is without repeated number, 1 ≤ i ≤ d, for example, V1 = x1 + ··· + xn,
V2 = x1x2 + x1x3 + ··· + xn−1xn, etc.

q(x) = c0 + c1V1 + c2V2 + ··· + cdVd,

(6)

8

Proof. Let p be a multilinear polynomial representing f and let deg(p) =

gdeg0(f ) = d. If π is some permutation and x = (x1, . . . , xn), then π(x) =
(xπ(1), . . . , xπ(n)). Let Sn be the set of all n! permutations. For any x ∈
{0, 1}n, the symmetrization of p is,

psym(x) = Pπ∈Sn

p(π(x))
n!

.

(7)

Clearly, 0 ≤ p(x) ≤ 1 implies 0 ≤ psym(x) ≤ 1 for x ∈ {0, 1}n. Since f is
symmetric, x ∈ D implies π(x) ∈ D. For all x ∈ D, we have f (π(x)) = f (x).
Since p represents f , for any x ∈ D, we have p(π(x)) = f (π(x)) = f (x) =
p(x). Therefore, for any x ∈ D,

psym(x) = Pπ∈Sn p(π(x))

n!

= Pπ∈Sn p(x)

n!

= p(x) = f (x).

(8)

So psym can represent f . Let the multilinear polynomial q = psym. According
to Minsky and Papert’s result [39] (also Lemma 2 in [16]), q can be written
as

Therefore, the lemma has been proved.

q(x) = c0 + c1V1 + c2V2 + ··· + cdVd.

(9)

c0 = 0,

we need to ﬁnd out the solution of the following linear system of equations:

2 (cid:1)c2 = 1. Therefore,

n, which
n) ≤ 2. Therefore,
we assume that there is a multilinear polynomial q(x) = c0 + c1V1 + c2V2
representing DJ0
n. For |x| = 0, we have q(x) = c0 = f (x) = 0. For |x| = n,
2 , we

Example 1. Let us give an example to ﬁnd outgdeg0(f ) for f = DJ0
is the Deutsch-Jozsa problem. We prove that gdeg0(DJ0
2(cid:1)c2 = 0. For |x| = n
we have q(x) =(cid:0)n
1(cid:1)c1 +(cid:0)n
2(cid:1)c2 =(cid:0)n
1(cid:1)c1 +(cid:0)n
0(cid:1)c0 +(cid:0)n
1 (cid:1)c1 +(cid:0)n/2
2 (cid:1)c2 =(cid:0)n/2
1 (cid:1)c1 +(cid:0)n/2
0 (cid:1)c0 +(cid:0)n/2
have q(x) =(cid:0)n/2

2(cid:1)c2 = 0,
1(cid:1)c1 +(cid:0)n
0(cid:1)c0 +(cid:0)n
(cid:0)n
2 (cid:1)c2 = 1.
1 (cid:1)c1 +(cid:0)n/2
0 (cid:1)c0 +(cid:0)n/2
(cid:0)n/2
, c2 = − 8
n. Therefore,gdeg0(DJ0
n) ≤ 2.
Suppose thatgdeg0(DJ0


It is easy to obtain that c0 = 0, c1 = 4(n−1)
n2 V2 representing DJ0
8

n) ≤ 1. Then there exists a multilinear polynomial
n. We need to get the solution for the

(cid:0)n
0(cid:1)c0 +(cid:0)n
(cid:0)n/2
0 (cid:1)c0 +(cid:0)n/2

1(cid:1)c1 = 0,
1 (cid:1)c1 = 1.

q(x) = c0 + c1V1 representing DJ0
following linear group of equations:

n2 and q(x) = 4(n−1)

n2 V1−

c0 = 0,

n2

9

(10)

(11)

n) = 2. The example ends.

For any total function f , with the next lemma it has been proved [10]

It is easy to deduce that there is no solution. Therefore, gdeg0(DJ0
and consequently gdeg0(DJ0
(or see [16]) that QE(f ) ≥ 1
Lemma 2. [10, 16] Let A be a quantum query algorithm that makes t
queries. Then there exist complex-valued n-variate multilinear polynomials
αi of degree at most t, such that the ﬁnal state of A is

2 deg(f ).

n) > 1,

Xi∈{0,1}m

αi(x)|ii

(12)

for every input x ∈ {0, 1}n.

Indeed, according to the proof of Theorem 17 in [16] (also refer to [10]),

Proof. Consider a Qε(f )-query quantum algorithm for f with error ε. Let
S be the set of basis states corresponding to a 1-output. Consider the

the following result still holds, and we also give a similar proof.
Lemma 3. For any partial Boolean function f , Qε(f ) ≥ 1
Qε(f ) denotes the quantum query complexity for f with bounded-error ε.

2fdegε(f ), where
polynomial p(x) =Pi∈S |αi(x)|2, which is the probability that the algorithm
outputs 1. If x ∈ D and f (x) = 1, then p(x) ≥ 1− ε. If x ∈ D and f (x) = 0,
then p(x) ≤ ε. Therefore, |p(x)−f (x)| ≤ ε for all x ∈ D. Since the algorithm
procedure to get the last state for any input x is the implementation of a
sequence of unitary operators, it is clear that 0 ≤ p(x) ≤ 1 for all x ∈ {0, 1}n.
So polynomial p(x) approximates f with error ε. According to Lemma 2,
the αi are polynomials of degree no more than Qε(f ), therefore p(x) is a
polynomial of degree no more than 2Qε(f ). Consequently, we have

and the lemma has been proved.

gdegε(f ) ≤ deg(p) ≤ 2Qε(f ),

(13)

In particular, when ε = 0 we have the following special case.

Lemma 4. For any partial Boolean function f , QE(f ) ≥ 1
We have proved that gdeg0(DJ0
n) ≥ 1

QE(DJ0
we can use the above lemma to conclude QE(DJ0

n) = 1. It is known that QE(DJ0

n) = 2. According to the above lemma,
n) ≤ 1 [24]. Therefore,

2fdeg0(f ).

n) = 1.

Now we deal with the case of approximating representation.

2gdeg0(DJ0

10

Lemma 5. For any symmetrically partial Boolean function f over {0, 1}n
with domain of deﬁnition D, suppose fdegε(f ) = d. Then there exists a real
multilinear polynomial q approximates f with error ε and q can be written
as

q(x) = c0 + c1V1 + c2V2 + ··· + cdVd

(14)

where ci ∈ R, V1 = x1 + ··· + xn, V2 = x1x2 + x1x3 + ··· + xn−1xn, etc.
Proof. The proof is similar to that of Lemma 1. For the readability, we
outline it again. Let p be a multilinear polynomial with degree d that
approximates f with error ε. The symmetrization of p is

psym(x) = Pπ∈Sn p(π(x))

n!

.

(15)

If x ∈ D, then |p(x) − f (x)| ≤ ε. Since f is symmetric, we have |psym(x) −
f (x)| = |p(x) − f (x)| ≤ ε. Since 0 ≤ p(π(x)) ≤ 1 for all x ∈ {0, 1}n, we
have 0 ≤ psym(x) ≤ 1 for all x ∈ {0, 1}n. According to Minsky and Papert’s
result [39] (also Lemma 2 in [16]), psym can be written as

psym(x) = c0 + c1V1 + c2V2 + ··· + cdVd.

(16)

Therefore, psym is the polynomial required.

It is important to determine the approximate degree of symmetrically
partial functions. The following lemma shows if or not an symmetrically
partial function has degree d.
Lemma 6. For any symmetrically partial function f over {0, 1}n with do-
main of deﬁnition D, and for the ﬁxed d and 0 ≤ ε < 1/2, there is a linear
programming algorithm to discover whether or not there exists

q(x) = c0 + c1V1 + c2V2 + ··· + cdVd =

ckVk

(17)

dXk=0

approximating f with error ε.

Proof. Suppose that f is fully described by the vector (b0, b1, . . . , bn) ∈
exists a polynomial q with degree d approximating f with error ε, then for
0 ≤ i ≤ n, q(x) satisﬁes the following inequalities and equalities:

{0, 1,∗}n+1, where f (x) = bi for |x| = i. For input x, Vk =(cid:0)|x|i(cid:1). If there
1. 0 ≤ q(x) =Pd

11

k=0 ck(cid:0) i

k(cid:1) ≤ ε if bi = 0;

k(cid:1) ≤ 1 if bi = 1;
k=0 ck(cid:0) i
2. 1 − ε ≤ q(x) =Pd
k(cid:1) ≤ 1 if bi = ∗.
k=0 ck(cid:0) i
3. 0 ≤ q(x) =Pd
Therefore, it suﬃces to verify whether the polyhedra has solution or not.
It is easy to transfer the above polyhedra to the normal form, i.e., P =
{c|Ac ≤ h}, where matrix A ∈ R2(n+1)×(d+1) and vector h ∈ R2(n+1). We
now consider the following linear programming problem:

LP: Max Z,

s.t. Ac + eZ ≤ h,

Z ≤ 0,

(18)

(19)

(20)

where e ∈ R2(n+1) and eT = (1, 1, . . . , 1). It is clear that S 6= ∅ if and only
if the maximal value Z∗ = 0.
According to Lemma 5, determininggdegε(f ) is equivalent to ﬁnd out the
minimal d such that q(x) =Pd
Theorem 3. For any symmetrically partial Boolean function f over {0, 1}n
with domain of deﬁnition D, and for the ﬁxed 0 ≤ ε < 1/2, there exists an
algorithm to ﬁnd out fdegε(f ) with time complexity O(log n) · t(LP ), where

t(LP ) is the time complexity to use linear programming algorithm to ﬁnd
the maximal value Z∗ in Lemma 6.

k=0 ckVk approximates f with error ε.

Proof. Let b = (b0, b1, . . . , bn) be the vector describing f . Let subroutine
LP(n, b, ε, d) = 1 (0) if there does (not) exist polynomial q with degree d
approximating f with error ε. The subroutine LP(n, b, ε, d) can be done
with a linear programming algorithm according to Lemma 6. We give a

In each iteration of the ‘while’ loop, it holds that LP(n, b, ε, r + 1) = 1

binary search algorithm to ﬁnd outgdegε(f ) as following:
and LP(n, b, ε, l−1) = 0. We havegdegε(f ) ≤ r+1 andgdegε(f ) > l−1. When
the ‘while’ loop is ﬁnished, we have that l = r + 1 andgdegε(f ) ≤ r + 1 = l.
Therefore,gdegε(f ) = l. The time complexity is O(log n) · t(LP ).

3 Generalized Deutsch-Jozsa problem

In this section we consider a generalized Deutsch-Jozsa problem DJk
n that
was described by Eq. (3), that is, the problem of distinguishing between the
inputs of Hamming weight n/2 and Hamming weights in the set {0, 1, . . . , k, n−
k, n − k + 1, . . . , n} for all even n with 0 ≤ k < n/2.

12

Algorithm 1 Algorithm for ﬁnding outgdegε(f )

1: procedure Degree(integer n, array b, real ε)
2:

⊲ b ∈ {0, 1,∗}n+1

integer l := 0, r := n;
while l ≤ r do

d = ⌊(l + r)/2⌋;
if LP(n, b, ε, d)=0 then l = d + 1;
else r = d − 1;
end if

3:

4:

5:

6:

7:

end while

8:
9: return l;
10: end procedure

3.1 Exact quantum algorithm

By combining the exact quantum query algorithms for the functions EXACT
and THRESHOLD by Ambainis et al [6], in this subsection we give an exact
quantum query algorithm for computing DJk
n.

Theorem 4. The exact quantum query complexity of DJk

n satisﬁes:

QE(DJk

n) ≤ k + 1.

(21)

Proof. We will give an exact quantum algorithm using k + 1 queries for
DJk
n. One of the important subroutines that we will use in this paper is as
following.

• Input: x = x1, x2, . . . , xm.
• Output: If the output is (0, 0) then |x| 6= m/2. Otherwise, it will

output (i, j) such that xi 6= xj.

We call this subroutine Xquery. Let x ∈ {0, 1}m. If Xquery(m, x) = (0, 0),
then |x| 6= m/2. If Xquery(m, x) = (i, j), then xi 6= xj.
Indeed, according to [6] by Ambainis et al, the subroutine Xquery can be
implemented in one exact quantum query algorithm, and we put the details
concerning the subroutine Xquery in Appendix A.

Based on the subroutine Xquery, now we give an algorithm (Algorithm

2) for DJk

n. It is clear that Algorithm 2 uses at most k + 1 queries.

13

Algorithm 2 Algorithm for DJk
n
1: procedure DJ(integer n, integer k, array x)
2:

integer l:=1
while l ≤ k do

⊲ x ∈ {0, 1}n

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

Output ←Xquery(n, x)
if Output=(0,0) then return 0
end if
if Output=(i, j) then

x ← x \ {xi, xj}
l ← l + 1
n ← n − 2

end if

end while
Output ←Xquery(n, x)
if Output=(0,0) then return 0
end if
if Output=(i, j) then return 1
end if

17:
18: end procedure

3.2 Lower bound of exact quantum query complexity

The purpose of this subsection is to prove that the exact quantum query
complexity of DJk

n is no less than k + 1, i.e., QE( DJk

n) ≥ k + 1.

Theorem 5. The exact quantum query complexity of DJk

n satisﬁes:

QE(DJk

n) ≥ k + 1.
n) ≥ 2k + 2. Let us consider a simple case
n) ≤ 3, according to Lemma
i=0 ciVi representing DJ1
n.
For |x| = 0, we have q(x) = c0 = f (x) = 0. For |x| = 1, we have q(x) =
the following equations:

Proof. We will prove thatgdeg0(DJk
k = 1 and n ≥ 6 ﬁrst. Suppose that gdeg0(DJ1
1, there exists a multilinear polynomial q(x) =P3
c0 +(cid:0)1

1(cid:1)c1 = f (x) = 0 and therefore c1 = 0. For |x| = n, n − 1, n/2, we have

(22)



3(cid:1)c3 = 0,
(cid:0)n
2(cid:1)c2 +(cid:0)n
2 (cid:1)c2 +(cid:0)n−1
(cid:0)n−1
3 (cid:1)c3 = 0,
(cid:0)n/2
2 (cid:1)c2 +(cid:0)n/2
3 (cid:1)c3 = 1.

14

(23)

Let us consider the determinant

(cid:12)(cid:12)(cid:12)(cid:12)

1

=

3 (cid:1) (cid:12)(cid:12)(cid:12)(cid:12) =(cid:12)(cid:12)(cid:12)(cid:12) (cid:0) n
n−2(cid:1)
(cid:0) n
n−3(cid:1)
3(cid:1)
2(cid:1)
(cid:0)n
(cid:0)n
n−4(cid:1) (cid:12)(cid:12)(cid:12)(cid:12)
2 (cid:1) (cid:0)n−1
(cid:0)n−1
(cid:0)n−1
n−3(cid:1)
(cid:0)n−1
n−2(cid:1)
n(cid:12)(cid:12)(cid:12)(cid:12) (cid:0) n
(cid:0) n
n−3(cid:1)
n−4(cid:1) (cid:12)(cid:12)(cid:12)(cid:12)
n−3(cid:1) n(cid:0)n−1
n(cid:0)n−1
n−2(cid:1)
n−3(cid:1)
(cid:0) n
(cid:0) n
n−3(cid:1) (cid:12)(cid:12)(cid:12)(cid:12)
n(cid:12)(cid:12)(cid:12)(cid:12)
(n − 2)(cid:0) n
n−2(cid:1) (n − 3)(cid:0) n
n(cid:12)(cid:12)(cid:12)(cid:12) (cid:0) n
n−2(cid:1) (cid:0) n
n−3(cid:1)
(cid:12)(cid:12)(cid:12)(cid:12) 6= 0.
(cid:0) n
n−2(cid:1)

=

=

1

0

1

(24)

(25)

(26)

(27)

n) ≥ 4. According the Lemma 4, we have QE(DJ1
n) ≥ 2. That is to say, the algorithm in Theorem 4 for DJ1

1
optimal. The algorithm in [38] for DJ1

Therefore, in order to satisfy the ﬁrst two equations, we have c2 = c3 = 0.
The last equation will not hold, which means that such q does not ex-
n) ≥
n is

ist. Thus, gdeg0(DJ1
2gdeg0(DJ1
Now we consider for the general case. Suppose that gdeg0(DJk
P2k+1

n) ≤ 2k +
1, according to Lemma 1, there exists a multilinear polynomial q(x) =
n. For 0 ≤ |x| ≤ k, f (x) = 0. Therefore, we
have c0 = c1 = ··· = ck = 0. For |x| = n, n − 1, . . . , n − k, we have the
following equations:

i=0 ciVi representing DJk

n is also optimal.

(28)

Let us consider the determinant (see Appendix B for the detailed proof):

2k+1(cid:1)c2k+1 = 0,
2k+1(cid:1)c2k+1 = 0,
2k+1(cid:1)c2k+1 = 0.



k+2(cid:1)ck+2 + ··· +(cid:0) n
k+1(cid:1)ck+1 +(cid:0) n
(cid:0) n
k+2(cid:1)ck+2 + ··· +(cid:0) n−1
(cid:0)n−1
k+1(cid:1)ck+1 +(cid:0)n−1
···(cid:0)n−k
k+2(cid:1)ck+2 + ··· +(cid:0) n−k
k+1(cid:1)ck+1 +(cid:0)n−k
2k+1(cid:1)
(cid:0) n
k+2(cid:1)
(cid:0) n
(cid:0)n−1
k+2(cid:1)
(cid:0) n−1
2k+1(cid:1)
(cid:0)n−k
(cid:0) n−k
k+2(cid:1)
2k+1(cid:1)
2gdeg0(DJk

n) ≥ k + 1.

···
···
. . .
···

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

k(k+5)

= (−1)

i(cid:1)
i=k+1(cid:0)n
·Q2k+1
i(cid:1) 6= 0.
i=1(cid:0)n
Qk
q(x) = 0, which is a contradiction. Therefore, gdeg0(DJk

Therefore, we have ck+1 = ··· = c2k+1 = 0. Then for |x| = n/2, f (x) =
n) ≥ 2k + 2 and
QE(DJk

n) ≥ 1

(29)

k+1(cid:1)
(cid:0) n
(cid:0)n−1
k+1(cid:1)
(cid:0)n−k
k+1(cid:1)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

...

...

...

2

15

3.3 Exact classical query complexity

Theorem 6. The classical deterministic query complexity of DJk

n satisﬁes:

D(DJk

n) = n/2 + k + 1.

(30)

n) ≥ n/2 + k + 1.

Proof. If the ﬁrst n/2 queries return xi = 1 and the next k queries re-
turn xi = 0, then we will need to make another query as well. Therefore,
D(DJk

Now suppose that we have made n/2 + k + 1 queries. If no more than
k queries return xi = 0, then there are more than n/2 + 1 queries returning
xi = 1 and DJk
n(x) = 0. If no more than k queries return xi = 1, then there
are more than n/2 + 1 queries returning xi = 0 and DJk
n(x) = 0. If there are
more than k queries return xi = 0 and also more than k queries return xi = 1,
then it muse be balanced and DJk
n) ≤ n/2 + k + 1
and the theorem has been proved.

n(x) = 1. Therefore, D(DJk

Remark 4. Again, we make some comparisons to the previous results.
When k = 0, this is the Deutsch-Jozsa problem; when k = 1, this problem
was considered by Montanaro et al [38] and an exact quantum 2-query al-
gorithm was given to solve it, but the optimality was not veriﬁed. Also, the
method in [38] is diﬀerent (the unitary operator in their query algorithm
was derived from distinguishing two orthogonal subsets of states).

So far, according to Theorem 4, Theorem 5, Theorem 6, our ﬁrst

main result, Theorem 1 has been proved.

4 Symmetrically partial functions with degree 1

or 2

This section is to give all symmetrically partial functions with degree 1 or 2

in the isomorphic sense. From now on, we just identity deg(f ) withgdeg0(f )

for any partial Boolean function f .

Lemma 7. For n > 1, then

deg(f (1)

n,n) = 1,

(31)

where f (1)

n,n is deﬁned as Eq. (32) with k = n, and the following symmetrically

16

partial Boolean functions have degree 2:

f (1)

f (2)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,l (x) =(cid:26) 0 if |x| = 0 or |x| = n,
n (x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = l,

1 if |x| = k or |x| = k + 1,

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉,

f (3)

f (4)

(32)

(33)

(34)

(35)

where n − 1 ≥ k ≥ ⌊n/2⌋, and ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋. As usual, for odd n,
⌊n/2⌋ = (n − 1)/2 and ⌈n/2⌉ = (n + 1)/2.
Proof. Since the polynomial q(x) = x1+x2+...+xn
f (1)
n,n with error 0, deg(f (1)
functions have degree 2 exactly.

n V1 can approximate
n,n) = 1 is veriﬁed. Next, we prove that the rest

= 1

n

Case 1. For n − 1 ≥ k ≥ ⌊n/2⌋, it is easy to check that deg(f (1)

n,k) > 1,
k V1 > 1 for |x| ≥ k. As for the proof of

since the polynomial q(x) = 1
deg(f (1)

n,k) = 2, it follows from the following Case 2.
Case 2. For n − 1 ≥ k ≥ ⌊n/2⌋, it is easy to verify that deg(f (2)

n,k) > 1.
n,k) = 2 in terms of the polynomial

Indeed, we can further verify that deg(f (2)
q(x) = 2

k+1 V1 − 2

k(k+1) V2.

k(k+1)

k+1(cid:0)i

k(k+1)(cid:0)i

1(cid:1) − 2

(1) First, we have q(x) = f (2)
n,k(x) for |x| = 0, k, k + 1.
(2) Second, it follows 0 ≤ q(x) ≤ 1 from q(x) = 2

k+1 for |x| = 1 and
q(x) = 2
for |x| = i ≥ 2. Indeed, since k ≥
⌊n/2⌋, we have q(x) ≥ 0; on the other hand, i(2k + 1 − i) − k(k + 1) =
−(i−k−1/2)2+1/4 ≤ −(1/2)2+1/4 ≤ 0, consequently we have 0 ≤ q(x) ≤ 1.
n,k) =
n,k) = 2 for n − 1 ≥ k ≥

n,k with error 0, and therefore deg(f (2)

2(cid:1) = i(2k+1−i)

So, this q(x) can approximate f (2)

n,k) ≤ deg(f (2)

n,k), we have also deg(f (1)

2. Since deg(f (1)
⌊n/2⌋.
Case 3. We now verify deg(f (4)
1. If n is even, the function f (4)
n
with QE(f (4)
deg(f (4)
p(x) = 2

n ) = 1, and with Lemma 4 we have deg(f (4)

n ) >
is the well-known Deutsch-Jozsa problem
n ) ≤ 2. Therefore
n ) = 2. If n is odd with n = 2m + 1, then we consider the polynomial
m(m+1) V2. When |x| = 0, n, m, m + 1, we have p(x) =

n ) = 2. It is easy to verify that deg(f (4)

m+1 V1 +

2

17

f (4)
n (x). If |x| = 1, then p(x) = 2
m(m+1)(cid:0)i
then p(x) = 2
above we also have 0 ≤ p(x) ≤ 1. Hence p(x) can approximate f (4)
error 0 and deg(f (4)

m+1 and 0 ≤ p(x) ≤ 1. For 2 ≤ |x| = i ≤ n,
m(m+1) . According to Case 2 (2)
n (x) with

2(cid:1) = i(2m+1−i)

m+1(cid:0)i
1(cid:1) −

n ) = 2.

2

Case 4. It is easy to verify that deg(f 3l

n) > 1. On the other hand, we

n ) = 2. Therefore, we have deg(f (3)

n,l ) = 2.

always have deg(f (3)

n,l ) ≤ deg(f (4)

First we note deg(f (2)

n,l ) ≤ deg(f (3)

give a polynomial q(x) of degree 2 to approximate f (3)
this polynomial q(x) = 4
check that 0 ≤ q(x) ≤ 1 and q(x) = f (3)
f (1)
n,n being 1.

n+1 V1 −

n,l ) with l = ⌊n/2⌋. Then we only need to
n,l with error 0. Consider
(n−1)(n+1) V2. Omitting the details, we can

8

n,l (x) for |x| = 0, n,⌊n/2⌋,⌈n/2⌉.

Summarily, the functions above have degree 2 except for the degree of

Indeed, the following lemma shows that those functions in Lemma 7
contain all symmetrically partial functions with degree 1 or 2. First, we
consider the case of n being odd. Indeed, the case of n being even is similar.
Lemma 8. Let n > 1 be odd, and let f : {0, 1}n → {0, 1} be an n-bit
symmetrically partial Boolean function. Then:

(1) if deg(f ) = 1, then f is isomorphic to the function f (1)
n,n;
(2) if deg(f ) = 2, then f is isomorphic to one of the functions

f (1)

f (2)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,l (x) =(cid:26) 0 if |x| = 0 or |x| = n,
n,1(x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = l,

1 if |x| = k or |x| = k + 1,

f (3)

f (4)

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉,

(36)

(37)

(38)

(39)

where n − 1 ≥ k ≥ ⌊n/2⌋, and ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋.
Proof. The lemma can be easily veriﬁed for n ≤ 3, so we now prove the case
of n > 3. Since the degree of function f to be considered is not 0, f is not a
constant function. Let (b0, b1, . . . , bn) ∈ {0, 1,∗}n+1 be the vector describing
f . Then there exist 0 ≤ i < j ≤ n such that bi = 0 and bj = 1, otherwise, we

18

can consider its isomorphic function (¯b0, ¯b1, . . . , ¯bn), instead of f . Also, we
note that if a polynomial q approximates function (b0, b1, . . . , bn) with error
0, then the polynomial 1 − q can approximate function (¯b0, ¯b1, . . . , ¯bn) with
error 0, and the polynomial q(¯x) can approximate function (bn, bn−1, . . . , b0)
with error 0, as well as the polynomial 1 − q(¯x) can approximate function
(¯bn, ¯bn−1, . . . , ¯b0) with error 0.
(1) If deg(f ) = 1, according to Lemma 5, there is a polynomial q(x) =
c0 + c1V1 that approximates f with error 0. Therefore, we have:

(a) q(x) = c0 + c1 · i = 0 for |x| = i, and q(x) = c0 + c1 · j = 1 for |x| = j;
(b) 0 ≤ q(x) = c0 + c1 · m ≤ 1 for 0 ≤ |x| = m ≤ n.
From (a), we have c0 = −i/(j − i) and c1 = 1/(j − i). However, (b)
implies 0 ≤ c0 ≤ 1 by taking |x| = 0. Therefore i = 0 and c0 = 0.
In
addition, when |x| = n, it follows from (b) that c1 ≤ 1/n. Therefore j = n
and c1 = 1/n. Moreover, bk is undeﬁned (i.e., ∗) for k 6∈ {0, n}, otherwise,
q(x) = k/n 6= bk.
Therefore, the symmetrically partial Boolean function f must isomorphic
to (0,∗, . . . ,∗, 1), i.e. the function f (1)
n,n.
(2) If deg(f ) = 2, with Lemma 5, there is a polynomial q(x) = c0 +
c1V1 + c2V2 approximating f with error 0. Suppose that bi = 0 and bj = 1
for some 0 < i < j < n. Then we have:

1 for |x| = j;

1(cid:1)+c2(cid:0)i
(a) q(x) = c0+c1(cid:0)i
(b) 0 ≤ q(x) = c0 + c1(cid:0)m

By virtue of (a), we have:

2(cid:1) = 0 for |x| = i, and q(x) = c0+c1(cid:0)j
2(cid:1) ≤ 1 for 0 ≤ |x| = m ≤ n.
1(cid:1) + c2(cid:0)m

1(cid:1)+c2(cid:0)j
2(cid:1) =

c1 = −

i + j − 1

ij

c2 =

2
ij

c0 +

On the other hand, by taking |x| = 0, (b) implies 0 ≤ c0 ≤ 1. Now for

,

i − 1
c0 −
j(j − i)
2

.

j(j − i)

19

|x| = n we have

q(x) = c0 + c1(cid:18)n

1(cid:19) + c2(cid:18)n
2(cid:19)

i + j − 1

= c0 + n(−

ij
(n − i)(n − j)

=

c0 +

i − 1
j(j − i)

c0 −
n(n − i)
j(j − i)

ij
n(n − i)
j(j − i)

≥
> 1,

) +

1
2

n(n − 1)(

2
ij

c0 +

2

j(j − i)

) (40)

(41)

(42)

(43)

but this contradicts to q(x) ≤ 1. This contradiction is derived from the
assumption of bi = 0 and bj = 1 for some 0 < i < j < n. So, by combining
with the isomorphic property, we have obtained the following result:
Result 1: If bi ∈ {0, 1} for 0 < i < n, then bj 6= ¯bi for 0 < j < n.
So, furthermore it suﬃces to consider b0 = 0 or bn = 1. We now consider

the case b0 = 0.

Note that b0 = 0 implies c0 = 0. Suppose that b1 = 1. Then we have (1)

2(cid:1) = c1 = 1 for |x| = 1 and, (2) 0 ≤ q(x) = c1(cid:0)m

1(cid:1)+c2(cid:0)1
q(x) = c1(cid:0)1
1 for 0 ≤ |x| = m ≤ n.
1(cid:1) + c2(cid:0)n
With (2), by taking |x| = n, we have 0 ≤ c1(cid:0)n
n−1 ≤ c2 ≤ −2
−2
1 (cid:19) + c2(cid:18)n − 2
2 (cid:19)

n . When |x| = n − 2, with (2) we have

q(x) =c1(cid:18)n − 2

1(cid:1)+c2(cid:0)m
2(cid:1) ≤
2(cid:1) ≤ 1 and therefore

1
2
1
2

=n − 2 +
≥n − 2 +
>1,

(n − 2)(n − 3)c2
(n − 2)(n − 3) −2
n − 1

(44)

(45)

(46)

(47)

(48)

which is a contradiction to q(x) ≤ 1. Therefore b1 6= 1.
some 1 < j < ⌊n/2⌋. Then we have

Indeed, for 1 < j < ⌊n/2⌋ we also have bj 6= 1: Suppose that bj = 1 for

1(cid:1) + c2(cid:0)j
(a) q(x) = c1(cid:0)j
(b) 0 ≤ q(x) = c1(cid:0)m

2(cid:1) = 1 for |x| = j;
1(cid:1) + c2(cid:0)m

With (a) we have

2(cid:1) ≤ 1 for 0 ≤ |x| = m ≤ n.
j(j − 1) −

2
j − 1

c1.

2

c2 =

20

With (b), by taking |x| = n and combining with Eq. (48) we have

0 ≤ nc1 +
= nc1 +

1
2
1
2

≤ 1,

n(n − 1)c2
n(n − 1)(

2

j(j − 1) −

2
j − 1

c1)

which follows

n + j − 1

nj

≤ c1 ≤

n − 1
j(n − j)

.

(49)

(50)

(51)

(52)

(53)

(54)

(55)

(56)

(57)

(58)

(59)

Similarly, with (b), by taking |x| = ⌈n/2⌉ and combining with Eq. (48)

we have

q(x) =

=

=

2

2

n + 1

2

n + 1

c1 +

1
2
1
2
2 − 1)

c1 +

2
2 ( n+1
n+1
j(j − 1)

n + 1

n + 1

n + 1

n + 1

(

(

2 − 1)c2
2 − 1)(

+ (

n + 1

2 −

c1)

2

n+1

j(j − 1) −
2 ( n+1
2 − 1)
j − 1

2
j − 1
)c1.

Therefore, with j < ⌈n/2⌉, we have

q(x) ≥

=

n+1

2 − 1)

2 ( n+1
j(j − 1)
2 (n − n+1
2 )
j(n − j)

n+1

+ (

n + 1

2 −

.

n+1

2 − 1)

2 ( n+1
j − 1

)

n − 1
j(n − j)

Furthermore, with j < ⌊n/2⌋, we have
n − 1

n − 1

) − j(n − j)

2

= (

2

(n −
n − 1
2 − j)(n −

n − 1

2 − j) > 0.

Together with the above equations we obtain q(x) ≥ 1 for |x| = ⌈n/2⌉, a
contradiction. So, we conclude the following result.

Result 2: If bj = 1, then j ≥ ⌊n/2⌋.
Let l be the smallest integer satisfying bl = 1 (of course, l ≥ ⌊n/2⌋).

Next we will prove that bk 6= 1 for any k > l + 1.

21

1(cid:1) + c2(cid:0)k

|x| = l + 1 < k, we have

Assume that bk = 1. Then we have c0 = 0, c0 + c1(cid:0)l
c0 + c1(cid:0)k
2(cid:1) = 1. Therefore, c0 = 0, c1 = l+k−1
q(x) = c0 + c1(cid:18)l + 1
1 (cid:19) + c2(cid:18)l + 1
2 (cid:19)
l(l + 1) · −2

= (l + 1)

1
2

lk

+

lk

1(cid:1) + c2(cid:0) l

2(cid:1) = 1 and

lk . For

and c2 = −2

l + k − 1
lk
(l + 1)(k − 1)

lk

=

> 1,

(60)

(61)

(62)

(63)

which is a contradiction. Therefore, we have proved this result:

any k > l + 1.

Result 3: If l is the smallest integer satisfying bl = 1, then bk 6= 1 for
Now let l be the smallest integer satisfying bl = 1. Next we complete the

proof by considering l with ﬁve cases.

n,n−1.

6= 1 for 2 ≤ i ≤ n − 1, that is bi

(I) l = n, i.e., bi 6= 1 for 1 ≤ i ≤ n − 1. Since the isomorphic function
(¯bn, ¯bn−1, . . . , ¯b0) also has degree 2 and ¯bn = 0, ¯b0 = 1, according to the
above Result 3, we have ¯bi
6= 0 for
2 ≤ i ≤ n − 1. Therefore f can be described by b = (0, b1,∗, . . . ,∗, 1).
If b1 = ∗, then deg(f ) = 1. So, we conclude f must be the formulation
b = (0, 0,∗, . . . ,∗, 1), and it is isomorphic to f (2)
(II) l = n− 1, i.e., bi 6= 1 for 1 ≤ i < n− 1. From Result 1 we know that
bj 6= ¯bl for 0 < j < n, that is bj 6= 0 for 0 < j < n. As a result, f has this
formulation b = (0,∗, . . . ,∗, 1, bn). However, if bn = 0, then it is isomorphic
to (0, 1,∗, . . . , 0), which results in deg(f ) > 2. Therefore, bn = 1 and f is
described by b = (0,∗, . . . ,∗, 1, 1), exactly the function f (2)
(III) ⌈n/2⌉ < l < n − 1, that is, bi 6= 1 for 1 ≤ i < l and l + 1 < i ≤ n.
From Result 1 it follows that bj 6= 0 for 0 < j < n. As a consequence, f has
the formulation b = (0,∗, . . . ,∗, 1, bl+1,∗, . . . ,∗, bn) where bn 6= 1. If bn = 0,
then f is isomorphic to (0,∗, . . . ,∗, bl+1, 1,∗, . . . ,∗, 0), which from Result 2
follows deg(f ) > 2, a contradiction. So, it holds that bn = ∗, and f thus has
the form b = (0,∗, . . . ,∗, 1, bl+1,∗, . . . ,∗). In this representation, bl+1 = ∗
implies the function f = f (1)

n,l ; and bl+1 = 1 results in f = f (2)
n,l .

n,n−1 as well.

(IV) l = ⌈n/2⌉. Then bi 6= 1 for 1 ≤ i < (n+1)/2 and (n+1)/2+1 < i ≤
n. With Result 1 we have also bj 6= 0 for 0 < j < n. Now it concludes that
f has this representation b = (0,∗, . . . ,∗, 1, bl+1,∗, . . . , bn). Furthermore, if
bl+1 = ∗ and bn = ∗, then f = f (1)
n,l ; if

n,l ; if bl+1 = ∗ and bn = 0, then f = f (3)

22

bl+1 = 1 and bn = ∗, then f = f (2)

in deg(f ) > 2, which is an impossible case.

n,l . Finally, both bl+1 = 1 and bn = 0 result

(V) l = ⌊n/2⌋. Then bi 6= 1 for 1 ≤ i < (n − 1)/2 and (n − 1)/2 + 1 <
i ≤ n. Result 1 also implies bj 6= 0 for 0 < j < n. Therefore f has this
representation b = (0,∗, . . . ,∗, 1, bl+1,∗, . . . , bn). In addition, if bl+1 = ∗ and
n,l ; if bl+1 = ∗ and bn = 0, then f = f (3)
bn = ∗, then f = f (1)
n,l ; if bl+1 = 1 and
n,l ; if bl+1 = 1 and bn = 0, then f = f (4)
bn = ∗, then f = f (2)
n,1.
So, the case of b0 = 0 has been proved. Finally, we consider the case bn =
1 with an isomorphic method. Because b = (b0, b1, . . . , bn) is isomorphic to
b′ = (¯bn, ¯bn−1, . . . , ¯b0), we have deg(b′) = deg(b) = 2. Since ¯bn = 0, as
we have proved above, the function b′ must be isomorphic to the one of
the following functions: f (1)
n,l , where n ≥ k ≥ ⌊n/2⌋ and
⌊n/2⌋ ≤ l ≤ ⌈n/2⌉. Therefore, f must be isomorphic to the one of the
following functions: f (1)
n,l , where n ≥ k ≥ ⌊n/2⌋ and
⌊n/2⌋ ≤ l ≤ ⌈n/2⌉.

n,l and f (1)

n,l and f (1)

n,l , f (2)

n,l , f (3)

n,l , f (2)

n,l , f (3)

If n is an even, then with a similar process of proof to the case of n being

odd we have the following result.
Lemma 9. Let n > 1 be even, and let f : {0, 1}n → {0, 1} be an n-bit
symmetrically partial Boolean function. Then:

(1) if deg(f ) = 1, then f is isomorphic to the function f (1)
n,n;
(2) if deg(f ) = 2, then is isomorphic to one of the functions

f (1)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,n/2(x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = k or |x| = k + 1,

1 if |x| = n/2,

f (2)

f (3)

(64)

(65)

(66)

where n − 1 ≥ k ≥ n/2.

Therefore, combining Lemmas 7 with 8 and 9, we have the following two

lemmas.
Lemma 10. Let n > 1 be odd, and let f : {0, 1}n → {0, 1} be an n-bit
symmetrically partial Boolean function. Then:

(1) deg(f ) = 1 if and only if f is isomorphic to the function f (1)
n,n;

23

(2) deg(f ) = 2 if and only if f is isomorphic to one of the functions

f (1)

f (2)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,l (x) =(cid:26) 0 if |x| = 0 or |x| = n,
n,1(x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = l,

1 if |x| = k or |x| = k + 1,

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉,

f (3)

f (4)

(67)

(68)

(69)

(70)

where n − 1 ≥ k ≥ ⌊n/2⌋, and ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋.
Lemma 11. Let n > 1 be even, and let f : {0, 1}n → {0, 1} be an n-bit
symmetrically partial Boolean function. Then:

(1) deg(f ) = 1 if and only if f is isomorphic to the function f (1)
n,n;
(2) deg(f ) = 2 if and only if f is isomorphic to one of the functions

f (1)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,n/2(x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = k or |x| = k + 1,

1 if |x| = n/2,

f (2)

f (3)

(71)

(72)

(73)

where n − 1 ≥ k ≥ n/2.

Combining Lemmas 10 and 11 we obtain the following result concerning
the characterizations of all symmetrically partial Boolean functions with
degree 1 or 2.
Theorem 7. Let n > 1 and let f : {0, 1}n → {0, 1} be an n-bit symmetri-
cally partial Boolean function. Then:

(1) deg(f ) = 1 if and only if f is isomorphic to the function f (1)
n,n;

24

(2) deg(f ) = 2 if and only if f is isomorphic to one of the functions

f (1)

f (2)

f (3)

f (4)

1 if |x| = k,

n,k(x) =(cid:26) 0 if |x| = 0,
n,k(x) =(cid:26) 0 if |x| = 0,
n,l (x) =(cid:26) 0 if |x| = 0 or |x| = n,
n (x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = l,

1 if |x| = k or |x| = k + 1,

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉,

(74)

(75)

(76)

(77)

where n − 1 ≥ k ≥ ⌊n/2⌋, and ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋.
Remark 5. According to Lemma 4, symmetric Boolean functions that can
be computed by exact quantum 1-query algorithm must have degree not
more than 2. Therefore, Theorem 7 describes all possible symmetric Boolean
functions that can be computed by exact quantum 1-query algorithms.

5 Symmetrically partial functions with exact quan-

tum 1-query complexity

In this section, we try to ﬁnd out all symmetrically partial functions that
can be computed with exact quantum 1-query algorithms. More precisely,
we will obtain that any symmetrically partial function has exact quantum
1-query complexity if and only if it can be computed by Deutsch-Jozsa
algorithm.

First, we have the following proposition that was proved in [34].

Proposition 1. [34] Let n > 1. Then for any n ≥ k ≥ ⌈n/2⌉, QE(f (1)

n,k) = 1.

The exact quantum query complexity of f (2)

n,k is beyond 1, and this is the

following result.

Theorem 8. Let n > 1. Then for any 0 < k < n, QE(f (2)

n,k) ≥ 2.

Proof. The proof is divided into two cases in terms of 0 < k < n − 1 and
k = n − 1.
Case 1: 0 < k < n− 1. Assume that there is an exact quantum 1-query
algorithm with U0, Ox and U1 being the sequence of unitary operators for

25

n,k, and |ψsi being its starting state. Let U0|ψsi = Pn,m

f (2)
When |x| = 0, we have

i=0,j=1 αij|ii|ji.

|ψ0i = OxU0|ψsi =

n,mXi=0,j=1

αij|ii|ji.

Denote βi =Pm

we have

j=1 |αij|2.

When |x| = k, let x1 = ··· = xk = 1 and xk+1 = ··· = xn = 0, and then

|ψki = OxU0|ψsi

=

k,mXi=1,j=1

−αij|ii|ji +

mXj=1

α0j|0i|ji +

n,mXi=k+1,j=1

αij|ii|ji.

Since the algorithm is exact, the quantum state U1|ψ0i must be orthogonal
to the quantum state U1|ψki. Therefore, we have

0 =(U1|ψ0i)†U1|ψki = hψ0|ψki

αijhi|hj| ×
k,mXi=1,j=1

α0j|0i|ji +

=
n,mXi=0,j=1

mXj=1
mXj=1
|α0j|2 +
kXi=1

=β0 −

=

βi +

k,mXi=1,j=1
nXi=k+1

−|αij|2 +

βi.

−αij|ii|ji +

n,mXi=k+1,j=1

n,mXi=k+1,j=1

|αij|2

αij|ii|ji

(78)

(79)

(80)

(81)

(82)

When |x| = k + 1, let x1 = ··· = xk+1 = 1 and xk+2 = ··· = xn = 0,

and then we have

|ψ(k+1)0i = OxU0|ψsi

=

k+1,mXi=1,j=1

−αij|ii|ji +

α0j|0i|ji +

n,mXi=k+2,j=1

αij|ii|ji.

mXj=1

26

We also have

0 =(U1|ψ0i)†U1|ψ(k+1)0i = hψ0|ψ(k+1)0i

=


n,mXi=0,j=1
mXj=1
k+1Xi=1

αijhi|hj| ×
k+1,mXi=1,j=1
nXi=k+2

βi

βi +

α0j|0i|ji +

=β0 −

= − 2βk+1,

−αij|ii|ji +

n,mXi=k+2,j=1

αij|ii|ji

(83)

(84)

(85)

(86)

(87)

(89)

(90)

where the last equality is according to β0 −Pk

Eq. (82). So, we have βk+1 = 0.

i=1 βi +Pn

With such an input x then we can similarly obtain βl = 0.

Let x1 = ··· = xk = 1, xl = 1 for an l > k + 1 and let the others be 0.
As a result, we have obtained that βi = 0 for k +1 ≤ i ≤ n, and therefore

i=k+1 βi = 0 from

β0 −

kXi=1

βi = 0.

(88)

Let xl = 0 for an l ≤ k, let xj = 1 for j ≤ k +2 with j 6= l, and the others
xi = 0 for n ≥ i ≥ k + 3. For such an input x, denote |ψ(k+1)li = OxU0|ψsi.
Then similarly we have

0 =(U1|ψ0i)†U1|ψ(k+1)li = hψ0|ψ(k+1)li

=
n,mXi=0,j=1

mXj=1
l−1Xi=1

=β0 −

αijhi|hj| ×
l−1,mXi=1,j=1
k+2Xi=l+1

βi + βl −

α0j|0i|ji +

=2βl,

βi

−αij|ii|ji +

mXj=1

αlj|li|ji +

k+2,mXi=l+1,j=1

−αij|ii|ji(91)

(92)

(93)

27

where the last equality follows from Eq. (88).

Therefore, now we have βl = 0 for 1 ≤ l ≤ n. From Eq. (88) it follows
that β0 = 0. So far, we have concluded that βl = 0 for 0 ≤ l ≤ n, which
result in αij = 0 for 0 ≤ i ≤ n and 1 ≤ j ≤ m.
i=0,j=1 αij|ii|ji = 0 and |ψsi = 0, a contra-
diction.
Case 2: k = n − 1. By using the above method as Case 1, it is easy
n) ≥ 2 for

to verify that 1-query is not enough. Therefore, we have QE(f 2k
0 < k < n.

Consequently, U0|ψsi =Pn,m

Combining Lemma 11 and Theorem 8 as well as Proposition 1, we have

the following result.
Theorem 9. Let n be even and let f : {0, 1}n → {0, 1} be an n-bit symmet-
rically partial function. Then QE(f ) = 1 if and only if f is isomorphic to
one of these functions: f (1)

n,k and f (3)

n,n/2, where k ≥ n/2.

n,n, f (1)

n,k, f (2)

Proof. Suppose that QE(f ) = 1. Then according to Lemma 4, deg(f ) ≤
2QE(f ) = 2. By virtue of Lemma 11, f is isomorphic to one of these func-
tions: f (1)
n,k, f (3)
n,n/2 for n − 1 ≥ k ≥ n/2. Furthermore, Proposition
1 shows that QE(f (1)
n,k) = 1 for n ≥ k ≥ n/2; and QE(f (3)
n,n/2) = 1 is de-
rived from Deutsch-Jozsa algorithm; Theorem 8 gives QE(f (2)
n,k) ≥ 2 for any
0 < k < n. Consequently, QE(f ) = 1 implies that f is isomorphic to one of
these functions: f (1)

n,k and f (3)

n,n/2, where k ≥ n/2.

On the other hand, since QE(f (1)

1, if f is isomorphic to one of these functions: f (1)
by Fact 1, QE(f ) = 1 follows.

n,k and f (3)

n,k) = 1 for n ≥ k ≥ n/2, and QE(f (3)

n,n/2) =
n,n/2, where k ≥ n/2,

To consider the case of n being odd, we need the following result.

Theorem 10. For any integer h > 0, QE(f (1)

2h+1,h) ≥ 2.

Proof. The method of proof is similar to that of Theorem 8. Let n = 2h + 1.
Assume that there is an exact quantum 1-query algorithm with U0, Ox and
U1 being the sequence of unitary operators for f (1)
2h+1,h, and with starting
i=0,j=1 αij|ii|ji. When |x| = 0, we have |ψ0i =
j=1 |αij|2. We prove that

state |ψsi. Let U0|ψsi =Pn,m
OxU0|ψsi = Pn,m

i=0,j=1 αij|ii|ji. Denote βi = Pm

β1 = ··· = βn as follows.

28

Given two inputs x and y such that |x| = |y| = h, xk 6= yk, xl 6= yl and

xi = yi for i 6= k, l (in this case xk 6= xl and yk 6= yl ), then we have

0 =(U1|ψ0i)†U1Ox|ψ0i − (U1|ψ0i)†U1Oy|ψ0i
=hψ0|Ox|ψ0i − hψ0|Oy|ψ0i

=
αijhi|hj|
n,mXi=0,j=1
×
n,mXi=1,j=1

(−1)xiαij|ii|ji −

n,mXi=1,j=1

(−1)yi αij|ii|ji

=(−1)xk βk + (−1)xlβl − ((−1)yk βk + (−1)ylβl)
= ((−1)xk − (−1)yk ) (βk − βl) = 2(−1)xk (βk − βl).

(94)

(95)

(96)

(97)

(98)

(99)

(100)

Therefore, β1 = ··· = βn = β for some β.
xj = 0 for h + 1 ≤ j ≤ n. Then we have

In addition, suppose that the input x satisﬁes xi = 1 for 1 ≤ i ≤ h, and

0 =(U1|ψ0i)†U1Ox|ψ0i

=
n,mXi=0,j=1

αijhi|hj|
mXj=1

α0j|0i|ji +

n,mXi=1,j=1

(−1)xiαij|ii|ji (101)

(102)

=β0 + (−1)hβ + (h + 1)β = β0 + β = 0,

but this leads to β0 = ··· = βn = 0 and thus αij = 0 for 0 ≤ i ≤ n and
1 ≤ j ≤ m, which is a contradiction. Hence, QE(f (1)

2h+1,h) ≥ 2.

Since any exact quantum query algorithm being able to compute f (3)

2m+1,m+1 is isomorphic to f (3)

2m+1,m, it follows that QE(f (3)

2m+1,m
2m+1,m) > 1.
2m+1,m. Combining Theorems 7 and

can also compute f (1)
Moreover, f (3)
10 as well as Proposition 1, we have the following result.
Theorem 11. Let n be odd and let f : {0, 1}n → {0, 1} be an n-bit sym-
metrically partial function. Then QE(f ) = 1 if and only if f is isomorphic
to one of the functions f (1)

2m+1,m) ≥ QE(f (1)

n,k, where k ≥ ⌈n/2⌉.

Proof. Suppose that QE(f ) = 1. From Lemma 4 it follows deg(f ) ≤
2QE(f ) = 2. Due to Lemma 10, f is isomorphic to one of these functions:
f (1)
n,n, f (1)
n,1, where n − 1 ≥ k ≥ ⌊n/2⌋, and ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋.

n,k, f (2)

n,k, f (3)

n,l , f (4)

29

By using Proposition 1, QE(f (1)
Next we verify the remainder functions have exact query complexity

n,k) = 1 for n ≥ k ≥ ⌈n/2⌉.

more than 1.

n,k) > 1 for k = ⌊n/2⌋;

Firstly, Theorem 10 shows that QE(f (1)
Secondly, Theorem 8 veriﬁes that QE(f (2)
n,k) > 1 for n − 1 ≥ k ≥ ⌊n/2⌋;
Thirdly, for l = ⌊n/2⌋, since any exact quantum query algorithm being
n,l , it follows that QE(f (3)
n,l can also compute f (1)
n,l ) ≥
n,l ) > 1. Moreover, for l = ⌊n/2⌋, f (3)
n,l+1, so,
n,l+1) = QE(f (3)
Finally, for ⌈n/2⌉ ≥ l ≥ ⌊n/2⌋, any exact quantum query algorithm

able to compute f (3)
QE(f (1)
QE(f (3)

n,l ) ≥ QE(f (1)

is isomorphic to f (3)

n,l ) > 1.

computing f (4)

n,1 can also compute f (3)

n,l , so, QE(f (4)

n,1) ≥ QE(f (3)

n,l ) > 1.

In a word, QE(f ) = 1 implies f is isomorphic to one of the functions

n,l

f (1)
n,k, for k ≥ ⌈n/2⌉.

On the other hand, since QE(f (1)

to one of these functions f (1)

n,k) = 1 for k ≥ ⌈n/2⌉, if f is isomorphic
n,k for k ≥ ⌈n/2⌉, by Fact 1, it holds QE(f ) = 1.

Remark 6. f (3)
n,n/2 is the Deutsch-Jozsa problem. Sometimes we can equiv-
alently transform some problems to the Deutsch-Jozsa problem or its more
special cases by padding some strings. Indeed, if we pad 2k − n zeros to
the input of the function f (1)
2k,k that is
simpler and more special than the Deutsch-Jozsa problem. Therefore we
can use the Deutsch-Jozsa algorithm to solve the problem. That is to say,
an symmetrically partial Boolean function f has QE(f ) = 1 if and only if f
can be computed by the Deutsch-Jozsa algorithm after appropriate padding
of the input.

n,k, then it is equivalently to solve f (1)

Therefore, with Theorems 9 and 11 we are ready to obtain the second

main result of the article:

Theorem 1. Any symmetrically partial Boolean function f has QE(f ) =

1 if and only if f can be computed by the Deutsch-Jozsa algorithm.

Proof. Suppose that QE(f ) = 1. Then according to Theorems 9 and 11 we
have:

(1) for n being odd, f is isomorphic to one of the functions f (1)

n,k, where

k ≥ ⌈n/2⌉;

(2) for n being even, f is isomorphic to one of these functions: f (1)

n,k and

f (3)
n,n/2, where k ≥ n/2.

30

If f is isomorphic to f (1)

n,k, then we pad 2k − n zeros to the input of the
n,k. As a result, it is equivalently to compute the function f (1)
2k,k.
2k,k is a more special problem than Deutsch-Jozsa problem, and

function f (1)
Clearly f (1)
therefore it can also be computed by the Deutsch-Jozsa algorithm.

If f is isomorphic to f (3)

n,n/2 (n being even), then it is just the Deutsch-

Jozsa problem.

Consequently, QE(f ) = 1 implies that f can always be computed by the

Deutsch-Jozsa algorithm.

On the other hand, if f can be computed by the Deutsch-Jozsa algorithm,
then QE(f ) = 1 (here we omit the ordinary case of f being a constant
function, and therefore we always suppose QE(f ) > 0).

Next we further discuss the exact quantum query complexity for the

symmetrically partial Boolean functions with degree 2.

and furthermore QE(f (3)

We have already proved that QE(f (1)
2m+1,m+1) = QE(f (3)
More investigations concerning QE(f (2)

2m+1,m) > 1 and QE(f (2)
2m+1,m) ≥ QE(f (1)
n,k) and QE(f (4)

2m+1,m) > 1.

n ) will be done in

2m+1,m) > 1,

next section. Now we give two optimal algorithms for f (1)
in the following.

2m+1,m and f (3)

2m+1,m+1

Theorem 12. QE(f (1)

2m+1,m) = QE(f (3)

2m+1,l) = 2, where m ≤ l ≤ m + 1.

Proof. Let n = 2m + 1. Let DJ(n, 0, x) be the subroutine to compute the
Deutsch-Jozsa problem. Let DHW(n, k, x) be the subroutine to compute the
function f (1)
n,k, where k ≥ ⌈n/2⌉. As we knew, the exact quantum algorithms
just use 1 query in the above subroutines. We now give an exact quantum
2-query algorithm to compute f (1)

2m+1,m as Algorithm 3.

We give an exact quantum 2-query algorithm to compute f (3)

2m+1,m+1 as

Algorithm 4.

It is clear that the above two algorithms can compute the functions
2m+1,m is

2m+1,m with two queries, respectively. The function f (3)

f (1)
2m+1,m and f (3)
isomorphic to the function f (3)

2m+1,m+1, so it holds that QE(f (3)

2m+1,m) = 2.

Remark 7. From Theorem 12 it follows the optimal exact quantum query
complexity is 2 for solving a variant of the Deutsch-Jozsa problem, i.e. dis-
tinguishes between inputs of Hamming weight in {⌊n/2⌋,⌈n/2⌉} and Ham-
ming weight in {0, n} for all odd n.

31

⊲ x ∈ {0, 1}n

⊲ x ∈ {0, 1}n

Algorithm 3 Algorithm for f (1)

2m+1,m

1: procedure f1(integer n, array x)
2:

Query x1
if x1 = 1 then return 1
end if
if x1 = 0 then
x ← x \ {x1}
return DHW(n − 1,⌊n⌋, x)

3:

4:

5:

6:

7:

end if

8:
9: end procedure

Algorithm 4 Algorithm for f (3)

2m+1,m+1

1: procedure f3(integer n, array x)
2:

Query x1
x ← x \ {x1}
if x1 = 1 then

3:

4:

5:

6:

7:

8:

return DJ(n − 1, 0, x)

end if
if x1 = 0 then

return DHW(n − 1,⌈n⌉, x)

end if

9:
10: end procedure

32

6 Further results

This section ﬁrst studies n-bit symmetrically partial function DWk,l
n :

DWk,l

n (x) =(cid:26) 0 if |x| = k,

1 if |x| = l.

(103)

We will give some optimal exact quantum query algorithms to compute the
function DWk,l
n as
subroutines to give some exact quantum query algorithms to compute the
functions f (2)

n for some special choices of k and l, and then use DWk,l

n,k and f (4)
n .

4m ) = 2.

Theorem 13. QE(DWm,3m
Proof. We give a 2-query exact quantum algorithm to compute DWm,3m
4m as
Algorithm 5, where the subroutine Grover(n, x) is a 1-query Grover search
[33] which returns an index i. We describe Grover(n, x) as follows:
(1) Begin with the quantum state |1i, and a unitary transformation acts
on it, resulting in |ψ0i = W|1i = 1√nPn
(2) Act on the quantum state |ψ0i with the transformation G = −W Z1W †Zf ,

i=1 |ii.

where

Z1|ii =(cid:26) −|ii if i = 1,

|ii if i 6= 1,

and Zf|ii = (−1)xi|ii.

(104)

(3) Measure the quantum state with the projective measurement {|iihi|}n

then returning the measurement result i.

i=1,

Let us consider the quantum state after the transformation G:

|ii

√n

1
√n

|ii!

nXi=1
|ψi = G|ψ0i = −W Z1W †Zf
= −W (I − 2|1ih1|)W †Zf  1
nXi=1
= (2W|1ih1|W † − I)  1
|ii!
nXi=1
|ii!  1
= 2  1
hi|! − I!  1
nXi=1
nXi=1
(−1)xj − (−1)xi|ii.
 2
nXj=1
nXi=1

1
√n

√n

√n

√n

=

n

(105)

(106)

(107)

(108)

(109)

|ii!

nXi=1

√n

33

nPn
j=1(−1)xj = 1 and |ψi = 2√nPi:xi=1 |ii.
When |x| = n/4, we have 2
nPn
j=1(−1)xj = −1 and |ψi = −2√nPi:xi=0 |ii.
When |x| = 3n/4, we have 2
Therefore, after the measurement, the subroutine Grover(n, x) will return
an index i such that xi = 1 if |x| = n/4 and xi = 0 if |x| = 3n/4.
Algorithm 5 Algorithm for DWm,3m
1: procedure DW1(integer n, array x)
2:

⊲ x ∈ {0, 1}n

4m

3:

i ← Grover(n, x)
Query xi
return 1 − xi.
4:
5: end procedure

4m with 2 queries and thus QE(DWm,3m

According to the above analysis, it is clear that Algorithm 5 computes
the function DWm,3m
4m ) ≤ 2. We now
prove QE(DWm,3m
4m ) ≥ 2 as follows. We note that the function DWm,3m
is not isomorphic to any function pointed out in Theorem 7. Therefore,
we have deg(DWm,3m
4m ) > 1 as well. Therefore,
QE(DWm,3m

4m ) > 2 and QE(DWm,3m

4m ) = 2.

4m

Using the padding method (similar method used in [13]), we have

Corollary 1. For any integers n and k such that 0 < k < n/3, l ≥
max{(2n + k)/3, 3k} and l − k is even, then QE(DWk,l
Proof. By padding (3l − k)/2 − n zeroes and (l − 3k)/2 ones to the inputs
of the function DWk,l
n , we have the new n′ = n + (3l − k)/2 − n + (l −
3k)/2 = 2(l − k). The new k′ = k + (l − 3k)/2 = (l − k)/2 and the new
l′ = l + (l − 3k)/2 = 3(l − k)/2. Therefore, the new function is DWn′/4,3n′/4
and, from Theorem 13 it follows that QE(DWk,l

n ) = 2.

n ) = 2.

n′

Let k ≤ n/4. Then max{(2n + k)/3, 3k} = 3n/4. We have the following

result.

Corollary 2. For any integers n and k such that 0 < k ≤ n/4, 3n/4 ≤ l < n
and l − k is even, then QE(DWk,l

n ) = 2.

The next theorem is implicit in the combination of the proof in [13] and

Theorem 7.

Theorem 14. For any integers n and l such that n
QE(DW0,l

n ) = 2.

4 ≤ l < ⌊ n

2⌋, then

34

Proof. Padding (4l−n) zeros to the input, we have n′ = n+4l−n = 4l. The
function changes to DW0,l
4l . We give an exact quantum 2-query algorithm to
compute DW0,l
4l as Algorithm 6. Similar to the analysis in Theorem 13, it is

Algorithm 6 Algorithm for DW0,l
4l

1: procedure DW2(integer n, array x)
2:

3:

i ← Grover(n, x)
Query xi
return xi.

4:
5: end procedure

⊲ x ∈ {0, 1}n

clear that Algorithm 6 computes DW0,l
for n
4 ≤ l < ⌊ n
n

n ) ≤ 2
2⌋. According to Theorem 7, we have deg(DW0,l
n ) > 2 for
4 ≤ l < ⌊ n
2⌋.

2⌋. Therefore, we have QE(DW0,l

4l . Therefore, we have QE(DW0,l

n ) ≥ 2 for n

4 ≤ l < ⌊ n

Now we use DWk,l

n as subroutines to give some algorithms for the func-

tions that we discussed in Section 4.

Theorem 15. For n/4 ≤ k < n, QE(f (2)
n,k(x) =(cid:26) 0 if |x| = 0,

f (2)

1 if |x| = k or |x| = k + 1.

n,k) ≤ 4, where

(110)

Proof. We give an exact quantum 4-query algorithm for the function as
Algorithm 7.

It is clear that Algorithm 7 can computes the function f (2)
n,k.

Theorem 16. For any odd n, QE(f (4)

n ) ≤ 5, where

f (4)

n (x) =(cid:26) 0 if |x| = 0 or |x| = n,

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉.

(111)

Proof. We give a 5-query exact quantum algorithm for the function as Al-
gorithm 8.

If x1 = 1, then the function reduces to the following function:

f (4)

n−1,1(x) =(cid:26) 0 if |x| = n − 1,

1 if |x| = ⌊n/2⌋ − 1 or |x| = ⌈n/2⌉ − 1,

(112)

which is isomorphic to f (2)
the function f (4)
n .

n−1,⌊n/2⌋

. It is clear that Algorithm 8 can compute

35

Algorithm 7 Algorithm for f (2)
n,k

1: procedure f2(integer n, integer k, array x)
2:

Pad 4k − n zeros to the input x and get a new input y.
i ← Grover(4k, y)
Query xi
if xi = 1 then

return 1

⊲ x ∈ {0, 1}n

end if
Pad 4(k + 1) − n zeros to the input x and get a new input y.
i ← Grover(4(k + 1), y)
Query xi
return xi

11:
12: end procedure

⊲ x ∈ {0, 1}n

3:

4:

5:

6:

7:

8:

9:

10:

3:

4:

5:

6:

7:

8:

9:

Algorithm 8 Algorithm for f (4)
n
1: procedure f4(integer n, array x)
2:

Query x1
x ← x \ {x1}
if x1 = 0 then

return F2(n − 1,⌊n⌋, x)

end if
if x1 = 1 then

Let the new input y = x
return F2(n − 1,⌊n⌋, y)

end if

10:
11: end procedure

36

7 Conclusion and problems

Symmetric Boolean functions are important in cryptography and property
testing ([22, 17]) due to their characters (for example, their outputs only
depend on the Hamming weights of their inputs). Symmetrically partial
Boolean functions are symmetric but their domains of deﬁnition are allowed
to be partial, so they also belong to the promise problems [27, 30], for exam-
ple, the Deutsch-Jozsa problem as a typical promise problem can be repre-
sented by an symmetrically partial Boolean function. In this article, we have
proved the exact quantum query complexity for a generalized Deutsch-Jozsa
problem, and presented a method for determining the degree of symmetri-
cally partial Boolean functions. Also, in the sense of isomorphism, we have
given all symmetrically partial Boolean functions with degree 1 or 2 and
with exact quantum 1-query complexity, and discovered that all symmet-
rically partial Boolean functions having exact quantum 1-query complexity
can be computed by the Deutsch-Jozsa algorithm.

Our results have done only the ﬁrst step for studying the exact quan-
tum query complexity of symmetrically partial Boolean functions. A nat-
ural problem for further study is to characterize the symmetrically partial
Boolean functions by exact quantum (k + 1)-query complexity for k ≥ 0. It
can be described more precisely in the following.
Let f : {0, 1}n → {0, 1} be an n-bit symmetrically partial Boolean
function with domain of deﬁnition D, and let 0 ≤ k < ⌊n/2⌋. Then, for
2k + 1 ≤ deg(f ) ≤ 2(k + 1), how to characterize f by giving all functions
with degrees from 2k + 1 to 2k + 2? A possible conjecture by means of
generalization is that f may be isomorphic to one of the following functions:

f (1),k

f (2),k

f (3),k
n,l

f (4),k
n

1 if |x| = m,

n,m (x) =(cid:26) 0 if |x| ≤ k,
n,m (x) =(cid:26) 0 if |x| ≤ k,
(x) =(cid:26) 0 if |x| ≤ k or |x| ≥ n − k,
(x) =(cid:26) 0 if |x| ≤ k or |x| ≥ n − k,

1 if |x| = m or |x| = m + 1,

1 if |x| = l,

1 if |x| = ⌊n/2⌋ or |x| = ⌈n/2⌉,

(113)

(114)

(115)

(116)

where m ≥ ⌊n/2⌋ and ⌊n/2⌋ ≤ l ≤ ⌈n/2⌉.
Moreover, how to characterize the symmetrically partial Boolean func-
tion f in terms of its exact quantum (k + 1)-query complexity? Can any
symmetrically partial Boolean function f with exact quantum (k + 1)-query

37

complexity be computed by the presented exact quantum (k + 1)-query al-
gorithm for computing the generalized Deutsch-Jozsa problem DJ k
n ?

Related are another two questions:

1. We have showed that 2 ≤ QE(f (2)

n,k) ≤ 4 for n/4 ≤ k < n and 2 ≤

QE(f (4)

n ) ≤ 5. How to determine QE(f (2)

n,k) and QE(f (4)

n )?

2. For the function DWk,l

n , we have given some optimal exact quantum
query algorithms for some special choices of k and l. Can we give
optimal exact quantum query algorithms for any k and l?

Acknowledgements

We thank Lvzhou Li for much essential discussions on query complexity
and this article. This work was supported by the National Natural Science
Foundation of China (Nos. 61572532, 61272058, 61472452).

References

[1] A. Ambainis, A note on quantum black-box complexity of almost
all Boolean functions, Information Processing Letters, 71 (1999),
pp. 5-7. Also, quant-ph/9811080.

[2] A. Ambainis, Quantum walk algorithm for element distinctness,
SIAM J. Comput., 37(2007), pp. 201–239. Earlier version in
FOCS’04. Also quant-ph/0311001.

[3] A. Ambainis, Superlinear advantage for exact quantum algorithms,
in Proceedings of the 45th ACM Symposium on Theory of Com-
puting, ACM, New York, 2013, pp. 891–900.

[4] S. Aaronson, A. Ambainis, J. Iraids, and M. Kokainis, Polynomials,
Quantum Query Complexity, and Grothendieck’s Inequality, 2015,
arXiv:1511.08682.

[5] A. Ambainis, J. Gruska, and S.G. Zheng, Exact quantum algo-
rithms have advantage for almost all Boolean functions, Quan-
tum Information and Computation, 15 (2015), pp. 0435–0452. Also
arXiv:1404.1684.

[6] A. Ambainis, A. Iraids, and J. Smotrovs, Exact quantum query
complexity of EXACT and THRESHOLD, in Proceedings of The

38

8th Conference on the Theory of Quantum Computation, Commu-
nication and Cryptography, Guelph, Canada, 2013, pp. 263–269.
Also arXiv:1302.1235.

[7] A. Ambainis and A. Yakaryilmaz, Superiority of exact quantum au-
tomata for one promise problems, Information Processing Letters,
112 (2012), pp. 289-291.

[8] A. Belovs, Span programs for functions with constant-sized 1-
certiﬁcates, In Proceedings of the forty-third annual ACM sympo-
sium on Theory of computing, ACM, New York, 2011, pp. 77–84.
Also arXiv:1105.4024.

[9] D. Bera, A Diﬀerent Deutsch-Jozsa, Quantum Information Pro-

cessing, 14 (2015), pp. 1777-1785.

[10] R. Beals, H. Buhrman, R. Cleve, M. Mosca, and R. de Wolf, Quan-
tum lower bounds by polynomials, Journal of the ACM, 48 (2001),
pp. 778–797. Earlier version in FOCS’98. Also arXiv:9802049.

[11] S. Boyd and L. Vandenberghe, Convex optimization, Cambridge

University Press, Cambridge, 2004.

[12] G. Brassard and P. Høyer, An exact quantum polynomial-time al-
gorithm for Simon’s problem, in Proceedings of the Fifth Israeli
Symposium on Theory of Computing and Systems, 1997, pp. 12–
23. Also arXiv:9704027.

[13] J. Bri¨et, H. Buhrman, D. Leung, T. Piovesan, and F. Speelman,
Round elimination in exact communication complexity, In Proceed-
ings of the 10th Conference on the Theory of Quantum Computa-
tion, Communication and Cryptography, Brussels, Belgium, 2015,
Leibniz International Proceedings in Informatics.

[14] H. Buhrman, C. D¨urr, M Heiligman, P. Høyer, F. Magniez, M.
Santha, and R. de Wolf, Quantum Algorithms for Element Dis-
tinctness, in Proceedings of the Sixteenth Annual IEEE Conference
on Computational Complexity, 2001, pp. 131-137.

[15] H. Barnum, M. Saks, and M. Szegedy, Quantum query complexity
and semi-deﬁnite programming, In Proceedings 18th IEEE Annual
Conference on Computational Complexity, 2003, pp. 179-193.

39

[16] H. Buhrman and R. de Wolf, Complexity measures and decision tree
complexity: a survey, Theoretical Computer Science, 288 (2002),
pp. 1–43.

[17] E. Blais, A. Weinstein, and Y. Yoshida, Partially symmetric func-
tions are eﬃciently isomorphism testable, SIAM J. Comput., 44
(2015), pp. 411–432.

[18] A. Childs and W. van Dam, Quantum algorithms for algebraic
problems, Reviews of Mod- ern Physics, 82 (2010), pp. 1-52. Also
arXiv:0812.0380.

[19] R. Cleve, A. Eckert, C. Macchiavello, and M. Mosca, Quantum
algorithms revisited, in Proceedings of the Royal Society of London,
454A (1998), pp. 339–354. Also arXiv:9708016.

[20] D. Collins, K. W. Kim, and W. C. Holton, Deutsch-Jozsa algo-
rithm as a test of quantum computation, Phys. Rev. A, 58 (1998),
R1633–R1636.

[21] D. P. Chi, J. Kim, and S. Lee, Quantum Algorithm for Generalized

Deutsch-Jozsa Problem, 2000, quant-ph/0005059.

[22] A. Canteaut and M.Videau, Symmetric Boolean Functions, IEEE

Transactions on Information Theory, 51 (2005), pp. 2791-2811.

[23] C. D¨urr, M. Heiligman, P. Høyer, and M. Mhalla, Quantum query
com- plexity of some graph problems, in Proceedings of The 31st
International Colloquium on Automata, Languages and Program-
ming, 2004, Lecture Notes in Computer Science, 3142 (2004), pp.
481- 493.

[24] D. Deutsch and R. Jozsa, Rapid solution of problems by quantum
computation, In Proceedings of the Royal Society of London, 439A
(1992), pp. 553–558.

[25] A. Dubrovska and T. Mischenko-Slatenkova, Computing boolean
functions: Exact quantum query algorithms and low degree polyno-
mials, 2006, quant-ph/0607022

[26] S. D¨orn, and T. Thierauf, The Quantum Query Complexity of Al-

gebraic Properties, 2007, arXiv:0705.1446.

40

[27] S. Even, A.L. Selman, and Y. Yacobi, The Complexity of Promise
Problems with Applications to Public-Key Cryptography, Informa-
tion and Control, 61 (1984), pp. 159–173.

[28] E. Farhi, J. Goldstone, and S. Gutman, A Quantum Algorithm for
the Hamil- tonian NAND Tree, Theory of Computing, 4 (2008),
pp. 169-190. Also quant- ph/0702144.

[29] E. Farhi, J. Goldstone, S. Gutmann, and M. Sipser, A limit on
the speed of quantum computation in determining parity, Physical
Review Letters, 81 (1998), pp. 5442–5444. Also arXiv:9802045.

[30] O. Goldreich, On promise problems: A survey, Shimon Even
Festschrift, Lecture Notes in Computer Science, 3895 (2006), pp.
254–290.

[31] J. Gruska, D.W. Qiu, and S.G. Zheng, Potential of quantum ﬁnite
automata with exact acceptance, International Journal of Founda-
tion of Computer Science, 26 (2015), pp. 381-398.

[32] J. von zur Gathen and J. R. Roche, Polynomials with two values,

Combinatorica, 17 (1997), pp. 345–362.

[33] L. K. Grover, A fast quantum mechanical algorithm for database
search, In Proceedings of the twenty-eighth annual ACM sympo-
sium on Theory of computing, ACM, New York, 1996, pp. 212–219.

[34] J. Gruska, D.W. Qiu, and S.G. Zheng, Generalizations of the dis-
tributed Deutsch-Jozsa promise problem, Mathematical Structures
in Computer Science, 2015, doi:10.1017/S0960129515000158. Also
arXiv:1402.7254.

[35] T. Hayes, S. Kutin, and D. van Melkebeek, The quantum black-box
complexity of majority, Algorithmica, 34 (2002), pp. 480-501. Also
quant-ph/0109101.

[36] P. Høyer and R. ˘Spalek, Lower bounds on quantum query complex-
ity, Bulletin of the European Association for Theoretical Computer
Science, 87 (2005), pp. 78-103. Also quant-ph/0509153.

[37] G. Midrij¯anis, Exact quantum query complexity for total Boolean

functions, 2004, quant-ph/ 0403168.

41

[38] A. Montanaro, R. Jozsa and G. Mitchison, On exact quantum
query complexity, Algorithmica, 419 (2015), pp. 775–796. Also
arXiv:1111.0475.

[39] M. Minsky and S. Papert, Perceptrons, 2nd expanded ed., MIT

Press, Cambridge, MA, 1988.

[40] M. Nielsen and I. Chuang, Quantum Computation and Quantum

Information, Cambridge University Press, Cambridge, 2000.

[41] N. Nisan and M. Szegedy, On the degree of Boolean functions as
real polynomials, Computational Complexity, 4 (1994), pp. 301–
313. Earlier version in STOC’92.

[42] B. Perez-Garciaa, M. McLarenb, S. K. Goyalc, R. I. Hernandez-
Arandaa, A. Forbesb, and T. Konradc, Quantum computation with
classical
implementation of the Deutsch-Jozsa Algorithm,
2015, arXiv:1510.03365.

light:

[43] B. Reichardt, R. ˘Spalek, Span-program-based quantum algorithm
for evaluating formulas, in Proceedings of the fortieth annual ACM
symposium on Theory of computing, ACM, New York, 2008, pp.
103-112. Also arXiv:0710.2630.

[44] P.W. Shor, Polynomial-time algorithms for prime factorization and
discrete logarithms on a quantum computer, SIAM J. Comput., 26
(1997), pp. 1484–509. Earlier version presented at FOCS’94. Also
quant-ph/9508027.

[45] D.R. Simon, On the power of quantum computation, SIAM J. Com-

put., 26 (1997), pp. 1474–1483. Earlier version in FOCS’94.

[46] T. Mischenko-Slatenkova, A. Vasilieva, I. Kucevalovs, and R.
Freivalds, Quantum Queries on Permutations, Lecture Notes in
Computer Science, 9118 (2015), pp. 177-184.

[47] S.G. Zheng and D.W. Qiu, From quantum query complexity to state
complexity, Gruska Festschrift, Lecture Notes in Computer Science,
8808 (2014), pp. 231–245. Also arXiv:1407.7342.

Appendix A: The subroutine for Xquery

The subroutine will use basis state |0, 0i, |i, 0i and |i, ji with 1 ≤ i < j ≤ m.

42

1. The subroutine Xquery begins in the state |0, 0i and then a unitary

mapping U1 is applied on it:

U1|0, 0i =

1
√m|i, 0i.

mXi=1

2. The subroutine Xquery then performs the query:

mXi=1

1
√m|i, 0i →

mXi=1

1
√m

(−1)xi|i, 0i.

(117)

(118)

3. The subroutine Xquery performs a unitary mapping U2 to the current

state such that

U2|i, 0i =Xj>i

1

√m|i, ji −Xj<i

1
√m|j, ii +

1
√m|0, 0i

(119)

and the resulting quantum state will be

U2

=

1
m

1
√m

(−1)xi|i, 0i
1

mXi=1
nXi=1
(−1)xi|0, 0i +

m X1≤i<j

((−1)xi − (−1)xj )|i, ji.

(120)

4. The subroutine Xquery measures the resulting state in the standard
i=1(−1)xi 6= 0 and |x| 6= m/2.
Otherwise, suppose that we get the state |i, ji. Then we have xi 6= xj
and the subroutine outputs (i, j).

basis. If the outcome is |0, 0i, then Pm

Appendix B: Proof of Equality (29)

l(cid:1) = 0 if l < 0. For any integers
l(cid:1) =(cid:0) p
p−l(cid:1). Now we prove that for any integers
l(cid:19) = (l + 1)(cid:18)p + 1
l + 1(cid:19).

(121)

p and l,

Proof. We deﬁne(cid:0)p
l(cid:1) = 0 if p < l and also(cid:0)p
p and l, it is easy to see that(cid:0)p
(p + 1)(cid:18)p
l(cid:1) = 0 and(cid:0)p+1

Case 1 p < l. In this case,(cid:0)p

There are several cases as follows:

l+1(cid:1), the equality holds.

43

(l + 1)(cid:0)p+1
l+1(cid:1).

l(cid:1) = (p+1)
Case 2 p ≥ l ≥ 0. In this case, (p+1)(cid:0)p
Case 3 p ≥ l and l < −1. In this case, (cid:0)p+1
Case 4 p ≥ l and l = −1. In this case, (cid:0)p

equality holds.

holds.

l+1(cid:1) = 0 and (cid:0)p
l(cid:1) = 0 and (l + 1)(cid:0)p+1

l(cid:1) = 0, the equality
l+1(cid:1) = 0, the

p!

l!(p−l)! = (l+1)

(p+1)!

(l+1)!((p+1)−(l+1))! =

Therefore, the equality holds.

Now we are ready to prove Equality (29).

...

...

...

...

...

n

...

n

...

n

...

1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

···
···
. . .

···
···
. . .
···
···

(cid:0) n
k+2(cid:1)
(cid:0) n
k+1(cid:1)
k+2(cid:1)
(cid:0)n−1
k+1(cid:1)
(cid:0)n−1
k+2 (cid:1)
(cid:0)n−k+1
k+1 (cid:1)
(cid:0)n−k+1
k+2(cid:1)
(cid:0)n−k
k+1(cid:1)
(cid:0)n−k
n−k−2(cid:1)
(cid:0)
n−k−1(cid:1)
(cid:0)
(cid:0) n−1
n−k−3(cid:1)
(cid:0) n−1
n−k−2(cid:1)
n−2k−1(cid:1) ···
(cid:0) n−k+1
n−2k(cid:1)
(cid:0)n−k+1
n−2k−2(cid:1) ···
(cid:0) n−k
n−2k−1(cid:1) (cid:0) n−k
(n − k + 1)×
n−k−1(cid:1)
(cid:0)
(cid:0) n−1
n−k−2(cid:1)
n−2k(cid:1)
(cid:0)n−k+1
(n − k + 1)(cid:0) n−k
(n − k + 1)×
(cid:0)
n−k−1(cid:1)
(cid:0) n−1
n−k−2(cid:1)
(cid:0)n−k+1
n−2k(cid:1)

(cid:0) n
2k+1(cid:1)
(cid:0) n
2k(cid:1)
2k+1(cid:1)
(cid:0) n−1
2k(cid:1)
(cid:0)n−1
2k+1(cid:1)
(cid:0)n−k+1
2k (cid:1)
(cid:0)n−k+1
2k+1(cid:1)
(cid:0) n−k
2k(cid:1)
(cid:0)n−k
n−2k−1(cid:1)
n−2k(cid:1)
(cid:0)
(cid:0) n
(cid:0) n−1
(cid:0) n−1
n−2k−1(cid:1)
n−2k−2(cid:1)
n−3k(cid:1)
n−3k−1(cid:1)
(cid:0)n−k+1
(cid:0) n−k+1
(cid:0) n−k
(cid:0) n−k
n−3k(cid:1)
n−3k−1(cid:1)
n−k−2(cid:1)
(cid:0)
(cid:0) n−1
n−k−3(cid:1)
n−2k−1(cid:1)
(cid:0) n−k+1
n−2k−1(cid:1) (n − k + 1)(cid:0) n−k
n−2k−2(cid:1)
(cid:0)
n−k−2(cid:1)
(cid:0) n−1
n−k−3(cid:1)
(cid:0) n−k+1
n−2k−1(cid:1)

···
···
. . .
···
···

(n − 2k − 2)(cid:0) n−k+1

n−2k−1(cid:1) ···

(n − 2k − 1)(cid:0)n−k+1
n−2k(cid:1)

···
···
. . .
···

1

...

n

...

n

...

n

...

n

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

=

=

=

44

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

n

...

...

n−2k(cid:1)
(cid:0) n
(cid:0) n−1
n−2k−1(cid:1)
n−3k−1(cid:1)
(cid:0) n−k+1
(n − k + 1)(cid:0) n−k
n−3k(cid:1)
(cid:0) n
n−2k(cid:1)
(cid:0) n−1
n−2k−1(cid:1)
n−3k−1(cid:1)
(cid:0) n−k+1
n−3k−1(cid:1) (n − 3k − 1)(cid:0)n−k+1
(n − 3k)(cid:0) n−k+1
n−3k(cid:1)

n−2k−1(cid:1)
(cid:0)
(cid:0) n−1
n−2k−2(cid:1)
n−3k(cid:1)
(cid:0)n−k+1
(n − k + 1)(cid:0) n−k
n−3k−1(cid:1)
n−2k−1(cid:1)
(cid:0)
(cid:0) n−1
n−2k−2(cid:1)
(cid:0)n−k+1
n−3k(cid:1)

(122)

...

...

n

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

rk+1−(n−3k−1)rk
=============

1

(n − k + 1)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

···===

1

(n − k + 1)(n − k + 2)··· n

=

k(k − 1)··· 1

(n − k + 1)(n − k + 2)··· n

1

1

n

n

n

n

n

n

...

...

1

=

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

k−1(cid:0)
n−k−2(cid:1)
k(cid:0)
n−k−1(cid:1)
n−k−2(cid:1)
(cid:0)
n−k−1(cid:1)
(cid:0)
k(cid:1)
(cid:0)n
n−2k(cid:1)
(cid:0)n−k+2
n−2k+1(cid:1)
(cid:0) n−k+2
n−2k−1(cid:1)
(cid:0) n−k+1
n−2k(cid:1)
(cid:0)n−k+1
n−k−1(cid:1)
(cid:0)
n−2k−1(cid:1)
= (−1)k+2 ·(cid:0)
k(cid:1)
(cid:0)n
n−2k+1(cid:1)
(cid:0) n−k+2
(cid:0)n−k+1
n−2k(cid:1)
···=== (−1)k+2(−1)k+1 ··· (−1)3(cid:0)
i(cid:1)
i=k+1(cid:0)n
·Q2k+1
i(cid:1) 6= 0.
i=1(cid:0)n
Qk

= (−1)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

k(k+5)

...

2

n

n

...

...

...

0

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

···
···
. . .
···
···

n−2k−1(cid:1)
n−2k(cid:1)
(cid:0)
(cid:0) n
n−2k−1(cid:1) (cid:0) n−1
(cid:0) n−1
n−2k−2(cid:1)
(cid:0)n−k+1
(cid:0) n−k+1
n−3k−1(cid:1)
n−3k(cid:1)
(cid:0) n−k+1
n−3k−1(cid:1)
(cid:0) n
n−2k−1(cid:1)
(cid:0)
n−2k(cid:1)
n−2k(cid:1)
(cid:0) n
(cid:0)n−k+2
n−3k(cid:1)
(cid:0) n−k+1
n−3k−1(cid:1)
n−2k−1(cid:1)
(cid:0)
n−2k(cid:1)
1(cid:0) n
n−2k(cid:1)
(cid:0) n
(cid:0)n−k+2
n−3k(cid:1)
n−3k−1(cid:1)
(cid:0) n−k+1

0
...
0
0

0
...
0
0

n

1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

1

1

n

n

n

n

n

n

n

n

n

n

...

...

...

...

...

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

···
···
. . .
···

n−k−2(cid:1)
n−k−1(cid:1)
(cid:0)
(cid:0)
(cid:0) n−1
n−k−2(cid:1)
(cid:0) n−1
n−k−3(cid:1)
(cid:0)n−k+1
n−2k(cid:1)
(cid:0) n−k+1
n−2k−1(cid:1)
k(cid:0)n−k+1
n−2k(cid:1)
(k − 1)(cid:0) n−k+1
n−2k−1(cid:1) ···
n−k−1(cid:1)
(cid:0)
n−k−2(cid:1)
(cid:0)
n−k−2(cid:1)
n−k−1(cid:1)
(k − 1)(cid:0)
k(cid:0)
k(cid:0) n−k+2
n−2k+1(cid:1)
(k − 1)(cid:0)n−k+2
n−2k(cid:1)
k(cid:0)n−k+1
n−2k(cid:1)
(k − 1)(cid:0) n−k+1
n−2k−1(cid:1)
n−k−1(cid:1)
n−k−2(cid:1)
k(cid:0)
k−1(cid:0)
n−k−2(cid:1)
n−k−1(cid:1)
(cid:0)
(cid:0)
n−2k(cid:1)
(cid:0)n−k+2
(cid:0) n−k+2
n−2k+1(cid:1)
n−2k−1(cid:1)
n−2k(cid:1)
(cid:0) n−k+1
(cid:0)n−k+1
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
1(cid:0) n
n−2k(cid:1)
(cid:0)
n−2k−1(cid:1)
n−2k(cid:1)
(cid:0) n
n−3k(cid:1)
(cid:0)n−k+2
n−3k−1(cid:1)
(cid:0) n−k+1
n−2k(cid:1)
n−k−2(cid:1)
(cid:0) n
(cid:0)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
n−3k(cid:1)
n−2k(cid:1)
(cid:0)n−k+2
(cid:0)n−k+2
(cid:0) n−k+1
n−2k−1(cid:1)
(cid:0) n−k+1
n−3k−1(cid:1)
n−2k−1(cid:1)(cid:0) n
n−2k(cid:1)···(cid:0)
n−k−2(cid:1)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:18)
n − k − 1(cid:19)(cid:12)(cid:12)(cid:12)(cid:12)
k−1(cid:1)···(cid:0)n
k(cid:1)(cid:0) n
(cid:0)n
1(cid:1)

···
···
. . .
···
···

···
···
. . .
···
···

···
. . .
···
···

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

0
...
0
0

n

...

...

...

...

...

n

n

n

1

n

45

