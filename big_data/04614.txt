Scalable Image Retrieval by Sparse Product Quantization

Qingqun Ning, Jianke Zhu, Member, IEEE, Zhiyuan Zhong,

Steven C.H. Hoi, Senior Member, IEEE, Chun Chen, Member, IEEE,

1

6
1
0
2

 
r
a

 

M
5
1

 
 
]

V
C
.
s
c
[
 
 

1
v
4
1
6
4
0

.

3
0
6
1
:
v
i
X
r
a

Fast Approximate Nearest Neighbor (ANN) search technique
for high-dimensional feature indexing and retrieval is the crux
of large-scale image retrieval. A recent promising technique is
Product Quantization, which attempts to index high-dimensional
image features by decomposing the feature space into a Cartesian
product of low dimensional subspaces and quantizing each of
them separately. Despite the promising results reported, their
quantization approach follows the typical hard assignment of
traditional quantization methods, which may result in large
quantization errors and thus inferior search performance. Unlike
the existing approaches,
in this paper, we propose a novel
approach called Sparse Product Quantization (SPQ) to encoding
the high-dimensional feature vectors into sparse representation.
We optimize the sparse representations of the feature vectors
by minimizing their quantization errors, making the resulting
representation is essentially close to the original data in practice.
Experiments show that the proposed SPQ technique is not only
able to compress data, but also an effective encoding technique.
We obtain state-of-the-art results for ANN search on four public
image datasets and the promising results of content-based image
retrieval further validate the efﬁcacy of our proposed method.

Index Terms—Approximate Nearest Neighbor Search, Sparse

Representation, Product Quantization, Image Retrieval

I. INTRODUCTION

I MAGE retrieval is an important technique for many mul-

timedia applications, such as face retrieval [19], object
retrieval [7], and landmark identiﬁcation [6]. For large-scale
image retrieval tasks, one of the key components is an effective
indexing method for similarity search [47], [5], particularly on
high-dimensional feature space [24], [48], [36], [42]. Similar-
ity search, a.k.a., nearest neighbor (NN) search, is a funda-
mental problem. Due to the curse of dimensionality, exact NN
search for high-dimensional data is extremely challenging and
expensive. To overcome the issue, extensive research efforts
have been devoted to approximate nearest neighbor (ANN)
search methods, such as hashing [46], [22], [8], tree-based
methods [39], [27], [28], and vector quantization [13], [15],
which attempt to ﬁnd the nearest neighbor with high proba-
bility using much less searching time and memory cost.

In this paper, we focus on developing a vector quantiza-
tion (VQ) method for similarity search, which is a typical
approach to effectively encoding the data for ANN search. A
codebook is learnt and every feature vector in the database
can be represented by one of the most similar vectors in the

Qingqun Ning, Jianke Zhu, Zhiyuan Zhong and Chun Chen are with the
College of Computer Science, Zhejiang University, Hangzhou, China, 310027.
E-mail: {ningqingqun,jkzhu,zyzhong,chenc}@zju.edu.cn.

Steven C.H. Hoi is with School of Information Systems, Singapore Man-

agement University, Singapore.
E-mail: chhoi@smu.edu.sg

Jianke Zhu is the Corresponding Author.

Fig. 1. The system view of Sparse Product Quantization for ANN search.

codebook, typically named as “codeword”. Then VQ directly
employs the index of the codeword to represent the original
data vector, which typically has only a few bits. In addition,
the similarity between query and the data vector in database
can be approximated by calculating the distance between query
and codebook vector. This greatly reduces the computational
cost and searching time.

In general, VQ requires more bits in order to reduce
quantization distortion. Since the size of codebook increases
exponentially with respect to the total number of encoded
bits, VQ-based method is ineffective for the data with high
dimensionality. To tackle this issue, Product Quantization
(PQ) [15] has recently been shown a promising paradigm
for efﬁciently indexing the high-dimensional image features.
Different from other Hashing-based methods, it decomposes
the high-dimensional space into a Cartesian product of low
dimensional subspaces and quantize each of them separately.
Since the dimensionality of each subspace is relatively small,
using a small-sized codebook is sufﬁcient to obtain the satis-
ﬁed searching performance.

Although computational cost can be effectively reduced by
diving the long vector into small segments, PQ may fail to
retrieve the exact nearest neighbor of a query with high prob-
ability due to the high quantization distortion. As discussed
in [10], this will eventually yield lower search accuracy com-
pared to VQ. To deal with this problem, several remedies have
recently been proposed. Gong and Lazebnik [12] presented an
iterative quantization approach which maps data onto binary
codes for fast retrieval. Cartesian K-means [31] and Optimized
Product Quantization [9] share the same idea of rotating
the original data to minimize the quantization error. These
methods including PQ essentially follow the same framework

of vector quantization, which all suffer from the inevitable
nontrivial quantization distortion.

To address the above limitations, in this paper, we propose
a novel approach called Sparse Product Quantization (SPQ) to
encoding the high-dimensional vector of image features, where
the sparse coding technique is introduced into approximate
nearest neighbor search. Motivated by soft assignment [35],
we intend to ﬁnd the sparse representation for each segment
of feature vector rather than hard assignment used in PQ.
Speciﬁcally, a feature vector is decomposed into Cartesian
product of the low dimensional subspaces, where the short
vector in each subspace is approximated by the linear combi-
nation of several vectors from the codebook. Fig. 1 illustrates
the overview of SPQ for ANN search. We formulate the
encoding stage as a sparse optimization problem and solve
it by employing a popular greedy algorithm. The Euclidean
distance between two vectors can be efﬁciently estimated from
their sparse product quantization through simple table lookups.
Moreover, the proposed method is able to take advantage of the
very efﬁcient SSE implementation using SIMD instructions,
which can greatly reduce the computational overhead. Thus,
the computational time of our presented method is comparable
to the PQ method’s while the precision of SPQ outperforms
that of PQ at a very large margin. In contrast to the compu-
tationally intensive clustering algorithm used in all the VQ-
based paradigms, we employ the sparse structure along with
the fast stochastic online algorithm [25], [26] to efﬁciently
generate the codebook, which optimizes the sparse represen-
tation of data vectors according to their quantization errors.
Consequently, the proposed representation is essentially close
to the original data in practice even with a few basics. The
empirical evaluation demonstrates that the presented method
yields state-of-the-art ANN search results and outperforms the
popular approaches on the application of image retrieval.

The rest of this paper is organized as follows. Section 2
reviews related work. Section 3 introduces basics of VQ and
propose our sparse vector quantization. Section 4 presents
the proposed sparse product quantization for ANN search.
Section 5 discusses our experimental results in detail and
ﬁnally Section 6 concludes this work.

II. RELATED WORK

Fast NN search is a fundamental research topic which is ex-
tensively studied in literature such as multimedia application,
image classiﬁcation, and machine learning. Our work is related
to approximate NN search methods, which can be roughly
grouped into three categories: Hashing-based methods [46],
[4], [44], KD-tree [3], and Vector Quantization work [15], [9].
Hashing-based ANN search approach has received lots of
attention. Most of them employ either random projection
or the learning-based methods to generate compact binary
codes. As a consequence, the similarity between two data
vectors is approximately represented by the Hamming distance
of their hashed codes. Random projection is an effective
approach which preserves pairwise distances for data points.
The most representative example is Locality Sensitive Hash-
ing (LSH) [8], [38]. According to the Jonson Lindenstrauss

2

Theorem [17], LSH needs O(ln n/ǫ2) random projections to
preserve the pairwise distances, where ǫ is the relative error.
Hence, LSH needs to employ the code with long bit length in
order to boost the projection performance, which leads to both
high computational cost and huge storage requirement. On the
other hand, learning-based hashing methods [46], [4], [44] try
to learn the structure of input data. Most of these algorithms
generate the binary codes by employing the spectral properties
of the data afﬁnity matrix, i.e., item-item similarity. Some
other hashing methods also employ multi-modal data [47] or
semantic information [22]. Despite achieving promising gain
with relatively short codes, these methods often fail to make
signiﬁcant improvement as code length increases [18].

The second group of research aims at speeding up the ANN
search with KD-tree [3]. The expected complexity of KD-tree
search is O(D log n), while the brute-force search is O(nD).
Unfortunately, for high dimension data KD-tree are not much
more efﬁcient than the brute-force exhaustive search [45] due
to the curse of dimensionality. Nevertheless, both randomized
KD-trees [40], [21] and hierarchical K-means [29] improve
the performance of KD-tree. In particular, these two methods
are included in FLANN [27], [28], which automatically selects
the best algorithm and optimal parameters depending on the
dataset. FLANN is much faster than other publicly available
ANN search software. However, KD-tree approaches need
fully access to the data and thus cost much more memory
in searching stage.

The third group of related work is about Vector Quantization
based approaches, which try to approximate data vectors with
codewords in the codebook. J´egou et al. [15] proposed an
efﬁcient product quantization (PQ) recently. The key of PQ
is to decompose the feature space into a Cartesian product of
low dimensional subspaces and quantize each one separately
using their corresponding predeﬁned codebook. Then,
the
distance between the query and a vector in gallery set can be
computed by either symmetric distance computation (SDC) or
asymmetric distance computation (ADC). Also, the inverted
ﬁle system is employed to conduct non-exhaustive search
efﬁciently. Empirically, PQ has been shown to signiﬁcantly
outperform various hashing-based methods in terms of ac-
curacy. As discussed in [15],
the prior knowledge on the
underlying structures of input data is essential to VQ. Most
recently, Ge et. al [9] consider PQ as an optimization problem
that minimizes the quantization distortions by searching for
the optimal codebooks and space decomposition. Due to the
inherent nature of VQ [13],
is hard for these methods
to evaluate the impact of quantization error on the ANN
search performance. We should mention that a work called
Product Sparse Coding [11] was published recently. However,
it substantially differs from our work as it brings a strategy for
sparse coding, though we both have relationship with product
method and sparse coding.

it

Finally, our work is closely related to soft-assignment [35],
which has been introduced into the context of object re-
trieval [34] in order to reduce the quantization error. The key
idea of soft-assignment is to map the original high-dimensional
descriptor to a weighted combination of multiple visual words
rather than hard-assigned onto a single word as in previous

3

35

30

25

20

15

10

5

0

0

x

d3

d1

q(y)

d2

y

5

10

15

20

25

30

35

35

30

25

20

15

10

5

0

0

d1

q(y)

d2

y

x

d3

q(x)

5

10

15

20

25

30

35

(a)

(b)

Fig. 2. 2D toy example of sparse vector quantization. x and y denote query and vector in gallery. q(x) and q(y) represent their quantization vectors. Instead
of using hard assignment by the nearest center, we employ the sparse representation of the codebook with few word. Thus, q(y) is the projection of y on
line spanned by d1 and d2. As d(y, q(y)) ≤ d(y, d2), the distortion of our method is always smaller than VQ’s. (a) Asymmetric Distance Computation
(ADC); and (b) Symmetric Distance Computation (SDC).

work [41], [34]. Still, this representation is just incorporated
into a standard tf-idf architecture. Despite requiring extra
storage and computational cost, soft-assignment always results
in lower quantization distortion and thus yields a signiﬁcant
improvement of retrieval performance in practice.

III. SPARSE VECTOR QUANTIZATION

In this section, we ﬁrst brieﬂy review basics of Vector
Quantization, and then introduce the proposed Sparse Vector
Quantization (SVQ), followed by discussing the codebook
training method for SVQ.

A. Vector Quantization
Vector Quantization (VQ) [13] is a classical technique for
data compression. It divides a dataset into some groups, where
each vector is represented by the centroid of its corresponding
group. More formally, given a vector x ∈ RD, VQ maps x to
the nearest codeword of a pre-trained codebook C = {ci, i =
1, 2, ..., k} as follows:

V Q : x → q(x) = arg min
c∈C

d(x, c).

(1)

where d(·) is a distance metric. In particular, the distance used
in this paper is Euclidean distance: d2(x, c) = kx − ck2.
The encoding map q(·) is called quantizer which is the
most important component of VQ. Therefore, the quantization
distortion or reconstruction error e(x) of x is deﬁned as:

e(x) = d2(x, q(x)) = kx − q(x)k2 = min

c∈C

kx − ck2

(2)

Given the codebook C, the quantization of x is computed by
solving the minimization problem in Eqn. (1). Typically, it can
be simply represented by the Euclidean distance between the
query and its corresponding codeword in C.

In general, there are two kinds of ANN search methods
according to different forms of queries. One is called Sym-
metric Distance Computation (SDC), in which both query
and database vectors are quantized into codes. The other is
called Asymmetric Distance Computation (ADC), where only
the database vectors are quantized.

B. Sparse Vector Quantization

One key limitation of VQ is that it assigns the original vec-
tor to the single nearest codeword in the codebook. This hard
assignment strategy can lead to relatively large quantization
distortion which limits the performance of VQ.

Motivated by the success of soft assignment [35], instead
of using the hard assignment as in VQ, we employ the sparse
representation of multiple codewords to represent the original
feature vector.

Fig. 2 shows a 2D-toy example to illustrate the key idea
of our proposed method. Let x and y denote a query and the
vector in gallery set respectively, and q(x) and q(y) represent
the quantization vector for x and y, respectively. VQ simply
sets q(y) to point d2 by hard assignment, and similarly sets
q(x) to d3. Thus, the quantization distortion for y is d(y, d2).
In this work, we employ the linear combination of two words
d1 and d2 to represent y. Therefore, q(y) is the projection
of y on the line spanned by d1 and d2. It is clear that the
quantization distortion by VQ is always larger than that of the
sparse quantization, since d(y, q(y)) ≤ d(y, d2).

As q(y) lies on the line (d1, d2), we assume y ≈ q(y) =
αd1 + βd2. Note that the coefﬁcients α and β can be easily
computed by solving the linear equation. As illustrated in
Fig. 2, we can compute the distance d(x, y) as follows:

d2(x, y) = kx − yk2

= kxk2 + kyk2 − 2hx, yi
≈ kxk2 + kyk2 − 2hx, q(y)i
= kxk2 + kyk2 + 2hx, αd1 + βd2i
= kxk2 + kyk2 + 2(hαx, d1i + hβx, d2i)

(3)

where h·, ·i denotes the dot product. The above equation calcu-
lates the ADC distance. Also, we can calculate SDC distance
d(q(x), q(y)) using the similar approximation method.

Before introducing SVQ, we ﬁrst give an equivalent formu-
lation of VQ. We stack the codebook C into a D × k matrix
C, in which each of its columns is a word. Let k denote the

size of codebook C, we can rewrite Eqn. (1) as the following
optimization problem:

1
2

min

α

kCα − xk2,

s.t. kαk0 = 1, α ∈ {0, 1}k

(4)

α is a k dimensional column vector, in which the value of
each element is either zero or one. Obviously, the above
optimization in Eqn. (4) is equivalent to hard assignment by
imposing very strict constraints on variable α to choose the
nearest word from matrix C given the input vector x.

As in the above discussion, it can be observed that searching
accuracy for ANN is directly related to the bound of Eqn. (4)
rather than its solution. To this end, we relax the constraints
in Eqn. (4) so as to obtain a lower bound. This will implicitly
yield better ANN searching performance. Speciﬁcally, we
relax the constraint in Eqn. (4) as follows:

1
2

min

α

kCα − xk2,

s.t. kαk0 ≤ L, α ∈ Rk

(5)

where L, named as sparse level, denotes the number of code-
words selected to encode x. It can be seen that such relaxation
not only increases L0 norm of sparse representation but also
expands the space of α. Obviously, Eqn. (4) can be viewed
as a special case of Eqn. (5) when L = 1. Therefore, we can
obtain a lower bound for quantization distortion. Intuitively,
the above formulation employs the linear combination of L
words in codebook rather than using only single word as VQ
to approximate the original input vector. Our empirical study
shows that using just two words is sufﬁcient to yield signiﬁcant
gain over the hard assignment.

Eqn. (5) is well-known as an NP-Hard problem. To tackle
this issue, we take advantage of an effective greedy algorithm
called Orthogonal Matching Pursuit (OMP) [25], [26]. OMP
updated all the extracted coefﬁcients by computing the orthog-
onal projection of the vector residual onto the set of codewords
selected so far. As L is usually set to two, there are at most two
non-zero elements in the coefﬁcient vector α. As the sparse
property of the representation is essential to fast NN search, we
thus name our method as Sparse Vector Quantization (SVQ).

C. Codebook Training
Remember that we assume the codebook of each approach
has been given in previous analysis. In this part, we will show
how to obtain the codebook.

The ﬁrst common and straightforward method is to ﬁnd the
codebook by directly minimizing the quantization error on the
training set {x|x ∈ X}. In the case of VQ, the codebook is
obtained by solving Eqn. (1) or Eqn. (1) on X, and this is
equivalent to running an iterative k-means clustering algorithm
where the centroids of the resulting k clusters are treated as
the codebook.

For SVQ, minimizing the quantization error is equal to the

following problem:

min

C∈RD×k,αi∈Rk

1
2

n
X
i=1

kCαi − xik2,

s.t. kαk0 ≤ L.

(6)

It is NP-hard. We can alternate between C and α to solve
this problem. When C is ﬁxed, we have shown how to solve

4

it in previous section. Notice that here what we care is the
codebook C. Then we can further relax the contraints by
using an L1-norm constraint which can also yield sparse
solutions. In section V-B, we will see that both methods
is applicable to our method. When α is ﬁxed, it becomes
an uncontrained least square problem. In our implementation
we employ the stochastic/online optimization algorithm [25],
[26] to solve the above optimization problem for learning
the codebook, where the learned codebook can be excellently
ﬁtted for the sparse coding tasks. Since the algorithm is based
on stochastic optimization, it is even faster than conventional
k-means clustering method.

In general, VQ-based methods heavily rely on a good code-
book, which is important to reduce the quantization distortion.
Due to its intrinsic limitedness, k-means is often difﬁcult to
generate a good one. In the experiment, we will show that, In
contrast to other VQ-based methods such as PQ and OPQ, our
proposed SPQ method is not limited to any speciﬁc codebook
learning method.

IV. SPARSE PRODUCT QUANTIZATION

To facilitate the practical ANN search, we propose an
efﬁcient Sparse Product Quantization approach by extending
the product quantization with the proposed SVQ technique in
order to further reduce the computational overhead.

A. Product Quantization
Following the idea of Product Quantization (PQ) [15],
we decompose the high-dimensional space into a Cartesian
product of low dimensional subspaces and then perform sparse
vector quantization in each subspace separately. Speciﬁcally,
a vector x is viewed as the concatenation of m subvectors:
x = [x1, x2, ..., xm] and the codebook is deﬁned as: C =
C1 × C2 × ... × Cm.

For PQ, each subvector is mapped onto a sub-codeword

from its corresponding codebook:

x = [x1, x2, ..., xm].
P Q : xi → qi(x) = arg min

c∈C i

i = 1, 2, ..., m.

d(xi, c),

(7)

where qi is a quantizer for the i-th subvector of x. Practically,
x is equally partitioned so that all subvectors xi ∈ RD/m and
D is a multiple of m. Note that each subvector is encoded
according to the different codebook. In this case, any word
c of x in codebook C will be the concatenation of m sub-
codewords: c = [c1, c2, ci, ..., cm], with each ci ∈ Ci, i ∈
[1, m].

Let Q(x) = [q1(x), q2(x), ..., qm(x)] denote the PQ of x.
Then, the quantization distortion of x by PQ is deﬁned as
follows:

e(x) = d2(x, Q(x)) =

m
X
i=1

kxi − qi(x)k2

(8)

Usually, we need to quantize a set of vectors X = {xi, i =
1, ..., n} rather than single one. Hence, the quantization dis-
tortion of X is deﬁned as E(X) = Px∈X e(x).

As in Eqn. (7), it can be easily observed that PQ divides
Eqn. (1) into m sub-VQ problems and therefore addresses it
separately. Therefore, PQ method enjoys the merit of providing
the compact coding scheme for high-dimensional data while
yielding accurate result for fast approximate nearest neighbor
search. However, the unavoidable quantization error limits its
performance of searching accuracy due to the inherent nature
of vector quantization [13].

Intuitively, better reconstruction that means having lower
quantization distortion indicates better search accuracy . In
next section, we will introduce an approach which can effec-
tively reduce the quantization distortion.

B. Sparse Product Quantization
In the proposed sparse vector quantization, we represent

each item x in the database as follows:

5

Algorithm 1 ANN Search with Sparse Product Quantization
Input:

The database X = [x1, · · · , xn], the codebook size k,
the subspace number s, the sparse level L, the query set
Q = [q1, · · · , qm], the number of NN p.

Output:

The top p ANN indexs I, the top p ANN distances D

/∗ Encoding Stage ∗/

1: Sample a subset Xs of X.
2: for each subspace X i
3:

s of Xs do

Using the fast stochastic online algorithm [25] to train
a codebook Ci of size k on X i
s .

4: end for
5: for each subspace X i of X do
6:

Compute sparse coefﬁcient Ai = {αi
n} on Ci
using Orthogonal Matching Pursuit algorithm, such that

1, · · · , αi

x ≈ C · α.

(9)

αi

j = arg min
α

kCiα − xi

jk2, s.t. kαk0 ≤ L.

where α is a sparse vector with a few non-zero elements.

Motivated by product quantization, in this paper, we employ
the proposed SPQ scheme with slight modiﬁcation by replac-
ing x with its subvector xi. Therefore, we can approximate
xi through the following equation:

xi ≈ Ciαi, i = 1, 2, ..., m,

(10)

We can prove that the quantization distortion of SPQ is
upper bounded by that of PQ. Remember that SVQ is a
relaxation version of VQ. Thus, the bound for quantization
distortion of SVQ is lower than that of VQ. In the case of
PQ and SPQ, their distortions are the sum of distortions for
each subvector. With respect to each subvector, the situation is
equal to that of VQ and SVQ. Thus, we can conclude that the
quantization distortion of SPQ is less than or equal to PQ’s.

C. Approximate Nearest Neighbor Search
In the following, we discuss how to apply the proposed SPQ
method to conduct ANN search towards large-scale image
retrieval tasks. The whole framework of our proposed SPQ
approach of ADC version is summarized into Algorithm 1.

In particular, to facilitate ANN search, we encode all the
data vectors in the gallery using the proposed SPQ method.
Then, we compute the distance between a query q and the data
in the gallery using two kinds of distance measures: ADC and
SDC.

According to the deﬁnition, ADC can be formulated as:

d2(q, x) =

=

m
X
i=1
m
X
i=1

kqi − xi)k2

kxik2 + kqik2 − 2hxi, qii

= kxk2 + kqk2 − 2

m
X
i=1

hCiαi, qii.

(11)

To reduce the computational cost for ADC distance computa-
tion, we can either normalize x or precompute kxk2. Since α

7: end for

/∗ Query Stage ∗/

for each subspace qi of q do

8: for each query q of Q do
9:
10:
11:

Precompute lookup table T i with qi and Ci.
Using Ai and T i to compute the approximate dis-
tances Ei to the database on this subspace.

12:
13:
14:

end for
Sum up the approximate distances E = Pi Ei.
Search the top p NNs based on E and save them to I
and D.

15: end for

is an essentially sparse vector, it only requires several ﬂoating
point operations to compute hCiαi, qii.

In the case of SDC computation, we employ sparse product
quantization to approximate the query vector q as: qi ≈ Ci ·
βi, i = 1, 2, ..., m , Similarly, SDC is computed as:

d2(q, x) =

=

m
X
i=1
m
X
i=1

kqi − xi)k2

kxik2 + kqik2 − 2hxi, qii

= kxk2 + kqk2 − 2

m
X
i=1

hCiαi, Ciβii

For better illustration, Fig. 2 shows a 2D example of distance
computation for both ADC and SDC.

D. Complexity Analysis
In the following, we give the detailed analysis on the

complexity of our proposed SPQ scheme.

Let D denote the dimensionality of each feature vector, n
denote the total number of items in the whole database, m
denote the number of subvectors in x, and k denote the size

of each codebook. For a given query, it takes O(nD + kD +
nmL) ﬂoating point multiplications to search its approximate
nearest neighbor in database X . Speciﬁcally, it requires nD
multiplications for the dot product of each database vector.
This is required if the database is not normalized. Also, it
takes kD operations to compute the distance between query
vector and vocabulary matrix C. We need nmL multiplications
to compute the dot product with the database vectors in sparse
representation, which is the third term in Eqn. (11).

If all the database vectors have been normalized with unit
L2 norm ofﬂine, then kxk2 = kqk2 = 1. Therefore, the
overall online time complexity to computing ADC distance
can be reduced to O(kD + nmL). In the task of multimedia
information retrieval, the dimensionality of each feature vector
D is far less than the total number of entries in database:
D ≈ k ≪ n. Thus, the computational complexity of Eqn. (11)
can be approximated to O(nmL). On the other hand, the
complexity of brute-force NN search is O(nD). Thus, we can
obtain substantial speedup using the proposed SPQ scheme.
Moreover, our method is able to take advantage of the ef-
ﬁcient SSE instructions to further reduce the multiplication
computational time. Speciﬁcally, the searching time of our
proposed SPQ is comparable to the original PQ while the
precision of SPQ outperforms that of PQ at large margin.
Additionally, the empirical study shows that SPQ is even faster
than FLANN [28] with the same recall rate.

Due to the inherent nature of soft-assignment, SPQ con-
sumes more memory cost than hard-assignment methods in-
evitably. However, it is worth the memory because SPQ brings
signiﬁcant gain on precision improvement. According to the
previous studies, FLANN is one of the most popular ANN
search techniques that utilize tree structure. However, it fails to
work for very large-scale datasets since it must load the whole
dataset in memory when building the trees. By contrast, SPQ
does not need to load the whole data in memory by employing
the efﬁcient inverted ﬁle structures, making it potentially more
practical than FLANN for large-scale multimedia retrieval.

V. EXPERIMENT

In this section, we will ﬁrst introduce our experimental
testbed and the background of several state-of-the-art ANN
methods we will compare with. Then we discuss the settings
of our proposed method and furnish our results comparing
with these methods. Finally, we show the application of our
method on image retrieval.

A. Experimental Testbed
To examine the empirical efﬁcacy of the proposed method,
we conduct an extensive set of experiments for comprehensive
performance evaluations on ﬁve datasets, including a synthetic
dataset with Gaussian noises and four publicly available image
feature collections. Each dataset is partitioned into three parts:
training set, gallery set and query set. The details of these
testbeds are summarized as follows: 1) SIFT dataset consists
of one million local SIFT features [24] with 128 dimensions,
in which 100K samples are employed to learn the codebook.
All the one million samples are treated as gallery set, and

6

10K samples are used for evaluation. Note that there is no
overlap between the training set and the gallery set, since
the former is extracted from Flickr images and the latter is
from the INRIA Holidays images [14]; 2) GIST [32] is made
of 960-dimensional global features. There are 50K samples
used to learn the codebook. Similarly, one million samples
in database are viewed as gallery set, and 1K samples are
used for query evaluation. They are extracted from the tiny
image set [43], Holidays image set, and Holiday with Flickr1M
set, respectively; 3) We perform empirical study on MNIST1
as used in OPQ [10], which is a 784-dimensional image
set of hand-written digits with totally 70K images. In our
experiment, we randomly sample 1K images as the queries
and the remaining data are treated as the gallery set. To learn
the codebook, we randomly pick 7K from the gallery set; 4)
LabelMe dataset [37] contains 22,019 images, where each
item is represented by a 512-dimensional GIST descriptor.
Following [44], we randomly sample 2K images to form the
query set and use the remaining data to form the gallery set;
5) We also synthesize a set of 128-dimensional vectors from
independent Gaussian distributions. We choose 10K data to
learn the codebook. 1M data is employed as gallery set, and
1K samples are used for query. All the compared methods are
evaluated on the same dataset for each setting. To make it
clear, Table I summarizes the statistics of the datasets used in
our experiments.

We compare our proposed Sparse Product Quantization
(SPQ) approach with the following state-of-the-art methods.
• Product Quantization (PQ [15]) tries to build codebook
on Cartesian Product space, which is treated as baseline.
IVFPQ refers to the PQ with the inverted ﬁle structure.
All the results of PQ in the experiment are reproduced
from the original implementation 2.

• Optimized Product Quantization (OPQ [9]) aims at ﬁnd-
ing an optimal space decomposition of PQ, which intro-
duces two different solutions. Due to its superior perfor-
mance, we only compare with the non-parametric solution
using parametric one as a warm start. Similarly, we adopt
their own implementation 3 with default settings.

• Cartesian K-means (CK-means [31])

is yet another
method to ﬁnd the optimal space decomposition for PQ. It
is equivalent to OPQ while using the same initialization.
The results of CK-means are produced from the publicly
available implementation 4 with default setup.

• Iterative Quantization (ITQ [12]) is an effective binary
embedding technique that can also be viewed as a vector
quantization method.

• Order Preserving Hashing (OPH [44]) is a state-of-the-art
hashing method that learns similarity-preserving hashing
functions.

• FLANN [28] is the most popular open-source ANN
search toolbox based on the framework of searching tree.
It is able to automatically select the best algorithm and

1http://yann.lecun.com/exdb/mnist/
2http://people.rennes.inria.fr/Herve.Jegou/projects/ann.html
3http://research.microsoft.com/en-us/um/people/kahe/cvpr13/index.html
4https://github.com/norouzi/ckmeans/tree/

0.7

0.6

0.5

0.4

0.3

0.2

0.1

P
A
m

SIFT 64bits ADC

 

Kmeans
SPQ

L=4

L=3

L=2

L=1

1

0.8

0.6

0.4

0.2

l
l

a
c
e
R

 
0
0

0.5

1
2
Square Distortion

1.5

2.5

3
x 104

 
0
100

(a)

101

R
(b)

SIFT 64bits ADC

x 104

10

 

SIFT 64bits ADC

i

n
o
i
t
r
o
t
s
d
e
r
a
u
q
S

 

8

6

4

2

0

Random
Kmeans
L1−Learning
L0−Learning

102

103

Random Kmeans

L1

Codebook methods

(c)

7

L0

Setting experiments on SIFT dataset. (a) mAP vs. Square Distortion under different sparse levels L. The square distortion decreases and mAP
Fig. 3.
increases consistently when the sparse level L increases. (b) Performance comparison on different codebook learning methods. Random denotes the random
sampling method and L0-learning and L1-learning are the online dictionary learning algorithm with corresponded constraint [25]. Our method perform very
similar in real data with various codebook learning methods, except for random sampling method that contains no information of the data. (c) The quantization
distortion on different codebook methods. It is easy to see the relationship between accuracy and distortion.

SUMMARY OF OUR EXPERIMENTAL TESTBEDS

TABLE I

Dataset

d

T raining

Gallery

Query

SIFT

128
100K
1M
10K

GIST

Random MNIST

LabelMe

960
50K
1M
1K

128
10K
1M
10K

784
10K
60K
1K

512
10K
20,019
2K

parameters for a given dataset.

The above methods can be roughly categorized into three
groups: (i) VQ-based methods, including PQ, OPQ, and CK-
means; (ii) hashing-based methods, including ITQ and OPH;
and ﬁnally (iii) FLANN that is a searching tree-based method.
In the following, we make the comparisons for each group
separately.

In our empirical study, distortion is employed to measure
the reconstruction performance for vector quantization. To
evaluate the efﬁcacy of ANN search methods, we employ the
conventional performance metrics for multimedia information
retrieval, including precision, recall and mAP. Precision means
the average proportion of true NNs ranked ﬁrst in the returned
candidates, and recall denotes the proportion of true NNs of
all queries is ranked. Moreover, mAP is the mean of Average
precision over all the queries, which indicates the overall
performance. All of our experiments were carried out on a PC
with Intel Core i7-3770 3.4GHz processor and 16GB RAM
using single thread.

B. Settings
We discuss the experimental settings for the proposed SPQ

approach in the following.

Sparse Level L denotes the number of words to encode a
feature vector by our method, which is critical to our method.
Fig. 3a shows mAP with respect to the quantization square
distortions under different sparse levels on the SIFT dataset.
Clearly, the square distortion decreases consistently when the

sparse level L increases, and at the same time mAP increases.
Moreover, we found that the distortion drops signiﬁcantly
from level one to level two. Since the computational time and
memory consumption grow with the sparse level, we set L to
2 in the following experiments as a tradeoff between efﬁciency
and accuracy. In section V-C, we will see that this sparse level
is good enough to outperform the state-of-the-art methods.

Codebook Training. In what will follow, we study four
different kinds of codebook generating methods. They are
random sampling, K-means, sparse dictionary learning with
L1-norm, and sparse dictionary learning with L0-norm. Ran-
dom sampling method simply generates the codebook via a
Gaussian distribution. Both Random method and K-means are
learning-free methods. The sparse dictionary learning method
is based on an L1 constraint or L0 constraint, both of which
can be solved by the online algorithm [25]. We test these
codebook methods on SIFT dataset and the results are shown
in Fig. 3b and Fig. 3c.

From the result, we observe that the performance of random
sampling method is much worse than that of other methods,
since its codebook contains no information of the gallery
set. Surprisingly, K-means clustering and sparse dictionary
learning methods perform very similar, which again implies
the robustness of our method for different codebook learning
algorithms. In the followed experiments, unless explicitly
stated, the codebooks are genereated by the sparse method
with L1 constraint.

C. Comparisons with other methods
Comparison with Vector Quantization Methods. Note
that our proposed SPQ approach is based on the framework of
VQ. To facilitate the comprehensive evaluation, we compare
our method with three state-of-the-art VQ-based methods,
including PQ, OPQ and CK-means.

We ﬁrstly examine the quantization distortion for different
methods with various code lengths. As shown in Fig. 4, it
can be observed that our proposed SPQ method consistently

0.25

0.2

0.15

0.1

0.05

n
o
i
t
r
o
t
s
D

i

 
0
16

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

0.4

0.35

0.3

0.25

0.2

0.15

0.1

0.05

 
0
16

P
A
m

x 104

SIFT

 

PQ
OPQ
SPQ
CK−means

RANDOM

 

PQ
OPQ
SPQ
CK−means

7

6

5

4

3

2

1

n
o
i
t
r
o
t
s
D

i

32

bits

64

RANDOM ADC 50−NN

PQ
OPQ
SPQ
CK−means

101

R

102

RANDOM ADC 50−NN

PQ
OPQ
SPQ
CK−means

128

 

102

 

32

bits

64

SIFT ADC 50−NN

PQ
OPQ
SPQ
CK−means

101
R

SIFT ADC 50−NN

PQ
OPQ
SPQ
CK−means

128

 

103

 

 
0
16

1

0.8

0.6

0.4

0.2

 
0
100

l
l
a
c
e
R

1

0.8

0.6

0.4

0.2

P
A
m

64

128

 
0
16

32

bits

(a)

64

128

32

bits
(b)

1.4

1.2

1

0.8

0.6

0.4

 
16

1

0.8

0.6

0.4

0.2

n
o
i
t
r
o
t
s
D

i

l
l
a
c
e
R

 
0
100

0.4

0.35

0.3

0.25

0.2

0.15

0.1

0.05

 
0
16

P
A
m

8

MNIST

 

PQ
OPQ
SPQ
CK−means

32

bits

64

MNIST ADC 50−NN

PQ
OPQ
SPQ
CK−means

101
R

MNIST ADC 50−NN

PQ
OPQ
SPQ
CK−means

128

 

102

 

GIST

 

PQ
OPQ
SPQ
CK−means

32

bits

64

GIST ADC 50−NN

PQ
OPQ
SPQ
CK−means

101

R

102

GIST ADC 50−NN

PQ
OPQ
SPQ
CK−means

128

 

103

 

n
o
i
t
r
o
t
s
D

i

0.45

0.4

0.35

0.3

0.25

0.2

0.15

0.1

0.05

 
16

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

0.7

0.6

0.5

0.4

0.3

0.2

0.1

P
A
m

64

128

 
0
16

32

bits

(c)

64

128

32

bits
(d)

Fig. 4. Performance comparison on different datasets. (a) - (d) are the results on dataset Random, SIFT, GIST, and MNIST, respectively. The ﬁrst row present
the performance in terms of Distortion vs. Code Length. The second and third row are performance comparison in terms of Recall vs. R and mAP vs. Code
Length ,respectively, when ﬁnding the top 50 nearest neighbors. Note that the poor performance of OPQ on MNIST is because we ﬁxed its initilization.

achieves very low squared distortion on all the datasets com-
pared to the other methods. Then, we evaluate the performance
in terms of recall vs. R when searching for different numbers
of NNs, and also measure the recall with respect
to the
total number of returned candidates, i.e., recall vs. R in the
result. Moreover, we also measure the recall@100, which
denotes the proportion of true NNs in the top 100 returned
NN results with various code lengths. Based on whether or
not quantizing the queries, there are two different kinds of
distance computation methods: ADC and SDC. Fig. 5 shows
the experimental results. From the results, it is clear to see
that our approach generally outperforms the other competing
quantization methods.

As presented in [15], PQ slightly improves the search accu-
racy by combining an inverted ﬁle structure and encoding the
residual. We also utilize the inverted ﬁle structure (IVFSPQ)
and compares with it (IVFPQ) in Fig. 5. We can see that
IVFPQ indeed perform slightly better than PQ in both the
SIFT and GIST dataset, while our method still outperform
both of them. For the efﬁciency, our proposed SPQ approach
is expected to be slightly more computational expensive than
PQ. However, as shown in Table III, the empirical time costs
for PQ and SPQ when using an inverted ﬁle structure (IVFPQ
vs. IVFSPQ) are fairly comparable.

Comparison with Hashing-based Methods.

We compare our SPQ approach with several state-of-
the-art hashing-based ANN search methods, including min-
imal loss hashing (MLH) [30], iterative quantization hash-
ing (ITQ) [12], order preserving hashing (OPH) [44], local-
ity sensitive hashing (LSH) [8], kernelized supervised hash-
ing (KSH) [23], isotropic hashing (IsoHash) [20], and spectral
hashing (SH) [46]. To make a fair comparison, we follow
the evaluation protocol in [44], where mAP is employed as
performance metric with the ground truth being 50 nearest
neighbors. Table II shows the performance evaluation on
three datasets, including LabelMe, SIFT and GIST. It can
be clearly seen that our proposed SPQ approach signiﬁcantly
outperforms these hashing-based methods at a large margin.
To make it clear, we compare searching time with the spectral
hashing algorithm (SH [46]), and the results are summarized in
Table III. For PQ [15], we have re-implemented the Hamming
distance computation in C in order to ensure that all the
approaches in our comparisons are optimized appropriately .
It can be seen that our proposed method outperforms SH in
terms of both efﬁciency and accuracy.

Comparison with Searching Tree-based Method.
It is interesting to compare our proposed SPQ approach
with FLANN, which is known as the most popular open-
source toolbox for ANN search. We select the SIFT dataset as
the testbed, and evaluate the precision with given searching

RANDOM ADC

PQ
OPQ
SPQ
CK−means
IVFPQ
IVFSPQ

101

R

102

RANDOM ADC

PQ
OPQ
SPQ
CK−means

32

bits

64

RANDOM SDC

PQ
OPQ
SPQ
CK−means

101

R

102

RANDOM SDC

PQ
OPQ
SPQ
CK−means

 

103

 

128

 

103

 

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

1

l
l

a
c
e
R

0.8

0.6

0.4

0.2

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

1

l
l

a
c
e
R

0.8

0.6

0.4

0.2

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

9

 

MNIST ADC

PQ
OPQ
SPQ
CK−means
IVFPQ
IVFSPQ

102

 

101
R

MNIST ADC

PQ
OPQ
SPQ
CK−means

128

 

32

64

bits

MNIST SDC

PQ
OPQ
SPQ
CK−means

102

 

101
R

MNIST SDC

PQ
OPQ
SPQ
CK−means

64

128

SIFT ADC

 

PQ
OPQ
SPQ
CK−means
IVFPQ
IVFSPQ

102

 

101
R

SIFT ADC

PQ
OPQ
SPQ
CK−means

128

 

32

64

bits

SIFT SDC

PQ
OPQ
SPQ
CK−means

102

 

101
R

SIFT SDC

PQ
OPQ
SPQ
CK−means

64

128

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

1

l
l

a
c
e
R

0.8

0.6

0.4

0.2

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

GIST ADC

PQ
OPQ
SPQ
CK−means
IVFPQ
IVFSPQ

101

R

GIST ADC

102

PQ
OPQ
SPQ
CK−means

32

64

bits

GIST SDC

PQ
OPQ
SPQ
CK−means

101

R

GIST SDC

102

PQ
OPQ
SPQ
CK−means

 

103

 

128

 

103

 

1

0.8

0.6

0.4

0.2

l
l
a
c
e
R

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

 
0
16

1

l
l

a
c
e
R

0.8

0.6

0.4

0.2

 
0
100

1

0.8

0.6

0.4

0.2

0
0
1
@

l
l

a
c
e
R

64

128

 
0
16

32

bits

(a)

32

bits
(b)

64

128

 
0
16

32

bits

(c)

32

bits
(d)

Fig. 5. Performance comparison of ADC and SDC on different datasets. (a) - (d) are the results on dataset Random, SIFT, GIST, and MNIST, respectively.
Performance comparison are in terms of Recall vs. R and mAP vs. Code Length when ﬁnding the nearest neighbor. The top two rows are under ADC and
the bottom two are under SDC. In the ﬁrst row, we also compare between PQ and SPQ that employ the inverted ﬁle structure, i.e. IVFPQ and IVFSPQ. It
can be observed that our method performs better, if not competitive, than other methods.

COMPARISON WITH HASHING METHODS (MAP). OUR APPROACH OBTAINS A SIGNIFICANT GAIN OVER ALL OF THESE METHODS ON ALL THE DATASETS.

TABLE II

Dataset

Code
Length

LabelMe

SIFT

GIST

32
64
128
32
64
128
32
64
128

SPQ
47.97
62.14
77.52
32.08
69.47
86.39
4.07
6.40
11.14

MLH [30]

ITQ [12]

OPH [44]

LSH [8]

KSH [23]

IsoHash [20]

SH [46]

Approaches

19.91
32.48
45.22
3.07
8.11
18.01
1.74
3.51
5.96

20.36
32.09
44.66
2.69
8.16
17.87
1.68
3.27
5.14

21.11
33.94
44.36
5.07
13.58
26.00
2.00
4.12
6.97

8.87
17.57
32.52
1.49
5.68
14.05
0.56
1.50
3.12

16.72
24.57
31.45
1.26
2.94
5.04
1.15
2.21
3.83

18.51
28.35
42.34
2.31
7.24
16.53
1.39
3.25
5.21

9.28
11.18
13.73
4.23
9.81
15.56
0.68
1.08
1.45

1

0.9

0.8

0.7

0.6

0.5

n
o
s

i

i

c
e
r
P

 
0.4
0

5

10

SIFT

 

FLANN
SPQ

25

30

35

15

20

Search Time (second)

Fig. 6. Comparison with FLANN [28]. The precision of our method is
obtained by re-ranking 50 returned candidates and the extra time cost is less
than 0.1 second. It can be clearly seen that our method is faster than FLANN
if the precision of re-ranking results is above 0.7.

THE RETRIEVAL RESULT IN THE OXFORD DATASET

TABLE IV

accuracy

mAP (%)

SPQ
77.5

FLANN

visualindex

77.1

75.0

time. As in PQ [15], we take advantage of an inverted
ﬁle structure to speed up the SPQ method with the cost
of slight performance drop. FLANN includes a re-ranking
scheme that computes the exact distances for the candidate
nearest neighbors. For the sake of comparison with FLANN,
we also add a re-ranking stage to our SPQ method. In practice,
while obtaining a precision of 94.7%, SPQ costs 6.0 seconds
or 4.2 seconds employing SSE in the search stage. FLANN,
however, takes 6.4 seconds to obtains a precision of 84.2%.
Fig. 6 shows the experimental results. The precision of our
method is obtained by re-ranking 50 returned candidates and
the extra time cost is less than 0.1 second. It is not difﬁcult
to see that our method is faster than FLANN if the precision
of re-ranking results is required to be higher than 0.7. This
is critical since we always pursue higher precision given a
ﬁxed period of time. More importantly, our method consumes
much less memory cost than the searching tree-based FLANN
method: the indexing structure occupies less than 100MB,
while FLANN requires more than 250 MB of RAM. We
should notice that our result could be further improved with a
better inverted method, such as multi-index [2].

Comparison on Image Retrieval
Image Retrieval [16] is also a popular topic in multime-
dia application. It aims at retrieving the items containing
the target object from a large image corpus. A typical im-
age retrieval system is based on the technique of bag-of-
visual-words (BOW) which mathches local features such as
SIFT [24]. And ANN search approach is heavily employed
by the BOW encoding strategy. In this paper we compare our
method with the popular fast ANN approach [28] for image
retrieval.

10

extracted with gravity vector constraints [33] and RootSIFT [1]
that use the square root of each component of a SIFT vector
is also employed. We build the codebook of 1M visual words
for BOW encoding. In our method, we assign 8 bits to each
subspace (k=256) and the subspace number is 8. For the
fast ANN approach, we followed the setup in Fast Object
Retrieval [49] and visualindex 5. In the experiment, we use
mean Average Precision (mAP) as the performance metric.
The result is shown in Table IV. We can see that our method
outperforms the other two approaches.

VI. CONCLUSION AND FUTURE WORK

In this paper, we propose a novel Sparse Product Quan-
tization approach to encoding high-dimensional feature vec-
tors into sparse representation. Euclidean distance between
two vectors can be efﬁciently estimated from their sparse
product quantization using fast table lookups. We optimize
the sparse representation of the data vectors by minimizing
their quantization errors, making the resulting representation
is essentially close to the original data in practice. We have
conducted extensive experiments by evaluating the proposed
Sparse Product Quantization technique for ANN search on
four public image datasets, whose promising experimental
results show that our method is fast and accurate, and sig-
niﬁcantly outperforms several state-of-the-art approaches with
large margin. Furthermore, the result on the image retrieval
also demonstrates the efﬁcacy of our proposed method.

Despite these promising results, some limitations and future
work should be addressed. As many other soft assignment
methods, the performance gain of our approach involves with
extra storage requirements and computational cost inevitably.
For future work, we will study how to compress the coding
coefﬁcients. Also, we will extend our technique to other tasks,
such as object retrieval.

ACKNOWLEDGMENT

The work was supported in part by National Natural Science
Foundation of China under Grants (61103105 and 91120302).

REFERENCES

[1] R. Arandjelovi´c and A. Zisserman. Three things everyone should know
to improve object retrieval. In Computer Vision and Pattern Recognition
(CVPR), 2012 IEEE Conference on, pages 2911–2918. IEEE, 2012.

[2] A. Babenko and V. Lempitsky. The inverted multi-index. In Computer
Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on,
pages 3069–3076, June 2012.

[3] J. L. Bentley. Multidimensional binary search trees used for associative

searching. Commun. ACM, 1975.

[4] J. Brandt. Transform coding for fast approximate nearest neighbor search

in high dimensions. In CVPR, 2010.

[5] J. Cai, Q. Liu, F. Chen, D. Joshi, and Q. Tian. Scalable image search
with multiple index tables. In Proceedings of International Conference
on Multimedia Retrieval, page 407. ACM, 2014.

[6] D. Chen, G. Baatz, K. Koser, S. Tsai, R. Vedantham, T. Pyl-
vanainen, K. Roimela, X. Chen, J. Bach, M. Pollefeys, B. Girod, and
R. Grzeszczuk. City-scale landmark identiﬁcation on mobile devices.
In Computer Vision and Pattern Recognition (CVPR), 2011 IEEE
Conference on, pages 737–744, June 2011.

We evaluate on the Oxford 5K dataset. SIFT features are

5https://github.com/vedaldi/visualindex

COMPUTATIONAL COST AND ACCURACY PERFORMANCE ON THE SIFT DATASET USING 64 BITS. FOR BETTER ILLUSTRATION, WE ALSO INCLUDE

COMPARISONS OF MATLAB IMPLEMENTATION WITH THE OPTIMIZED C++/MEX CODE IN THE SEARCH STAGE. FOR THE EFFICIENCY, OUR PROPOSED
SPQ APPROACH IS EXPECTED TO BE SLIGHTLY MORE COMPUTATIONAL EXPENSIVE THAN PQ. HOWEVER, THE EMPIRICAL TIME COSTS FOR PQ AND

SPQ WHEN USING AN INVERTED FILE STRUCTURE (IVFPQ VS. IVFSPQ) ARE FAIRLY COMPARABLE. FOR OTHER ANN METHODS, OUR METHOD

OUTPERFORMS BOTH SH AND FLANN ON THE SEARCH TIME AND PRECISION. THE SOURCE CODES OF ALL THE METHODS ARE PUBLICLY AVAILABLE.

TABLE III

11

Approaches

Search time (ms/per)

Recall@1 (%)

Recall@100 (%)

PQ [15]

SPQ

MATLAB/mex

IVFPQ [15]

IVFSPQ
SH [46]
IVFSPQ

FLANN [28]

C/C++

8.8
21.9
1.3
1.4
2.2
0.4
0.6

23.0
51.9
26.6
51.2
9.5
43.5

-

92.3
99.8
92.1
95.7
53.0
94.7
84.2

Fig. 7. Qualitative results between PQ and our proposed methods. (a) are the results of PQ and (b) are the results of SPQ. For each row, the ﬁrst image is a
query image and the remaining are the ranking results by each method. It is obvious that our method outperforms PQ.

(a)

(b)

[7] O. Chum, J. Philbin, J. Sivic, M. Isard, and A. Zisserman. Total recall:
Automatic query expansion with a generative feature model for object
retrieval. In Computer Vision, 2007. ICCV 2007. IEEE 11th International
Conference on, pages 1–8. IEEE, 2007.

[8] M. Datar, N. Immorlica, P. Indyk, and V. S. Mirrokni. Locality-sensitive

hashing scheme based on p-stable distributions. In SCG, 2004.

[9] T. Ge, K. He, Q. Ke, and J. Sun. Optimized product quantization for

approximate nearest neighbor search. In CVPR, 2013.

[10] T. Ge, K. He, Q. Ke, and J. Sun. Optimized product quantization. IEEE

Trans. Pattern Anal. Mach. Intell., 2014.

[11] T. Ge, K. He, and J. Sun. Product sparse coding. In Computer Vision

and Pattern Recognition (CVPR), 2014 IEEE Conference on, 2014.

[12] Y. Gong and S. Lazebnik. Iterative quantization: A procrustean approach

to learning binary codes. In CVPR, 2011.

[13] R. M. Gray. Vector quantization. ASSP Magazine, IEEE, 1984.
[14] H. J´egou, M. Douze, and C. Schmid. Hamming embedding and weak

geometric consistency for large scale image search. In ECCV, 2008.

[15] H. J´egou, M. Douze, and C. Schmid. Product quantization for nearest

neighbor search. IEEE Trans. Pattern Anal. Mach. Intell., 2011.

[16] H. J´egou, M. Douze, C. Schmid, and P. P´erez. Aggregating local

descriptors into a compact image representation. In CVPR, 2010.

[17] W. Johnson and J. Lindenstrauss. Extensions of Lipschitz mappings into

[18] A. Joly and O. Buisson. Random maximum margin hashing. In CVPR,

2011.

[19] M. Kafai, K. Eshghi, and B. Bhanu. Discrete cosine transform locality-
sensitive hashes for face retrieval. Multimedia, IEEE Transactions on,
16(4):1090–1103, 2014.
[20] W. Kong and W.-J. Li.

In Advances in Neural

Isotropic hashing.

Information Processing Systems, pages 1646–1654, 2012.

[21] V. Lepetit, P. Lagger, and P. Fua. Randomized trees for real-time

keypoint recognition. In CVPR, 2005.

[22] P. Li, M. Wang, J. Cheng, C. Xu, and H. Lu. Spectral hashing with
semantically consistent graph for image indexing. Multimedia, IEEE
Transactions on, 15(1):141–152, 2013.

[23] W. Liu, J. Wang, R. Ji, Y.-G. Jiang, and S.-F. Chang. Supervised hashing
with kernels. In Computer Vision and Pattern Recognition (CVPR), 2012
IEEE Conference on, pages 2074–2081. IEEE, 2012.

[24] D. G. Lowe. Distinctive image features from scale-invariant keypoints.

International journal of computer vision, 60(2):91–110, 2004.

[25] J. Mairal, F. Bach, J. Ponce, and G. Sapiro. Online dictionary learning

for sparse coding. In ICML, 2009.

[26] J. Mairal, F. Bach, J. Ponce, and G. Sapiro. Online learning for matrix

factorization and sparse coding. J. Mach. Learn. Res., 2010.

[27] M. Muja and D. G. Lowe. Fast approximate nearest neighbors with

automatic algorithm conﬁguration. In VISAPP, 2009.

a Hilbert space. In Contemporary mathematics. 1984.

[28] M. Muja and D. G. Lowe. Scalable nearest neighbor algorithms for

high dimensional data. Pattern Analysis and Machine Intelligence, IEEE
Transactions on, 36, 2014.

[29] D. Nister and H. Stewenius. Scalable recognition with a vocabulary tree.

In CVPR, 2006.

[30] M. Norouzi and D. M. Blei. Minimal loss hashing for compact binary
codes. In Proceedings of the 28th International Conference on Machine
Learning (ICML-11), pages 353–360, 2011.

[31] M. Norouzi and D. J. Fleet. Cartesian k-means. In CVPR, 2013.
[32] A. Oliva and A. Torralba. Modeling the shape of the scene: A holistic

representation of the spatial envelope. IJCV, 2001.

[33] M. Perd’och, O. Chum, and J. Matas. Efﬁcient representation of local
geometry for large @scale object retrieval.
In Computer Vision and
Pattern Recognition, 2009. CVPR 2009. IEEE Conference on, pages 9–
16. IEEE, 2009.

[34] J. Philbin, O. Chum, M. Isard, J. Sivic, and A. Zisserman. Object
In CVPR,

retrieval with large vocabularies and fast spatial matching.
2007.

[35] J. Philbin, O. Chum, M. Isard, J. Sivic, and A. Zisserman. Lost in
quantization: Improving particular object retrieval in large scale image
databases. In CVPR, 2008.

[36] E. Rublee, V. Rabaud, K. Konolige, and G. Bradski. Orb: an efﬁcient
In Computer Vision (ICCV), 2011 IEEE

alternative to sift or surf.
International Conference on, pages 2564–2571. IEEE, 2011.

[37] B. C. Russell, A. Torralba, K. P. Murphy, and W. T. Freeman. Labelme:

a database and web-based tool for image annotation. IJCV, 2008.

[38] G. Shakhnarovich, T. Darrell, and P. Indyk. Nearest-Neighbor Methods

in Learning and Vision: Theory and Practice. The MIT Press, 2006.

[39] C. Silpa-Anan and R. Hartley. Optimised kd-trees for fast

image
descriptor matching. In Computer Vision and Pattern Recognition, 2008.
CVPR 2008. IEEE Conference on, pages 1–8. IEEE, 2008.

[40] C. Silpa-Anan and R. Hartley. Optimised kd-trees for fast

image

descriptor matching. In CVPR, 2008.

[41] J. Sivic and A. Zisserman. Video Google: A text retrieval approach to

object matching in videos. In ICCV, 2003.

[42] E. Spyromitros-Xiouﬁs, S. Papadopoulos,

I. Y. Kompatsiaris,
G. Tsoumakas, and I. Vlahavas. A comprehensive study over vlad and
product quantization in large-scale image retrieval. Multimedia, IEEE
Transactions on, 16(6):1713–1728, 2014.

[43] A. Torralba, R. Fergus, and W. T. Freeman. 80 million tiny images:
A large data set for nonparametric object and scene recognition. IEEE
Trans. Pattern Anal. Mach. Intell., 2008.

[44] J. Wang, J. Wang, N. Yu, and S. Li. Order preserving hashing for

approximate nearest neighbor search. In ACM Multimedia, 2013.

[45] R. Weber, H.-J. Schek, and S. Blott. A quantitative analysis and
performance study for similarity-search methods in high-dimensional
spaces. In VLDB, 1998.

[46] Y. Weiss, A. Torralba, and R. Fergus. Spectral hashing. In Advances in

neural information processing systems, pages 1753–1760, 2009.

[47] F. Wu, Z. Yu, Y. Yang, S. Tang, Y. Zhang, and Y. Zhuang. Sparse
multi-modal hashing. Multimedia, IEEE Transactions on, 16(2):427–
439, 2014.

[48] S. Zhang, Q. Tian, Q. Huang, W. Gao, and Y. Rui. Usb: ultrashort binary
descriptor for fast visual matching and retrieval. Image Processing, IEEE
Transactions on, 23(8):3671–3683, 2014.

[49] Z. Zhong, J. Zhu, and S. Hoi. Fast object retrieval using direct spatial
matching. Multimedia, IEEE Transactions on, 17(8):1391–1397, Aug
2015.

Qingqun Ning is currently a PhD candidate in the
Department of Computer Science and Technology,
Zhejiang University of China. Before that, he re-
ceived the BS degree from Northwestern Polytech-
nical University of China in 2011. His research
interests include machine learning and computer
vision, with a focus on large scale image search and
object detection.

12

Jianke Zhu is an Associate Professor in College
of Computer Science at Zhejiang University. He
received his Ph.D degree in Computer Science and
Engineering from The Chinese University of Hong
Kong. He was a postdoc in BIWI Computer Vision
Lab at ETH Zurich. Dr. Zhu’s research interests
include computer vision and multimedia information
retrieval. He is a member of the IEEE.

Zhiyuan Zhong is currently a Master student in the
Department of Computer Science and Technology,
Zhejiang University. He received his Bachelor de-
gree in Computer Science from South China Univer-
sity of Technology, Guangzhou, P.R. China. His re-
search interests include machine learning, computer
vision and multimedia information retrieval.

Steven C.H. Hoi received the bachelors degree in
computer science from Tsinghua University, Beijing,
P.R. China, and the masters and PhD degrees in
computer science and engineering from the Chinese
University of Hong Kong. He is currently an asso-
ciate professor in the School of Information Systems,
Singapore Management University, Singapore. His
research interests include machine learning, multi-
media information retrieval, web search, and data
mining. He is a member of the IEEE and ACM.

Chun Chen received the PhD degree from Zhejiang
University in 1990. He is a professor in College of
Computer Science, the Dean of College of Software,
and the Director of Institute of Computer Software
at Zhejiang University. His research interests include
image processing, computer vision, embedded sys-
tem and information retrieval. He is a member of
the IEEE.

