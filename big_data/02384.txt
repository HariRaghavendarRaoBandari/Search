6
1
0
2

 
r
a

M
 
8

 
 
]

.

C
O
h
t
a
m

[
 
 

1
v
4
8
3
2
0

.

3
0
6
1
:
v
i
X
r
a

Column Generation and Lazy constraints for solving the Liner Ship

Fleet Repositioning Problem with cargo ﬂows

Robin H. Pearce, Alexis Tyler & Michael Forbes

School of Mathematics and Physics, University of Queensland, Australia

Abstract

We consider an important problem in the shipping industry known as the liner shipping ﬂeet

repositioning problem (LSFRP). We examine a public data set for this problem including many

instances which have not previously been solved to optimality. We present several improvements

on a previous mathematical formulation, however the largest instances still result in models too

diﬃcult to solve in reasonable time. The implementation of column generation reduces the model

size signiﬁcantly, allowing all instances to be solved, with some taking two to three hours. A novel

application of lazy constraints further reduces the size of the model, and results in all instances

being solved to optimality in under four minutes.

Keywords: Liner Shipping, Network ﬂows, Scheduling, Column Generation, Lazy constraints

1. Introduction

The shipping industry is responsible for transporting many billion tons of cargo each year, almost

9.6 billion tons in 2013, with a large percentage of this (35.4%) made up by container shipping [24].

Optimising the practices of the shipping industry to maximise proﬁts is the subject of considerable

academic and commercial interest. Much of this research centres around the principle of optimising

scheduling to maximise proﬁts. The main areas of research are in the ﬂeet deployment problem

and the network design problem, which are related to this principle.

Liner shipping operates on a ﬁxed schedule and uses a standard container size, the ISO container

[20]. Within the shipping industry, ships are often referred to as vessels, and the set of ships which

a liner shipping company operates is called a ﬂeet. An operator is the person responsible for

the operation of the shipping company and its ﬂeet. These companies operate within a shipping

network, which is a set of ports connected by arcs over which the ﬂeet may travel. While liner

Preprint submitted to

March 9, 2016

shipping does operate on a ﬁxed, periodic schedule, ships within the ﬂeet often need to be moved

between services to meet the demand of clients. This often happens to create new or modify existing

services. However, repositioning vessels is an expensive exercise due to fuel costs and potential losses

in revenue, so optimising these journeys is of particular interest within the industry.

In this paper we present several improvements for solving the LSFRP. We begin with an improved

MIP model for the LSFRP which ignores some less important aspects of the problem. Next, we

apply column generation and present a proof of the integer properties of the column generation

master problem. Finally, we present a novel use of lazy constraints to massively speed up the

solution of the column generation formulation.

This paper is organised as follows: the remainder of this section will be a review of the literature

around shipping network optimisation, followed by a review more speciﬁc to the LSFRP. In Section

2 we will describe the problem in more detail, and in Section 3 we will look at the improvements

we have made to the original formulation. Section 4 contains computational results comparing our

diﬀerent formulations, and Section 5 is a discussion about various aspects of this problem and the

associated public data set.

While the optimisation of network ﬂow models is well studied, very little work focusses on the

application of these models to shipping networks. This is emphasised in a survey conducted by

Ronen [18] in which he states that, while the development of these models has the potential to have

a large economic impact, the lack of literature in the ﬁeld has meant that the application of these

models in industry has been limited. Ronen details the models and techniques that were used in

ship scheduling in the previous decade. He notes that the majority of the work was focused on four

main areas: ﬂeet size, mix and deployment; inventory routing; cruising speed; and ship scheduling.

It is interesting to note that only a handful of the papers reviewed in this survey pertain to liner

shipping.

One such study is by Brown, Graves and Ronen [5], and focusses on scheduling ocean trans-

portation of crude oil. The authors use an elastic set partitioning model which incorporates all

ﬂeet cost components and optimises for speed as well as scheduling. However, this model assumes

that all ships are of similar sizes, and that one unit of cargo is a full shipload which has only a

single discharging port, which, in reality, are not feasible assumptions. With these assumptions

the authors are able to solve this problem with thousands of binary variables to an optimal integer

solution in less than a minute.

2

Another study is by Rana and Vickson [16], in which they use Lagrangian Relaxation to solve

the container ship routing problem. Their model incorporates multiple ships and solves for the

optimal schedule and amount of cargo transported by the ﬂeet to maximise proﬁt. The constraints

in this model cover the carrying capacity of the ships, available cargo, time duration, and the

requirement of having a connected feasible route for each ship. This model does not incorporate

more complex scheduling constraints for the ships, for example a cargo delivery deadline, which

limits the potential applications for this model.

In their 1992 study, Rathi, Church and Solanki [17] explore allocating resources to support a

multi-commodity ﬂow with time windows. This study presents three diﬀerent linear programming

(LP) models to minimise costs associated with this problem. All three formulations achieve this

by minimising lateness, which is determined by the amount of assets of each type that should be

allocated to a given route in each time period.

The review by Christiansen, Fagerholt and Ronen [7] provides an overview of the published

research on ship routing and scheduling from 1994-2002. The review is split into several sections.

The ﬁrst section looks at strategic ﬂeet planning, the design of ﬂeets. The second section is tactical

and operational ﬂeet planning which explores ship routing and scheduling problems for diﬀerent

types of shipping. Fagerholt and Christiansen [9] solve a combined ship scheduling and allocation

problem for industrial shipping using set partitioning. Next, they consider a problem related to

robust ship scheduling with multiple time windows using a set partitioning method, where all

feasible ship schedules are found prior to the model being solved [6]. Sherali [19] investigates ﬂeet

management models and algorithms for an oil-tanker routing and scheduling problem using a mixed

integer program (MIP) with heuristics.

The third and ﬁnal section of their review covers naval applications and other related problems.

Of the papers reviewed pertaining to ship routing and scheduling, most used dynamic programming

(DP), integer programs (IP) or heuristic algorithms to solve the problem. The authors note that

trends in the literature display a growing need for research into these types of problems.

There are a number of studies dedicated to solving the ﬂeet deployment problem, such as the

one by Powell and Perkins [15], and the network design problem, for example those by Agarwal
and Ergun [1], ´Alvarez [2] and Brouer et. al.

[4]. These problems are related to the decisions

associated with the design of networks and timetables, as opposed to determining optimal paths

for ships through a predetermined network. Agarwal and Ergun provide a unique formulation of

3

ship scheduling and network design for cargo routing in liner shipping. The authors use a mixed

integer linear program to solve the ship scheduling and cargo routing problem. Their model includes

constraints such as frequency of operation and transshipment of cargo.

Agarwal and Ergun also develop several solution techniques and compare their success and

eﬃciency. The described algorithms are a greedy heuristic, column generation and Benders decom-

position. They also outline an iterative search algorithm to generate schedules for liner shipping.

Computational tests were performed on each of the algorithms using generated instances and it was

found that, while the greedy heuristic was able to solve the problem very quickly, the solution qual-

ity was low. It was also found that the column generation and Benders’ decomposition approaches

achieved similar results in terms of accuracy, however the Benders’ formulation was signiﬁcantly

faster, particularly when the instance size was large.

1.1. Liner ship ﬂeet repositioning problem

The LSFRP is a type of network design problem which involves repositioning ships between

service routes while maximising proﬁt. This is achieved by visiting ports and delivering cargo while

repositioning. However, despite the body of literature devoted to liner shipping and its surrounding

problems, very little of this research is focused on the liner shipping ﬂeet repositioning problem.

The ﬁrst study that explores the LSFRP is by Tierney et. al. [21]. In this paper, the authors

solve a simpliﬁed version of the LSFRP without cargo ﬂows, empty equipment, or sail-on-service

(SOS) opportunities (discussed further below). Tierney and Jensen then conduct a study which

continues to explore this problem and incorporated cargo ﬂows [22]. In this paper, the authors use

a mixed-integer program (MIP) in conjunction with a constructed graph to solve the LSFRP. This

graph incorporates many of the LSFRP-speciﬁc constraints (such as SOS opportunities) so that

they can be removed from the model formulation. This approach is able to solve several instances

to optimality, however there are many larger instances where the problem can not be solved, as the

solver runs out of memory or exceeds the maximum CPU time of one hour.

Another approach to solving the LSFRP is proposed by Kelareva, Tierney and Kilby [13]. In

this study, they solve the full LSFRP with SOS opportunities, however they do not incorporate

cargo ﬂows into their model. A constraint programming (CP) method is used with lazy clause

generation, and is tested against the MIP in [21]. After testing the diﬀerent models on a data set,

the CP method is found to be faster than the MIP for all instances. However, this only occurs after

4

choosing a search strategy for the particular problem. The authors note that, without suﬃcient

understanding of the problem and of CP modelling techniques, it is diﬃcult to choose a search

strategy that is both fast and successfully ﬁnds optimal solutions. Furthermore, the CP method

can not be extended to allow pre-computations or chaining of SOS or opportunities to carry empty

cargo containers.

The most recent study on the LSFRP is by Tierney et. al. [20], which expands on the work by

Tierney and Jensen from 2012 [22]. They improve the model, provide a public data set, and use

a heuristic approach. This model was able to incorporate many complex aspects of the LSFRP,

including SOS opportunities, phase-in/phase-out requirements, and ﬂexible arcs. Some of these

(SOS opportunities and phase-in/phase-out requirements) are processed into the graph structure,

along with sailing costs and cabotage restrictions. The MIP forms a “disjoint path problem in

which a fractional multi-commodity ﬂow is allowed to ﬂow over arcs in the vessel paths, along with

a small scheduling component in the ﬂexible nodes” [20].

2. Problem description and model formulation

The LSFRP consists of ﬁnding sequences of activities that move vessels between services in a

liner shipping network, while maximising proﬁt by trading oﬀ ship moving costs and cargo ﬂow

incomes [20]. “Liner shipping services are composed of multiple slots, each of which represents a

cycle that is assigned to a particular vessel”. The slots contain nodes or ports which must be visited

by vessels at speciﬁc times in sequence. When a vessel is assigned a slot, it sails to all of its ports in

order and delivers its cargo. Figure 1 shows an example of a service with three slots (represented

by the diﬀerently styled lines in the graph) and ﬁve ports (a, b, c, d, e). The diagram shows that

each slot takes three weeks to return to the start of the cycle, so three ships would be needed to

run this service weekly. An LSFRP needs to be solved when we are transitioning a ﬂeet from one

set of services to a new one.

Another aspect of repositioning that needs to be taken into account is the time constraints.

The time at which a ship may begin repositioning is known as the phase-out time. The ship must

ﬁnish repositioning by the phase-in time of the goal service. In between these two times the ship

is available for repositioning and is able to undertake a number of activities to both reach its goal

service and reduce costs. An example of this can be seen in Figure 1. The latest phase in time is

5

Figure 1: A time-space graph of a service with three vessels. Image sourced from Tierney et. al. (2014) [20]

at port c in week 2 and the phase out time is after all the hollow circles [20]. Between these points

a vessel may undertake repositioning activities.

The LSFRP is best described using Figure 2. This shows a ship which needs to be repositioned

from its initial service (Chennai Express) to a goal service (Intra-WCSA). During repositioning

the vessel can deliver cargo to ports to oﬀset the cost of moving the ship, thus cargo ﬂows are an

important aspect of the problem. One way to do this is to take advantage of sail-on-service (SOS)

opportunities, which are situations in which a repositioning ship can replace an on-service vessel

for part of its service in order to reduce costs (by not having two ships sailing on the same course

unnecessarily). There are two main methods of performing a SOS opportunity: transhipping, where

all cargo from the on-service ship is moved onto the repositioning ship at a port, or parallel sailing,

where the two ships visit the same ports sequentially and the on-service vessel only unloads cargo,

while the repositioning vessel only loads cargo.

6

Figure 2: Liner shipping network. Image sourced from Tierney et. al. (2014) [20]

2.0.1. Empty containers and ﬂexible arcs

Another way for ships to oﬀset the cost of repositioning is to transport empty containers from

ports with an empty equipment surplus to ports with a deﬁcit. The revenue from performing this

type of activity is calculated as an approximation of the savings from moving the equipment now,

as opposed to at a later date, potentially through a more expensive channel. There are two types of

cargo considered in this problem: dry and refrigerated (reefer). We must diﬀerentiate between the

two types, since when transporting cargo the reefer containers must be plugged into a power outlet,

which means that ships will only have a limited reefer capacity. This is not the case when moving

empty equipment, however we still make the distinction as the deﬁcit we are supplying may be for

a speciﬁc container type. We use the term ﬂexible visits to denote ports with empty equipment

available, but no actual cargo demands. These ﬂexible visits are travelled to via ﬂexible arcs.

There are also various restrictions placed on the cargo carried by repositioning ships such as

trade zones. Trade zones are countries or groups of countries with trade agreements. Often cargo

cannot ﬂow between trade zones without violating these agreements. To avoid the movement of

cargo violating these trade zone restrictions, the law, or a customer contract, repositioning ships

are disallowed from crossing into other trade zones while carrying cargo. A similar restriction is

known as a cabotage restriction, which prevents international ships from performing domestic cargo

services [20]. These are all aspects which need to be considered when modelling the LSFRP. Most

7

of these restrictions have been incorporated directly into the network of potential ship paths, so

they will not be represented in the MIP formulation.

For the original model formulation, we refer the reader to the paper by Tierney et. al. (2014)

[20]. We have maintained consistency in notation from previous studies. We now present a reduced

formulation of the LSFRP.

2.1. Reduced MIP

Starting with the MIP model described in Tierney et. al. (2014) [20], a reduced version is

formulated that does not incorporate ﬂexible arcs or empty equipment. These aspects of the problem

are omitted for simplicity to allow us to explore the core structure of the LSFRP without added

complexity. By noting the percentage of the public data set that does not include these additional

requirements (66%), it can be seen that the reduced problem is still able to provide much value,

as the majority of the instances do not contain the more complex aspects of the problem. There

are more reasons why omitting these aspects of the problem are reasonable, some of which will be

explored in Section 5.

Parameters

S
V (cid:48)
A(cid:48)

Q

M

Set of ships.

Set of visits minus the graph sink.

Set of arcs minus those arcs connecting to the graph sink,
i.e., (i, j) ∈ A, i, j ∈ V (cid:48).
Set of cargo types; Q = {dc, rf}.
Set of demand triplets of the form (o, d, q), where o ∈ V (cid:48), d ⊆ V (cid:48),
and q ∈ Q are the origin visit, possible destination visits, and the

, (M Dest

i

i

M Orig
s ∈ R+
uq
vs ∈ V (cid:48)

cargo type respectively.

) ⊆ M Set of demands with an origin (destination) visit i ∈ V .

Capacity of vessel s for cargo type q ∈ Q.
Starting visit of ship s ∈ S.

8

r(o,d,q) ∈ R+

sij ∈ R+
cSail
i ∈ R+
cMv
si ∈ R
cPort
a(o,d,q) ∈ R+
In(i) ⊆ V (cid:48)
Out(i) ⊆ V (cid:48)
τ ∈ V

Variables

Amount of revenue gained per TEU of loaded containers carried

for the demand triplet.
Fixed cost of vessel s utilizing are (i, j) ∈ A(cid:48).
Cost to move a single TEU on or oﬀ a ship at visit i ∈ V (cid:48).
Port fee associated with vessel s at visit i ∈ V (cid:48).

Amount of demand available for the demand triplet.
Set of visits with an arc connecting to visit i ∈ V .
Set of visits receiving an arc from visit i ∈ V .

Graph sink, which is not an actual visit.

∈ R+
x(o,d,q)
ij
ij ∈ {0, 1}
ys

0 Amount of ﬂow of demand triplet (o, d, q) ∈ M on (i, j) ∈ A(cid:48).

Indication of whether vessel s is sailing on arc (i, j) ∈ A.

Objective and Constraints

(cid:88)

j∈d

(cid:88)
ij − (cid:88)

i∈In(j)

(r(o,d,q) − cM v

(cid:88)

j

o − cM v
(cid:88)

cPort
sj ys
ij



)x(o,d,q)

ij

(cid:41)

(i,j)∈A(cid:48)

j∈V (cid:48)

i∈In(j)

s∈S

∀j ∈ V (cid:48);

∀s ∈ S, i = vs;

max

s.t.

s∈S

(o,d,q)∈M

(cid:40) (cid:88)
(cid:88)
−(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

j∈Out(i)

i∈In(τ )

i∈In(j)

i∈In(j)

s∈S

(o,d,rf )∈M

cSail
sij ys

ij ≤ 1,
ys

ys
ij = 1,

(cid:88)
ij − (cid:88)

s∈S

ys

iτ = |S|;
ys

i∈Out(j)

x(o,d,rf )
ij

(1)

(2)

(3)

(4)

(5)

(6)

(7)

∀j ∈ V (cid:48)\(cid:91)

s∈S

vs, s ∈ S;

ys
ij = 0,

≤(cid:88)

s∈S

urf
s ys
ij,

∀(i, j) ∈ A(cid:48);

9

(o,d,q)∈M

(cid:88)
(cid:88)
(cid:88)

i∈Out(o)

i∈In(j)

∀(i, j) ∈ A(cid:48);

s ys
udc
ij,

≤(cid:88)
≤ a(o,d,q) (cid:88)
− (cid:88)

s∈S

i∈Out(o)
x(o,d,q)
jk

k∈Out(j)

(cid:88)

s∈S

= 0,

x(o,d,q)
ij

x(o,d,q)
oi

x(o,d,q)
ij

ys
oi,

∀(o, d, q) ∈ M ;

∀(o, d, q) ∈ M, j ∈ V (cid:48)\(o ∪ d);

(8)

(9)

(10)

The objective function maximises the proﬁt of the shipping company. The ﬁrst line (1) calculates

the proﬁt from delivering the cargo by adding the revenue minus the cost to transport the cargo on

and oﬀ the ship. This is multiplied by the amount of cargo carried. The second line of the objective

function (2) subtracts the sum of the sailing costs and the port fees for each port visited by each

ship.

Constraint (3) ensures that only one ship visits each port, while (4-6) conserve the ﬂow of each

ship from its starting port to the sink node. If a ship uses an arc, that arc is assigned a reefer

capacity in (7) and a total capacity in (8). Constraint (9) ensures that cargo can only ﬂow along

an arc if it is on a ship. Constraint (10) conserves the ﬂow of cargo from its source node to its

destination by ensuring that if it enters an intermediate node, it must also exit that node.

The reduced MIP only uses the x(o,d,q)

ij variables, as the others pertain to ﬂexible arcs,
empty equipment or entrance/exit times. As such, constraints and terms referring to the other

and ys

ij

variables are omitted from the reduced formulation. With the use of the Gurobi solver package [10]

this model was implemented and solved using a subset of the public data instances (those which
did not contain ﬂexible arcs). Pre-processing ensures that only the x(o,d,q)

variables which can be

ij

non-zero are added to the model. That is, there exists a path from the origin to one of the demand

points passing through arc (i,j).

3. Improved solution techniques for LSFRP

We have made a number of improvements to the solution of the LSFRP, which we describe

in this section. The reduced MIP is our starting point, which eliminates some complexity while

preserving the core components of the problem. We then tighten some constraints and reformulate

the model using disaggregation, which increases the number of variables we solve for, but results in

a tighter bound. Next, we apply column generation, which allows us to solve all previously unsolved

instances within a large time window. Finally, we apply lazy constraints, which greatly simpliﬁes

the problem, to the point where all instances are solved to optimality within four minutes.

10

3.1. Tighter Bound and revised formulation

While the reduced MIP is able to replicate the results shown in Tierney et. al. (2014) [20], it is

still unable to solve the last seven instances in the public data set. We note that one of the reasons

the MIP struggles on larger problems is because the linear relaxation of the problem generates

solutions in which fractional ship variables are used to transport all of a demand triplet. In order

to prevent this an additional set of constraints is added:

≤ a(o,d,q)(cid:88)

s∈S

x(o,d,q)
ij

ij ∀(i, j) ∈ A(cid:48), (o, d, q) ∈ M ;
ys

(9a)

These constraints prevent ships from moving a greater fraction of the demand triplet than

the fraction of the ship used. This is a disaggregated version of constraint (9) from the reduced
formulation, as it is no longer summed over i ∈ Out(o). This is allowed since only one ship can
visit any node, and thus only one arc leaving each node will have a non-zero value of ys
ij in any
integer solution. By the properties of disaggregation this must give a tighter bound for the linear

relaxation. This improved bound yielded strong improvement on some larger instances, however it

is still unable to solve ﬁve instances to optimality within the timeout limit.

Despite these tighter constraints, fractional parts of demand triplets can still be shipped, as

the new constraints apply to all the ships rather than individual ships (the RHS is summed over

s). To combat this, we reformulate the model for individual ships by adding a ship index to the

x variables. As stated earlier, an important aspect of the problem to note is that the paths need

to be node distinct, meaning that only one ship can visit each node. This property means that no

product can be transshipped, and allows the ship index to be added to the x variables. The revised
formulation with xs,(o,d,q)

variables is shown below.

ij

Variables

xs,(o,d,q)
ij
ij ∈ {0, 1}
ys

∈ R+

0 Amount of ﬂow of demand triplet (o, d, q) ∈ M on (i, j) ∈ A(cid:48) on s ∈ S.

Indication of whether vessel s is sailing on arc (i, j) ∈ A.

Objective and Constraints

(cid:40) (cid:88)

(cid:88)

(cid:88)

(cid:88)

(o,d,q)∈M

s∈S

j∈d

i∈In(j)

max

(r(o,d,q) − cM v

o − cM v

j

)xs,(o,d,q)

ij

(11)

11

ij − (cid:88)

j∈V (cid:48)

cSail
sij ys

(cid:41)

(cid:88)

(cid:88)

i∈In(j)

s∈S

cPort
sj ys
ij

∀j ∈ V (cid:48);

∀s ∈ S, i = vs;

∀j ∈ V (cid:48)\(cid:91)

s∈S

vs, s ∈ S;

ys
ji = 0,

≤ urf

s ys
ij,

∀(i, j) ∈ A(cid:48), s ∈ S;

∀(i, j) ∈ A(cid:48), s ∈ S;

s.t.

(i,j)∈A(cid:48)

ij ≤ 1,
ys

ys
ij = 1,

(cid:88)
ij − (cid:88)

s∈S

ys

iτ = |S|;
ys

i∈Out(j)
xs,(o,d,rf )
ij

s∈S

s∈S

i∈In(j)

j∈Out(i)

(cid:88)
−(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

(o,d,rf )∈M

(o,d,q)∈M

i∈Out(o)

i∈In(τ )

i∈In(j)

i∈In(j)
xs,(o,d,q)
ij

xs,(o,d,q)
ij

xs,(o,d,q)
oi

xs,(o,d,q)
ij

≤ udc

s ys
ij,

≤ a(o,d,q) (cid:88)
− (cid:88)

i∈Out(o)
xs,(o,d,q)
jk

k∈Out(j)

(12)

(13)

(14)

(15)

(16)

(17)

(18)

(19)

ys
oi,

∀(o, d, q) ∈ M, s ∈ S;

= 0,

∀(o, d, q) ∈ M, j ∈ V (cid:48)\(o ∪ d), s ∈ S;

(20)

≤ ys

ij min(a(o,d,q), uq

s),

∀(i, j) ∈ A(cid:48), s ∈ S, (o, d, q) ∈ M ;

(21)

The objective value is unchanged from the reduced MIP, except that now the x variables are
also summed over all ships s ∈ S. Constraints (13-16) are identical to the original formulation, and
constraints (17-20) are disaggregated versions of constraints (7-10), so there is now one constraint

for each ship. Finally, constraint (21) is a disaggregated version of constraint (9a), which ensures

that for each ship, and on each arc, no more cargo can be transported than is either available or

able to be transported on the ship.

While this formulation does introduce more variables into the problem, it also provides a linear

relaxation with a tighter bound, which allows it to solve much faster for larger instances. The

results of this new MIP formulation are reported in Section 4.2.

3.2. Column Generation

One of the main reasons that larger instances are unsolvable when using the presented MIP

formulations is because the problems are too large to consider all variables explicitly and still be

solved within a reasonable time frame. The last three instances are so large that the LP relaxation

can not be solved using any of the MIP formulations within one hour. To combat this issue,

12

composite variables and the technique of column generation are employed to reduce the number of

variables considered at one time [3].

First the MIP is decomposed into a master problem and sub-problems (one for each ship). The

master problem is an IP with every possible composite variable, which represent paths of ships

through the network. This is then transformed into the reduced master problem (RMP), which

contains a reduced set of the composite variables. We begin by solving the LP relaxation of the

RMP, which is an LP that contains two constraints. The ﬁrst says each ship is used exactly once,

and the second says each node is used at most once. The variables for the master problem are

paths through the graph for certain ships. The sub-problems are equivalent to the revised MIP on

a ship-by-ship basis, with the dual variables associated with the master problem in the objective

function. Since the path of each ship is decided by the master problem, the constraints on each

node being visited only once are removed from the sub-problems. Since there is one sub-problem

per ship, we do not need to sum over the ships. The RMP is described as:

Parameters.

P
Csp ∈ R+

δisp ∈ {0, 1}

Variables.

Set of paths.

Proﬁt of vessel s sailing on path p (revenue from moving product

less the cost of the path).
1 if vessel s sailing on path p goes through node i ∈ V (cid:48).

Zsp ∈ {0, 1}

1 if vessel s sails on path p ∈ P , 0 otherwise.

Objective and Constraints.

max

s.t.

(cid:88)
(cid:88)
(cid:88)

p∈P

p∈P

(cid:88)

s∈S

CspZsp

Zsp = 1,

(cid:88)

∀s ∈ S

δispZsp ≤ 1,

∀i ∈ V (cid:48)

p∈P

s∈S

(22)

(23)

(24)

After setting up the models, an initial solution to the master problem is generated. This is

achieved using a modiﬁed version of the sub-problems. First the number of possible paths through

13

the graph for each ship is calculated, then the ships are ordered from those with the least to those

with the most paths. The sub-problems are solved in this order using the objective function from

the revised formulation, with s as a constant. After each subproblem is solved, the nodes used in

the solution are excluded from subsequent sub-problems. This heuristic procedure resulted in a

feasible starting solution for each instance, though our code does allow for high cost dummy paths

direct from source to sink if this procedure fails for any ship. The paths generated from these sub-

problems are then added to the master problem as columns. The master problem is then solved

using these columns.

In the main loop of the algorithm, the sub-problems are solved in the reverse order than before,

and if a new column is found, it is added to the master problem, which is then re-solved. If all

sub-problems are solved without any new column being added to the master problem, the algorithm

terminates and the optimal solution has been found. Due to speciﬁc properties of this problem, the

column generation master problem gives integer optimal solutions, so a branch and bound algorithm

is not required. The reasons for this are explored in Section 5.1.

3.3. Lazy Constraints

The ﬁnal improvement we present for the solution of the LSFRP involves using lazy constraints

to dramatically reduce the size of the column generation sub-problems. Each node can be visited by

at most one ship, the ship movement graph is acyclic, and no transshipment can occur. Therefore,

if any two demands are ever carried together at any time, then they will always be carried together.

This is because each demand has a single port of origin, and that port cannot be visited twice.

Consider a ship that visits port A and loads some demand from that port. The ship then

proceeds to port B where it loads another demand from this port. Finally, the ship then proceeds

to port C. Because the demands from ports A and B were carried together, the sum of demands

from A and B cannot exceed the capacity of the ship on this arc. If demand B is unloaded at port

C, it will not be possible to return to port A to load more demand of type A, and vice versa.

This means that rather than solving for the ﬂow along each arc, we can instead solve for the

total ﬂow of each demand, and add extra constraints enforcing shared capacity where it is exceeded.
We deﬁne a new set ¯Ms, which is the set of all demands (o, d, q) which can be moved by ship s. By
extension, ¯V Orig
is the set of all nodes from which ship s can pick up a demand of type q from ¯Ms,

sq

that is:

14

sq = {o|(o, d, q) ∈ ¯Ms}
¯V Orig

Finally, we denote the set of all arcs (i, j) ∈ A(cid:48) across which a demand triple (o, d, q) ∈ M can
possibly travel as A(o,d,q). We also use the set M Orig
from the original formulation, which is the
set of demands with an origin visit i ∈ V . Starting with the revised formulation from Section 3.1,
we modify the x variables so that they are no longer indexed by arc. That is:

i

x(o,d,q)
s

∈ R+

0 Amount of ﬂow of demand triplet (o, d, q) ∈ M on ship s ∈ S.

We remove constraints (17-21) and replace them with the following:

x(k,d,q)
s

udc
s ys

kj,

x(k,d,rf )
s

urf
s ys

kj,

∀k ∈ (cid:91)

q∈Q

¯V Orig
sq

, s ∈ S;

∀k ∈ ¯V Orig

s,rf , s ∈ S;

(cid:88)
(cid:88)

(k,d,q)∈M Orig

k

k

(k,d,rf )∈M Orig
≤ min

x(o,d,q)
s

(cid:16)
(cid:16)

j∈Out(k)
(k,j)∈A(cid:48)

≤ (cid:88)
≤ (cid:88)
(cid:17) (cid:88)
(cid:17)(cid:88)

j∈Out(k)
(k,j)∈A(cid:48)

j∈Out(o)

(o,j)∈A(o,d,q)

(cid:88)

a(o,d,q), uq
s

oj ∀(o, d, q) ∈ M, s ∈ S;
ys

x(o,d,q)
s

≤ min

a(o,d,q), uq
s

ij ∀(o, d, q) ∈ M, s ∈ S;
ys

j∈d

i∈In(j)

(i,j)∈A(o,d,q)

(25)

(26)

(27)

(28)

Constraints (25-26) ensure that the sum of demands loaded at any node cannot exceed the

capacity of the ship, and speciﬁcally for reefer cargo. Constraints (27-28) ensure that a demand can

only be carried if the ship passes through the demand’s origin and one of its destinations, and caps

the ﬂow of each demand by the minimum of the demand’s availability and the ship’s capacity for

the speciﬁc type. These constraints are the bare-basic constraints that ensure that cargo can only

be carried if the ship visits the origin and a destination of the demand, and empty ships will not

load more than their capacity. However, if a ship is already carrying other demands, the capacity

of the ship might be breached without violating any of these constraints. This is where we add lazy

constraints.

While solving a sub-problem, candidate integer solutions will be found by the MIP solver at

nodes in the branch-and-bound tree. When a candidate solution is found, we check to see if the

15

capacity of the ship is violated at any stage, speciﬁcally at any location where additional demands

are loaded. We follow the path of the ship through the network, keeping track of all demands that

are currently on the ship (i.e. those that have been loaded at their origin but not yet unloaded at

a destination), and if, at a particular node i, the sum of the demands currently on the ship exceeds

the capacity of the ship (for any type), we then add a constraint of the form:

(cid:88)

(o,d,q)∈M
j∈Out(i)
(i,j)∈A(o,d,q)

x(o,d,q)
s

≤ udc

s

(29)

(cid:88)

(o,d,rf )∈M
j∈Out(i)
(i,j)∈A(o,d,rf )

x(o,d,rf )
s

≤ urf

s

(30)

that is, the sum of the ﬂow of all demands that can pass through node i must be less than

the capacity of the ship, and also speciﬁcally for reefer demands. After a sub-problem has been

solved, we take the lazy constraints that were generated and add them to the sub-problem as

regular constraints for the next iteration. By implementing these constraints, the model is now

signiﬁcantly smaller and easier to solve, as can be found in Section 5.4. The results of running this

implementation can be found in Section 4.4.

3.3.1. Splitting demand triples

While it’s true for a speciﬁc path through the network that if two demands are carried together

at any time, then they will be carried together until one is unloaded, that does not mean that the

two demands must be carried together in the ﬁrst place. This can occur if one of the demands

has more than one possible destination. Consider the example in Figure 3.3.1, where demand A

will be picked up from Origin A. There are two choices: either proceed directly to Origin B, still

carrying cargo A, and pick up cargo B, or proceed to destination A1, unload cargo A and continue

to Origin B. In the ﬁrst case, a constraint limiting the combined capacity of demands A and B may

be imposed, where it is unnecessary if the second option is chosen.

This means that the variables for demand A must be separated, which involves looking for any

demand triples (o, d, q) that ﬁt the following criteria:

16

• There are two destinations d1, d2 ∈ d such that d2 is reachable from d1.
• There exists another demand m∗ with origin o∗ such that o∗ is reachable from d1, and d2 is

reachable from o∗.

• There exists a destination d∗ of demand m∗ such that d∗ is reachable from d2.
• There exists a path between the origins o and o∗ that does not pass through d1.

If such conditions are met, then the variables for x(o,d,q)

s

are split up into x(o,di,q)

s

∀di ∈ d, and

an additional constraint is added: (cid:88)

di∈d

x(o,di,q)
s

≤ a(o,d,q)

(31)

This ensures that we will not add any lazy constraints to the problem which will unnecessarily

over-constrain the problem. Each demand triple has an associated revenue and amount, both of

which will be inherited by the split variables.

3.3.2. Modiﬁcation to the objective function

Because we are no longer explicitly calculating which arcs the cargo travels along, we cannot

easily determine which destination it is being delivered to. Our implementation assumes that cargo

is unloaded at the earliest possible time, that is, if the node i is visited, all demands (o, d, q) where
i ∈ d will be unloaded. In the public data set, each destination in a demand triple is the same
physical port, the diﬀerence is the delivery time. This means that the unloading cost of each demand

triple is the same for all destinations. This allows us to take the unload cost of any destination

from the demand triple. If the destinations had diﬀerent unload costs, we would have to split the

demand triple as discussed in Section 3.3.1.

Figure 3: A scenario where the variables for a particular demand triple need to be separated.

17

4. Results

Here we consider the results from Tierney et. al. (2014) [20] and Tyler (2015) [23], and compare

them to our results. We use the same code as Tyler, however since their results were calculated,

Gurobi [10] released version 6.5 which led to signiﬁcant improvements to the solve time of large

MIPs. We are using a similar computer to Tyler for the reduced MIP, and report their comparison

to Tierney et. al., as well as our comparison to Tyler. The machine on which the optimisation was

run uses Windows 8.1 Enterprise, Python 2.7.10 and Gurobi 6.5, with an Intel i7-3770 (3.40 GHz)

running 8 threads with 8 GB of RAM. All software involved is 64-bit.

Tierney et. al.

tested this formulation on a public data set of 44 instances of increasing

complexity. The number of ships ranged from 3 to 11, with between 30 and 379 ports and 94 to

11979 arcs. With a time limit of 1 hour and a memory limit of 10GB, the MIP implemented in

CPLEX 12.4 was able to solve the ﬁrst 33 instances to optimality.

4.1. Comparison of reduced model with original

Table 1 shows the results of the reduced MIP compared with the results reported in the paper

by Tierney et al.. Instances are left to run for 1 hour, and if no solution is found within that time

they were said to have timed out. Instances that run out of memory are denoted by ‘Mem’. In the
table |M| represents the number of demands, |V | the number of ports, |A| the number of arcs and
|S| the number of ships.

As can be seen in Table 1 the reduced MIP formulation was able to replicate the results from

Tierney et. al. for all instances. The reduced MIP appears to run much faster than that used by

Tierney et. al. (2014) [20], however this is believed to be caused by an updated version of Gurobi

[10] and diﬀerences in computing power, rather than diﬀerences in the model itself. Since only the

smaller models are solved within the time limit, there is not much diﬀerence between the run times

reported in Tyler (2015) [23] and our run times. The times achieved by our reduced MIP will serve

as a baseline for comparison with the other models we present.

4.2. Revised Formulation with tighter bound

As can be seen in Table 2, the revised formulation with the tighter bound enables the MIP

to solve six more instances to optimality. All solved instances are solved within 10 minutes using

this formulation, which does not appear to have a signiﬁcant eﬀect on the run time of the model

18

Table 1: Results of reduced MIP run on public data instances from Tierney et. al. (2014) [20]

|S|

|V |

Instance

ID

repos1p

repos2p

repos3p

repos4p

repos5p

repos6p

repos7p

repos10p

repos12p

repos13p

repos15p

repos16p

repos17p

repos18p

repos20p

repos24p

repos25p

repos27p

repos28p

repos30p

repos31p

repos32p

repos34p

repos36p

repos39p

repos41p

repos42p

repos43p

repos44p

|A|

|M| Tierney MIP Tyler MIP Reduced MIP

time (s)

time (s)

time (s)

0.07

0.07

0.06

0.07

0.11

0.11

0.09

7.25

14.94

16.53

0.29

0.42

1.55

1.25

3.34

0.47

0.57

4.43

6.92

8.15

19.02

10.38

Time

Time

Time

Time

Time

Time

Time

0.23

0.38

0.25

0.30

0.29

0.27

0.26

4.26

11.94

10.66

0.40

0.52

1.52

1.25

2.86

0.58

0.73

1.79

1.91

4.59

9.82

6.96

Time

Time

Time

Time

Time

Time

Time

3

3

3

3

3

3

3

4

4

4

5

5

6

6

6

7

7

7

7

8

8

8

9

9

9

10

11

11

11

36

36

38

42

51

51

54

58

74

80

71

106

102

135

142

75

77

79

90

126

130

144

150

150

151

185

270

270

196

499

603

632

355

420

1198

1439

1865

482

496

571

618

1450

1362

1501

304

10577

28

28

24

20

22

22

46

125

145

155

173

320

75

87

80

154

156

188

189

265

152

170

344

364

11972

1048

379

11666

1109

249

279

8051

375

6596

1423

320

13058

1013

328

13705

1108

0.06

0.06

0.04

0.04

0.07

0.08

0.08

74.85

106.63

99.81

0.47

1.08

4.64

6.79

13.84

2.23

3.19

1394.44

1099.87

307.12

57.4

65.51

Time

Mem

Mem

Time

Time

Mem

Mem

19

for smaller instances. The main beneﬁt is that all but three of the hardest instances are solved to

optimality, something which has not been achieved before. Therefore the revised formulation is a

signiﬁcant improvement over previous formulations for the larger instances of the LSFRP.

4.3. Column Generation

Table 2 shows the results of using column generation implemented in Python using Gurobi.

Tyler’s results using column generation report the approach is able to ﬁnd optimal solutions to

all instances in under 7.5 hrs [23]. The update to Gurobi 6.5 results in all instances being solved

to optimality in under 2.7 hours. With the exception of repos43p and repos44p, all instances are

solved within the timeout limit, with the slowest taking approximately 20 minutes, and the majority

solving within minutes or seconds. For the larger instances (repos34p-repos44p), column generation

is signiﬁcantly faster than the other approaches (excluding repos41p which is slightly slower than

the revised MIP). In the best case (repos34p) the column generation solves the problem almost

three times faster than the revised formulation.

For the two instances that remain unsolved after the timeout limit, but can be solved within 8

hours, Tyler performs a comparison test with the revised MIP formulation [23]. This MIP is allowed

to run on these instances with a new timeout limit of 8 hours, in order to determine whether it is

able to solve these problems in a comparable time frame. However, after 8 hours both problems are

still in the preprocessing stage of Gurobi’s solver, and have not obtained a solution or an optimality

gap. Therefore it can be concluded that for these large instances the only feasible technique for

solving them is column generation.

4.4. Lazy constraints

All instances are solved to optimality using the lazy constraints formulation, and the optimal

objective values all agreed with past results. The only comparison we are interested in is the

diﬀerence in run-time between the diﬀerent formulations. Table 2 is a comparison between all

methods presented in this paper.

Because of the added work setting up column generation, the smaller instances for the lazy

constraints method all take longer to run compared to the reduced MIP. The real strength of this

formulation is that it scales far better than any other formulation presented previously. Where

instances repos43p and repos44p take hours to solve with column generation, using lazy constraints

20

Table 2: Comparison of solution times for diﬀerent implementations

Instance

Reduced MIP

Revised MIP

Column Generation

Lazy Constraints

ID

repos1p

repos2p

repos3p

repos4p

repos5p

repos6p

repos7p

repos10p

repos12p

repos13p

repos14p

repos15p

repos16p

repos17p

repos18p

repos19p

repos20p

repos21p

repos22p

repos24p

repos25p

repos26p

repos27p

repos28p

repos29p

repos30p

repos31p

repos32p

repos34p

repos36p

repos37p

repos39p

repos40p

repos41p

repos42p

repos43p

repos44p

time (s)

time (s)

time (s)

time (s)

0.23

0.38

0.25

0.30

0.29

0.27

0.26

4.26

11.94

10.66

10.34

0.40

0.52

1.52

1.25

1.18

2.86

3.14

3.33

0.58

0.73

0.63

1.79

1.91

2.34

4.59

9.82

6.96

Time

Time

Time

Time

Time

Time

Time

Time

Time

0.25

0.28

0.25

0.34

0.25

0.30

0.26

1.37

1.88

2.02

2.07

0.77

1.03

1.85

2.50

2.54

3.07

3.13

3.13

1.23

1.35

1.34

2.63

2.73

2.85

3.09

6.95

3.89

251.01

493.70

447.98

539.08

541.28

88.84

Time

Time

Time

1.00

0.53

0.30

0.78

0.33

0.34

0.66

3.06

4.58

3.75

3.61

1.76

2.27

3.06

3.36

3.32

5.69

5.64

6.20

2.19

1.80

2.10

3.59

3.38

3.52

5.83

12.19

6.42

91.51

228.88

263.02

374.75

370.84

113.24

1271.69

Time (9632.16)

Time (8924.85)

21

0.44

0.50

0.33

0.75

0.44

0.34

0.44

1.02

1.47

1.65

1.64

1.64

1.42

1.80

2.25

2.36

2.38

2.70

2.86

1.47

1.69

1.38

1.91

2.13

1.70

2.78

6.88

3.19

19.04

38.25

33.63

35.12

29.06

17.00

57.41

223.21

222.63

Table 3: Number of ships aﬀected by lazy constraints, and number of constraints added for each instance.

Number of Ships

Number of Constraints

Instance

Dry

Reef

Dry

Reef

repos10p-repos14p

repos15p-repos16p

repos36p

repos39p

repos42p

repos43p

repos44p

1

0

0

0

3

2

2

0

3

1

1

10

10

10

4

0

0

0

8

4

5

0

7

1

2

21

22

27

means the problems can be solved within four minutes. Since these larger instances are more likely

to be useful in real-world situations, this formulation is by far the best for solving the LSFRP.

Another interesting result is the number of lazy constraints added during the solve process. For

almost three in four instances, no lazy constraints are added at all. This means that the small

formulation without ﬂow variables for every arc is suﬃcient to solve the problem. The instances

which most beneﬁted from the lazy constraints formulation (repos42p-repos44p) only need at most

30 constraints for any cargo type to solve the problem to optimality. Compare this to the number

of constraints that were removed from the problem, and it becomes clear why lazy constraints are

so powerful when applied to this problem. A comparison of model sizes can be found in Section

5.4.

Table 3 shows, for the instances where lazy constraints are added, how many ships need them

and how many constraints are added in total for the diﬀerent cargo types. For all instances except

the three largest, no more than seven additional constraints are required before an optimal solution

was found. The reefer cargo is also more likely to have lazy constraints imposed because there are

signiﬁcantly fewer reefer spots on each ship compared to the dry cargo.

22

Figure 4: Example of network modiﬁcation to turn column generation master problem into a pure network ﬂow

problem

5. Discussion

5.1. Proof of integer solutions to column generation

One reason column generation is so eﬀective for this problem is because it always generates

integer optimal solutions. This means we don’t need to use a branch-and-bound algorithm, which

makes the whole solution process much faster. After making a few observations about the nature

of our problem, we will prove that solutions to the column generation are always integer.

Observation 1. The LSFRP with a single ship type and no product ﬂow can be modelled as a pure

network ﬂow problem.

“The pure network ﬂow problem can be deﬁned by a given set of arcs and a given set of nodes

with known upper bounds and cost parameters for each arc, and ﬁxed external ﬂow for each node”

[12]. Now consider the LSFRP with a single ship type. This implies that the cost of travelling

along any arc is the same for all ships. If we ignore the product ﬂow in this problem, then we can

consider the problem to have a set of source nodes vs which each have a supply of 1 unit, a sink

node τ which has a demand equal to the number of ships, and a set of intermediate nodes. These

nodes can be split into In and Out nodes, with an arc connecting them which has a capacity of 1.

The graphical representation of this can be seen in Figure 4. We are now solving a pure network

ﬂow problem where all constant terms are integer, which will give us the node-distinct paths of

minimum cost, along which the ships will travel.

Observation 2. Pure network ﬂow problems have integer values at all of their extreme points

23

It is known that, if the constant values of a network ﬂow problem are all integer, then the

extreme points will be integer-valued [11, 12, 8, 14].

Theorem 1. The extreme points of the column generation master problem for a single ship type

with or without cargo ﬂows are all integer valued.

Proof. Consider ﬁrst the case without cargo ﬂows and with one ship type. Since we can reformulate

the master problem as a pure network ﬂow problem with integer-valued constraints, the extreme

points will all be integer. If we now consider the case where we have product ﬂow, the constraints

of the master problem remain unchanged. While the objective function will change, which means

a diﬀerent extreme point may be optimal, all extreme points are integer, so the column generation

solution will still be integer.

For Theorem 1 to apply, we require a “single ship type”. This means that all ships have the

same capacity and costs for all arcs. We note that this is the case for all but three instances in the

public data set. In each of these instances there is one ship that is diﬀerent. While it is possible

that these could give non-integer solutions to the LP relaxation of the master problem, in practice

they did not. To handle this possibility, we would need to modify our code to branch on the ship

type that visits a node. Any continuous solution that has only one ship type visiting each node can

be split into a separate solution for each ship type. Theorem 1 would then hold for each ship type,

and thus the optimal solution will be integer.

5.2. Empty cargo ﬂows in the public data set

As described in Tierney et. al. (2014) [20], the next step in this problem is to include the

possibility of moving empty cargo containers for extra proﬁt. This is a natural extension of the

model proposed previously, except now instead of having a one-to-many delivery system as with the

standard demands, we have a many-to-many system. This is because the capacity constraints on

empty containers treat them as identical. The only distinction between the container types comes

from the revenue earned, assuming one is more valuable than another. Our formulation of empty

cargo ﬂows is similar to that of the regular demands, except now we have one ﬂow variable for each

pair of supply-demand ports, where the demand port is reachable from the supply.

The parameters from Tierney et. al. (2014) [20] that are relevant to our implementation of

empty cargo ﬂows which have not previously been introduced are as follows:

24

V q+ ⊆ V (cid:48)
V q− ⊆ V (cid:48)
V q∗ ⊆ V (cid:48)

q ∈ R+
rVar

Set of visits with an equipment surplus of type q

Set of visits with an equipment deﬁcit of type q.

Set of visits with an equipment surplus or deﬁcit of type q
(V q∗
Revenue for each TEU of equipment of type q ∈ Q delivered.

= V q+ ∪ V q−

).

We denote the empty cargo ﬂows with variables of the form x(o,d)

sq

, which is the amount of

empty containers ﬂowing from origin o to destination d of type q on ship s. The lazy constraints

are modiﬁed appropriately, so now we keep track of which demands and how many empty containers

are on board, and if the capacity is violated a constraint is added to limit these ﬂows.

sq ≤ udc
x(o,d)

s

(32)

(cid:88)

(o,d,q)∈M
j∈Out(i)

Reach(i,j,o,d,q)

(cid:88)

(cid:88)

x(o,d,q)
s

+

q∈Q

(o,d)∈V q+×V q−
d∈ReachFrom(o)

Before presenting any results, we should note there is a problem with the public data set:

it is not proﬁtable to move empty containers. For all instances that have empty containers, the

combined cost of picking up and dropping oﬀ an empty container is greater than the revenue earned

from moving it. In three sets, the revenue value is 0, so even if there were no moving costs, there

is no incentive to transport empty containers. Of all sets, the most proﬁtable empty container

opportunity will add -22 per container to the objective value.

As this leads to the trivial solution of x(o,d)

sq = 0 for all empty cargo variables, we have decided

to change the amount of revenue associated with moving empty cargo containers. All previous

revenue values were either 0 or 150, but the moving costs are typically close to 150 each, so we

have decided upon a new revenue value of 300. This ensures that at least moving empty containers

does not result in a loss, and there are some proﬁtable opportunities for moving empty containers,

however not so proﬁtable as to replace the movement of actual, proﬁtable demands.

The results of this can be seen in Table 4. In some instances the increased revenue does not

make a signiﬁcant diﬀerence because proﬁtable demands are already being moved, or there are no

ship paths connecting (o, d) pairs. However, for the instances with more empty cargo opportunities,

25

Table 4: Comparison of objective value for original instances and when revenue for empty cargo ﬁxed at 300 units.

Instance

repos8p

repos9p

repos11p

repos14p

repos19p

repos21p

repos22p

repos23p

repos26p

repos29p

repos33p

repos35p

repos37p

repos38p

repos40p

Without empty cargo

With empty cargo

Objective (×105)

Time (s)

Objective (×105)

Time (s)

-8.21

-8.21

137.61

138.86

5.22

-11.85

-11.85

5.22

-53.13

-32.13

-10.92

138.54

139.31

160.02

161.53

0.60

0.58

0.88

1.24

2.06

2.17

2.71

2.09

1.28

1.68

3.32

26.30

32.96

38.47

28.27

-8.21

-8.21

137.61

138.86

15.23

-11.78

7.03

15.06

-53.13

-32.13

-10.92

157.79

163.73

179.27

185.03

1.04

1.24

1.94

2.84

4.05

4.80

6.33

4.14

3.31

4.21

5.93

114.47

147.15

142.00

191.76

Table 5: Number of lazy constraints added for instances with ﬁxed empty cargo revenue of 300

Number of Ships

Number of Constraints

Instance

repos19p

repos22p

repos23p

repos35p

repos37p

repos38p

repos40p

Dry

Reef

5

6

5

9

9

9

9

0

0

0

1

1

1

1

26

Dry

15

21

12

101

173

94

188

Reef

0

0

0

1

1

1

4

carrying empty cargo leads to higher proﬁts. Typically these empty containers only ﬁll previously

empty spaces rather than displacing demands. The biggest diﬀerence is in the number of lazy

constraints generated. Table 5 shows the instances which change when the revenue is increased.

There are seven instances with empty cargo ﬂows which do not add extra lazy constraints, however

for some of the larger instances the number of constraints added approaches 200. This is still an

insigniﬁcant number when compared to the size of the original formulation. All problem sets with

empty cargo ﬂows are solved using lazy constraints and column generation in less than four minutes.

As such, it is no more diﬃcult to consider the movement of empty containers in our formulation

with column generation and lazy constraints.

5.3. Flexible arcs

There is one ﬁnal feature of the Tierney et. al.

(2014) [20] model that has not yet been

implemented in our model: ﬂexible arcs. Tierney et. al. note in their paper that the “fuel

consumption of a ship is approximately a cubic function of the speed of the vessel”, however in

their model formulation the cost associated with sailing along a ﬂexible arc is a linear function of

sailing time, and thus has inverse relation with speed. Because the only constraints on the sailing

time are upper bounds, the optimal solution for travelling along ﬂexible arcs is always to sail as

fast as possible, thus minimising the time spent sailing on the arc.

Another consideration is that ﬂexible arcs only occur to connect ﬂexible visits to the rest of the

network. Flexible visits are ports which have no available demands, but do have a surplus or supply

of empty cargo. This means that to use ﬂexible arcs, the proﬁt from moving empty cargo must

be greater than the sum of the load and unload costs, plus the movement cost associated with the

ﬂexible arcs. For the original public data set, there are no proﬁtable situations for moving empty

cargo containers, including to ﬂexible destinations.

5.4. Comparison of model sizes

The real beneﬁt from lazy constraints comes from the dramatic reduction in model size, which

allows the solver to manipulate the problem much more eﬀectively. We can make a back-of-the-

envelope estimate of the contribution of the demand ﬂow variables to the size of the problem for

the original formulation, and compare it to ours with column generation and lazy constraints.

In the original formulation, there are at most |A(cid:48)||M| variables of the form x(o,d,q)

, where in
our implementation there are less than |M| variables in each sub-problem. Since there are only |S|

ij

27

Table 6: Comparison of model sizes for instance repos44p

Rows

Columns Non-zeros

Reduced MIP

171102

269796

1858378

Column Generation

sub-problems

Col. Gen. and Lazy

Constraints sub-problems

136391

76612

426025

1627

6715

33475

sub-problems, our formulation has at most |S||M| variables. For the largest instance (repos44p),
|A(cid:48)| ≈ 13700, |M| = 1108 and |S| = 11, so in our formulation we have tens of thousands of variables,
where the original has tens of millions.

Looking next at the number of constraints governing the x variables, the original formulation
has at most 2|A(cid:48)|+|M|•(|V (cid:48)|−1) constraints, where our formulation has fewer than 2|V (cid:48)|+3|M|+γ,
where γ is the number of lazy constraints added. As seen in Table 3, γ < 40 for even the largest
instance. Again looking at repos44p, where |V (cid:48)| = 327, our formulation has fewer than 4 × 103
constraints, where the original has over 3.8 × 105. This means our model is almost three orders of
magnitude smaller than the original formulation, which is why Gurobi has no problem solving the

largest instances.

Table 6 is a comparison of the actual model sizes for instance repos44p between our reduced

MIP, the sub-problems of the column generation implementation and of our reformulation using

lazy constraints. For the latter two cases, the numbers are averaged over all 11 sub-problems.

Remember that the models also include the ys

ij variables. These numbers are the reported model
size before Gurobi’s pre-solve stage, which typically removes up to half the rows from the column

generation formulation, and a few hundred rows and columns from the lazy constraints formulation.

This illustrates the signiﬁcant diﬀerence that using lazy constraints has made, in that the number

of rows, columns and non-zeros of the column generation sub-problems have been reduced by at

least one order of magnitude each.

28

6. Conclusion

The LSFRP is a large and important problem in the shipping industry. The only feasible way

to solve large instances of the problem is with column generation, however it is the application of

lazy constraints to the model which makes the most diﬀerence. By dramatically reducing the size

of the model, modern solver packages can manipulate the problem much more eﬀectively, resulting

in signiﬁcantly reduced run times.

This application of lazy constraints can be applied to any vehicle routing problem where trans-

shipment cannot occur and the routes must be node-distinct. Further, it is likely that many more

models can beneﬁt from lazy constraints used in a similar way to how we have used them in the

column generation sub-problems. Speciﬁcally, a large part of the model (in this case demand ﬂow

on each arc) can be optimistically approximated by a much smaller model (total amount of each

demand), with additional reﬁnements added using lazy constraints, as and when required. We

consider this to be a rich area of further research.

References

[1] Agarwal, R., ¨O. Ergun. 2008. Ship scheduling and network design for cargo routing in liner

shipping. Transportation Science 42(2) 175–196. doi:10.1287/trsc.1070.0205.

[2] ´Alvarez, J. 2009. Joint routing and deployment of a ﬂeet of container vessels. Maritime

Economics & Logistics 11(2) 186–208. doi:10.1057/mel.2009.5.

[3] Barnhart, C., E.L. Johnson, G.L. Nemhauser, M.W.P. Savelsbergh, P.H. Vance. 1998. Branch-

and-price: Column generation for solving huge integer programs. Operations Research 46(3)

316–329.

[4] Brouer, B.D., J. Dirksen, D. Pisinger, C.E.M. Plum, B. Vaaben. 2013. The vessel schedule

recovery problem (VSRP) a MIP model for handling disruptions in liner shipping. European

Journal of Operational Research 224(2) 362–374. doi:10.1016/j.ejor.2012.08.016.

[5] Brown, G.G., G.W. Graves, D. Ronen. 1987. Scheduling ocean transportation of crude oil.

Management Science 33(3) 335–346. doi:10.1287/mnsc.33.3.335.

29

[6] Christiansen, M., K. Fagerholt. 2002. Robust ship scheduling with multiple time windows.

Naval Research Logistics 49(6) 611–625. doi:10.1002/nav.10033.

[7] Christiansen, M., K. Fagerholt, D. Ronen. 2004. Ship routing and scheduling: Status and

perspectives. Transportation Science 38(1) 1–18. doi:10.1287/trsc.1030.0036.

[8] Dantzig, G. B. 1963. Linear programming and extensions. Princeton University Press.

[9] Fagerholt, K., M. Christiansen. 2000. A combined ship scheduling and allocation problem.

Journal of the Operational Research Society 51 834–842.

[10] Gurobi Optimization. 2015. Gurobi Optimizer Reference Manual . 6th ed. Gurobi Optimization.

URL http://www.gurobi.com/documentation/6.5/refman.pdf.

[11] Jenson, P. 1999. Network ﬂow programming models. URL http://www.me.utexas.edu/

~jensen/models/network/net1.html.

[12] Jenson, P. 1999. Pure minimal cost ﬂow problem. URL http://www.me.utexas.edu/~jensen/

methods/net.pdf/netmcf.pdf.

[13] Kelareva, E., K. Tierney, P. Kilby. 2014. CP methods for scheduling and routing with time-

dependent task costs. EURO Journal on Computational Optimization 2(3) 147–194. doi:

10.1007/s13675-014-0022-7.

[14] Nananukul, N. 2008. Lot-sizing and inventory routing for a production-distribution supply

chain. Ph.D. thesis, University of Texas.

[15] Powell, B.J., A.N. Perkins. 1997. Fleet deployment optimization for liner shipping: An in-

teger programming model. Maritime Policy & Management 24(2) 183–192. doi:10.1080/

03088839700000069.

[16] Rana, K., R.G. Vickson. 1991. Routing container ships using Lagrangean Relaxation. Trans-

portation Science 25(3) 201–214.

[17] Rathi, A.K., R.L. Church, R.S. Solanki. 1992. Allocating resources to support a multicom-

modity ﬂow with time windows. Logistics and Transportation Review 28(2) 167–188.

30

[18] Ronen, D. 1993. Ship scheduling: The last decade. European Journal of Operational Research

71(3) 325–333. doi:10.1016/0377-2217(93)90343-l.

[19] Sherali, H.D., S.M. Al-Yakoob, M.M. Hassan. 1999. Fleet management models and algorithms

for an oil-tanker routing and scheduling problem. IIE Transactions 31(5) 395–406. doi:10.

1080/07408179908969843.

[20] Tierney, K., B. ´Askelsd´ottir, R.M. Jensen, D. Pisinger. 2014. Solving the liner shipping ﬂeet

repositioning problem with cargo ﬂows. Transportation Science 1–23doi:10.1287/trsc.2013.

0515.

[21] Tierney, K., A.J. Coles, A.I. Coles, C. Kroer, A.M. Britt, R.M. Jensen. 2012. Automated

planning for liner shipping ﬂeet repositioning. Proceedings of the 22nd International Conference

on Automated Planning and Scheduling 279–287.

[22] Tierney, K., R.M. Jensen. 2012. The liner shipping ﬂeet repositioning problem with cargo

ﬂows. Hao Hu, Xiaoning Shi, Robert Stahlbock, Stefan Vo, eds., Computational Logistics,

Lecture Notes in Computer Science, vol. 7555. Springer Berlin Heidelberg, 1–16.

[23] Tyler, A. 2015. Solving the liner shipping ﬂeet repositioning problem with cargo ﬂows. Un-

published honours thesis, School of Mathematics and Physics, University of Queensland.

[24] United Nations Conference on Trade and Development (UNCTAD). 2014. Review of maritime

transport. UN Publications, New York.

31

