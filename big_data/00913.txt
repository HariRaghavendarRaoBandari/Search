6
1
0
2

 
r
a

M
2

 

 
 
]

R
C
.
s
c
[
 
 

1
v
3
1
9
0
0

.

3
0
6
1
:
v
i
X
r
a

Client-CASH: Protecting Master Passwords against Oﬄine Attacks

Jeremiah Blocki

Microsoft Research

jblocki@microsoft.com

Anirudh Sridhar

Carnegie Mellon University
asridha1@andrew.cmu.edu

March 4, 2016

Abstract

Oﬄine attacks on passwords are increasingly commonplace and dangerous. An oﬄine adversary is
limited only by the amount of computational resources he or she is willing to invest to crack a user’s
password. The danger is compounded by the existence of authentication servers who fail to adopt proper
password storage practices like key-stretching. Password managers can help mitigate these risks by
adopting key stretching procedures like hash iteration or memory hard functions to derive site speciﬁc
passwords from the user’s master password on the client-side. While key stretching can reduce the
oﬄine adversary’s success rate, these procedures also increase computational costs for a legitimate user.
Motivated by the observation that most of the password guesses of the oﬄine adversary will be incorrect,
we propose a client side cost asymmetric secure hashing scheme (Client-CASH). Client-CASH randomizes
the runtime of client-side key stretching procedure in a way that the expected computational cost of
our key derivation function is greater when run with an incorrect master password. We make several
contributions. First, we show how to introduce randomness into a client-side key stretching algorithms
through the use of halting predicates which are selected randomly at the time of account creation.
Second, we formalize the problem of ﬁnding the optimal running time distribution subject to certain
cost constraints for the client and certain security constrains on the halting predicates. Finally, we
demonstrate that Client-CASH can reduce the adversary’s success rate by up to 21%. These results
demonstrate the promise of the Client-CASH mechanism.

1 Introduction

Passwords are often the primary entryway to access a user’s conﬁdential information on a website, and are
thus a focus of attention for attackers. Oﬄine attacks against passwords are particularly powerful. An
oﬄine adversary has access to the cryptographic hash of a user’s password and can check a vast number of
password possibilities without interacting with the authentication server. This adversary is only restricted
by the computational resources that he is willing to invest into breaching each account. Oﬄine attacks are
increasingly commonplace due to recent high-proﬁle security breaches at organizations like LinkedIN, Sony,
eBay, and Ashley Madison1.

Several factors contribute to the danger of oﬄine attacks. First, users struggle to remember high entropy
passwords for multiple accounts. Second, many organizations had failed to implement proper password
storage techniques at the time they were breached. Finally, password cracking resources (e.g., hardware
and password dictionaries) continue to improve allowing an adversary to mount cheaper and more eﬀective
attacks.

Client-side password management tools (e.g., PwdHash [34]) allow the user to generate multiple passwords
from one master password and apply secure procedures like key stretching or salting on the client-side.
While password managers oﬀer many beneﬁts they also introduce a single point of failure (i.e., the master

1For example, see http://www.privacyrights.org/data-breach/ (Retrieved 9/1/2015).

1

password) through which the adversary could attack to gain access to all of a user’s accounts. A user’s
master password is not necessarily immune to oﬄine attacks just because a password manager is used. The
recent breach of LastPass2 highlights this dangerous possibility. Thus, key stretching procedures (e.g., hash
iteration, memory hard functions) are recommended to mitigate security risks in the event of an oﬄine attack.
However, key-stretching increases costs for the honest party as well as the adversary. It is thus desirable to
make authentication costs asymmetric so that (on average) a user authenticating with a correct password
will incur lower costs than an oﬄine adversary attempting to check an incorrect password guess. Previous
work by Manber [26] and by Blocki and Datta [4] achieves this goal of cost-asymmetric key-stretching, but
these solutions are only appropriate for server-side key stretching (see discussion in Section 2).

Contributions
In this work we present Client-CASH a client-side key-stretching algorithm which achieves
the goal of asymmetric costs, and we demonstrate that this system can protect user passwords from oﬄine
attacks. The core idea behind Client-CASH is to randomize the runtime of the client-side key stretching so
that on average, the cost of verifying a correct password is smaller than the cost of rejecting an incorrect
password. This is achieved by the use of halting predicates P : {0, 1}∗ → {0, 1}, which tells us when to
stop hashing the password (e.g., stop after t rounds of hash iteration if P (Ht(pwd)) = 1). These halting
predicates are chosen randomly at the time of account creation and are stored by the client (e.g., on a local
computer or on the cloud).

Because these halting predicates are stored by the client we must take care to ensure that the predicates
themselves do not leak too much information about the user’s password. The key challenge is to select the
predicates in a way that satisﬁes two seemingly conﬂicting requirements: 1) the halting predicates should
induce a cost-asymmetry in the validation of correct/incorrect passwords, and 2) the adversary should not be
able learn much about any user’s master password even if he observes these halting predicates. We borrow
ideas from diﬀerential privacy [18, 28] to satisfy both of these conﬂicting requirements.

correct password pwd as input then the expected cost to verify a correct password guess is k(cid:80)
k(cid:80)

We formalize the properties of Client-CASH and give an example of a system that satisﬁes these properties
based on the Exponential Mechanism [28], a powerful tool in diﬀerentially private analysis. We additionally
formalize the problem of minimizing the percentage of passwords cracked by the adversary as an optimization
over the parameters of the system and show that it can be solved eﬃciently as a linear program. In this work
we analyze the security of Client-CASH systems that use up to two iterations of an underlying hash function
Hk for password key stretching (the two-round case) or up to three iterations of Hk for key stretching
(the three-round case). Here, the parameter k speciﬁes the cost of the underlying hash function (e.g.,
BCRYPT [32] uses hash iteration to control costs and SCRYPT [30] uses a memory hard function to control
costs). If we let Pr[Ei,pwd] denote the probability that Client-CASH terminates after the i’th round given the
i i· Pr[Ei,pwd].
We compare Client-CASH to deterministic key-stretching techniques Hk(cid:48) with equivalent costs k(cid:48) =
i i · Pr[Ei,pwd] to Client-CASH by looking at the probability that an oﬄine adversary with a ﬁnite
computational budget B could crack the user’s password — we use Padv,B (resp. Pdet,B) to denote the
adversary’s success rate against Client-CASH (resp. deterministic key-stretching). For the two-round case,
we obtain a reduction Pdet,B − Padv,B in passwords breached of up to 12%, and up to 21% in the three round
case. Although we only show results for 2 and 3 round systems, we formulate the essential groundwork
for analysis of systems with more rounds. From the signiﬁcant decreases in passwords breached from two
round to three round systems, we might expect that introducing more rounds will decrease the number of
passwords breached in an oﬄine attack even further.

In our analysis we make no assumptions on the password storage practices of the authentication server.
If the authentication server adopts techniques like key stretching and salting then this will only make the
adversary’s task harder. However, we do assume that we face an optimal oﬄine adversary with a ﬁnite
computational budget B, and that users choose passwords uniformly at random. Because the later assump-
tion does not hold for general users we only recommend our solution to users who choose passwords (nearly)
uniformly at random. However, we argue that this assumption is plausible for many of the security conscious

2For example, see https://blog.lastpass.com/2015/06/lastpass-security-notice.html/ (Retrieved 9/1/2015).

2

users that would opt to use a client-side key stretching algorithm (ﬁnding Client-CASH distributions that
are optimal for protecting non-uniform passwords is an important direction for future work).

Overview of Client-CASH When Alice creates an account on server W using the master password
pwdA our client-side application ﬁrst selects a sequence of halting predicates oW = (Pu1,. . ., Pun−1) using
a randomized function SelPreds(pwdA). Afterwards our application sends the message (Alice, H) to the
SW (pwdA)
server where H = H
(pwdA). Here, Hk denotes a collision resistant hash function which costs k work
k denotes the hash function iterated i times and SW (pwdA) denotes the stopping
k
units to compute one time, Hi
time for password pwdA given by the halting predicates oW — that is the smallest number i ≥ 1 for which
Pui(Hi
(pwdA),
sends (Alice, H) to the server and gains access to her account. An incorrect password guess pg (cid:54)= pA would
be rejected with high probability since Hk is collision resistant.

SW (pwdA)
k(pwdA)) = 1. During authentication, Alice recomputes the derived password H = H
k

2 Related Work

Halting Puzzles. At a high level our use of halting predicates is similar to Boyen’s [11] halting puzzles.
In Boyen’s solution the chosen halting predicate will never return ‘halt’ unless we run the key derivation
function with the correct password so the key derivation algorithm never halts (or only halts after the
maximum possible number of rounds). The key diﬀerence between our work and the work of Boyen [11] is
that we carefully bound the amount of information that the chosen halting predicate(s) can leak about the
user’s password. Thus, unlike [11], we can ensure that an adversary who only breaches the client will not be
able to execute an oﬄine attack against the user’s password.

Cost-Asymmetric Server-Side Key Stretching. Manber [26] proposed the use of hidden salt values
(e.g., ‘pepper’) to make it more expensive to reject incorrect passwords. Blocki and Datta [4] reﬁned this
idea using game theoretic tools. While our work closely follows the work of Blocki and Datta [4], we stress
that neither work [4, 26] addresses the issue of client side key-stretching.
In both of these schemes the
authentication server selects a secret salt value t ∈ {1, . . . , m} (e.g., “pepper”) and stores the cryptographic
hash H(pwd, t) — the value t is not stored on the authentication server. An adversary would need to
compute the hash function m times in total to reject an incorrect password, while the authentication server
will need to compute it at most (m + 1)/2 times on average to verify a correct password guess because
it can halt immediately after it ﬁnds the correct value of t. This approach is not suitable for client-side
key-stretching because we would produce m diﬀerent derived keys, but the client program would not know
which one is correct — neither of these value t or H(pwd, t) should be stored on the client. Since we are
performing key-stretching on the client-side we need to ensure that the ﬁnal derived password that is sent
to the authentication server is consistent among diﬀerent authentication sessions.

Password Management Software. Password managers like PwdHash [34] allow the user to generate
multiple passwords from one master password. PwdHash uses a public key-derivation function to (re)generate
each of the user’s passwords from a single master password. Since the key-derivation function is public an
adversary who breaks into any of the third party authentication servers could still execute an oﬄine attack
against the user’s master password. By contrast, password managers like KeePass [33] store an encrypted
password vault on the client and are not necessarily vulnerable in the previous scenario because the adversary
would not have the password vault. The vault, which contains all of the user’s passwords, is encrypted with
the user’s master password. However, any adversary who breaks into the client and steals a copy of this vault
could execute an oﬄine attack against the user’s master password. Commercial applications like LastPass
rely on a trusted server to derive passwords from the user’s master password. Unlike PwdHash and KeePass
these commercial applications are typically not open source so it is not always possible for independent
researchers to verify their security properties. In theory these password managers could be designed so that
an adversary would need to break into multiple servers (e.g., at LinkedIn and LastPass) before he can mount

3

an oﬄine attack on the user’s master password. However, the recent breach at LastPass3 demonstrates that
we cannot rule out this dangerous possibility. Similarly, Client-CASH is designed so that the adversary
would need to breach both the client computer and a third party authentication server to mount an oﬄine
attack.

Deterministic Key Stretching Techniques. Advances in computing hardware (e.g., GPUs [24], ASiCs [16])
make oﬄine attacks increasingly dangerous. An oﬄine adversary can often try millions of password guesses
per second. Morris and Thompson [29] proposed the idea of key-stretching to make the hash function more
expensive to evaluate so that an oﬄine attack is more expensive for the adversary. Other defenses (e.g.,
distributing the storage/computation of cryptographic hash values so that an adversary who only breaches
one server does not learn anything about the user’s password [13] and [15]) require multiple dedicated
authentication servers. Finding good key-stretching techniques is an active area of research4. Hash iteration
(e.g., PBKDF2 [23], BCRYPT [32]) alone is often viewed as an insuﬃcient key-stretching technique because
an oﬄine adversary can often signiﬁcantly reduce costs by building customized hardware to evaluate the
iterated hash function. While computational speeds may vary greatly between diﬀerent devices, memory
latency speeds are relatively consistent [17]. Thus, modern password hash functions like SCRYPT [30] or
Argon2 [2] typically use memory hard functions [17] for key-stretching purposes. Our work is largely orthog-
onal to these lines of research. In particular, we stress that Client-CASHis compatible with both forms of
key-stretching (hash iteration and memory hard functions).

Password Alternatives. Although researchers have been working on alternatives to text-passwords (e.g.,
graphical passwords[22, 14, 1] or biometrics [8]) text-passwords are likely to remain entrenched as the domi-
nant form of authentication for many years [8]. While we focus on text passwords in this paper we stress that
the applications of Client-CASH are not necessarily limited to text passwords. Client-side key stretching
is a valuable primitive that could be used to protect any lower entropy secret whether that secret is a text
password, a graphical password or a biometric signal.

3 Description of the Mechanism

In this section we introduce the Client-CASH mechanism and describe the account creation and authenti-
cation protocols. In our presentation we will use H to denote a cryptographic hash function (e.g., SHA256
or Blake2b) and we will use CH to denote the cost of computing H one time. We will also use Hk to denote
a deterministic hash function that is k times more expensive to compute than H (i.e., CHk = k · CH ). This
might be achieved by hash iteration [32, 23] or by the adoption of memory hard functions [30]. We also use
P to denote the set of passwords a user can pick.
Account Creation. When a user u creates an account a with a master password pwdu ∈ P Client-
CASH will execute the following steps: First, the client will run a randomized algorithm SelPreds(pwdu) to
obtain a sequence of n− 1 halting predicates ou = (Pu1, . . . , Pun−1). Here, a halting predicate Pu : {0, 1}∗ →
{0, 1} is simply a function that will tell us when to halt the key-derivation process. Second, the client will

then store the tuple (a, u, su, ou), where su ← Unif(cid:0){0, 1}L(cid:1) is a random L-bit salt value. The client will

then run the algorithm Reproduce (described below) to derive the password for account a.

We intentionally omit the workings of SelPreds and treat it as a black box for now. However, we stress
that outcome ou selected by the randomized algorithm SelPreds(pwdu) may depend both on the master
password pwdu and on a security parameter  which bounds the amount of information the outcome ou
might leak about pwdu. In later sections we will show how to construct a randomized algorithm SelPreds
which minimizes the adversary’s success rate Padv,B subject to certain security and cost constraints. The
account creation protocol is described formally in Algorithm 1.

3See https://blog.lastpass.com/2015/06/lastpass-security-notice.html/ (Retrieved 9/1/2015).
4For example, the Password Hashing Competition (https://password-hashing.net/index.html) was developed to encour-

age the development of alternative password hashing schemes (e.g., [2, 21])

4

Algorithm 1 Create Account (Client Side)

Input: account name a, username u, password pwdu; random bit strings r1, r2
System Parameters:
ou ← SelPreds(pwdu; r1)

key ← (u, a); su ← Unif(cid:0){0, 1}L; r2

(cid:1); value ← (ou, su)

rounds n, O, iterations k, , L

StoreOnClient(key, value)
H ← Reproduce (u, pwdu, su, n)
SendToServer(u, H)

Authentication. When the user u attempts to access the account a with the password guess pwdg ∈ P,
the client ﬁrst locates the record (a, u, su, ou) on the client. Then we execute the algorithm Reproduce
function to derive the password H

(pwdg, su) for account a.

S(pwdg,ou)
k

Algorithm 2 Reproduce (Client Side)

Input: account name a, username u, password pwdg
key ← (u, a); value ← FindClientRecord(key)
If value = ∅ then return “Account does not exist.”
(ou, su, n,O, ) ← value
(P1, . . . , Pn−1) ← ou; H ← Hk(pwdg, su)
for m = 1, . . . , n − 1 do

If Pm(H) = 1 then Break
H ← Hk(H)

(cid:17)

(cid:16)

Hj

end for
SendToServer(u, H)
Here, we use S(pwd, o) to denote the implicitly deﬁned stopping time for each password pwd ∈ P
given the sequence o = (Pu1, . . . , Pun−1) of halting predicates. Formally, S(pwd, o) = i if and only if (1)
Pui
= 0
for all j < n, where n denotes the maximum possible rounds of hash iteration.

(cid:0)Hi
k (pwd, su)(cid:1) = 1 and Puj

= 0 for all j < i or (2) i = n and Puj

k (pwd, su)

k (pwd, su)

S(pwdg,ou)
k

Thus, to compute H

(pwdg, su) we initially compute H1 ← Hk(pwdg, su) and check if Pu1(H1) =
1. If it is then we return the derived password H1. Otherwise, we compute H2 ← Hk(H1) and return H2 if
and only if Pu2(H1) = 1. This process is repeated until either Pui(Hi) = 1 or i = n. The derived password
is sent to the server to be accepted or rejected. Authentication is guaranteed when pwdg = pwdu and is
very unlikely when pwdg (cid:54)= pwdu because H is collision resistant. The client-side algorithm Reproduce
is presented formally as Algorithm 2. We note that, unlike the account creation process, the algorithm
Reproduce is entirely deterministic.

(cid:16)

Hj

(cid:17)

Remark. We omit any description of how the authentication server stores the derived password as this
is an orthogonal issue. In an ideal world the authentication server would add salt and apply a strong key-
stretching algorithm before storing the derived password. Unfortunately, many authentication servers have
failed to adopt these standard security practices [9]. Furthermore, users will not necessarily know what
security practices have been adopted until the authentication server is actually breached. Thus, in our
security analysis we will assume that the authentication server does not do any key-stretching. By applying
salting and key-stretching algorithms on the client-side we can help protect users even when organizations
fail to adopt these security practices. Of course if the authentication server does perform additional key
stretching then the adversary’s task will be even harder.

Notation and Customizable Parameters We use B to denote the budget of the adversary (i.e., the
maximum number of times the adversary is willing to evaluate H in an attempt to crack the user’s password),
and we will use Csrv to denote the maximum cost that the client is willing to bear per authentication session
(in expectation).

We use O to denote the range of the SelPreds function (e.g., the space of all valid predicate sequences of
length n − 1, where n denotes the maximum number of rounds of hashing for Reproduce ). We adopt the

5

following notational conventions: Given a randomized algorithm like SelPreds we use o ← SelPreds(pwd)
to denote a random sample from the distribution induced by an input pwd. If we ﬁx the random input bits r
then we will use o := SelPreds(x; r) to denote the deterministic result. We will use P to denote the space
of all possible passwords that the user might select.

For a user with password pwdu and predicate sequence ou, the hash used by that user on the instance of
S(pwdu,ou)
= {o ∈ O S(pwd, o) = j} ⊆ O to denote the subset
.
a correct password is H
k
of outcomes which yield stopping time j for the password pwd. Finally, we will use the parameter  > 0 to
quantify the maximum amount of information leaked about a user’s password by the output o ∈ O of the
SelPreds function. For readers familiar with the notion of -diﬀerential privacy we remark that we use the
same notation intentionally.

. We will use Oj,pwd

4 Design of the Mechanism

In the previous section we outlined the Client-CASH mechanism using the randomized algorithm SelPreds in
a black-box manner. We now examine the exact formulation of this algorithm.

4.1 Security Requirements
The probability that SelPreds(pwd) yields a particular outcome o ∈ O may depend on the input password
pwd. Indeed, our goal is to introduce a cost asymmetry so that, in expectation, the stopping time S(pwd, o)
for the correct password is less than stopping time S(pwd(cid:48), o) for any incorrect passwords pwd(cid:48) (cid:54)= pwd. One
natural way to achieve this asymmetry might be to deﬁne a family of predicates

(cid:40)

Ppwd,j(x) =

if x ≡ H j
else

k (pwd, su)

1
0

for each password pwd ∈ P and j < n. Then SelPreds(pwd) might select a stopping time j at random
from some distribution and set o = Pu1, . . . , Pun−1 where Pui = Ppwd,j for each i < n. This solution could
provide an extreme cost asymmetry. In particular, we would have S(pwd, o) = j for the correct password
and with high probability we would have S(pwd(cid:48), o) = n for all other passwords. Indeed, this solution is
simply a reformulation of Boyen’s [11] halting puzzles.

The downside to this solution is that it would enable an adversary to mount an oﬄine attack using only
state from the client (e.g., without breaching the authentication server) because the output o of SelPreds
is stored on the client and this output would include the hash value H j

k (pwd, su).

In contrast to Boyen [11], we will require the SelPreds function to satisfy a very stringent information
theoretic security property. In particular, for every o ∈ O and for all pwd, pwd(cid:48) ∈ P with pwd (cid:54)= pwd(cid:48), we
will require that

Pr [SelPreds(pwd) = o]
Pr [SelPreds(pwd(cid:48)) = o]

≤ e .

(1)

Here,  is the security parameter which upper bounds the amount of information about the user’s password
that is leaked by the outcome o. This requirement is exactly equivalent to the powerful notion of -diﬀerential
privacy [18]. Intuitively, the probability that we produce a particular outcome o ∈ O cannot depend too
much on particular password pwd that the user chose.

Discussion. Diﬀerential privacy is an information theoretic guarantee, which holds even if the adversary
has background knowledge about the user. The security guarantees are quite strong.
In particular, let
Attackz denote any attack that an adversary with background knowledge z might use after observing the

6

outcome o from SelPreds(pwd) and let Bad ⊆ Range (Attackz) denote the set of outcomes that our user
Alice would consider harmful. It is easy (e.g., see [19]) to show that
Pr [Attackz (SelPreds(pwd)) ∈ Bad]
Pr [Attackz (SelPreds(pwd(cid:48))) ∈ Bad]

≤ e .

Intuitively, the numerator represents the adversary’s actual success rate and the denominator represents
the adversary’s success rate if the output of SelPreds were not even correlated with Alice’s real password.
Thus, the constraint implies that the probability the adversary’s attack succeeds cannot greatly depend on
the output of the SelPreds function.

4.2 Cost Requirements

Performing client-side key stretching requires computational resources on the client side. We will require that
the amortized cost of hashing a password does not exceed the maximum amortized cost the user is willing to
bear. Let Csrv denote the user’s maximum amortized cost and let k· CH denote the cost of executing Hk one
= Pr [SelPreds(pwd) ∈ Oj,pwd] denote the probability
.
time. Finally, for a ﬁxed password pwd let Pr[Ej,pwd]
that SelPreds returns an outcome o ∈ O which yields stopping time S(pwd, o) = j for the password pwd.
Given a password pwd the expected cost of executing Reproduce in Client-CASH is

E [S(pwd, o) · k · CH ] = k · CH

i · Pr[Ei,pwd] ,

n(cid:88)

i=1

where the expectation is taken over the randomness of the algorithm SelPreds. Thus, we require that

n(cid:88)

i · Pr[Ei,pwd] ≤ Csrv
k · CH

.

(2)

4.3 Symmetric Predicate Sets

i=1

In this section we show how to simplify the security and cost constraints from the previous sections by
designing O with certain symmetric properties. In particular, we need to design the SelPreds algorithm in
such a way that the cost constraint (eq. 2) is satisﬁed for all passwords pwd ∈ P, and we need to ensure
that our security constraint (eq. 1) holds for all pairs of passwords pwd (cid:54)= pwd(cid:48). Working with |P|2 diﬀerent
security constraints is unwieldy. Thus, we need a way to simplify these requirements.

One natural way to simplify these requirements is to construct a symmetric O; that is, for all pwd, pwd(cid:48) ∈
P and for all j ∈ {1, . . . , n}, |Oj,pwd|= |Oj,pwd(cid:48)|. We stress that this restriction does not imply that the
sets Oj,pwd and Oj,pwd(cid:48) are the same, simply that their sizes are the same. We will also require that
∀pwd, pwd(cid:48) ∈ P,∀j ≤ n,∀o ∈ Oj,pwd, o(cid:48) ∈ Oj,pwd(cid:48)

Pr[SelPreds(pwd) = o] = Pr[SelPreds(pwd(cid:48)) = o(cid:48)]

(3)
as there is no clear reason to favor one outcome over the other since both outcomes o, o(cid:48) ∈ O yield the same
halting time for their respective passwords pwd and pwd(cid:48) (i.e, S(pwd, o) = S(pwd(cid:48), o(cid:48))) .
Notation for Symmetric O. Given a symmetric O, we deﬁne Oj
= |Oj,pwd|. We deﬁne ˜pj
.
o] for an arbitrary password pwd ∈ P and output o ∈ Oj,pwd since, by symmetry, the choice of pwd and
o do not matter. Intuitively, ˜pj denotes the probability that SelPreds(pwd) outputs o with stopping time
S(pwd, o) = j. We will also write Pr[Ej] instead of Pr[Ej,pwd] = Oj · ˜pj because the value will be the same
for all passwords pwd ∈ P.

.
= Pr[SelPreds(pwd) =

7

No Symmetry

∀pwd, pwd(cid:48) ∈ P,∀o ∈ O,
≤ e
Pr[SelPreds(pwd)=o]
Pr[SelPreds(pwd(cid:48))=o]

Constraint With Symmetry
∀i, j ∈ {1, . . . , n},

Security

(Thm 4)

˜pi
˜pj

≤ e

n(cid:80)

j=1

∀pwd ∈ P,

j · Pr[Ej,pwd] ≤ Csrv
k·CH

Cost

n(cid:80)

j=1

j · Oj ˜pj ≤ Csrv
k·CH

Table 1: Security and cost constraints for SelPreds with symmetric predicate set O.

Now the SelPreds algorithm can be completely speciﬁed by the values ˜pj for j ∈ {1, . . . , n}. It remains
to construct a symmetric O. The construction of a symmetric O used in this work is simple we will focus
on stopping predicates with the following form:

(Thm 5)

(cid:40)

Pi,j(x) =

if x ≡ i mod j
else

1
0

Theorem 1 says that we can use these predicates to construct a symmetric set O.

Theorem 1 Let integers (cid:96)1, . . . , (cid:96)n−1 ≥ 2 be given and suppose that O = {P0,(cid:96)1 , . . . P(cid:96)1−1,(cid:96)1}× . . . ×
{P0,(cid:96)n−1,. . ., P(cid:96)n−1−1,(cid:96)n−1}. Then O is symmetric, i.e. for all j ∈ {1, . . . , n} and for all pwd, pwd(cid:48) ∈ P we
have |Oj,pwd|= |Oj,pwd(cid:48)|.

One of the primary advantages of using a symmetric O is that we can greatly reduce the number of
security and cost constraints. Table 1 compares the security and cost constraints with and without symmetry.
Without symmetry we had to satisfy separate cost constraints for all passwords pwd ∈ P. With symmetry
we only have to satisfy one cost constraint. Similarly, with symmetry we only need to satisfy one security
constraint for each i, j ∈ {1, . . . , n} instead of multiple constraints for each pair of passwords pwd (cid:54)= pwd(cid:48)
that the user might select. While the space of passwords may be very large, n, the number of rounds of
hashing, will typically be quite small (e.g., in this paper n ∈ {2, 3}). See Theorems 4 and 5 in the appendix
for formal statements of these results and their proofs.

In our analysis of Client-CASH we will focus on two simple symmetric constructions of O:
• “Two Round” Case: set n = (cid:96)1 = 2 in Theorem 1 so O = {P0,2, P1,2}.
• “Three Round” Case: set n = (cid:96)1 = (cid:96)2 = 3 in Theorem 1 so O = {P0,3, P1,3, P2,3}2.

We do not rule out the possibility that other cases would yield even stronger results. However, we are already
able to obtain signiﬁcant reductions in the adversary’s success rate with these simple cases.

5 The Adversary Model

In this section we formalize the strategies that an oﬄine adversary might adopt so that we can analyze the
eﬀectiveness of the Client-CASH mechanism against an oﬄine adversary. In an online attack, the adversary
must interact with and query the authentication server to have a password veriﬁed or rejected, and there
are a variety of eﬀective methods to deal with such an attack (e.g., a k-strikes policy). By contrast, the
oﬄine adversary we consider is limited only by the resources that he is willing to invest to crack the user’s
password. The adversary’s goal is to maximize the odds that he cracks the user’s password given a ﬁnite
computational budget B. We will use Padv,B (resp. Pdet,B) to denote the probability that the optimal oﬄine
adversary successfully cracks a password protected with Client-CASH (resp. deterministic key-stretching)

8

with a budget B denoting the maximum number of times that the adversary is willing to compute H. To
simplify notation we will often write Padv (resp. Pdet) when B is clear from context.
The Adversary’s Knowledge. We consider an adversary who has breached the client and one of the third party
authentication servers (e.g., LinkedIn) where the user has an account. This adversary has access to all code
and data on the client and on a third party authentication server. Suppose for example that user u created
account a with a password pwdu. The client will store the tuple (u, a, ou, su, n,O, ) and the third party
authentication server will have some record of the derived password H
(pwdu, su). In our analysis
we do not assume that the third party authentication server adopts proper password storage procedures like
key-stretching — this is the unfortunate reality for many authentication servers [9]. If the authentication
server does apply key-stretching then the adversary’s oﬄine attack will be even more expensive.

S(pwdu,ou)
k

Oﬄine attack against the traditional mechanism We ﬁrst analyze the adversary’s success rate Pdet,B
against a traditional deterministic key stretching algorithm with comparable cost to Client-CASH. In par-
ticular, let k(cid:48) = Csrv
. Instead of adopting Client-CASH the adversary might instead use a deterministic
key-stretching algorithm Hk(cid:48) with the same cost. In this case the adversary could check at most B
k(cid:48) passwords,
and each password has probability 1|P| of being the correct password. Thus,

CH

(cid:40) B

k(cid:48)|P|
1

Pdet,B =

k(cid:48) ≤ |P|

if B
otherwise

(4)

Oﬄine attack against Client-CASH We now consider the adversary’s optimal success rate Padv,B
against Client-CASH. While each password pwd ∈ P is chosen with equal probability, we might have
diﬀerent stopping times S (pwd, ou) for each password. The adversary can compute Hk up to B
k times so he
can complete B/k rounds of hashing in total. For each password guess pwdg the adversary can decide how
many rounds of hashing to complete for that particular guess. There are many diﬀerent strategies that the
adversary might adopt, and some may produce a larger probability of success than others. Of course the
optimal adversary will never complete more rounds of hashing than necessary (e.g., if S(pwdg, o) = i then
the adversary will never complete i + 1 rounds of guessing for guess pwdg).
It turns out that we can represent the optimal adversary’s strategies as a vector of n numbers b =
(b1, . . . , bn) ∈ Rn where bi ∈ [0, min{1, k |P| /B}] denotes the fraction of the adversary’s budget spent
hashing passwords i’th round (see the appendix for a more formal justiﬁcation). Formally, given a symmetric
set O from Theorem 1 we use FB ⊆ Rn to denote the set of feasible strategies for the adversary

(cid:94)∀i ≤ n

(cid:18)

(cid:20)

(cid:26)

(cid:27)(cid:21)(cid:94)

k |P|
B

bi+1 ≤ bi − bi
(cid:96)i

(cid:19)(cid:27)

.

FB =

b ∈ Rn

bi = 1

bi ∈

0, min

1,

(cid:40)

n(cid:88)

i=1

We require that bi+1 ≤ bi · (cid:96)i−1
because the adversary can only hash a password pwdg in round i + 1 if he
previously completed round i for the same password and the optimal adversary will not hash pwdg in round
i + 1 if S(pwdg, o) = i — for a random password the halting predicate will output 1 with probability 1/(cid:96)i in
the i’th round. Given a particular strategy b the adversary succeeds with probability

(cid:96)i

Pr[E1]b1 +

n(cid:88)

B
k|P|

i−1(cid:89)

(cid:18) (cid:96)j

(cid:96)j − 1

(cid:19) .

Pr[Ei]bi

i=2

j=1

Inutuitively, bi

(cid:17)

(cid:16) (cid:96)j−1
i−1(cid:81)
(cid:16) (cid:96)j
(cid:17)
i−1(cid:81)

j=1

(cid:96)j

(cid:96)j−1

j=1

and the

Pr[Ei]

B
k|P| denotes the fraction of password selected by the adversary to be hashed at least i time,
term represents the fraction of passwords with stopping time S(pwdg, o) > i − 1. Thus,
denotes the conditional probability that S(pwdg, o) = i given that S(pwdg, o) > i − 1.

9

Because the user selects passwords uniformly at random from the set P we might conjecture that the
optimal adversary will follow the same strategy for every password guess (e.g., for some i ≤ n the optimal
adversary will hash each guess pwdg for min{i,S(pwdg, o)} rounds before moving on to the next guess). This
= {b ∈ FB : ∀b(cid:48) ∈ FB, bi ≥ b(cid:48)
intuition turns out to be correct. Formally, Ai
i} denotes the set of strategies
.
in which the adversary tries each password guess for min{i,S(pwdg, o)} rounds before giving up. Our next
results states that for some i ≤ n the adversary will follow a strategy in Ai.
Theorem 2 Assume that O is constructed as in Theorem 1. The dominant adversary strategies are given
by the collection of sets Ai = {b ∈ FB : ∀(cid:126)b(cid:48) ∈ FB, bi ≥ b(cid:48)

Ai. Then

B :=

Pr[E1]b1 +

i} for 1 ≤ i ≤ n. Let F ∗
n(cid:88)

(cid:18) (cid:96)j

i−1(cid:89)

Pr[Ei]bi

(cid:96)j − 1

i=2

j=1

n(cid:83)
(cid:19)

i=1

Padv,B =

B
k|P| max
b∈F ∗

B

Discussion. In our analysis of the adversary we assume that the user picks passwords uniformly at random
from P. Thus, we can only recommend Client-CASH to users for whom this assumption holds. A large
body of research has explored the security of user selected passwords (e.g., [27, 12, 31, 7]), how users cope
with multiple passwords [20] and how users respond to password restrictions [25, 6]. These results indicate
that many users do not select their password uniformly at random — contrary to the assumption we made in
our security analysis. However, several research results indicate that users are capable of remembering truly
random system-assigned passwords with practice [3, 5, 10, 35]. Our assumption would hold for users who
adopt the four random words strategy popularized by the web comic XKCD5 or the password management
strategies proposed by Blocki et al. [3]. Thus, we believe that this assumption could be reasonable for many
the security conscious users who would adopt Client-CASH.

5.1 Two Round Strategies
In the two-round case we have F ∗ = A1 ∪ A2 in Theorem 2, so it suﬃces to calculate these two sets. We

have A2 =(cid:8)(cid:0) 2

3 , 1

3

(cid:1)(cid:9) and

If b = (1, 0) then, using the fact that O1 = 1, we have

(cid:96)j − 1
Thus, working out each case for b ∈ F ∗ Theorem 2 simpliﬁes to:

Oi ˜pibi

j=1

i=2

B
k|P|

(cid:17)(cid:111)
(cid:18) (cid:96)j

B

A1 =

(cid:40){(1, 0)}
(cid:110)(cid:16) k|P|
B , 1 − k|P|
O1 ˜p1b1 +
i−1(cid:89)
n(cid:88)
max
(cid:110)
(cid:111)
(cid:110)
(cid:16) B
(cid:17)
B
k|P|
k|P| − 1

k|P| , 2

˜p1 + 2

max

˜p1

B

3

if B

k|P| ≤ 1

otherwise.

(cid:19) = ˜p1

B
k|P| .

(cid:111)

if B

k|P| ≤ 1

otherwise.

˜p2, 2
3

B
k|P|

Padv,B ≥

5.2 Three Round Strategies
In the three-round case we have F ∗ = A1 ∪A2 ∪A3 in Theorem 2, so it suﬃces to calculate these three sets.
To bound Padv,B we note that it is suﬃcient to ﬁnd the extremal points of each region since the adversary’s
objective function is linear in the bi’s. Letting Ai denote the extremal points of Ai, we thus have

5See http://xkcd.com/936/ (retrieved 9/8/2015).

10



A1 =

(cid:17)
(cid:17)
(cid:17)

,

5

{(1, 0, 0)}

(cid:110)(cid:16) k|P|
(cid:16)
(cid:16) k|P|
B , 1 − k|P|
B , 0
(cid:16)
(cid:110)(cid:16) k|P|
1 − k|P|
B , 3
1 − k|P|
(cid:40)(cid:8)(cid:0) 3
5 , 0(cid:1)(cid:9)
B , 3
(cid:110)(cid:16) k|P|
(cid:26)(cid:18) 9

B , 2

5 , 2

A2 =

B

B

5

3

6
19

,

4
19

,

19

A3 =

(cid:16)
(cid:16)

, 2
5
, 2
5

1 − k|P|
1 − k|P|

B

B

(cid:17)(cid:17)(cid:111)
(cid:17)(cid:17)(cid:111)
(cid:17)(cid:111)

(cid:19)(cid:27)
k|P|
B , 1 − 5

3

k|P|
B

if B

k|P| ≤ 1

k|P| ∈(cid:2)1, 5

3

(cid:3)

if B

otherwise

if B

k|P| ≤ 5

3

otherwise

Thus, we can express Padv,B in terms of the following bounds.

(2)

(1) 3˜p1

B
k|P|

(4) 3˜p1 + 3˜p2

(cid:19)
(cid:18) B
k|P| − 1
5 , 0(cid:1) then, using the fact that O1 = 3, O2 = 2 and (cid:96)j = 3, we have
For example, if b =(cid:0) 3
O1 ˜p1b1 +
(cid:18)
5 , 2
n(cid:88)

(cid:19)(cid:18) B
(cid:19)
k|P| − 1
(cid:18)

(6) 3˜p1 + 2˜p2 + 9˜p3

(cid:18) 3

(cid:19)(cid:19)

B
k|P|

i−1(cid:89)

(5) 3˜p1 +

Oi ˜pibi

+ 2˜p2

9
19

3˜p1

(3)

=

(cid:18) B
k|P| − 5
(cid:19)

3

˜p1

+

˜p2

(cid:19)

B
k|P|

9
5

6
5

3
5

2
5

2

B
k|P|

i=2

j=1

as in (2). Thus, in the three-round case Theorem 2 simpliﬁes to:

(cid:18) 9

(cid:19) B

5

5

˜p3

˜p2

6
5

˜p2 +

˜p1 +

k|P|
18
5

(cid:18) 9
(cid:19) =
(cid:18) (cid:96)j
max{(1), (2), (3)}

(cid:96)j − 1

B
k|P|

max{(2), (3), (4), (5)}
max{(3), (5), (6)}

Padv,B ≥

k|P| ≤ 1

k|P| ∈(cid:2)1, 5

if B
if B
otherwise.

3

(cid:3)

6 The Exponential Mechanism

In this section we show how to construct the SelPreds function so that it satisﬁes our security and cost
constraints (equations 1 and 2). Our construction is based on the Exponential Mechanism of McSherry and
Talwar [28], a powerful tool from the diﬀerential privacy literature. We demonstrate that this mechanism
is feasible and that it leads to a signiﬁcant reduction in the adversary’s success rate.
In particular the
exponential mechanism can reduce the adversary’s success rate by up to 12% when n, the maximum number
of hashing rounds, is two and by up to 18% when n = 3.

6.1 Constructing SelPreds via the Exponential Mechanism
To deﬁne the SelPreds function it suﬃces to specify the probability of each outcome o ∈ O given an input
password pwd ∈ P. Consider the utility function U (pwd, o)
which assigns a utility score to

= 1−S(pwd,o)
.

n−1

11

each outcome o ∈ O given a password pwd. We can now use U (pwd, o) to specify the probability of an
outcome o given password pwd. We deﬁne SelPredsexp, such that

Pr[SelPredsexp,(pwd) = o]

.
=

(cid:80)

eU (pwd,o)
o(cid:48)∈O eU (pwd,o(cid:48))

.

Intuitively, given a ﬁxed password pwd the exponential mechanism assigns a higher probability to outcomes
o with shorter stopping times S(pwd, o).

We can ensure that our cost constraints are satisﬁed by tuning the parameter k (the number of hash

iterations per round). After  and O have been ﬁxed we will set k to be the maximum integer such that:

n(cid:88)

i=1

n(cid:88)

i=1

iOi ˜pi =

1
W

iOieU (i) ≤ Csrv
k · CH

.

where the left hand side is a constant.
Observe that whenever O is symmetric it is possible to precompute the stopping time probabilities
(cid:80)n
Oj·e·j
.
i=1 Oi·e·i . Thus, to sample from SelPredsexp,(pwd) it suﬃces to sample the stopping time j,
=

˜pj
compute Hjk(pwd, su) and sample uniformly at random from the set Oj,pwd.

Theorem 3 states that the exponential mechanism above satisﬁes our desired security constraint. Theorem
3 is similar to the general result of McSherry and Talwar [28], which would imply that our mechanism
SelPredsexp, satisﬁes the security constraint with security parameter 2. In our particular setting we can
exploit symmetry (e.g., |Oj,pwd(cid:48)| = |Oj,pwd|) to obtain a tighter bound with security parameter .
Theorem 3 For any symmetric O we have

∀pwd, pwd(cid:48) ∈ P,∀o ∈ O,

Pr[SelPredsexp,(pwd) = o]
Pr[SelPredsexp,(pwd(cid:48)) = o]

≤ e .

= (cid:80)

.

Proof of Theorem 3.
and let Wpwd
Wpwd = Wpwd(cid:48) for any pair of passwords pwd, pwd(cid:48) ∈ P. Thus,

o∈O

Let wo,pwd

= eU (pwd,o) denote the weight of outcome o ∈ O given password pwd
.
wo,pwd denote the cumulative weight of all o ∈ O. Because O is symmetric we have

Pr [SelectPredicate (pwd) = o]
Pr [SelectPredicate (pwd(cid:48)) = o]

=

wo,pwd/Wpwd
wo,pwd(cid:48)/Wpwd(cid:48)

=

wo,pwd
wo,pwd(cid:48)

≤ e|U (pwd(cid:48),0)−U (pwd,o)| ≤ e .

(cid:3)

6.2 Analysis of the Exponential Mechanism

= Pdet,B − Padv,B to denote the gains from adopting Client-CASH (i.e., the reduction
.
We will use GB
in the probability that the adversary cracks the password). Recall that Padv,B (resp. Pdet,B) denotes
the probability that the optimal oﬄine adversary successfully cracks a password protected with Client-
CASH (resp. deterministic key-stretching) with a budget B. Figure 1a and 1b plots GB as a function of B
for various values of the security parameter . Theorem 2 allows us to compute Padv,B and GB eﬃciently.

12

(a) Two round exponential mechanism.

(b) Three round exponential mechanism.

(c) Two round optimal mechanism.

(d) Three round optimal mechanism.

Figure 1: Percent reduction in passwords breached GB = Pdet,B−Padv,B given as a function of the adversary’s
total budget B with a normalizing factor of
Csrv|P| for various values of . (a) and (b) show the
two and three round exponential mechanisms, respectively, while (c) and (d) show the optimal gains for the
two and three round mechanisms when the adversary’s budget is known in advance.

k(cid:48)|P| = CH

1

6.2.1 Two-Round Exponential Mechanism
Note that when n = 2, O = {P0,2, P1,2} so (O1, O2) = (1, 1). Thus for a ﬁxed value of , we can deﬁne the
exponential mechanism as follows:

W = 1 + e− ,

˜p1 =

1
W

,

˜p2 =

e−
W

Pr[E1] + Pr[E2] = ˜p1 + ˜p2 = 1
Pr[E1] + 2 Pr[E2] = ˜p1 + 2˜p2 ≤ Csrv
k · CH

13

Although we have an inequality in the last equation, we emphasize that k is determined to be the maximum
integer such that the inequality holds, as described in §6.1. Since k is large, and thus marginal changes in
Csrv
and round k downwards if it is not an integer.
k·CH

are small, we assume for simplicity that ˜p1 + 2˜p2 = Csrv
k·CH

6.2.2 Three-Round Exponential Mechanism
When n = 3, O = {P0,3, P1,3, P2,3} × {P0,3, P1,3, P2,3} so (O1, O2, O3) = (3, 2, 4). Thus for a ﬁxed , we can
deﬁne the exponential mechanism as follows:

(cid:18) 1

,

W

(˜p1, ˜p2, ˜p3) =

W = 3 + 2e−/2 + 4e−
e−
W

e−/2
W

,

(cid:19)

Pr[E1] + Pr[E2] + Pr[E3] = 3˜p1 + 2˜p2 + 4˜p3 = 1

Pr[E1] + 2 Pr[E2] + 3 Pr[E3] = 3˜p1 + 4˜p2 + 12˜p3 ≤ Csrv
k · CH

Discussion Our analysis shows that exponential mechanism can be used to reduce the percentage of
passwords breached by an optimal oﬄine adversary. When B = k(cid:48)|P| we will always have Pdet,B = 1. Thus,
we expect that the gain GB will decrease monotonically after this point which is indeed what we observe in
the plots. In the two round case we always had positive gain (e.g., for all B ≥ 0 we had GB > 0 for every
value of  that we tried). In the three round case we always had GB > 0 whenever  < 2.3. Observe that
GB does not always increase monotonically as we increase  (e.g., as we relax the security constraint). In
both the two round and the three round case GB increases monotonically with  as long as  ≤ 0.5, but after
this the graphs intersect indicating that diﬀerent values of  are better than others for diﬀerent B when the
exponential mechanism is used.

We note that the exponential mechanism does not incorporate any information about the adversary’s
budget B. The exponential mechanism SelPredsexp,≈2.3 with the largest value of  performs poorly against
smaller budgets B, but it provided the optimal defense in two rounds against an adversary with larger
budgets. If we know B in advance then we can often improve our construction of the SelPreds function
(see §7).

7 Client-CASH Optimization

In this section we show how to optimize the SelPreds function under the assumption that the size of the
password space |P| and the adversary’s budget B are known in advance. This may not be an unreasonable
assumption for many users. For example, Bonneau and Schechter estimated that for the SHA256 hash
function CH = $7× 10−15 [10], and Symantec reports that passwords generally sell for $4− $30 on the black
market. Thus, we might reasonably expect that a rational adversary will have a budget B ≤
7×10−15 =
4.29 × 1015. If the user selects passwords uniformly at random then it is reasonable to assume that |P| is
known. For example, we might have |P|= 1012 for users who memorize three random person-action-object
stories and use the associated action-object pairs for their password [3, 5].

Given a symmetric set O of outcomes our goal is to ﬁnd probability values ˜p1, . . . , ˜pn and a parameter
k which minimize the adversary’s success rate Padv,B in the event of an oﬄine attack. We must choose
these values in a way that satisfy our security and cost constraints (Table 1). This goal is stated formally as
Optimization Goal 1.

30

Constraints (1) and (2) specify that the ˜pi values must deﬁne a valid probability distribution and con-
straints (3) and (6) are the security and cost constraints from Table 1. Constraint (4) states that k, the
parameter controling the cost of the underlying hash function Hk in each round of Client-CASH, can be

14

Input Parameters: Csrv, CH , ,O, B,|P| , n
Variables:
minimize Padv,B subject to

˜p1, . . . , ˜pn, k, Padv,B

(1) ∀i ∈ {1, . . . , n}, ˜pi ∈ [0, 1]

n(cid:88)

i=1

(2)

(3) ∀i, j ∈ {1, . . . , n},

(5) Padv,B ≥ B

k|P| max
b∈F ∗

˜pi
˜pj

≤ e

O1 ˜p1b1 +

n(cid:88)

i=2

Oi ˜pibi

(cid:18) (cid:96)j

(cid:96)j − 1

i−1(cid:89)

j=1

(cid:19)

Oi · ˜pi = 1

(cid:26)

(cid:27)

(4) k ∈

1, . . . ,

Csrv
CH
jOj ˜pj ≤ Csrv
kCH

n(cid:88)

j=1

(6)

Optimization Goal 1: Minimizing the adversary’s probability of success.

(a) Two round mechansims.

(b) Three round mechanisms.

CH

Figure 2: Comparison of the percent reduction in cracked passwords GB between the optimal distribution
(blue) and the exponential distribution (orange) for as a function of B with a normalizing factor of
k(cid:48)|P| =
Csrv|P| for various values of . The results for the two round optimal mechanism is shown in (a), while the
three round optimal mechanism is shown in (b).
at most Csrv
. Otherwise it would be impossible to satisfy our cost constraint because just a single round
CH
of hash iteration would cost more than Csrv. Finally, constraint (5) implies that we must minimize Padv,B
subject to the assumption that the adversary responds with his optimal strategy (see Theorem 2 ).

1

We note that, for a ﬁxed value of k, Optimization Goal 1 becomes a linear program. Thus, we can solve
}
Optimization Goal 1 eﬃciently by solving the resulting linear program for each value of k ∈ {1, . . . , Csrv
and taking the best solution.

CH

7.1 Analysis

Figures 1c and 1d compare the optimal Client-CASH defense to the cost-equivalent deterministic key-
stretching defense. We use the same symmetric predicate sets O as in previous sections (two-round and

15

(a) Comparison of exponential mechanisms.

(b) Comparison of optimal mechanisms.

Figure 3: Comparison of the percent reduction in passwords between two-round mechanisms (blue) and
three-round mechanisms (orange) as a function of B with a normalizing factor of
Csrv|P| for various
values of . The results for the exponential mechanism are shown in (a), while the optimal mechanism is
shown in (b).

k(cid:48)|P| = CH

1

three-round). Figures 2a and 2b in the appendix directly compare the exponential mechanism and the
optimal mechanism.

Discussion Our results demonstrate that it is often possible to obtain even greater reductions in the
adversary’s success rate if we know the budget B in advance. For example, in the three round case n = 3
we can reduce the adversary’s rate of success by as much as GB = 21%. However, we note that the solution
to Optimization Goal 1 may not be optimal if the estimate of the adversary’s budget B is wrong. Thus, if
the user is uncertain about the adversary’s budget he may better oﬀ adopting the exponential mechanism.

Unlike the exponential mechanism we expect for the gain GB to increase monotonically with larger 
because we only loosen constraint (3). This is what we observe in Figures 1c and 1d. We also note that
when the adversary’s budget B exceeds k(cid:48)|P| we have Pdet,B = 1. Thus, GB must decrease monotonically
after this point because Padv,B will increase monotonically with B.

8 Practical Guidelines

All the Client-CASH mechanisms examined give reductions in the percentage of passwords breached by an
optimal oﬄine adversary. We also make the following recommendations of when a user should use a certain
mechanism.

Two Rounds vs. Three Rounds Figures 3a and 3b compare the two-round Client-CASH mechanism
mechanism to the three-round Client-CASH mechanism. Based on the results in Figure 3, we recommend
using three rounds of hashing in general. In particular, the three round mechanisms tend to achieve greater
gains in security. The one possible exception is when the adversary’s budget is smaller, but we are uncertain
about the adversary’s exact budget. In this one case the two round exponential mechanism might be the

16

right choice 6. Against adversaries with a larger budget the three round mechanism is the clear winner —
note that the gains remain positive for much larger values of the adversary budget B.

Information Leakage In general we would recommend that any implementation use  ≤ 2.08 so that the
outcome o leaks at most 3 bits of information about the user’s password. We note that if the adversary
breaches only the client then he would still need to complete a brute-force search over all passwords pwd ∈ P
to extract this information from o. In our demo implementation we selected security parameter  = 1.609
so that the outcome o of SelPreds will leak at most 2.32 bits of information about the user’s password.
Future versions might help the client to tune  himself. We selected  = 1.609 because it yielded the highest
reductions against an adversary with a larger budget B.

Adversary Budget
If we have an accurate estimation of the adversary’s budget B then we should compute
the SelPreds distribution using our algorithm from §7 before implementing Client-CASH. However, if this
estimation is not precise then it may be better to use the exponential mechanism from §6.

Password Distribution We only show how to optimize Client-CASH under the assumption that users
choose passwords uniformly at random. We hope that future work will extend this analysis to more general
password distributions. Until then Client-CASH should only be adopted by users who select uniformly
random passwords from some space.

Amortization of Costs Our guarantee that the client’s computational costs during authentication at
most Csrv only holds in expectation. Of course the user may get unlucky when we run SelPreds(pwd) and
end up with the maximum stopping time S(pwd, o) = n. We note that if key-stretching was performed by a
trusted third party (e.g., LastPass) then these costs could be amortized over diﬀerent users. If key-stretching
is only performed on the user’s local computer then we could give an unlucky user the option to speed up
the key-stretching process by memorizing an additional random character and appending it to his password
(e.g., see [10]).

8.1 Demo Implementation

A demo implementation of the three round exponential Client-CASH mechanism is available on client-cash.github.io7.
We implemented our algorithms in Javascript so the key-stretching is done locally by the user’s web browser.
In our implementation we used k = 100, 000 iterations of the SHA256 hash function H. Thus, Client-
CASH perform between 100, 000 and 300, 000 iterations of the SHA256 hash function to derive our ﬁnal
password. We selected n = 3 because the exponential mechanism performs better with n = 3 rounds of
hashing (see Figure 3a).

9 Conclusions and Future Work

In this work, we have introduced Client-CASH as a novel client-side key stretching mechanism which gives
better security guarantees than traditional key-stretching procedures.We make several contributions. First,
we show how to introduce randomness into a client-side key stretching algorithms through the use of halting
predicates which are selected randomly at the time of account creation. Second, we formalize the problem
of ﬁnding the optimal running time distribution subject to certain cost constraints for the client and certain
k(cid:48)|P| ≤ 0.5 for

6In Figure 3a, the two round exponential mechanism will outperform the three round mechanism when

B

security parameters  ≥ 1.6.

7The current demo implementation does not permanently save state for future authentication sessions though we anticipate

adding this functionality soon.

17

security constrains on the halting predicates. Finally, we demonstrate that Client-CASH can reduce the
adversary’s success rate by up to 21% ( in the n = 3 round case). These results demonstrate the promise
of the Client-CASH mechanism. In the future we hope that researchers will extend our analysis of Client-
CASH to handle non-uniform password distributions. We also speculate that it may be possible to obtain
even larger reductions in the adversary’s success rate by using predicate sequences O with more rounds of
hashing n > 3. Future work might extend our analysis of Client-CASH to explore this possibility.

Acknowledgments

This work was completed in part while Jeremiah Blocki was visiting the Simons Institute for the Theory of
Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptogra-
phy through NSF grant #CNS-1523467. Anirudh Sridhar was supported by a grant from the PNC Center
for Financial Services Innovation. Any opinions, ﬁndings, and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily reﬂect the views of Microsoft, the PNC Center
for Financial Services Innovation at Carnegie Mellon University or the National Science Foundation.

References

[1] R. Biddle, S. Chiasson, and P. van Oorschot. Graphical passwords: Learning from the ﬁrst twelve years.

ACM Computing Surveys (CSUR), 44(4):19, 2012.

[2] A. Biryukov, D. Dinu, and D. Khovratovich. Fast and tradeoﬀ-resilient memory-hard functions for
cryptocurrencies and password hashing. Cryptology ePrint Archive, Report 2015/430, 2015. http:
//eprint.iacr.org/.

[3] J. Blocki, M. Blum, and A. Datta. Naturally rehearsing passwords. In K. Sako and P. Sarkar, editors,
Advances in Cryptology - ASIACRYPT 2013, volume 8270 of Lecture Notes in Computer Science, pages
361–380. Springer Berlin Heidelberg, 2013.

[4] J. Blocki and A. Datta. Cash: A cost asymmetric secure hash algorithm for optimal password protection.

CoRR, abs/1509.00239, 2015.

[5] J. Blocki, S. Komanduri, L. F. Cranor, and A. Datta. Spaced repetition and mnemonics enable recall
of multiple strong passwords. In 22nd Annual Network and Distributed System Security Symposium,
NDSS 2015, San Diego, California, USA, February 8-11, 2014, 2015.

[6] J. Blocki, S. Komanduri, A. Procaccia, and O. Sheﬀet. Optimizing password composition policies. In

Proceedings of the fourteenth ACM conference on Electronic commerce, pages 105–122. ACM, 2013.

[7] J. Bonneau. The science of guessing: analyzing an anonymized corpus of 70 million passwords.

In

Security and Privacy (SP), 2012 IEEE Symposium on, pages 538–552. IEEE, 2012.

[8] J. Bonneau, C. Herley, P. C. van Oorschot, and F. Stajano. The quest to replace passwords: A framework
for comparative evaluation of web authentication schemes. In IEEE Symposium on Security and Privacy,
pages 553–567. IEEE, 2012.

[9] J. Bonneau and S. Preibusch. The password thicket: technical and market failures in human authenti-

cation on the web. In Proc. of WEIS, volume 2010, 2010.

[10] J. Bonneau and S. Schechter. ”toward reliable storage of 56-bit keys in human memory”. In Proceedings

of the 23rd USENIX Security Symposium, August 2014.

[11] X. Boyen. Halting password puzzles. In Proc. Usenix Security, 2007.

18

[12] S. Boztas. Entropies, guessing, and cryptography. Department of Mathematics, Royal Melbourne Insti-

tute of Technology, Tech. Rep, 6, 1999.

[13] J. G. Brainard, A. Juels, B. Kaliski, and M. Szydlo. A new two-server approach for authentication with

short secrets. In USENIX Security, volume 3, pages 201–214, 2003.

[14] S. Brostoﬀ and M. Sasse. Are Passfaces more usable than passwords: A ﬁeld trial investigation. In

People and Computers XIV-Usability or Else: Proceedings of HCI, pages 405–424, 2000.

[15] J. Camenisch, A. Lysyanskaya, and G. Neven. Practical yet universally composable two-server password-
authenticated secret sharing. In Proceedings of the 2012 ACM conference on Computer and Communi-
cations Security, pages 525–536. ACM, 2012.

[16] M. D¨urmuth and T. Kranz. On password guessing with gpus and fpgas.

[17] C. Dwork, A. Goldberg, and M. Naor. On memory-bound functions for ﬁghting spam. In Advances
in Cryptology - CRYPTO 2003, 23rd Annual International Cryptology Conference, Santa Barbara,
California, USA, August 17-21, 2003, Proceedings, volume 2729 of Lecture Notes in Computer Science,
pages 426–444. Springer, 2003.

[18] C. Dwork, F. McSherry, K. Nissim, and A. Smith. Calibrating noise to sensitivity in private data

analysis. In Theory of cryptography, pages 265–284. Springer, 2006.

[19] C. Dwork and A. Roth. The algorithmic foundations of diﬀerential privacy. Theoretical Computer

Science, 9(3-4):211–407, 2013.

[20] D. Florencio and C. Herley. A large-scale study of web password habits. In Proceedings of the 16th

international conference on World Wide Web, pages 657–666. ACM, 2007.

[21] C. Forler, S. Lucks, and J. Wenzel. Catena: A memory-consuming password scrambler. IACR Cryptology

ePrint Archive, 2013:525, 2013.

[22] I. Jermyn, A. Mayer, F. Monrose, M. K. Reiter, and A. D. Rubin. The design and analysis of graphical
passwords. In Proceedings of the 8th conference on USENIX Security Symposium - Volume 8, pages
1–1, Berkeley, CA, USA, 1999. USENIX Association.

[23] B. Kaliski. Pkcs# 5: Password-based cryptography speciﬁcation version 2.0. 2000.

[24] K. Kim, S. Lee, D. Hong, and J.-C. Ryou. Gpu-accelerated password cracking of pdf ﬁles. KSII

Transactions on Internet and Information Systems (TIIS), 5(11):2235–2253, 2011.

[25] S. Komanduri, R. Shay, P. Kelley, M. Mazurek, L. Bauer, N. Christin, L. Cranor, and S. Egelman.
Of passwords and people: measuring the eﬀect of password-composition policies. In Proceedings of the
2011 annual conference on Human factors in computing systems, pages 2595–2604. ACM, 2011.

[26] U. Manber. A simple scheme to make passwords based on one-way functions much harder to crack.

Computers & Security, 15(2):171–176, 1996.

[27] J. Massey. Guessing and entropy. In Information Theory, 1994. Proceedings., 1994 IEEE International

Symposium on, page 204. IEEE, 1994.

[28] F. McSherry and K. Talwar. Mechanism design via diﬀerential privacy. In Foundations of Computer

Science, 2007. FOCS’07. 48th Annual IEEE Symposium on, pages 94–103. IEEE, 2007.

[29] R. Morris and K. Thompson. Password security: A case history. Communications of the ACM,

22(11):594–597, 1979.

[30] C. Percival and S. Josefsson. The scrypt password-based key derivation function. 2012.

19

[31] J. Pliam. On the incomparability of entropy and marginal guesswork in brute-force attacks. Progress

in Cryptology-INDOCRYPT 2000, pages 113–123, 2000.

[32] N. Provos and D. Mazieres. Bcrypt algorithm.

[33] D. Reichl. Keepass password safe, 2013. Retrieved July, 10, 2013.

[34] B. Ross, C. Jackson, N. Miyake, D. Boneh, and J. C. Mitchell. Stronger password authentication using

browser extensions. In Usenix security, pages 17–32. Baltimore, MD, USA, 2005.

[35] R. Shay, P. Kelley, S. Komanduri, M. Mazurek, B. Ur, T. Vidas, L. Bauer, N. Christin, and L. Cranor.
Correct horse battery staple: Exploring the usability of system-assigned passphrases. In Proceedings of
the Eighth Symposium on Usable Privacy and Security, page 7. ACM, 2012.

A Missing Proofs

Let n be the number of rounds. Suppose that O is the set of all possi-
Reminder of Theorem 1.
ble predicate sequences such that for {P1, . . . , Pn} ∈ O, Pm ∈ {P0,(cid:96)m , . . . P(cid:96)m−1,(cid:96)m} for some ﬁxed (cid:96)m for all
m ∈ {1, . . . , n}. Then for all pwd, pwd(cid:48) ∈ P, O is symmetric, i.e. for all j ∈ {1, . . . , n}, |Oj,pwd|= |Oj,pwd(cid:48)|.
Proof of Theorem 1. We proceed by a simple counting argument. Suppose that j < n. Then Oj,pwd
consists of all outcomes which give a stopping time of j, so for every o = {P1, . . . Pn} ∈ Oj,pwd, we must
have Pi(Hik(pwd, su)) = 0 for i < j and Pj(Hjk(pwd, su)) = 1. Due to the structure of O, we can directly
calculate the value |Oj,pwd|, since for all choices of pwd, there will be 1 choice of the mth predicate which
will give an evaluation of 1 on the iterated hash, and (cid:96)m − 1 choices that give an evaluation of 0. Thus, for
j < n,

|Oj,pwd| = ((cid:96)1 − 1) × . . . ((cid:96)j−1 − 1) × 1 × (cid:96)j+1 × . . . × (cid:96)n−1

and when j = n, since we have a sequence of n − 1 predicates,

On,pwd = ((cid:96)1 − 1) × . . . × ((cid:96)n−1 − 1)

Since these calculations are independent of the password selected we can set Oj
= ((cid:96)1 − 1) × . . . ((cid:96)j−1 −
.
1) × 1 × (cid:96)j+1 × . . . (cid:96)n−1 for j < n and On = ((cid:96)1 − 1) × . . . ((cid:96)n−1 − 1). Now |Oj,pwd| = Oj for any password
pwd ∈ P and any j ∈ {1, . . . , n}. Thus, O is indeed symmetric.
(cid:3)
Theorem 4, stated informally in Table 1, shows how we can simplify our security constraints using the
symmetric set O from Theorem 1. The key observation is that Theorem 4 gives us one constraint for each
i, j ∈ {1, . . . , n} instead of multiple constraints for each password pair of passwords pwd (cid:54)= pwd(cid:48) that the
user might select. While the space of passwords may be very large, n, the number of rounds of hashing, will
typically be quite small (e.g., in this paper n ∈ {2, 3}).
Theorem 4 Suppose that O is constructed as speciﬁed in Theorem 1, equation 3 holds and ∀i, j ∈ {1, . . . , n}, ˜pi
e. Then ∀pwd, pwd(cid:48) ∈ P,∀o ∈ O, Pr[SelPreds(pwd)=o]
Pr[SelPreds(pwd(cid:48))=o]

≤ e.

˜pj

≤

Proof of Theorem 4. We begin by noting that for all passwords pwd ∈ P and for all outcomes o ∈ O we
can ﬁnd some m ∈ {1, . . . , n} such that

Pr[SelPreds(pwd) = o] = ˜pm ,

because {Oj,pwd} partitions O. Let pwd, pwd(cid:48) ∈ P be arbitrarily selected. Then for some i, j ∈ {1, . . . , n}
we have

Pr[SelPreds(pwd) = o]
Pr[SelPreds(pwd(cid:48)) = o]

=

˜pi
˜pj

20

which is in turn less than or equal to e by our second assumption. Thus,

Pr[SelPreds(pwd) = o]
Pr[SelPreds(pwd(cid:48)) = o]

≤ e

for all pwd, pwd(cid:48) ∈ P and for all o ∈ O. Thus -diﬀerential privacy is satisﬁed by these conditions.

(cid:3)

Similarly, Theorem 5,stated informally in Table 1, says that we exploit symmetry to simplify our cost
constraint. Before we had to satisfy separate cost constraints for all passwords pwd ∈ P. With symmetry
we only have to satisfy one cost constraint.

Theorem 5 Suppose that O and the ˜pi’s are constructed as speciﬁed in Theorems 1 and 4, and that
Oi ˜pi ≤ Csrv
k·CH

. Then for all pwd ∈ P we have

n(cid:80)

i · Pr[Ei,pwd] ≤ Csrv
k·CH

.

i=1

Proof of Theorem 5. Recall that Ej is the event that SelPreds(pwd) ∈ Oj,pwd for a ﬁxed pwd ∈ P. With
the symmetric construction of O and the design of the probability distribution, we have that Pr[Ej] =

Pr[SelPreds(pwd) = o] =

˜pj ≤ Oj ˜pj .

(cid:88)

o∈Oj,pwd

n(cid:80)

i=1

i ·

(cid:88)

o∈Oj,pwd

n(cid:88)

j=1

j × Oj ˜pj =

n(cid:88)

j=1

Thus,

j × Pr[Ej] ≤ Csrv
k · CH

(cid:3)

We defer the proof of Theorem 2 until appendix §B as it is more involved.

A.1 Future Work

The main goal of this work was to formalize the properties of the Client-CASH mechanism and show that
we can obtain signiﬁcant reductions in the number of passwords breached by an adversary. Naturally, there
are several extensions to our work which can increases the reduction in passwords breached even further.

• Number of rounds. We only analyze mechanisms using two and three rounds of hashing. We
have shown that using three rounds is always better than using two rounds, and it is possible that this
behavior continues by considering more rounds of hashing.

• Predicate structure. In our mechanisms we set (cid:96)i = n for all i ∈ {1, . . . , n}, but we can optimize
with respect to the (cid:96)i’s as well. More generally, we can use diﬀerent types of predicates to produce
a symmetric O (see §4 and Theorem 1). We note that this change would fundamentally alter our
adversary model.

• Non-uniform password selection. We assume in this work that a user who opts to use Client-
CASH is mindful of security and therefore will choose passwords roughly uniformly at random. A
typical user does not pick passwords uniformly, which is evident through recent password breaches.
Thus, we can also design Client-CASH with respect to a particular password distribution over the set
of users and treat the formulation in this paper as a special case.

21

B Adversary Analysis

Recall that Sm denotes the set of passwords hashed at least m times by the adversary, and Tm denotes the
set of passwords in P with stopping time at most m. Formally,

Sm = {pwd ∈ P : Hm×k(pwd) is computed by the adversary}
Tm = {pwd ∈ P : Pum (Hm×k(pwd)) = 1} for m < n

Recall that the strategy of the adversary is a n-tuple of sets (S1, S2, ...Sn) such that

• Sm is the set of passwords hashed at least m times
• S1 ⊆ P
• Sp ⊆ Sp−1 ∩ T c

p−1 for p > 1

• n(cid:80)

i=1

|Si|= B

k

We also assume that for m ≤ n, |Sm| is either 0 or of a non-negligible quantity compared to the number of
iterated hashes the adversary can compute, B
k . Since users pick passwords uniformly at random, if the size
of Sm is negligible compared to B
k , then the increase in the adversary’s probability of success will also be
negligible.
Let X ⊆ P be of non-negligible size and suppose that Pui = Pt,(cid:96)i for some t < (cid:96)i. Treating our cryp-
tographic hash like a random oracle and assuming that |P|(cid:29) n, we have with high probability that

(cid:12)(cid:12)(cid:12)(cid:12)Pr[pwd ∈ Ti | pwd ∈ X] − 1

(cid:96)i

(cid:12)(cid:12)(cid:12)(cid:12) =

(cid:12)(cid:12)(cid:12)(cid:12)|Ti ∩ X|

|X| − 1

(cid:96)i

(cid:12)(cid:12)(cid:12)(cid:12) < i

for small i > 0. We thus assume for simplicity that (cid:96)i × |Ti ∩ X|= |X| for all i ∈ {1, . . . , n − 1} as long as
X is of non-negligible size. Some cases of interest are when X = P to obtain (cid:96)i × |Ti|= |P| and X = Si to
obtain (cid:96)i × |Si ∩ Ti|= |Si|.

For m < n deﬁne

Bm := |{pwd ∈ Sm : S(pwd, ou) = m}|

where ou is the user’s output from the SelPredsfunction. We also deﬁne Bn := |Sn|. Since we assume we
face an optimal adversary, each pwd ∈ Sm such that S(pwd, ou) = m will also satisfy pwd ∈ Tm for m < n.
Thus, Bm = |Sm ∩ Tm| for m < n.

From this formulation, we obtain the following constraints

• S1 ⊆ P ⇒ (cid:96)1B1 ≤ |P|
• |Sm|≤ |Sm−1 ∩ T c

for 1 < m ≤ n

m−1|⇒ (cid:96)mBm ≤ ((cid:96)m−1 − 1)Bm−1

• |Sn|≤ |Sn−1 ∩ T c

n−1|⇒ Bn ≤ ((cid:96)n−1 − 1)Bn−1

• n(cid:80)

i=1

k ⇒ n−1(cid:80)

i=1

|Si|= B

(cid:96)iBi + Bn = B
k

22

We can rephrase these constraints by normalizing the values of the Bi’s relative to B

k . Deﬁne

(cid:40) k(cid:96)mBm

B
kBm

B

bm =

|Sm|
B/k

=

if m < n
if m = n

Intuitively, bm represents the fraction of the budget spent on hashing passwords at least m times. We
additionally note that since each of the Bi’s must be less than B
k , each of the bi’s must be less than or equal
to 1. Then we have

(cid:110)

• b = (b1, . . . , bn) ∈ [0, 1]n
• b1 ≤ k|P|
B ⇒ b1 ≤ min
• bm ≤ (cid:96)m−1−1

(cid:96)m−1

(cid:111)

1, k|P|

B

bm−1 for 1 < m ≤ n

• (cid:80)n

i=1 bi = 1

These are the necessary conditions for a feasible (optimal) adversary strategy. We can also show that is it
suﬃcient as well, that every b that satisﬁes these properties corresponds to an adversary strategy since the
conversion process from the adversary strategy tuple of sets (S1, . . . , Sn) to b is a reversible process (the
usage of b gives a set size, and (S1, . . . , Sn) gives the sets themselves, but the contents do not matter much
since passwords are selected uniformly at random). We can therefore equivalently deﬁne the feasible strategy

region F ⊆(cid:104)

(cid:110)

(cid:111)(cid:105)n

0, min

1, k|P|

B

such that all b ∈ F satisfy the above properties.

B.1 Maximum Adversary Budget

If the adversary’s budget is suﬃciently large, then the adversary will almost certainly be able to retrieve the
password and number of hashes necessary to breach an account. For example, if B
would be able to hash every password n times and therefore gain access to the account. We wish to ﬁnd the
minimum budget size such that the adversary succeeds with probability 1.

k = n|P|, the adversary

Step 1: The adversary determines and checks the set of passwords such that Pu1(Hk(pwd)) = 1. The

adversary must hash every password in the space, so there are |P|×k computations.

Step m (m < n): The adversary determines and checks the set of remaining passwords such that

(cid:16) (cid:96)i−1

(cid:96)i

m−1(cid:81)

i=1

(cid:17)|P| candidate passwords, so there are

(cid:16) (cid:96)i−1

(cid:96)i

(cid:17)|P|×k

m−1(cid:81)

i=1

Step n: The adversary determines and checks the set of passwords such that S(pwd, ou) = n. These
are the leftover passwords, so the adversary must hash all of these to breach the account. Thus there are

k (pwd)) = 1. There are roughly

Pum(Hm
computations.

(cid:16) (cid:96)i−1

(cid:96)i

n−1(cid:81)

i=1

(cid:17)|P|×k computations.

In total, for the adversary to succeed with probability 1,

B ≥ |P|×k +

|P|×k

We thus assume in the rest of our analysis that

(cid:32)

B
k

<

1 +

n−1(cid:88)

n−1(cid:88)

(cid:19)

(cid:18) (cid:96)i − 1
m(cid:89)
(cid:19)(cid:33)
(cid:18) (cid:96)i − 1

(cid:96)i

m(cid:89)

m=1

i=1

m=1

i=1

(cid:96)i

23

|P|

It is of interest to analyze the case where (cid:96)i = n for all i when we have n rounds. Then B

k <

(cid:32)

(cid:18) n − 1

(cid:19)m(cid:33)

n−1(cid:88)

1 +

m=1

n

(cid:19)m(cid:33)
(cid:32) n−1(cid:88)
(cid:18) n − 1
(cid:19)
(cid:18) nn − (n − 1)n

m=0

n

nn−1

|P|

|P|

|P| =

=

This is clearly an increasing function in n, so as long as we pick suﬃcient n (cid:28) |P| we can make sure the
adversary’s probability of success is less than 1.

B.2 The Adversary’s Probability of Success
Suppose that the adversary uses strategy b ∈ F . We deﬁne Pb to be the adversary’s probability of success
with this strategy. Then Pb is simply the probability of selecting the right password and hashing it the
correct number of times. Suppose that the user’s correct password is pwdu = pwd∗ for user u, and that
S(pwd∗, ou) = i. Then the adversary’s probability of success is the same as the probability that pwd∗ ∈ Si,
given that it has not reached its stopping time yet. Recall that

Tm = {pwd ∈ P : Pum(Hm×k(pwd)) = 1} for m < n

Then, for i > 1, Pr[Adversary succeeds ∩ S(pwd∗, ou) = i] =



T c
j

pwd∗ ∈ Si | pwd∗ ∈ i−1(cid:92)

 bi·B
(cid:17)
(cid:16) (cid:96)j−1
i−1(cid:81)

j=1

k

(cid:96)j

j=1

Pr[pwdu = pwd∗] × Pr[Ei] × Pr

=

1
|P| Pr[Ei]

=

1
|P| Pr[Ei]

|i−1(cid:84)
|Si|/|P|
j |/|P|
T c
i−1(cid:89)

j=1

(cid:96)j
(cid:96)j − 1

j=1

=

B
k|P| Pr[Ei]bi

In the case where i = 1, the probability is simply B
stopping times before hashing passwords for the ﬁrst time. We can now calculate Pb to be

k|P| Pr[E1]b1 since the adversary has no information about

However, the adversary has control over the particular strategy to execute. Let Padv denote the probability
of success for an optimal adversary. Then Padv,B = max
b∈F

Pb =

n(cid:88)

i=1

B
k|P|

Pb =

=

B
k|P| max
b∈F

Pr[Adversary succeeds ∩ S(pwd∗, ou) = i]

n(cid:88)

Pr[E1]b1 +
Pr[E1]b1 +

n(cid:88)

i=2

i−1(cid:89)

Pr[Ei]bi

i=2

j=1

(cid:96)j
(cid:96)j − 1

i−1(cid:89)

(cid:18) (cid:96)j

(cid:96)j − 1

j=1

Pr[Ei]bi


(cid:19) .

24

As an interesting special case of importance to us, let (cid:96)i = n for all i ≤ n. Then

Padv,B =

B
k|P| max
b∈F

=

B
k|P| max
b∈F

(cid:40)
(cid:40) n(cid:88)

i=1

Pr[E1]b1 +

Pr[Ei]bi

(cid:19)i−1(cid:41)

n(cid:88)
(cid:18) n

i=2

(cid:18) n
(cid:19)i−1(cid:41)

n − 1

Pr[Ei]bi

n − 1

B.3 Dominant Adversary Strategies

Calculating the optimal Padv for ﬁxed Pr[Ej]’s may be made eﬃcient if we consider dominant strategies of
the adversary; i.e. b∗ ∈ F which yield greater values of Padv than other b ∈ F independent of the values
of Pr[Ej]’s. Let Ai ⊆ F denote the collection of members of F such that bi is maximized. Formally, we
Ai is the collection of
deﬁne Ai := {b ∈ F : ∀b(cid:48) ∈ F, bi ≥ b(cid:48)
dominant strategies of the adversary.

i}. Then we claim that the collection F ∗ :=

n(cid:83)

i=1

Reminder of Theorem 2.
strategies are given by the collection of sets Ai = {b ∈ FB : ∀(cid:126)b(cid:48) ∈ FB, bi ≥ b(cid:48)
F ∗
B :=

Assume that O is constructed as in Theorem 1. The dominant adversary
i} for 1 ≤ i ≤ n. Let

Ai. Then

n(cid:83)

i=1

Proof of Theorem 2. Recall that the feasible strategy region F ⊆ [0, 1]n for a system with up to n rounds
of hashing is deﬁned as follows. For all b ∈ F ,

Padv,B =

B
k|P| max
b∈F ∗

B

• b1 ≤ min
• bm ≤ (cid:96)m−1−1

(cid:96)m−1

n(cid:88)

Pr[Ei]bi

i=2

j=1

i−1(cid:89)

(cid:18) (cid:96)j

(cid:96)j − 1

(cid:19)

• n(cid:88)

bi = 1

i=1

(cid:18) (cid:96)j

(cid:96)j − 1

i−1(cid:89)

j=1

(cid:19) .

for m > 1.

n(cid:88)

i=2

Pr[Ei]bi

(cid:110)

Pr[E1]b1 +
(cid:111)
Pr[E1]b1 +
(cid:16) (cid:96)j
(cid:17)
i−1(cid:81)

1, k|P|

bm−1

B

(cid:96)j−1

and that

Padv,B =

Noting that f (b) = Pr[E1]b1 +

n(cid:80)

B
k|P| max
b∈F

Pr[Ei]bi

i=2

j=1

is linear in b, we can rewrite the formula for Padv,B

as a linear optimization problem over the feasible strategy region F . This is shown in Optimization Goal 2.
We note that the maximum does indeed exist since it can be shown that the feasible region F is closed and
bounded.

It is a well known fact that for linear optimization, maxima are attained at the vertices of the feasible
region; that is, for a m-variable linear optimization, the maxima occur at the intersection of m constraints
(provided we have at least this many constraints). We show that all such maxima of Optimization Goal 2
are also elements of F ∗

n(cid:83)

Ai.

We ﬁrst observe that Optimization Goal 2 is eﬀectively an optimization in n− 1 variables; once the values
of n − 1 variables are determined, the last one can be calculated using Constraint n + 1. In particular, we

B =

i=1

25

(cid:110)

k|P| f (b) subject to

Input Parameters: B, k, n, P, Pr[Ej], (cid:96)j
Variables: b = (b1, . . . , bn)
maximize Padv,B = B
(Constraint 1) b1 ≤ min
(Constraint m) bm ≤ (cid:96)m−1−1
(Constraint n) 0 ≤ bn ≤ (cid:96)n−1−1
bn−1
(Constraint n + 1) b1 + . . . + bn = 1

1, k|P|

(cid:111)

(cid:96)m

(cid:96)n

B
bm−1 for 1 < m < n

Optimization Goal 2: The adversary’s probability of success as the solution to a linear program.

can write bn = 1 − (b1 + . . . + bn−1) and Constraint n + 1 would be rewritten as (b1 + . . . + bn−1) ≤ 1 to
reﬂect this substitution.

We can ﬁnd the set of possible maxima by considering all possible intersections of n− 1 constraints. Since
there are n + 1 constraints in total, this amounts to choosing 2 constraints to exclude in order to determine
a possible maxima.

Case 1: Constraint 1 is selected.
possible value. In this case, (cid:126)b ∈ A1 ⊆ F ∗
B.

If Constraint 1 is selected, the adversary sets b1 to its maximum

Case 2: Constraint 1 is excluded.

Constraint 1 is one of two constraints that are excluded, so
suppose we also exclude Constraint j. Suppose j = n + 1. Then Constraints 2-n are all set to equality, and
are thus directly proportional to b1. In particular, bn is proportional to b1. Thus, if the adversary maximizes
b1, bn is maximized as well. Thus, (cid:126)b ∈ An ⊆ F ∗
B.

Otherwise, suppose j ≤ n. Then the values of all variables are dependent on b1 and bj. In particular,

since all other constraints are set to equality, we have that
(cid:96)2 − 1
(cid:96)3

b3 =

b2 =

bm =

and similarily,

(cid:96)1 − 1
b1
(cid:96)2
(cid:96)m−1 − 1

(cid:96)m

bm =

bm−1 =

m(cid:89)

i=j+1

(cid:26)

1,

• b1 ≤ min
• bj ≤ (cid:96)j−1 − 1

(cid:96)j

(cid:96)1 − 1
(cid:96)2

b1

(cid:96)2 − 1
(cid:96)3

(cid:19)

b1 for m < j

b2 =

(cid:18) (cid:96)i−1 − 1
(cid:19)

(cid:96)i

i=2

m(cid:89)
(cid:18) (cid:96)i−1 − 1
(cid:27)

(cid:96)i

k|P|
B

bj−1 =

bj for m > j

n(cid:88)
(cid:18) (cid:96)i−1 − 1

i=1

bi = 1

(cid:19)

•

j(cid:89)

i=2

(cid:96)i

b1

We can now reduce our linear program to a much smaller set of constraints:

However, this new feasible system (which has the same objective function as the original linear program)

has only 2 variables; each bi is directly proportional to either b1 or bj, so for some α, β > 0,
αb1 + βbj = 1 ⇒ b1 = 1−βbj
α . Thus, we can reduce the system to just one variable. To calculate the
maximum of this new system, we need only pick one constraint to set to equality. If we pick the ﬁrst to set
to equality, then b1 is maximized, so by Case 1, (cid:126)b ∈ A1 ⊆ F ∗
B. Otherwise, if we set the second constraint to
equality, bj is equal to its upper bound, which is proportional to b1. By maximizing b1, we thus maximize
bj so (cid:126)b ∈ Aj ⊆ F ∗
B.

bi =

i=1

n(cid:80)

26

Thus since every potential maximum over the feasible region FB is in F ∗

B ⊆ F ,

Pr[E1]b1 +
n(cid:88)
Pr[E1]b1 +
n(cid:88)

i=2

i=2

Padv =

B
k|P| max
b∈F

=

B
k|P| max
b∈F ∗

B

(cid:18) (cid:96)j
i−1(cid:89)
(cid:18) (cid:96)j
i−1(cid:89)

j=1

(cid:96)j − 1

(cid:96)j − 1

(cid:19)
(cid:19)

Pr[Ei]bi

Pr[Ei]bi

j=1

(cid:3)

27

