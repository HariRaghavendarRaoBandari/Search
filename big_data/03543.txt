Community Detection: a Reﬁned Axiomization and Beyond

Gang Zeng1, Yuyi Wang2, Xingwu Liu1, Xiaoming Sun1, and Jialin Zhang1

1Institute of Computing Technology, Chinese Academy of Sciences

2Distributed Computing Group, ETH Z¨urich

1{zenggang, liuxingwu, sunxiaoming, zhangjialin}@ict.ac.cn, 2{yuyiwang920}@gmail.com

6
1
0
2

 
r
a

 

M
1
1

 
 
]
I
S
.
s
c
[
 
 

1
v
3
4
5
3
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

Borgs et al. [2016] investigate the essential require-
ments for community in preference networks, and
deﬁned six axioms on community detection rules
(or community functions). Two of these axioms
play critical roles in their system, however, it is
coNP-complete to check whether they are satisﬁed.
We propose efﬁciently-checkable alternatives to the
two axioms, and prove that various desirable prop-
erties are preserved. Most strikingly, the new ax-
ioms enable to easily ﬁnd constructive and consis-
tent community functions. Actually, we ﬁnd such a
natural community function which is also enumer-
able and samplable, answering an open problem in
the literature. We further discuss how to infer a cor-
responding preference network from a given col-
lection of communities. We completely solve the
problem when the simplest community rule is used,
and uncover an inherent limitation of preference
networks. Motivated by this observation, we extend
the concept of preference to multi-preferences and
prove that any collection of communities can be ex-
actly generated by multi-preferences.

1 Introduction
Community detection is a fundamental task in data min-
ing, which has been adequately studied on networks mod-
eled by graphs. However, there does not exist a widely ac-
cepted deﬁnition of clustering (see e.g., [Everett and Borgatti,
1998; Kannan et al., 2001; Dongen, 2002; Newman, 2004;
Shao et al., 2015]) or overlapping clustering (community)
(see e.g., [Palla et al., 2005; Zhang et al., 2007; Gregory,
2007; Yang et al., 2013]), which makes it challenging to com-
pare two or more clustering or community detection tech-
niques.

In order to tackle this problem in a systematic way, re-
searchers started considering axiomatic approaches. As a pio-
neer, Kleinberg [2003] developed an axiomatic framework for
clustering and deﬁned clustering functions whose inputs are
a node set V of size n and pairwise distances between these
n nodes. The output of a clustering function is a partition of
V . Based on Arrow’s impossibility theorem on social choice

[Arrow, 1963], he found that there are three simple proper-
ties which cannot be satisﬁed by any clustering function at
the same time.

Recently, Balcan et al. [2013] deﬁned communities in net-
works in which every node has a preference, i.e., a total
order of all nodes, by the community function proposed
by Mishra et al. [2008]. Borgs et al. [2016] called such net-
work a preference network and deﬁned community func-
tions that map a preference network to a set of communi-
ties. Preference networks can be used in various occasions,
e.g., voting ([Gale and Shapley, 1962; Gusﬁeld and Irving,
1989; Roth, 1984a]), network routing ([Rekhter and Li, 1994;
Caesar and Rexford, 2005]), and coalition formation in col-
laborative games ([Brams et al., 2003; Roth, 1984b]). Borgs
et al. also came up with six axioms for community functions.
They observed that community functions satisfying all the six
axioms form a lattice. In addition, they gave community func-
tions in the bottom (the minimum, called Ccliq) and in the top
(the maximum, called Ccomp) of the community function lat-
tice.

In the six axioms mentioned above, the group stability ax-
iom (GS) plays a very important role but is coNP-complete to
verify on a community. We deﬁne a new axiom strong group
stability (SGS) and then get rid of the coNP-completeness.

Though community detection is a classic topic, the inverse
problem of network generation has much less results. Net-
work generation is the problem of, given subsets of nodes,
inferring a preference proﬁle such that all the given subsets
are communities in the generated network. With this prefer-
ence proﬁle, one can ﬁnd some hidden communities that was
not present in the given set. Furthermore, we observe that in
order to capture some natural communities it is necessary to
use multi-preference networks (referred as multi-facted pref-
erence networks in [Borgs et al., 2016]) in which every node
is allowed to have multiple preferences. We propose an algo-
rithm to infer a multi-preference proﬁle from given commu-
nities.

In summary, our contributions are threefold:

1. We propose two polynomial-time-checkable alternatives
SSA and SGS to the two critical axioms SA and GS
which are coNP-complete to check.

2. We ﬁnd a natural, consistent, constructive, enumerable,
and samplable community function different from Ccliq,

answering an open problem in [Borgs et al., 2016].

3. We show that generally a multi-preference network can-
not be reduced to a single-preference network, and de-
velop an algorithm to infer a multi-preference proﬁle
from given communities.

The structure of this paper is as follows. In Section 2, we
give necessary notions and notations. We deﬁne polynomial-
time alternatives to two important axioms GS and SA in Sec-
tion 3. In the same section, we present a systematic way to
construct consistent and constructive community functions,
and give an ideal community function Cgrow. In Section 4,
we discuss the inverse problem of constructing preference
networks from given communities. For non-overlapping com-
munities, we construct a single preference proﬁle; for general
communities, we construct a multiple preference proﬁle. We
conclude this paper in Section 5 with an open problem.

2 Preliminaries
In this section, we review notions and notations that are used
in this paper. For more details, see [Borgs et al., 2016].

Let V be a non-empty ﬁnite node set and L(V ) be the set
of total orders on V . Every π ∈ L(V ) is a bijective mapping
π : V → {1, . . . , |V |}, denoted by [v1v2...v|V |] where vi =
π−1(i) for each i. For any u, v ∈ V and π ∈ L(V ), π(u)
is referred to the rank of u in π, and we say that π ranks u
higher than v if π(u) < π(v), denoted by u ≻π v.

A preference proﬁle on V is a list Π = {πu}u∈V ∈ L(V )V
of total orders on V . For each u, v, w ∈ V , πu is called the
preference of u, and by “u prefers v over w” we mean that
πu(v) < πu(w). A preference network is a pair (V, Π) where
V is a non-empty ﬁnite set and Π is a preference proﬁle on
V . A community rule (or community function) is a function
C that maps a preference network (V, Π) to a collection S of
subsets of V . If S ∈ C(V, Π), we say that S is a community
of (V, Π) according to C, and the term “according to C” will
be omitted if clear from context.

We consider community function Ccliq as an example.

Ccliq(V, Π) = {S ⊆ V : ∀u, v ∈ S, ∀w ∈ V − S, v ≻πu w}.

In this community rule, every community S is called a clique.
Roughly speaking, a clique is a subset of nodes preferring
each other over those not in the subset.

Borgs et al. [2016] formulated six axioms for community
functions. Let’s ﬁx a non-empty ﬁnite set V and a community
function C now.
Axiom 1 (Anonymity(A)) Let S, S′ ⊆ V , and Π, Π′ be
two preference proﬁles on V . Assume that S′ = σ(S) and
Π′ = σ(Π) for some permutation σ : V → V . Then
S ∈ C(V, Π) ⇔ S′ ∈ C(V, Π′).

This axiom means that whether S is a community is deter-

mined by the preference proﬁle rather than by labeling.

Axiom 2 (Monotonicity(Mon)) Let S ⊆ V , and Π, Π′ be
s v ⇒ u ≻πs v for
two preference proﬁles on V . If u ≻π′
∀s, u ∈ S and ∀v ∈ V , then S ∈ C(V, Π′) ⇒ S ∈ C(V, Π).

Intuitively, Monotonicity means that if the change of the
preference proﬁle does not increase the rank of any commu-
nity member at the cost of decreasing the rank of any other
member, then the community remains.

Axiom 3 (Embedding(Emb)) Given (V, Π) and (V ′, Π′)
such that V ′ ⊆ V and π′
u(v) = πu(v) for all u, v ∈ V ′,
then C(V ′, Π′) = C(V, Π) ∩ 2V ′.

This axiom means that if (V ′, Π′) is “embedded” into
(V, Π), then Π′ completely determines (V, Π)’s communities
in V ′.

Axiom 4 (World Community(WC)) For any preference
proﬁle Π on V , V ∈ C (V, Π).

To formulate the other two axioms, we need the following
deﬁnition.

Deﬁnition 1 (Lexicographical preference) Given π ∈ L(V ),
consider T, T ′ ⊆ V with |T | = |T ′|. If there is a bijection f :
T → T ′ such that g ≻π f (g), we say that π lexicographically
prefers T over T ′, denoted by T ≻π T ′.
Given a preference network (V, Π) and S ⊆ V , if there is no
T ⊆ V − S with |T | = |S| such that T ≻πu S for all u ∈ S,
then S is said to be self-approving with respect to Π. If for
all ∅ 6= G $ S, there is no T ⊆ V − S with |G| = |T | such
that T ≻πu S all for u ∈ S − G, then S is called group stable
with respect to Π.
Axiom 5 (Self-Approval(SA)) For any (V, Π),
C(V, Π), then S is self-approving with respect to Π.

if S ∈

Self-Approval requires that the members of a community
don’t uniformly prefer an outside subset over the community.

Axiom 6 (Group Stability(GS)) Given (V, Π),
C(V, Π), then S is group stable with respect to Π.

if S ∈

Group Stability means that a community cannot be parti-
tioned into two parts such that all elements in one part prefers
a subset out of the community over the other part.

There exist community functions satisfying all the axioms.

Examples include Ccliq and

Ccomp(V, Π) = {S ⊆ V : S is self-approving and group stable}.

Borgs et al. [2016] showed that this axiom system has nice
properties. The most impressive property is that all commu-
nity functions conforming to the six axioms, under operations
∩ and ∪, form a bounded lattice whose top and bottom are
Ccomp and Ccliq respectively. However, it is computationally
hard to verify the key axioms GS and SA.

Theorem 1 ([Borgs et al., 2016]) It is coNP-complete to de-
cide whether a subset S ⊆ V is self approval or group stable
with respect to a preference proﬁle.

3 Polynomial-time alternatives to GS and SA
This section deﬁnes alternatives to GS and SA which are
polynomial-time checkable, and show nice properties of the
new system of axioms.

3.1 Alternatives to GS and SA
The hardness of checking group stability of a subset S is
partially rooted at enumerating equal-sized subsets of S and
V − S. A natural idea to tackle this difﬁculty is to compare
subsets of S just with V − S directly, rather than with its
subsets. The ﬁrst obstacle to this reduction is to enable com-
paring subsets of different sizes, so we extend the concept of
lexicographical preference.
Deﬁnition 2 (Top-Lexicographical Preference) Given
G, G′ ⊆ V and π ∈ L(V ), assume1 m = |G| ≤ |G′|. If
there is an injection f : G → G′ such that g ≻π f (g) for any
g ∈ G, we say that π top-lexicographically prefers G over
G′, also denoted by G ≻π G′.
Now assume that G ≻π G′. By deﬁnition, when |G| = |G′|,
top-lexicographical preference is equivalent to lexicographi-
cal preference. When |G| > |G′|, it actually means that there
is T ( G with |T | = |G′| such that π lexicographically
prefers T over G′. When |G| < |G′|, we have that π lexi-
cographically prefers G over any T ( G′ with |G| = |T |.

By the deﬁnition of top lexicographical preference, we can

get two propositions.
Proposition 2 Given π, for all G, G′ ⊂ V with |G′| ≥ |G|, if
π top lexicographically prefers G′ over G, and G′ is a subset
of T ′, then π top lexicographically prefers T ′ over G.
Proposition 3 Given π, for all G, G′ ⊂ V , if π top lexico-
graphically prefers G′ over G, then for all T ⊂ G, π top
lexicographically prefers G′ over T .

Now we are ready to deﬁne the alternative SGS (namely
strong group stability) to GS. Let’s arbitrarily ﬁx a commu-
nity function C.
Axiom 7 (SGS) For any preference network (V, Π) and any
subset S ⊆ V , if S ∈ C(V, Π), then for any non-empty
T $ S, there is u ∈ S − T such that u does not top-
lexicographically prefer V − S over T .

Symmetrically, we have the following axiom which ﬁxes
S and enumerates subsets of V − S. It happens to formally
coincide with SA, hence called SSA (short for strong self-
stability).
Axiom 8 (SSA) For any preference network (V, Π) and any
subset S ⊆ V , if S ∈ C(V, Π), then for any T ⊆ V − S, there
is u ∈ S such that u does not top-lexicographically prefer T
over S.
Roughly speaking, GS considers a community S not good if
all members of some T ( S agree to replace S − T with a
common, equal-sized group outside of S (hence V − S ≻πt
S−T for all t ∈ T ), while SGS just requires V −S ≻πt S−T
for all t ∈ T , which essentially means two facts. First, S − T
can be replaced by a group of different size. Second, members
of T might not have a common replacement of S − T (in
case that |V − S| > |S − T |), but they reach an agreement
on kicking S − T out of their community. In this case, it is
reasonable to rule out such communities; see the following
example.

1We only deﬁne for the case |G| ≤ |G′|. A similar deﬁnition is

straightforward for the case |G| > |G′|.

Let V = {1, 2, ...5} and Π = (π1, π2, ...π5) with π1 =
[12534], π2 = [12534], π3 = [34512], π4 = [34512], π5 =
[51324], then S = {1, 2, 3, 4} should not be a community
since both {1, 2} and {3, 4} prefer V − S = {5} over each
other. Though SGS does rule out S as a community, GS and
SA cannot.

3.2 Properties
Here we present properties of SGS and SSA. First of all,
they are shown to be stronger than GS and SA, respectively.
Proposition 4 For any community function C, if it satisﬁes
SGS, then it also satisﬁes GS. Likewise for SSA and SA.
Proof. We prove this proposition by showing that for all com-
munities S, S /∈ CGS means S /∈ CSGS and S /∈ CSA means
S /∈ CSSA.

Given a preference network (V, Π),

in
CGS(V, Π), then there exist two non-empty subset T $ S
and T ′ ⊆ V − S such that |T ′| = |T | and for all nodes u in
S − T , u lexicographically prefers T ′ over T . By Proposition
2, u top lexicographically prefers V − S over T , which means
that S is not in CSGS(V, Π).

if S is not

If S is not in CSA(V, Π), then there exists a non-empty
subset T ′ ⊆ V − S such that |S| = |T ′| and for all nodes
u in S, u lexicographically prefers T ′ over S. By Proposition
2, u top lexicographically prefers V − S over S, which means
that S is not in CSSA(V, Π).
(cid:3)
Let Cscomp be the maximum community function that sat-
isﬁes both SGS and SSA, namely for any preference net-
work (V, Π), CSGS(V, Π) consists of all the subsets of V si-
multaneously allowed by SGS and SSA. It is a counterpart
of Ccomp in [Borgs et al., 2016], but in contrast to Theorem 1,
it is efﬁciently checkable in the following sense.

Algorithm 1 Decision Algorithm
1: procedure DETERMINE(V, Π, S)
2:
3:
4:
5:
6:
7:

for ∀u ∈ S do
G ← {u}
while G 6= S do

sign ← T rue
for ∀s ∈ S − G do

S over G then

if πs not top lexicographically prefers V −

8:
9:
10:
11:
12:

G ← G ∪ {s}
sign ← F alse
if sign = T rue then

return F alse

return T rue

We will show that the time complexity of determine algo-

rithm is O(|S|4)
Lemma 5 Given (V, Π) and S, if S does not satisfy SGS and
T ⊂ S is an evidence, then for all non-empty sets G ⊂ T , all
nodes in S − T top lexicographically prefer V − S over G.
The proof of Lemma 5 is straightforward by Proposition 3.
Lemma 6 Given (V, Π) and S ⊆ V , it is in time O (cid:0)|S|4(cid:1) to
decide whether S ∈ CSGS(V, Π).

Proof. We prove this lemma by showing that Algorithm 1
returns N o if and only if S is not in CSGS(V, Π).

If S is not in CSGS(V, Π), then there exists an evidence
T ( S. If the node u selected at line 3 is in T , then G will
always be a subset of T by Lemma 5, which means that Al-
gorithm 1 will terminate in line 10 and return N o. Since it
traversals all nodes in line 2, Algorithm 1 will return N o.

If the algorithm returns N o, then all nodes in S − G top
lexicographically prefer V − S over G, which means that S
is not in CSGS(V, Π).

There are three loops in Algorithm 1 and each loop runs
for |S| times at most. The complexity of line 7 is O(|S|), so
the complexity of Algorithm 1 is O(|S|4).
(cid:3)
Lemma 7 Given (V, Π) and S, if |S| > 1 and S ∈ CSGS,
then S ∈ CSSA
Proof. We prove this lemma by showing that if |S| > 1, then
S /∈ CSSA implies S /∈ CSGS.

If S is not in CSSA, then there exists a node set T ′ ⊆ V − S
such that for each node u in S, u top lexicographically prefers
T ′ over S. If |T ′| ≥ |S| and |S| > 1, then u prefers S − {u}
over T ′ by Proposition 3 and u prefers S − {u} over V − S
by Proposition 2, which means that S does not satisﬁes SGS
and {S − {u}} is an evidence of S. If |T ′| < |S|, let G be a
subset S such that |G| = |T ′|, then for all nodes u in S − G,
u top lexicographically prefers T ′ over G and V − S over G
by Proposition 2. By Proposition 3, u top lexicographically
prefers V − S over G, which means S not satisfying SGS. (cid:3)

Theorem 8 Given (V, Π) and S ⊆ V , Algorithm 1 decides
whether S ∈ Cscomp(V, Π) in time O(|S|4).
The proof of Theorem 8 is straightforward from Lemma 6
and Lemma 7.

Being efﬁciently checkable is a desirable property of
Cscomp. In the next subsection, we will use it to ﬁnd com-
munity functions that have various nice features as expected
in [Borgs et al., 2016].

To see CSGS satisfying M on, let Π and Π′ be preference
proﬁles such that for all u, s ∈ S and v ∈ V , u ≻π′
s v →
u ≻πs v. If there exists a community S not in CSGS(V, Π),
then there exists a non-empty node set T $ S such that for
each node u in S − T , πu top lexicographically prefers V − S

Notation: Let A = {A, M on, W C, Emb, GS, SA} and
SA = {A, M on, W C, Emb, SGS, SSA}. For a collection
X of axioms, a community is said to be X -consistent if it
conforms with all axioms in X .

We go on with showing that many good properties of A
are preserved by SA. An example is the intersection lemma,
one of the most important properties of A. Fortunately, it still
holds in SA.
Lemma 9 (Intersection Lemma) Given a community func-
tion C satisfying any axiom X in {A, M on, W C, Emb}, then
C ∩ Cscomp satisﬁes X, SGS and SSA.
Proof. We prove this lemma by showing that Cscomp satisﬁes
A, M on, W C and Emb. and it is straightforward that Cscomp
satisﬁes A, W C or Emb.

By Lemma 7, if CSGS satisﬁes M on, then Cscomp satisﬁes

M on.

over T . Since for all u, s ∈ S and v ∈ V , u ≻π′
s v → u ≻πs
s u, which means that for each
v, then v ≻πs u implies v ≻π′
node u in S − T , π′
u top lexicographically prefers V − S over
T and S is not in CSGS(V, Π′). So S ∈ CSGS(V, Π′) → S ∈
CSGS(V, Π), and CSGS satisﬁes M on.
(cid:3)
In some sense, the critical role of intersection lemma lies in
that it provides a normal form of consistent community func-
tions: the intersection of a simple community function with
Cscomp. Intersection lemma ensures the lattice structure of
SA-consistent community functions, which is also true for A
and is one of the most striking results in [Borgs et al., 2016].
Theorem 10 Let C denote all SA-consistent community
functions, then the algebraic structure T = {C, ∪, ∩} form a
bounded lattice whose top and bottom are Cscomp and Ccliq,
respectively.
Proof. The proof is straightforward by the intersection
lemma and the proof of Theorem 3.1 in Borgs et al. [2016].
(cid:3)

As a result, the richness of SA-consistent community func-
tions is to some extent determined by the difference between
Cscomp and Ccliq. Using an example inspired by [Borgs et al.,
2016] which showed that the size of Ccomp can be larger than
2|V |/2, we observe that Cscomp has the same property:
Proposition 11 For any positive integer n,
there exists
a preference network (V, Π) with |V | = n such that
|Cscomp(V, Π)| ≥ 2⌊n/2⌋.
Proof.
If n is an even number, consider a node set com-
posed of m hhero, sidekicki. Let H = {h1, h2, ..., hm}
be the set of heros and S = {s1, s2, ..., sm} be the
set of sidekicks. For all i ∈ [1, m], πhi = πsi =
[hi, h1, h2, ..., hm, si, s1, s2, ..., sm]. Let G be a subset of H.
Since the size of H ∪ G > 1, H ∪ G ∈ CSGS → H ∪ G ∈
Cscomp holds by Lemma 7.

If there exists non-empty G ⊆ S such that H ∪ G /∈
CSGS(V, Π), then any evidence T ⊂ H ∪ G is a subset of
G since all nodes prefer the nodes in H over other nodes.
But for all nodes si in G, there exists a node hi in H which
favourite si over other nodes in S and if si is in G, hi must
be in G, which leads to contradictory, and the size of Cscomp
is larger than 2⌊n/2⌋ .

If n is an odd number, then we set all preferences of n −
1 nodes in front of n nodes by above ways and ignore the
communities including the last node, and the size of Cscomp
is larger than 2⌊n/2⌋.
(cid:3)
Considering that the size of Ccliq(V, Π) is at most linear
(proved in Appendix), it seems that the collection of SA-
consistent community functions is rich and the lattice is far
from collapsing. The above proposition also implies that the
though SGS and SSA are stronger than GS and SA, the re-
striction is not too much.
3.3 Consistent, constructive community functions
A community function C is said to be constructive if for any
preference network (V, Π), the membership of C(V, Π) can
be checked in polynomial-time in |V |. Constructive com-
munity functions are desirable, but it is not easy to ﬁg-
ure out a non-trivial A-consistent one (non-trivial means

essentially different from Ccliq). Borgs et al. [2016] mainly
considered two families of candidates, namely Ccliq(g) and
Charmonious(λ) with non-negative real function g and real
number λ ∈ [0, 1]. They showed that though A-consistent,
Ccliq(g) ∩Ccomp and Charmonious(λ) ∩Ccomp are nonconstruc-
tive in general. The deﬁnitions of Ccliq(g) and Charmonious(λ)
are presented here in order to make this paper self-contained.
Deﬁnition 3 (Ccliq(g)) Given a non-negative number func-
tion g : N → N ∪ {0}, for any preference proﬁle (V, Π) and
S ⊆ V , S is a community according to Ccliq(g) if and only if
∀u, s ∈ S, πs(u) ∈ [1 : |S| + g(|S|)].
Deﬁnition 4 (Charmonious(λ)) Given λ ∈ [0, 1], for any pref-
erence proﬁle (V, Π) and S ⊆ V , S is a community according
to Charmonious(λ) if and only if ∀u ∈ S, v ∈ V − S, at least
λ-fraction of {πs : s ∈ S} prefer u over v.

On the other hand, in the context of SA, we have the fol-
lowing theorem mainly due to the intersection lemma and
Theorem 8.
Theorem 12 If a constructive community function C satisﬁes
A, M on, Emb and W C, then C ∩ Cscomp is SA-consistent
and constructive.

This theorem greatly simpliﬁes the problem of ﬁnding
SA-consistent constructive community functions, since it
is relative easy to ﬁnd a constructive one that satisﬁes all
of A, M on, Emb and W C. For example, for any non-
negative real function g and real number λ ∈ [0, 1],
Ccliq(g) and Charmonious(λ) conform with A, M on, Emb and
W C. Hence, Theorem 12 immediately implies the following
proposition.
Proposition 13 The community functions Ccliq(g) ∩ Ccomp
and Charmonious(λ) ∩Ccomp are SA-consistent and construc-
tive, for any non-negative real function g and any real number
λ ∈ [0, 1].

Furthermore, by Proposition 4, the two families commu-
nity functions in Proposition 13 are also A-consistent and
constructive.

In the next subsection we will go further in this direction
and ﬁnd a community function having more nice properties,
solving an open problem posed by Borgs et al. [2016].

3.4 Cgrow: an ideal community function
An ideal community function should not only be constructive
(meaning easy to check the communities), but also be easy to
present the communities. As a result, Borgs et al. [2014] (and
the arXiv version of [Borgs et al., 2016]) deﬁned two more
properties for community functions C:

• Samplable: given (V, Π), one can obtain a random sam-
ple of the communities in time polynomial in n = |V |;
• Enumerable: given (V, Π), one can enumerate C(V, Π)

in time O(nk|C(V, Π)|) for some constant k.

Borgs et al. [2016] proposed the following open problem.
Problem 1 (ACCSE) Find a natural community function
that allows overlapping communities and is A-consistent,
constructive, samplable, and enumerable.

Ccliq is ruled out, because Borgs et al. [2014] proved that it

does not allow overlapping communities.

We solve the ACCSE problem in this subsection. Actually,

the following stronger problem is solved.
Problem 2 (SACCSE) Find a natural nontrivial community
function that allows overlapping communities and is SA-
consistent, constructive, samplable, and enumerable.
The basic idea of our solution is reducing the problem accord-
ing to Theorem 12. Namely, if we ﬁnd a community func-
tion C satisfying A, M on, W C and Emb, then C ∩ Cscomp is
SA-consistent. Furthermore, if C is enumerable and |C(V, Π)|
is polynomial in |V | for all preference networks (V, Π)|,
C ∩ Cscomp will be enumerable and trivially samplable.

But how to ﬁnd such a community function C? Our ap-
proach is inspired by the method in [Palla et al., 2005].
Roughly speaking, starting with the most harmonious sub-
structures (namely, cliques), we grow the communities as
much as possible, by adding nodes that keep the communi-
ties harmonious. Intuitively, this process of growing conforms
with the formation of communities in real life (for example,
consider how friendship forms). The key of the approach is
to deﬁne harmonious communities, so we consider the fol-
lowing community function which is slightly adapted from
Charmonious(λ) in [Borgs et al., 2014].
Deﬁnition 5 (Charmon) Given a preference network (V, Π),
a subset S ⊆ V is a community according to Charmon if for
all u ∈ S and v ∈ V − S, more than half of the members of
S − {u} prefer u over v.

Borgs et al. [2016] proved the following lemma.

Lemma 14 Given a preference network A(V, Π) and
S1, S2 ∈ Cclique(V, Π), then S1 ⊂ S2, S2 ⊂ S1 or S1 ∩ S2 =
∅
Proposition 15 Given a preference network A(V, Π), the up-
per bound of community numbers of Cclique(V, Π) is 2|V |−1.
Proof. By Lemma 14, for all Π ∈ L(V )V , the number
of Cclique(V, Π) is less than max
(1 + Cclique(S, ΠS)) +
S⊂V
Cclique(V − S, ΠV −S). Let F (V ) be the upper bound of
Cclique(V, Π), then F (V ) = max
(1 + F (S) + F (V −

S$V &S6=∅

S)). We complete the rest of the proof by mathematical in-
duction.

If the size of V is 1, then F (V ) = 2|V | − 1 = 1 holds.
Suppose F (V ) = 2|V | − 1 holds for |V | < k. When |V |
(1 + F (S) + F (V − S)) =

equals to n, F (V ) = max

S$V &S6=∅

1 + 2|S| − 1 + 2|V | − 2|S| + 1 = 2|V | − 1.

By mathematical induction, the upper bound of community
(cid:3)

numbers of Cclique(V, Π) is 2|V | − 1.
Lemma 16 Given a preference network (V, Π) and S, it is
O(|V |3) to determine whether S is in Charmon(V, Π).
Proof. For each node u in S and each node v in V − S, it is
O(|S|) to determine whether the majority of S − {u} prefer u
over v, which means that it is O(|V |3) to determine whether
S is in Charmon(V, Π).
(cid:3)

Now we are ready to specify the community function C,
which is denoted Cgrow in this paper. Cgrow is deﬁned in
terms of Algorithm 2, i.e., for any preference network (V, Π),
Cgrow(V, Π) := CLIQUEGROWING(V, Π).

C ← QUEUE(Ccliq(V, Π))
R ← {}
while C is not empty do

Algorithm 2 Cgrow
1: procedure CLIQUEGROWING(V, Π)
2:
3:
4:
5:
6:
7:
8:
9:
10:

S ← C.pop(); R ← R ∪ {S}
for u in V − S do
S′ ← S ∪ {u}
if S′ ∈ Charmon(V, Π) then

C.push(S′)

return R

4.1 Non-overlapping community sets
This subsection characterizes the collection of communities
that can be generated by Ccliq. In [Borgs et al., 2014], it
was shown that for any preference network (V, Π), S =
Ccliq(V, Π) is non-overlapping, namely for any S1 6= S2 ∈ S,
either S1 ⊆ S2 or S2 ⊆ S1. Now we prove the other direc-
tion: any non-overlapping collection of subsets that includes
V can be generated by Ccliq.

The proof is constructive, and the desired preference proﬁle
is the output of Algorithm 3 (Get Preference Proﬁle), given a
non-overlapping collection S of subsets of V .

We ﬁx a total order σ = [1, 2, ..., n] ∈ L(V ), and deﬁne u’s
preference σu = [u + 1, u + 2, ..., n, 1, 2, ..., u] for ∀u ∈ V .
The notation σu|S means the total order on S obtained by
restricting σu to S. For example, if S = {1, 2, 3, 5}, then
σ3|S is [5, 1, 2, 3].

Given a preference network (V, Π) and S, there exists at
most one u ∈ V − S such that S ∪ {u} ∈ Charmon(V, Π).
Hence, starting with any community S ∈ Ccliq, at most
O(n) communities (in the sense of Charmon) can emerge.
In this way we get an upper bound O(|V |2) of the size of
Cgrow(V, Π).

Then we discuss the time complexity of Algorithm 2. The
If statement in line 8 is executed for |V − S| times for
each community S. This fact, together with Lemma 16, im-
plies that the time complexity of CLIQUEGROWING(V, Π) is
O(|V |6), which means that Cgrow is enumerable.

In addition, it is straightforward to show that Cgrow con-

forms with A, M on, W C and Emb.

Up to now, we have proved that Cgrow ∩ Cscomp is SA-
consistent, constructive, samplable, and enumerable. The
only issue not addressed is whether Cgrow ∩ Cscomp degen-
erates to Ccliq.
Proposition 17 For any node set V , there exists a prefer-
ence proﬁle Π such that the size of Cgrow ∩ Cscomp(V, Π) is
Ω(|V | log |V |).

Since the number of cliques of any preference network is
O(|V |), the community function Cgrow ∩ Cscomp far differs
from Ccliq. Altogether, we get the following theorem.
Theorem 18 Cgrow ∩ Cscomp is a natural nontrivial commu-
nity function that allows overlapping communities and is SA-
CCSE.

So, the problem SACCSE is solved. By Proposition 4,

Cgrow ∩ Cscomp also solves the problem ACCSE.

4 An inverse problem: inferring preference

proﬁle from communities

In this section, we deal with the problem of inferring the pref-
erence proﬁle from communities, namely, for a community
function C, given S ⊆ 2V , to ﬁnd a preference proﬁle Π such
that S = C(V, Π). If such Π exists, we say that S can be gen-
erated by C. As the ﬁrst step, we mainly consider and com-
pletely solve the case C = Ccliq.

Su ← SORTBYSIZEINCRE({S : u ∈ S ∈ S})
πu ← GETPREFERENCE(Su)

/*T should be an inclusive list of communities*/
initialize π s.t. for any v and w, v ≻π w if w appears

for ∀u ∈ V do

Algorithm 3 Get Preference Proﬁle
1: procedure GETPROFILE(V, S)
2:
3:
4:
5:
6:
7: procedure GETPREFERENCE(T )
8:
9:

Π ← {πu}u∈V
return Π

later than v in T

10:
11:
12:
13:

let T [0] stand for ∅
for i = 1 → |T | do

π ← T |T [i]−T [i−1]

return π

In Algorithm 3, Su is a list of communities containing u
sorted by size in increasing order, and Su[i] means the i-th
community in Su. For any T , πu ← σu|T means tuning πu
so that πu|T = σu|T and the other nodes are intact.

Intuitively, Algorithm 3 determines preference proﬁles one
by one. For each u ∈ V , GETPREFERENCE(Su) sets the pref-
erence proﬁle πu block by block as follows. Sorted by size
in increasing order, Su is an inclusive list of communities,
meaning that Su[i] ( Su[i + 1] for all 1 ≤ i < |Su|. Since the
last community in Su equals V , Su naturally decomposes V
into blocks: the i-th block is Su[i]−Su[i−1], with Su[0] , ∅.
πu is initialized such that block i ranks higher than block i+1
for all 1 ≤ i < |Su|. Then the order over each block is locally
tuned according to σu.
Theorem 19 If the set S of communities deﬁned on V is non-
overlapping and Π is the result of GETPROFILE(V, S), then
Ccliq(V, Π) = S.
Proof. Given V and S ⊂ 2V , let Π be result of GetΠ(V, S),
and we prove this theorem by showing that S ∈ Cclique(V, Π)
if and only if S ∈ S.

Let π|1:t denote the sub preference of preference π from
the ﬁrst node to t-th node. If S ∈ S, then for all nodes u in S,
πu|1,|S| ∈ L(S), which means that S ∈ Ccliq(V, Π).

If there exists S′ ∈ Cclique(V, Π) that is not in S, then
1 $ S′ be-
there exists an unique maximum Su
cause S is compatible, which means that there must exist a
node t in S′ − Su
1 is max-
imum, then St
1 and
t ∈ St
(cid:3)

1 . Since S is compatible and Su

1 must be a subset of Su

1, which leads to contradictory.

1 while t /∈ Su

1 such that Su

4.2 Multi-preference proﬁles
Now we know that any community set which includes V can
be generated by Ccliq if and only if it is non-overlapping. A
question then arises: given an overlapping collection of com-
munities, can it be generated by an A/SA-consistent com-
munity function? The answer is negative, considering the fol-
lowing example. Let V = {1, 2, · · · , n}. It is natural that
S1 = {1, 2} and S2 = {1, 3} are communities (taking
friendship as an example). However, for any preference pro-
ﬁle Π and any community function C satisfying GS or SGS,
C(V, Π) cannot contain S1 and S2 simultaneously.

So, the above mentioned preference networks are not ex-
pressive enough. A natural idea to tackle this problem is
to endow every node with multiple preferences, coinciding
with the concept of multi-preference proﬁle propsosed by
Borgs et al. [2016].

Multi-preference proﬁles naturally arise in practice. As
Borgs et al. [2016] mentioned, one member may have three
preferences – one based on ”family/friends”, one based on
”academic interests” and one based on ”business interests”.
Meanwhile, another member may have two preferences – one
based on ”sports” and one based on ”musics”.

u, π2

u, ...} where each πi

Formally, a multi-preference proﬁle eΠ on V is a list
{eπu}u∈V with eπu = {π1
u ∈ L(V )
is a preference of u on V . A single-preference proﬁle Π =
{πu}u∈V is said to belong to eΠ if for each node u ∈ V ,
πu ∈ eπu.
Any community function C on single-preference networks
can be generalized to multi-preference networks in a natu-
ral way: given a multi-preference network (V, eΠ), C(V, eΠ) ,
∪Π belongs to eΠC(V, Π)
We are ready to study the inverse problem for multi-
preference networks, namely, given a S ⊂ 2V , can we ﬁnd
a multi-preference proﬁle eΠ on V such that S = Ccliq(V, eΠ)?
When such a eΠ exists, we still say that S is generated by Ccliq.
The answer is yes, if V ∈ S. The desired multi-preference
proﬁle eΠ is found by Algorithm 4.
Algorithm 4 Get Exact Multi-Preferences
1: procedure GetExacteΠ(V, S)
2:
3:
4:
5:
6:
7:

initialize eπS
eπS
u ← σu|S
eπS
u ← σu|V −S
return eΠ

u w, ∀v ∈ S, w /∈ S

for S ∈ S do

u s.t. v ≻eπS

for u ∈ S do

In Algorithm 4, the total order is deﬁned in Subsection 4.1,

u in eπu such that eπS

and the operation in lines 5 and 6 is the same as that in Algo-
rithm 3. The algorithm is self-explained.
Theorem 20 Given S deﬁned on V , suppose eΠ be the result
of GetExacteΠ(V, S), and then S = Ccliq(V, eΠ).
Proof. For all communities S in S and for all nodes u in
S, there exists a preference eπS
u |1:|S| is
in L(S), which means that S is in Ccliq(V, eΠ) and S ⊆
Ccliq(V, eΠ).
If there exists a community S ∈ Ccliq(V, eΠ) not in S, then
S is not V and there must exist a node p ∈ S such that the
next node q of p in σ is not in S (Actually we treat σ as a circle
instead of a list, so if p is the last node in σ, then q is the ﬁrst
node in σ). Since p is in S, then there exists a preference πS ′
p
such that πS ′
p |1:|S| ∈ L(S). Since p is the last node of S′ in
πS ′
p , then S′ $ S. For all nodes v /∈ S′, πS ′
p favourite q over
v. It means that πS ′
p (q) equals to |S′| + 1 and must be less
than |S|, which leads to contradictory.
(cid:3)
GetExacteΠ(V, S) sets a preference eπS
u for u ∈ S in the in-
ner For loop, so the number of preferences in eπu is the num-
ber of communities containing u. To our surprise, though the
preferences for different nodes and different community are
constructed independently, their combination does not pro-
duce extra communities.

However, generally, in eΠ produced by Algorithm 4, each
nodes has too many preferences. Can we solve the problem
using fewer preferences? Fortunately, given a node set V and
a community set S ⊂ 2V , we ﬁnd an algorithm to generate a
multi-preference proﬁle eΠ with minimum preferences num-
ber such that S ⊆ Ccliq(V, eΠ).
Algorithm 5 Get Minimum Multi-Preferences
1: procedure GeteΠ(V, S)
2:
3:
4:
5:
6:
7:
8:
9:

Su ← {S : S ∈ S&u ∈ S}
let Gu be the inclusion graph of Su
Pu ← MINPATHCOVER(Gu) /*P is a set*/
for each P ∈ P do /*P is a list of communities*/

u ← GETPREFERENCE(P )
πP

eπu ← {πP

for ∀u ∈ V do

u : P ∈ P}

return eΠ = {eπu}u∈V

The procedure GETPREFERENCE is deﬁned in Algorithm
3. The inclusion graph Gu of Su is a directed graph with
communities in Su as vertices. For any two communities
S1, S2 ∈ Su with S1 ( S2, there exists a directed edge in
Gu from S1 to S2. MINPATHCOVER is the algorithm de-
ﬁned in [Ntafos and Hakimi, 1979] which solves the mini-
mum path cover problem on directed acyclic graphs. If the
inclusion graph is input, each output path is actually an inclu-
sive list of communities, so each P ∈ P is a valid input to
the procedure GETPREFERENCE . Because both GETPREF-
ERENCE and MINPATHCOVER are polynomial in time, so is
Algorithm 5.

u}u∈V such that S ⊆ Ccliq(V, eΠ′), |eπu| ≤ |eπ′

For each node u, the number of preferences in eπu is mini-
mum in the following sense. For any multi-preference proﬁle
eΠ′ = {eπ′
u| for
each u ∈ V .
Theorem 21 Given S ⊂ 2V , GETeΠ(V, S) outputs the mini-
mum eΠ such that S ⊆ Ccliq(V, eΠ).
Proof. For all communities S ∈ S and all nodes u ∈ S, there
exists a community set P in Pu such that S ∈ P . Let eπP
u be
u ∈ L(S), which
the result of GETPREFERENCE(P ), then eπP
means that S ∈ Ccliq(V, eΠ).
For all nodes u in V , the number of preferences in its multi-
preference is minimum for generating the communities in Cu,
so the number of preferences in multi-preference proﬁle is
minimum.
(cid:3)

Nevertheless, this eΠ may generate communities which are
not in S. For example, let V be {1, 2, 3, 4, 5} and S be
{{1, 2}, {1, 2, 4, 5}, {1, 4}, {1, 2, 3, 4}}. A legal conﬁgura-
tion of Pi, i = 1, 2, 5 is as follows.

• P1

:

{{1, 4}, {1, 2, 3, 4}}

P 1
1

= {{1, 2}, {1, 2, 4, 5}}, P 1
2

=

2 = {{1, 2, 3, 4}}
2 = {{1, 4}, {1, 2, 3, 4}}
1 = [41235], eπ(1)

2 = [12453],
4 = [14235]. Hence,

4 = [51243] and eπ(2)

1 = {{1, 2}, {1, 2, 4, 5}}, P 2
1 = {{1, 2, 4, 5}}, P 4
1 = [21453], eπ(2)

• P2 : P 2
• P4 : P 4
In this case, eπ(1)
eπ(2)
2 = [43125], eπ(1)
{1, 2, 4} ∈ Ccliq(V, eΠ) \ S, which means Ccliq(V, eΠ) * S.
5 Conclusion
In this paper, we studied the problem of deﬁning an axiomatic
system for community functions in a network. A previous
system included six axioms, but two of them, GS and SA,
are rather hard (i.e., coNP-complete) to verify while they play
very crucial roles in this system. We modiﬁed these axioms
and obtained two new axioms SGS and SSA. The time com-
plexity of determining whether a given subset S ⊆ V satis-
ﬁes the two new axioms, SGS and SSA, becomes O(|S|4).
By the intersection lemma, we found two constructive and
SA-consistent community functions. We also found an SA-
consistent, constructive, samplable and enumerable commu-
nity function that allows overlapping communities, and an-
swers to an open problem in [Borgs et al., 2016].

We dealt with the problem that inferring preference proﬁle
from communities. For a special class of community sets, we
completely solved this problem, and for general community
sets, we proposed multi-preference proﬁles and found an al-
gorithm to inferring a multi-preference proﬁle eΠ from a given
community set S such that S = Ccliq(V, eΠ). We also pro-
posed an algorithm to ﬁnd a minimum multi-preference pro-
ﬁle eΠ such that S ⊆ Ccliq(V, eΠ). A remaining open problem
is whether the minimum preference proﬁle eΠ can be chosen
to make sure S = Ccliq(V, eΠ).

of complex networks in nature and society.
435(7043):814–818, 2005.

Nature,

Y. Rekhter and T. Li. A border gateway protocol 4 (bgp-4).

RFC, 19(6):193–199, 1994.

Alvin E Roth. The evolution of the labor market for medical
interns and residents: a case study in game theory. The
Journal of Political Economy, pages 991–1016, 1984.

Alvin E Roth. Stable coalition formation: aspects of a dy-

namic theory. Business History, 1984.

Junming Shao, Zhichao Han, Qinli Yang, and Tao Zhou.
Community detection based on distance dynamics. In Pro-
ceedings of the 21th ACM SIGKDD International Con-
ference on Knowledge Discovery and Data Mining, pages
1075–1084. ACM, 2015.

Jaewon Yang, Julian McAuley, and Jure Leskovec. Commu-
nity detection in networks with node attributes.
In Data
Mining (ICDM), 2013 IEEE 13th international conference
on, pages 1151–1156. IEEE, 2013.

Shihua Zhang, Rui Sheng Wang, and Xiang Sun Zhang. Iden-
tiﬁcation of overlapping community structure in complex
networks using fuzzy c-means clustering. Physica A Statis-
tical Mechanics & Its Applications, 374(1):483–490, 2007.

References
Kenneth J. Arrow. Social Choice and Individual Values. Wi-

ley, 1963.

Maria-Florina Balcan, Christian Borgs, Mark Braverman,
Jennifer Chayes, and Shang-Hua Teng. Finding endoge-
nously formed communities. In Proceedings of the Twenty-
Fourth Annual ACM-SIAM Symposium on Discrete Algo-
rithms, pages 767–783. SIAM, 2013.

Christian Borgs, Jennifer T. Chayes, Adrian Marple, and
Fixed-points of social choice: An
CoRR,

Shang-Hua Teng.
axiomatic approach to network communities.
abs/1410.5152, 2014.

Christian Borgs, Jennifer Chayes, Adrian Marple, and Shang-
Hua Teng. An axiomatic approach to community detec-
tion. In Proceedings of the 7th conference on Innovations
in Theoretical Computer Science. ACM, 2016.

Steven J Brams, Michael A Jones, and D Marc Kilgour. Dy-
namic models of coalition formation: fallback vs. build-up.
In Proceedings of the 9th conference on Theoretical as-
pects of rationality and knowledge, pages 187–200. ACM,
2003.

Matthew Caesar and Jennifer Rexford. Bgp routing policies

in isp networks. Network, IEEE, 19(6):5–11, 2005.

Stijn Dongen. A new cluster algorithm for graphs. Informa-

tion Systems [INS], pages 1–42, 2002.

Martin G Everett and Stephen P Borgatti. Analyzing clique

overlap. Connections, 21(1):49–61, 1998.

David Gale and Lloyd S Shapley. College admissions and
the stability of marriage. American mathematical monthly,
pages 9–15, 1962.

Steve Gregory. An Algorithm to Find Overlapping Commu-
nity Structure in Networks. Springer Berlin Heidelberg,
2007.

Dan Gusﬁeld and Robert W Irving. The stable marriage prob-

lem: structure and algorithms. MIT press, 1989.

Ravi Kannan, Santosh Vempala, and Adrian Vetta. On clus-
terings: Good, bad and spectral. Foundations of Computer
Science Annual Symposium on, 51(3):367 – 377, 2001.

Jon Kleinberg. An impossibility theorem for clustering. Ad-
vances in neural information processing systems, pages
463–470, 2003.

Nina Mishra, Robert Schreiber,

Isabelle Stanton, and
Robert E. Tarjan. Finding strongly knit clusters in social
networks. Internet Mathematics, 5(1):155–174, 2008.

Mark EJ Newman. Detecting community structure in net-
works. The European Physical Journal B-Condensed Mat-
ter and Complex Systems, 38(2):321–330, 2004.

Simeon C. Ntafos and S Louis Hakimi. On path cover prob-
lems in digraphs and applications to program testing. Soft-
ware Engineering, IEEE Transactions on, (5):520–529,
1979.

Gergely Palla, Imre Der´enyi, Ill´es Farkas, and Tam´as Vic-
sek. Uncovering the overlapping community structure

