6
1
0
2

 
r
a

 

M
3
1

 
 
]

.

A
N
h
t
a
m

[
 
 

1
v
0
0
1
4
0

.

3
0
6
1
:
v
i
X
r
a

Modiﬁed Virtual Grid Diﬀerence for Discretizing the

Laplace-Beltrami Operator on Point Clouds

Meng Wang∗

Shingyu Leung†

Hongkai Zhao†

March 15, 2016

Abstract

We propose a new and simple discretization, named the Modiﬁed Virtual Grid Diﬀerence
(MVGD), for numerical approximation of the Laplace-Beltrami (LB) operator on manifolds
sampled by point clouds. The key observation is that both the manifold and a function
deﬁned on it can both be parametrized in a local Cartesian coordinate system and approxi-
mated using least squares. Based on the above observation, we ﬁrst introduce a local virtual
grid with a scale adapted to the sampling density centered at each point. Then we propose a
modiﬁed ﬁnite diﬀerence scheme on the virtual grid to discretize the LB operator. Instead of
using the local least squares values on all virtual grid points like the typical ﬁnite diﬀerence
method, we use the function value explicitly at the grid located at the center (coincided
with the data point). The new discretization provides more diagonal dominance to the re-
sulting linear system and improves its conditioning. We show that the linear system can be
robustly, eﬃciently and accurately solved by existing fast solver such as the Algebraic Multi-
grid (AMG) method. We will present numerical tests and comparison with other exiting
methods to demonstrate the eﬀectiveness and the performance of the proposed approach.

1

Introduction

Solving partial diﬀerential equations (PDEs) on surfaces or manifolds in general has many
important applications arising from problems in science and engineering. Examples include
diﬀusion process simulation on interfaces in multiphase problems in ﬂuids and materials, three
dimensional geometric modeling and shape analysis, manifold learning in high dimensional data
analysis, to name just a few. One numerical representation of the surface is given by a point
cloud which is the simplest, the most natural and ubiquitous way of sampling and representing
surfaces and manifolds of free form in three dimension and higher. Points cloud data are
routinely obtained by modern sensing technology and are extensively used in 3D modeling and
shape analysis. Feature vectors used in data analysis can also be viewed as point clouds typically
embedded in a high dimensional Euclidean space.

Various intrinsic diﬀerential operators have been successfully used to connect the dots to
extract geometric quantities and local/global structures from these unstructured point clouds.
Hence, it is desirable to develop eﬃcient and robust numerical methods for solving PDEs directly
on point clouds without a global mesh or parameterization. Although point clouds provide a
simple and ﬂexible way for geometric representations, it leads to diﬃculties when computing
integrals and solving diﬀerential equations. In this work, we propose a simple numerical method
for discretizing the Laplace-Beltrami (LB) operator on manifolds sampled by point clouds. The
LB operator is one of the most important diﬀerential operators deﬁned on manifolds. It models

∗Department of Mathematics, Hong Kong University of Science and Technology, Clear Water Bay, Hong Kong

(mwangae@ust.hk,masyleung@ust.hk).

†Department of Mathematics, University of California

at

Irvine,

Irvine, CA92697-3875, USA

(zhao@math.uci.edu).

1

diﬀusion process on surfaces in physics. The eigen-system of LB operator also provides an
intrinsic orthogonal basis for square integrable functions and it contains intrinsic geometrical
information of the underlying manifold. The LB operator and related tools such as the LB eigen-
map, the heat kernel and diﬀusion maps are used extensively in shape analysis and manifold
learning.

Given a manifold sampled by a point cloud, there are a few ways to approximate the LB
operator. One way is ﬁrst to construct a global mesh, e.g., triangulation, on the point cloud.
Then the LB operator can be readily approximated using any standard ﬁnite element method
based on variational formulation on the triangulation [4, 18, 16, 20]. This approach naturally
results in a symmetric positive deﬁnite linear system, which is the main advantage of the
approach. On the other hand, obtaining a global triangulation itself can already be a challenging
task. Moreover, the resulting triangulation may not be good enough for a stable ﬁnite element
method if the sampling of the point cloud is non-uniform. Instead of building a global mesh,
a local mesh method has been recently proposed in [7]. However, the discretized system is not
symmetric in general.

There are also a few methods for approximating the LB operator directly on point clouds.
Instead of building a mesh on point clouds, these methods only utilize neighboring points relation
and are particularly useful when a good quality global mesh is intractable. One type in this class
is the kernel based methods [1, 3, 2, 12, 17]. The idea is to transform the diﬀerential equation
into an integral equation. If the kernel function is the Green’s function for the LB operator
on the underlying manifold, an exact integral equation can be derived. However, since the
Green’s function for the LB operator is impossible to obtain in practice, one usually derive an
approximate integral equation using a radial symmetric kernel function in the ambient Euclidean
space with compact support or exponential decay, e.g., Gaussian. Even though kernel based
method can be generalized to more general settings such as graph Laplacian and diﬀusion maps,
the method is still mainly restricted to the diﬀusion operator. Kernel based methods typically
lead to a discrete linear system with a M-matrix, which gives the discrete system a maximum
principle analogous to that of the continuous problem. The approximation error is determined
by two competing scales. One is the spatial scale of the kernel at which geodesic distance of the
underlying manifold is approximated by the Euclidean distance in the ambient space. The other
is the ﬁner scale at which the data is sampled and such that integration at the kernel scale can
be approximated accurately enough. Although one can show that the solution to the integral
equation converges to the corresponding solution to the LB equation under certain sampling
conditions of the point cloud, the order of convergence is low.

Recently, motivated by our earlier work [10] where the grid based particle method (GBPM)
was developed for moving interface problems, [13, 14] has introduced another framework for
solving PDEs directly on point clouds. The GBPM represent and track a moving interface by
meshless Lagrangian particles based on an underlying Eulerian mesh. This results in a special
type of point clouds representation of the interface with a quasi-uniform sampling rate. We
refer interested readers to [10, 9, 11, 8, 15, 6] for a complete discussion on the representation. In
a follow-up work [8], the method has been further developed to solve several kinds of PDEs on
surfaces arising from physical and geometric ﬂow based on the GBPM. The key observation is
that both the manifold and the function on it can be parametrized in a local Cartesian coordinate
system at each point of the point cloud. Hence, diﬀerential operators can be approximated at
each point by applying a least squares approximation to both the manifold (and its metric)
and the function in the local coordinate system through neighboring points. The least squares
approximation in the approach introduce a more robust and ﬂexible discretization compared to
the exact interpolation on point clouds. The method applies to general diﬀerential operators
on point clouds sampling manifolds with arbitrary dimensions and co-dimensions. Local least
squares approximation allows also high order accuracy. Moreover, the computational complexity
depends mainly on the intrinsic dimension of the manifold rather than the dimension of the

2

embedded space. However, the computational cost for least squares approximation grows quickly
with the dimension of the manifold. Although local approximation accuracy is relatively easy
to achieve, a more important and more challenging issue is how to construct a discretization on
the whole point cloud so that the resulting linear system can be solved eﬃciently and stably.
For example, when applied to the LB operator, one can obtain a M-matrix system by using a
constrained quadratic programming optimization technique to enforce both the consistency and
diagonal dominance after the discretization [14].

In this work, we propose a new and simple discretization of the LB operator on point
clouds, called the Modiﬁed Virtual Grid Diﬀerence (MVGD). There are two key ideas in our
new approach. Based on the same observation that both the manifold and the function on it
can be parametrized in a local Cartesian coordinate system centered at each point of the point
cloud, we ﬁrst introduce a virtual grid with a scale adapted to the sampling density in the local
coordinate system and we apply ﬁnite diﬀerence scheme on the virtual grid to discretize the LB
operator. Secondly, functions values on the virtual grid used for the ﬁnite diﬀerence scheme are
interpolated from the local least squares approximation of the function except at the center
grid (coincided with the data point), where the function value at the data point is explicitly
used. As will be shown later, this MVGD discretization leads to a more diagonal dominant and
a better conditioned linear system which can be eﬃciently and robustly solved by many existing
fast solver for elliptic PDEs.

Using a simple 1D example with some explicit formula, we will show that the MVGD im-
proves both the numerical accuracy and computational stability as compared to the original least
squares approach. The numerical implementation is also simpler compared to the discretization
using the constrained quadratic optimization approach proposed in [14]. As demonstrated by
numerical tests, the MVGD can handle point clouds with non-uniform sampling reasonably well
too.

The paper is organized as follows. In Section 2, we ﬁrst brieﬂy summarize the approach
discussed in [14], and will discuss some issues associated to the discretization of LB operator.
The proposed method will be given in Section 3. Explicit discretization for the LB operator
for one and two dimensional manifolds will be explicitly constructed. A simple numerical
examples in one dimension will be provided a few insights. In Section 4, we ﬁrst test our new
discretization by solving the LB equation on point clouds. We then compute the eigenvalues
and the eigenvectors of the LB operator and make comparisons with other methods.

2 Background: Approximating the LB operator on point clouds

For simplicity, we consider a two-dimensional surface Σ in R3 parametrized by (s1, s2), the LB
operator acting on a function U : Σ → R is deﬁned by

∆ΣU =

2

Xα,β=1

1
√g

∂

∂sα (cid:18)√ggαβ ∂U
∂sβ(cid:19)

(1)

where the metric [gαβ] is given by

gαβ =

∂X
∂sα

∂X
∂sβ

,

with the surface Σ given by X(s1, s2). The function g = g11g22 − g12g21 is the Jacobian of the
metric and [gαβ] is the inverse of the matrix [gαβ].
Numerically, given a point cloud S = {pi | i = 1, ..., N} sampling Σ, we want to approximate
the above LB operator at any point pi ∈ S. A general framework has been proposed in [14].
The key idea is that both Σ and U are functions that can be parametrized in a local Cartesian
coordinate system centered at pi, and can be approximated to any desired order, e.g., by
polynomials using least squares on neighbors of pi. Then the LB operator (1) at pi can be

3

deﬁned in the local coordinate system and easily approximated as well. A key point is that
the resulting numerical approximation or discretization of the LB operator of a function at a
point pi is written as a linear combination of the function values at neighboring points of pi.
The coeﬃcients of the linear combination depends on the relative locations of the neighboring
points and the choice of least squares approximation. Although local approximation accuracy
is relatively easy to achieve, the central issue is essentially how to construct a discretization so
that the resulting linear system can be eﬃciently inverted in a stable manner. For example, it is
desirable for the discrete system to preserve analogous properties of the underlying continuous
diﬀerential operator. Without a global mesh, symmetry of the linear system is not possible in
general. Even so, it is still possible and desirable to obtain a M-matrix for the linear system
which gives discrete maximum principle and hence stability for the numerical solution. Here we
give a brief summary of the idea. For a detailed description, we refer interested reader to [14]
and some references thereafter.

For a given pi, we ﬁrst collect its K neighboring points, e.g., K nearest neighbors (KNN),
and denote them by N (i) = {pj
: pj belongs to the nearest K neighboring points of pi,
for j = 1, 2,··· , K}. Then the manifold is locally approximated using these points in an
appropriate Cartesian coordinate system centered at pi. For example, one can use standard
Principal Component Analysis (PCA) to obtain the local coordinate system. Let Ci be the
covariance matrix at point pi through its KNN,

Ci = Xpk∈N (i)

(pk − ci)T (pk − ci)

where ci is the local barycenter of N (i) given by

ci =

1

K Xpk ∈N (i)

pk .

The eigenvectors of the covariance matrix Ci provides a Cartesian coordinate system centered
at pi. To simplify the later notations, we denote the corresponding coordinates of KNN by
{(xj, yj, zj), pj ∈ N (i)}. Here the z-axis is in parallel to the eigenvector that corresponds to
the smallest eigenvalue and is an approximation of the surface normal at pi.
In this Cartesian coordinate system, the surface Σ is a graph near pi and can be locally

approximated by a polynomial, e.g., of second order, denoted by z(i)

z(i)(x, y) =

2

Xα=0 X0≤α+β≤2

a(i)
α,βxαyβ ,

where the metric gαβ in this coordinates system can be approximated by

with

[gαβ] =


∂z(i)
∂x
∂z(i)
∂y

∂x (cid:17)2
1 +(cid:16) ∂z(i)

∂z(i)
∂x

∂z(i)
∂y

∂zi)
∂x

∂z(i)
∂y

∂y (cid:17)2 
 ,

1 +(cid:16) ∂z(i)

= a(i)

1,0 + 2a(i)

2,0x + a(i)

1,1y ,

= a(i)

0,1 + 2a(i)

0,2y + a(i)

1,1x .

(2)

(3)

(4)

Numerically, the local approximation (2) can be computed using (weighted) moving least
squares (MLS). Given a function U deﬁned on Σ also sampled on the point cloud, we again

4

use MLS to approximate it in the same local coordinate system at pi, e.g., by a quadratic
polynomial, denoted by U (i),

U (i)(x, y) =

2

Xα=0 X0≤α+β≤2

b(i)
α,βxαyβ .

(5)

Note that such least squares approximation is valid only locally near pi. Unless the number of
points is the same as the degrees of freedom, which becomes an interpolation, the value of least
squares approximation at pi (when x = y = 0) is diﬀerent from Ui = U (pi) in general unless U
itself is a polynomial of the same degree or lower. The derivatives of U can be approximated
by the corresponding derivatives of the local least squares approximation. By expanding (1),
we obtain

∆ΣU (i)(x, y) ≃ A(i)

1

∂U (i)
∂x

+ A(i)
2

∂U (i)
∂y

+ A(i)
3

∂2U (i)
∂x2 + A(i)

4

∂2U (i)
∂x∂y

+ A(i)
5

∂2U (i)

∂y2

,

(6)

where coeﬃcients A(i)
, l = 1, . . . , 5 depend on the local metric, which can be computed from
l
local reconstruction of the surface (2) to (4). From the local approximation (5) for U (i), we
have:

∂U (i)
∂x

= b(i)
1,0,

∂U (i)
∂y

= b(i)
0,1,

∂2U (i)
∂x2 = 2b(i)
2,0,

∂2U (i)
∂x∂y

= b(i)
1,1,

∂2U (i)
∂y2 = 2b(i)
0,2 .

As U (i)(x, y) is the least squares approximation, we have the system of linear equation Ab = U
where

2,0, b(i)

1,0, b(i)

b =(cid:16)b(i)

0,0, b(i)
with the sum is taken over pi and its KNN, i.e. {pj ∈ N (i)}.
So, b(i)
α,β for α, β = 0, 1, 2 are all linear combinations of values of U at pi and pj ∈ N (i).
Thus, at every point on the point cloud, the LB operator can be discretized and expressed as
a linear combination of its value and its neighboring values, where the coeﬃcients depend on
the locations of neighboring points. By assembling the discretization at all points of the point
cloud together, we can obtain a linear system with the function value at each point of the point
cloud as unknowns. Each row of the matrix corresponds to the discretization of LB operator
at a point and we denote the matrix by A. First of all, A is not symmetric in general because
the least squares approximation at each point is computed in a local coordinate system through
its nearest neighbors. For a general point cloud, the relative positions of nearest neighbors for
two nearby points are diﬀerent. This fact is illustrated by Fig 1. Consider the two points (red
square) on a curve (black curve). Local coordinate systems are plotted using arrow (along the
normal) and dashed (along the tangent) lines, respectively. The x coordinate of each point
translated to the local coordinate system of the other point is denoted by a blue circle.
In
general, sa is diﬀerent from sb.

Local approximation order can be achieved by using certain higher order of polynomial
in the least squares approximation. For example, if quadratic polynomials are used for the
local least squares approximation for the LB operator, local truncation error is at least of ﬁrst

5

A =





K + 1 P xj P yj P x2
j P xjyj P x3
P xj P x2
j P x2
P yj P xjyj P y2
j P x2
j yj P x4
j P x3
P x2
j P x3
P xjyj P x2
j yj P xjy2
j P x2
j P y3
j P xjy2
P y2
U =(cid:16)X Uj,X xjUj,X yjUj,X x2
0,2(cid:17)T

1,1, b(i)

0,1, b(i)

j

j



j P xjyj P y2
j P x2
j yj P xjy2
j P y3
j yj P xjy2
j P x3
j yj P x2
j P xjy2
j yj P x2
j P y4
j P xjy3
j Uj(cid:17)T
j Uj,X xjyjUj,X y2



j y2

j y2

j

j y2

j

j

j

,

,

Figure 1: Discretization of the surface Laplacian gives a nonsymmetric matrix.

order (of second order if super-convergence happens) [14]. However, monotonicity or discrete
maximum principle is not preserved by the quadratic approximation. Moreover, the matrix A
can be quite ill-conditioned especially when the sampling density of the point cloud is highly
non-uniform. Therefore, a more challenging problem is how to construct a discretization so that
one can have a computationally eﬃcient algorithm to stably invert the resulting linear system.
To address these issues, one approach proposed in [14] is to enforce the consistency and the
diagonal dominance as constraints. Since consistency is guaranteed, which implies that the sum
of each row of A is zero, diagonal dominance is enforced if the diagonal element is of diﬀerent
sign with all oﬀ-diagonal elements. This means that the local least squares approximation is
transformed into a constrained optimization problem. The resulting discretization leads to a
M-matrix and hence the discrete maximum principle holds. However, quadratic programming
is used for the optimization at each point which increases the computational cost.

3 A new discretization of the LB operator

3.1 The Modiﬁed Virtual Grid Diﬀerence (MVGD)

One key idea for the MVGD is to introduce a virtual grid aliening with the local coordinate
system of each data point with the grid size adapted to the local sampling density. Instead of
using the derivatives of the local least squares approximation at the data point to approximate
the corresponding derivatives of the underlying function, we approximate the derivatives of
the underlying function by applying an appropriate ﬁnite diﬀerence method on the local least
squares approximation with the following modiﬁcation: the value of the original function instead
of the value of the least squares approximation is used at the center grid which coincides with
the data point.

Here we ﬁrst use the following 1D example to illustrate our method. Assume U is a function
deﬁned on a 1D curve sampled by a point cloud S with Ui = U (pi) and pi ∈ S. In a local
coordinate with origin at pi, let y(i)(x) be the least squares approximation of the curve and
U (i)(x) be the least squares approximation of U near pi in the local coordinate. With a virtual
grid in the x-dimension centered at pi and with a grid size h, we deﬁne the following MVGD
at pi to approximate derivatives of U ,

Ux(pi) ≈ ˜DhU (pi) , U (i)(h) − U (i)(−h)
Uxx(pi) ≈ ˜D2

and
hU (pi) , U (i)(h) − 2Ui + U (i)(−h)

2h

h2

.

(7)

6

Figure 2: Setup for the MVGD. Data from the point cloud (pi) are plotted in red squares. The
least squares approximation to the manifold (y(i)(x)) is plotted in the red dashed line. On this
parametrized surface, we obtain a least squares approximation to the function U , represented by
U (i)(x). Then we use the function value at x = ±h (located using black circles) to approximate
the derivatives of U at x = 0.

Note that we have replaced U (i)(0) by Ui = U (pi) for the central ﬁnite diﬀerence formula for
U (i)
xx (0). In general, for a least squares approximation, we have U (i)(0) 6= Ui and so ˜D2
hU (pi) 6=
U (i)
xx (0). In the case when we use a polynomial with a degree less than 3 in the least squares
approximation, we have

x (0) = ˜DhU (pi) .
U (i)

If the least squares polynomial has a degree less than 4, we have

U (i)

xx (0) =

U (i)(h) − 2U (i)(0) + U (i)(−h)

h2

6= ˜D2

hU (pi).

For a 1D curve, the LB operator in the local coordinate at pi is explicitly given by

∆ΣU =

1

p1 + y2

x

∂

∂x 

1

p1 + y2

x

∂U

∂x! =

Uxx
1 + y2

x −

yxyxxUx
x)2 ,
(1 + y2

(8)

which leads to the following two possible ways of discretizing the LB operator at pi.

1. The central diﬀerence

∆ΣU ≈

˜D2

hU (pi)
x (0)]2 −

1 + [y(i)

y(i)
x (0)y(i)

xx(0) ˜DhU (pi)

(cid:16)1 + [y(i)

x (0)]2(cid:17)2

;

(9)

2. The central diﬀerence in the divergence form

U (i)(h)
q1+[y(i)
x ( h

2 )]2 − 

1
q1+[y(i)
x ( h

2 )]2

+

1
q1+[y(i)
x (− h

2 )]2! Ui +

h2q1 + [y(i)

x (0)]2

U (i)(−h)
x (− h

q1+[y(i)

2 )]2

.

(10)

Both discretizations are easy to implement and have similar performance as will be shown on
a simple test in Section 4.2. For most of our tests we use the non-divergence form (9) in this
work.

The MVGD can be easily generalized to high dimensions for the LB operator. To approxi-
mate a derivative of U at a point pi, one can simply apply the standard centered diﬀerence to

7

the local least squares approximation U (i) of U on a virtual grid centered at pi and replace U (i)
at the center grid by Ui = U (pi) whenever needed.

The same strategy can be applied to other type of ﬁnite diﬀerence approximations. For
example, to solve the diﬀerential equation with an advection term such as the advection diﬀusion
equation, one should use an upwind or a one sided diﬀerence. We can made the following
modiﬁcation to the standard one sided diﬀerence,

h U (pi) , U (i)(h) − Ui
˜D+

h

and ˜D−

h U (pi) , Ui − U (i)(−h)

h

corresponding to the forward and the background diﬀerences, respectively.

The grid scale h of the virtual grid at each data point should be compatible with the local
sampling density of the point cloud, which will be justiﬁed to some extent below. At a point pi,
the general guideline is that h should not be too large so that U (i)(h) or U (i)(−h) becomes an
extrapolation of U in terms of local least squares approximation through its K neighbors N (i).
This should be avoided whenever possible since it may cause numerical instability. On the other
hand, h should not be too small compared to the spacing of data points near pi since it may
leads to unnecessary ill-conditioning of the linear system without gaining more accuracy. There
are many possible ways to choose h according to this guideline which all produce satisfying and
similar numerical results. For example, one could choose h to be the average spacing near pi
using its KNN. In our numerical experiments, we choose

h =

1
4

(max{xj, pj ∈ N (i)} − min{xj, pj ∈ N (i)})

(11)

for a one dimensional manifold (1D curve), which is one-fourth of the size of the interval that
contains the KNN in the local coordinate at pi. We use

h = minn 1

1

4(cid:0) max{xj, pj ∈ N (i)} − min{xj, pj ∈ N (i)}(cid:1),

4(cid:0) max{yj, pj ∈ N (i)} − min{yj, pj ∈ N (i)}(cid:1)o

for a two dimensional manifold.

For point clouds sampled from open surfaces with boundary, various boundary conditions
can be incorporated in the MVGD at boundary points. For an open surface Σ with the Dirichlet
boundary condition U|∂Σ = f , we just enforce this condition at all boundary points and use
the MVGD for all interior points. For an open surface with the Neumann boundary condition
∂nU|∂Σ = f , where n is the normal of the boundary in the tangent plane of the surface, we use
the following reﬂection method in the n direction.

Figure 3: Notation in the reﬂection method for imposing the Neumann boundary condition.
(Left) The open surface plotted in light red. (Right) The construction of pR
for the interior
i
point pI

i which has a boundary point pB

j as one of it’s KNN.

8

The key idea of the reﬂection method is to create an extended layer of ghost points by
reﬂecting those interior points near the boundary with respect to the boundary. The Neu-
mann boundary condition is used to reﬂect the function values at those interior points near the
boundary to their reﬂected points. Once the reﬂection is done, the MVGD discretization can be
applied at all interior points which results in a linear system that involve all interior points as
well as the Neumann boundary condition. In order to implement the reﬂection for an interior
point near the boundary, one needs to construct a local coordinate system at a corresponding
boundary point which consists of the normal to the surface, the tangent of the boundary and
the normal to the boundary in the tangent plane of the surface. To be more speciﬁc mathemati-
cally, let P I and P B be the sets of interior and boundary points in the point cloud, respectively.
For an interior point pI
i ∈ P I , we check if any of its KNN is a boundary point. If no, we just
use MVGD for the discretization at pI
i as described before. If yes, we need to create a ghost
point as the reﬂection of pI
i with respect to the boundary. First, we ﬁnd the closest boundary
point pB
j , i.e. j = argminkkpI
i − pB
j as follows.
Following the procedure proposed in [14], we use the k-nearest boundary neighbors of pB
in
j
P B to construct the boundary curve locally as rj(ξ) = (ξ, ηj(ξ), ζj (ξ)) in some local coordinate
system. This provides the tangent of the boundary at pB
j , denoted by e1. Using the PCA
on the k-nearest neighbors of pB
from the whole data set, one constructs the normal to the
j
surface at pB
in the tangent plane of
the surface is then given by e3 = e1 × e2. Assuming pI
i has coordinates (x, y, z) in this local
coordinate system, its reﬂection point pR
i has coordinates (x, y,−z). The setup is summarized
and is plotted in Figure 3.
Once the reﬂection point is determined, we impose the Neumann boundary condition ∂nU|∂Σ =

k k2 and construct a local coordinate system at pB

j , denoted by e2. Then the normal to the boundary at pB
j

f by assigning the function value at the reﬂected point by

i − pR

i ) +(cid:13)(cid:13)pI

j ) .

i (cid:13)(cid:13) · f (pB

U (pR

i ) = U (pI

Once we obtain all reﬂections of all interior points near the boundary with respect to the
boundary, we assign their function values by imposing the boundary condition and we use the
MVGD to discretize the diﬀerential operator at each interior point pI
i ∈ P I. Note that the
i consist of points in P I ∪ P R, where P R denotes the set of all reﬂected points. Hence
KNN of pI
a linear system involving all interior points is formed with the Neumann boundary condition
implicitly incorporated. Combining the treatments for the Dirichlet and the Neumann boundary
conditions, one can also easily deal with the general Robin type of boundary condition.

Finally, for the full linear system resulting from the above discretization for the LB operator

at each point, we ﬁnd that algebraic multi-grid (AMG) is a very eﬀective solver.

3.2 Some motivations and analysis of the MVGD

For simplicity, we use the Laplacian in R1 to shed some insights into the new discretization in
terms of both accuracy and stability.

3.2.1 Accuracy

In terms of local truncation error, from the deﬁnitions in (7), we have

˜D2

hU (pi) =

U (i)(h) − 2U (i)(0) + U (i)(−h)

h2

+

2(U (i)(0) − Ui)

h2

.

(12)

And so, one can see that when h is compatible with the local spacing of data points and quadratic
polynomial is used for least squares approximation, the two terms in the above expression for
local truncation error is of the same order. They are at least of O(h) and can be of O(h2) if the
distribution of data points has some symmetry so that super-convergence occurs (see [14]).

9

3.2.2 Stability

As discussed before, an important and more diﬃcult issue is for a discretization is to result a
better behaved linear system that can be solved stably and eﬃciently. Since we are discretiz-
ing the LB operator directly on a point cloud without a global mesh or parametrization, it is
rather hard, if not impossible, to design a discretization so that the resulting linear system has
a symmetric positive deﬁnite matrix. However, one can still hope that the linear system has
a M-matrix due to the use of least squares approximation instead of exact interpolation. Dis-
cretization based on the least squares approximation provides (i) more robustness with respect
to noise or almost degeneracy of point distribution, e.g., very close neighbors when sampling is
highly non-uniform, and (ii) ﬂexibility to satisfy both required accuracy and extra constraints.
For example, a constrained optimization approach was proposed in [14] to design such a dis-
cretization. However, quadratic programming has to be used for the optimization at each point.
Here we show that the proposed MVGD for the LB operator can also achieve this goal.

Since our discretization of the LB operator is consistent, the sum of each row of the matrix of
the discretized linear system is zero. If the matrix is diagonal dominant, then it is a M-matrix.
Below we construct an explicit example for the Laplacian in R1 to show that by using the value
of the original function instead of the value of the least squares approximation at the center
grid in the standard central ﬁnite diﬀerence scheme, diagonal dominance can be achieved for
the linear system when the grid size is comparable to the local spacing of the point cloud.

Consider that the discretization of the Laplacian of a function T on the straight line at the
point x = 0 as shown in Fig 4, and the function T is sampled at regular grid points with grid
size k.

T−2k

T−k

T0

T2k

Tk

approximating Txx at the origin

−2k −k

0

k

2k

Figure 4: A 1D example.

Assume T (0)(x) = a0 + a1x + a2x2 is the least squares quadratic approximation through
the function values at 5 points, i.e. Tj = T (jh) for j = 0,±1,±2. From the least squares
approximation, we have

5
0

10k2

0

10k2

0




and so

0

10k2

34k4 


a0
a1
a2




 =



1

1
1
−2k −k 0
4k2

k2

1
k

1
2k

0 k2 4k2 


T−2k
T−k
T0
Tk
T2k




,




a0
a1
a2





 =

1

70k2 


−6k2 24k2 34k2 24k2 −6k2
14k
−14k −7k
10
10

7k
−5 −10 −5

0




T−2k
T−k
T0
Tk
T2k




.




If we simply use the derivative of the least squares approximation at the origin, it leads to the
following discretization of Txx

Txx(0) ≈ T (0)

xx (0) = 2a2 =

1
7k2 (2,−1,−2,−1, 2)T

10

where T = (T−2k, T−k, T0, Tk, T2k)T . Although it is consistent with the second order local
truncation error, the resulting matrix is not diagonal dominant since oﬀ-diagonal elements have
mixed sign. This means that the linear system after discretization does not give a M-matrix
and this can cause numerical instability and might lead to non-convergence for many iterative
methods.

Now for the proposed MVGD discretization, we have
T (0)(h) − 2T0 + T (0)(−h)
10h2
k2 , 24 −

Txx(0) ≈ ˜D2
2

h2
5h2
k2 ,−36 −

hT (0)(0) =

70 h2 (cid:18)−6 +

=

=

h2

+ 2a2

2a0 − 2T0
5h2
k2 ,−6 +

10h2
k2 , 24 −

As long as

10h2

k2 (cid:19) T .

(13)

3

k(cid:19)2
5 ≤(cid:18) h

24
5

,

≤

all oﬀ-diagonal elements have diﬀerent sign from diagonal element which makes the discretized
linear system having a M-matrix. Since max xi = 2k and min xi = −2k in this simple example,
our choice of h according to (11) implies h = k and so the ratio (h/k)2 satisﬁes above conditions.
From this simple yet explicit example, we see that by replacing T0 by T (0)(0) at the center
grid in the modiﬁed central ﬁnite diﬀerence, we have introduced to the coeﬃcient a2 in the
new discretization an extra term, (a0 − T0)/h2. It can be easily checked that the magnitude
of the newly added term is of order O(h2) which is the same as |a2 − Txx(0)| when h ∼ k,
which is a special case of equation (12) when a quadratic polynomial is used for the least
squares approximation and data points are regularly distributed around 0. However, the key
observation is that this modiﬁcation enhances the diagonal dominance. In this special case, for
a given k, diagonal dominance is guaranteed for any h satisfying (13). For more general cases,
an explicit formula is more complicated since it depends on both the distribution of neighboring
points near 0 and the number of points used in the least squares approximation. Nevertheless,
we will demonstrate numerically that the new discretization of LB operator on point clouds will
indeed lead to a much better conditioned matrix in the following section.

Finally, in practice, at each point one could also determine the virtual grid spacing h by
the following dynamical approach. We can ﬁrst determine explicitly all the coeﬃcients in the
discretization for the LB operator in terms of h, and then we choose the value of h at each
sampling point to optimize the diagonal dominant property.

4 Numerical examples

In this section, we give numerical results from our proposed MVGD discretization of the LB
operator on point clouds. We are going to demonstrate that the new discretization indeed
provides better conditioning, stability and numerical accuracy when compared to the simple
least squares approach (without using the constraint optimization) as described in Section 2 as
proposed in [14]. For all numerical examples, the linear system corresponding to the MVGD
discretization is solved by the AGM. While the linear system corresponding to the simple least
squares approach cannot be typically solved by most common eﬃcient iterative methods and is
solved by GMRES in our tests.

4.1 Conditioning of the discretized system

Let A be the matrix corresponding to the discretization of the LB operator on a given point
cloud. We decompose it as A = M + N according to Gauss-Seidel iteration, i.e., N is upper
triangular portion of A. We compute the eigenvalues of matrix M −1N for a few point clouds
in 2D and 3D.

11

In our ﬁrst example, we have sampled the two curves in Fig 5 by the GBPM, where an
interface is sampled by closest points to those underlying mesh points in the vicinity of the
interface. A typical point cloud sampling an interface by the GBPM is illustrated in Fig 5 (a),
where we plot the underlying mesh in solid line, all active grids near the interface (a circle) using
little blue circles and their associated closest points on the interface using little red squares. The
correspondence between each pair is shown by a solid line link. The point cloud resulting from
the GBPM can be quite non-uniform because two closest points to two mesh points can be very
close or the same. The eigenvalues of matrix M −1N corresponding to the discretization using
the LS approach for these two point clouds are plotted in Fig 6. The unit circle in the complex
plane is plotted in red. As we can see clearly, the magnitude of most of these eigenvalues (blue
dots) are larger than one and there is no guarantee of convergence if Gauss-Seidel iteration
is used to solve the linear system. Fig 7 shows the eigenvalues corresponding to the MVGD
discretization. The magnitude of all eigenvalues are now less than 1. Hence, even the simple
Gauss-Seidel iteration can be used to solve the linear system.

0.85

0.8

0.75

0.7

0.65

0.6

0.55

0.5

0.45

0.4

0.35

0.4

0.5

0.6

0.7

0.8

0.9

1

(a)

(b)

Figure 5: (a) A circle sampled by the GBPM. (b) Another closed curve used in the test.

1.5

1

0.5

0

1.5

1

0.5

0

l

)
s
e
u
a
v
n
e
g
E
(
g
a
m

i

l

)
s
e
u
a
v
n
e
g
E
(
g
a
m

i

I

−0.5

−1

−1.5

−1.5

(a)

I

−0.5

−1

−1

−0.5

0

0.5

1

1.5

Real(Eigenvalues)

−1.5

−1.5

(b)

−1

−0.5

0

0.5

1

1.5

Real(Eigenvalues)

Figure 6: Eigenvalues of the Gauss-Seidel iterative matrix for LS on (a) a circle and (b) a closed
curve as shown in Fig 5 (b).

4.2 Solving the LB equation on point clouds

We ﬁrst consider a simple example, point clouds sampled from a unit circle centered at the
origin. On the unit circle, let U (θ) = −2 sin θ cos θ which solves −∆ΣU = −8 sin θ cos θ. We

12

1.5

1

0.5

0

1.5

1

0.5

0

l

)
s
e
u
a
v
n
e
g
E
(
g
a
m

i

l

)
s
e
u
a
v
n
e
g
E
(
g
a
m

i

I

−0.5

−1

−1.5

−1.5

(a)

I

−0.5

−1

−1.5

−1.5

−1

−0.5

0

0.5

1

1.5

Real(Eigenvalues)

−1

−0.5

0

0.5

1

1.5

Real(Eigenvalues)

(b)

Figure 7: Eigenvalues of the iterative matrix for MVGD on (a) a circle and (b) a closed curve
as shown in Fig 5 (b).

solve this LB equation on two diﬀerent point cloud data sets sampled on the circle. One is
evenly distributed and the other one is sampled by the GBPM. Fig 8 (a) shows the L∞ error
in the numerical solution versus the number of points on a uniformly sampled circle. Fig 8 (b)
plots the L∞ error in the numerical solution versus the grid spacing dx for a circle sampled by
the GBPM. Even though both methods seem to give second order convergence, the proposed
discretization in this paper can achieve a better accuracy in solving the LB equation. More
importantly, since the linear system resulted from the MVGD discretization can be solved by
any eﬃcient iterative solver, such as AMG, it is computationally much more eﬃcient. We have
implemented the MVGD for the LB operator using both central diﬀerence (9) and the divergence
form (10) and show results in Fig 8 (a). The two are comparable and both are signiﬁcant better
than that by using direct LS discretization.

10-2

10-3

r
o
r
r

E

10-4

10-5

10-4

r
o
r
r

E

10-6

10-8

10-6

102

(a)

103

Number Of Points

104

(b)

10-3

10-2

dx

Figure 8: Error in the numerical solution to the LB equation on point clouds sampled from a
circle. (a) Uniform sampling, and (b) Sampling by the GBPM. Red line: LS. Blue dash-dotted
line: MVGD in the non-divergence form. Black dash line: MVGD in the divergence form. Green
lines: reference curves of O(dx2) and O(dx3), respectively.

We carry out a similar test on a sphere. Let p be a point on any given surface Σ, we have

− ∆Σp = 2H(p)

(14)

where H(p) is the mean curvature vector on Σ [19]. If Σ is the unit sphere centered at the
origin, the mean curvature is one and the above equation is reduced to −∆Σp = 2p. To test the
convergence of the algorithm, we look at only the x-coordinate in p, i.e. we let the right hand
side of (14) be 2x and therefore the exact solution to the equation is simply x. Once again,

13

we consider two diﬀerent point clouds. One is the uniform sampling given by the Fibonacci
sampling [5], while the other one is sampled by the GBPM. These two diﬀerent samplings of
the sphere are shown in Fig 9.

(a)

(b)

Figure 9: Two samplings of a unit sphere. (a) The Fibonacci sampling and (b) the GBPM
sampling.

Fig 10 (a) shows the L∞ error versus the number of points on a uniformly sampled sphere,
and (b) shows the corresponding L∞ error versus the grid spacing dx on a sphere sampled by the
GBPM. We observe similar convergence behaviors as in the circle case. Both methods converge
in approximately second order. AMG works beautifully for the linear system discretized by the
MVGD. Table 1 presents the CPU time (in second) for solving the LB equation on a sphere
sampled by the uniform sampling. It shows that the CPU time is approximately linear in the
number of sampling points.

Sample size
CPU time (s)

500

0.0239

1000
0.0512

2000
0.133

4000
0.261

8000
0.365

16000
0.845

Table 1: The CPU time for solving LB equation discretized by the MVGD using the AMG.
Sample size represents the number of points on a uniformly sampled sphere. The CPU time is
approximately linearly proportional to the sample size.

10-2

10-3

r
o
r
r

E

10-4

10-2

10-3

r
o
r
r

E

10-4

(a)

103

104

Number Of Points

(b)

0.04

0.06

dx

0.08

0.1 0.12

Figure 10: Error in the numerical solution to the LB equation on a sphere. (a) The Fibonacci
sampling. (b) The GBPM sampling. Red line: LS. Blue dash-dotted line: MVGD. Green lines:
reference curves of O(dx2) and O(dx3), respectively.

14

4.3 Eigenvalues and eigenfunctions of the LB operator

In this section, we solve the eigenvalue problem for the LB operator on manifolds, i.e we deter-
mine constants λ and corresponding functions ν such that

−∆Σν = λν

on a given closed surface Σ. Numerically, we discretize the LB operator and determine the
eigenvalues λ and their corresponding eigenvectors ν such that Aν = λν using the function eigs
in MATLAB. For the LB eigenvalue problem on a unit sphere, the exact eigenvalues and their
corresponding eigenvectors are explicitly known. The n-th eigenvalue is given by λn = n(n + 1)
with multiplicity (2n + 1) and the associated eigenfunction is given by the spherical harmonics.

Uniform sampling

GBPM

samples
λ4 = 20
λ8 = 72

2000
0.48
1.2

4000
0.15
0.77

8000
0.12
0.34

16000
0.050
0.21

2007
1.2
1.9

4011
0.76
0.90

8048
0.35
0.76

16038
0.21
0.51

Table 2: E2

n (×10−2) on a sphere computed using MVGD discretization.

Uniform sampling

GBPM

samples
λ4 = 20
λ8 = 72

2000
0.72
1.76

4000
0.27
1.46

8000
0.25
0.74

16000
0.0765
0.38

2007
1.57
3.33

4011
1.05
1.68

8048
0.59
1.67

16038
0.38
1.22

Table 3: E∞

n (×10−2) on a sphere computed using MVGD discretization.

Uniform sampling

GBPM

samples
λ4 = 20
λ8 = 72

2000
2.1
26

4000
1.1
5.0

8000
0.54
2.5

16000
0.27
1.2

2007
1.5
6.8

4011
0.74
3.5

8048
0.37
1.7

16038
0.18
0.85

Table 4: E2

n (×10−2) on a sphere computed using the LS approach.

Uniform sampling

GBPM

samples
λ4 = 20
λ8 = 72

2000
2.49
28.25

4000
1.13
5.53

8000
0.57
2.63

16000
0.29
1.36

2007
1.56
7.3

4011
0.8
3.73

8048
0.42
1.9

16038
0.23
0.98

Table 5: E∞

n (×10−2) on a sphere computed using the LS approach.

Again we tests on two diﬀerent point clouds, one is uniform and the other one by the GBPM,
sampled on a sphere. For a particular eigenvalue λn, we deﬁne the following L2- and L∞-norm
error by

E2

n =vuut

1

2n + 1Xi (cid:18) λn,i − λn

λn

(cid:19)2

15

and E∞

n = max

i

λn,i − λn

λn

(cid:12)(cid:12)(cid:12)(cid:12)

,

(cid:12)(cid:12)(cid:12)(cid:12)

Sample size

Boundary points

λ5 = 30
λ13 = 182

500
20
1.27
10.02

1000
40
0.46
3.76

2000
80
0.54
2.16

4000
160
0.22
1.57

8000
320
0.14
0.85

Table 6: L∞ (×10−2) errors in the eigenvalues of the LB operator with the Dirichlet boundary
condition on the upper hemisphere.

where λn,i are the eigenvalues computed from the the discretized LB matrix A for eigenvalue,
and i = 1, 2, ..., 2n + 1. Table 2 and Table 3 summarize the results for our newly proposed dis-
cretization. As a comparison, we summarize the results using the simple least squares approach
in Table 4 and Table 5. In each of these tables, we look at the errors in the fourth and the
eighth eigenvalues (i.e. λ4 = 20 and λ8 = 72).

For the Fibonacci uniform sampling, MVGD based approach gives more accurate solutions
in all sampling densities. When the sampling density of the point cloud is quite non-uniform
such as the one obtained by the GBPM, the accuracy is comparable. Again, the more important
point is that the linear system corresponding to the new discretization is better conditioned and
can be solved much more eﬃciently by using oﬀ-the-shelf fast solver such as the AMG.

Note, however, that since the matrix is not symmetric, there is no guarantee that all obtained
eigenvalues are real. In fact, we have indeed obtained some complex eigenvalue pairs in the
solutions. For example, considering the sphere represented by the uniform sampling, we found
one complex pair among the ﬁrst 81 eigenvalues for the data with 2000 samples, and two complex
pairs for each of the samplings with 4000, 8000 and 16000 sampling points. Nevertheless, the
largest relative magnitude of the complex parts are given by 1.24×10−4, 1.29×10−5, 1.05×10−6,
and 1.71 × 10−5 for four diﬀerent sampling densities, respectively. When the surface is sampled
by the GBPM, we have a slightly larger number of complex pairs. Among the ﬁrst 81 eigenvalues
for the same number of sampling points as in Table 2, we found 9, 4, 7 and 3 complex eigen-
pairs with the largest relative magnitudes given by 2.14 × 10−3, 3.22 × 10−3, 1.34 × 10−3, and
7.56 × 10−4 for four diﬀerent sampling densities, respectively. When we determine the error in
the eigenvalues, we simply truncate the imaginary part of these complex eigen-pairs.
We also tested our new method to compute the eigenvalue problem of the LB operator on
several publicly available point clouds including a torus (768 points), a knot (36898 points) and
also the Stanford bunny (28006 points). We have computed the ﬁrst 30 smallest eigenvalues
(in magnitude) and their corresponding eigenfunctions. The sixth, the twenty-second and the
thirtieth eigenfunctions from the MATLAB function eigs are shown in Fig 11.

The proposed MVGD approach can also be applied to open surfaces. We compute the
eigenvalues and their corresponding eigenfunctions on an upper hemisphere with the Dirichlet
boundary condition ν|∂Σ = 0 and the Neumann boundary condition ∂nν|∂Σ = 0 imposed on the
unit circle on the x-y plane. Solutions to these problems can be analytically computed. The
multiplicities for the eigenvalue λn in both problems are given by n and their values are given
by λn = n(n + 1) and λn = n(n − 1), respectively. Some eigenfunctions are plotted in Fig 12
and Fig 13, respectively. Table 6 shows the L∞ error, E∞
n as deﬁned above, for λ5 and λ13
for the Dirichlet problem. The L∞ errors in the eigenvalues from the Neumann problem are
shown in Table 7. As we increase the number of sampling points, the errors in these numerical
solutions are reduced approximately linearly.

5 Conclusion

In this paper, we have proposed the Modiﬁed Virtual Grid Diﬀerence (MVGD) method for
discretizing the LB operator on manifolds sampled by point clouds. The discretization is very

16

Figure 11: The sixth, the twenty-second and the thirtieth eigenfunctions of the LB operator on
diﬀerent point clouds.

Figure 12: First few eigenfunctions of the LB operator with the Dirichlet boundary conditionon
the upper hemisphere.

simple to implement. The discretized system can achieve diagonal dominance and can be eﬃ-
ciently solved by many well developed iterative methods which then leads to a computationally
very eﬃcient method for solving the LB equation on manifolds. As a future application, we will
extend this proposed LB discretization to solve diﬀerential equations on moving interfaces.

17

Figure 13: First few eigenfunctions of the LB operator with the Neumann boundary condition
on the upper hemisphere.

Sample size

Boundary points

λ5 = 30
λ13 = 182

500
20
1.71
7.86

1000
40
0.86
4.75

2000
80
0.38
2.3

4000
160
0.18
1.07

8000
320
0.12
0.57

Table 7: L∞ (×10−2) errors in the eigenvalues of the LB operator with the Neumann boundary
condition on the upper hemisphere.

References

[1] M. Belkin and P. Niyogi. Towards a theoretical foundation for Laplacian-based manifold

methods. COLT, pages 486–500, 2005.

[2] M. Belkin, J. Sun, and Y. Wang. Constructing Laplace operator from point clouds in rd.
In Proceedings of the twentieth Annual ACM-SIAM Symposium on Discrete Algorithms,
pages 1031–1040. Society for Industrial and Applied Mathematics, 2009.

[3] R.R. Coifmam and S. Lafon. Diﬀusion maps. Appl. Comput. Harmon. Anal., 21(1):5–30,

2006.

[4] G. Dziuk. Finite elements for the beltrami operator on arbitrary surfaces. In S. Hilde-brandt
and R. Leis, editors, Partial diﬀerential equations and calculus of variations, 1357:142–155,
1988.

[5] ´Alvaro Gonz´alez. Measurement of areas on a sphere using Fibonacci and latitude–longitude

lattices. Mathematical Geosciences, 42(1):49–64, 2010.

[6] S. Hon, S. Leung, and H.-K. Zhao. A cell based particle method for modeling dynamic

interfaces. J. Comp. Phys., 272:279–306, 2014.

[7] R. Lai, J. Liang, and H. Zhao. A local mesh method for solving pdes on point clouds.

Inverse Problems and Imaging, 7(3):737–755, 2013.

[8] S. Leung, J. Lowengrub, and H.K. Zhao. A grid based particle method for high order
geometrical motions and local inextensible ﬂows. J. Comput. Phys., 230:2540–2561, 2011.

18

[9] S. Leung and H.K. Zhao. A grid-based particle method for evolution of open curves and

surfaces. J. Comput. Phys., 228:7706–7728, 2009.

[10] S. Leung and H.K. Zhao. A grid based particle method for moving interface problems. J.

Comput. Phys., 228:2993–3024, 2009.

[11] S. Leung and H.K. Zhao. Gaussian beam summation for diﬀraction in inhomogeneous
media based on the grid based particle method. Communications in Computational Physics,
8:758–796, 2010.

[12] Z. Li, Z. Shi, and J. Sun. Point Integral Method for Solving Poisson-type Equations on Man-
ifolds from Point Clouds with Convergence Guarantees. arXiv preprint arXiv:1409.2623,
2015.

[13] J. Liang, R. Lai, T.W. Wong, and H. Zhao. Geometric understanding of point clouds using
Laplace-Beltrami operator. Computer Vision and Pattern Recongnition (CVPR), pages
214–221, 2012.

[14] J. Liang and H. Zhao. Solving partial diﬀerential equations on point clouds. SIAM J. on

Scientiﬁc Computing, 35(3):A1461–A1486, 2013.

[15] J. Liu and S. Leung. A splitting algorithm for image segmentation on manifolds represented

by the grid based particle method. J. Sci. Comput., 56(2):243–266, 2013.

[16] M. Meyer, M. Desbrun, P. Schroder, and Alan H Barr. Discrete diﬀerential-geometry
operators for triangulated 2-manifolds. Visualization and Mathematics III, pages 35–57,
2003.

[17] A. Singer and H.-T. Wu. Spectral convergence of the connection Laplacian from random

samples. Submitted, http://arxiv.org/abs/1306.1587, 2015.

[18] G. Taubin. Geometric signal processing on polygonal meshes. EUROGRAPHICS, 2000.

[19] T.J. Willmore. Riemannian Geometry. New York: Oxford Science Publications, The

Clarendon Press, Oxford University Press, 1993.

[20] G. Xu. Convergent discrete Laplace-Beltrami operators over triangular surfaces. Geometric

Modeling and Processing, pages 195–204, 2004.

19

