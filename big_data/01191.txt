6
1
0
2

 
r
a

M
3

 

 
 
]

M
D
.
s
c
[
 
 

1
v
1
9
1
1
0

.

3
0
6
1
:
v
i
X
r
a

Completing partial schedules for Open Shop with

unit processing times and routing

René van Bevern1,(cid:63) and Artem V. Pyatkin1,2,(cid:63)(cid:63)

1 Novosibirsk State University, Novosibirsk, Russian Federation, rvb@nsu.ru

2 Sobolev Institute of Mathematics, Novosibirsk, Russian Federation,

artem@math.nsc.ru

Abstract. Open Shop is a classical scheduling problem: given a set J
of jobs and a set M of machines, ﬁnd a minimum-makespan schedule to
process each job Ji ∈ J on each machine Mq ∈ M for a given amount piq
of time such that each machine processes only one job at a time and each
job is processed by only one machine at a time. In Routing Open Shop,
the jobs are located in the vertices of an edge-weighted graph G = (V, E)
whose edge weights determine the time needed for the machines to
travel between jobs. The travel times also have a natural interpretation as
sequence-dependent family setup times. Routing Open Shop is NP-hard
for |V | = |M| = 2. For the special case with unit processing times piq = 1,
we exploit Galvin’s theorem about list-coloring edges of bipartite graphs
to prove a theorem that gives a suﬃcient condition for the completability
of partial schedules. Exploiting this schedule completion theorem and
integer linear programming, we show that Routing Open Shop with
unit processing times is solvable in 2O(|V ||M|2 log |V ||M|) · poly(|J |) time,
that is, ﬁxed-parameter tractable parameterized by |V | + |M|. Various
upper bounds shown using the schedule completion theorem suggest it to
be likewise beneﬁcial for the development of approximation algorithms.

Keywords. NP-hard scheduling problem, ﬁxed-parameter algorithm, edge list-
coloring, sequence-dependent family or batch setup times

1

Introduction

One of the most fundamental and classical scheduling problems is Open Shop [19],
where the input is a set J := {J1, . . . , Jn} of jobs, a set M := {M1, . . . , Mm} of
machines, and the processing time piq that job Ji needs on machine Mq; the task
is to process all jobs on all machines in a minimum amount of time such that
each machine processes at most one job at a time and each job is processed by
at most one machine at a time.

Averbakh et al. [3] introduced the variant Routing Open Shop, where the
jobs are located in the vertices of an edge-weighted graph whose edge weights

(cid:63) Supported by the Russian Foundation for Basic Research (RFBR) under research

project 16-31-60007 mol_a_dk.

(cid:63)(cid:63) Supported by the RFBR under research projects 15-01-00462 and 15-01-00976.

A route with s stays is a sequence R := (Ri)s

determine the time needed for the machines to travel between jobs. Initially, the
machines are located in a depot. The task is to minimize the time needed for pro-
cessing all jobs by all machines and returning all machines to the depot. Routing
Open Shop models, for example, tasks where machines have to perform main-
tenance work on stationary objects in a workshop [3]. Routing Open Shop has
also been interpreted as a variant of Open Shop with sequence-dependent family
or batch setup times [1, 37]. Formally, Routing Open Shop is deﬁned as follows.
Deﬁnition 1.1 (Routing Open Shop). An instance of Routing Open
Shop consists of a graph G = (V, E) with a depot v∗ ∈ V and travel times c : E →
N, jobs J = {J1, . . . , Jn} with locations L : J → V , machines M = {M1, . . . ,
Mm}, and, for each job Ji and machine Mq, a processing time piq ∈ N.
i=1 of stays Ri = (ai, vi, bi) ∈
N×V ×N from time ai to time bi in vertex vi for 1 ≤ i ≤ s such that v1 = vs = v∗,
a1 = 0, and bi + c(vi, vi+1) ≤ ai+1 ≤ bi+1 for 1 ≤ i ≤ s − 1. The length of R is
the end bs of the last stay.
A schedule S : J ×M → N is a total function determining the start time S(Ji,
Mq) of each job Ji on each machine Mq. That is, each job Ji is processed by each
machine Mq in the half-open time interval [S(Ji, Mq), S(Ji, Mq)+piq). A schedule
is feasible with respect to routes (RMq )Mq∈M if
(i) no machine Mq processes two jobs Ji (cid:54)= Jj at the same time, that is,
S(Ji, Mq)+piq ≤ S(Jj, Mq) or S(Jj, Mq)+pjq ≤ S(Ji, Mq) for all jobs Ji (cid:54)=
Jj and machines Mq,
(ii) no job Ji is processed by two machines Mq, Mr at the same time, that is,
S(Ji, Mq) + piq ≤ S(Ji, Mr) or S(Ji, Mr) + pir ≤ S(Ji, Mq) for all jobs Ji
and machines Mq (cid:54)= Mr,
(iii) machines stay in the location L(Ji) while executing a job Ji, that is, for each
k=1, there is a k ∈ {1, . . . , s}
job Ji and machine Mq with route RMq = (Rk)s
such that Rk = (ak,L(Ji), bk) with ak ≤ S(Ji, Mq) ≤ S(Ji, Mq) + piq ≤ bk.
A schedule S is feasible and has length L if there are routes (RMq )Mq∈M of
length L such that S is feasible with respect to (RMq )Mq∈M. An optimal solution
to a Routing Open Shop instance is a feasible schedule of minimum length.
Preemption and unit processing times. Open Shop is NP-hard for |M| = 3 ma-
chines [19]. Thus, so is Routing Open Shop with |V | = 1 vertex and |M| = 3
machines. Routing Open Shop remains (weakly) NP-hard even for |V | =
|M| = 2 [3]; there are approximation algorithms both for this special and the
general case [2, 11, 28, 36]. However, Open Shop is solvable in polynomial time if
(1) job preemption is allowed, or
(2) all jobs Ji have unit processing time piq = 1 on all machines Mq.
It is natural to ask how these results transfer to Routing Open Shop.
Regarding (1), Pyatkin and Chernykh [32] have shown that Routing Open
Shop with allowed preemption is solvable in polynomial time if |V | = |M| = 2,
yet NP-hard for |V | = 2 and an unbounded number |M| of machines.

2

Regarding (2), Routing Open Shop with unit processing times models tasks
where machines process batches of equal jobs in several locations and where the
transportation of machines between the locations takes signiﬁcantly longer than
processing each individual job in a batch. Herein, there are conceivable situations
where the number of machines and locations is small.
Routing Open Shop with unit processing times clearly is NP-hard even for
|M| = 1 machine since it generalizes the metric travelling salesperson problem.
It is not obvious whether it is solvable in polynomial time even when both |V |
and |M| are ﬁxed. We show the even stronger result that Routing Open Shop
with unit processing times is solvable in 2O(|V ||M|2 log |V ||M|)·poly(|J |) time, that
is, ﬁxed-parameter tractable.

Fixed-parameter algorithms. Fixed-parameter algorithms are an approach towards
eﬃciently and optimally solving NP-hard problems: the main idea is to accept the
exponential running time for ﬁnding optimal solutions to NP-hard problems, yet
to conﬁne it to some smaller problem parameter k [12, 14, 17, 31]. A problem with
parameter k is called ﬁxed-parameter tractable (FPT) if there is an algorithm that
solves any instance I in f (k)poly(|I|) time, where f is an arbitrary computable
function. The corresponding algorithm is called ﬁxed-parameter algorithm. In
contrast to algorithms that merely run in polynomial time for ﬁxed k, ﬁxed-
parameter algorithms can potentially solve NP-hard problems optimally and
eﬃciently if the parameter k is small.

Recently, the ﬁeld of ﬁxed-parameter algorithmics has shown increased interest
in scheduling [5, 7, 9, 10, 15, 24, 26, 30] and routing [6, 8, 13, 20–23, 35], yet
ﬁxed-parameter algorithms for routing scheduling problems are unexplored so far.

Our results. Using Galvin’s theorem on list-coloring edges of bipartite graphs [18,
34], in Section 3 we prove a suﬃcient condition for the polynomial-time com-
pletability of a partial schedule, which does not necessarily assign start times to
all jobs on all machines, into a feasible schedule.

We use the schedule completion theorem to prove upper bounds on various

parameters of optimal schedules, in particular on their lengths in Section 4.

Using these bounds and integer linear programming, in Section 5 we show that
Routing Open Shop with unit processing times is ﬁxed-parameter tractable
parameterized by |V | + |M| (unlike the general case when assuming P (cid:54)= NP).
Since the schedule extension theorem is a useful tool for proving upper bounds
on various parameters of optimal schedules, we expect the schedule completion
theorem to be likewise beneﬁcial for approximation algorithms.
Due to space constraints, some proofs are deferred to a full version of the paper.

Input encoding. In general, a Routing Open Shop instances requires at least
Ω(|J |·|M| +|V | +|E|) bits in order to encode the processing time of each job on
each machine and the travel time for each edge. We call this the standard encoding.
In contrast, an instance of Routing Open Shop with unit processing times can
be encoded using O(|V |2 · log cmax + |V | · log |J |) bits by simply associating with

3

each vertex in V the number of jobs it contains, where cmax is the maximum
travel time. We call this the compact encoding.
All running times in this article are stated for computing and outputting a
minimum-length schedule, whose encoding requires at least Ω(|J |·|M|) bits for the
start time of each job on each machine. Thus, outputting the schedule is impossible
in time polynomial in the size of the compact encoding. We therefore assume to get
the input instance in standard encoding, like for general Routing Open Shop.
However, we point out that the decision version of Routing Open Shop with
unit processing times is ﬁxed-parameter tractable parameterized by |V |+|M| even
when assuming the compact encoding: our algorithm is able to decide whether
there is a schedule of given length L in 2O(|V ||M|2 log |V ||M|) ·poly(|I|) time, where
I is an instance given in compact encoding. To this end, the algorithm does not
apply the schedule completion Theorem 3.4 to explicitly construct a schedule
but merely to conclude its existence.

2 Preprocessing for metric travel times

In this section, we show how any instance can be transformed into an equivalent
instance with travel times satisfying the triangle inequality. This will allow us
to assume that, in an optimal schedule, a machine only stays in a vertex if it
processes at least one job there: otherwise, it could take a “shortcut” bypassing
the vertex.
Lemma 2.1. Let I be a Routing Open Shop instance and I(cid:48) be obtained
from I by replacing the graph G = (V, E) with travel times c : E → N by a
complete graph G(cid:48) on the vertex set V with travel times c(cid:48) : {v, w} (cid:55)→ distc(v, w),
where distc(v, w) is the length of a shortest path between v and w in G with
respect to c.
Then, any schedule for I is a schedule of the same length for I(cid:48) and vice
versa. Moreover, c(cid:48) satisﬁes the triangle inequality c(cid:48)({v, w}) ≤ c(cid:48)({v, u}) +
c(cid:48)({u, w}) for all u, v, w ∈ V and can be computed in O(|V |3) time.
Lemma 2.2. Let S be a feasible schedule of length L for a Routing Open
Shop instance satisfying the triangle inequality.

Then, S is feasible with respect to machine routes (RMq )Mq∈M of length at
most L such that, for each route R = ((ak, vk, bk))s
k=1 and each stay (ak, vk, bk)
on R, except, maybe, for k ∈ {1, s}, there is a job Ji ∈ J with S(Ji, Mq) ∈ [ak, bk).
Clearly, from Lemma 2.2, we get the following:
Observation 2.3. Vertices v ∈ V \ {v∗} with Jv = ∅ can be deleted from a
Routing Open Shop instance satisfying the triangle inequality, where v∗ is the
depot.

From now on, we assume that our input instances of Routing Open Shop
satisfy the triangle inequality and exploit Lemma 2.2 and Observation 2.3.

4

3 Schedule completion theorem

In this section, we present a theorem that allows us to complete partial schedules,
which do not necessarily assign a start point to each job on each machine, into
feasible schedules.

In the following, we consider only Routing Open Shop with unit processing
times and say that a machine Mq processes a job Ji at time S(Ji, Mq) if it processes
job Ji in the time interval [S(Ji, Mq), S(Ji, Mq) + 1). We use S(Ji, Mq) = ⊥ to
denote that the processing time of job Ji on machine Mq is undeﬁned.
Deﬁnition 3.1 (Partial schedule). A partial schedule with respect to given
routes (RMq )Mq∈M of length at most L is a partial function S : J × M → N
satisfying Deﬁnition 1.1(i–iii) for those jobs Ji, Jj ∈ J and machines Mq, Mr ∈ M
for which S(Ji, Mq) (cid:54)= ⊥ and S(Jj, Mr) (cid:54)= ⊥. For a partial schedule S : J ×M →
N, we introduce the following terminology:
J S
MS
T S
T S
T RMq

:= {Ji ∈ J | S(Ji, Mq) = ⊥} is the set of jobs that lack processing by
:= {Mq ∈ M | S(Ji, Mq) = ⊥} is the set of machines that job Ji lacks
:= {t ≤ L | ∃Mq ∈ M : S(Ji, Mq) = t} is the set of time units where
:= {t ≤ L | ∃Ji ∈ J : S(Ji, Mq) = t} is the set of time units where
:= {t ≤ L | there is a stay (ai, v, bi) on RMq such that ai ≤ t < bi} are

machine Mq,
processing of (note that Ji ∈ J S

machine Mq is processing,
the time units where Mq stays in a vertex v ∈ V , and

if and only if Mq ∈ MS

job Ji is being processed,

Jv := {Ji ∈ J | L(Ji) = v} is the set of jobs in vertex v ∈ V of G.

),

Mq

Mq

Mq

Ji

Ji

Ji

v

routes and, for each vertex v ∈ V , let(cid:83)gv

The schedule completion theorem will allow us to turn any completable partial
schedule into a feasible schedule. Intuitively, a schedule is completable if a machine
has enough “free time” in each vertex to process all yet unprocessed jobs and to
wait for other machines in the vertex to free their jobs.
Deﬁnition 3.2 (Completable schedule). Let (RMq )Mq∈M be a family of
v := M be a partition of machines
such that, for any two machines Mq ∈ Ms
v with s (cid:54)= t, one has
T RMq
A partial schedule S : J ×M → N with respect to (RMq )Mq∈M is completable
if, for each vertex v ∈ V , each 1 ≤ s ≤ gv, each machine Mq ∈ Ms
v, and each
job Ji ∈ J S

∩ Jv, it holds that

v and Mr ∈ Mt

s=1 Ms

∩ T RMr

= ∅.

v

v

Mq

 max

Mr∈Ms
max
Jj∈Jv

v

Mr

|J S
|MS

Jj

∩ Jv|,
∩ Ms
v|.

(3.1)

|T RMq

v

\ (T S

Ji

∪ T S

Mq

)| ≥ max

Example 3.3. Let (RMq )Mq∈M be routes such that all machines are in the same
vertex at the same time, that is, T RMq
for all vertices v ∈ V and ma-
chines Mq, Mr ∈ M. Moreover, assume that each machine Mq ∈ M stays in each

= T RMr

v

v

5

vertex v ∈ V at least max{|Jv|,|M|} time, that is, |T RMq
| ≥ max{|Jv|,|M|}.
Then the empty schedule is completable and, by the following schedule completion
theorem, there is a feasible schedule with respect to the routes (RMq )Mq∈M.
Theorem 3.4 (Schedule completion theorem). If a partial schedule S : J ×
M → N with respect to routes (RMq )Mq∈M is completable, then there is a feasible
schedule S(cid:48) ⊇ S with respect to the routes (RMq )Mq∈M and it can be computed

in time polynomial in |J | + |M| + |V | +(cid:80)

v∈V,Mq∈M |T RMq

|.

v

v

We prove Theorem 3.4 using Galvin’s theorem about properly list-coloring the
edges of bipartite graphs [18, 34].
Deﬁnition 3.5 (Proper edge coloring, list chromatic index). A proper
edge coloring of a graph G = (V, E) is a coloring C : E → N of the edges of G
such that C(e1) (cid:54)= C(e2) if e1 ∩ e2 (cid:54)= ∅.
A graph G = (V, E) is k-edge-choosable if, for every family {Le ⊆ N | e ∈ E}
satisfying |Le| ≥ k for all e ∈ E, G allows for a proper edge coloring C : E → N
with C(e) ∈ Le. The list chromatic index χ(cid:48)
(cid:96)(G) of G is the least integer k such
that G is k-edge-choosable.
Theorem 3.6 (Galvin [18]). For any bipartite multigraph G, it holds that
χ(cid:48)
(cid:96)(G) = ∆(G), where ∆(G) is the maximum degree of G.
Moreover, given a bipartite multigraph G = (V, E) and, for each edge e ∈ E, a
set Le ⊆ N with |Le| ≥ ∆(G), a proper edge coloring C : E → N with C(e) ∈ Le
is computable in polynomial time.
Before Galvin [18] proved Theorem 3.6, its special case with G = Kn,n being
a complete bipartite graph was known as Dinitz’ conjecture. A self-contained
proof of Theorem 3.6 was later given by Slivnik [34], who also pointed out the
polynomial-time computability of the coloring. We now use Theorem 3.6 to prove
Theorem 3.4.
Proof (of Theorem 3.4). Let B = (J ∪ M, X) be a bipartite graph with an edge
{Ji, Mq} ∈ X if and only if S(Ji, Mq) = ⊥ for Ji ∈ J and Mq ∈ M. We compute
a proper edge coloring C of B such that, for each edge {Ji, Mq} ∈ X, we have
(3.2)

C({Ji, Mq}) ∈ T RMqL(Ji) \ (T S

∪ T S

Mq

Ji

(cid:40)

C({Ji, Mq})
S(Ji, Mq)

)
if {Ji, Mq} ∈ X and
otherwise.

and deﬁne S(cid:48)(Ji, Mq) :=

in |J | + |M| + |V | +(cid:80)

It remains to show that (1) the edge coloring C is computable in time polynomial
v∈V,Mq∈M |T RMq
| and that (2) S(cid:48) is a feasible schedule.
(1) We obtain the proper edge coloring C by independently computing, for
each induced subgraph Bvs := B[Jv ∪Ms
v] for all v ∈ V and 1 ≤ s ≤ gv, a proper
edge coloring Cvs satisfying (3.2). To this end, observe that the maximum degree
of Bvs is

v

∆ := max

Mr

|J S
|MS

Jj

∩ Jv|,
∩ Ms
v|.

 max

Mr∈Ms
max
Jj∈Jv

v

6

By Theorem 3.6, if, for each edge e ∈ X, we have a list Le of colors with |Le| ≥ ∆,
then Bvs has a proper edge coloring Cvs with Cvs(e) ∈ Le for each edge e of Bvs.
For each edge {Ji, Mq} of Bvs, we choose
L{Ji,Mq} := T RMq

\ (T S

∪ T S

).

v

Mq

Ji

v

v

v

v

v∈V,1≤s≤gv

∩ T RMr
∩T RMqw

v

e∈E(Bvs) |Le|.

We now let C := (cid:83)

polynomial in |Bvs| +(cid:80)

Since S is completable (Deﬁnition 3.2), we have |Le| ≥ ∆ for each edge e of Bvs.
Thus, Bvs admits a proper edge coloring Cvs satisfying (3.2).
Cvs. This is a proper edge coloring for the
bipartite graph B since, for edges evs of Bvs and ewt of Bwt with v (cid:54)= w or s (cid:54)= t, we
have Levs ∩ Lewt = ∅: for any vertex v ∈ V and machines Mq ∈ Ms
v, Mr ∈ Mt
with s (cid:54)= t, one has T RMq
= ∅, and for any machine Mq ∈ M and
v (cid:54)= w ∈ V , one has T RMq
= ∅. Moreover, C satisﬁes (3.2) since each Cvs
for v ∈ V and 1 ≤ s ≤ gv satisﬁes (3.2).
Regarding the running time, it is clear that, for each v ∈ V and 1 ≤ s ≤ gv, the
bipartite graph Bvs and the sets L{Jj ,Mq} of allowed colors for each edge {Jj, Mq}
|.3 Moreover, by The-
are computable in time polynomial in |J | + |M| + |T RMq
orem 3.6, the sought edge coloring Cvs for each Bvs is computable in time
(2) We ﬁrst show that S(cid:48) is a schedule. For each job Ji ∈ J and each
machine Mq ∈ M we have S(Ji, Mq) (cid:54)= ⊥ or {Ji, Mq} ∈ X. Thus, S(cid:48)(Ji, Mq) =
S(Ji, Mq) (cid:54)= ⊥ or S(cid:48)(Ji, Mq) = C({Ji, Mq}) (cid:54)= ⊥ and S(cid:48) is a schedule. We show
that S(cid:48) is feasible.
First, let Ji ∈ J be a job and Mq, Mr ∈ M be distinct machines. We show that
S(cid:48)(Ji, Mq) (cid:54)= S(cid:48)(Ji, Mr). We distinguish three cases. If S(Ji, Mq) (cid:54)= ⊥ and S(Ji,
Mr) (cid:54)= ⊥, then S(cid:48)(Ji, Mq) = S(Ji, Mq) (cid:54)= S(Ji, Mr) = S(cid:48)(Ji, Mr). If S(Ji, Mq) =
⊥ = S(Ji, Mr), then S(cid:48)(Ji, Mq) = C({Ji, Mq}) (cid:54)= C({Ji, Mr}) = S(cid:48)(Ji, Mr).
Finally, if S(Ji, Mq) = ⊥ and S(Ji, Mr) (cid:54)= ⊥, then S(cid:48)(Ji, Mq) (cid:54)= S(cid:48)(Ji, Mr) since
S(cid:48)(Ji, Mq) = C({Ji, Mq}) ∈ T RMq
Now, let Ji, Jj ∈ J be distinct jobs and Mq ∈ M be a machine. We show S(cid:48)(Ji,
Mq) (cid:54)= S(cid:48)(Jj, Mq). We distinguish three cases. If S(Ji, Mq) (cid:54)= ⊥ and S(Jj, Mq) (cid:54)=
⊥, then S(cid:48)(Ji, Mq) = S(Ji, Mq) (cid:54)= S(Jj, Mq) = S(cid:48)(Jj, Mq). If S(Ji, Mq) =
⊥ = S(Jj, Mq), then S(cid:48)(Ji, Mq) = C({Ji, Mq}) (cid:54)= C({Jj, Mq}) = S(cid:48)(Jj, Mq).
Finally, if S(Ji, Mq) = ⊥ and S(Jj, Mq) (cid:54)= ⊥, then S(cid:48)(Ji, Mq) (cid:54)= S(cid:48)(Jj, Mq) since
S(cid:48)(Ji, Mq) = C({Ji, Mq}) ∈ T RMq
(cid:117)(cid:116)

) and S(cid:48)(Jj, Mq) ∈ T S

) and S(Ji, Mr) ∈ T S

\ (T S

Ji

∪ T S

∪ T S

Mq

.

Ji

v

v

\ (T S

Ji

Mq

.

Mq

4 Upper and lower bounds

In this section, we show lower and upper bounds on the lengths of optimal solutions
to Routing Open Shop with unit processing times. These will be exploited in our
ﬁxed-parameter algorithm and make ﬁrst steps towards approximation algorithms.
We assume Routing Open Shop instances to be preprocessed to satisfy the
triangle inequality. By Lemma 2.1, this does not change the length of optimal

3 We abstain from a more detailed running time analysis since no such analysis is

available for the forthcoming application of Theorem 3.6 (yet).

7

A simple lower bound is given by the fact that, in view of Observation 2.3,

schedules. However, it ensures that the minimum cost of a cycle visiting each
vertex of the graph G = (V, E) with travel times c : E → N at most once
coincides with the minimum cost of a cycle doing so exactly once [33], that is, of
a Hamiltonian cycle.
all machines have to visit each vertex at least once and to process |J | jobs.
Observation 4.1. Let H be a minimum-cost Hamiltonian cycle in the graph G =
(V, E) with metric travel times c : E → N. Then, any feasible schedule has length
at least c(H) + |J |.
A trivial upper bound can be given by letting the machines work sequentially.
Observation 4.2. Given a Hamiltonian cycle H for the graph G = (V, E) with
travel times c : E → N, a feasible schedule of length c(H) + |J | + |M| − 1 is
computable in O(|J | · |M| + |V |) time.
This bound can be improved if c(H) + 1 ≤ |M| ≤ |J | or c(H) + 1 ≤ |J | ≤ |M|:
Proposition 4.3. Given a Hamiltonian cycle H for the graph G = (V, E) with
travel times c : E → N, a feasible schedule of length 2c(H) + max{|J |,|M|} is
computable in O(|J |2 + |M| + |V |) time.
We next study for which instances one gets an upper bound that matches the
lower bound from Observation 4.1. In Example 3.3, we have already seen that
arbitrary machine routes that stay in each vertex v at least max{|Jv|,|M|} time
can be completed into a feasible schedule. We therefore distinguish vertices v for
which staying |Jv| time is both necessary and suﬃcient.
Deﬁnition 4.4 (Criticality of vertices). For a vertex v ∈ V , we denote by

k(v) := max{0,|M| − |Jv|} the criticality of v, and by

(cid:88)

K :=

k(v) the total criticality.

v∈V

A vertex v ∈ V is critical if k(v) > 0, that is, if |Jv| < |M|.
Proposition 4.5. Given a Hamiltonian cycle H for the graph G = (V, E) with
travel times c : E → N, a feasible schedule of length at most c(H) + |J | + K can
be computed in polynomial time.

Proof. Let H = (v1, v2, . . . , v|V |) and v|V |+1 := v1. Without loss of generality,
assume that v1 = v∗, where v∗ is the depot vertex. Each machine Mq ∈ M uses
the same route R of |V | + 1 stays (a1, v1, b1), . . . , (a|V |+1, v|V |+1, b|V |+1), where

a1 := 0,

ai+1 := bi + c(vi, vi+1),

b|V |+1 := a|V |+1,

bi := ai + |Jvi| + k(vi),

for i ∈ {1, . . . ,|V |}.

Each stay (ai, vi, ai) lasts |Jvi| + k(vi) = max{|Jvi|,|M|} time. By Theorem 3.4,
the empty schedule S is completable into a feasible schedule S(cid:48) with respect

8

J2

1

2

J3

1

J1

S M1 M2 M3 M4 M5 M6 M7
3
J1 0
1
J2 2
J3 5
7

6
4
1

7
5
2

1
3
6

2
7
4

8
6
3

Fig. 1. On the left: a graph with one job in each vertex, travel times as denoted on the
edges, and the depot being J1. On the right: a schedule S of length 9 to process these
jobs on seven machines. Note that machine M7 does not travel along a Hamiltonian cycle,
but along route J1, J2, J1, J3, J1. One can show that any schedule in which machines
travel along Hamiltonian cycles has length at least 10.

in |J | + |M| +(cid:80)

to the route R for each machine and S(cid:48) is computable in time polynomial
v | ∈ O(|J | + |M| + K) ⊆ O(|J | + |M| + |V | · |M|).

v∈V |T R

Finally, the route R has length

|V |(cid:88)
(|Jvi| + k(vi)) = c(H) + |J | + K.

(cid:117)(cid:116)

b|V |+1 = a|V |+1 = b|V | + c(v|V |, v1) +

i=1

Combining Observation 4.1 and Proposition 4.5 and that a minimum-cost Hamil-
tonian cycle is computable in O(2|V |·|V |2) time using the algorithm of Bellman [4],
Held and Karp [25], we obtain a ﬁrst ﬁxed-parameter tractability result:
Corollary 4.6. Routing Open Shop with unit processing times is ﬁxed-pa-
rameter tractable parameterized by |V | if there are no critical vertices.
Corollary 4.6 makes clear that, given the schedule completion theorem, critical
vertices are the main obstacle for solving Routing Open Shop with unit
processing times: while staying |Jv| time in a noncritical vertex v ∈ V is both
necessary and suﬃcient, staying in critical vertices |M| time is suﬃcient, but
not necessary. Indeed, as shown in Figure 1, in the presence of critical vertices,
there might not even be optimal schedules in which the machines travel along
Hamiltonian cycles.

5 Fixed-parameter algorithm

In this section, we present a ﬁxed-parameter algorithm for Routing Open Shop
with unit processing times, which is our main algorithmic result:
Theorem 5.1. Routing Open Shop with unit processing times is solvable in
2O(|V ||M|2 log |V ||M|) · poly(|J |) time.
The outline of the algorithm for Theorem 5.1 is as follows: in Section 5.1, we use
the schedule completion Theorem 3.4 to show that the routes of a minimum-length
schedule comply with one of 2O(|V ||M|2 log |V ||M|) pre-schedules, which determines
the sequence of vertices that each machine stays in, the durations of stays in
critical vertices, and the time oﬀsets between stays in critical vertices.

9

In Section 5.2, we use integer linear programming to compute, for each pre-
schedule, shortest complying routes so that each machine stays in each noncritical
vertex v for at least |Jv| time. The schedule for noncritical vertices is then implied
by the schedule completion Theorem 3.4, whereas we compute the schedule for
critical vertices using brute force.

5.1 Enumerating pre-schedules

One can show that the routes of a minimum-length schedule comply with some
pre-schedule:
Deﬁnition 5.2 (Pre-schedule). A pre-stay is a triple (Mq, v, σ) ∈ M × V ×
{1, . . . ,|V ||M| + 2}, intuitively meaning that machine Mq ∈ M has its σ-th stay
in vertex v ∈ V. We call T = ((Mqi, vi, σi))s
(i) for each Mq ∈ M, the σi with qi = q increase in steps of one for increasing i.
Machine routes (RMq )Mq∈M, where RMq = ((aq
k=1, comply with a
pre-stay sequence if

i=1 a pre-stay sequence if,

k, wq

k))tq

k, bq

k, bq

k, wq

k) if and only if (Mq, wq

k, k) is in T and,
(ii) route RMq has a stay (aq
≤ aqj
(iii) for pre-stays (Mqi, vi, σi) and (Mqj , vj, σj) with i < j, one has aqi
σj .
σi
Let K := {i ≤ s | vi is critical} be the indices of pre-stays in critical ver-
tices of T . A length assignment is a map A : K → {0, . . . , 2|M| − 1}. Machine
routes (RMq )Mq∈M comply with a length assignment A if,
(iv) for each pre-stay (Mqi, vi, σi) on T with i ∈ K, one has bqi
= A(i).
A displacement is a map D : K → {0, . . . , 2|M|}. The machine routes (RMq )Mq∈M
comply with a displacement D if
(v) for two pre-stays (Mqi, vi, σi) and (Mqj , vj, σj) with i, j ∈ K and k /∈ K for

− aqi

σi

σi

all k with i < k < j, one has
+ 2|M|
+ D(j)

≥ aqi
σi
= aqi
σi

aqj
σj
aqj
σj

if D(j) = 2|M| and
if D(j) < 2|M|.

We call (T, A, D) a pre-schedule and say that machine routes comply with (T, A, D)
if they comply with each of T , A, and D, that is, (i)–(v) hold.
We show that an optimal solution for Routing Open Shop with unit processing
times can be found by solving instances of the following problem:
Problem 5.3.
Input: An instance I of Routing Open Shop with unit processing times, a

pre-schedule (T, A, D), and a natural number L.

Task: Compute a schedule whose machine routes (RMq )Mq∈M have length at

most L and comply with (T, A, D), if such a schedule exists.

10

Proposition 5.4. For a Routing Open Shop instance I with unit processing
times there is a set I of 2O(|V ||M|2 log |V ||M|) instances of Problem 5.3 such that
(i) if some instance (I, (T, A, D), L) ∈ I has a solution S, then S is a schedule

(ii) there is a minimum-length schedule S for I such that S is a solution for at

of length at most L for I and
least one instance (I, (T, A, D), L) ∈ I, where L is the length of S.

Moreover, the set I can be generated in 2O(|V ||M|2 log |V ||M|) · poly(|J |) time.

Having Proposition 5.4, for proving Theorem 5.1, it remains to solve Problem 5.3
in 2O(|V ||M|2 log |V ||M|) · poly(|J |) time since a shortest schedule for an instance I
of Routing Open Shop with unit processing times can be found by solving the
instances (I, (T, A, D), L) ∈ I for increasing L. The proof of Proposition 5.4 is
based on proving that there are at most 2O(|V ||M|2 log |V ||M|) pre-schedules and
the following two lemmas.

Lemma 5.5. Each of the routes (RMq )Mq∈M of an optimal schedule consists of
at most |V ||M| + 2 stays.
Proof. Let H be a minimum-cost Hamiltonian cycle for the graph G with travel
times c : E → N. Let Mq ∈ M be an arbitrary machine. It has to stay in all
vertices and return to the depot, that is, its tour RMq has at least |V | + 1 stays.
Moreover, by Observation 4.1, its length is at least c(H) + |J |. By Lemma 2.2,
each additional stay has length at least one.
Thus, if RMq had more than |V | + K + 1 stays, where K is the total critically
of vertices in the input instance (cf. Deﬁnition 4.4), then it would have length
at least c(H) + |J | + K + 1, contradicting the optimality of the schedule by
Proposition 4.5. Thus, the number of stays on RMq is at most

(cid:88)

v∈V

|V | + K + 1 = |V | +

max{0,|M| − |Jv|} + 1 ≤ |V ||M| + 2

since, by Observation 2.3, only for the depot v∗ one might have Jv∗ = ∅.
Lemma 5.5 implies that there is a pre-stay sequence that the routes (RMq )Mq∈M
of an optimal schedule comply with. The following lemma implies that there are
also length assignments and displacements that (RMq )Mq∈M comply with. For
the notation used in Lemma 5.6, recall Deﬁnition 3.1.

(cid:117)(cid:116)

Mq

v

Lemma 5.6. For each feasible schedule S with respect to routes (RMq )Mq∈M,
there is a feasible schedule S(cid:48) of the same length with respect to routes (R(cid:48)
)Mq∈M
such that |T R(cid:48)
| ≤ max{|Jv|,|M|} + |M| − 1 for each vertex v ∈ V .
Proof. For each machine Mq ∈ M, construct the route R(cid:48)
((ak, vk, bk))s
1. If |T RMq

k=1 as follows:
| ≤ max{|Jv|,|M|} + |M| − 1, then R(cid:48)

from the route RMq =

:= RMq,

Mq

v

Mq

Mq

11

2. Otherwise, let R(cid:48)

1, v1, b(cid:48)
are chosen arbitrarily with |T R(cid:48)

:= ((a(cid:48)

Mq

1))s

k=1, where ai ≤ a(cid:48)
| = max{|Jv|,|M|} + |M| − 1.

i ≤ b(cid:48)

i ≤ bi for 1 ≤ i ≤ s

Mq

v

Denote by M := {Mq ∈ M | RMq (cid:54)= R(cid:48)
} the set of machines whose tours
have been altered. If M = ∅, then there is nothing to prove. Henceforth, assume
M (cid:54)= ∅. Then, S might not be a feasible schedule for the routes (R(cid:48)
)Mq∈M but

Mq

Mq

(cid:40)⊥

S∗(Ji, Mq) :=

if Mq ∈ M,
S(Ji, Mq) otherwise

Mq

Mq

)Mq∈M since the machines in M do
is a partial schedule for the routes (R(cid:48)
not process any jobs in S∗. We show that S∗ is completable with respect
to (R(cid:48)
)Mq∈M in terms of Deﬁnition 3.2.
To this end, choose an arbitrary vertex v ∈ V and an arbitrary machine Mq ∈
M with some unprocessed job Ji ∈ J S∗
. Then, Mq ∈ M, since only machines
in M have unprocessed jobs in S∗. Moreover, |T S∗
| ≤ |M| − 1, since at least the
machine Mq does not process Ji. Finally T S∗
= ∅ since Mq does not process any
jobs in S∗. Thus,

Mq

Mq

Ji

|T R(cid:48)

v

Mq

\ (T S∗

Ji

∪ T S∗

Mq

)| ≥ max{|Jv|,|M|} + |M| − 1 − (|M| − 1)

= max{|Jv|,|M|}

Mq

)Mq∈M.

and Theorem 3.4 shows how to complete S∗ into a feasible schedule S(cid:48) for the
(cid:117)(cid:116)
routes (R(cid:48)
Remark 5.7. Lemma 5.6 gives an upper bound of max{|Jv|,|M|} + |M| − 1 on
the total amount of time that each machine stays in a vertex v in an optimal
schedule. Note that neither Example 3.3 nor Proposition 4.5 give such an upper
bound: these show that, in order to obtain a feasible schedule, it is suﬃcient
that each machine stays in each vertex v for at least max{|Jv|,|M|} time. They
do not exclude that, in an optimal schedule, a machine might stay in a vertex
signiﬁcantly longer in order to enable other machines to process their jobs faster.

5.2 Computing routes and completing the schedule

In this section, we provide the last missing ingredient for our ﬁxed-parameter
algorithm for Routing Open Shop with unit processing times:
Proposition 5.8. Problem 5.3 is solvable 2O(|V ||M|2 log |V ||M|) · poly(|J |) time.
By Proposition 5.4, this proves Theorem 5.1. The key to our algorithm for
Proposition 5.8 is the following lemma.

Lemma 5.9. Let (I, (T, A, D), L) be an instance of Problem 5.3 that has a solu-
tion. Then, for arbitrary routes (RMq )Mq∈M of length L complying with (T, A, D)
and satisfying |T RMq

| ≥ |Jv| for each non-critical vertex v ∈ V ,

v

12

(i) there is a partial schedule S with respect to (RMq )Mq∈M such that S(Ji,

Mq) (cid:54)= ⊥ if and only if L(Ji) is critical,

If there is a partial schedule S for I that satisﬁes Lemma 5.9(i), then we can

(ii) any such partial schedule is completable with respect to (RMq )Mq∈M.
Lemma 5.9 shows that, to solve Problem 5.3, it is suﬃcient to compute routes
(RMq )Mq∈M of length L that comply with a given pre-schedule (T, A, D) and
stay in each uncritical vertex v for at least |Jv| units of time. If no such routes
are found, then the instance of Problem 5.3 has no schedule of length L since any
feasible schedule has to spend at least |Jv| units of time in each vertex v. If such
routes are found, then a feasible schedule with respect to them can be computed
independently using the schedule completion Theorem 3.4 for noncritical vertices
by Lemma 5.9(ii) and using brute force for critical vertices:
Lemma 5.10. Let (I, (T, A, D), L) be an instance of Problem 5.3 and (RMq )Mq∈M
be arbitrary routes complying with (T, A, D).
ﬁnd it in 2O(|V ||M|2 log |M|) · poly(|J |) time.
Proof. Observe that, in total, there are at most |V | · |M| jobs in critical vertices.
Thus, we determine S(Ji, Mq) for at most |V | · |M|2 pairs (Ji, Mq) ∈ J × M.
By Lemma 5.6, each machine can process all of its jobs in a critical vertex
staying there no longer than 2|M| − 1 units of time. Thus, for each of the
at most |V | · |M|2 pairs (Ji, Mq) ∈ J × M, we enumerate all possibilities of
choosing S(Ji, Mq) among the smallest 2|M| − 1 numbers in T RMqL(Ji). There are
(2|M| − 1)|V |·|M|2 ∈ 2O(|V ||M|2 log |M|) possibilities to do so.
(cid:117)(cid:116)
Finally, we compute the routes required by Lemma 5.9 by testing the feasibility
of an integer linear program with O(|M|· (|V ||M| + 2)) variables and constraints,
which, by Lenstra’s theorem below, works in 2O(|V ||M|2 log |V ||M|) time. Together
with Lemma 5.10 and Theorem 3.4, this completes the proof of Proposition 5.8.
Theorem 5.11 (Lenstra [29]; see also Kannan [27]). A feasible solution to
an integer linear program with p variables and m constraints is computable in
pO(p) · poly(m) time, if such a feasible solution exists.

6 Conclusion
We have proved the schedule completion Theorem 3.4 and used it for a ﬁxed-
parameter algorithm for Routing Open Shop with unit processing times.
Precisely, we used it to prove upper bounds on various parameters of optimal
schedules. This suggests that Theorem 3.4 will be likewise beneﬁcial for approx-
imation algorithms. Indeed, our Section 4 makes ﬁrst steps into this direction.
A natural direction for future research is determining the parameterized
complexity of Routing Open Shop with unit processing times parameterized by
the number |V | of vertices. Even the question whether the problem is polynomial-
time solvable for constant |V | is open, yet we showed ﬁxed-parameter tractability
in the absence of critical vertices (Corollary 4.6). Finally, it would be desirable
to ﬁnd a fast polynomial-time algorithm for ﬁnding the coloring whose existence
is witnessed by Galvin’s theorem (Theorem 3.6).

13

References

[1] Allahverdi, A., Ng, C., Cheng, T., Kovalyov, M.Y.: A survey of scheduling
problems with setup times or costs. Eur. J. Oper. Res. 187(3), 985–1032
(2008)

[2] Averbakh, I., Berman, O., Chernykh, I.: A 6

5-approximation algorithm for
the two-machine routing open-shop problem on a two-node network. Eur. J.
Oper. Res. 166(1), 3–24 (2005)

[3] Averbakh, I., Berman, O., Chernykh, I.: The routing open-shop problem
on a network: Complexity and approximation. Eur. J. Oper. Res. 173(2),
531–539 (2006)

[4] Bellman, R.: Dynamic programming treatment of the Travelling Salesman

Problem. J. ACM 9(1), 61–63 (1962)

[5] van Bevern, R., Chen, J., Hüﬀner, F., Kratsch, S., Talmon, N., Woeginger,
G.J.: Approximability and parameterized complexity of multicover by c-
intervals. Inform. Process. Lett. 115(10), 744–749 (2015)

[6] van Bevern, R., Komusiewicz, C., Sorge, M.: Approximation algorithms for
mixed, windy, and capacitated arc routing problems. In: Proc. 15th ATMOS.
OASIcs, vol. 48. Schloss Dagstuhl–Leibniz-Zentrum für Informatik (2015)
[7] van Bevern, R., Mnich, M., Niedermeier, R., Weller, M.: Interval scheduling

and colorful independent sets. J. Sched. 18, 449–469 (2015)

[8] van Bevern, R., Niedermeier, R., Sorge, M., Weller, M.: Complexity of arc
routing problems. In: Arc Routing: Problems, Methods, and Applications.
SIAM (2014)

[9] van Bevern, R., Niedermeier, R., Suchý, O.: A parameterized complexity
view on non-preemptively scheduling interval-constrained jobs: few machines,
small looseness, and small slack. J. Sched. (2016), accepted for publication
[10] Bodlaender, H.L., Fellows, M.R.: W[2]-hardness of precedence constrained

k-processor scheduling. Oper. Res. Lett. 18(2), 93–97 (1995)

[11] Chernykh, I., Kononov, A., Sevastyanov, S.: Eﬃcient approximation al-
gorithms for the routing open shop problem. Comput. Oper. Res. 40(3),
841–847 (2013)

[12] Cygan, M., Fomin, F.V., Kowalik, L., Lokshtanov, D., Marx, D., Pilipczuk,
M., Pilipczuk, M., Saurabh, S.: Parameterized Algorithms. Springer (2015)
[13] Dorn, F., Moser, H., Niedermeier, R., Weller, M.: Eﬃcient algorithms for
Eulerian Extension and Rural Postman. SIAM J. Discrete Math. 27(1),
75–94 (2013)

[14] Downey, R.G., Fellows, M.R.: Fundamentals of Parameterized Complexity.

Springer (2013)

[15] Fellows, M.R., McCartin, C.: On the parametric complexity of schedules to

minimize tardy tasks. Theor. Comput. Sci. 298(2), 317–324 (2003)

[16] Floyd, R.W.: Algorithm 97: Shortest path. Commun. ACM 5(6), 345 (1962)
[17] Flum, J., Grohe, M.: Parameterized Complexity Theory. Springer (2006)
[18] Galvin, F.: The list chromatic index of a bipartite multigraph. J. Comb.

Theory B. 63(1), 153–158 (1995)

14

[19] Gonzalez, T., Sahni, S.: Open shop scheduling to minimize ﬁnish time. J.

ACM 23(4), 665–679 (1976)

[20] Gutin, G., Jones, M., Sheng, B.: Parameterized complexity of the k-Arc
In: Proc. 22nd ESA. LNCS, vol. 8737, pp.

Chinese Postman Problem.
530–541. Springer (2014)

[21] Gutin, G., Jones, M., Wahlström, M.: Structural parameterizations of the
Mixed Chinese Postman Problem. In: Proc. 23rd ESA. LNCS, vol. 9294, pp.
668–679. Springer (2015)

[22] Gutin, G., Muciaccia, G., Yeo, A.: Parameterized complexity of k-Chinese

Postman Problem. Theor. Comput. Sci. 513, 124–128 (2013)

[23] Gutin, G., Wahlström, M., Yeo, A.: Parameterized Rural Postman and Con-
joining Bipartite Matching problems (2014), available on arXiv:1308.2599v4
[24] Halldórsson, M.M., Karlsson, R.K.: Strip graphs: Recognition and scheduling.

In: Proc. 32nd WG. LNCS, vol. 4271, pp. 137–146. Springer (2006)

[25] Held, M., Karp, R.M.: A dynamic programming approach to sequencing

problems. J. SIAM 10(1), 196–210 (1962)

[26] Hermelin, D., Kubitza, J.M., Shabtay, D., Talmon, N., Woeginger., G.:
Scheduling two competing agents when one agent has signiﬁcantly fewer
jobs. In: Proc. 10th IPEC, LIPIcs, vol. 43, pp. 55–65. Schloss Dagstuhl–
Leibniz-Zentrum für Informatik (2015)

[27] Kannan, R.: Minkowski’s convex body theorem and integer programming.

Mathematics of operations research 12(3), 415–440 (1987)

[28] Kononov, A.: O(log n)-approximation for the routing open shop problem.

RAIRO-Oper. Res. 49(2), 383–391 (2015)

[29] Lenstra, H.W.: Integer programming with a ﬁxed number of variables.

Mathematics of operations research 8(4), 538–548 (1983)

[30] Mnich, M., Wiese, A.: Scheduling and ﬁxed-parameter tractability. Math.

Programming 154(1-2), 533–562 (2015)

[31] Niedermeier, R.: Invitation to Fixed-Parameter Algorithms. Oxford Univer-

sity Press (2006)

[32] Pyatkin, A.V., Chernykh, I.D.: The Open Shop problem with routing in a
two-node network and allowed preemption [in Russian]. Diskretnyj Analiz i
Issledovaniye Operatsij 19(3), 65–78 (2012), English translation in Journal
of Applied and Industrial Mathematics, 6(3):346-354

[33] Serdyukov, A.I.: On some extremal by-passes in graphs [in Russian]. Up-

ravlyayemyye sistemy 17, 76–79 (1978), zbMATH 0475.90080

[34] Slivnik, T.: Short proof of Galvin’s Theorem on the list-chromatic index of

a bipartite multigraph. Comb. Probab. Comput. 5, 91–94 (1996)

[35] Sorge, M., van Bevern, R., Niedermeier, R., Weller, M.: A new view on Rural
Postman based on Eulerian Extension and Matching. J. Discrete Alg. 16,
12–33 (2012)

[36] Yu, W., Liu, Z., Wang, L., Fan, T.: Routing open shop and ﬂow shop

scheduling problems. Eur. J. Oper. Res. 213(1), 24–36 (2011)

[37] Zhu, X., Wilhelm, W.E.: Scheduling and lot sizing with sequence-dependent

setup: A literature review. IIE Trans. 38(11), 987–1007 (2006)

15

A Appendix: Omitted proofs

A.1 Proof of Lemma 2.1
Proof. It is obvious that c(cid:48) satisﬁes the triangle inequality. It can be computed
in O(|V |3) time using the Floyd-Warshall algorithm [16].
Any feasible schedule for I is also a feasible schedule for I(cid:48) of the same length
since any route R for I is also a route for I(cid:48): for two consecutive stays (ai, vi, bi)
and (ai+1, vi+1, bi+1) of R, one has bi + c(cid:48)(vi, vi+1) ≤ bi + c(vi, vi+1) ≤ ai+1.
Any feasible schedule for I(cid:48) is a feasible schedule of the same length for I since
any route R(cid:48) with s stays for I(cid:48) can be turned into a route of the same length
with additional stays for I: for each i ∈ {1, . . . , s − 1}, take two consecutive
stays (ai, vi, bi) and (ai+1, vi+1, bi+1) on R(cid:48) and a shortest path P = (w1 =
vi, w2, . . . , w(cid:96) = vi+1) between vi and vi+1 in G with respect to c. Between stay i
and i + 1, add zero-length stays in the vertices of P . That is, for each k ∈
{1, . . . , (cid:96) − 2}, add stays

(cid:16)

k(cid:88)

k(cid:88)

j=1

k(cid:88)

(cid:17)

k+1(cid:88)

j=1

c(wj, wj+1)

ai +

c(wj, wj+1), wk+1,

ai +

c(wj, wj+1)

j=1

j=1

to R(cid:48). This yields a route R for I since

ai +

c(wj, wj+1) + c(wk+1, wk+2) ≤ ai +

for all k ∈ {1, . . . , (cid:96) − 1}. Moreover, R has the same length as R(cid:48) since the end of
(cid:117)(cid:116)
the last stay has not changed.

A.2 Proof of Lemma 2.2

Proof. Since S is a feasible schedule of length L, it is feasible with respect to
machine routes (RMq )Mq∈M of length L. Assume that each machine route RMq
is minimal, that is, no stay can be removed without violating the feasibility of S
with respect to RMq.
k=1 con-
tains a stay (ak, vk, bk), where k /∈ {1, s}, such that there is no job Ji ∈ J
with S(Ji, Mq) ∈ [ak, bk). Then removing (ak, vk, bk) from RMq would yield a
route R(cid:48)

For the sake of contradiction, assume that RMq = ((ak, vk, bk))s

with fewer stays since

Mq

bk−1 + c(vk−1, vk+1) ≤ bk−1 + c(vk−1, vk) + c(vk, vk+1)

≤ ak + c(vk, vk+1) ≤ bk + c(vk, vk+1) ≤ ak+1.

Since S is feasible with respect to R(cid:48)

Mq

, this contradicts RMq being minimal. (cid:117)(cid:116)

16

A.3 Proof of Proposition 4.3
Proof. Let n := |J | and m := |M|. Without loss of generality, assume that
n ≥ m. Otherwise, we can simply add m − n additional jobs to the depot and
ﬁnally remove them from the constructed schedule. We will construct a feasible
schedule S of length 2c(H) + n by constructing a matrix S = (siq)1≤i≤n,1≤q≤m,
where siq determines the time at which job Ji is processed by machine Mq.
Let H = (v1, v2, . . . , v|V |), where v1 = v∗ is the depot. Without loss of
generality, let the jobs J1, . . . , Jn be ordered so that, for jobs Ji, Jj with i ≤ j,
one has Ji ∈ Jvk and Jj ∈ Jv(cid:96) with k ≤ (cid:96). That is, the ﬁrst jobs are in v1, then
follow jobs in v2, and so on. First, construct a matrix S(cid:48) = (s(cid:48)
iq)1≤i≤n,1≤q≤m with

(cid:40)

iq := (i − q) mod n =
s(cid:48)

n − q + i
i − q

if i < q,
otherwise.

iq red if i < q and green otherwise. Note that if s(cid:48)

Call a cell s(cid:48)
same color and i < j or r < q, then s(cid:48)
is larger than the number in any green cell of the same row or column: if s(cid:48)
red and s(cid:48)

jr are of the
jr. Moreover, the number in a red cell
iq is

jq is green, then from

iq and s(cid:48)

iq < s(cid:48)

n + i > j

follows
iq = n − q + i > j − q = s(cid:48)
s(cid:48)

jq

and if s(cid:48)

iq is red and s(cid:48)

ir is green, then from

n − q > −r

follows
iq = n − q + i > i − r = s(cid:48)
s(cid:48)
ir.

Let ck =(cid:80)k

i=2 c(vi−1, vi) be the travel time from v1 to vk along H. Clearly, the
sequence (ck)1≤k≤s is non-decreasing and c|V | = c(H). Our schedule is given
by S = (siq)1≤i≤n,1≤q≤m, where

siq := s(cid:48)

iq +

ck
c(H) + ck

if L(Ji) = vk and siq is green,
if L(Ji) = vk and siq is red.

(cid:40)

Let us prove that this schedule is feasible in terms of Deﬁnition 1.1. Indeed,
by construction, for two elements siq and sjr with i = j or q = r and s(cid:48)
iq >
s(cid:48)
jr, one has siq > sjr since the value added to s(cid:48)
iq is not smaller than the
value added to s(cid:48)
jr due to our sorting of jobs by non-decreasing vertex indices.
Therefore, conditions (i) and (ii) are satisﬁed. It remains to determine the
i=1 for each machine Mq ∈ M. Machine Mq
machine routes RMq = ((ai, vi, bi))t
k) in a vertex vk, it
will follow H up to two times. During the ﬁrst stay (a1
will process all jobs Ji such that siq is green. During the second stay (a2
k),
k, vk, b2
it will process all jobs Ji such that siq is red. That is, the beginning and end

k, vk, b1

17

times of the stays are

k := min{S(Ji, Mq) | Ji ∈ J ,L(Ji) = vk and sij is green},
a1
k := max{S(Ji, Mq) | Ji ∈ J ,L(Ji) = vk and sij is green} + 1,
b1
k := min{S(Ji, Mq) | Ji ∈ J ,L(Ji) = vk and sij is red},
a2
k := max{S(Ji, Mq) | Ji ∈ J ,L(Ji) = vk and sij is red} + 1.
b2

It is easy to verify that such route satisﬁes the condition (iii) and the length of
(cid:117)(cid:116)
the schedule is at most n + 2c(H).

k, bq

k, wq

k, bq

k))tq

i ≤ aq

By Lemma 5.5, each route RMq = ((aq

i=1 that has a pre-stay (Mqi , vi, σi) = (Mq, wq
k), where T is sorted so that one has aqi
k, wq
σi

A.4 Proof of Proposition 5.4
Proof. (i) is trivially true by deﬁnition of Problem 5.3.
(ii) Let S be a schedule for I with respect to minimum-length machine
routes (RMq )Mq∈M. We choose I := {(I, (T, A, D), L) | (T, A, D) is a pre-schedule
and c(H) + |J | ≤ L ≤ c(H) + |J | + K}, where H is a minimum-cost Hamil-
tonian cycle for G and K is the total criticality (cf. Deﬁnition 4.4). We ﬁrst
show that the routes (RMq )Mq∈M comply with some pre-schedule (T, A, D).
Since, by Observation 4.1 and Proposition 4.5, the routes (RMq )Mq∈M have
length L ∈ [c(H) + |J |, c(H) + |J | + K], it follows that S is a solution for
some (I, (T, A, D), L) ∈ I. Thereafter, we analyze the cardinality of I.
k=1 of a machine Mq ∈ M has
tq ≤ |V ||M| + 2 stays. Thus, by Deﬁnition 5.2(i–iii) it complies with the pre-stay
sequence T := ((Mqi, vi, σi))s
k, k) if
≤ aqj
and only if RMq has a stay (aq
σj
for i < j and so that one has σi < σj for i < j with qi = qj. Such a sorting exists
j for i < j and all machines Mq ∈ M. Now, let KT := {i ≤ s | T
since aq
has a pre-stay in a critical vertex vi}. By Lemma 5.6, we may assume that the
routes (RMq )Mq∈M stay in a critical vertex at most 2|M|− 1 units of time. Thus,
by Deﬁnition 5.2(iv), the routes (RMq )Mq∈M comply with the length assignment
A : KT → {0, . . . , 2|M|−1}, i (cid:55)→ bqi
. It is trivial that the routes (RMq )Mq∈M
σj −
comply with the displacement D : KT → {0, . . . , 2|M|}, j (cid:55)→ min{2|M|, aqj
}, where i ∈ KT is the maximum number with i < j (for the smallest
aqi
number j ∈ KT , we deﬁne D(j) := 0, but any other choice would ﬁt the purpose).
σi
It remains to count the number of instances in I. We have K + 1 ≤
(|V | − 1)(|M| − 1) + |M| + 1 choices for L ∈ [c(H) + |J |, c(H) + |J | + K].
For each pre-stay (Mqi, vi, σi), there are |M| choices for Mqi and |V | choices
for vi. There is only one choice for σi: in the pre-stays for each machine Mq,
σ increases from 1 to at most |V ||M| + 2 in steps of one by Deﬁnition 5.2(i).
Thus, there are at most |M| · (|V ||M| + 2) pre-stays in a pre-stay sequence T
and hence, at most (|V ||M|)|M|·(|V ||M|+2) ∈ 2O(|V ||M|2 log |V ||M|) pre-stay se-
quences. Moreover, this implies that, for each pre-stay sequence T , one has
|KT| ≤ |M| · (|V ||M| + 2). Thus, there are at most (2|M|)|M|·(|V ||M|+2) ∈
2O(|V ||M|2 log |M|) length assignments A : KT → {0, . . . , 2|M| − 1} and (2|M| +
1)|M|·(|V ||M|+2) ∈ 2O(|V ||M|2 log |M|) displacements D : KT → {0, . . . , 2|M|}. (cid:117)(cid:116)

−aqi

σi

σi

18

A.5 Proof of Lemma 5.9
Proof. We ﬁrst show (ii). Let S be any partial schedule such that S(Ji, Mq) (cid:54)= ⊥
if and only if L(Ji) is critical. We show that S is completable with respect
to (RMq )Mq∈M in terms of Deﬁnition 3.2. For each critical vertex v ∈ V , each
machine Mq ∈ M, and each job Ji ∈ J S
∩ Jv, (3.1) of Deﬁnition 3.2 is trivially
satisﬁed since there is no such job: J S
∩Jv = ∅. For each uncritical vertex v ∈ V ,
each machine Mq ∈ M, and each job Ji ∈ J S

∩ Jv, one has

Mq

Mq

Mq

|T RMq

v

\ (T S

Ji

∪ T S

Mq

)| = |T RMq

v

| ≥ |Jv| = max{|Jv|,|M|},

thus satisfying (3.1) of Deﬁnition 3.2.
(i) Let S∗ be a solution for (I, (T, A, D), L), that is, S∗ is a feasible schedule
with respect to machine routes (R∗
)Mq∈M of length L complying with the pre-
Mq
k=1. We show how to construct a partial sched-
stay sequence T = ((Mqk , vk, σk))s
ule S with respect to the given routes (RMq )Mq∈M such that S(Ji, Mq) (cid:54)= ⊥ if and
k ))tq∗
only if L(Ji) is critical. Let the routes for S∗ be (R∗
k=1 for each machine Mq ∈ M. By
and the given routes be RMq = ((aq
Deﬁnition 5.2(ii) and Deﬁnition 1.1(iii), for each job Ji ∈ J and machine Mq ∈ M
there is an index P (Ji, Mq) := p of a pre-stay (Mqp , vp, σp) = (Mq,L(Ji), σp)
on T such that

)Mq∈M = ((aq∗

k , wq∗

k , bq∗

k, wq

k))tq

k, bq

k=1

Mq

aq∗

σp

≤ S∗(Ji, Mq) < bq∗

σp

.

(A.1)

Since the routes (R∗
one has tq = t∗
1 ≤ k ≤ tq. For each job Ji ∈ J and machine Mq ∈ M, we deﬁne

)Mq∈M and (RMq )Mq∈M comply with T , by Deﬁnition 5.2(ii),
for each machine Mq ∈ M and

q and, moreover, wq

k = wq∗

Mq

k

(cid:40)⊥

S(Ji, Mq) :=

S∗(Ji, Mq) − aq∗

σp

if L(Ji) is not a critical vertex,
for p = P (Ji, Mq), otherwise.

+ aq
σp

We show that S is indeed a partial schedule for the machine routes (RMq )Mq∈M.
For each job Ji in a critical vertex and each machine Mq, we ﬁrst show that
machine Mq stays in L(Ji) when processing job Ji. More precisely, for p =
P (Ji, Mq), we show aq
to
σp
both sides of

as follows. By adding −aq∗

≤ S(Ji, Mq) < bq

+ aq
σp

σp

σp

aq∗

σp

≤ S∗(Ji, Mq),

which holds since p is chosen so as to satisfy (A.1), one gets

aq
σp

≤ S∗(Ji, Mq) − aq∗

σp

+ aq
σp

= S(Ji, Mq).

Moreover, since both R∗
Deﬁnition 5.2(iv), one has bqk
(Mqk , vk, σk) such that vk is critical. Thus, by adding −aq∗
σk

and RMq comply with the length assignment A, by
for all pre-stays
to both sides of

= A(k) = bqk∗

− aqk∗
σk
+ aq
σp

− aqk

Mq

σk

σk

σp

S∗(Ji, Mq) < bq∗

σp

,

19

which holds since p is chosen so as to satisfy (A.1), one gets

S(Ji, Mq) = S∗(Ji, Mq) − aq∗

σp

+ aq
σp

< bq∗

σp

− aq∗

σp

+ aq
σp

= bq
σp

.

It remains to show that S∗ processes no two jobs at the same time and that
no two machines process one job at the same time. To this end, consider
jobs Ji, Jj ∈ J in critical vertices and machines Mq, Mr ∈ M. If either Ji = Jj
or Mq = Mr, then S∗(Ji, Mq) (cid:54)= S∗(Jj, Mr). Thus, it is suﬃcient to show
that S∗(Ji, Mq) (cid:54)= S∗(Jj, Mr) implies S(Ji, Mq) (cid:54)= S(Jj, Mr). To this end, let
p := P (Ji, Mq) and π := P (Jj, Mr). Without loss of generality, assume that
p ≤ π. Then, by Deﬁnition 5.2(iii), aq
≤
If bq
= A(p) ≤ 2|M| − 1 by Deﬁni-
≤ S(Jj, Mr). Otherwise, since bq
σp
ar
≤ 2|M| − 1. Thus, for K(p, π] :=
≤ bq
σπ
tion 5.2(iv), one has ar
{p < k ≤ π | (Mqk , vk, σk) is a pre-stay of T in a critical vertex}, one has, by
σπ
Deﬁnition 5.2(iii) and (v),

, then S(Ji, Mq) (cid:54)= S(Jr, Mr) follows from S(Ji, Mq) < bq

≤ ar
− aq
− aq

≤ ar

− aq

σπ

σπ

σp

σp

σp

σp

σp

σp

σp

.

ar
σπ

− aq

σp

D(k) = ar∗

σπ

− aq∗

σp

(A.2)

(cid:88)

=
k∈K(p,π]

)Mq∈M comply with the displacement D.

σp

Mq

− aq∗

since both tours (RMq )Mq∈M and (R∗
By adding ar
to both sides of
σπ
S(Ji, Mq) + aq∗
which is true by the deﬁnition of S from S∗, one obtains
(cid:54)= S(Jr, Mr) + ar∗

S(Ji, Mq) + ar
σπ

− aq

− aq

σp

σp

σp

σπ

− a∗

σp

,

= S∗(Ji, Mq) (cid:54)= S∗(Jj, Mr) = S(Jj, Mr) + ar∗

− ar

σπ

,

σπ

and, therefore, S(Ji, Mq) (cid:54)= S(Jj, Mr) from (A.2).

(cid:117)(cid:116)

A.6 Proof of Proposition 5.8
Any feasible schedule has to stay in each non-critical vertex v for at least |Jv| time.
Thus, it is enough to show the following lemma:

In 2O(|V ||M|2 log |V ||M|) time one can compute routes (RMq )Mq∈M that have
| ≥ |Jv| for each non-critical

Lemma A.1. Let (I, (T, A, D), L) be an instance of Problem 5.3.
length L, comply with (T, A, D), and satisfy |T RMq
vertex v ∈ V , if such routes exist.
Then, Proposition 5.8 follows from Lemmas 5.9 and 5.10. To prove Lemma A.1,
we formulate the task of ﬁnding the required routes as an integer linear program
feasibility problem.

v

Proof (of Lemma A.1). Let the pre-stay sequence T = ((Mqi, vi, σi))s
i=1. For each
machine Mq ∈ M, let tq := max{σ | (Mq, w, σ) is a pre-stay on T}. By Deﬁni-
tion 5.2, tq ≤ |V ||M| + 2 for each Mq ∈ M. We compute the routes (RMq )Mq∈M

20

k))tq

k, bq

k, wq
1 (cid:54)= v∗ or v∗ (cid:54)= wq

with RMq := ((aq
k=1 as follows. For each pre-stay (Mqi, vi, σi) on T , we
tq for some machine Mq, where v∗ is the depot,
let wqi
:= vi. If wq
σi
then there is no solution and we answer “no” accordingly. Otherwise, the aq
k and
k for each machine Mq ∈ M and 1 ≤ k ≤ sq are at most 2|M|·(|V ||M| + 2) vari-
bq
ables to be determined by a feasible solution to our integer linear program. This,
together with Theorem 5.11 directly yields the running time stated in Lemma A.1.
Our linear program consists of the following constraints. We want each route

to have length at most L, that is,

tq ≤ L
bq

for each Mq ∈ M.

A route must have suﬃcient travel time between stays, that is,
for each Mq ∈ M and 1 ≤ k ≤ tq − 1.

k+1) ≤ aq

bq
k + c(vq

k, vq

k+1

Stays should have non-negative length, that is,

k ≤ bq
aq

k

for each Mq ∈ M and 1 ≤ k ≤ tq.

Each machine should stay in v ∈ V for at least |Jv| time, that is

(cid:88)

1≤k≤tq
wq
k=v

k − aq
(bq

k) ≥ |Jv|

for each Mq ∈ M.

Stays must be ordered according to the pre-stay sequence T , that is

≤ aqj

σj

aqi
σi

for pre-stays (Mqi, vi, σi) and (Mqj , vj, σj) with i ≤ j.

Stays should adhere to the length assignment A, that is

− aqi

σi

bqi
σi

= A(i)

for each pre-stay (Mqi, vi, σi) such that vi is critical.

Finally, the routes have to comply with the displacement D. To formulate the
constraint, let K := {i ≤ s | vi is critical} be the indices of pre-stays in critical
vertices of T . For any two pre-stays (Mqi, vi, σi) and (Mqj , vj, σj) with i, j ∈ K
such that k /∈ K for i < k < j, we want that

aqj
σj
aqj
σj

= aqi
σi
≥ aqi

σi

+ D(j)

+ D(j) + 1

if D(j) < 2|M|, and
if D(j) = 2|M|.

(cid:117)(cid:116)

21

