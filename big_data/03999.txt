6
1
0
2

 
r
a

 

M
3
1

 
 
]
h
p
-
t
n
a
u
q
[
 
 

1
v
9
9
9
3
0

.

3
0
6
1
:
v
i
X
r
a

The Classiﬁcation of Stabilizer Operations over Qubits

Daniel Grier∗

Luke Schaeﬀer†

Abstract

We present a complete classiﬁcation of quantum stabilizer gates in terms of the functions
they generate assuming the ability to swap qubits and use ancillary workspace. Because we view
these stabilizer circuits as subroutines of some general quantum computation, we insist that any
ancilla qubits used during the computation must not change in an input-dependent manner.
This is the ﬁrst attempt at a quantum extension of the classiﬁcation of reversible classical gates
introduced by Aaronson et al., another part of an ambitious program to classify all quantum
gate sets.

The classiﬁcation uses, at its center, a reinterpretation of the tableau representation of
stabilizer gates to give circuit decompositions, from which elementary generators can easily be
extracted. There are a total of 57 diﬀerent stabilizer classes generated in this way, 30 of which
arise from the single-qubit subgroups of the Cliﬀord group. At a high level, the remaining classes
are arranged according to the bases they preserve. For instance, the CNOT gate preserves the
X and Z bases because it maps X-basis elements to X-basis elements and Z-basis elements to
Z-basis elements. The remaining classes are characterized by more subtle tableau invariants;
for instance, the T4 and phase gate generate a proper subclass of Z-preserving gates.

1

Introduction

A common thread through much of quantum computing and indeed through computation in general
is the manner in which a few elementary gates often suﬃce for universal computation. Indeed, this
“pervasiveness of universality” as described in recent work of Aaronson et al. [3] helps to explain
why a random gate on n qubits suﬃces for universal quantum computation.
In that work, the
authors give a complete classiﬁcation of classical reversible gates in terms of the functions over bits
they generate. Indeed, they ﬁnd that even when they restrict themselves to classical gates, a rich
structure emerges.

Of course, the ultimate goal would be a complete classiﬁcation of quantum gate sets based on
the functions over qubits they generate. Unfortunately, the extraordinary diﬃculty of this problem
given the current state of mathematics renders such a task nearly impossible. Not even a full
classiﬁcation of the subgroups of a three-qubit system is known1! This might be surprising, given
how well we understand random instances and even gate sets that contain particular gates such
as CNOT [6, 17]. However, a full classiﬁcation begets a complete understanding of all possible

∗MIT. Email: grierd@mit.edu. Supported by an NSF Graduate Research Fellowship under Grant No. 1122374.
†MIT. Email: lrs@mit.edu.
1The diﬃculty in classifying the subgroups of SU(N ) arises not from the inﬁnite classes but from the ﬁnite ones.
In fact, even the ﬁnite subgroups of SU(5) remain unclassiﬁed. This motivates our focus on ﬁnite, discrete classes
such as the stabilizer group.

1

behaviors, despite their strangeness or rarity (see, for example, the sporadic gate sets in [3]). Nev-
ertheless, there has been some recent and encouraging progress on some classiﬁcation problems,
in particular, on classifying Hamiltonians (which can be applied for any period of time), rather
than discrete gate sets. For instance, Bouland, Man˘cinska, and Zhang [7] recently classiﬁed all 2-
qubit commuting Hamiltonians while Childs et al. [9] characterized all 2-qubit Hamiltonians when
restricted to circuits over two qubits. Additionally, Aaronson and Bouland [1] completed a classiﬁ-
cation for linear optics of 2-mode beamsplitters, which relied heavily on the recent characterization
[14] of the ﬁnite subgroups of SU(3), underscoring the diﬃculty of quantum gate classiﬁcation.

This paper contributes its own classiﬁcation of quantum gate sets by giving a complete clas-
siﬁcation of the so-called stabilizer gates, where we allow the swapping of qubits and the use of
ancillary workspace. To provide some context, stabilizer gates2 are a discrete set of gates generated
by the CNOT gate, the Hadamard gate, and the π
4 -phase gate. Stabilizer circuits are somewhat
remarkable in that they may in fact be integral to our eventual development of a general-purpose
quantum computer. Since quantum error correction will likely play a large role in determining
when a quantum computer will be viable, there has been considerable research in building and an-
alyzing quantum error correcting codes. The stabilizer formalism arose as powerful way of unifying
the analyses of many of these codes [12], and as a consequence, understanding the nature of the
stabilizer states has been of particular interest [11, 16].

Our model is motivated by these interests. That is, we view the application of a stabilizer
circuit as the subroutine of a general quantum computation. In fact, the stabilizer operations are
exactly those operations which can be easily computed transversally in many fault-tolerant schemes
of quantum computing (e.g., the Shor code [18] or the [[7,1,3]] Steane code [19]). For this reason,
we insist that any ancillary qubits used during the computation return to their initial state by the
end of the computation so that the delicate quantum coherence of the protocol is not broken. The
ancilla states of our model are very similar to the “reusable magic states” mentioned in [5]. In fact,
our classiﬁcation closes many of the open problems left by that paper. Nevertheless, we regard
the classiﬁcation of stabilizer gates as an interesting mathematical problem in its own right, as it
exposes many of the beautiful symmetries inherent in the subgroups of the stabilizer operations.

Because the stabilizer operations on n qubits only generate a discrete, ﬁnite set, it has always
been widely assumed that they do not suﬃce for universal quantum computation. Nevertheless,
stabilizer gates drew attention when Gottesman and Knill [13] showed that they could be eﬃciently
simulated with a classical computer. This result was surprising to many because entanglement was
traditionally thought of as a barrier to classical simulation.

This result was subsequently improved by Aaronson and Gottesman [2], who showed that sta-
bilizer gates have surprisingly little computational power. First notice that the stabilizer gates can
be seen as a generalization of the aﬃne reversible gates in [3]; CNOT and NOT are stabilizer gates,
and hence all aﬃne reversible gates are stabilizer gates. What Aaronson and Gottesman realized is
that this is not just a good intuition for the stabilizer gates, but that stabilizer circuits are complete
for the class ⊕L (or parity-L), for which the complete problem is the solution of a linear system over
F2. Indeed, ⊕ L is widely regarded to be weaker than all of polynomial time computation. In that
work, Aaronson and Gottesman proposed the tableau representation of a stabilizer gate, which we
reinterpret to serve as one of the principal components of our classiﬁcation theorem. See Section 4
for those details.

2These gates are often called Cliﬀord operations in the literature due to their alternative characterization as

normalizers of the Pauli group.

2

1.1 Results

We present a full inclusion lattice of the 57 diﬀerent classes of stabilizer gates. Refer to Figure 4
for a diagram of the 30 single-qubit classes and Figure 5 for the remaining lattice of multi-qubit
gates. Notation for the generators of the classes depicted in those diagrams is given in Section 3.
We list some highlights of the classiﬁcation below:

(1) Conserved Quantities. The invariants that dictate the structure of the lattice are most
easily described by appealing to the tableau representation of a stabilizer circuit (see Sec-
tion 4). Nevertheless, there are some common themes that persist throughout classiﬁcation.
One major theme is that of basis preservation. We say that a gate “preserves” a basis if
it acts as an automorphism on the elements of that basis. For instance, the CNOT gate
preserves the X and Z bases, but not the Y basis. There are classes which correspond to
all 8 possible ways to preserve the X, Y , and Z bases. There are also classes in which each
entangling operation only changes the sign of a certain basis, such as the CSIGN gate, or
classes in which each entangling operation acts like an orthogonal transformation over the
computational basis states, such as the T4 gate of [3]. Finally, a class can be constrained by
its ability to rotate a single qubit. See Section 6 for a more formal exposition.

(2) Finite Generation. Every class can be generated by a single gate on at most four qubits.
In fact, given a set of gates generating some class, there always exist three gates from that
set that generate the same class. Moreover, the classiﬁcation implies that the canonical set
of stabilizer generators—CNOT, Hadamard, and phase—is not a minimal set of generators
in our model. Indeed, it turns out that with the aid of ancilla qubits, CNOT and Hadamard
generate a phase gate. This was discovered in [4, 15], but comes as a simple consequence of
our classiﬁcation theorem.

(3) Ancilla Simpliﬁcation. A priori, one might imagine that allowing the use of ancillas initial-
ized to arbitrary quantum states would increase the power of a stabilizer gate set compared
to say, ancillas initialized to stabilizer states. We show that the classiﬁcation, and indeed
the stabilizer functions generated by each class, do not change under the two models. This
implies that we can convert any circuit using general quantum ancillas to one using stabilizer
ancillas (over the same set of gates) with only an additive constant blowup in the number
of ancillas. Indeed, this has the eﬀect of giving a simple proof that stabilizer circuits cannot
generate a non-stabilizer gate using general quantum ancillas [5]. In fact, an even stronger
result is true. Namely, our classiﬁcation holds even when we allow the ancillas to change
in an input-independent manner3, as would be natural for a stabilizer subroutine applied
unconditionally in a quantum circuit. See Section 5 for further discussion.

(4) Algorithms. Our classiﬁcation implies a linear time algorithm which, given the tableau of
a gate G, decides which class G belongs to. As a consequence, we can identify the class for
a list of tableaux (by running the algorithm for each one, then looking up the least upper
bound on our lattice diagram), or determine whether one gate generates another (by running
the algorithm for both, and checking whether the one class contains the other). In fact, to

3The “Loose Ancilla Rule” in the classiﬁcation in [3] shows that this is not true for their classical reversible
circuits. However, we will see in Appendix B that this would have been true had those authors allowed general
quantum ancillas.

3

witness that G generates some class C (or higher) in the classiﬁcation, one only needs to view
a constant number of bits of the tableau. These details are discussed in sections 9 and 10.

(5) Enumeration. For each class C and for all n, we give explicit formulas for the number of
gates in C on n-qubits. The enumeration usually leads to eﬃcient canonical forms for circuits
in the various classes. In fact, every class is exponentially smaller than any class containing
it. See Appendix A for details.

(6) Sporadic Gates. The process of classiﬁcation unearthed certain strange classes, which
arise from the sometimes complicated interaction of the various invariants which might have
otherwise gone overlooked. For example, there are four classes containing the T4 gate which
require a generator over at least 4 qubits. Nevertheless, the smallest generator for the class
hT4, Γ,Pi is a gate over three qubits. We investigate such a gate in Appendix C. Interestingly,
there are no aﬃne gate sets in the classiﬁcation of classical reversible gates which admit a
generator over three bits and no smaller.

1.2 Proof Outline

We can break the proof into a few major steps. First, we introduce the notion of a stabilizer
tableau, a binary matrix representation of the function computed by a circuit. We then “guess”
all the classes in the classiﬁcation and designate them by their generators. An examination of the
tableaux of the gates in these classes reveals candidate invariants based on the elements of those
tableaux. We then prove that these candidate invariants are indeed invariant under the rules of our
model. That is to say, if we have two gates whose tableaux satisfy the invariant, then the tableau
of their composition satisﬁes the invariant, and so on for all the other ways to build circuits from
gates—tensor products, ancillas, swapping.

At this point, we will have shown that each class has a corresponding invariant, from which
the distinctness of the classes in the lattice is immediate. That is, for every pair of distinct classes
there is a generator of one that fails to satisfy the invariant of the other. Next, we will show that
this correspondence is bijective; that is, for each tableau invariant there is a corresponding class
whose generators generate all gates satisfying that tableau invariant. This will have the side eﬀect
of producing canonical forms for most of the classes in the lattice.

The challenge remains then to show that our list of classes is exhaustive. Suppose we are given
some gate set G. Clearly, the class generated by G is contained in some class in the lattice. Let C
be the smallest class containing all the gates in G. The hope is that we can use gates from G to
give explicit circuits for the generators of C. For each class S ⊂ C, there must be some gate g ∈ G
which is not in S, otherwise S would be a smaller class containing G.
The next step of the proof is to focus on some particular gate g, which has failed to satisfy the
invariant of S. The key now is the fact that from g we can extract a small generator that also fails
to satisfy the invariant of S. This is accomplished via the “universal construction” of the gate g,
which is a particular circuit built from g and SWAP gates from which these small generators can
easily be extracted. Finally, we show that these generators, one for each class S suﬃce to generate
the class C itself.

4

2 Stabilizer Formalism

The one-qubit unitary operations

X =(cid:18)0 1
1 0(cid:19)

Y =(cid:18)0 −i
0 (cid:19)

i

0

Z =(cid:18)1

0 −1(cid:19)

are known as Pauli matrices. The Pauli matrices are all involutions (X 2 = Y 2 = Z 2 = I), and
have the following relations between them

XY = iZ
Y X = −iZ

Y Z = iX
ZY = −iX

ZX = iY
XZ = −iY.

It follows that the Pauli matrices generate a discrete group (under multiplication), called the Pauli
group P, which consists of sixteen elements: {I, X, Y, Z} with phases ±1 or ±i. Then the Pauli
group on n qubits, Pn, is the set of all n-qubit tensor products of elements from P. We deﬁne a Pauli
string as any element of Pn with positive phase (i.e., a tensor product of the matrices I, X, Y, Z).
We frequently omit the tensor product symbol from Pauli strings and write, e.g., P1 ··· Pn where
we mean P1 ⊗ ··· ⊗ Pn.
The Cliﬀord group on n qubits, Cn, is the set of unitary operations which normalize Pn in the
group-theoretic sense. That is, U ∈ Cn if U pU† ∈ Pn for all p ∈ Pn. We leave it as a simple exercise
to check that Cn is indeed a group.
A stabilizer gate is any unitary inSn≥1 Cn. A stabilizer circuit is a quantum circuit of stabilizer
gates implementing a unitary transformation on some set of qubits, designated the input/output
qubits, while preserving the state of the remaining ancilla qubits. We further require that the initial
state of ancilla qubits is a stabilizer state, meaning that it is the result of applying a stabilizer gate
to |0··· 0i. We say that a state |ψi is stabilized by an operation U iﬀ U|ψi = |ψi. In other words,
|ψi is in the +1 eigenspace of U . The Pauli elements and their corresponding stabilized states are
below:

X : |+i = |0i+|1i√2
Y : |ii = |0i+i|1i√2
Z : |0i

−X : |−i = |0i−|1i√2
−Y : |−ii = |0i−i|1i√2
−Z : |1i

We call the vectors stabilized by non-identity Pauli elements P and −P the P -basis.

3 Gates

Let us introduce some common stabilizer gates. We start with the single-qubit stabilizer gates,
which happen to correspond to symmetries of cube (see Figure 1) or octahedron.

3.1 Single-qubit Gates

Face rotations: The Pauli matrices X, Y , and Z (as gates) correspond to 180◦ rotations about
the X, Y , and Z axes respectively. Similarly, we deﬁne RX, RY , and RZ to be 90◦ rotations
(in the counterclockwise direction) about their respective axes. Formally,

RX =

I − iX
√2

,

RY =

I − iY
√2

,

RZ =

I − iZ
√2

,

5

although in the case of RZ (also known as the phase gate and often denoted by S or P ), a
diﬀerent choice of phase is more conventional. The clockwise rotations are then R†X, R†Y and
R†Z .

Edge rotations: Another symmetry of the cube is to rotate one of the edges 180◦. Opposing
edges produce the same rotation, so we have six gates: θX+Y , θX−Y , θX+Z , θX−Z , θY +Z ,
θY −Z. We deﬁne

θP +Q =

P + Q
√2

,

θP−Q =

P − Q
√2

,

for all Pauli matrices P 6= Q. Note that θX+Z is the well-known Hadamard gate, usually
denoted by H.

Vertex rotations: The ﬁnal symmetry is a 120◦ counterclockwise rotation around one of the diag-
onals passing through opposite vertices of the cube. The cube has eight vertices, (±1,±1,±1),
and we denote the corresponding single-qubit gates Γ+++, Γ++−, . . ., Γ−−−. Algebraically,
we deﬁne

Γ+++ =

Γ++− =
...

Γ−−− =

I − iX − iY − iZ
I − iX − iY + iZ

2

2

I + iX + iY + iZ

2

,

,

.

We also deﬁne Γ (without subscripts) to be the ﬁrst gate, Γ+++, since it is the most convenient;
conjugation by Γ maps X to Y , Y to Z, and Z to X.

3.2 Multi-qubit Gates

We now introduce the multi-qubit stabilizer gates relevant to the classiﬁcation. The SWAP gate,
for instance, which exchanges two qubits. A more interesting example is the controlled-NOT or
CNOT gate, and the generalized CNOT gates.

A generalized CNOT gate is a two-qubit stabilizer gate of the form

C(P, Q) :=

I ⊗ I + P ⊗ I + I ⊗ Q − P ⊗ Q

2

,

where P and Q are Pauli matrices. If the ﬁrst qubit is in the +1 eigenspace of P then C(P, Q)
does nothing, but if it is in the −1 eigenspace of P then C(P, Q) applies Q to the second qubit. Of
course, the deﬁnition is completely symmetric, so you can also view it as applying P to the ﬁrst
qubit when the second qubit is in the −1 eigenspace of Q.
Observe that C(Z, X) is actually the CNOT gate; it applies a NOT gate to the second qubit
when the ﬁrst qubit is |1i and does nothing when the ﬁrst qubit is |0i. Figure 2 shows this
equivalence, and illustrates our circuit diagram notation for generalized CNOT gates. Also note
that C(X, Z) is a CNOT, but with the opposite orientation (i.e., the second bit controls the ﬁrst).

6

Γ−−+

RZ

Γ−++

θY +Z

Γ+−+

θX−Y

θX+Z

Γ+++

Γ−−−

RX

RY

θX+Y

Γ−+−

Γ+−−

θX−Z

θY −Z

Γ++−

Figure 1: Single-qubit gates as symmetries of the cube

7

Gate

Tableau

Unitary Matrix

i

0

RX

RY

X

Y

Z

0 1 1 (cid:19)
(cid:18) 1 0 0
(cid:18) 1 0 1
0 1 1 (cid:19)
0 1 0 (cid:19)
(cid:18) 1 0 1
1 1 1 (cid:19)
(cid:18) 1 0 0
(cid:18) 0 1 1
1 0 0 (cid:19)
0 1 0 (cid:19)
(cid:18) 1 1 0
θXZ = θX+Z = H (cid:18) 0 1 0
1 0 0 (cid:19)
(cid:18) 0 1 1
1 0 1 (cid:19)
(cid:18) 1 1 0
1 0 0 (cid:19) 1−i

(cid:18) 0 1
1 0 (cid:19)
(cid:18) 0 −i
0 (cid:19)
(cid:18) 1
0 −1 (cid:19)
1√2(cid:18) 1 −i
1 (cid:19)
−i
1√2(cid:18) 1 −1
1 (cid:19)
1−i√2 (cid:18) 1 0
0 i (cid:19)
1√2(cid:18) 1
1 −1 (cid:19)
1√2(cid:18) −1 1
1 (cid:19)
i (cid:19)
2 (cid:18) 1 −i

Γ+++ = Γ

θX−Z

RZ = S

1

1

1

1

Table 1: Single-qubit gates

•

=

Z

X

Figure 2: CNOT expressed as a C(Z, X) gate

The rest of the heterogeneous generalized CNOT gates (i.e., C(P, Q) where P 6= Q) are the natural
equivalents of CNOT in diﬀerent bases.
Similarly, C(Z, Z) is better known as the controlled-sign gate (denoted CSIGN), which ﬂips
the sign on input |11i, but does nothing otherwise. The homogeneous generalized CNOT gates
(i.e., C(P, P ) for some P ) are quite diﬀerent from heterogeneous CNOT gates. For instance, when
one CNOT targets the control qubit of another CNOT then it matters which gate is applied ﬁrst.
On the other hand, two CSIGN gates will always commute, whether or not they have a qubit in
common.

It turns out that every two-qubit stabilizer gate is equivalent to some combination of one qubit
stabilizer gates and generalized CNOT gates (see Appendix D). Most classes of stabilizer gates are
of this form, but there are a handful of classes which require larger generators. We will use the T4
gate, introduced in [3], to generate these classes. In that work, T2k is a 2k-bit classical gate (for
k ≥ 1) that ﬂips all bits of the input when the parity of the input is odd and does nothing when

8

Gate

C(Y, Y )

C(X, X)





C(Z, Z) = CSIGN 





C(X, Z) = CNOT 


C(Y, X)

C(Z, Y )

Tableau

1 0 0 0
0 1 1 0
0 0 1 0
1 0 0 1

1 0 1 1
0 1 1 1
1 1 1 0
1 1 0 1

1 0 0 1
0 1 0 0
0 1 1 0
0 0 0 1

1 0 1 0
0 1 1 0
0 0 1 0
1 1 0 1

1 0 1 1
0 1 0 0
0 1 1 0
0 1 0 1

1 0 0 0
0 1 0 1
1 0 1 0
0 0 0 1














Unitary Matrix on computational basis









1

1

2
1
1
1 −1
1
1
1 −1

1
1
1 −1
−1
1
1
1
2
1 −i −i
1
i
1 −1 −i

1 −i
i −1
1
i
i
1


1 0 0
0
0 1 0
0


0 0 1
0
0 0 0 −1
2
1
1 −i
i
1
i −i
1

1
1
i −i
−i
i
1
1

1 0 0
0
0 1 0
0

0 0 0 −i
0
0 0 i



1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0






1

Table 2: Two qubit gates. The sign bits are all 0 in the above tableaux so they are omitted.

the parity of the input is even. Notice that T2k is an orthogonal linear function of the input bits.
In particular, the matrix of the T4 gate (over F2) is

0 1 1 1
1 0 1 1
1 1 0 1
1 1 1 0




.




In the quantum setting, let the T2k gate simply apply this transformation to the Z basis vectors.

4 Tableaux

Observe that the matrices I, X, Y, Z are linearly independent, and therefore form a basis for the
It follows that Pn spans all 2n × 2n complex matrices. Hence, any
2 × 2 complex matrices.
unitary operation on n qubits can be characterized by its action on Pn. In particular, any gate is

9

characterized by how it acts on

p1 = XI ··· I, p2 = ZI ··· I, . . . , p2n−1 = I ··· IX, p2n = I ··· IZ.

We call this list the Pauli basis on n qubits, since one can write any element of Pn as a product of
basis elements times a phase (±1 or ±i).
Now suppose we are given a stabilizer gate, U ∈ Cn. By deﬁnition, stabilizer gates will map
each Pauli basis element to something in Pn, which can be written as a product of basis elements
times a phase. That is,

U pjU† = αj

p

Mjk
k

2n

Yk=1

for some bits Mj1, . . . , Mj(2n) ∈ {0, 1} and some phase4 αj ∈ {±1,±i}. The tableau for U is a
succinct representation for U consisting of the binary matrix M = [Mjk], and some representation
of the phases α1, . . . , α2n.

It turns out that U maps pj (or any Pauli string) to ±1 times a Pauli string, never ±i times a

Pauli string. This follows from the fact that the square of any Pauli string is I ··· I, so

(U pjU†)2 = U p2

j U† = U (I ··· I)U† = +I ··· I.

If the phase in front of the Pauli string in U pjU† were ±i, then squaring it would produce a negative
phase. Therefore, U pjU† is ±1 times a Pauli string.
Unfortunately, αj may still be any one of {±1,±i}. This is because the product of p2k−1p2k is
I ··· I(XZ)I ··· I = −iI ··· IY I ··· I, with an awkward −i phase. Once we cancel the extra factors
of i from αj, we are left with

n

(−1)vj := αj

Yk=1
(−i)Mj(2k−1)Mj(2k),

where vj ∈ {0, 1} is the phase bit for row j. For example, if U p1U† is Y I ··· I then we have
M11 = M12 = 1 and v1 = 0. Then the complete tableau for U is the matrix M = [Mjk] and the
vector of bits v = [vj], which we typically write as

M11
...

M(2n)1

··· M1(2n)
. . .
··· M(2n)(2n)

...

v1
...
v2n




.




Our ordering of the basis elements (which diﬀers from other presentations) puts Pauli strings
on the same qubit (e.g., XI ··· I and ZI ··· I) side-by-side in the matrix, so the 2 × 2 submatrix

M2i,2j (cid:19)
(cid:18)M2i−1,2j−1 M2i−1,2j
M2i,2j−1

completely describes how the ith qubit of the input aﬀects the jth qubit of the output. In fact, it
will be fruitful to think of the tableau as an n× n matrix of 2× 2 blocks, along with a vector of 2n
4Note that the order of the terms in the product matters, since the Pauli basis elements do not necessarily

commute, so we assume the terms are in the natural order from p

Mj1
1

up to p

Mj(2n)
2n

10

phase bits. To be clear, the blocks come from R := F2×2
, the ring of 2 × 2 matrices over the ﬁeld
of two elements, F2. Then the tableau is a matrix in Rn×n (the n × n matrices over the ring R),
combined with a vector of phase bits in F2n
2 . Each row of the matrix is associated with a pair of
phase bits from the vector.

2

However, not every matrix in Rn×n corresponds to a stabilizer circuit due to unitarity con-

straints. To best express these constraints, we deﬁne a unary operation ∗ on R such that

The ∗ operator has the property that

c d(cid:19)∗
(cid:18)a b

=(cid:18)d b
c a(cid:19) .

c d(cid:19)∗
(cid:18)a b
c d(cid:19)(cid:18)a b

Additionally,

=(cid:18)a b

c d(cid:19)(cid:18)d b

c a(cid:19) =(cid:18)ad + bc

0

0

ad + bc(cid:19) = I(cid:12)(cid:12)(cid:12)(cid:12)

a b

c d(cid:12)(cid:12)(cid:12)(cid:12)

.

I∗ = I,

(M + N )∗ = M∗ + N∗,

(M N )∗ = N∗M∗,
(M∗)∗ = M,

so ∗ makes R a ∗-ring or ring with involution. We also extend ∗ to an operation on matrices (over
R) which applies ∗ to each entry and then transposes the matrix.
It turns out that a tableau
represents a unitary operation if and only if the matrix M ∈ Rn×n satisﬁes M M∗ = M∗M = I.
This (intentionally) resembles the deﬁnition of a unitary matrix (U U† = U†U = I), we will call
this the unitarity condition, and it corresponds to the unitarity of U as a gate, but M is certainly
not a traditional complex unitary matrix (nor unitary over some ﬁnite ﬁeld with conjugation).

4.1 Correspondence between Gates and Tableaux

We will ﬁnd it useful to switch between gates and tableaux, as one notion often informs the other.
In light of that, deﬁne T (g) to be the tableau of a stabilizer gate g. In fact, we will use M(g)
to denote only the matrix part of the tableau of g, as the phase bits of the tableau often prove
to be irrelevant.
Indeed, most non-degenerate gate sets generate the Pauli group, which alone
suﬃces to set the phase bits of the tableau arbitrarily as follows: applying X to qubit j negates v2j
and applying Z to qubit j negates v2j−1. Furthermore, there is a surprising connection between
individual entries of tableaux and elementary stabilizer operations that can be extracted from them
(see Section 9).

If a ∈ R is invertible, then let G(a) be the single-qubit gate with M(G(a)) = a and zeros for
phase bits. These are the gates in the ﬁrst row of Table 4. Let G(a, i) be the gate G(a) applied to
the ith qubit.
If b ∈ R is noninvertible, deﬁne CNOT(b, i, j) to be the generalized CNOT on qubits i and j
corresponding to the singular matrix b. These are the gates in the ﬁrst row of Table 3. The tableau
T (CNOT(b, i, j)) is the identity tableau except for b∗ and b in positions (i, j) and (j, i), respectively.
We use the circuit in Figure 3 to designate such a gate.

11

b

b∗

Figure 3: Circuit diagram for CNOT(b, 1, 2) gate.

Finally, we would like to have a direct way to compose two circuits by a simple operation on
their tableaux. Suppose we wish to compute the composition of circuits C1 and C2. To compute
T (C2 ◦ C1), we must compute, for each Pauli basis element pj, the product C2C1pjC†1C†2. First
consider the jth row of T (C1), which gives

C1pjC†1 = αj

M (1)
jk
k

,

p

2n

Yk=1

where M (1) is the binary representation of M(C1), and αj is the phase. Similarly,

Therefore,

C2pjC†2 = βj

M (2)
jk
k

.

p

2n

Yk=1

2n

2n

C2C1pjC†1C†2 = C2 αj
Yk=1
Yk=1 β
Yℓ=1

= αj

=

2n

p

M (1)
jk
k

[M (1)M (2)]jℓ
ℓ

p

M (1)
jk

k ! C†2 = αj
Yℓ=1

M (1)
ℓ

jk M (2)

2n

p

kℓ

2n

M (1)
jk

Yk=1(cid:18)C2p
k C†2(cid:19) = αj
! ∝
Yℓ=1
Yk=1
∝

M (1)
ℓ

jk M (2)

2n

2n

p

kℓ

2n

Yℓ=1

2n

Yk=1 βk
Yℓ=1

2n

L2n
ℓ

p

jk

M (2)
kℓ

ℓ !M (1)

p

k=1 M (1)

jk M (2)

kℓ

Notice that this implies M(C2 ◦ C1) = M(C1)M(C2). Since it is cumbersome to write out
explicitly, we did not include the exact phases in the above calculation. Nevertheless, one can
compute the phase bits by tracking the intermediate steps in the above calculation, which includes
the multiplication of Pauli basis elements.

5 Classes

Given a set of stabilizer gates, our goal is to determine the functions over stabilizer states that they
can compute. A priori, we do not limit the complexity of the circuits computing these functions. It
will turn out however, as a result of the classiﬁcation, that we can eﬃciently construct a canonical
circuit from a given tableau.

Our ﬁrst rule is that we always allow the swapping of qubits. This allows us to consider gates
without needing to specify the qubits on which they must be applied. Indeed, we can relabel the
input wires however we like. Secondly, we allow the use of stabilizer ancillas, that is, arbitrary

12

stabilizer states that we can “hardwire” into the computation. We only stipulate that these ancilla
states be returned to their initial conﬁguration at the end of the computation.

These ancilla inputs can be viewed as the workspace of the computation. If we allow no ancilla
inputs at all then, of course, a gate set consisting of gates over many inputs can’t possibly hope
to simulate a gate over a smaller number of qubits. Furthermore, if we want to apply a stabilizer
function as a subroutine of a general quantum computation (as we would, say, for a fault-tolerant
scheme), then we need that the ancilla states do not depend on the input. Otherwise, they would
destroy the quantum coherence of your computation.

Finally, we turn to the question of the ancillas themselves. The weakest assumption one could
make is that the ancillas are initialized to an unknown state, which the circuit may only change
temporarily. This is somewhat artiﬁcial, since we can easily initialize the workspace to |0··· 0i,
and makes the problem dramatically more complicated (see Post’s Lattice vs. Post’s Lattice Lite
in [3] to see how access to constants can simplify a lattice). A slightly stronger assumption would
be to allow ancillas initialized to computational basis states, but this would break the symmetry by
introducing a bias towards the Z-basis 5. For this reason, we opt for ancillas initialized to arbitrary
(potentially multi-qubit) stabilizer states.

On the other hand, we could also give ourselves more powerful ancillas. Typically, increasing
the power of ancillas makes it possible to construct gates in situations they could not be constructed
before, causing groups of classes to collapse. For instance, we could assume the ancillas can be
initialized to arbitrary quantum states. Indeed, Bravyi and Kitaev [8] show that arbitrary magic
states and Cliﬀord operations suﬃce for general quantum computation, but their protocol depends
on a random walk on measurement outcomes, which are non-unitary and therefore outside our
model. In fact, we show in Appendix B that the lattice of reversible gates collapses signiﬁcantly
when we assume quantum ancillas.

Another way to increase the power of ancillas is to let them change over the course of the
computation, as long as the change is independent of the input (that is, from some constant initial
state to some possibly diﬀerent constant ﬁnal state). In [3], the authors call these loose ancillas,
and show that a few pairs classes collapse. Surprisingly, even with loose ancillas initialized to
arbitrary quantum states, our classiﬁcation (as presented) still holds! When we formally deﬁne
class invariants in Section 6 (see Theorem 4 in particular), we will see that the invariants remain
invariant with these stronger ancillas. Since any pair of classes can be separated by an invariant,
this implies that no two classes collapse under the more powerful ancillas.

A consequence of the classiﬁcation is that any function computed by gates from class C with
general ancillas can be converted to a circuit with gates from C with stabilizer ancillas. This
result should be somewhat surprising. Consider the gate θX+Z, whose eigenvectors (unnormalized)
(1 ± √2)|0i + |1i are not stabilizer states6. How then, given the gate θX+Z ⊗ θX+Z , does one

generate the gate θX+Z which acts only on one qubit? This is answered in the theorem below,
which gives an explicit nine qubit stabilizer state for this task.

Theorem 1. For any single-qubit gate g, there exists a stabilizer state |ψi and circuit of SWAP
gates π such that g ◦ π|ψi = |ψi.

5We can ﬁx the bias by allowing all single-qubit ancillary states: |0i, |1i, |+i, |−1i, |ii, |−ii. This introduces new

classes such as hθX+Z ⊗ θX+Zi, but we leave the classiﬁcation under these assumptions as an open problem.

6Stabilizer states are of the form (unnormalized) Px∈A(−1)q(x)iℓ(x)|xi where A is an aﬃne space over F2, q(x) is
a quadratic form, and ℓ(x) is a linear form [11, 16]. One can prove this by inducting on the form itself with a case
analysis of the Hadamard, phase, and CNOT gates.

13

Proof. For many of the single-qubit gates this statement is trivial. For instance, we have that
by deﬁnition X and RX stabilize the state |+i. Similarly, Y and RY stabilize |ii and Z and RZ
stabilize |0i. Since neither eigenvector for θX+Z is a stabilizer state, we require a stabilizer state
on more than one qubit. Let π be a circuit that cyclicly permutes qubits 2 through 9, and suppose
θX+Z is applied to qubit 1. Then (θX+Z ◦ π)|ψi = |ψi if the stabilizer group for |ψi is generated
by the Pauli strings

XXZXZIIII, ZIXZXZIII, XIIXZXZII, ZIIIXZXZI,
XIIIIXZXZ, ZZIIIIXZX, XXZIIIIXZ, ZZXZIIIIX,
−Y IIIY IIIY ,
Y Y IIIY III,

−Y IY IIIY II, Y IIY IIIY I,

9 of which are actually linearly independent. One can check straightforwardly that |ψi is a legitimate
stabilizer state which is stabilized by θX+Z ◦ π. By symmetry, all single-qubit edge rotations can
be handled similarly. The eigenvectors for the single-qubit vertex rotations are also not stabilizers.
In the spirit of the construction above, suppose Γ is applied to the qubit 1. Then Γ ◦ SWAP(2, 3)
stabilizes the state generated by {XXY, Y Y X, ZXY, XY X, Y XY, ZY X}, from which 3 linearly
independent generators can be extracted.

Now let us formally deﬁne a class C to be a set of stabilizer gates satisfying the following four

rules:

(1.) Composition Rule C is closed under composition of gates.
(2.) Tensor Rule C is closed under tensor product of gates.
(3.) Swap Rule C contains the SWAP gate.
(4.) Ancilla Rule C is closed under stabilizer ancillas. More precisely, if we have a gate g ∈ C
and a stabilizer state |ψi, and there exists g′ such that g(|xi ⊗ |ψi) = g′(|xi) ⊗ |ψi for all
inputs |xi (up to a global phase), then g′ is a member of C.

Let’s ﬁrst see a view simple consequences of the model.

Proposition 2. Let C be a class of stabilizer gates. Then C contains the n qubit identity gate for
any n.

Proof. First, C contains SWAP. It follows that C contains the two qubit identity gate since it is
the composition SWAP◦ SWAP. By the ancilla rule, we can remove a qubit from the two qubit
identity using literally any one-qubit stabilizer state. Hence, the one qubit identity gate is in C.
Finally, C must contain the n-qubit identity gate because it is the tensor product of n one-qubit
gates.
Proposition 3. Let C be a class of stabilizer gates. For any g ∈ C, the inverse, g−1, belongs to C.
Proof. Consider the sequence

g, g ◦ g, g ◦ g ◦ g, . . . , gn, . . . .

Since there are ﬁnitely many stabilizer gates on n qubits (certainly ﬁnitely many tableaux, and one
gate per tableau), the sequence must eventually repeat. That is, gi = gj for some 1 ≤ i < j. Since
every stabilizer gate has an inverse, we conclude that 1 = g0 = gj−i, and hence g−1 = gj−i−1. In
other words, g−1 is a stabilizer gate, and g−1 is a (positive) power of g and therefore in C.

14

The most practical way to talk about a class C is by its generators. We say a set of gates
G generates a class C if G ⊆ C and every class containing G also contains C. We introduce the
notation h·i for the class generated by a set of gates. Similarly, we say that G generates a speciﬁc
gate g if g ∈ hGi.
Our goal is therefore to identify all stabilizer gate classes, determine their generators, and
diagram the relationships between classes. As it turns out, there are 57 diﬀerent classes, which we
have split across Figure 4 (which contains the classes with single-qubit generators) and Figure 5
(which contains the multi-qubit classes). Each class is labelled by a set of generators for that class,
except for ALL, the class of all stabilizer gates; ⊤, the class of all single-qubit stabilizer gates; and
⊥, the class generated by the empty set. Additionally, we abbreviate some class names in Figure 4:
• θ+++, θ+−−, θ−+−, θ−−+ denote the single-qubit classes containing Γ+++, Γ+−−, Γ−+−, and

Γ−−+ respectively, and three θ gates each, as indicated by the gray lines.

• θxy abbreviates θx+y or θx−y (it contains both) and similarly for θxz and θyz.

Some of the lines in Figure 4 are gray and dotted, not for any technical reason, but because the
lattice would be unreadable otherwise.

In Figure 5 each class includes the label of the single-qubit subgroup, even when not all of the
single-qubit generators are necessary to generate the class. This is intended to make the relationship
between the degenerate and non-degenerate lattices clearer. For example, T4 generates the Pauli
group, P, on its own (Lemma 12), but we label the class hT4,Pi to make it clear that the class
hT4i is above hPi in the lattice.

6

Invariants

Up until now, we have deﬁned each class in terms of the generators for that class. It turns out
that each class can also be characterized as the set of all gates satisfying a collection of invariants.
Section 7 formalizes this equivalence. This section focuses on the form of the invariants themselves.
Informally, an invariant is a property of gates, readily apparent from their tableaux, which is
preserved by the circuit building operations. In other words, if a collection of gates all satisfy a
particular invariant then any circuit constructed from those gates must also satisfy the invariant.
All our invariants are formally deﬁned from the tableaux, but for now we give the following informal
descriptions to make the intuition for each invariant clear.

X-, Y -, or Z-preserving: We say a stabilizer gate is Z-preserving if it maps Z-basis states to
Z-basis states, possibly with a change of phase. The Z-preserving gates include all (classical)
reversible gates (e.g., X, CNOT, and T4), gates which only manipulate the sign (e.g., RZ
and CSIGN), and combinations of the two.

Symmetrically, there are X-preserving gates mapping X-basis states to X-basis states, and
Y -preserving gates gates mapping Y -basis states to Y -basis states. Our deﬁnitions of classes,
gates, invariants, etc., are completely symmetric with respect to X, Y and Z basis, so if
some gate or class is X-preserving (resp. Y -preserving or Z-preserving), then there must be a
corresponding gate or class which is Y -preserving (resp. Z-preserving or X-preserving). We
will often appeal to this symmetry to simplify proofs.

15

⊤

P + Γ

θ+++

θ+−−

θ−+−

θ−−+

P + RX

P + RY

P + RZ

1
6

P

RX

RY

RZ

X + θY Z

Y + θX Z

Z + θX Y

Γ+++

Γ+−−

Γ−+−

Γ−−+

θY +Z θY −Z θX+Z θX−Z θX+Y θX−Y

X

Y

Z

⊥

Figure 4: The inclusion lattice of degenerate stabilizer gate classes

ALL

C(Y, X) + P + RX

T4 +P + Γ

C(Z, Y ) + P + RY

C(X, Z) + P + RZ

C(X, Z) + P

T4 +P + RX

C(Y, X) + P

T4 +P + RY

C(Z, Y ) + P

T4 +P + RZ

1
7

T4 +P

C(X, X) + P + RX

C(Y, Y ) + P + RY

C(Z, Z) + P + RZ

C(X, X) + P

C(X, X) + RX

C(X, X) + X + θY Z

C(Y, Y ) + P

C(Y, Y ) + RY

C(Y, Y ) + Y + θXZ

C(Z, Z) + P

C(Z, Z) + RZ

C(Z, Z) + Z + θXY

C(X, X) + X

C(Y, Y ) + Y

C(Z, Z) + Z

Figure 5: The inclusion lattice of non-degenerate stabilizer gate classes. Red, green, blue denote X-, Y -, and Z-preserving,
respectively.

Note that a gate can be any combination of X-, Y -, and Z-preserving. For instance, T4 is
X-, Y -, and Z-preserving; CNOT is X-preserving and Z-preserving but not Y -preserving
(similarly C(X, Y ) and C(Y, Z) fail to be Z-preserving and X-preserving respectively); RZ is
Z-preserving only (similarly RX is X-preserving and RY is Y -preserving); and Γ is not X-,
Y -, or Z-preserving.

Egalitarian We say a gate is egalitarian if it is ﬁxed (up to a Pauli operation on each qubit)
by the aforementioned X/Y /Z symmetry, that is, the symmetry arising from conjugating all
qubits by Γ (which cycles X to Y , Y to Z, and Z to X). In particular, this implies that if
egalitarian operation U maps Pauli string P to Q = U P U† under conjugation, then U maps
ΓP Γ† to

U ΓP Γ†U† ∝ ΓU Γ†ΓP Γ†ΓU†Γ† = ΓU P U†Γ† = ΓQΓ†.

Not only are Γ and the Pauli matrices themselves egalitarian, but so is T4.

Degenerate: We say a gate is degenerate if each input aﬀects only one output. More precisely,
when applying the gate to a string of Paulis, changing one Pauli in the input will change
exactly one Pauli in the output. All single-qubit gates are degenerate, and all degenerate
gates can be composed of single-qubit gates and SWAP gates.

X-, Y -, or Z-degenerate: A gate is Z-degenerate if it is Z-preserving and ﬂipping any bit of a
classical (Z-basis) input to the gate causes exactly one bit of the output to ﬂip. The gate
may or may not aﬀect the phase. This class includes several Z-preserving single qubit gates,
like RZ, the Pauli operations, and θX+Y .
It also includes CSIGN because this gate only
aﬀects phase, but CNOT is not Z-degenerate because ﬂipping the control bit changes both
outputs. Notice that CSIGN is Z-degenerate, but not degenerate. We deﬁne X-degenerate
and Y -degenerate symmetrically.

X-, Y -, or Z-orthogonal: A gate G is Z-orthogonal if it can be built from T4 and Z-preserving
single-qubit gates. The term “orthogonal” comes from the fact that T4 is an orthogonal
linear transformation in the Z-basis, but not all Z-orthogonal gates are literally orthogonal
transformations in the Z-basis (see, for example, Lemma 12). Similarly for X-orthogonal and
Y -orthogonal.

Single Qubit Gates: There are thirty diﬀerent classes of single-qubit gates. All of these classes
are degenerate, and some can be distinguished by the other invariants above. However, many
single-qubit invariants depend on the phase bits of the tableau. For instance, the tableau of
θX+Y , θX−Y , and RZ all have the same matrix part, ( 1 1
0 1 ), but generate three distinct classes.
One can write down explicit invariants for these classes where the phase bits are correlated
to the tableau entries, but in most cases we present a single-qubit class as a subgroup of the
symmetries of the cube/octahedron, as shown in Figure 1.

6.1 Formal invariants

An invariant is a property of tableaux which is preserved by the four circuit-building rules.

Swap Rule: Every class contains the SWAP gate, so every invariant we propose must be satisﬁed

by the tableau for SWAP.

18

Composition Rule: If the invariant holds for two gates, then it must hold for their composition.
We have seen that the tableau for the composition of two gates is essentially the matrix
product of the two tableau, except for the phase bits (which are signiﬁcantly more complicated
to update).

Tensor Rule: The tensor product of two gates satisfying the invariant must also satisfy the in-
variant. Note that the tableau of the tensor product is the direct sum of the tableaux, and
phase bits are inherited from the sub-tableaux in the natural way.

Ancilla Rule: The invariant must be preserved when some qubits are used as ancillas. It turns out
the ancilla operation reduces the tableau to a submatrix (of non-ancilla rows and columns)
and under certain conditions, the corresponding subset of the phase bits. This is somewhat
technical, so we prove it in Theorem 4 below.

Theorem 4. Let G be a stabilizer gate on n qubits, and suppose there exist states |ψi and |ψ′i
such that

for all |xi, for some unitary H on m-qubits. In particular, this is true if we use the ancilla rule to
reduce G to H, where |ψi = |ψ′i is the ancilla state. Then

G(|xi ⊗ |ψi) = H(|xi) ⊗(cid:12)(cid:12)ψ′(cid:11)

1. H is a stabilizer operation,

2. M(H) is obtained by removing the rows and columns corresponding to the ancilla bits from

M(G),

3. If every bit (in M(G) as a binary matrix) we remove from a row is zero, then the phase bit

for that row is the same in T (G) and T (H).

Proof. Let P ∈ Pm. Then for all |xi,

On the other hand, G is a stabilizer gate, so conjugating P ⊗I n−m by G produces Q⊗R for Q ∈ Pm
and R ∈ Pn−m . Equivalently,

G(P|xi ⊗ |ψi) = H(P|xi) ⊗(cid:12)(cid:12)ψ′(cid:11).
G(P ⊗ I n−m) = (Q ⊗ R)G.

It follows that

= (Q ⊗ R)G(|xi ⊗ |ψi)

H(P|xi) ⊗(cid:12)(cid:12)ψ′(cid:11) = G(P|xi ⊗ |ψi)
= (Q ⊗ R)(cid:0)H(|xi) ⊗(cid:12)(cid:12)ψ′(cid:11)(cid:1)
= QH(|xi) ⊗ R(cid:12)(cid:12)ψ′(cid:11),

so up to phase, H(P|xi) = QH(|xi) for all |xi, and |ψ′i = R|ψ′i. The ﬁrst equation implies
HP = QH, or HP H† = Q. Since P was arbitrary, the conjugation of a Pauli string by H is always
another Pauli string, so H is a stabilizer gate.

In the special case that P (and therefore P ⊗ I n−m) is a Pauli basis element, then Q ⊗ R is
represented in row of the binary tableau of G. We keep the bits representing Q in the tableau for

19

H, since HP H† = Q, which is why M(H) is a submatrix of M(G). Clearly the phase of Q is the
same as the phase of Q ⊗ R if and only if R is positive. In the special case R = ±I n−m, it is easy
to see that R is positive, otherwise

is a contradiction. Hence, the phase for the corresponding row of T (H) is inherited from T (G).

(cid:12)(cid:12)ψ′(cid:11) = R(cid:12)(cid:12)ψ′(cid:11) = −I n−m(cid:12)(cid:12)ψ′(cid:11) = −(cid:12)(cid:12)ψ′(cid:11)

As a direct consequence of these rules, our invariants take on a distinctly algebraic ﬂavor. Let us
consider, for the sake of illustration, invariants that depend only on the matrix part of the tableau
and ignore the phase bits. Then an invariant is equivalent to a set of matrices closed under the four
rules above. In particular, the matrices to form a group under multiplication as a consequence of
the composition rule (and the fact that every gate has ﬁnite order).

On the other hand, not every group of matrices will correspond to an invariant. For instance,
due to the swap rule, the group of matrices must also be closed under arbitrary reordering the rows
and columns. This eliminates, e.g., the group of upper triangular matrices. Similarly, the ancilla
rule excludes the special orthogonal group. In the end, we are left with just two kinds of matrix
groups which lead to invariants:

Subring Invariants Matrices with elements restricted to a particular subring of R (analogous to

the real matrices, integer matrices, etc.)

Permutation Invariants Permutation matrices, except where each 1 entry can be any one of
a subset of invertible elements, and each 0 entry comes from a collection of non-invertible
elements.

Now we are ready to present formal deﬁnitions for these invariants, and show that they really

are preserved by the circuit-building rules.

6.2 Subring invariants

The ﬁrst kind of invariant restricts the entries of the tableau to a subring of R. That is, given a
subring S ⊆ R, a gate satisﬁes the invariant I(S) if and only if all entries of the tableau are in S.
There are twelve classes, all near the top of the lattice, of the form

corresponding to all 12 subrings of R listed below.

C = {All gates satisfying I(S)},

• The entire ring, R, is technically a subring of itself, and I(R) is the trivial invariant satisﬁed
by all stabilizer gates. Notice that not every matrix over R gives a valid tableau because it
must still be unitary.

• There are four maximal proper subrings of R:

RX = {( a 0
RY = {( a b
RZ = {( a b
RE = {( a b

c d ) : {a, c, d} ∈ {0, 1}},
c d ) : {a, b, c, d} ∈ {0, 1}, a + b + c + d = 0},
0 d ) : {a, b, d} ∈ {0, 1}},
b a+b ) : {a, b} ∈ {0, 1}}.

20

Our formal deﬁnition for Z-preserving gates is the invariant I(RZ ). The fact that the lower
left entry is 0 implies that the gate maps Pauli strings of I and Z to strings of I and Z. Hence,
Z-basis strings are mapped to Z-basis strings. Similarly, the X-preserving and Y -preserving
invariants are I(RX ) and I(RY ) respectively. The egalitarian invariant, I(RE), comes from
the subring RE.

• The intersection of two subrings is itself a subring, giving us exactly four more subrings
(RX ∩ RY , RX ∩ RZ, RY ∩ RZ , and RX ∩ RY ∩ RZ) since the intersection of RE with any of
the others is

the trivial ring.

RX ∩ RY ∩ RZ = {( 0 0

0 0 ), ( 1 0

0 1 )},

• Three more subrings are obtained by taking only self-conjugate elements of RX, RY , and RZ

respectively. An element ( a b

c d ) is self-conjugate if

( a b
c d ) = ( a b

c d )∗,

or equivalently, a = d. These invariants correspond to the X-orthogonal (i.e., hT4,P, RXi),
Y -orthogonal (i.e., hT4,P, RY i), and Z-orthogonal (i.e., hT4,P, RZi) classes respectively.

Theorem 5. For any subring S ⊆ R, the property I(S) is an invariant. That is, the set of matrices
over S respect the circuit building operations.

Proof. Every subring contains ( 0 0
omitted) of the SWAP gate,

0 0 ) and ( 1 0

0 1 ) by deﬁnition, and therefore the tableau (phase bits

0 0 1 0
0 0 0 1
1 0 0 0
0 1 0 0







satisﬁes I(S).

Matrix multiplication is a polynomial in the entries of the two matrices, so composition cannot
produce entries outside the subring. Similarly, combining tableau with tensor products or reducing
tableau to submatrices via ancillas does not introduce any new ring elements; those operations only
use elements already present in the tableau. We conclude that I(S) is an invariant for any subring
S.

6.3 Permutation invariants

The permutation invariants get their name from the matrix part of their tableaux, which is required
to have the structure of a permutation matrix. That is, every row (or column) has exactly one
element which is invertible, and the others are non-invertible. Permutation invariants are also
sensitive to phase bits. It is natural to associate the unique invertible element in a row with the
phase bits for that row, giving the tableau of a single-qubit gate. A permutation invariant P(G, S)
is deﬁned by the set of single-qubit gates G which can be obtained in this way, and the set of
non-invertible elements S used to ﬁll the rest of the tableau. In other words, a tableau satisﬁes
P(G, S) if all entries are from S except exactly one entry per row which, when combined with the
phase bits for the row, is the tableau of some gate in G.

21

Note that not all pairs of sets (G, S) produce an invariant. For instance, circuit-building oper-
ations will fail to preserve P(G, S) if G is not a group. The exact relationship between G and S
required to produce an invariant is diﬃcult to write down. Roughly speaking, products of elements
in S should be zero, products of elements in G should remain in G, and products between S and
M(G) should be manageable in some sense. Theorem 6 gives a list of P(G, S) invariants, which
will turn out to be exhaustive by Theorem 20, the culminating theorem of this paper.

Theorem 6. We prove that the following permutation invariants are indeed invariant under the
circuit-building operations.

1. If G is a group of single-qubit gates then

P(G,{( 0 0

0 0 )})

is an invariant for hGi. All thirty degenerate classes are characterized by invariants of this
form.

2. If hXi ⊆ G ⊆ hP, RXi is a group of single-qubit gates then

P(G,{( 0 0

0 0 ), ( 0 0

1 0 )})

is an invariant for hC(X, X), Gi. These invariants characterize the ﬁve X-degenerate classes.

3. If hY i ⊆ G ⊆ hP, RY i is a group of single-qubit gates then

P(G,{( 0 0

0 0 ), ( 1 1

1 1 )})

is an invariant for hC(Y, Y ), Gi. These invariants characterize the ﬁve Y -degenerate classes.

4. If hZi ⊆ G ⊆ hP, RZi is a group of single-qubit gates then

P(G,{( 0 0

0 0 ), ( 0 1

0 0 )})

is an invariant for hC(Z, Z), Gi. These invariants characterize the ﬁve Z-degenerate classes.
Proof. Let P(G, S) be one of the invariants above. Let M = {M(g) : g ∈ G} be the set of matrices
from tableaux in G. In all cases, S contains ( 0 0
0 0 ), and G contains the single-qubit identity operation,

(cid:18) 1 0 0
0 1 0 (cid:19) ,

so SWAP satisﬁes the invariant. And clearly the direct sum of two tableaux in P(G, S) is still in
P(G, S) for any G and S.

Now consider the composition of two gates. Each entry in the tableau is a dot product of some
row from one tableau with some column from the other. Hence, the entry is a sum of S × S, S × M ,
M × S, or M × M products. Observe that the S × S products are all zero (for the particular sets S
above), so we may ignore those products. Recall that the row and column each contain exactly one
entry in M , so depending on whether those entries align, we get either SM + M S ⊆ S or M 2 = M .
Furthermore, for any row in one tableau there is exactly one column in the other such that the
invertible entries line up, therefore exactly one entry in any row (or column) of the composition is

22

in M and the rest are in S. Clearly the matrix part of the tableau has the correct form for the
invariant.

We must also consider phase bits under composition. Recall that the phase bits associate with
the invertible entries of the matrix to produce single-qubit gates. When we multiply two tableau,
these single-qubit gates multiply to produce elements in G (since G is a group), as you would
expect. If the non-invertible elements are all zero, then this is the only factor in determining phase
bits, so the invariant is preserved by composition.

Now consider the phase bits in the case where S contains nonzero elements, for instance,

S = {( 0 0

0 0 ), ( 0 1

0 0 )}.

Notice that in this case, both matrices in S have zeros in the bottom row, and the invertible
matrices are of the form ( 1 a
0 1 ). Hence, every even-indexed row of the tableau (as a binary matrix)
is all zeros except for one entry. Using the method of tableau composition in Section 4, one can
easily show that for these even-indexed rows, the phase bits are exactly what one would get by
composing the invertible elements as gates in G. For the other half of the rows, the non-invertible
elements may ﬂip the phase bits. But we assume G contains the Pauli element (in this case Z)
which ﬂips that sign, so the invertible elements and associated phase bits are still in G, therefore
the invariant is preserved. The X- and Y -degenerate cases are similar.

Last, we show that P(G, S) is preserved under ancilla operations. Recall that when we use
ancillas, we remove the rows and columns corresponding to those bits. Clearly the elements of the
submatrix are still in M and S. There is a risk that the invertible element for some row could be in
one of the removed columns, but if the submatrix is missing an invertible element in some row then
the submatrix is not unitary and the ancilla rule must have been misapplied. Hence, only elements
in S are removed in the non-ancilla part of the tableau, and each row still contains exactly one
entry in M .

We appeal to Theorem 4 for the phase bits. The theorem says that removing the ancillas can
only change the sign for a row if there is a nonzero entry in the non-ancilla bits of the row that are
removed. For example, if S = {( 0 0
0 0 )} then only the top phase bit can change. But changing
the top phase bit is the same as applying a Z, and for this case Z is assumed to be in G, so the
combination of the element in M and the phase bits is still in G. Therefore the Z-degenerate
P(G, S) are invariants, and the X-degenerate and Y -degenerate invariants follow by symmetry.

0 0 ), ( 0 1

7 Equivalence of Generator and Invariant Deﬁnitions

We have now deﬁned each class by a set of generators, and by an invariant, but have not yet shown
that these deﬁnitions coincide. Below are a collection of lemmas which prove this for all classes in
our lattice. Note that one direction is always trivial: it is easy to check that the generators deﬁning
a class satisfy a particular invariant, and therefore everything they generate (i.e., the class) must
satisfy the invariant. We encourage the reader to check these invariants against, say, the tableaux
in Table 2.

For the other inclusion (i.e., every gate satisfying the invariant can be generated by the given
generators), we start with an arbitrary gate g satisfying the invariant, and apply gates in the class
to g to simplify its tableau step-by-step until it is the tableau of the identity operation. It follows
that AgB = I for circuits A and B in the class, which proves g = A−1B−1 is in the class. In many

23

cases, the circuit derived this way is a canonical form for the gate, and can be used to count the
number of gates on n qubits in a class.

Let us start with the degenerate classes.

Lemma 7. Let G be a group of single-qubit gates, and let g be a gate satisfying the permutation
invariant P(G,{( 0 0
0 0 )}). Then there is a circuit for g consisting of a permutation of the inputs
followed by layer of single-qubit gates in G.

Proof. Consider the tableau for g. Each row or column has exactly one invertible element, so
we can read oﬀ a permutation π from the positions of those elements. Apply SWAP gates to g to
remove this permutation, and put the invertible elements on the diagonal. When we pair a diagonal
element with the phase bits for that row, we get a single-qubit gate gi in G. Applying the inverse of
this gate to qubit i will zero the phase bits for that row, and make ( 1 0
0 1 ) the diagonal entry. Once
we do this for each row, we have the identity tableau, therefore g is in hGi and has a circuit of the
desired form.

Next, we consider the Z-degenerate classes and, by symmetry, the X-degenerate and Y -degenerate

classes.

Lemma 8. Let hZi ⊆ G ⊆ hP, RZi be a subgroup of Z-preserving single-qubit gates. Let g be
any gate satisfying the permutation invariant P(G,{( 0 0
0 0 )}). Then there is a circuit for g
consisting of a layer of single-qubit gates (from G), a layer of C(Z, Z) gates, and a permutation.

0 0 ), ( 0 1

Proof. Consider the tableau of g. We can read oﬀ a permutation π, and a single-qubit gate for each
input. Assume we have removed those gates (i.e., we now consider the tableau of gπ−1g−1
··· g−1
n ),
1
so the tableau has ( 1 0
0 0 ) or zero, and the phase
bits are zero.

0 1 ) on the diagonal, all other entries are either ( 0 1

The non-zero, oﬀ-diagonal entries in the matrix indicate the positions of C(Z, Z) gates. Specif-
ically, if the entry in row i and column j is nonzero then there is a C(Z, Z) on qubits i and j. Note
that because the matrix part of the tableau is unitary, the symmetric entry in row j and column i
must also be non-zero. The remainder of the circuit consists of the set of C(Z, Z) gates indicated
by the non-zero, oﬀ-diagonal entries. Notice that C(Z, Z) gates always commute, so their ordering
does not matter..

Now let us consider four Z-preserving classes which, when we consider symmetry (i.e., the

X-preserving and Y -preserving equivalents) cover all but two of the remaining classes.

Lemma 9. Each of the classes hT4,Pi, hT4,P, RZi, hC(Z, X),Pi, and hC(Z, X),P, RZi is the set
of all gates corresponding to a subring invariant, where the subrings are

S1 = {( 0 0
S2 = {( 0 0
S3 = {( 0 0
S4 = {( 0 0

0 0 ), ( 1 0
0 0 ), ( 0 1
0 0 ), ( 1 0
0 0 ), ( 0 0

0 1 )},
0 0 ), ( 1 0
0 0 ), ( 0 0
0 1 ), ( 0 1

0 1 ), ( 1 1
0 1 ), ( 1 0
0 0 ), ( 0 1

0 1 )},
0 1 )},
0 1 ), ( 1 0

0 0 ), ( 1 0

0 1 ), ( 1 1

0 0 ), ( 1 1

0 1 )}.

Proof. In all four classes, elements of the tableau are of the form ( a b
entry of some row, and ( ? ?
qubit i to j, these entries will be of the form ( ? ?

0 d1 ) is the ith
0 d2 ) is the jth entry in the same row. If we apply a CNOT gate from
0 d1+d2 ) respectively. That is, the bottom

0 d ). Suppose ( ? ?

0 d1 ) and ( ?

?

24

right bits change as though we applied the CNOT gate to those bits. Since a T4 gate can be built
from CNOT gates, it will (similarly) aﬀect the bottom right bits as though we are applying a T4.
Our strategy is to use either CNOT or T4 gates (depending on the class) to perform Gaussian
elimination on the bottom right entries of the matrix elements. If we have access to CNOT gates
then we literally apply Gaussian elimination, using CNOT to add one column to another, and using
SWAP to exchange columns.

If we only have T4 gates then we are in subring S1 ⊆ S2 or S2, so ( 1 0

0 1 ) are the only
elements with a 1 in the bottom right position, and also the only invertible elements. It follows
that the number of bottom right bits set to 1 in a row is the same as the number of invertible
elements, which must be odd because the matrix is unitary. To reduce the number, we apply a T4
to three 1 bits and a 0 bit (note: we may add a zero bit by adding an ancilla, if necessary), which
changes the 0 to a 1 and the 1’s to 0’s, reducing the number of 1’s (or invertible elements) in the
row by two. When there is a single 1 left in the row, unitarity conditions imply that it is also the
only 1 left in that column, so we may ignore that row and column for the moment and continue to
eliminate the rest of the matrix.

0 1 ) and ( 1 1

Now suppose we have row reduced the matrix, using either CNOT or T4, so that the bottom
right entry of every element is 0, except along the diagonal where that bit 1. At this point, the
diagonal element is the only element in a row that can possibly be invertible, therefore the diagonal
elements are of the form ( 1 b
0 1 ). Similarly, unitarity conditions imply that the oﬀ-diagonal elements
are of the form ( 0 b
0 0 ). In other words, the remaining tableau is Z-degenerate, since there is only
one invertible element per row or column, and the oﬀ-diagonal elements are in I = {( 0 0
0 0 )}.
We can use either Lemma 7 or Lemma 8 to ﬁnd a circuit from the remainder, which is in either
hPi or hC(Z, Z),P, RZi, depending on the class.

0 0 ), ( 0 1

There are only two classes remaining, ALL and hT4,P, Γi, which we handle specially. For the
ﬁrst, we appeal to Aaronson and Gottesman [2] who give an explicit decomposition for any stabilizer
gate into layers of CNOT, Hadamard (θX+Z in our notation), and phase (RZ ) gates.

Lemma 10. Any egalitarian gate g can be constructed from T4, P and Γ gates.
Proof. Egalitarian gates satisfy the invariant that all elements are in the subring

0 0 ), ( 1 0

{( 0 0

0 1 ), ( 1 1

1 0 ), ( 0 1

1 1 ).}

In fact, this subring is isomorphic to F4, so it is a ﬁeld. The unitarity of the matrix in our sense
translates to unitarity as a matrix over F4.

Like the other T4 classes, we use Gaussian elimination on the tableau of g. Consider a row of the
tableau. If the entry in some column is not the identity, then apply Γ or Γ−1 to the corresponding
qubit to make it the identity. By unitarity, there are an odd number of identity elements in the
row. We may remove pairs of identity elements with a T4, similar to Lemma 9, until there is only
one left and the rest of the row is zero. Unitarity implies the column below the identity element is
also zero, and we proceed to eliminate the rest of the tableau. Once the matrix part of the tableau
is the identity, we apply Pauli matrices to zero out the phase bits.

We conclude that all egalitarian gates are in hT4,P, Γi.

25

8 Circuit Identities

In this section, we give necessary tools to prove that a set of gates generates, in some sense, “all
that one could hope for.” Formally, we wish to prove that the gate set generates a particular class
in the classiﬁcation lattice when it is contained in that class but fails to satisfy the invariants of all
classes below it. To this end, we give several useful circuit identities that will be used extensively
in Section 9. For instance, one can show that any circuit on two qubits can be reduced to an
equivalent circuit containing at most one generalized CNOT gate (see Appendix D). The following
lemma gives only the aspect of that theorem that is necessary to the classiﬁcation, that is, the
ability to extract single-qubit stabilizers from the composition of generalized CNOT gates.
Lemma 11. Let P, Q, R ∈ P, and let ΓP Γ† = Q and ΓQΓ† = R. Then

• C(P, Q) and C(P, R) generate RP .
• C(P, P ) and C(P, R) generate RP .
• C(P, P ) and C(Q, R) generate Γ.
• C(P, P ) and C(Q, Q) generate θP +Q.

Proof. The ﬁrst two inclusions come from the following identity, which holds whenever ΓQΓ† = R
(i.e. regardless of P ):

P

R

P

Q

=

RP

P

RQ

ancilla−−−−→rule

RP

Similarly, for the third identity, we get

P

P

Q

R

and for the ﬁnal identity

P

P

Q

Q

P

P

P

P

=

=

× Γ

× Γ†

swap

−−−→rule

Γ

Γ†

Thm 1−−−−→

Γ

× θP +Q

× θP +Q

swap

−−−→rule

θP +Q

θP +Q

Thm 1−−−−→

θP +Q

.

It might seem strange to reduce non-degenerate gates into less powerful single-qubit gates, but
we will eventually see that single-qubit generators are the most crucial. Once we have shown that a
particular set of gates generates all single-qubit operations, then that set of gates will generate the
class of all stabilizer operations provided it contains any non-degenerate gate. All non-degenerate
gates generate at least one Pauli, often the entire Pauli group, which is why some single-qubit
classes do not appear as the single-qubit subgroup of a non-degenerate class. For instance, consider

26

the CNOT gate where the ﬁrst qubit controls the second qubit. If we let the ﬁrst input be |1i,
then a Pauli X operation is always applied to the second qubit. Similarly, if we let the input to the
second qubit be |−i, then a Pauli Z operation is always applied to the ﬁrst qubit. Under the ancilla
rule, we now have Pauli X and Z operations, so we can generate Y and the entire Pauli group.
Clearly, the same is true for any heterogeneous CNOT gate. However, surprisingly, the following
lemma shows that even the T4 gate suﬃces to generate the entire Pauli group.

Lemma 12. T4 generates the Pauli group.

Proof. Consider the following two circuits:

|00i−|11i√2

|01i+|10i√2

|0i
|xi

T4

×
×

(−1)x|xi

|+i
|xi

T4

×
×

|x ⊕ 1i

Under the ancilla rule, the ﬁrst generates a Pauli Z operation while the second generates a Pauli
X, from which we can clearly generate the Pauli group.

There is another way to view the identity of Lemma 12 which will be useful later. Since T4
is an aﬃne gate over the computational basis states, T4 = C1C2 . . . Cn where each Ci is a CNOT
gate. Furthermore, T4 and CNOT are their own inverses, so T4 = CnCn−1 . . . C1. Finally, because
n . Notice that C T
T4 is symmetric when represented as a 4 × 4 matrix over F2, T4 = C T
i
just represents the CNOT gate Ci where the control and target qubits are swapped. Therefore,
leveraging the well-known equivalence θ⊗2
X+Z = SWAP◦ CNOT◦ SWAP we arrive
at the following consequence7:

2 . . . C T

1 C T

X+Z ◦ CNOT◦θ⊗2
X+Z T4 θ⊗4
θ⊗4
X+Z = T4 .

Similarly, by straightforward calculation, we get

R⊗4

Z T4 R⊗4

Z = T4 .

It is now easy to extend old circuit identities into new ones. For instance, conjugating the ﬁrst
circuit in the proof of Lemma 12 by θ⊗4
X+Z (which does not change the circuit because of the above
observations) and pushing the θX+Z gates into the inputs, yields the second circuit. This technique
is in fact very general and is used in the proof of the lemma below.

Lemma 13. T4 and C(P, P ) generate RP .

Proof. Figure 6 shows how to generate RZ with C(Z, Z). Using the argument by conjugation above,
T4 and C(P, P ) generate RP .

The following lemmas make precise our working assumption that single-qubit gates can signiﬁ-

cantly bolster the power of non-degenerate gate sets.

Lemma 14. Suppose we have any C(P, Q) gate with any single-qubit gate G that does not preserve
the P -basis and any single-qubit gate H that does not preserve the Q-basis. Then hC(P, Q), G, Hi =
ALL.

7Recall that θX+Z is commonly known as the Hadamard gate

27

|00i+i|11i

√2

|0i
|xi

T4

Z

Z ×
×

ix|xi

Figure 6: Generating RZ with T4 and C(Z, Z).

Proof. We will prove that the class hC(P, Q), G, Hi contains all single-qubit gates. Then, to prove
that the class generates all stabilizer operations, it is be suﬃcient to show that it contains a CNOT
gate. However, since all generalized CNOT gates are conjugates of each other, this is immediate.

First suppose P = Q. Since G does not preserve P -basis, we can use G to create a C(R, R)
gate where R 6= P . By Lemma 11, we can generate a θP +R gate. Conjugating C(P, P ) by θP +R
on the second qubit yields a C(P, R) gate. Once again leveraging Lemma 11, C(P, R) and C(P, P )
generate an RP gate. Referring to the single-qubit lattice (see Figure 4), we see that the class
hP, θP +R, RPi contains all single-qubit gates.
Now suppose that P 6= Q. Once again, since G does not preserve P -basis, we can use G to
create a C(R, Q) gate. If R = Q, then by the logic above, we can use H to generate all single qubit
gates, so suppose R 6= Q. By Lemma 11, we can use C(P, Q) and C(R, Q) to generate an RQ gate.
Conjugating both C(P, Q) and C(R, Q) by H appropriately, gives a C(P, S) and C(R, S) for some
S 6= Q, which we can once again generate an RS gate. Referring to the single-qubit lattice, we see
that the class hP, RS, RQi contains all single-qubit gates.
Lemma 15. T4 with the class of all single-qubit gates generates ALL.

Proof. It is well known that CNOT, θX+Z, and RZ generate all stabilizer circuits. Therefore, it
will be suﬃcient to show that T4 plus all single-qubit gates generate CNOT. Under the ancilla
rule, it is clear by Figure 7 that T4 and RZ suﬃce to generate C(Z, Z). Conjugating one qubit of
C(Z, Z) by θX+Z yields a C(Z, X) = CNOT gate, completing the proof.

R†Z

T4

T4

RZ

RZ

RZ

Z

Z

=

Z

Z

Z

Z

Figure 7: Generating C(Z, Z) with T4 and RZ .

28

×
×

...

G

...

G−1

...

Figure 8: Universal Construction C(G)

9 Universal Construction

Suppose G is an n-qubit stabilizer gate.
It turns out there is a single circuit C(G), the univer-
sal construction, which can help us extract useful generators (e.g., single-qubit gates, generalized
CNOTs, etc.) from G. Speciﬁcally, the circuit C(G) (shown in Figure 8) applies G to qubits 2
through n + 1, swaps qubits 1 and 2, then applies G−1 to qubits 2 through n + 1.

Note that after we apply G, all of the qubits but one go directly into G−1, which should
intuitively cancel out “most” of the eﬀect G has on those qubits, isolating the eﬀect of G on the
swapped qubit. The following theorem makes this intuition more precise.

Theorem 16. Let G be an n-qubit stabilizer gate. Then

M(C(G)) = In+1 +(cid:18)1

v(cid:19)(cid:0)1 v∗(cid:1)

where v ∈ Rn×1 is the ﬁrst column of M(G).
Proof. Let M(G) =(cid:0) A B
M(G)M(G†) =(cid:18)1

C D(cid:1) with A ∈ R, B ∈ R1×(n−1), C ∈ R(n−1)×1, and D ∈ R(n−1)×(n−1). Thus,
0 In−1(cid:19) =(cid:18)A B

B∗ D∗(cid:19) =(cid:18)AA∗ + BB∗ AC∗ + BD∗
CA∗ + DB∗ CC∗ + DD∗(cid:19)

C D(cid:19)(cid:18)A∗ C∗

0

which implies

M(C(G)) =

=


0

1
0
0 A B
0 C D
A∗




0
A 1 + AA∗
C

CA∗







0 1 0
1 0 0
0 0 1
C∗
AC∗




In−1 + CC∗

0

A∗

1
0
0 A∗ C∗
0 B∗ D∗

C∗
0
A BB∗ BD∗
C DB∗ DD∗

 =


 = In+1 +


(cid:0)1 A∗ C∗(cid:1) .


1
A
C




Tableaux of the form In + vv∗ have relatively simple circuit decompositions in terms of single-

qubit generators and generalized CNOT gates, which is formalized in the following theorem.

29

Theorem 17. Let v = {1, a2, a3, . . . , a2k, b1, . . . , bℓ} ∈ Rn×1 where each ai is invertible and each bi
is singular, and let C be a stabilizer circuit such that M(C) = In + vv∗. Then C is equivalent to
the circuit consisting of

• a T2k gate on the ﬁrst 2k qubits,
• conjugated by G(ai, i) for all i in {2, . . . , 2k},
• conjugated by CNOT(bi, 1, 2k + i) for all i ∈ {1, . . . , ℓ}, and
• a ﬁnal layer of Pauli gates ( not conjugated) on every qubit.

That is, C is equivalent to the circuit in Figure 9.

Proof. Notice ﬁrst that because each ai is invertible, we can conjugate C by G(ai, i) for each
i ∈ {2, . . . , 2k}, yielding a circuit with the simpler tableau

Diag(1, a2, . . . , a2k, 1, . . . , 1)(In + vv∗)Diag(1, a∗2, . . . , a∗2k, 1, . . . , 1) = In + v′v′∗

where v′ = {1, . . . , 1, b1, . . . , bℓ}. Furthermore, conjugating the circuit by the gate CNOT(bi, 1, i +
2k) corresponds to the simpliﬁcation

CNOT(bi, 1, i + 2k)(In + v′v′∗) CNOT(bi, 1, i + 2k) = In + v′′v′′∗

where v′′ is equal to v′ with the exception that entry i+2k is equal to zero. Repeating this procedure
for each i ∈ {1, . . . , ℓ}, we arrive at a circuit with a very simple tableau:
In + {1, . . . , 1, 0, . . . , 0}{1, . . . , 1, 0, . . . , 0}T ,

which is exactly the tableau of a T2k gate applied to the ﬁrst 2k qubits. Notice, ﬁnally, that by
reversing the procedure and applying the appropriate Pauli gates to each qubit, we can ensure that
the tableau of the decomposition is that of C(G).

Theorem 17 leads to a clean circuit decomposition of C(G). All that is left to show is that
we can actually generate each of the elementary gates that appears in the decomposition under
the ancilla rule. First, we will need the following useful lemma, which will allow us to essentially
disregard the Pauli operators in the decomposition of the universal construction when applying the
ancilla rule.

Lemma 18. Let G be a gate on n qubits which is stabilized by some stabilizer state |ai on the ﬁrst
k qubits and generates H on the remaining qubits. Furthermore, let P be any gate on the ﬁrst k
qubits. Then P ◦ G generates H ⊗ H−1.
Proof. By supposition we have that G(|ai ⊗ |ψi) = |ai ⊗ H|ψi. Therefore P ◦ G(|ai ⊗ |ψi) =
P|ai ⊗ H|ψi. Now apply inverse of P ◦ G to P|ai ⊗ H|ψi with the same ﬁrst k qubits and n − k
new qubits. In the middle, P cancels with P −1, and we can remove those k qubits by using |ai as
an ancilla. On the remaining qubits, we have H ⊗ H−1.

We are ﬁnally ready to prove the main theorem of this section.

30

b1

b2

. . .

bℓ

bℓ

. . .

b2

b1

T2k

G(a2)
G(a3)

...

G(a2k)

G−1(a2)
G−1(a3)

...

G−1(a2k)

P1

P2

P3
...
P2k

b∗1

b∗2

. . .

b∗ℓ

b∗1

P2k+1

P2k+2

b∗2

. . .

b∗ℓ

...
Pn

Figure 9: Decomposition of C(G).

Theorem 19. Let G be a stabilizer gate on n qubits. Furthermore, let

v = (1, a2, a3, . . . , a2k, b1, . . . , bℓ) ∈ Rn×1

be a vector where each ai is invertible and each bi is singular be some row of M(G). Then G
generates a gate G such that M(G) = ai for each i ∈ {2, . . . , 2k}, CNOT(bj) for all j ∈ {1, . . . , ℓ},
and T2k gate.

Proof. From theorems 16 and 17, we know that universal construction C(G) can be decomposed as
shown in Figure 9. The proof will proceed in the following manner. Starting with the decomposition
of C(G), we show that it generates some elementary gate. We then use that gate to simplify the
original decomposition of C(G), eventually generating all such gates in this manner.

First notice that for some input i ∈ {2k + 1, . . . , n}, the single qubit stabilizer state |bii serves
to remove the eﬀect of the generalized CNOT. By Lemma 18, we can remove the last ℓ qubits with
ancillas, at the expense of creating another (inverted) copy of the remaining 2k bits. That is, we
have H ⊗ H−1 where H is as follows:

T2k

G(a2)
G(a3)

...

G(a2k)

P1

P2

G−1(a2)
G−1(a3)

P3
...
G−1(a2k) P2k

...

31

Now let |φi = |00i+|11i√2
be the Bell state on two qubits. Notice that we can use |φi as an ancilla
to remove two bits from T2ℓ (i.e., leaving a T2ℓ−2). However, the T2ℓ occurs in H conjugated by
single-qubit gates, followed by Pauli operations. If we feed the state G(ai, i)† ⊗ G(aj , j)†|φi to bits
i and j, the single-qubit gates transform it to |φi, it removes two bits from the T2ℓ, then it is
transformed to PiG(ai, i)† ⊗ PjG(aj, j)†|φi. We can do the exact same thing to H−1, starting with
PiG(ai, i)† ⊗ PjG(aj , j)†|φi and going to G(ai, i)† ⊗ G(aj, j)†|φi. Then we swap the two states, and
use the ancilla rule to remove them. The net result is that we can remove any two qubits of H, as
long as we remove the same pair of qubits from H−1.

Iterate this procedure to until H has been reduced to just the ﬁrst two qubits, and so has H−1.
In particular, the T2ℓ gate in the middle is now a T2, which we observe is actually a SWAP gate.
From H, the remaining circuit is

×
×

G(ai)

G−1(ai)

P1

Pi

and the inverse survives from H−1. Remove the swaps, and observe that we have ancillas to remove
any of the remaining single-qubit gates, so we can isolate each single-qubit gate, in particular
Pi ◦ G−1(ai), P1 ◦ G−1(ai) and their inverses. From this point on, everything we do for H can be
repeated for H−1, which culminates in removing all the single-qubit gates, at which point we can
remove the extra T2ℓ gate easily. Hence, let us ignore H−1.

Now let us repeat the procedure above starting from the C(G), but stop short of applying the
ancilla rule to qubit 2k + j. The result is the ﬁrst circuit depicted below, which is then simpliﬁed
by an application of the swap rule, and gates Pi ◦ G−1(ai) and P1 ◦ G−1(ai):

bj

b∗j

×

G(ai) × G−1(ai)

bj

b∗j

P1

Pi

Pj

→

G(ai)

bj

b∗j

bj

b∗j

G−1(ai)

Pj

Notice that the topmost qubit is stabilized by G−1(ai)|bji, from which we can see that the ancilla
rule immediately generates CNOT(bj). Finally, we exploit the fact that

T2k(P ⊗ I⊗2k−1)T2k = I ⊗ P ⊗2k−1

to show8

T2k

G(a2)
G(a3)

...

G(a2k)

P1

P2

P3

...
P2k

G−1(a2)
G−1(a3)

...

G−1(a2k)

→

T2k

G(a2)
G(a3)

...

G(a2k)

P1

P1

...
P1

G−1(a2)
G−1(a3)

...

G−1(a2k)

P2

P3

...
P2k

T2k

→

8Actually, conjugation of a single Pauli imparts a global phase when P = Y . Although, this is unimportant for

circuit identities such as this one, care should be taken when conjugating the stabilizer group of a state.

32

where the last implication comes from the fact that we already generated Pi ◦ G−1(ai) and P1 ◦
G−1(ai).

10 Completing the Classiﬁcation

The ﬁnal step in the classiﬁcation is to demonstrate that the classes we have deﬁned are in fact the
only classes that exist.

Theorem 20. Let S be some class in the classiﬁcation, and let G be a collection of gates. Suppose
hGi ⊆ S, but hGi 6⊆ S′ for all S′ below S in our classiﬁcation. That is, for all such S′ there exists
a gate g ∈ G such that g /∈ S′. Then hGi = S.
Proof. Let C be the class generated by G. There is a very general strategy for proving that the
given class C is indeed one already stated in the classiﬁcation. For each invariant described in
Section 6 that C fails to preserve, the universal construction generates a (simple) gate which also
fails to satisfy that invariant by Theorem 19. Composing these gates using identities from Section 8,
one can show that they always generate some class in the classiﬁcation. This would complete the
classiﬁcation.

Nevertheless, we now give a complete sequence of tests to identify the class C. First consider
If C is degenerate, then by Lemma 7 we can decompose each gate
the degeneracy invariant.
into a circuit of single-qubit gates and swap gates. Using Theorem 1, each single-qubit gate can
be extracted. The question therefore reduces to the simple group-theoretic question about the
subgroups of single-qubit gates, which can be solved straightforwardly. Therefore, assume C is
non-degenerate.
Let us separate the remainder of the proof based on the X-, Y -, Z-preserving invariant. Let P ,

Q, and R be distinct Pauli operations.

Suppose ﬁrst that C is X-, Y -, and Z-preserving. Because every generalized CNOT gate violates
one such invariant and C is non-degenerate, some gate in C must have a tableau with multiple
invertible elements in some row. Therefore, from the universal construction we extract a T4 gate.
By Lemma 12, we have then that C = hT4,Pi.
Suppose now that C is P - and Q-preserving but not R-preserving. Because C is non-degenerate,
it must generate either a heterogeneous CNOT gate, a homogenous CNOT gate, or a T4 gate. We
wish to show that C contains a C(P, Q) gate, which would imply C = hC(P, Q),Pi as desired. First
notice that no homogeneous CNOT gate can be P - and Q-preserving. Suppose then that from the
universal construction, C generates a T4 gate but no C(P, Q) gate. Since T4 is R-preserving, there
must be some single-qubit gate from the universal construction that is not R-preserving but is P -
and Q-preserving. It is straightforward to check that no such single-qubit gate exists, which implies
that C must contain a C(P, Q) gate.
Suppose now that C is P -preserving but not Q- and R-preserving. This is the most involved
case and will require several more subdivisions. It will be ﬁrst useful to notice that all P -preserving
single-qubit gates are also P -orthogonal. Therefore, if C violates the P -orthogonality invariant, then
the universal construction must produce some non-degenerate gate which violates P -orthogonality.
Therefore, C contains a C(P, Q) gate or a C(P, R) gate. If it contains both via the universal con-
struction, then indeed C = hC(P, Q), RP ,Pi by Lemma 11. Otherwise, the universal construction
produces some single-qubit gate which is P -preserving but not Q- and R-preserving. Since all

33

heterogeneous CNOT gates generate the Pauli group as well, the class of single qubit gates must
therefore contain an RP gate.

Therefore let us now assume that C is P -orthogonal but not P -degenerate. Since C is P -
orthogonal, it cannot contain a C(P, Q) or C(P, R). However, because C is P -preserving, it must
contain a T4 gate; otherwise it would be P -degenerate. Once again, since the T4 gate generates
the Pauli group and C is neither Q- nor R-preserving, the class of single qubit gates must contain
an RP gate, implying that C = hT4, RP ,Pi.
Let us then assume that C is P -degenerate. Since C is non-degenerate, it must contain a
C(P, P ) gate. There are ﬁve P -degenerate classes, which are determined by their single-qubit
subgroup. Indeed, the ﬁve P -degenerate classes correspond to the ﬁve P -preserving single-qubit
classes containing P . Unlike previous cases, such a diversity of classes exists because C(P, P ) does
not suﬃce to generate the Pauli group on its own. Once again, the universal construction allows
us to extract the C(P, P ) gate along with single-qubit gates which suﬃce to generate every gate
in C. It is straightforward to see why the entire single-qubit group must arise from the universal
construction.
If not, then each gate in C could be constructed by gates in a smaller class, a
contradiction. This completes the classiﬁcation of all gates that are P -preserving but not Q- and
R-preserving.

Assume then that C is neither P -,Q-, nor R-preserving. If it is egalitarian, then it must contain
a T4 gate because it is non-degenerate. Therefore it must contain a single-qubit gate that is
egalitarian, but not P -,Q-, or R-preserving. The only such single-qubit class which contains the
Pauli group is hΓ,Pi. Therefore C = hT4, Γ,Pi.
Finally, let us then assume that C also violates the egalitarian invariant. That is, C violates
every invariant so should be equal to the class of all stabilizer operations. Suppose the only non-
degenerate gate generated by the universal construction is the T4 gate. In particular, this implies
that class of single-qubit gates generated by C must not be X-, Y -, Z-preserving, nor egalitarian.
Therefore the single-qubit class of C must contain all single-qubit gates. Therefore by Lemma 15
we generate all stabilizer circuits.
Similarly, Lemma 11 implies that if the set of generalized CNOT gates generated by the universal
construction fails to be P -, Q-, or R-preserving, then C generates a single-qubit gate which fails
to be P -, Q-, or R-preserving, respectively. Combining this fact with Lemma 14 implies that
C = ALL.
Corollary 21. Given any set of gates G, there is a subset S ⊆ G of at most three gates such that
hSi = hGi.
Proof. The result follows by a careful accounting of the gates used in the proof of Theorem 20. We
give the argument only for the degenerate classes.

Let G be a set of single-qubit gates with S ⊆ G and such that hSi = hGi. Suppose S =
{g1, . . . , gk} with k > 3. We can assume that each generator in the set S is not contained in
the subgroup generated by the other elements in S, otherwise we could remove that generator,
reducing the size of S. Therefore, there is an ascending chain of subgroups G0 ⊂ G1 ⊂ . . . ⊂ Gk,
where Gi = hg1, . . . , gii. Observing Figure 4, the longest ascending chain has length four, and in
particular, all chains of length four end at the class of all single-qubit gates. Furthermore, that
chain must contain one of the subgroups hP, RXi, hP, RY i, or hP, RZi, which we can assume is
hP, RZi by symmetry.

34

Element

( 0 0
1 0 )

( 1 1
1 1 )

( 0 1
0 0 )

Gen. CNOT C(X, X) C(Y, Y ) C(Z, Z)

0 0 ) / ( 0 0
( 1 0
0 1 )
C(X, Z)

1 0 ) / ( 0 0
( 1 0
1 1 )
C(Y, X)

0 0 ) / ( 0 1
( 1 1
0 1 )
C(Z, Y )

Table 3: Noninvertible tableau elements and the corresponding generalized CNOT gates produced
by the universal construction.

( 1 0
0 1 )
I

X

Z

Y

( 1 0
1 1 )
R†X
RX

θY +Z
θY −Z

( 0 1
1 0 )
θX+Z
R†Y
RY
θX−Z

( 1 1
0 1 )
RZ

θX+Y
R†Z
θX−Y

( 0 1
( 1 1
1 1 )
1 0 )
Γ+++ Γ−−−
Γ−−+ Γ+−+
Γ−+− Γ−++
Γ+−− Γ++−

( 0
0 )
( 0
1 )
( 1
0 )
( 1
1 )

Table 4: Invertible tableau elements and the corresponding single-qubit gates produced by the
universal construction. Row of the table corresponds to the sign bit of the row of the tableau in
which the element occurs.

Since not all gates in S are Pauli operators, we can assume that g1 is not a Pauli operator.
In particular, g1 ∈ hP, RZi \ hPi. That is, g1 is one of RZ, R†Z, θX+Y , or θX−Y . Therefore, the
class G2 is either hRZi or hZ, θXY i. Clearly, g4 /∈ hP, RZi (i.e., it does not preserve the Z-basis),
and by a simply case analysis, it is easy to see that hg1, g2, g4i is the entire class of single-qubit
operations.

11 Open Problems

Our classiﬁcation of stabilizer gates resolves an open problem of Aaronson et al. [3], but leaves
their central question, the classiﬁcation of quantum gates, completely open. It is unclear whether
there is another piece of the full quantum gate classiﬁcation that can be peeled oﬀ. Other discrete
quantum gate sets are known, but none are known to have the rich structure and entanglement
of stabilizer gates (aside from conjugated stabilizer gates). So we ask: are there other interesting
discrete gate sets, and can they be classiﬁed like stabilizer gates?

Another source of open problems is the choice of ancilla rule. As discussed, we permit ancillas
initialized to stabilizer states. What if we only allow ancillas to be initialized to the eigenvectors of
X, Y or Z? We expect a new class for the Hadamard gate (among other single-qubit gates), but are
there any new non-degenerate classes? What if we go a step further and allow only computational
basis ancillas, as in [3]?

12 Acknowledgments

We would like to thank Scott Aaronson for his insightful guidance throughout this project. Also,
thanks to Adam Bouland for useful discussion. We would especially like to acknowledge Han-Hsuan
Lin for contributing the stabilizer state for the Hadamard gate in Theorem 1.

35

References

[1] Scott Aaronson and Adam Bouland. Generation of universal linear optics by any beam splitter.

Phys. Rev. A, 89(6):062316, 2014. arXiv:1310.6718.

[2] Scott Aaronson and Daniel Gottesman. Improved simulation of stabilizer circuits. Phys. Rev.

A, 70(052328), 2004. arXiv:quant-ph/0406196.

[3] Scott Aaronson, Daniel Grier, and Luke Schaeﬀer. The classiﬁcation of reversible bit opera-

tions. arXiv preprint arXiv:1504.05155, 2015.

[4] Panos Aliferis. Level reduction and the quantum threshold theorem. arXiv preprint quant-

ph/0703230, 2007.

[5] Jonas T. Anderson. On the power of reusable magic states. arXiv preprint arXiv:1205.0289,

2012.

[6] A. Barenco, C. H. Bennett, R. Cleve, D. P. DiVincenzo, N. Margolus, P. Shor, T. Sleator,
J. Smolin, and H. Weinfurter. Elementary gates for quantum computation. Phys. Rev. A,
52(3457), 1995. arXiv:quant-ph/9503016.

[7] Adam Bouland, Laura Mancinska, and Xue Zhang. Complexity classiﬁcation of two-qubit

commuting Hamiltonians. arXiv preprint arXiv:1602.04145, 2015.

[8] Sergey Bravyi and Alexei Kitaev. Universal quantum computation with ideal cliﬀord gates

and noisy ancillas. Physical Review A, 71(2):022316, 2005.

[9] Andrew M. Childs, Debbie Leung, Laura Manˇcinska, and Maris Ozols. Characterization of

universal two-qubit Hamiltonians. arXiv preprint arXiv:1004.1645, 2010.

[10] John Horton Conway, Robert T. Curtis, Simon P. Norton, and Richard A. Parker. Atlas of

ﬁnite groups. Oxford University Press, 1985.

[11] Jeroen Dehaene and Bart De Moor. Cliﬀord group, stabilizer states, and linear and quadratic

operations over GF(2). Physical Review A, 68(4):042318, 2003.

[12] Daniel Gottesman. Stabilizer codes and quantum error correction. arXiv preprint quant-

ph/9705052, 1997.

[13] Daniel Gottesman. The Heisenberg representation of quantum computers. arXiv preprint

quant-ph/9807006, 1998.

[14] Walter Grimus and Patrick Otto Ludl. On the characterization of the SU(3)-subgroups of type

C and D. Journal of Physics A: Mathematical and Theoretical, 47(7):075202, 2014.

[15] N. Cody Jones, Rodney Van Meter, Austin G. Fowler, Peter L. McMahon, Jungsang Kim,
Thaddeus D. Ladd, and Yoshihisa Yamamoto. Layered architecture for quantum computing.
Physical Review X, 2(3):031007, 2012.

[16] Martin Van den Nest. Classical simulation of quantum computation, the Gottesman-Knill

theorem, and slightly beyond. arXiv preprint arXiv:0811.0898, 2008.

36

[17] Yaoyun Shi. Both Toﬀoli and controlled-NOT need little help to do universal quantum com-

putation. Quantum Information and Computation, 3(1):84–92, 2002. quant-ph/0205115.

[18] Peter W. Shor. Fault-tolerant quantum computation. In Foundations of Computer Science,

1996. Proceedings., 37th Annual Symposium on, pages 56–65. IEEE, 1996.

[19] Andrew Steane. Multiple particle interference and quantum error correction. Proc. Roy. Soc.

London, A452:2551–2577, 1996. quant-ph/9601029.

A Enumeration

Theorem 22. Let #h·in denote the number of n qubit gates in a class. Then

#hGin = |G|n n!

n

#hC(Z, Z), Gin = |G|n 2n(n−1)/2n!
Yi=1
(2i − 1),
#hC(Z, X),Pin = 4n2n(n−1)/2
Yi=1
(2i − 1),

#hC(Z, X),P, RZin = 8n2n(n−1)
#hT4,Pin = 4na(n),

n

n

#hT4,P, RZin = 8n2n(n−1)/2a(n),
Yi=1
(2i − (−1)i),
#hT4,P, Γin = 4n2n(n−1)/2
Yi=1
(4i − 1),

#hALLin = 4n2n2

n

for G a group of single-qubit gates,
for hZi ⊆ G ⊆ hP, RZi a group,

if n = 2m,
if n = 2m + 1.

where

a(n) =(2m2Qm−1
2m2Qm

i=1 (22i − 1),
i=1(22i − 1),

Proof. Most of these numbers follow from the lemmas above. For example, consider the class
hC(Z, X),P, RZi. It follows from Lemma 9 that any gate in this class has a circuit consisting of a
layer of C(Z, X) gates, then a layer of C(Z, Z) gates, then a layer of single-qubit gates in G.
We would like to count the number of possible gates by multiplying the number of possibilities
for each layer, but we must be careful that there is no gate with two circuit representations. Suppose
for a contradiction that g1 and g2 generate the same gate, but some layer of g1 diﬀers from g2.
Then g−1

1 g2 is the identity, since g1 and g2 generate the same transformation.

On the other hand, the C(Z, X) layers of g1 and g2 meet in the middle of the circuit for
g−1
1 g2.
If those layers do not generate the same linear transformation, then the combination is
some non-trivial linear transformation which is, in particular, not Z-degenerate. The other layers
of g1 and g2 are Z-degenerate, so we conclude that g−1
1 g2 is not Z-degenerate (if it were, we could
invert the outer layers to show that the two middle layers are Z-degenerate). But g−1
1 g2 = I

37

is clearly Z-degenerate, therefore the C(Z, X) layers of g1 and g2 must generate the same linear
transformation.

The C(Z, X) layers of g1 and g2 cancel (since we have shown they are equivalent), so they
eﬀectively disappear, and we make a similar argument about the C(Z, Z) layers, and then the
single-qubit layers. That is, if the C(Z, Z) layers do not contain the same set of C(Z, Z) gates,
then we obtain a contradiction because they produce a non-degenerate layer in the middle, implying
that g−1
1 g2 = I is non-degenerate. Once we remove the C(Z, Z) layers, the single-qubit layers must
be the same or they would leave behind a non-trivial single-qubit gate. We conclude that all layers
of g1 and g2 are actually the same, so the number of gates is the product of the number of choices
for each layer.

Now the problem is to count the number of choices for each layer. For the single qubit layer,
this is clearly just n independent choices of single-qubit gate from hP, RZi, or 8n. For the C(Z, Z)
layer, there is a choice whether or not to place a C(Z, Z) gate in each of the (cid:0)n
2(cid:1) possible positions,
so 2n(n−1)/2 choices for the layer. For the C(Z, X) layer, observe that C(Z, X) generate precisely
the set of invertible linear transformations, of which there are

2n(n−1)/2

n

Yi=1

(2i − 1)

by a classical argument. Multiplying the three layers, we have a total of

#hC(Z, X),P, RZin = 8n2n(n−1)

n

Yi=1
(2i − 1)

n-qubit transformations generated by C(Z, X), P, and RZ .
argument, although for the last two classes we need the fact that T4 generates

The numbers for hGi, hC(Z, Z), Gi, hC(Z, X),Pi, hT4,Pi, and hT4,P, RZi follow by a similar

a(n) =(2m2Qm−1
2m2Qm

i=1 (22i − 1),
i=1(22i − 1),

orthogonal transformations on n qubits.

if n = 2m,
if n = 2m + 1.

For the ﬁnal two classes, we use known expressions (from [10]) for the number of n × n unitary
matrices over F4 (in the case of hT4,P, Γi) and for the number of 2n× 2n symplectic matrices over
F2 (in the case of ALL). We multiply by 4n in both cases to account for the phase bits, which are
completely independent of the matrix part.

38

log2 2π + O(cid:18) 1
n(cid:19) ,
log2 2π + O(cid:18) 1
n(cid:19) ,

1
2

+ n log2 n − nlog2 e +

Theorem 23. The asymptotic size of each class is as follows.

log2 #hGin = n log2(|G|) + n log2 n − nlog2 e +

1
2

2

log2 #hC(Z, X),P, RZin =
log2 #hT4,Pin =

n(n − 1)
log2 #hC(Z, Z), Gin = n log2(|G|) +
log2 #hC(Z, X),Pin = n2 + 2n − α + O(2−n),
n − α + O(2−n),
n − β + O(2−n),
log2 #hT4,P, RZin = n2 + 3n − β + O(2−n),
log2 #hT4,P, Γin = n2 + 2n + γ + O(2−n),
log2 #hALLin = 2n2 + 3n − β + O(4−n).

n2 +

n2 +

3
2
1
2

5
2
3
2

where G is the same as in Theorem 22, and

∞

∞

α = −

log2(1 − 2−i) ≈ 1.7919,

Xi=1
Xi=1
β = −
∞
Xi=1
log2(1 − (−2)−i) ≈ 0.27587.

log2(1 − 4−i) ≈ 0.53839,

γ =

Proof. We take the logarithm of each class size, which we can separate into the logarithm of each
layer comprising that class, as in Theorem 22. For most layers this is straightforward, except
for the layer of permutations, orthogonal transformations, or general linear transformations. The
ﬁrst we handle with Stirling’s approximation. For the other two, we factor out powers of two
leaving a partial sum of a convergent series, which we analyze with a Taylor expansion. The classes
hT4,P, Γin and hALLin follow by similar techniques.
Corollary 24. Let C be any class, and let G be an n-qubit gate chosen uniformly at random from
C. Then

Pr [G generates C] = 1 − O(2−n).

B Classical reversible gates with quantum ancillas

In this section we describe what the classical reversible gate lattice of Aaronson et al. [3] would
have looked like had they allowed quantum rather than classical ancillas. We extend all classical
gates discussed in that paper to the quantum setting in the most natural way; that is, a classical
reversible gate acts as a permutation on the computational basis states. Figure 11 shows this
dramatically simpler lattice.

Some of the collapses in the lattice are immediate. For instance, the class hNOT⊗ NOTi
collapses with the class hNOTi because NOT|+i = |+i. A similar collapse occurs been all classes
where the parity issue arises such as between the classes hCNOTNOTi and hCNOTi.

39

A more interesting collapse occurs between all mod-k-preserving classes for k ≥ 2. Consider

the following gate G : {0, 1}k → {0, 1}k of order 2 which preserves Hamming weight mod k:

G(0k) = 1k
G(1k) = 0k

G(1a0b0) = 1a−10b+11
G(1a0b1) = 1a+10b−10

where G acts as the identity on all other inputs. Since G preserves the Hamming weight mod k, it
must appear in the class. We will show that G can generate a NOT gate. Let

so, for example

|ψki :=

1
√k

k−1

Xi=0(cid:12)(cid:12)(cid:12)
1i0k−i−1E

|ψ4i = |000i + |100i + |110i + |111i

2

.

Now, for b ∈ {0, 1}, G(|ψki|bi) = |ψki|b ⊕ 1i. Therefore, each mod-k-preserving class for k ≥
2 collapses to the hFredkin, NOTi class. Furthermore, Figure 10 shows that the Fredkin and
NOT gates are suﬃcient to generate a CNOT. Therefore, every non-conservative non-aﬃne class
generates all classical reversible transformations.

|ci
|xi
|+i

•
•
×
×
× NOT ×

Figure 10: Generating CNOT from Fredkin and NOT gates

We now only need to prove that the classes appearing in Figure 11 are distinct. Notice, however,
that the classes hCNOTi, hT4i, and hNOTi all have stabilizer generators, which by the results of
this paper, generate distinct classes. We only need to show then, that the hFredkini class is distinct
from the remaining classes. However, the invariant in [3] more or less functions to prove this
separation. Namely, Fredkin conserves the Hamming weight of its input. Therefore the sum of the
Hamming weights of the computational basis states of the input state is conserved. However, the
NOT gate necessarily changes this sum, witnessing that NOT /∈ hFredkini, and therefore that the
lattice is complete.

C Three-qubit generator for hT4 ,

Γ

, Pi

In this section, we point out a peculiar consequence of the classiﬁcation. Namely, that there exists
a class whose smallest generator is on 3 qubits. Contrasted with the aﬃne gate sets of Aaronson
et al. [3] which have minimal generators over 1, 2, 4, and 6 bits. The existence of such a class is an

40

⊤

CNOT

T4

Fredkin

NOT

⊥

Figure 11: The inclusion lattice of classical gates using quantum ancillas

immediate consequence of the enumeration in Appendix A. That is,

3

Yi=1
(2i − (−1)i) = 41472

#hT4,P, Γi3 = 23(3−1)/2+2(3)
#hΓ,Pi3 = 1233! = 10368
#hT4,Pi3 = 43212
Yi=1
(22i − 1) = 384
#hPi3 = 433! = 384

1

so the non-degenerate gates in hT4,P, Γi3 outnumber the degenerate gates (i.e. #hΓ,Pi3), con-
trasted with the class hT4,Pi, where this does not occur. Notice that there are 4 cosets of hΓ,Pi3
in hT4,P, Γi3 by Lagrange’s Theorem, corresponding to 4 gates that are nonequivalent up to ap-
plications of elements in hΓ,Pi3. If we let α = ( 0 1
1 1 ) ∈ R, then one such gate is described by the
following tableau
α I
I
I α I
I

0
0
I α 0

By Theorem 20 it is clear that this gate indeed generates all of hT4,P, Γi.





 .

41

D Canonical form for 2-qubit circuits

In this section, we describe a very clean canonical form for 2-qubit stabilizer circuits.

Theorem 25. Let C be any stabilizer circuit on two qubits. Then, C is equivalent to a circuit of
at most depth 3 composed of the following sequence of gates

1. a SWAP gate, and
2. a tensor product of single-qubit gates, and
3. a generalized CNOT gate,

where we can choose at each step whether or not to include the gate. That is, C is of the form of
the circuit depicted in Figure 12.

Proof. Since C is a stabilizer circuit, it can be written as a product of CNOT, θX+Z, and RZ
gates9. Recall that conjugating a generalized CNOT gate by a single-qubit gate is simply another
generalized CNOT gate. Therefore, we can push all the single-qubit gates left and all the generalized
CNOT gates right. All that remains to show is that we can coalesce the generalized CNOT gates
into a single CNOT gate. We refer to Table 5 for those equivalences, and note that identical
generalized CNOT gates cancel. Eventually, what remains is a circuit composed of single-qubit
gates, SWAP gates, and at most one generalized CNOT gate. We can push the SWAP gates to
the left (they collapse to either a single SWAP gate or the identity) and combine the single-qubit
gates, which completes the proof.

× G

× H

P

Q

Figure 12: Canonical form of a 2-qubit circuit: optional SWAP gate, optional C(P, Q) gate, and
single-qubit gates G and H

9Notice that we don’t need to include SWAP gates because of the equivalence SWAP(1, 2) = CNOT(1, 2) ◦

CNOT(2, 1) ◦ CNOT(1, 2).

42

P

R

P

P

P

P

P

Q

P

Q

P

Q

Q

R

Q

Q

Q

R

Q

P

=

=

=

=

=

RP

P

RQ

P

P

P

P

P

Q

×

Γ

× Γ†
× θP +Q

× θP +Q
× RQ

× R†Q
× P

× Q

Table 5: Rules for coalescing generalized CNOT gates, assuming ΓP Γ† = Q and ΓQΓ† = R

43

