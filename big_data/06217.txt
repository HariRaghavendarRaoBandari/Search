6
1
0
2

 
r
a

 

M
0
2

 
 
]

O
R
.
s
c
[
 
 

1
v
7
1
2
6
0

.

3
0
6
1
:
v
i
X
r
a

An Approximation Approach for Solving the

Subpath Planning Problem

Masoud Saﬁlian1, S. Mehdi Tashakkori Hashemi1, Sepehr Eghbali2, Aliakbar

Saﬁlian3

1 Amirkabir University of Technology, Iran

ma.saﬁlian@gmail.com, hashemi@aut.ac.ir

2 University of Waterloo, Canada

sepehr.eghbali@uwaterloo.ca

3 McMaster University, Canada

saﬁliaa@mcmaster.ca

Abstract

The subpath planning problem is a branch of the path planning problem,
which has widespread applications in automated manufacturing process as well
as vehicle and robot navigation. This problem is to ﬁnd the shortest path or
tour subject for travelling a set of given subpaths. The current approaches
for dealing with the subpath planning problem are all based on meta-heuristic
approaches. It is well-known that meta-heuristic based approaches have several
deﬁciencies. To address them, we propose a novel approximation algorithm
in the O(n3) time complexity class, which guarantees to solve any subpath
planning problem instance with the ﬁxed ratio bound of 2. Beside the formal
proofs of the claims, our empirical evaluation shows that our approximation
method acts much better than a state-of-the-art method, both in result and
execution time.

Note to Practitioners—In some real world applications such as robot and
vehicle navigation in structured and industrial environments as well as some
of the manufacturing processes such as electronic printing and polishing, it is
required for the agent to travel a set of predeﬁned paths. Automating this pro-
cess includes three steps: 1) capturing the environment of the actual problem
and formulating it as a subpath planning problem; 2) solving subpath planning
problem to ﬁnd the near optimal path or tour; 3) command the robot to fol-
low the output. The most challenging phase is the second one that this paper
tries to tackle it. To design an eﬀective automation for the aforementioned
applications, it is essential to make use of methods with low computational
cost but near optimal outputs in the second phase. According to the fact that
the length of the ﬁnal output has a direct eﬀect on the cost of performing
the task, it is desirable to incorporate methods with low complexity that can
guarantee a bound for the diﬀerence between length of the optimal path and

1

the output. Current approaches for solving subpath planning problem are all
meta-heuristic based. These methods do not provide such a bound. And plus,
they are usually very time consuming. They may ﬁnd promising results for
some instances of problems, but there is no guarantee that they always exhibit
such a good behaviour.
In this paper, in order to avoid the issues of meta-
heuristics methods, we present an approximation algorithm, which provides an
appropriate bound for the optimality of its solution. To gauge the performance
of proposed methods, we conducted a set of experiments the results of which
show that our proposed method ﬁnds shorter paths in less time in comparison
with a state-of-the-art method.

1

Introduction

Path planning is a challenging problem in artiﬁcial intelligence and robotics [30] with
applications also in other areas such as computer animation and computer games
[14], therapeutic [5] protein folding [35], manufacturing process [34] and computa-
tional biology [36]. Due to various applications, diﬀerent types of this problem have
been proposed including the subpath planning problem (SPP). SPP has widespread
applications such as navigation of robots and vehicles as well as automated manufac-
turing process [16, 37]. The goal of SPP is to ﬁnd the shortest tour, which travels all
given subpaths. SPP is an NP-hard problem [13, 19]. As an example, Fig. 1.a shows
a workspace and Fig. 1.b represents its corresponding optimal result. Also, Fig 1.a
represents the corresponding graph constructed based on the workspace.

There have been proposed a few approaches for solving SPP, all of which are
meta-heuristic based. Recently, Ying et al. [37] and Gyorﬁ et al. [16] proposed some
algorithms based on Genetic Algorithm (GA) [15] for solving SPP in polishing robots
and electronic printing, respectively.

Like other meta-heuristic methods [4], GA cannot guarantee any bound on its
ﬁnal result. It may produce some promising results on some given instances, while it
has a tendency to converge to local optima for some other instances. In addition, GA
needs considerable amount of time in order to return a result. This problem becomes
more severe as the number of subpaths grows.

The current paper aims at overcoming the problems of meta-heuristic methods in
solving SPP by proposing an approximation algorithm [3] with a ﬁxed ratio bound
and eﬃcient polynomial complexity. Our method includes three stages described as
follows.

The ﬁrst stage is transforming SPP to Travelling Salesman Problem (TSP) [18]
with an O(n2) time complexity algorithm. TSP is a well-known combinatorial opti-
mization problem. Since TSP is an NP-hard problem [19], proposing a precise algo-
rithm for solving TSP does not make sense. Thus, several attempts have been done
to propose approximation algorithms for solving this problem. In the recent decades,

2

various approximation methods have been proposed for solving this problem.

Once an SPP instance is transformed to a suitable TSP one, it may seem easy
to apply the existing ﬁxed-ratio bound approximation algorithms for TSP for solving
SPP. However, this is not the case and there are some crucial challenging issues
in this way. Christoﬁdes in [6] argues that there is no polynomial approximation
algorithm with a ﬁxed ratio bound for general TSP. Literally, we cannot propose any
ﬁxed ratio bound approximation algorithm on a general graph, in which the triangle
inequality does not hold in all triangles [6] (this observation is also due to Sahni and
Gonzale [33]). However, there are some ﬁxed-ratio bound approximation algorithms
such as Christoﬁdes’ algorithm [6], for solving TSP over constrained graphs, which
satisfy triangle inequality. Here is the point where we face a crucial problem: the
output graph of transforming of SPP to TSP for a given instance deﬁnitely violates
the triangle inequality condition, as shown in Section 3. Thus, it is not feasible to
apply existing ﬁxed-ratio bound TSP approximation algorithms for solving SPP. We
address this shortcoming in a two next stages.

In the second stage, we propose an algorithm, called Imperfectly Establish the Tri-
angle Inequality (IETI), which establishes the triangle inequality in a main subset of
violating triangles 1. The output of the ﬁrst stage, i.e., transforming SPP to TSP, is
considered as the input graph of the IETI algorithm. The algorithm outputs a new
graph by changing the edges’ weight of the input such that the triangle inequality con-
dition holds on all triangles except for some special triangles (those that one and only
one of their edges does have the inﬁnity weight). Let G(cid:48) be the result of transforming
an SPP instance graph G and G(cid:48)(cid:48) be the output graph of the IETI algorithm for G(cid:48).
We formally show that solving SPP on G would be equivalent to solving TSP on G(cid:48)(cid:48).
The IETI algorithm is in O(n2) complexity class and should be seen as a fundamental
step for introducing and applying a ﬁxed-ratio bound approximation algorithm for
solving SPP. This is because, as discussed already, the main requirement of applying
such an algorithm for solving SPP is holding triangle inequality in the given graph.
Nonetheless, some special triangles still violate the triangle inequality in the out-
put graph of the IETI algorithm. To tackle this problem, in the third stage, we
propose an approximation algorithm with the ﬁxed-ratio bound of 2 and O(n3) com-
plexity, called Christoﬁdes for SPP (CSPP) . Indeed, the CSPP algorithm is a mod-
iﬁed version of the Christoﬁdes’ algorithm [6] to make it able to work for all outputs
of the IETI algorithm. The Christoﬁdes’ algorithm is a polynomial approximation
algorithm with ﬁxed-ratio bound of 1.5 2 for solving TSP instances in which edge

1As it may be clear, a violating triangle is a triangle which violates the triangle inequality

condition.

2The ﬁxed ratio bound of 1.5 is the minimum among the existing methods proposed for solving

TSP.

3

(a)

(b)

Figure 1: (a) The workspace related to a subpath planning problem where dashed
curves represent the subpaths. (b) The optimal solution of the corresponding SPP.

weights are metric 3. Thus, any input graphs of this algorithm must satisfy the tri-
angle inequality condition. Therefore, it is not feasible to apply Christoﬁdes to our
problem. In other words, the CSPP algorithm aims at solving TSP for given graphs
in which the triangle inequality holds in all triangles except for those that one of their
edges has the inﬁnity weight.

In addition to complexity analysis and proving the ratio bound of CSPP, it is
[16] over various
empirically compared with the method proposed by Gyorﬁ et al.
workspaces with diﬀerent number of subpaths. The results illustrate that CSPP is
more eﬃcient than the state-of-the-art method in terms of both result and running
time.

The rest of the paper is organized as follows. Section 2 discusses the related
work. Section 3, presents transformation of SPP to TSP. We discusses the IETI
algorithm in Section 4. In Section 5, we propose the CSPP algorithm and describe
its characteristics and the related theorems. The experimental comparison of CSPP
and the method proposed by Gyorﬁ et al. [16] is presented in Section 6. Finally, the
conclusions and future work are discussed in Section 7.

2 Related Work

There exist some graph problems, which are relevant to SPP. This set of problems
includes Travelling Salesman Problem with Neighbours (TSPN) and those that are in
the context of Arc Routing Problems (ARP) [9, 10]. Bellow, we discuss their similar-

3like other ﬁxed-ratio bound algorithms for solving the TSP

4

5124351243ities and diﬀerences with SPP.

Travelling Salesman Problem with Neighbours: Travelling Salesman Prob-
lem with Neighbours (TSPN) is introduced by Arking and Hassin [2]. It is a gener-
alization of TSP in which the constraint is to visit the neighbourhood of each node
instead of the node itself. In TSPN, each node is represented as a polygon instead
of a single point and an optimal solution is the shortest path such that it intersects
all polygons. Since TSPN is a generalization of TSP, it is also NP-hard [26, 28]. Be-
sides, Safra and Schwartz [32] showed that it is NP-hard to approximate within any
constant bound. For the general case of connected polygons, Mata and Mitchell [24]
proposed an O(log n) approximation bound with O(N 5) time complexity based on
”guillotine rectangular subdivisions”, where N is the total number of vertices of the
polygons. If all the polygons have the same diameter, then an O(1) algorithm also
exists [8]. Even if we represent each subpath with a polygon of two vertices, then SPP
is diﬀerent from TSPN. This is because an SPP solution requires to traverse all the
subpaths, while a solution for TSPN can only have intersections with each subpaths.

Rural Postman Problem: Consider a graph G(V, E), where V is the set of
vertices and E is the set of edges. In the Chinese Postman Problem (CPP), we are
interested in ﬁnding the shortest closed path such that it travels all the edges. An
optimal solution is an Eulerian tour, if exists any. Thus, whenever the degree of
each node is even, CPP can be reduced to ﬁnding an Eulerian tour. Note that it is
well-known that an Eulerian tour always exists in such a graph. If G is either purely
directed or purely undirected, CPP has a polynomial time solution. Otherwise (the
given graph is neither purely directed nor undirected), the problem would be NP-hard
[10].

Rural Postman Problem (RPP) is a variant of CPP. A CPP problem is called
RPP, if a subset of edges must be covered instead of covering all the edges. RPP
was ﬁrst introduced by Orloﬀ [27]. The undirected, directed and mixed versions of
RPP are all proven to be NP-hard [11, 22]. Frederickson [11] proposed a polynomial
time solution for RPP with the worst case ratio bound of 1.5 for given graphs, which
satisfy the triangle inequality condition. This solution is known as the best one for
RPP.

There are many similarities between RPP and SPP. Indeed, RPP is a generaliza-
tion of SPP. An SPP instance is an RPP instance in which the subpaths are the edges
that must be covered. As Fig. 2 shows, there are additional constraints in SPP. The
number of vertices is twice the number of edges that must be covered (subpaths).
Thus, the must-be-covered edges in an SPP instance cannot share a common vertex.
Besides, the graph is an undirected complete one. Although SPP and RPP have
many similarities, ﬁxed-ratio bounds algorithms for RPP cannot be applied for SPP.
This is because given graphs for SPP do not satisfy the triangle inequality condition.

5

Stacker Crane Problem: The Stacker Crane Problem (SCP) [12] is another
relevant problem in the context of routing. SCP is deﬁned on a graph consisting
of directed and undirected edges. The problem is to ﬁnd the shortest circuit, which
covers all the directed edges (which can be the deliveries that to be made by a vehicle).
SCP is also an NP-hard problem, since it is a generalization of TSP. Coja-Oghlan et
al. [7] proposed an approximation approach for a special case of SCP. In this solution,
given graphs must be trees. Even in such a restricted case, the problem is NP-hard.
Fredrickson et al.
[12] proposed a polynomial algorithm for this problem with the
ratio bound of 1.8 in the worst case. The Fredrickson’s solution for SCP is known to
be the best approximation algorithm [38]. The diﬀerence between SCP and SPP is
that, in SPP, subpaths, which must be covered, are indirected edges.

3 Transformation of SPP to TSP

In this section, we show how to transform SPP to TSP. Feasible solutions for an SPP
instance are the tours that travel all the subpaths. A tour with the minimum length
is a desired solution. Each feasible solution is a sequence of connected subpaths. In
a ﬁxed sequence with n subpaths, the ith (i < n) subpath can be connected to the
(i + 1)th subpath (the nth subpath is connected to the ﬁrst one) in two diﬀerent ways
(either to head or tail). Now, consider an SPP instance with n subpaths. Obviously,
the number of possible sequences of these n subpaths is n!. Thus, due to two diﬀerent
ways of connections between two consecutive subpaths, the total number of feasible
solutions would be n!2n.

TSP is one of the classical NP-hard problems of combinatorial optimization. In the
recent decades, various approximation [21] and combinatorial optimization methods
[18] have been proposed for solving this problem. Thus, transformation of SPP to
TSP facilitates applying such methods for solving SPP. The rest of the section is
organized as follows. The subsection 3.1 discusses the transformation procedure of
SPP to TSP and in the subsection 3.2, we discuss the complexity analysis of the
procedure on its corresponding pseudo code.

3.1 TSP model of SPP: Transformation Procedure
Consider an SPP instance with n subpaths indexed with the set I = {1, ..., n}. The
procedure includes two stages. In the ﬁrst stage, a complete graph G is built, accord-
ing to the following stages.

Stage 1:

6

(a)

(b)

Figure 2: (a) graph G represents the workspace. In this graph, thick edges indicate
subpaths and thin edges indicate the connections between the subpaths. The weight
of connecting edges are equal to their corresponding Euclidean distances between
subpaths in the workspace. (b) The graph G(cid:48) is built by adding middle nodes to G.
Inﬁnity weight edges are not shown here.

1. For each subpath, say ith (i ∈ I), consider two nodes si and ei corresponding to

its starting and end points, respectively.

2. For each i ∈ I, consider an edge between si and ei with the weight equal to
the length of ith subpath in the workspace. Let us call this edge the ith subpath
edge.

3. For each pair of two distinct subpaths i and j (i (cid:54)= j), we add edges siej, eisj,
sisj and eiej to the graph. We also consider the weights of these newly added
edges equal to the corresponding Euclidean distances in the workspace. Let us
call these edges the connecting edges.

Fig. 2.a depicts the graph G generated according to Stage 1 for the given workspace
in Fig. 1.a.

The TSP tour of G (the graph generated in the above procedure) is not necessarily
equivalent to the solution of the given SPP instance. This is because the solution of
SPP is a tour traveling all the subpaths, while the TSP tour of G may not cover all
the subpath edges (such as siei). To make sure that the TSP tour travels all the
subpaths, a complete graph G(cid:48) is generated based on G as follows:

Stage 2:

1. For each subpath, say ith subpath, a node mi is added to the graph, called the

middle node of ith subpath.

7

s2e2s1e1s3e3s4e4s2e2s1e1s3e3s2e2s1e1s3e3s4e4m2m1m3m4s4e4s2e2s1e1s3e3m2m1m3m42. For each subpath, say ith, two edges simi and miei are added to the graph, the
weights of which are equal to the half of the subpath length. These edges are
called ith double subpath edges.

3. For each middle node mi, the edge miv, where v /∈ {si, ei}, is added to the

graph with the inﬁnity weight.

Fig. 2.b depicts the graph G(cid:48) generated according to Stage 2 for the given graph G
in Fig. 2.a.

Theorem 1 The result of solving SPP on a given instance is equivalent to ﬁnding
the TSP tour in G(cid:48) generated according to the above procedures (Stage 1 + Stage 2)
(cid:4)
on the instance.

Proof: According to Fig. 2.b, there is a ﬁnite Hamiltonian tour in G(cid:48). [s1-m1-e1-s2-
m2-e2-s3 . . . sn,mn-en] is a sample of ﬁnite hamiltonian tours in G(cid:48) with n subpaths.
The TSP tour over G(cid:48) is a Hamiltonian tour with the minimum weight. Therefore,
The TSP tour over G(cid:48) is ﬁnite. The TSP tour of G(cid:48) must visits all the middle nodes,
since, for each i, it contains two edges crossing the node mi. There are only two ﬁnite
edges si-mi and mi-ei connecting to mi. Hence, the TSP tour over G(cid:48) must contain
ith double subpath edges for each i. Since simi and miei together are equivalent to
ith subpath in the workspace, the TSP tour of G(cid:48) is a minimum tour, which travels
(cid:3)
all subpaths. Hence, solving SPP is equivalent to ﬁnding the TSP tour in G(cid:48).
Throughout the rest of the paper, we use the notation G(cid:48) to denote the graph

generated in the above procedure for a given SPP instance.

3.2 Pseudo Code and Complexity Analysis of Transforming

Algorithm 1 presents a pseudo code for the SPP to TSP transformation procedure.
The algorithm takes a workspace as input and returns a graph G(cid:48) as output.
It
includes the following two phases:

1) Generating a graph G, according to Stage 1 (Line 1)
2) Generating a graph G(cid:48) by adding middle nodes to G, according to Stage 2

(Lines 2 to 9)

Time complexity of generating the graph G is in O(n2), where n is the number
of subpaths. Lines 2 to 9 add middle nodes to the graph within a loop of n itera-
tions. In each iteration, there is another loop (lines 6-8), which requires O(n) running
time. Therefore, adding middle nodes requires O(n2) running time. Thus, the total
complexity of the algorithm is O(n2).

8

Algorithm 1 : SPP to TSP

1: Construct G with the adjacency matrix w
2: for i = 1 to n do
3:
4:

add middle node mi
w(mi, si) ← w(ei,si)
w(mi, ei) ← w(ei,si)
for each node d ∈ G where d /∈ {si, ei} do
w(mi, d) ← ∞

2

2

5:
6:
7:
8:
9: end for

end for

4

Imperfectly Establish the Triangle Inequality

As discussed already, using any existing approximation method for TSP requires
triangle inequality to be hold over given graphs. Two kinds of triangles in G(cid:48) (Fig.
2.b) may violate triangle inequality:
of (cid:52)sieiv 4, where v (cid:54)= mi.
edges is either simj or eimj (i (cid:54)= j).

V-2) Triangles with one and only one inﬁnity edge. In such a triangle, one of its

V-1) Triangles with a subpath edge as one of their edges, i.e, triangles in the form

Other triangles in G(cid:48) that are not in one of the above kinds do not violate the
triangle inequality condition. Such triangles can be grouped into the following kinds:

Euclidean distances.

1) Triangles that have more than one inﬁnity edge.
2) Triangles in which all of the edges’ weights are equal to their corresponding
3) Triangles that are of the form (cid:52)simiei.
As mentioned in the introduction, we tackle the triangle inequality violation in G(cid:48)
in two stages. The ﬁrst stage is proposing an algorithm, called Imperfectly Establish
the Triangle Inequality (IETI). We discuss how the algorithm works in the subsection
4.1. The subsection 4.2 discusses the complexity analysis of the procedure on its
corresponding pseudo code.

IETI: The Procedure

4.1
The IETI algorithm is given the output of the transformation procedure (G(cid:48)) and
deals with the ﬁrst category of violating triangles, i.e., V-1. Indeed, this algorithm
makes some modiﬁcations to the edges’ weight of G(cid:48) to make a graph, denoted by
G(cid:48)(cid:48), such that TSP tours in G(cid:48) and G(cid:48)(cid:48) are the same (see Theorem 3) and there is no
violating triangles of kind V-1 in G(cid:48)(cid:48) (see Theorem 2).

4(cid:52)abc denotes the triangle with a, b, and c as its vertices.

9

The IETI algorithm is an iterative method. Indeed, it iterates over all subpaths,
for each of which it updates the weight of edges in a same way. Indeed, each iteration
corresponds to a subpath. Below, we describe how it works.

For each iteration, say ith (corresponding to the ith subpath), we deﬁne a variable
called ith degree of violation, denoted by dvi. We apply this variable to formally
recognize what triangles in V-1 violate the triangle inequality condition. We also use
it to resolve such violations. The equation (1) shows how to compute dvi.

Remark 1 For a given graph H, the notations V (H) and w(a, b) denote the set of
vertices and the weight of the edge ab, respectively.

∀ d ∈ V (G(cid:48)) − {si, ei}
dvi = 0.5(min∀d

(w(si, d) + w(ei, d)) − w(si, ei))

(1)

dvi < 0 implies that at least one of the triangles in which one of their edges is
eisi violates the triangle inequality condition. Otherwise, i.e., dvi ≥ 0, none of such
triangles violates the condition. In the former case, the weight of edges are updated
by the following equations:

w(si, ei) ← w(si, ei) − |dvi|
w(si, mi) ← w(si, mi) − | dvi
2
w(ei, mi) ← w(ei, mi) − | dvi
2
∀q ∈ V (G(cid:48)) − {si, ei, mi}
|dvi|
w(q, ei) ← w(q, ei) +
2
|dvi|
w(q, si) ← w(q, si) +
2

|
|

(2)

(3)

Note that, in equation 3, the added weights to the edges, which are connected to
the subpaths, are equal and symmetric, i.e., the weights of edges connected to si and
ei are increased equally. This property makes the TSP tour over G(cid:48) to be equivalent
to one over G(cid:48)(cid:48) (proven in Theorem 3).

These changes make the triangles containing the ith subpath to satisfy the triangle
inequality. Note that it does not make other triangles, which already satisfy the
triangle inequality, to violate the condition. This claim is proven in Theorem 2.

Theorem 2 shows that IETI establishes the triangle inequality in all V-1 trian-
gles in G(cid:48)(cid:48) such that other triangles except for those in V-2 still satisfy the triangle
inequality. Throughout the rest of the paper, we use the notation G(cid:48)(cid:48) to denote the
graph generated in the above procedure (IETI) for G(cid:48).

10

Theorem 2 After the execution of IETI, all the triangles in G(cid:48)(cid:48) satisfy the triangle
(cid:4)
inequality except for those in V-2.

Proof: Let n be the number of subpaths of the original workspace. Consider the
ith step of IETI. If dvi < 0 (computed in the equation 1), then, according to the
equations (2) and (3), the weights of the corresponding edges change. Let G(cid:48)(cid:48)
i denote
the result graph after the execution of the ith step of IETI on G(cid:48). It is also natural
to consider G(cid:48)(cid:48)

n equal to G(cid:48) and G(cid:48)(cid:48), respectively.
Now, we are going to prove the following statement:

0 and G(cid:48)(cid:48)

Statement: A violating triangles in G(cid:48)(cid:48)
i is either in:
g-1) V-2 or
g-2) V-1 such that it is a triangle (cid:52)sjejv with j > i.

We use an inductive reasoning to prove the above statement, as follows.
(base case): It follows obviously that the above statement holds in G(cid:48)(cid:48)
0 (which is
equal to G(cid:48)).
(hypothesis): Assume that, for some t with 1 ≤ t < i, the statement holds for
0, ..., G(cid:48)(cid:48)
G(cid:48)(cid:48)
t . This is
shown in the inductive step.
(inductive step): There exists the two following possible cases for G(cid:48)(cid:48)

t−1, now it suﬃces to show that the statement also holds for G(cid:48)(cid:48)

t−1. We show

in each case the G(cid:48)(cid:48)

t satisﬁes the statement.

1. “In G(cid:48)(cid:48)

t−1, the triangles with the edge stet do not violate the triangle inequality

condition.”
Thus, for any j ≤ t, the triangles in G(cid:48)(cid:48)
t−1 with an edge sjej do not violate the
In this case, during the tth step, no modiﬁcation will be
triangle inequality.
t−1. Thus, for any j ≤ t,
made to the graph G(cid:48)(cid:48)
t−1 and G(cid:48)(cid:48)
the triangles in G(cid:48)(cid:48)
t with an edge sjej do not violate the triangle inequality.
Hence the statement holds for G(cid:48)(cid:48)
t .

t would be equal to G(cid:48)(cid:48)

2. “There are some triangles in G(cid:48)(cid:48)

t−1 with an edge stet, which violates the triangle

inequality.”
Consider a violating triangle in G(cid:48)(cid:48)
t−1 with an edge stet. Let us see what would
happen in the tth step. According to the equation (2), the weight of the edge
stet must decrease by |dvt|. Moreover, for any q, the weights of the edges stq
|dvt|
and qet increase by
2
t , say (cid:52)abc, can fall into one of the seven following categories.
Each triangle in G(cid:48)(cid:48)
In
The validity of triangle inequality in all categories will be investigated.
other words, the validity of the inequalities wt(a, c) + wt(b, c) ≥ wt(a, b) and

(equation 3).

11

wt(a, b)+wt(b, c) ≥ wt(a, c), where wt is the adjacency matrix of G(cid:48)(cid:48)
denotes the weight of the edge ab in G(cid:48)(cid:48)

5.

t

t and wt(a, b)

(a) “The triangle edge ab is equal to stet.”

In this case, the weight of the edge ab decreases by |dvt| and the weights of
|dvt|
2 . The equations (5) and (9) show that
the edges ac and bc increases by
the triangles in this category satisfy the triangle inequality after modiﬁca-
tions:

wt(a, c) + wt(b, c)
= wt(st, c) + wt(et, c)
|dvt|
2

|dvt|
= wt−1(st, c) +
2
= wt−1(st, c) + wt−1(et, c) + 2|dvt| − |dvt|

+ wt−1(et, c) +

(4)

By replacing 2|dvt| with wt−1(st, et) − min∀d[wt−1(st, d) + wt−1(et, d)], we
would have:

wt(a, c) + wt(b, c)
= wt−1(st, c) + wt−1(et, c) + wt−1(st, et)
− min∀d
[wt−1(st, d) + wt−1(et, d)] − |dvt|
≥ wt−1(st, et) − |dvt| = wt(st, et) = wt(a, b)

wt(a, b) + wt(b, c)
= wt(st, et) + wt(et, c)
= wt−1(st, et) − |dvt| + wt−1(et, c) +

|dvt|
2

(5)

(6)

By replacing |dvt| with 1

2(wt−1(st, et)− min∀d[wt−1(st, d) + wt−1(et, d))], we
5Validity investigation of wt(a, b) + wt(a, c) ≥ wt(b, c) is similar to of wt(a, b) + wt(b, c) ≥ wt(a, c).

So, there is no need to investigate the validity of the former inequality in the proof.

12

would have:

wt(a, b) + wt(b, c) = wt−1(st, et) + wt−1(et, c)

− wt−1(st, et) − min∀d[st−1(st, d) + st−1(et, d)]
|dvt|
2
wt−1(st, et)

+

2

(7)

=

+

2

min∀d[wt−1(st, d) + wt−1(et, d)]

+ wt−1(et, c) +

2
|dvt|
2

The weight of the edge stet has not changed before the tth step. Thus,
In other words, it is equal to the length of tth
wt−1(st, et) = w0(st, et).
subpath. Hence, wt−1(st, et) > ed(st, et), where ed(st, et) is the Euclidean
distance between st and et in the workspace.
Also, any node such as d satisﬁes the inequality wt−1(st, d) + wt−1(et, d) ≥
ed(st, d)+ed(et, d) > ed(st, et).6 As a consequence, the inequality min∀d[wt−1(st, d)+
wt−1(et, d)] > ed(st, et) holds, which results in:

wt(a, b) + wt(b, c)
≥ ed(st, et) + wt−1(et, c) +

|dvt|
2

(8)

2 and ed(c, et) + α

If the weights of subpaths, which pass through the node c change before
the tth step, then the values of wt−1(st, c) and wt−1(et, c) would be equal
to ed(st, c) + α
2 , respectively, where α is equal to the pa-
rameter dv (degree of violation) of the subpath, which passes through the
node c.
Otherwise (if the value of such subpaths are not updated), the values
of wt−1(st, c) and wt−1(et, c) would be ed(st, c) and ed(c, et), respectively.
Hence, the inequality ed(st, et)+wt−1(c, et) > wt−1(st, c) turns to ed(st, et)+
ed(c, et) > ed(st, c) that always holds. Consequently, the following inequal-

6The weights of edges std and etd either have not changed before tth step or are modiﬁed by
equation (3). Therefore, wt−1(st, d) ≥ w0(st, d) ≥ ed(st, d) and wt−1(et, d) ≥ w0(st, d) ≥ ed(et, d).

13

ity holds:

wt(a, b) + wt(b, c)
≥ wt−1(st, c) +
≥ wt(st, c)
≥ wt(a, c)

|dvt|
2

(9)

t−1 satisﬁes the triangle inequality. Two following

(b) “The edge ab is sjej (i.e., a = sj and b = ej), where j < t”.

In this case, (cid:52)abc in G(cid:48)(cid:48)
scenarios are possible during the step tth:
1) The edges’ weight of (cid:52)abc do not change in tth step.
obviously, (cid:52)abc still satisﬁes the triangle inequality in tth step.
2) The weights of the edges ac and bc increase by
scenario happens when c is either st or et).
equations show that (cid:52)abc still satisﬁes the triangle inequality:

|dvt|
2

In this case,

(Note that this
In this case, the following

wt(a, c) + wt(b, c)
= wt(sj, c) + wt(ej, c)
|dvt|
2
|dvt|
2

= wt−1(sj, c) +

+ wt−1(ej, c) +
≥ wt−1(sj, c) + wt−1(ej, c)
≥ wt−1(sj, ej) = wt(sj, ej) = wt(a, b)

and

wt(a, b) + wt(b, c) = wt(sj, ej) + wt(ej, c)

= wt−1(sj, ej) + wt−1(ej, c)

|dvt|
2

+
≥ wt−1(sj, c) +
= wt(sj, c)
= wt(a, c)

|dvt|
2

(10)

(11)

(c) “The edge ab is sjej, where j > t”.

In this case, the triangle (cid:52)abc may violate the triangle inequality in the
graph G(cid:48)(cid:48)

t−1. Hence, it may violate the triangle inequality in G(cid:48)(cid:48)

t too.

14

(d) “(cid:52)abc does not have any edge in the form of sjej for some j (i.e., it does
not have any subpath edge), and the weights of the edges ac and bc change
during the tth step”. 7
In this case, the triangle (cid:52)abc satisﬁes the triangle inequality condition
in the graph G(cid:48)(cid:48)
t−1 . During the tth step, the weights of the edges ac and
bc increase by dvt
2 . The following equations show that this triangle still
satisﬁes the triangle inequality in G(cid:48)(cid:48)
t :

dvt
wt(a, c) + wt(b, c) = wt−1(a, c) +
2
|dvt|
2

wt−1(b, c) +
≥ wt−1(a, c) + wt−1(b, c)
≥ wt−1(a, b) = wt(a, b)

wt(a, b) + wt(b, c) = wt−1(a, b) + wt−1(b, c)

|dvt|
2
|dvt|
2

+

+

≥ wt−1(a, c)

= wt(a, c)

(12)

(13)

(e) “(cid:52)abc does not have any edge in the form of sjej for some j (i.e., it does
not have any subpath edge) and the weight of no edge of the triangle
change during the tth step”.
Since (cid:52)abc satisﬁes the triangle inequality condition in G(cid:48)(cid:48)
ﬁes the inequality in G(cid:48)(cid:48)
t .

t−1, it also satis-

(f) “(cid:52)abc has one edge with the inﬁnity weight”.

The triangle violates the triangle inequality condition in both G(cid:48)(cid:48)
G(cid:48)(cid:48)
t .

t−1 and

(g) “(cid:52)abc has two or three edges with the inﬁnity weight”.

It follows obviously that (cid:52)abc satisﬁes the triangle inequality condition in
both G(cid:48)(cid:48)

t−1 and G(cid:48)(cid:48)

t

Thus, after the execution of the tth step, only the triangles with one inﬁnity weight
edge (category f) or with edges in the form of sjej for some j greater than t (category
c) may violate the triangle inequality in G(cid:48)(cid:48)

t . Therefore, the statement holds in G(cid:48)(cid:48)
t .

The statement was proven, which means that it holds in G(cid:48)(cid:48)

n = G(cid:48)(cid:48).

7Note that during each step of IETI for each triangle either no weight is updated (category e) or

two weights are updated (category d).

15

Figure 3: Example of Hamiltonian tour over G(cid:48) and G(cid:48)(cid:48). The pair of edges are shown
by dashed arrows and other arrows represent the connecting edges between the pair
of edges.

As a result, the triangle inequality condition is satisﬁed by every triangle in the
graph G(cid:48)(cid:48) (the output graph of IETI) except for those with an inﬁnity edge. These
triangles are either in the form of (cid:52)simid or (cid:52)eimid, where the edge mid is an inﬁnite
(cid:3)
edge. The theorem is proven.
The following theorem shows that the TSP tours in a given graph of IETI, i.e.,
G(cid:48) (the result of SPP to TSP transformation for a given SPP workspace) and the
output graph of IETI, i.e., G(cid:48)(cid:48), are the same. This implies that the TSP tour in G(cid:48)(cid:48)
is equivalent to the SPP solution of the given workspace.
Theorem 3 The TSP tours in G(cid:48) and G(cid:48)(cid:48) are the same.

(cid:4)

Proof: To prove this theorem, we show that the TSP tours of G(cid:48) and G(cid:48)(cid:48) are the
same in terms of length and sequence of nodes. In other words, we show that the
length of each ﬁnite Hamiltonian tour of G(cid:48) is equal to the length of its corresponding
ﬁnite Hamiltonian tour of G(cid:48)(cid:48) (A Hamilton tour over G(cid:48) and another one over G(cid:48)(cid:48)
corresponds to each other, if they have the same sequence of nodes).

As already stated, any ﬁnite Hamiltonian tours in both G(cid:48) and G(cid:48)(cid:48) include all
edges is the form of simi and miei (for any possible index i). Note that in such a
tour, for any i, miei and simi happen consecutively and are connected through mi (as
a sequence in the form of either si-mi-ei or ei-mi-si). Let us call these two consecutive
edges ”pair of edges of ith subpath”. As a result, each ﬁnite Hamiltonian tour in either
G(cid:48) or G(cid:48)(cid:48) is a sequence of pairs of edges connected via some edges. Fig. 3 presents an
example of Hamiltonian tour over G(cid:48) and G(cid:48)(cid:48).

Note that the graph G(cid:48) diﬀers from the graph G(cid:48)(cid:48) in their weights of the edges. Let
H be a ﬁnite Hamiltonian tour over G(cid:48) and H(cid:48) be its corresponding ﬁnite Hamiltonian
tour over G(cid:48)(cid:48) (suppose that the number of subpaths is n). Without loss of generality,

16

s2e2s1e1s3e3s4e4m2m1m3m4e1-m1, m1-s1, s1-e2, e2-m2, m2-s2, s2-s4, s4-m4, m4-e4, e4-s3, s3-m3, m3-e3, e3-e1 s4e4s2e2s1e1s3e3m2m1m3m4we let the pairs of edges occur in H (also in H(cid:48)) according the usual order of their
indices, i.e., for any index i less than n, the (i + 1)th pair happens exactly after the
ith pair of edges. Suppose that the corresponding node p in G(cid:48) is p(cid:48) in G(cid:48)(cid:48).

H : e1m1, m1s1, s1e2, ..., si−1ei, eimi, misi, siei+1, ...,

en−1sn, snmn, mnen

and

i, s(cid:48)
is(cid:48)
i, m(cid:48)
ie(cid:48)
i+1, ...,

H(cid:48) : e(cid:48)

1m(cid:48)

1e(cid:48)
1, s(cid:48)
1s(cid:48)
1, m(cid:48)
2, ..., s(cid:48)
n, s(cid:48)
n−1s(cid:48)
e(cid:48)

i−1e(cid:48)
nm(cid:48)

im(cid:48)
i, e(cid:48)
ne(cid:48)
n, m(cid:48)

n

During the ith of the IETI procedure over G(cid:48), only the weights of the edges in H,
which are in the form of eimi, misi, siei, eisi−1, and siei+1, may change and others
are left without any changes. Thus, the following equations hold:
i) + |dvi|

w(eimi) + w(mi, si) = w(e(cid:48)

i, m(cid:48)

(14)

i) + w(m(cid:48)
i, s(cid:48)
i) − |dvi|
w(si−1, ei) = w(s(cid:48)
w(si, ei+1) = w(si, ei+1) − |dvi|

i−1, e(cid:48)

2

2

(15)

The above equations show that changes made in weights in each step of IETI do
not make the length of the corresponding tours H and H(cid:48) unequal. Therefore, the
length of each ﬁnite Hamilton tour in G(cid:48) is equal to its corresponding tour in G(cid:48)(cid:48). (cid:3)

4.2 Pseudo Code and Complexity Analysis of IETI

Algorithm 2 presents the pseudo code of the IETI algorithm. This algorithm takes a
graph G(cid:48) (the output of the SPP to TSP transformation) and returns a graph G(cid:48)(cid:48).

The loop of n iterations in lines 1 to 13 updates the weights of the subpath edges.
There exist two loops within these lines each of which iterates 2n times (lines 2 and
8 to 11). Thus, the time complexity of the algorithm is in the O(n2) class.

5 A 2-approximation Algorithm

The Christoﬁdes’ algorithm [6] is one the most eﬃcient approximation algorithms for
solving TSP, which works for given graphs satisfying the triangle inequality condition.
This algorithm has time complexity of O(n3) and the ratio bound of 1.5. Due to its
complexity and ratio bound, the Christoﬁdes’ algorithm is a popular approximation
method for TSP.

17

Algorithm 2 : TSP Transformation and IETI
1: for each subpath edge siei do
2:

Find node d ∈ G that minimizes R = w(si, d) + w(d, ei)
dv ← R−w(si,ei)
if dv < 0 then

2

w(si, ei) ← w(si, ei) − |dv|
w(si, mi) ← w(si,ei)
w(ei, mi) ← w(si,ei)
for each node q ∈ G where q /∈ {si, ei, mi} do

2

2

3:
4:
5:

6:

7:
8:

9:

w(si, q) ← w(si, q) − |dv|
w(ei, q) ← w(ei, q) − |dv|

2

2

end for

10:
11:
end if
12:
13: end for

According to Theorem 3, the TSP tour in G(cid:48)(cid:48) is equivalent to the solution of SPP.
However, G(cid:48)(cid:48) violates the triangle inequality condition. Therefore, it is not feasible
to use Christoﬁdes’ algorithm (or any other existing ﬁxed-ratio bound approximation
algorithms) to ﬁnd the TSP tour in G(cid:48)(cid:48). Nonetheless, the triangle inequality is violated
by some special triangles in G(cid:48)(cid:48). By using this special feature, an approximation
algorithm for ﬁnding the TSP tour over G(cid:48)(cid:48), called Christoﬁdes for SPP (CSPP), is
proposed with O(n3) time complexity and ratio bound of 2. CSPP can be seen as a
modiﬁed version of Christoﬁdes’ algorithm.

The CSPP algorithm contains one additional step in comparison with the Christoﬁdes’

algorithm. Moreover, one step of Christoﬁdes is modiﬁed in CSPP.

The plan of this section is as follows. In 5.1, we discuss the CSPP algorithm. In
5.2, we show that the ratio bound of the CSPP algorithm is 2. We ﬁnally discuss the
time complexity of the algorithm in 5.3.

5.1 CSPP: the procedure
CSPP takes G(cid:48)(cid:48) (the output of the IETI algorithm) as input and returns a Hamiltonian
tour as output. This algorithm consists of ﬁve steps as follows:

Step 1: Finding the Minimum Spanning Tree

This step ﬁnds the minimum spanning tree (MST) over G(cid:48)(cid:48) (one of the nodes is
arbitrarily chosen as the root of the tree). This step is the same as the ﬁrst step of
the Christoﬁdes’ algorithm [6].

Step 2: Modify MST by Adding Subpath Edges

The MST (the result of the ﬁrst step) does not include an edge with inﬁnity weight.
As a consequence, a middle node of the graph G(cid:48)(cid:48), say mi for some i, can be either

18

Figure 4: Step 2 of CSPP, constructing graph G∗ from MST.

a two-degree node in the MST connected to si and ei or a leaf node in the MST
connected to si or ei. In this step, for each middle node as a leaf such as mi (suppose
si is the parent of mi), the edge miei is added to the MST to form a graph denoted by
G∗. In G∗, the degree of any middle node is even. Fig 4 shows how this step works.
As a natural consequence of this step, the overall weight of the MST increases by the
sum of w(mi, ei) for any i such that mi is a leaf middle node.

Step 3: Minimum Perfect Matching over Odd-degree Nodes

This step, which is identical to one of the Christoﬁdes’ steps [6], performs minimum
perfect matching in G(cid:48)(cid:48) between all odd-degree nodes in G∗ 8 and adds the edges
involved in perfect matching to G∗ to build a graph denoted by ˆG. Since there is no
odd-degree middle node in G∗, no middle node is involved in perfect matching. As
a result, no inﬁnity weight edge is added to G∗. Thus ˆG is still without any inﬁnity
weight edges.

Step 4: Finding an Eulerian Tour Over ˆG

The ﬁnal output graph of Step 3, i.e., ˆG, is an Eulerian graph 9. Thus, it has an
Eulerian tour. An Eulerian tour is a sequence of nodes, which visits every edge
exactly once. The current step (similar to Christoﬁdes’) ﬁnds an Eulerian tour of ˆG.
We call the output of this step trail.

Step 5: Conﬁned Shortcut on trail

As deﬁned above, trail is an Eulerian tour. It is possible for an Eulerian tour to visit
some nodes more than once. In order to turn an Eulerian tour into a Hamiltonian tour,
the extra occurrences of nodes have to be removed. An operation, called shortcut,
is used in Christoﬁdes’ algorithm [6] to do such a transformation. However, G(cid:48)(cid:48)
contains some inﬁnity weight edges and so it is not feasible to do shortcuts like in

8Number of these nodes is even because the total degrees of nodes in a graph is even.
9a connected graph with even-degree nodes

19

1243..…...….si..….6..….MSTG*1243..…...….si..….6..….24361sieimi24361sieimithe Christoﬁdes’ algorithm. This is because it may add inﬁnity edges to the tour. To
address this problem, we introduce a new operation, called conﬁned shortcut. The
procedure of this operation is discussed in the following.

Consider a node v such that it is visited more than once in trail. Let w and u
denote the predecessor and successor in one of v’s occurrences in the tour, respectively.
In this case, it is feasible to add an edge uw to the tour and remove the edges uv and
vw to decrease the number of occurrences of v by one. We keep doing this process
until the number of occurrences of v in the tour get to one. If one of the nodes u and
w is a middle node, then the weight of the edge uw is inﬁnity and so performing the
conﬁned shortcut operation would result in adding an inﬁnity edge to the tour. To
resolve this problem, we avoid performing the conﬁned shortcut operation over u-v-w
and in place of that the operation is done over other occurrences of v. Lemma 1 shows
that performing conﬁned shortcut over at most one of the occurrences of v in trail
may lead to adding an inﬁnity edge. Thus, in order to build a ﬁnite Hamiltonian tour,
conﬁned shortcuts can be performed over other occurrences to avoid adding inﬁnity
weight edges. In fact, diﬀerences between shortcut in [6] and conﬁned shortcut are in
the two following issues: 1) Performing conﬁned shortcuts in only three consecutive
nodes in the tour; 2) avoiding performing conﬁned shortcut whenever it leads to
adding an inﬁnity weight edge.
In step 5, it is possible to have a sequence like x-p0-p1- . . . - pm-y in which, for all i
(0 ≤ i ≤ m), pi is already visited. In Christoﬁeds’ shortcut, all nodes pi are removed
in one step and then edge x-y is added to the tour. On the other hand, in each step
of conﬁned shortcut, only one node is removed. Lemma 2 shows that doing conﬁned
shortcut on such cases is doable.

Lemma 1 For each node v in trail (the Eulerian tour generated by step 4 of the CSPP
algorithm), doing conﬁned shortcut (step 5 of the algorithm) adds inﬁnity wight edges
(cid:4)
for at most one of the v’s occurrences.

Proof: According to the steps 2, 3, and 4, ˆG does not have any inﬁnity edges. The
node v in ˆG can be either head or tail of a subpath (i.e. si or ei for some i) or a
middle node (i.e., mi for some i). In the former case, v (equal to si or ei) is not a
neighbour of a middle node in ˆG, unless the neighbour middle node is mi (if v is a
neighbour of mj where j (cid:54)= i, then the edge vmj has the inﬁnity weight in ˆG). In the
latter case, v is a middle node, say mi. In this case, v cannot have any other middle
nodes, say mj for j (cid:54)= i, as its neighbour in ˆG, since the weight of mimj is inﬁnity.
Therefore, only one neighbour of v in ˆG would be a middle node.

Moreover, according to operations involved in steps 1 to 4, no middle node has a
multiple edge in ˆG 10. As a result, at most one occurence of v can appear next to a

10A node x has multiple edge in a graph, if there exists another node y such that there are two or

more edges between x and y.

20

In ˆG no middle node has a multiple edge.

middle node in trail and doing shortcut over that speciﬁc occurence leads to adding
(cid:3)
an inﬁnity weight edge.
It is worth pointing out that if ˆG
includes a multiple edge connected to a middle node, then there exist some cases like
one shown in Fig. 5, where trail over graph includes sequences like simisi. In this
case, removing each of the occurrences of si (by using conﬁned shortcut) leads to
adding an inﬁnity weight edge. Therefore, the step 5 of CSPP is not feasible in such
cases, since it may add inﬁnity weight edges to the Hamiltonian tour of CSPP.

Lemma 2 Consider an Eulerian tour with a subsequence x-p0-p1-. . .-pm-y in which
each node pi, for any i (0 ≤ i ≤ m), has been already visited. Multiple applying of
conﬁned shortcut (according to step 5) on this Eulerian tour makes the number of
occurrences of nodes pi (for all i) to reduced to 1 and also it does not add any inﬁnity
(cid:4)
edge to the tour.

Proof: Since each pi has been visited already before x in the Eulerian tour, the
number of its occurrences in the tour would be more than 1. The degree of each
middle node in ˆG is 2. Therefore, the number of occurrences of middle nodes in
an Eulerian tour of this graph would be 1. This implies that none of the nodes pi
(1 ≤ i ≤ m) is a middle node (note the premise in the lemma stating that pi has been
already visited). Thus, only one of the following cases would be possible:

1. x is a middle node and y is not:

In this case, conﬁned shortcut acts in the way as follows. First, the sequence
with the ﬁrst three nodes, i.e., x-p0-p1, is investigated. Since x is a middle node,
removing p0 results in adding the edge x-p1, which has inﬁnity weight. Thus,
conﬁned shortcut is not applicable on this sequence, which means p0 is not
removed. In the next sequence, i.e., p0-p1-p2, conﬁned shortcut is applicable,
since the nodes p0 and p1 are not middle nodes. Applying conﬁned shortcut
on this sequence, p1 is removed, the edge p0-p2 is added into the tour, and the
subsequence would be turned into x-p0-p2-··· -pm-y. Similarly, in the next step,
conﬁned shortcut is applied on p0-p2-p3 and p2 is removed. This procedure
is continued until the subseqeunce is turned into x-p0-y. Since, according to
Lemma 1, applying conﬁned shortcut on at most one of the p0’s occurrences
makes adding an inﬁnity edge (in this case, x-p0-p1), conﬁned shortcut can be
applied on other occurrences of p0 to make the number of its occurrences equal
to 1.

2. y is a middle node and x is not:

Like the case 1, multiple applying of conﬁned shortcut, the subsequence would
be turned into x-pm-y. Since y is a middle node, applying conﬁned shortcut

21

Figure 5: If a middle node has a multiple edge then step 5 of CSPP may add inﬁnite
edge to the tour.

to remove pm would be impossible. However, according to Lemma 1, conﬁned
shortcut can be applied on other occurrences of pm to make the number of its
occurrences equal to 1.

3. Both x and y are middle nodes:

In this case, both p0 and pm would be problematic, i.e., applying conﬁned
shortcut on the tour does not remove p0 and pm. In other words, the subsequence
eventually would be turned into x-p0-pm-y. However, again according to Lemma
1, this means that other occurrences of both p0 and pm would be removed by
applying conﬁned shortcut, which makes their number of occurrences to reduced
to 1.

4. None of x and y is middle node:

In this case, all nodes p0, . . . , pm are removed by multiple applying of conﬁned
shortcut. Then the tour would be turned into x-y.

As we saw above,
in all cases, the number of occurrences of each of the nodes
p0,··· , pm is reduced to 1 by multiple applying of conﬁned shortcut without adding
(cid:3)
any inﬁnity edge.
After the ﬁfth step, according to Lemma 1, the resulting Hamiltonian tour, de-

noted by h-trail, does not include any inﬁnity weight edge.

22

1243..…...…...….c..….a243a1sieimicbd5.2 Ratio Bound of CSPP Algorithm

In this section, it is shown that the ratio bound of CSPP is 2. Lemmas 3 and 5 are
adapted from [6]. The proofs of them can be found in Appendix. A.
Lemma 3 The weight of MST is less than the weight of T ∗, where T ∗ is the optimal
(cid:4)
TSP tour in G(cid:48)(cid:48).

Remark 2 The notation W (H) denotes the sum of edge weights of a given graph
H. T ∗ and P M∗ denote the TSP tour in G(cid:48)(cid:48) and edges of perfect matching in step 3,
respectively.

Lemma 4 The total added weight to MST during the second step is less than the half
(cid:4)
of the weight of T ∗.

w(ei, mi) is added to the weight of MST. Therefore, W (E2) ≤ (cid:80)n
(cid:80)n
(cid:80)n

Proof: During the second step, for each middle leaf node mi (for some i) in MST,
i=1 w(ei, mi) =
i=1 w(si, mi) + w(ei, mi), where W (E2) is the total weights of added edges to
MST during this step. T ∗ does not include any inﬁnity weight edge. Thus, for
each subpath, say ith, T ∗ includes the edges simi and eimi, which implies W (T ∗) >
i=1 w(si, mi) + w(ei, mi). Therefore, the inequality W (E2) < 0.5W (T ∗) holds. The
(cid:3)

1
2

lemma is proven.
Lemma 5 P M∗’s weight is less than half of T ∗’s.

Theorem 4 The ratio bound of CSPP is 2.

(cid:4)

(cid:4)

Proof: The graph ˆG is composed of the edges of the MST and the edges added in
steps 2 and 3 (perfect matching). According to Lemmas 3, 4 and 5,

W ( ˆG) = W (MST) + W (E2) + W (P M∗)

≤ 2W (T ∗)

(16)

, where ˆG denotes the graph generated in step 3 of CSPP, MST denotes the output
tree of step 1, E2 denotes the set of edges which are added to MST in step 2, and
P M∗ denotes edges of perfect matching in step 3. Thus, the length of trail over ˆG
(found in step 4) is less than 2 times of the optimal TSP tour.

trail does not contain any inﬁnity weight edges, since the edges of ˆG are not
inﬁnity weight edges. Moreover, based on Lemma 1, performing shortcuts during
step 5 does not add any inﬁnity edge. Accordingly, the triangles used in performing
conﬁned shortcut (for each conﬁned shortcut two edges of tour corresponding to a
triangle are replaced with the third edge of triangle) do not include any inﬁnity edge.

23

Thus, based on Theorem 2, triangle inequality is not violated in these triangles.
Thus, for each execution of conﬁned shortcuts (during step 5), the length of the tour
decreases. Hence, the length of the Hamiltonian tour, h-trail, returned by CSPP is
less than the length of trail and the following statement holds:
W (h-trail) ≤ W (trail) = W ( ˆG) ≤ 2W (T ∗)

(17)

Hence, the solution produced by CSPP is within 2 of optimum. Therefore, the ratio
(cid:3)
bound of CSPP is 2.

5.3 Pseudo Code and Complexity Analysis of CSPP

In this section, the time complexity of the approximation algorithm CSPP is discussed
in term of the number of subpaths. Algorithm 3 is a pseudo code for this algorithm,
which takes G(cid:48)(cid:48) (the output of the IETI algorithm) as input and returns a Hamiltonian
tour called h-trail. Let the number of subpaths in the given workspace be n. Then
the graph G(cid:48)(cid:48) has 3n nodes and 9n2 edges.

Complexity analysis of Step 1 (line 1): MST can be found using Kruskal’s
algorithm [20] or Prim’s algorithm [31]. Two implementations of these algorithms are
Improved Implementation of Kruskal Algorithm and Fibonacci Heap Implementation
of Prim‘s Algorithm [1], respectively, which both are in O(|E|+|V | log |V |) complexity
class. Since the numbers of nodes and edges are 3n and 9n2, respectively, the total
complexity of this step would be in O(n2).

Complexity analysis of Step 2 (lines 2 to 9): This step includes a loop of n
iterations, where each iteration takes O(1) time. Thus, the total complexity of this
step is in O(n).

Complexity analysis of Step 3 (lines 10 and 11): The modiﬁed version of
Edmond’s Blossom Shrinking algorithm in [25] can be used to do perfect matching,
which requires O(|V |3) running time. The total number of odd-degree nodes in G∗
is in the O(n) class. Thus, complexity of perfect matching would be in the O(n3)
class. Furthermore, the number of nodes involved in perfect matching is in O(n).
Therefore, adding the perfect matching edges to G∗ (line 11) is in O(n). As a result,
step 3 requires O(n3) running time.
Complexity of Step 4 (line 12): One can use Fleury algorithm [29] to ﬁnd
Eulerian tour, which has the running time complexity of O(|E|).
ˆG includes the
following kinds of edges: 1) the edges of MST (O(n) edges) 2) the edges between
misi or miei, which are added in step 2 (O(n) edges) 3) the edges of perfect matching
(O(n) edges). Thus, the total number of the edges in ˆG is in the O(n) class. This
implies that the running time of Fleury algorithm on ˆG is in the O(n) class.

Complexity analysis of Step 5 (lines 13 to 34): trail in line 12 is the output
of step 4. In line 13, trail is copied into h-trail. Hence, according to Lemma 1, conﬁned
shortcut (step 5) can be applied on h-trail in order to produce a ﬁnite Hamiltonian

24

Algorithm 3 CSPP

Add edge miei

Add edge misi

end if

end if

if mi is a leaf node and si is the parent of mi then

end if
if mi is a leaf node and ei is the parent of mi then

1: Find the minimum spanning tree, MST
2: for all subpaths such as i do
3:
4:
5:
6:
7:
end if
8:
9: end for
10: Do perfect matching over odd-degree nodes in G∗
11: Add perfect matching edges to G ∗ and construct ˆG
12: Find Eulerian tour, trail, in ˆG
13: h-trail ← trail
14: Make visit zero for all nodes in G(cid:48)(cid:48)
15: while has not reached the end of h-trail do
select the next node in t in forward order
16:
visit(t) ← visit(t) + 1
17:
if visit(t) ≥ 2 then
18:
19:
20:
21:
22:
23:
24:
25:
26: end while
27: while has not reached the end of h-trail do
28:
29:
30:
31:
32:
33: end while
34: return h-trail

t0 ← the node appears before t in h-trail
t1 ← the node appears after t in h-trail
if w(t0, t1) is ﬁnite then
Delete node t
visit(t) ← visit(t) − 1

Select the next node t in h-trail forward order
if visit(t) == 2 then

Delete node t
visit(t) ← visit(t) − 1

end if

25

tour. The procedure of conﬁned shortcut is shown in lines 14 to 33.
In order to
perform conﬁned shortcut, h-trail is explored two times from head to tail (lines 15
to 26 and lines 27 to 33).
If during an exploration (moving along all members of
h-trail) performing a conﬁned shortcut leads to adding an edge with inﬁnity weight,
that particular shortcut will not be performed.

One can think of h-trail as a list of nodes. Lines 16 to 25 iterates over all members
of this list. At each iteration, visit(t) shows the number of occurrences of node t in
h-trail up to the current index of the list. If the number of occurrences of a node
is more than 1 (line 18), its current occurrence is removed (line 22) provided that
performing conﬁned shortcut (t0-t-t1) does not add an inﬁnity edge (line 21). As a
result, only the ﬁrst occurrence of a node is kept and the rest are removed. According
to Lemma 1, two scenarios can happen for a node t in h-trail: 1) performing conﬁned
shortcut over one of its occurrences adds an inﬁnity edge, 2) performing conﬁned
shortcut over each occurrence never adds an inﬁnity edge. Therefore, after executing
the loop in lines 15 to 26, one of the three following cases can occur for a node t:

1. Performing conﬁned shortcut over each occurrence of t does not add an inﬁnity
edge. In this case, only the ﬁrst occurrence of t remains in h-trail and the others
are removed. This makes the value of visit(t) equal to 1.

2. Performing conﬁned shortcut over the ﬁrst occurrence of t adds an inﬁnity edge.
Similar to the previous case, only the ﬁrst occurrence is kept in the list and the
others are removed. Therefore, the value of visit(t) would be 1 after executing
the loop.

3. Performing conﬁned shortcut over one of the t’s occurrences (not the ﬁrst one)
adds an inﬁnity edge. In this case, two occurrences are kept and the others are
removed. The kept occurrences are the ﬁrst one and the occurrence that results
in adding an inﬁnity edge. In this case, the value of visit(t) would be 2.

As already mentioned, to turn an Eulerian tour to a Hamiltonian one, the occur-
rences of each node must be reduced to one. To this end, the execution of lines 27 to
33 reduces the value of visit for those nodes that are visited more than once (nodes
in the case 3 above).

Performing conﬁned shortcut on the second occurrence of nodes belonging to
the case 3 leads to adding an inﬁnity edge. Therefore, conﬁned shortcut must be
performed over the ﬁrst occurrence of nodes. Lines 28 to 32 iterate over each element
of h-trail. Line 29 detects the ﬁrst occurrence of nodes belonging to the case 3. Then,
conﬁned shortcut is performed on the ﬁrst occurrence and the number of visits is
reduced to one (line 30).

At the end of the ﬁrst exploring, the number of occurrences of each node can be
up to two, while at the end of the second exploring, this number is exactly one. These
explorations can prevent us from moving constantly back and forth over h-trail.

26

Figure 6: An augmented chromosome used in Gyorﬁ GA which consists of two arrays
(adapted from [16]).

The time of exploring h-trail is linearly dependent to the number of its edges,
which is equal to the number of ˆG’s edges (the number of edges in ˆG is in the O(n)
class). As a consequence, the complexity of each exploration is in O(n) and, hence,
the overall complexity of this step would be in O(n).

According to the complexity class of each step (discussed above), the total com-

plexity of CSPP would be in the O(n3) class.

6 Experiments and Results

In this section, we empirically gauge the performance of CSPP by comparing it with
the method proposed by Gyorﬁ et al. [16], which uses GA. For simplicity, throughout
this section, this method is referred by Gyorﬁ GA. For comparison, we use diﬀer-
ent sets of workspaces including 3 workspaces with 20 subpaths, 3 workspaces with
50 subpaths and 3 workspaces with 80 subpaths. The subpaths of each workspace
were built randomly in diﬀerent lengths and diﬀerent locations. Any of the 9 ran-
domly generated workspaces can be seen as a sample for a real work application. For
instance, they can be a scratch on a surface that a robot should smooth.

In the Gyorﬁ GA method, each feasible solution of the problem is shown with a
ﬁxed length augmented chromosome with length of n. Each augmented chromosome
such as e, consists two chromosomes such as c and d shown in Fig. 6. Each gene
of chromosome d can take value 0 or 1, which indicates the connection between two
subpath. For any i, d(i) = 0 shows that the head of the subpath c(i) is connected to
the subpath c(i + 1). Similarly, d(i) = 1 shows that the tail of c(i) is connected to
c(i + 1). Five diﬀerent genetic operations are used in the Gyorﬁ GA method. “The
crossover operator produces an oﬀspring chromosome by combining genes from two
parent chromosomes. The inversion operator changes a region of a parent chromosome
by inverting the order of the genes in the region. The rotation operator changes a
region of a parent chromosome by rotating the genes in the region in manner similar
to a circular shift register. The mutation operator exchanges two genes in a parent
chromosome. The subpath reversal operator changes the direction ﬂag of randomly
chosen genes within a parent chromosome”[16].

Parameter setting for the operation rates of Gyorﬁ GA were chosen to be 0.5 for

27

e(4) e(3) e(2) e(1)   c(4) c(3) c(2) c(1)      d(4) d(3) d(2) d(1)     crossover, 0.25 for inversion, 0.25 for rotation, 0.5 for mutation and 0.5 for subpath
reversal. These parameters are ﬁxed during all experiments and seem to be near
optimal set of parameters, according to the results of diﬀerent parameter settings.
Each of the methods were executed 30 times over each environment.

Table 1 compares means and standard deviations (in parenthesis) of 30 execu-
tions of CSPP and Gyorﬁ GA (population size is 100) in three environments with
20 supaths. Gyorﬁ GA iterates until it converges (all of the executions converged at
150 iteratios at most). The results indicate that Gyorﬁ GA returns longer outputs
with more time consumption (in average CSPP is more than 8.55 times eﬃcient than
Gyorﬁ GA in terms of time consumption).

Likewise, both methods were executed in the workspaces with 50 and 80 subpaths
over 30 iteratios the results of which are shown in Tables 2 and 3. The population sizes
for these experiments are 200 and 300, respectively. Roughly, the Gyorﬁ GA converges
after 300 and 500 iteratios for workspaces with 50 and 80 subpaths. According to
Tables 2 and 3, Gyorﬁ GA leads to less eﬃcient results both in terms of length of
output and time. Technically speaking, the time that the Gyorﬁ GA method spends
is more than 7.28 and 2.97 times than CSPP uses to generate the ﬁnal results.

According to Table 4, using CSPP in place of Gyorﬁ GA provides an average
improvement of 86.7% and 0.33% in execution time and result’s length, respectively.
Note that these improvements happen while the average rate of deviation in both
execution time and result’s length in Gyorﬁ GA (0.13 and 32.2, respectively) are
reduced to 0 in CSPP.

Similarly, according to Tables 5 and 6, CSPP improves the average execution time

Table 1: Results of CSPP and Gyorﬁ GA with population size 100,
workspaces with 20 subpaths.

in three

Env.

1st
2nd
3rd

CSPP

Gyorﬁ GA

Length
1134.6(0)
1375.8(0)
1394.8(0)

Time
0.6(0)
1(0)
0.2(0)

Length
1147.9(31.7)
1357.6(34.5)
1410.8(30.3)

Time (in seconds)
5.6(0.2)
3.9(0.1)
5.9(0.1)

Table 2: Results of CSPP and Gyorﬁ GA with population size 200,
workspaces with 50 subpaths.

in three

Env.

1st
2nd
3rd

CSPP

Gyorﬁ GA

Length
2889.8(0)
3004.5(0)
2710.1(0)

Time
6.0(0)
6.3(0)
12.7(0)

Length
3052.9(49.3)
3110.7(45)
2843.0(54)

Time (in seconds)
65.1(3.1)
64.2(5.1)
52.1(3)

28

Table 3: Results of CSPP and Gyorﬁ GA with population size 300,
workspaces with 80 subpaths.

in three

Env.

1st
2nd
3rd

CSPP

Gyorﬁ GA

Length
4536.2(0)
4254.2(0)
4732.3(0)

Time
74.8(0)
16.7(0)
65.5(0)

Length
4791.4(71.5)
4610.2(81.3)
5003.5(78.1)

Time (in seconds)
168.2(19.7)
147.8(2.8)
149.7(3.3)

Table 4: Result Improving by CSPP in comparison with Gyorﬁ GA in environments
with 20 subpaths.

Env.

Time Improving Length Improving

I
II
III

Average

89.3%
74.4%
96.6%
86.7%

1%
-1%
1%

0.33%

85.5% and 66.8% in workspaces with 50 and 80 subpaths, respectively. Also, result’s
length is improved 4.43% and 6.13% in average, respectively. The average rate of
deviation in both execution time and result’s length in Gyorﬁ GA are reduced to 0 in
CSPP. Note that the average rate of deviation in time and length in Gyorﬁ GA are,
respectively, 3.73 and 49.4 in workspaces with 50 subpaths and 8.6, 77 in workspaces
with 80 subpaths.

Comparing the outputs of the two algorithm, we get the following results:

1. Increasing the number of subpaths causes a pretty huge increase in the rate of
deviation in both execution time and result’s length in Gyorﬁ GA. This implies
that uncertainty in Gyorﬁ GA increases by increasing the number of subpaths
in the same environment, whereas this is not the case in CSPP. Since the rate
of deviation is 0 for both execution time and result’s length in CSPP, it always
delivers a certain result in a certain time for a given input.

2. As we see in the third columns of the Tables 4, 5, and 6, the CSPP algorithm
delivers better results than Gyorﬁ GA does. Also, it is more intriguing that
the eﬃciency of CSPP remarkably increases in comparison with Gyorﬁ GA by
increasing the number of subpaths: the average length improvement increases
from 0.33% to 6.13% by increasing the number of subpaths from 20 to 80.

3. The CSPP algorithm is much more faster than the Gyorﬁ GA algorithm to solve

SPP in all above experiments.

29

Table 5: Result Improving by CSPP in comparison with Gyorﬁ GA in environments
with 50 subpaths.

Env.

Time Improving Length Improving

I
II
III

Average

90.7%
90.2%
75.6%
85.5%

5.3%
3.4%
4.6%
4.43%

Table 6: Result Improving by CSPP in comparison with Gyorﬁ GA in environments
with 80 subpaths.

Env.

Time Improving Length Improving

I
II
III

Average

55.5%
88.7%
56.2%
66.8%

5.3%
7.7%
5.4%
6.13%

7 Conclusion and Future Works

In this paper, we have proposed a method to transform SPP to TSP. Transforming
SPP to TSP allows us to use existing algorithms for solving TSP in the subpath
planning context. However, violation of triangle inequality hinders applying existing
ﬁxed-ratio bound approximation algorithms such as Christoﬁdes for SPP. To address
this problem, we have proposed the algorithm IETI, which makes a main subset of
violating triangles to satisfy the triangle inequality condition. The IETI algorithm
should be seen as a fundamental step in proposing and applying ﬁxed-ratio bound
approximation algorithms for solving SPP. Using this method, a ﬁxed-ratio bound
approximation algorithm, called CSPP, has been proposed to ﬁnd a near optimal
solution for SPP. CSPP Solves TSP over the output graph of IETI algorithm. CSPP
is similar to the Christoﬁdes’ algorithm regarding time complexity, but its ratio bound
(the ﬁxed ratio bound of 2) is more than the Christoﬁdes’ algorithm. This is natural,
since CSPP can be executed over some graphs, which cannot be in the domain of
Christoﬁdes’ algorithm.

Although we theoretically showed that CSPP has reasonable time complexity
with a small ﬁxed ratio bound, experiments also indicate that the algorithm is a fast
algorithm with more eﬃcient results in comparison with a state-of-the-art method
Gyorﬁ GA. Moreover, the diﬀerences between eﬃciency of these algorithms becomes
much more signiﬁcant as the number of subpaths increases.

We think that it would be possible to improve the results of the CSPP method

using some improvement methods such as Lin-Kernighan [23] and Helsgaun [17].

30

We plan to propose some algorithms with smaller ratio bounds. Indeed, we try to
improve the ratio bound of the CSPP algorithm using some heuristic-based methods.
One important guide line could be using the graph generated by the IETI algorithm
as an input for a modiﬁed version of the RPP algorithm [11].

Our algorithms solve SPP without considering any constraints, say some priorities
over subpaths or environments with obstacles. We also plan to solve SPP for some
certain applications with some constraints.

CSPP is neither a meta-heuristic nor a stochastic method.

It may be possible
to propose some meta-heuristic based methods such as tabu search and simulated
annealing based on the TSP model of a given SPP to generate more eﬃcient results
in the case of oﬄine tasks. We can initialize such algorithms with the solutions found
by CSPP to improve the output of such meta-heuristic methods.

31

References

[1] R. Ahuja, T. Magnanti, and J. Orlin. Network ﬂows: Theory, algorithms, and

applications, 1993.

[2] E. M. Arkin and R. Hassin. Approximation algorithms for the geometric covering

salesman problem. Discrete Applied Mathematics, 55(3):197–218, 1994.

[3] G. Ausiello. Complexity and approximation: Combinatorial optimization prob-

lems and their approximability properties. Springer Verlag, 1999.

[4] C. Blum and A. Roli. Metaheuristics in combinatorial optimization: Overview
and conceptual comparison. ACM Computing Surveys (CSUR), 35(3):268–308,
2003.

[5] D. Chen, S. Luan, and C. Wang. Coupled path planning, region optimiza-
tion, and applications in intensity-modulated radiation therapy. Algorithmica,
60(1):152—174, 2011.

[6] N. Christoﬁdes. Worst-Case analysis of a new heuristic for the travelling salesman

problem. Technical report, DTIC Document, 1976.

[7] A. Coja-Oghlan, S. O. Krumke, and T. Nierhoﬀ. A heuristic for the stacker crane
problem on trees which is almost surely exact. Journal of Algorithms, 61(1):1–19,
2006.

[8] A. Dumitrescu and J. S. Mitchell. Approximation algorithms for tsp with neigh-
borhoods in the plane. In Proceedings of the twelfth annual ACM-SIAM sym-
posium on Discrete algorithms, pages 38–46. Society for Industrial and Applied
Mathematics, 2001.

[9] H. A. Eiselt, M. Gendreau, and G. Laporte. Arc routing problems, part i: The

chinese postman problem. Operations Research, 43(2):231–242, 1995.

[10] H. A. Eiselt, M. Gendreau, and G. Laporte. Arc routing problems, part ii: The

rural postman problem. Operations Research, 43(3):399–414, 1995.

[11] G. N. Frederickson. Approximation algorithms for some postman problems. Jour-

nal of the ACM (JACM), 26(3):538–554, 1979.

[12] G. N. Frederickson, M. S. Hecht, and C. E. Kim. Approximation algorithms
for some routing problems. In Foundations of Computer Science, 1976., 17th
Annual Symposium on, pages 216–227. IEEE, 1976.

32

[13] M. Garey and D. Johnson. Computers and intractability. a guide to the theory
of np-completeness. a series of books in the mathematical sciences, ed. v. klee.
1979.

[14] R. Geraerts and M. Overmars. The corridor map method: a general frame-
work for real-time high-quality path planning. Computer Animation and Virtual
Worlds, 18(2):107—119, 2007.

[15] D. Goldberg. Genetic algorithms in search, optimization, and machine learning.

Addison-wesley, 1989.

[16] J. Gyorﬁ, D. Gamota, S. Mok, J. Szczech, M. Toloo, and J. Zhang. Evolution-
ary path planning with subpath constraints. IEEE Transactions on Electronics
Packaging Manufacturing, 33(2):143—151, 2010.

[17] K. Helsgaun. An eﬀective implementation of the Lin-Kernighan traveling sales-
man heuristic. European Journal of Operational Research, 126(1):106—130, 2000.

[18] D. Johnson and L. McGeoch. The traveling salesman problem: A case study in
local optimization. Local search in combinatorial optimization, pages 215—310,
1997.

[19] R. Karp. Reducibility among combinatorial problems, volume 40. Springer, 1972.

[20] J. Kruskal. On the shortest spanning subtree of a graph and the traveling sales-
man problem. Proceedings of the American Mathematical society, 7(1):48—50,
1956.

[21] G. Laporte. The traveling salesman problem: An overview of exact and approx-
imate algorithms. European Journal of Operational Research, 59(2):231—247,
1992.

[22] J. K. Lenstra and A. Kan. Complexity of vehicle routing and scheduling prob-

lems. Networks, 11(2):221–227, 1981.

[23] S. Lin and B. Kernighan. An eﬀective heuristic algorithm for the traveling-

salesman problem. Operations research, pages 498—516, 1973.

[24] C. S. Mata and J. S. Mitchell. Approximation algorithms for geometric tour and
network design problems. In Proceedings of the eleventh annual symposium on
Computational geometry, pages 360–369. ACM, 1995.

[25] S. Micali and V. Vazirani. An o (v| v| c| e|) algoithm for ﬁnding maximum
matching in general graphs. In Foundations of Computer Science, 1980., 21st
Annual Symposium on, pages 17—27, 1980.

33

[26] R. G. Michael and D. S. Johnson. Computers and intractability: A guide to the

theory of np-completeness. WH Freeman & Co., San Francisco, 1979.

[27] C. Orloﬀ. A fundamental problem in vehicle routing. Networks, 4(1):35–64, 1974.

[28] C. H. Papadimitriou. The euclidean travelling salesman problem is np-complete.

Theoretical Computer Science, 4(3):237–244, 1977.

[29] S. Pemmaraju and S. Skiena. Computational discrete mathematics: combina-

torics and graph theory with Mathematica. Cambridge Univ Pr, 2003.

[30] R. Pepy, M. Kieﬀer, and E. Walter. Reliable robust path planning with ap-
plication to mobile robots. International Journal of Applied Mathematics and
Computer Science, 19(3):413–424, 2009.

[31] R. Prim. Shortest connection networks and some generalizations. Bell system

technical journal, 36(6):1389—1401, 1957.

[32] S. Safra and O. Schwartz. On the complexity of approximating tsp with neigh-
borhoods and related problems. computational complexity, 14(4):281–307, 2006.

[33] S. Sahni and T. Gonzalez. P-complete approximation problems. Journal of the

ACM (JACM), 23(3):555–565, 1976.

[34] W. Sheng, H. Chen, N. Xi, and Y. Chen. Tool path planning for compound
surfaces in spray forming processes. Automation Science and Engineering, IEEE
Transactions on, 2(3):240–249, 2005.

[35] G. Song, S. Thomas, K. DILL, J. Scholtz, and N. Amato. A path planning-based
study of protein folding with a case study of hairpin formation in protein g and
l. In Proc. Paciﬁc Symposium of Biocomputing (PSB), pages 240—251, 2002.

[36] L. Tapia, S. Thomas, and N. Amato. A motion planning approach to studying
molecular motions. Communications in Information & Systems, 10(1):53—68,
2010.

[37] G. Tong-ying, Q. Dao-kui, and D. Zai-li. Research of path planning for polishing
robot based on improved genetic algorithm. In Robotics and Biomimetics, 2004.
ROBIO 2004. IEEE International Conference on, pages 334—338, 2004.

[38] K. Treleaven, M. Pavone, and E. Frazzoli. Asymptotically optimal algorithms
for one-to-one pickup and delivery problems with applications to transportation
systems. 2013.

34

A Proofs of Lemma 3 and Lemma 5

The proofs of Lemmas 3 and 5 are adapted from [6].

Proof:
[Proof of Lemma 3] Suppose H is a Hamiltonian tour which is constructed
by subtracting an arbitrary edge of T ∗. Note that H is a spanning tree of G. Hence:

W (M ST ) ≤ W (H) < W (T ∗)

(18)
(cid:3)

[Proof of Lemma 5] For an n-city TSP, consider T ∗ = (xi1, xi2, ..., xin). Start-
Proof:
ing from vertex xi1 and travelling round the circuit T ∗, allocate the links traversed in
an alternating manner to two sets M1 and M2. Starting with M1, for example: M1 =
{(xi1, xi2), (xi3, xi4), ..., (xin−1, xin)} and M2 = {(xi2, xi3), (xi4, xi5), ..., (xin, xi1)}. M1
and M2 are matching of G and W (M1) + W (M2) = W (T ∗). Since M1 and M2 are
deﬁned arbitrarily we can assume W (M1) ≤ W (M2) without loss of generality, and
so we have: W (P M ) ≤ W (M1) ≤ 1
(cid:3)

2W (T ∗). Hence, the lemma is proved.

35

