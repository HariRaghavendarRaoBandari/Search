Von Neumann Algebras form a Model for the
Quantum Lambda Calculus∗
Kenta Cho and Abraham Westerbaan

Institute for Computing and Information Sciences
Radboud University, Nijmegen, the Netherlands
{K.Cho,awesterb}@cs.ru.nl

Abstract

We present a model of Selinger and Valiron’s quantum lambda calculus based on von Neumann
algebras, and show that the model is adequate with respect to the operational semantics.

1998 ACM Subject Classiﬁcation F.3.2 Semantics of Programming Language

Keywords and phrases quantum lambda calculus, von Neumann algebras

1

Introduction

In 1925, Heisenberg realised, pondering upon the problem of the spectral lines of the hydrogen
atom, that a physical quantity such as the x-position of an electron orbiting a proton is
best described not by a real number but by an inﬁnite array of complex numbers [12].
Soon afterwards, Born and Jordan noted that these arrays should be multiplied as matrices
are [3]. Of course, multiplying such inﬁnite matrices may lead to mathematically dubious
situations, which spurred von Neumann to replace the inﬁnite matrices by operators on a
Hilbert space [44]. He organised these into rings of operators [25], now called von Neumann
algebras, and thereby set oﬀ an explosion of research (also into related structures such as
Jordan algebras [13], orthomodular lattices [2], C∗-algebras [34], AW ∗-algebras [17], order
unit spaces [14], Hilbert C∗-modules [28], operator spaces [31], eﬀect algebras [8], . . . ), which
continues even to this day.

One current line of research (with old roots [6, 7, 9, 19]) is the study of von Neumann
algebras from a categorical perspective (see e.g. [4, 5, 30]). One example relevant to this
paper is Kornell’s proof that the opposite of the category vNAMIU of von Neumann algebras
with the obvious structure preserving maps (i.e. the unital normal ∗-homomorphisms) is
monoidal closed when endowed with the spatial tensor product [18]. He argues that vNAop
MIU
should be thought of as the quantum version of Set. We would like to focus instead on the
category of von Neumann algebras and completely positive normal subunital maps, vNACPsU,
as it seems more appropriate for modelling quantum computation: the full subcategory
of vNAop
CPsU consisting of ﬁnite dimensional von Neumann algebras is equivalent to Selinger’s
category Q [35], which is used to model ﬁrst order quantum programming languages.

On the syntactic side, in 2005, Selinger and Valiron [36,37]
proposed a typed1 lambda calculus for quantum computation,
and they studied it in a series of papers [38–40]. A striking
feature of this quantum lambda calculus is that functions

B

⊥ C

⊥

D

Figure 1 General shape of

a model of the QLC

∗ The research leading to these results has received funding from the European Research Council under
the European Union’s Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no
320571

1 An untyped quantum lambda calculus had already been proposed by Van Tonder [43].

© Kenta Cho and Abraham Westerbaan;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

6
1
0
2

 
r
a

M
7

 

 
 
]

O
L
.
s
c
[
 
 

1
v
3
3
1
2
0

.

3
0
6
1
:
v
i
X
r
a

%
%
%
%
d
d
d
d
2

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

naturally appear as data in the description of the Deutch–Jozsa algorithm, teleportation
algorithm and Bell’s experiment. Although Selinger and Valiron gave a precise formulation
of what might constitute a model of the quantum lambda calculus — basically a pair of
adjunctions, see Figure 1, with some additional properties [40, §1.6] — the existence of such
a model (other than the term model) was an open problem for several years until Malherbe
constructed a model in his thesis using presheaves [21]. The construction of Malherbe’s
model is quite abstract, and it is (perhaps because of this) not yet known whether his model
is adequate with respect to the operational semantics deﬁned by Selinger and Valiron in
[37] (see also [40]). While several adequate models for variations on the quantum lambda
calculus have been proposed in the meantime (using the geometry of interaction in [10], and
quantitative semantics in [27]), Malherbe’s model remains the only model of the original
quantum lambda calculus [37] known in the literature, and so the existence of an adequate
model for the quantum lambda calculus is still open.

In this paper, we present the model of Selinger
and Valiron’s quantum lambda calculus, based
on von Neumann algebras, see Figure 2, and we
show that the model is adequate with respect
to the operational semantics. We should note
that it is possible to extend the quantum lambda
calculus with recursion and inductive types, but
that we have not yet been able to include these features in our model.

‘∞
⊥ vNAop
MIU
nsp

Neumann algebras

Set

⊥

vNAop

CPsU

Figure 2 A model of the QLC using von

The paper is divided in six sections. We begin with a short review of quantum computation
(in Section 2), and the quantum lambda calculus and its operational semantics (in Section 3).
We give the denotational semantics for the quantum lambda calculus using von Neumann
algebras and prove its adequacy in Section 4. For this we use several technical results about
the categories vNAMIU and vNACPsU of von Neumann algebras, which we will discuss in
Section 5. We end with a conclusion in Section 6.

2 Quantum Computation

In a nutshell, one gets the quantum lambda calculus by taking the simply typed lambda
calculus with products and coproducts and adding a qubit type. This single ingredient
dramatically changes the ﬂavour of the whole system e.g. forcing one to make the type system
linear, so we will spend some words on the behaviour of qubits in this section. For more
details on quantum computation, see [26].

A state of an isolated qubit is a vector |ψi of length 1 in the Hilbert space C2, and can
be written as a complex linear combination (“superposition”) |ψi = α|0i + β|1i, since the
vectors |0i = (1, 0) and |1i = (0, 1) form an orthonormal basis for C2.

When qubits are combined to form a larger system, one can sometimes no longer speak
about the state of the individual qubits, but only of the state of the whole system (in which
case the qubits are “entangled”). The state of a register of n qubits is a vector |ψi of length 1
in the n-fold tensor product (C2)⊗n ∼= C2n, which has as an orthonormal basis the vectors of
the form |wi ≡ |w1i ⊗ ··· ⊗ |wni where w ≡ w1 ··· wn ∈ 2n.

For the purposes of this paper there are three basic operations on registers of qubits.

1. One can add a new qubit in state |0i to a register of n qubits in state |ψi, turning it to a

register of n + 1 qubits in state |ψi ⊗ |0i. A qubit in state |1i can be added similarly.

2. One can apply a unitary 2n × 2n matrix U to a register of n qubits in state |ψi turning

the state to U|ψi.

*
*
%

+
+
h
h
l
l
K. Cho and A. Westerbaan

3

3. One can test the ﬁrst qubit in the register. If the state of the register is written as
|ψi ≡ α|0i ⊗ |ψ0i + β |1i ⊗ |ψ1i where the length of |ψ0i and |ψ1i is 1, then the test
comes out negative and changes the state of the register to |0i⊗|ψ0i with probability |α|2,
and comes out positive with probability |β|2 changing the state to |1i ⊗ |ψ1i.
Measurement of the i-th qubit in the register is also possible and behaves similarly.

A predicate on a register of n qubits is a 2n × 2n matrix P such that both P and I − P are
positive (which is the case when P is a projection). The probability that P holds in state |ψi
is hψ|P|ψi. For example, given a state |ψi of a qubit, the projection |ψihψ| (which maps |ξi
to hψ|ξi|ψi) represents the predicate “the qubit is in state |ψi”.

Thus the predicates on a qubit are part of the algebra M2 of 2×2 complex matrices. There
is also an algebra for the bit, namely C2. A predicate on a bit is an element (x, y) ≡ v ∈ C2
with 0 ≤ v ≤ 1, which is interpreted as “the bit is true with probability y, false with
probability x, and undeﬁned with probability 1 − x − y”.

An operation on a register of qubits may not only be described by the eﬀect it has on

states (Schrödinger’s view), but also by its action on predicates (Heisenberg’s view).
1. The operation which takes a bit b and returns a qubit in state |bi is represented by the

3. The operation which tests a qubit and returns the outcome is represented by the

2. The operation which applies a unitary U to a register of n qubits is represented by the

map fnew : M2 → C2 given by fnew(A) = (h0|A|0i, h1|A|1i ).
map fU : M2n → M2n given by fU(A) = U∗AU.
map fmeas : C2 → M2 given by fmeas(λ, ) = λ|0ih0| + |1ih1|.
Ln
A general operation between ﬁnite dimensional quantum data types is usually taken to be
a completely positive subunital linear map (see below) between direct sums of matrix algebras,
i=1 Mmi. The category formed by these operations is equivalent to Qop [4, Th. 8.4].
Von Neumann algebras are a generalisation of direct sums of matrix algebras to inﬁnite
dimensions. Formally, a von Neumann algebra A is a linear subspace of the bounded
operators on a Hilbert space H , which contains the identity operator, 1, is closed under
multiplication, involution, (−)∗, and is closed in the weak operator topology, i.e. the topology
generated by the seminorms |hx|−|xi| where x ∈ H (cf. [16,25]).

We believe that the opposite vNAop

CPsU of the category of von Neumann algebras and
normal completely positive subunital maps (deﬁnitions are given below) might turn out
to be the most suitable extension of Q to describe operations between (possibly inﬁnite
dimensional) quantum data types. Indeed, to support this thesis, we will show that vNAop
CPsU
gives a model of the quantum lambda calculus.

Let us end this section with the deﬁnitions that are necessary to understand vNACPsU.
An element a of a von Neumann algebra A is self-adjoint if a∗ = a, and positive if a ≡ b∗b
for some b ∈ A . The self-adjoint elements of a von Neumann algebra A are partially
ordered by: a ≤ b iﬀ b− a is positive. Any upwards directed bounded subset D of self-adjoint

elements of a von Neumann algebra A has a supremumW D in the set of self-adjoint elements

of A [16, Lem. 5.1.4]. (So a von Neumann algebra resembles a domain.)

The linear maps between von Neumann algebras which preserve the multiplication,
involution, (−)∗, and unit, 1, are called unital ∗-homomorphisms in the literature and MIU-
maps by us. A linear map f between von Neumann algebras is positive if it maps positive
elements to positive elements, unital if it preserves the unit, subunital if f(1) ≤ 1, and normal
if f is positive and preserves suprema of bounded directed sets of self-adjoint elements. (If
subunital maps are akin to partial maps between sets, then the unital maps are the total

4

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

Type A, B ::= qbit | > | !A | A (cid:40) B | A ⊗ B | A ⊕ B
Term M, N, L ::= xA | newA | measA | U A | λnxA.M | M N | ∗n | let hxA, yBin = N in M
A,B(N) | match L withn(xA 7→ M | yB 7→ N)
A,B(W )

Value V, W ::= xA | newA | measA | U A | ∗n | λnxA.M | hV, Win | inln
Table 1 Types, terms and values of the quantum lambda calculus

A,B(V ) | inrn

| hM, Nin | inln

A,B(M) | inrn

maps. Normality is the incarnation of Scott continuity in this setting, and coincides with
continuity with respect to the σ-weak = ultraweak = weak* topology [32, Th. 1.13.2].)
Given a von Neumann algebra A on a Hilbert space H , and a von Neumann algebra B
on a Hilbert space K , the spatial tensor product A ⊗B of A and B is the least von Neumann
algebra on H ⊗ K which contains all operators of the form a ⊗ b where (a ⊗ b)(x ⊗ y) =
a(x)⊗ b(y) for all a ∈ A , b ∈ B, x ∈ H and y ∈ K [15, §11.2]. (The tensor product A ⊗ B
may be physically interpreted as the composition of the systems A and B — recall that a
register of two qubits is represented by the von Neumann algebra M2 ⊗ M2.)
Given normal positive f : A → B and g : C → D there might be a normal positive linear
map f ⊗ g : A ⊗ C → B ⊗ D given by (f ⊗ g)(a ⊗ c) = f(a) ⊗ g(c). An interesting, and
annoying, phenomenon is that such f ⊗ g need not exist for all f and g. This warrants
the following deﬁnition: if f : A → B is a positive linear map such that for every natural
number n the map Mn(f): Mn(A ) → Mn(B) is positive, then f is called completely
positive [29]. Here Mn(A ) is the von Neumann algebra of n × n matrices with entries drawn
from A , and Mn(f)(A)ij = f(Aij) for all i, j and A ∈ Mn(A ). If f and g are normal and
completely positive, then f ⊗ g exists, and is completely positive [41, Prop. IV/5.13].

The Quantum Lambda Calculus and its Operational Semantics

3
We review the quantum lambda calculus for which we will give a denotational semantics.
The language and its operational semantics are basically the same as Selinger and Valiron’s
ones [37], but with sum type ⊕ [40] and ‘indexed’ terms [38], see Remark 1 and Notation 2
below. For space reasons we omit many details, and refer to [37,38,40].

3.1 Syntax and Typing Rules
The language consists of types, terms and values deﬁned in Table 1. We use obvious shorthand
!nA = !··· !A and A⊗n = A ⊗ ··· ⊗ A. The subtyping relation <: on types is deﬁned by the
rules shown in Table 2(a). In the deﬁnition of terms and values, n ∈ N is a natural number;
x ranges over variables; and U ranges over 2k × 2k unitary matrices for k ≥ 1. The (nullary)
constructors new, meas, U are called constants and sometimes referred to by c. Clearly, values
form a subclass of terms. As usual, we identify terms up to α-equivalence.
(cid:73) Remark 1. The terms are indexed terms of [38], which have explicit type annotations (cf.
Church-style vs. Curry-style in the simply-typed lambda calculus). A typing derivation for
an indexed term is unique in a suitable sense, so that we can more easily obtain Lemma 12.
In fact, for the language of [38] we can safely remove the type annotations [38, Corollary 1].
We conjecture that the same is true for our language, which is left as a future work.
(cid:73) Notation 2. Following [40] (and [10, 27]), the language has sum type ⊕ instead of
the bit type (which exists in [37]). The bit type and its constructors are emulated by
bit := > ⊕ >; ffn := inln>,>(∗n); ttn := inrn>,>(∗n); and if L then M else N :=
match L with0(x> 7→ M | y> 7→ N), with fresh variables x, y.

K. Cho and A. Westerbaan

5

!nqbit <: !mqbit

!n> <: !m>

A1 <: B1

A2 <: B2

!n(A1 ⊗ A2) <: !m(B1 ⊗ B2)

A1 <: B1

A2 <: B2

!n(A2 (cid:40) B1) <: !m(A1 (cid:40) B2)
A1 <: B1

A2 <: B2

!n(A1 ⊕ A2) <: !m(B1 ⊕ B2)

(a) Rules for subtyping, with a condition (n = 0 ⇒ m = 0) for each rule

∆, x : A, y : B, Γ (cid:66) M : C (ex)
∆, y : B, x : A, Γ (cid:66) M : C
∆, x : A (cid:66) M : B

((cid:40).I1)

∆ (cid:66) λ0xA.M : A (cid:40) B

A <: B

∆, x : A (cid:66) xB : B
Γ, !∆, x : A (cid:66) M : B

(ax1 )

!Ac <: B (ax2 )
∆ (cid:66) cB : B
FV(M) ∩ |Γ| = ∅

Γ, !∆ (cid:66) λn+1xA.M : !n+1(A (cid:40) B)

((cid:40).I2)

!∆, Γ1 (cid:66) M : A (cid:40) B

!∆, Γ2 (cid:66) N : A ((cid:40).E)

!∆, Γ1, Γ2 (cid:66) M N : B
!∆, Γ1 (cid:66) M : !nA

(>)

∆ (cid:66) ∗n : !n>
!∆, Γ1, x : !nA, y : !nB (cid:66) M : C

!∆, Γ1, Γ2 (cid:66) hM, Nin : !n(A ⊗ B)
!∆, Γ2 (cid:66) N : !n(A ⊗ B)

!∆, Γ1, Γ2 (cid:66) let hxA, yBin = N in M : C

(⊗.E)

!∆, Γ2 (cid:66) N : !nB (⊗.I)

∆ (cid:66) M : !nA
A,B(M) : !n(A ⊕ B)

∆ (cid:66) inln

(⊕.I1)

∆ (cid:66) N : !nB
A,B(N) : !n(A ⊕ B)

∆ (cid:66) inrn

(⊕.I2)

!∆, Γ1, x : !nA (cid:66) M : C

!∆, Γ1, y : !nB (cid:66) N : C

!∆, Γ2 (cid:66) L : !n(A ⊕ B)

!∆, Γ1, Γ2 (cid:66) match L withn(xA 7→ M | yB 7→ N) : C

(⊕.E)

(b) Typing rules

Table 2 Subtyping relation and typing rules

The set FV(M) of free variables is deﬁned in the usual way. A context is a list ∆ = x1 :
A1, . . . , xn : An of variables xi and types Ai where the variables xi are distinct. We write
|∆| = {x1, . . . , xn} and !∆ = x1 : !A1, . . . , xn : !An. We also write ∆|M = ∆ ∩ FV(M) for
the context restricted to the free variables of M.
A typing judgement, written as ∆ (cid:66) M : A, consists of a context ∆, a term M and a type
A. A typing judgement is valid if it can be derived by the typing rules shown in Table 2(b).
In the rule (ax2 ), c ranges over new, meas and 2k × 2k unitary matrices U; and the types Ac
are deﬁned as follows: Anew = bit (cid:40) qbit, Ameas = qbit (cid:40) !bit, AU = qbit⊗k (cid:40) qbit⊗k.
The type system is aﬃne (weak linear). Each variable may occur at most once, unless it

has a duplicable type !A. Substitution of the following form is admissible.
(cid:73) Lemma 3 (Substitution). If !∆, Γ1, x : A (cid:66) M : B and !∆, Γ2 (cid:66) V : A, where V is a value
and |Γ1| ∩ |Γ2| = ∅, then !∆, Γ1, Γ2 (cid:66) M[V /x] : B.
(cid:74)
Note, however, that we need to deﬁne the substitution M[V /x] with care. For example,
if A <: A0, M = yA0(cid:40)BxA0 and V = zA, then we substitute zA0 (not zA) for xA0 in M.
See [38, §2.5] or [42, §9.1.4] for details.

3.2 Operational Semantics
The operational semantics is taken from [37,40], but is adapted for indexed terms.
(cid:73) Deﬁnition 4. A quantum closure is a triple [|ψi, Ψ, M ] with m ∈ N where:

|ψi is a normalised vector of the Hilbert space (C2)⊗m ∼= C2m.

0

0
N ]
, M
0i, Ψ0
,hM

[ |ψi, Ψ, M N ] →p [ |ψ
0i, Ψ0
, Nin ]
[ |ψi, Ψ,hM, Nin ] →p [ |ψ
[ |ψi, Ψ, let hxA, yBin = M in N ] →p [ |ψ
[ |ψi, Ψ, inln
[ |ψi, Ψ, inrn
[ |ψi, Ψ, match M withn(xA 7→ N | yB 7→ L) ] →p [ |ψ

A,B(M) ] →p [ |ψ
A,B(M) ] →p [ |ψ

0i, Ψ0
0) ]
0) ]

A,B(M
A,B(M

, inln
, inrn

0i, Ψ0
0i, Ψ0

[ |ψi, Ψ, V M ] →p [ |ψ

0i, Ψ0

0 ]
, V M
[ |ψi, Ψ,hV, Min ] →p [ |ψ
0i, Ψ0
, let hxA, yBin = M
0 in N ]

,hV, M

0in ]

6

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

xA.M)V ] →1 [ |ψi, Ψ, M[V /x] ]

[ |ψi, Ψ, (λ
0
[ |ψi, Ψ, let hxA, yBin = hV, Win in M ] →1 [ |ψi, Ψ, M[V /x, W/y] ]
[ |ψi, Ψ, match inln
[ |ψi, Ψ, match inrn

A,B(V ) withn(xA 7→ M | yB 7→ N) ] →1 [ |ψi, Ψ, M[V /x] ]
A,B(W ) withn(xA 7→ M | yB 7→ N) ] →1 [ |ψi, Ψ, N[W/y] ]

(a) Classical control

k

1

, . . . , xqbit

i0 ] →1 [ |ψ

[ |ψi, Ψ, U qbit⊗k(cid:40)qbit⊗khxqbit
[ |ψi,|x1 . . . xmi, measqbit(cid:40)!nbit xqbit
[ |ψi,|x1 . . . xmi, measqbit(cid:40)!nbit xqbit
[ |ψi,|x1 . . . xmi, newA(cid:40)qbit ˜ff ] →1 [ |ψi|0i,|x1 . . . xmyi, yqbit ]
[ |ψi,|x1 . . . xmi, newA(cid:40)qbit ˜tt ] →1 [ |ψi|1i,|x1 . . . xmyi, yqbit ]

] →p0 [ |ψ0i,|x1 . . . xmi, ffn ]
] →p1 [ |ψ1i,|x1 . . . xmi, ttn ]

0i, Ψ,hxqbit

1

i

i

, . . . , xqbit

k

i0 ]

((cid:40))
(⊗)
(⊕1)
(⊕2)

(U)
(meas0)
(meas1)
(new0)
(new1)

(b) Quantum data
If [ |ψi, Ψ, M ] →p [ |ψ0i, Ψ0, M0 ], the following are valid reductions (if well-formed).

0i, Ψ0

, match M

0 withn(xA 7→ N | yB 7→ L) ]

(c) Congruence rules

Table 3 Reduction rules

Ψ is a list of m distinct variables, written as |x1 . . . xmi. We write |Ψ| = {x1, . . . , xm},
and Ψ(xi) = i for the position of a variable in the list.
M is a term with FV(M) ⊆ |Ψ|.

We say a quantum closure P = [|ψi,|x1 . . . xmi, M ] is well-typed of type A, written as P : A,
if the typing judgement x1 : qbit, . . . , xm : qbit (cid:66) M : A is valid. We call [|ψi, Ψ, V ] a
value closure if V is a value.

(cid:73) Deﬁnition 5. A (small-step) reduction P →p Q consists of quantum closures P, Q and
p ∈ [0, 1], meaning that P reduces to Q with probability p. The valid reductions P →p Q
are given inductively by the reduction rules shown in Table 3. In the rules, V and W refer
to values. The ‘quantum data’ rules (b) correspond to the three basic operations explained
in §2. In the rule (U), |ψ0i is the state obtained by applying the 2k × 2k unitary matrix U to
the k qubits of the position Ψ(x1), . . . , Ψ(xk) in |ψi. In the rule (meas0), p0 is the probability
that we obtain 0 (‘negative’ in terms of §2) by measuring the i-th qubit of |ψi; and |ψ0i is
the state after that. The rule (meas1) is similar. In the rule (new0), we denote by ˜ff any
term of the form inln!k>,!h>(∗n+k) (cf. Notation 2). The term ˜tt in (new1) is similar.

Reduction satisﬁes the following properties.

(cid:73) Lemma 6 (Subject reduction). If P : A and P →p Q, then Q : A.
(cid:74)
(cid:73) Lemma 7 (Progress). Let P : A be a well-typed quantum closure. Then either P is a value
closure, or there exists a quantum closure Q such that P →p Q. In the latter case, there are

K. Cho and A. Westerbaan

7

at most two (up to α-equivalence) single-step reductions from P, and the total probability of
(cid:74)
all the single-step reductions from P is 1.

The next deﬁnitions follow [37,39].

(cid:73) Deﬁnition 8. We deﬁne the small-step reduction probability prob(P, Q) ∈ [0, 1] for well-
typed quantum closures P, Q by: prob(P, Q) = p if P →p Q; prob(V, V ) = 1 if V is a value
closure; prob(P, Q) = 0 otherwise. Lemma 7 guarantees that prob is a probabilistic system in
a suitable sense. For a well-typed quantum closure P and a well-typed value closure Z, the big-
step reduction probability Prob(P, Z) ∈ [0, 1] is deﬁned by Prob(P, Z) = limn→∞ probn(P, Z),

where prob1(P, Z) = prob(P, Z) and probn+1(P, Z) =P

Q prob(P, Q) probn(Q, Z).

(cid:73) Deﬁnition 9. For each b ∈ {ff0
the set of well-typed quantum closures of the form [|ψi, Ψ, b ].

, tt0}, we deﬁne P ⇓ b =P

Z∈Ub

Prob(P, Z), where Ub is

We will use a strong normalisation result. The proof is similar to [27, Lemma 33].

(cid:73) Lemma 10 (Strong normalisation). Let P : A be a well-typed quantum closure. Then there
is no inﬁnite sequence of reductions P →p1 P1 →p2 P2 →p3 ··· .
Proof (Sketch). Clearly it suﬃces to prove the strong normalisation for the underlying (non-
deterministic) reductions M → N on terms. We add a constant cqbit to replace free variables
xqbit. We then deﬁne a translation (−)† from the quantum lambda calculus (with cqbit) to a
simply-typed lambda calculus with product, unit, sum types and constants new, meas, U, cqbit.
The translation (−)† forgets the ! modality, and translates the let constructor via (let hx, yi =
N in M)† = (λz.(λx.λy.M†) fst(z) snd(z))N†. We can prove the strong normalisation for
(cid:74)
the simply-typed lambda calculus via standard techniques.

4 Denotational Semantics Using von Neumann Algebras
4.1 Facts about von Neumann Algebras
We need the following notation and facts concerning von Neumann algebras. Those facts for
which we could not ﬁnd proof in the literature will be discussed in the next section.
Let (vNAMIU,⊗, C) be the symmetric monoidal category (SMC) of von Neumann algebras
and normal MIU-maps [18, Prop. 7.2], and (vNACPsU,⊗, C) the SMC of von Neumann
algebras and normal CPsU-maps (where ⊗ is the spatial tensor product) [4]. Note that the
unit C is initial in vNAMIU (but not in vNACPsU). Both categories have products given by
direct sums ⊕ (with the supremum norm [41, Def. 3.4]). To interpret the quantum lambda
calculus, we will use the following pair of (lax) symmetric monoidal adjunctions,

(Setop

,×, 1)

nsp
⊥
‘∞

(vNAMIU,⊗, C)

F
⊥
J

(vNACPsU,⊗, C)

(1)

where Setop is the opposite of the category Set of sets and functions, considered as a SMC
via cartesian products (i.e. coproducts in Setop). The functor J is the inclusion functor; the
other functors are explained in the next section. Note that J is strict symmetric monoidal
and strictly preserves products. The following facts are important:

vNAMIU is a co-closed SMC [18]. This means the endofunctor (−) ⊗ A on vNAMIU
has a left adjoint (−)∗A . The von Neumann algebra B∗A is called the free exponential
in [18].

0
0
q
q

|
0
0
q
q
8

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

B f−→ C ⊗ A in vNACPsU
FB −→ C ⊗ A in vNAMIU

The counit of the adjunction nsp a ‘∞ is an isomorphism (see Corollary 21).
The functors nsp, ‘∞ and the adjunction nsp a ‘∞ are strong monoidal (see Corollary 23).
Moreover, the functors nsp and ‘∞ preserves products (see Cor. 20 and Lem. 22).
The tensor product ⊗ distributes over products ⊕ in vNAMIU, as A ⊗ (B ⊕ C ) ∼=
(A ⊗ B)⊕ (A ⊗ C ), since A ⊗ (−) is a right adjoint and thus preserves products. We denote
the canonical isomorphism by θA ,B,C : (A ⊗ B) ⊕ (A ⊗ C ) → A ⊗ (B ⊕ C ).
We deﬁne a ‘Kleisli co-exponential’ (cid:40) by
A (cid:40) B := (FB)∗A . We have the bijective
correspondence as shown on the right. We
write Λf = g for the MIU-map A (cid:40) B → C
(FB)∗A = A (cid:40) B g−→ C in vNAMIU
corresponding to f. We also write εA ,B =
Λ−1id: B → (A (cid:40) B) ⊗ A for the co-evaluation map, i.e. the CPsU-map correspond-
ing to id: A (cid:40) B → A (cid:40) B. Then (Λf ⊗ id) ◦ ε = f by the naturality of the bijective
correspondence.
We write L = ‘∞ ◦ nsp for the strong symmetric monoidal monad on vNAMIU induced
by the left-hand adjunction of (1). The unit and multiplication are denoted by η and µ
respectively. From the fact that the counit of nsp a ‘∞ is an isomorphism, it easily follows
that L is an idempotent monad, i.e. the multiplication µ: L2 ⇒ L is an isomorphism. Note
also that L preserves products. We denote the structure isomorphisms by: dLC : C → LC;
A ,B : LA ⊗ LB → L(A ⊗ B); and eL
dL
Because the adjunction nsp a ‘∞ satisﬁes a dual condition to a linear-non-linear model [1]
(see also [23,33]), the monad L has a property which is dual to a linear exponential comonad.
Thus each object of the form LA is equipped with a map (cid:79)A : LA ⊗ LA → LA which,
with a unique map !LA : C → LA , makes LA into a ⊗-monoid in vNAMIU.
(cid:73) Remark 11. One can summarise these facts by saying that the opposite vNAop
MIU is a
(weak) linear category for duplication [38,40]; and moreover vNAop
MIU is a concrete model
of the quantum lambda calculus deﬁned by Selinger and Valiron [40, §1.6.8]. Although they
gave the deﬁnition of concrete models of the quantum lambda calculus, results on them (e.g.
how to interpret the quantum lambda calculus; adequacy of models) have never been given.
In the remainder of the section, therefore, we will give the interpretation of the language in
von Neumann algebras concretely, and then prove its adequacy.

A ,B : LA ⊕ LB → L(A ⊕ B).

4.2 The Interpretation of Types and Typing Judgements
We interpret types as von Neumann algebras, i.e. objects in vNAMIU / vNACPsU, as follows.

(cid:74)!A(cid:75) = L(cid:74)A(cid:75)
(cid:74)A ⊕ B(cid:75) =(cid:74)A(cid:75) ⊕(cid:74)B(cid:75)

(cid:74)qbit(cid:75) = M2
(cid:74)A (cid:40) B(cid:75) =(cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75)
(cid:73) Remark. One familiar with Fock space might be surprised to realise that(cid:74)!qbit(cid:75) = {0},

because there is no normal MIU-map ϕ: M2 → C. The intuition here may be that no part of
a qubit can be duplicated, and so the assumption of a duplicable qubit amounts to nothing.
This is also the interpretation of !qbit intended by Selinger and Valiron, see [38, §5].
(cid:73) Remark. The interpretation of a function type A (cid:40) B is obtained by abstract means,
and at this point we know very little about it. (Might it be as intangible as an ultraﬁlter?)
However, applying ! makes the function type almost trivial: after §4, it will be clear that

(cid:74)>(cid:75) = C

(cid:74)A ⊗ B(cid:75) =(cid:74)A(cid:75) ⊗(cid:74)B(cid:75)

(cid:74)!(A (cid:40) B)(cid:75) = ‘∞({ f :(cid:74)B(cid:75) CPsU−→ (cid:74)A(cid:75)}).

K. Cho and A. Westerbaan

9

given in §2, as follows.

map dL

C ◦ LΛ(fmeas ◦ η−1

in vNAMIU, which exists uniquely by a coherence property for an idempotent (co)monad;

C2 ):(cid:74)!Ameas(cid:75) = L(M2 (cid:40) LC2) −→ C

C ◦ LΛfnew :(cid:74)!Anew(cid:75) = L(C2 (cid:40) M2) −→ C
C ◦ LΛfU :(cid:74)!AU(cid:75) = L(M⊗k2 (cid:40) M⊗k2 ) −→ C

treat the monoidal structure (⊗, C) as if it were strict monoidal, which is justiﬁed by the
coherence theorem for monoidal categories.
fnew : M2 → C2, fmeas : C2 → M2 and fU : M⊗k2 → M⊗k2

The interpretation of the subtyping relation A <: B is a ‘canonical’ map (cid:74)B(cid:75) →(cid:74)A(cid:75)
see [42, §8.3.2] for details. For instance, we have(cid:74)A (cid:40) !B <: !A (cid:40) !!B(cid:75) = η(cid:74)A(cid:75) (cid:40) µ(cid:74)B(cid:75).
Contexts ∆ = x1 : A1, . . . , xn : An are interpreted as(cid:74)∆(cid:75) =(cid:74)A1(cid:75) ⊗ ··· ⊗(cid:74)An(cid:75). We shall
The interpretations (cid:74)new(cid:75), (cid:74)meas(cid:75) and (cid:74)U(cid:75) of constants are deﬁned using the maps
(cid:74)new(cid:75) = η−1
(cid:74)meas(cid:75) = η−1
(cid:74)U(cid:75) = η−1
We now give the interpretation(cid:74)∆ (cid:66) M : A(cid:75) of a typing judgement as a map(cid:74)A(cid:75) →
(cid:74)∆(cid:75) in vNACPsU. The deﬁnition is similar to [11]. First we deﬁne a normal CPsU-map
(cid:74)∆ (cid:66) M : A(cid:75)FV :(cid:74)A(cid:75) → (cid:74)∆|M(cid:75) (recall that ∆|M = ∆ ∩ FV(M)) by induction on the
derivation of the typing judgement as shown in Table 4. We then deﬁne(cid:74)∆ (cid:66) M : A(cid:75) :=
((cid:74)A(cid:75) (cid:74)∆(cid:66)M:A(cid:75)FV
−−−−−−−−→(cid:74)∆|M(cid:75) ι−→(cid:74)∆(cid:75)). Here and in Table 4, we use the following notations (often
contexts ∆ ⊆ Γ, we write ι:(cid:74)∆(cid:75) →(cid:74)Γ(cid:75) for the ‘injection’ map deﬁned via unique MIU-maps
!A : C → A . For a context !∆, Γ1, Γ2, we deﬁne the map merge:(cid:74)!∆, Γ1(cid:75) ⊗(cid:74)!∆, Γ2(cid:75) →
(cid:74)!∆, Γ1, Γ2(cid:75) via monoid structures (cid:79)(cid:74)A(cid:75) :(cid:74)!A(cid:75) ⊗(cid:74)!A(cid:75) →(cid:74)!A(cid:75) and symmetry maps γ. The
∆ :(cid:74)!∆(cid:75) → L(cid:74)∆(cid:75) can be deﬁned using dL
A ,B : LA ⊗ LB → L(A ⊗ B). We write
µ∆ :(cid:74)!!∆(cid:75) →(cid:74)!∆(cid:75) for µ(cid:74)A1(cid:75)⊗···⊗µ(cid:74)An(cid:75); dLn : LnA ⊗LnB → Ln(A ⊗B) for Ln−1
dL◦···◦dL;
and eLn : LnA ⊕LnB → Ln(A ⊕ B) similarly. Projection maps and tupling for direct sums,
products in vNACPsU, are denoted by πi : A1 ⊕ A2 → Ai and hf, gi: A → B ⊕ C .
Note that the interpretation(cid:74)∆ (cid:66) M : A(cid:75) is deﬁned by induction on typing derivations.

suppressing subscripts). Let γA ,B : A ⊗ B → B⊗ A denote the symmetry isomorphism. For

Because we use indexed terms, it is not hard to prove the following fact by induction on a
typing derivation Π.
(cid:73) Lemma 12. Suppose that ∆ (cid:66) M : A is valid with a derivation Π, and so is ∆0 (cid:66) M : A

with Π0. Then(cid:74)Π0(cid:75)FV = σ ◦(cid:74)Π(cid:75)FV, where σ :(cid:74)∆|M(cid:75) →(cid:74)∆0|M(cid:75) is a (unique by coherence)
isomorphism that permutes ∆|M to ∆0|M. In particular,(cid:74)∆ (cid:66) M : A(cid:75) is well-deﬁned, not

(cid:74)
Let [|ψi,|x1 . . . xni, M ] : A be a well-typed quantum closure. The mapping A 7→ hψ|A|ψi
deﬁnes a normal CPU-map hψ|−|ψi: M⊗m2 → C. The interpretation of the quantum closure
is deﬁned by:

depending on derivations.

hψ|−|ψi
−−−−−→ C

−−−−−−−−−−−−−−−−−→ M⊗n2

4.3 Adequacy of the Denotational Semantics
The next soundness/invariance for the small-step reduction is a key result to obtain adequacy.
i ri ≤ 1, the
i rifi of maps is deﬁned in the obvious pointwise manner and is a normal

(cid:74)[|ψi,|x1 . . . xni, M ] : A(cid:75) := (cid:74)A(cid:75) (cid:74)x1:qbit,...,xn:qbit(cid:66)M:A(cid:75)
Note that for normal CPsU-maps f1, . . . , fn : A → B and ri ∈ [0, 1] with P
(convex) sumP
closure. Then(cid:74)P : A(cid:75) =P

CPsU-map.
(cid:73) Proposition 13 (Soundness for the small-step reduction). Let P : A be a well-typed quantum

Q prob(P, Q)(cid:74)Q : A(cid:75).

10

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

L(Λf0)

f0

ι

−−−−−→ C

−−−−−→(cid:74)A(cid:75)

(cid:74)∆, y : B, x : A, Γ (cid:66) M : C(cid:75)FV = (id(cid:74)∆|M(cid:75) ⊗ γ ⊗ id(cid:74)Γ|M(cid:75)) ◦ f (if x, y ∈ FV(M)); f (otherwise)
−−−−−−→(cid:74)!Ac(cid:75) (cid:74)c(cid:75)−−→ C
(cid:74)∆, x : A (cid:66) xB : B(cid:75)FV =(cid:74)B(cid:75) (cid:74)A<:B(cid:75)
((cid:74)(∆, x : A)|M(cid:75)
(cid:74)∆|M(cid:75) ⊗(cid:74)A(cid:75)
−−−−−−−−−−−−−−−−→ L((cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75))

(cid:74)∆, x : A, y : B, Γ (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) f−→(cid:74)(∆, x : A, y : B, Γ)|M(cid:75)
(cid:74)∆ (cid:66) cB : B(cid:75)FV =(cid:74)B(cid:75) (cid:74)!Ac<:B(cid:75)
−−−−−−−→ LC (dLC )−1
where: (cid:74)B(cid:75) f /
(cid:74)Γ, !∆, x : A (cid:66) M : B(cid:75)FV =(cid:74)B(cid:75) f−→(cid:74)(Γ, !∆, x : A)|M(cid:75)
xA.M : A (cid:40) B(cid:75)FV =(cid:74)!n+1(A (cid:40) B)(cid:75) (cid:74)!(A(cid:40)B)<:!n+1(A(cid:40)B)(cid:75)
(cid:74)!∆, Γ1 (cid:66) M : A (cid:40) B(cid:75)FV =(cid:74)A (cid:40) B(cid:75) f−→(cid:74)(!∆, Γ1)|M(cid:75)

(cid:74)∆ (cid:66) ∗n : !n>(cid:75)FV =(cid:74)!n>(cid:75) (cid:74)!><:!n>(cid:75)
(cid:74)∆, x : A (cid:66) M : B(cid:75)FV =(cid:74)B(cid:75) f−→(cid:74)(∆, x : A)|M(cid:75)
(cid:74)∆ (cid:66) λ0xA.M : A (cid:40) B(cid:75)FV =(cid:74)A(cid:75) (cid:40)(cid:74)B(cid:75) Λf0−−→(cid:74)∆|M(cid:75)
(cid:74)Γ, !∆ (cid:66) λn+1

−−−−−→(cid:74)!!∆|M(cid:75) µ−→(cid:74)!∆|M(cid:75) =(cid:74)(!∆, Γ)|M(cid:75)
(cid:74)!∆, Γ2 (cid:66) N : A(cid:75)FV =(cid:74)A(cid:75) g−→(cid:74)(!∆, Γ2)|N(cid:75)

−−−−→ L(cid:74)!∆|M(cid:75) (dL)−1

(cid:74)!∆, Γ1, Γ2 (cid:66) M N : B(cid:75)FV =(cid:74)B(cid:75) ε−→(cid:74)A (cid:40) B(cid:75) ⊗(cid:74)A(cid:75) f⊗g−−−→(cid:74)(!∆, Γ1)|M(cid:75) ⊗(cid:74)(!∆, Γ2)|N(cid:75)

ι⊗ι−−→(cid:74)(!∆, Γ1)|M N(cid:75) ⊗(cid:74)(!∆, Γ2)|M N(cid:75) merge−−−−→(cid:74)(!∆, Γ1, Γ2)|M N(cid:75)

(cid:74)!∆, Γ1 (cid:66) M : !nA(cid:75)FV =(cid:74)!nA(cid:75) f−→(cid:74)(!∆, Γ1)|M(cid:75)
(cid:74)!∆, Γ2 (cid:66) N : !nB(cid:75)FV =(cid:74)!nB(cid:75) g−→(cid:74)(!∆, Γ2)|N(cid:75)
−−−−−−→(cid:74)!nA(cid:75) ⊗(cid:74)!nB(cid:75) f⊗g−−−→
(cid:74)!∆, Γ1, Γ2 (cid:66) hM, Nin : !n(A ⊗ B)(cid:75)FV =(cid:74)!n(A ⊗ B)(cid:75) (dLn )−1
(cid:74)(!∆, Γ1)|M(cid:75) ⊗(cid:74)(!∆, Γ2)|N(cid:75) ι⊗ι−−→(cid:74)(!∆, Γ1)|hM,Ni(cid:75) ⊗(cid:74)(!∆, Γ2)|hM,Ni(cid:75) merge−−−−→(cid:74)(!∆, Γ1, Γ2)|hM,Ni(cid:75)
(cid:74)!∆, Γ1, x : !nA, y : !nB (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) f−→(cid:74)(!∆, Γ1, x : !nA, y : !nB)|M(cid:75)
(cid:74)!∆, Γ1, Γ2 (cid:66) let hxA, yBin = N in M : C(cid:75)FV =(cid:74)C(cid:75) f−→(cid:74)(!∆, Γ1, x : !nA, y : !nB)|M(cid:75)
ι−→(cid:74)(!∆, Γ1)|let...(cid:75) ⊗(cid:74)!nA(cid:75) ⊗(cid:74)!nB(cid:75) id⊗dLn
−−−−−→(cid:74)(!∆, Γ1)|let...(cid:75) ⊗(cid:74)!n(A ⊗ B)(cid:75) id⊗g−−−→
(cid:74)(!∆, Γ1)|let...(cid:75) ⊗(cid:74)(!∆, Γ2)|N(cid:75) id⊗ι−−−→(cid:74)(!∆, Γ1)|let...(cid:75) ⊗(cid:74)(!∆, Γ2)|let...(cid:75) merge−−−−→(cid:74)(!∆, Γ1, Γ2)|let...(cid:75)

(cid:74)!∆, Γ2 (cid:66) N : !n(A ⊗ B)(cid:75)FV =(cid:74)!n(A ⊗ B)(cid:75) g−→(cid:74)(!∆, Γ2)|M(cid:75)

(f

0 deﬁned similarly)

(cid:74)∆ (cid:66) inln
(cid:74)∆ (cid:66) inrn

(cid:74)∆ (cid:66) M : !nA(cid:75)FV =(cid:74)!nA(cid:75) f−→(cid:74)∆|M(cid:75)
(cid:74)∆ (cid:66) N : !nB(cid:75)FV =(cid:74)!nB(cid:75) g−→(cid:74)∆|N(cid:75)

A,B(M) : !n(A ⊕ B)(cid:75)FV =(cid:74)!n(A ⊕ B)(cid:75) Lnπ1−−−→(cid:74)!nA(cid:75) f−→(cid:74)∆|M(cid:75)
A,B(N) : !n(A ⊕ B)(cid:75)FV =(cid:74)!n(A ⊕ B)(cid:75) Lnπ2−−−→(cid:74)!nB(cid:75) g−→(cid:74)∆|N(cid:75)
(cid:74)!∆, Γ1, x : !nA (cid:66) M : C(cid:75)FV =(cid:74)C(cid:75) f−→(cid:74)(!∆, Γ1, x : !nA)|M(cid:75)
(cid:74)!∆, Γ1, y : !nB (cid:66) N : C(cid:75)FV =(cid:74)C(cid:75) g−→(cid:74)(!∆, Γ1, y : !nB)|N(cid:75)
(cid:74)!∆, Γ2 (cid:66) L : !n(A ⊕ B)(cid:75)FV =(cid:74)!n(A ⊕ B)(cid:75) h−→(cid:74)(!∆, Γ2)|L(cid:75)

(cid:74)!∆, Γ1, Γ2 (cid:66) match L withn(xA 7→ M | yB 7→ N) : C(cid:75)FV =
(cid:74)C(cid:75) hf,gi−−−→(cid:74)(!∆, Γ1, x : !nA)|M(cid:75) ⊕(cid:74)(!∆, Γ1, y : !nB)|N(cid:75) ι⊕ι−−→
((cid:74)(!∆, Γ1)|match...(cid:75) ⊗(cid:74)!nA(cid:75)) ⊕ ((cid:74)(!∆, Γ1)|match...(cid:75) ⊗(cid:74)!nB(cid:75)) θ−→(cid:74)(!∆, Γ1)|match...(cid:75) ⊗ ((cid:74)!nA(cid:75) ⊕(cid:74)!nB(cid:75))
−−−−−→(cid:74)(!∆, Γ1)|match...(cid:75) ⊗(cid:74)!n(A ⊕ B)(cid:75) id⊗h−−−→(cid:74)(!∆, Γ1)|match...(cid:75) ⊗(cid:74)(!∆, Γ2)|L(cid:75)
id⊗ι−−−→(cid:74)(!∆, Γ1)|match...(cid:75) ⊗(cid:74)(!∆, Γ2)|match...(cid:75) merge−−−−→(cid:74)(!∆, Γ1, Γ2)|match...(cid:75)

id⊗eLn

Table 4 Inductive deﬁnition of the interpretation of typing judgements

/
(

K. Cho and A. Westerbaan

11

(cid:74)
Proof. See Appendix A.
(cid:73) Proposition 14 (Soundness for the big-step reduction). Let P : A be a well-typed quantum

Proof. By Lemmas 7 and 10, Prob(P, Z) def= limn→∞ probn(P, Z) = probm(P, Z) for some
(cid:74)
Proposition 13.
(cid:73) Theorem 15 (Adequacy). Let P : bit be a quantum closure of type bit. For the interpret-

closure. Then(cid:74)P : A(cid:75) =P
Z Prob(P, Z)(cid:74)Z : A(cid:75), where Z runs over well-typed value closures.
m. It is then easy to obtain(cid:74)P : A(cid:75) =P
Q probm(P, Q)(cid:74)Q : A(cid:75) by induction on m, using
ation(cid:74)P : bit(cid:75): C ⊕ C → C, we have P ⇓ ff =(cid:74)P : bit(cid:75)(1, 0) and P ⇓ tt =(cid:74)P : bit(cid:75)(0, 1).
Proof. By Proposition 14 we have(cid:74)P : bit(cid:75) =P
Z Prob(P, Z)(cid:74)Z : bit(cid:75). Note that for each
follows since(cid:74)[|ψi, Ψ, ff0 ] : bit(cid:75)(λ, ρ) = λ and(cid:74)[|ψi, Ψ, tt0 ] : bit(cid:75)(λ, ρ) = ρ.

well-typed value closure [|ψi, Ψ, V ] : bit, either V = ff0 or V = tt0. Then the assertion
(cid:74)

Technical Results about von Neumann Algebras
5
Let us sketch how we obtained the two monoidal adjunctions in (1).
(cid:73) Deﬁnition 16. Let ‘∞(X) denote the von Neumann algebra of bounded maps f : X →
C on a set X. Addition, multiplication, involution, suprema, and so on, are computed
coordinatewise in ‘∞(X). In fact, ‘∞(X) is simply the X-fold product in vNAMIU of C with
ϕ 7→ ϕ(x) as x-th projection. We extend X 7→ ‘∞(X) to a functor ‘∞ : Setop → vNAMIU
by deﬁning ‘∞(f)(ϕ) = ϕ ◦ f for every map f : X → Y (in Set) and ϕ ∈ ‘∞(Y ).
Let nsp(A ) be the ‘normal spectrum’ of a von Neumann algebra A , i.e. the set of normal
MIU-maps ϕ: A → C. We extend A 7→ nsp(A ) to a functor nsp: vNAMIU → Setop by
deﬁning nsp(f)(ϕ) = ϕ ◦ f for every normal MIU-map f : A → B and ϕ ∈ nsp(B) (it is
simply a hom-functor vNAMIU(−, C)).

Note that any normal MIU-map f : A → ‘∞(X) gives a map g : X → nsp(A ) by

“swapping arguments” — g(x)(ϕ) = f(ϕ)(x) — and with a little bit more work, we get:
(cid:73) Lemma 17. There is an adjunction nsp a ‘∞.

(cid:74)

i∈I

The following two lemmas describe the normal spectrum of direct products and tensors

each ω ∈ nsp(L

Ai), there is i ∈ I and ˜ω ∈ nsp(Ai) with ω = ˜ω ◦ πi.

of von Neumann algebras, and can be proven using standard techniques.
(cid:73) Lemma 18. Let I be a set, and for each i ∈ I, let Ai be a von Neumann algebra. For
(cid:74)
(cid:73) Lemma 19. Let A1 and A2 be von Neumann algebras. Then for every ω ∈ nsp(A1 ⊗ A2)
there are unique ω1 ∈ A1 and ω2 ∈ A2 with ω(a1 ⊗ a2) = ω1(a1) · ω2(a2) for all ai ∈ Ai. (cid:74)
(cid:73) Corollary 20. The functor nsp: vNAMIU → Setop preserves products, and tensors. (cid:74)
Using that ‘∞(X) is the X-fold product of C in vNAMIU we get:
(cid:73) Corollary 21. The counit of the adjunction nsp a ‘∞ is an isomorphism.
(cid:73) Lemma 22. Let X and Y be sets. There is a normal MIU-isomorphism

ϕ: ‘∞(X) ⊗ ‘∞(Y ) −→ ‘∞(X × Y )

given by

ϕ(f ⊗ g)(x, y) = f(x) · g(y).

Proof. Use the proof of Proposition 9.2 from [4].

(cid:74)

(cid:74)

12

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

(cid:73) Corollary 23. The adjunction nsp a ‘∞ is strong monoidal.
(cid:74)
Let us turn to the second adjunction in (1). In [45] it is shown how the following result
follows from Freyd’s Adjoint Functor Theorem (see Theorem V.6.2 of [20]).
(cid:73) Theorem 24 ([45]). The inclusion J : vNAMIU → vNACPsU has a left adjoint.
(cid:74)
(cid:73) Corollary 25. The category vNACPsU is isomorphic to the co-Kleisli category of the
comonad F ◦ J on vNAMIU induced by F a J .
(cid:74)
Proof. See Theorem 9 of [45], or do Exercise VI.5.2 of [20] (and use the fact that an
(cid:74)
equivalence of categories which is bijective on objects is an isomorphism).
(cid:73) Corollary 26. The adjunction F a J is symmetric monoidal.
Proof. Clearly, J : vNAMIU → vNACPsU is strict symmetric monoidal. From this fact
alone, it follows that the adjunction F a J is symmetric monoidal, see Prop. 14 of [24]. (cid:74)
In our model of the quantum lambda calculus the von Neumann algebras of the form
‘∞(X) serve as the interpretation of the duplicable types (of the form !A), because ‘∞(X)
carries a ⊗-monoid structure. Among all von Neumann algebras ‘∞(X) is arguably quite
special and one might wonder if there is a broader class of von Neumann algebras that might
serve as the interpretation of duplicable types (such as the class of all commutative von
Neumann algebras, which includes L∞[0, 1]). The following result settles this matter: no.
Due to space constraints, the proof will appear somewhere else.
(cid:73) Theorem 27. For a von Neumann algebra A the following are equivalent.
1. There is a duplicator on A , that is, a normal positive unital map µ: A ⊗ A → A such
that µ(1 ⊗ a) = a = µ(a ⊗ 1) and µ(a ⊗ µ(b ⊗ c)) = µ(µ(a ⊗ b) ⊗ c) for all a, b, c ∈ A .

2. A is isomorphic to ‘∞(X) for some set X.
Moreover, there is at most one duplicator on A .
(cid:73) Corollary 28. ‘∞(nsp(A )) is the free ⊗-monoid on A from vNAMIU.

(cid:74)
(cid:74)

Final Remarks

6
We have given a rather concrete proof of adequacy for the sake of clarity. However, it
seems that we only used the fact that vNAMIU is a ‘concrete model of the quantum lambda
calculus’ (see Remark 11), and that vNACPsU is ‘suitably’ enriched over convex sets. Thus
an abstract result might be distilled from our work stating that any concrete model of the
quantum lambda calculus is adequate when suitably enriched over convex sets, but we have
not pursued this.

We believe selling points of our model are that it is a model for Selinger and Valiron’s
original quantum lambda calculus [37] (in Selinger and Valiron’s linear fragment [39] the
! modality is absent; in Hasuo and Hoshino’s language [10] the tensor type qbit ⊗ qbit
does not represent two qubits; and only function types may be duplicable, !(A (cid:40) B), in the
language of Pagani et al. [27]); that it is adequate (Malherbe’s model [21,22] is not known to
be); that the interpretation of ! is rather simple; and that it is formed using von Neumann
algebras, a mathematical classic.

We believe our model could be improved by a more concrete description of(cid:74)A (cid:40) B(cid:75) (as

all the other models have), and by features such as recursion and inductive types (present
in e.g. Hasuo and Hoshino’s and Pagani’s models), which leaves us with ample material for
future research.

K. Cho and A. Westerbaan

13

Acknowledgements We thank Chris Heunen for spotting a typo.

1

References
P. N. Benton. A mixed linear and non-linear logic: Proofs, terms and models. In CSL ’94,
volume 933 of LNCS, pages 121–135. Springer, 1995.

2 Garrett Birkhoﬀ and John von Neumann. The logic of quantum mechanics. Annals of

mathematics, pages 823–843, 1936.

3 Max Born and Pascual Jordan. Zur quantenmechanik. Zeitschrift für Physik, 34(1):858–888,

1925.

4 Kenta Cho. Semantics for a quantum programming language by operator algebras. In QPL

2014, volume 172 of EPTCS, pages 165–190, 2014.

6

5 Kenta Cho, Bart Jacobs, Bas Westerbaan, and Abraham Westerbaan. Quotient-

comprehension chains. In QPL 2015, volume 195 of EPTCS, pages 136–147, 2015.
John Dauns. Categorical w∗-tensor product. Transactions of the American Mathematical
Society, 166:439–456, 1972.
John Dauns. Enveloping W ∗-algebras. Journal of Mathematics, 8(4), 1978.

7
8 David J. Foulis and Mary K. Bennett. Eﬀect algebras and unsharp quantum logics. Found-

ations of Physics, 24(10):1331–1352, 1994.

9 Alain Guichardet. Sur la catégorie des algebres de von Neumann. Bull. Sci. Math, 90(2):41–

64, 1966.
Ichiro Hasuo and Naohiko Hoshino. Semantics of higher-order quantum computation via
geometry of interaction. In LICS 2011, pages 237–246. IEEE, 2011.
Ichiro Hasuo and Naohiko Hoshino. Semantics of higher-order quantum computation via
geometry of interaction. Extended version of [10], preprint, 2014.

12 Werner Heisenberg. Quantum-theoretical re-interpretation of kinematic and mechanical

relations. Z. Phys, 33:879–893, 1925.
Pascual Jordan. Über verallgemeinerungsmöglichkeiten des formalismus der quantenmech-
anik. Weidmann, 1933.

14 Richard V. Kadison. A representation theory for commutative topological algebra. American

10

11

13

Mathematical Society, 1951.

15 Richard V. Kadison and John R. Ringrose. Fundamentals of the theory of operator algebras:

Advanced theory, volume 2. American Mathematical Society, 1997.

17

16 Richard V. Kadison and John R. Ringrose. Fundamentals of the Theory of Operator Algeb-

ras: Elementary Theory, volume 1. American Mathematical Society, 1997.
Irving Kaplansky. Projections in Banach algebras. Annals of Mathematics, pages 235–249,
1951.

18 Andre Kornell. Quantum collections. arXiv preprint arXiv:1202.2994v1, 2012.
19

Falko Lorenz. Die epimorphismen der ringe von operatoren. Archiv der Mathematik,
20(1):48–53, 1969.
Saunders Mac Lane. Categories for the working mathematician. Springer, second edition,
1998.

21 Octavio Malherbe. Categorical models of computation: partially traced categories and

20

presheaf models of quantum computation. PhD thesis, University of Ottawa, 2010.

23

22 Octavio Malherbe, Philip Scott, and Peter Selinger. Presheaf models of quantum compu-
tation: An outline. In Computation, Logic, Games, and Quantum Foundations. The Many
Facets of Samson Abramsky, volume 7860 of LNCS, pages 178–194. Springer, 2013.
Paul-André Melliès. Categorical models of linear logic revisited. Available on the author’s
website, 2002.
Paul-André Melliès. Categorical semantics of linear logic. Panoramas et synthèses, 27:1–
196, 2009.

24

14

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

25

Francis J. Murray and John von Neumann. On rings of operators. Annals of Mathematics,
pages 116–229, 1936.

26 Michael A Nielsen and Isaac L Chuang. Quantum computation and quantum information.

Cambridge university press, 2010.

27 Michele Pagani, Peter Selinger, and Benoît Valiron. Applying quantitative semantics to

higher-order quantum computing. In POPL 2014, pages 647–658. ACM, 2014.

28 William L Paschke. Inner product modules over B∗-algebras. Transactions of the American

Mathematical Society, 182:443–468, 1973.

29 Vern Paulsen. Completely bounded maps and operator algebras, volume 78. Cambridge

University Press, 2002.

30 Mathys Rennela. Towards a quantum domain theory: Order-enrichment and ﬁxpoints in

31

W ∗-algebras. Electronic Notes in Theoretical Computer Science, 308:289–307, 2014.
Zhong-Jin Ruan. Subspaces of C∗-algebras. Journal of functional analysis, 76(1):217–230,
1988.
Shôichirô Sakai. C∗-algebras and W ∗-algebras. Springer, 2012.

32
33 Andrea Schalk. What is a categorical model of linear logic? Available on the author’s

website, 2004.
Irving E. Segal. Postulates for general quantum mechanics. Annals of Mathematics, pages
930–948, 1947.
Peter Selinger. Towards a quantum programming language. Mathematical Structures in
Computer Science, 14(04):527–586, 2004.
Peter Selinger and Benoît Valiron. A lambda calculus for quantum computation with
classical control. In TLCA 2005, volume 3461 of LNCS, pages 354–368. Springer, 2005.
Peter Selinger and Benoît Valiron. A lambda calculus for quantum computation with
classical control. Mathematical Structures in Computer Science, 16(3):527–552, 2006.
Peter Selinger and Benoît Valiron. A linear-non-linear model for a computational call-by-
value lambda calculus (extended abstract). In FoSSaCS 2008, volume 4962 of LNCS, pages
81–96. Springer, 2008.
Peter Selinger and Benoît Valiron. On a fully abstract model for a quantum linear functional
language: (extended abstract). In QPL 2006, volume 210 of ENTCS, pages 123–137, 2008.
Peter Selinger and Benoît Valiron. Quantum lambda calculus. In Semantic Techniques in
Quantum Computation, pages 135–172. Cambridge University Press, 2009.

34

35

36

37

38

39

40

44

41 Masamichi Takesaki. Theory of operator algebras I. Springer, 2002.
42 Benoît Valiron. Semantics for a Higher Order Functional Programming Language for

Quantum Computation. PhD thesis, University of Ottawa, 2008.

43 André van Tonder. A lambda calculus for quantum computation. SIAM Journal on Com-

puting, 33(5):1109–1135, 2004.
John von Neumann. Wahrscheinlichkeitstheoretischer aufbau der quantenmechanik.
Nachrichten von der Gesellschaft der Wissenschaften zu Göttingen, Mathematisch-
Physikalische Klasse, 1927:245–272, 1927.

45 Abraham Westerbaan.

arXiv:1501.01020v2, 2014.

Quantum programs as Kleisli maps.

arXiv preprint

A

Proof of Soundness for the Small-Step Reduction

We need some results on the denotational semantics.

K. Cho and A. Westerbaan

15

(cid:73) Lemma 29. Suppose that !∆, Γ1, x : A (cid:66) M : B and !∆, Γ2 (cid:66) V : A, so that !∆, Γ1, Γ2 (cid:66)
M[V /x] : B by Lemma 3. Then the following diagram commute.

(cid:74)B(cid:75)
(cid:74)!∆,Γ2,x:A(cid:66)M:B(cid:75) 

(cid:74)!∆, Γ1(cid:75) ⊗(cid:74)A(cid:75)

(cid:74)!∆,Γ1,Γ2(cid:66)M[V /x]:B(cid:75)
id⊗(cid:74)!∆,Γ2(cid:66)V :A(cid:75)

(cid:74)!∆, Γ1, Γ2(cid:75)
/(cid:74)!∆, Γ1(cid:75) ⊗(cid:74)!∆, Γ2(cid:75)

merge

(cid:74)
Proof. By induction on M. Note that the interpretation of a value is MIU.
(cid:73) Lemma 30. We have the following equations, when terms M, N and values V, W are
appropriately well-typed.

(cid:74)

0

(cid:74)(λ

Proof. Straightforward, using Lemma 29.

xA.M)V(cid:75) =(cid:74)M[V /x](cid:75)
(cid:74)let hxA, yBin = hV, Win in M(cid:75) =(cid:74)M[V /x, W/y](cid:75)
A,B(V ) withn(xA 7→ M | yB 7→ N)(cid:75) =(cid:74)M[V /x](cid:75)
A,B(W) withn(xA 7→ M | yB 7→ N)(cid:75) =(cid:74)N[W/y](cid:75)

(cid:74)match inln
(cid:74)match inrn
Here we abbreviate(cid:74)∆ (cid:66) M : A(cid:75) to(cid:74)M(cid:75).
Note that(cid:74)P : A(cid:75)(0) =(cid:74)P : A(cid:75).
(cid:74)[|ψi,|x1 . . . xmi, M ] : A(cid:75)(l) = M⊗l2 ⊗(cid:74)A(cid:75) id⊗(cid:74)xl+1:qbit,...,xm:qbit(cid:66)M:A(cid:75)
xi /∈ FV(M) for all i ≤ l. Then(cid:74)P : A(cid:75)(l) =P
Q prob(P, Q)(cid:74)Q : A(cid:75)(l).

(cid:73) Deﬁnition 31. Let [|ψi,|x1 . . . xmi, M ] : A be a well-typed quantum closure such that
xi /∈ FV(M) for all i ≤ l. Then we deﬁne:

hψ|−|ψi
−−−−−→ C
(cid:73) Lemma 32. Let P = [|ψi,|x1 . . . xmi, M ] : A be a well-typed quantum closure such that

−−−−−−−−−−−−−−−−−−−−−→ M⊗m2

To prove Proposition 13 by induction, we need to strengthen the statement into Lemma 32.

Proof. We prove it by induction on terms M. If M is a value, then it holds by the deﬁnition
of prob. In the other induction steps, we prove the assertion by cases.
Consider the induction step for M N, and the case where M is not a value. Then the
only possible reductions from P = [ ψ, Ψ, M N ] are [ ψ, Ψ, M N ] →p [ ψ0, Ψ0, M0N ] when
[ ψ, Ψ, M ] →p [ ψ0, Ψ0, M0 ]. Without loss of generality,2 we may assume that

l = |y1 . . . ylz1 . . . zkx1 . . . xhi

such that x1 : qbit, . . . , xh : qbit (cid:66) M : A (cid:40) B and z1 : qbit, . . . , zk : qbit (cid:66) N : A. We

will simply write(cid:74)M(cid:75) for(cid:74)x1 : qbit, . . . , xh : qbit (cid:66) M : A (cid:40) B(cid:75) and(cid:74)N(cid:75) similarly. Then
(cid:74)[ ψ, Ψ, M N ] : B(cid:75)(l)
= M⊗l2 ⊗(cid:74)B(cid:75) id⊗ε−−−→ M⊗l2 ⊗(cid:74)A (cid:40) B(cid:75) ⊗(cid:74)A(cid:75) id⊗(cid:74)M(cid:75)⊗(cid:74)N(cid:75)
= M⊗l2 ⊗(cid:74)B(cid:75) id⊗ε−−−→ M⊗l2 ⊗(cid:74)A (cid:40) B(cid:75) ⊗(cid:74)A(cid:75) id⊗γ−−−→ M⊗l2 ⊗(cid:74)A(cid:75) ⊗(cid:74)A (cid:40) B(cid:75)

−−−−−−−−→ M⊗l2 ⊗ M⊗h2 ⊗ M⊗k2

id⊗γ−−−→ M⊗l2 ⊗ M⊗k2 ⊗ M⊗h2
id⊗(cid:74)N(cid:75)⊗id
−−−−−−−→ M⊗(l+k)

−−−−−→ M⊗(l+k)

hψ|−|ψi
−−−−−→ C

hψ|−|ψi
−−−−−→ C

2

2

⊗ M⊗h2

⊗(cid:74)A (cid:40) B(cid:75) id⊗(cid:74)M(cid:75)

2 A permutation of variables in Ψ which keeps the ﬁrst l variables, with the permutation of the correspond-

ing qubits in |ψi, does not change(cid:74)P : A(cid:75)(l). The same is true for the operational semantics [39, §3.2].

/
/

/
O
O
16

Von Neumann Algebras form a Model for the Quantum Lambda Calculus

hψi|−|ψii

i∈I

i∈I

pi

2

M⊗(l+k)

2

⊗ M⊗h2

hψ|−|ψi
−−−−−→ C

−−−−−→ M⊗(l+k)

2

⊗ M⊗hi2

−−−−−→ M⊗(l+k)

2

Next consider the case where M = U and N = hx1, . . . , xki0. Without loss of generality
we may assume P = [|ψi, Ψ, Uhx1, . . . , xki ] with l = |y1 . . . ylx1 . . . xkz1 . . . zhi. The only
reduction from P is [|ψi, Ψ, Uhx1, . . . , xki ] →1 [|ψ0i, Ψ,hx1, . . . , xki ] =: Q, where |ψ0i =

Let [ ψ, Ψ, M ] →pi [ ψi, Ψi, Mi ] (i ∈ I) be all the reductions from [ ψ, Ψ, M ]. By IH, we have
⊗(cid:74)A (cid:40) B(cid:75) id⊗(cid:74)M(cid:75)
=(cid:74)[ ψ, Ψ, M ] : A (cid:40) B(cid:75)(l+k)
=X
pi(cid:74)[ ψi, Ψi, Mi ] : A (cid:40) B(cid:75)(l+k)
(cid:16)M⊗(l+k)
−−−−−−→ C(cid:17)
=X
⊗(cid:74)A (cid:40) B(cid:75) id⊗(cid:74)Mi(cid:75)
It is then straightforward to see that(cid:74)[ ψ, Ψ, M N ] : B(cid:75)(l) =P
i pi(cid:74)[ ψi, Ψi, MiN ] : B(cid:75)(l).
(Il ⊗ U ⊗ Ih)|ψi (In denotes the 2n × 2n identity matrix). We need to show that (cid:74)P :
qbit⊗k(cid:75)(l) =(cid:74)Q : qbit⊗k(cid:75)(l). Note that
(cid:74)x1 : qbit, . . . , xk : qbit (cid:66) Uhx1, . . . , xki : qbit⊗k(cid:75) = fU : M⊗k2 → M⊗k2
(cid:74)P : qbit⊗k(cid:75)(l) = M⊗l2 ⊗ M⊗k2
(cid:74)x1 : qbit, . . . , xk : qbit (cid:66) hx1, . . . , xki : qbit⊗k(cid:75) = id: M⊗k2 → M⊗k2
(cid:74)Q : qbit⊗k(cid:75)(l) = M⊗l2 ⊗ M⊗k2
(cid:74)P : qbit⊗k(cid:75)(l)(A ⊗ B) = hψ|(id ⊗ ι)((id ⊗ fU)(A ⊗ B))|ψi

id⊗ι−−−→ M⊗(l+k+h)
For each elementary tensor A ⊗ B ∈ M⊗l2 ⊗ M⊗k2 ,

On the other hand, we have

id⊗fU−−−−→ M⊗l2 ⊗ M⊗k2

id⊗ι−−−→ M⊗(l+k+h)

2

hψ0|−|ψ0i
−−−−−−→ C

hψ|−|ψi
−−−−−→ C

Thus we have

and hence

2

= hψ|A ⊗ (U†BU) ⊗ Ih|ψi
= hψ|(Il ⊗ U† ⊗ Ih)(A ⊗ B ⊗ Ih)(Il ⊗ U ⊗ Ih)|ψi
= hψ0|(id ⊗ ι)(A ⊗ B)|ψ0i

=(cid:74)Q : qbit⊗k(cid:75)(l)(A ⊗ B)
We conclude that(cid:74)P : qbit⊗k(cid:75)(l) =(cid:74)Q : qbit⊗k(cid:75)(l).

Consider the case where M N is of the form (λx.M)V . Only the reduction is [|ψi, Ψ, (λx.M)V ] →1

[|ψi, Ψ, M[V /x] ]. The assertion holds immediately by Lemma 30.

The other cases in the induction step M N can be shown similarly. We can prove the
(cid:74)

other induction steps similarly by cases.

