6
1
0
2

 
r
a

M
6

 

 
 
]

O
L
.
s
c
[
 
 

1
v
6
7
7
1
0

.

3
0
6
1
:
v
i
X
r
a

Preprint for arXiv

Generalised rely-guarantee concurrency:
An algebraic foundation

Ian J. Hayes
School of Information Technology and Electrical Engineering, The University of Queensland, Australia

Abstract. The rely-guarantee technique allows one to reason compositionally about concurrent programs. To handle
interference the technique makes use of rely and guarantee conditions, both of which are binary relations on states.
A rely condition is an assumption that the environment performs only atomic steps satisfying the rely relation and
a guarantee is a commitment that every atomic step the program makes satisﬁes the guarantee relation. In order to
investigate rely-guarantee reasoning more generally, in this paper we allow interference to be represented by a process
rather than a relation and hence derive more general rely-guarantee laws. The paper makes use of a weak conjunction
operator between processes, which generalises a guarantee relation to a guarantee process, and introduces a rely
quotient operator, which generalises a rely relation to a process. The paper focuses on the algebraic properties of
the general rely-guarantee theory. The Jones-style rely-guarantee theory can be interpreted as a model of the general
algebraic theory and hence the general laws presented here hold for that theory.
Keywords: Concurrent programming; rely-guarantee concurrency; program veriﬁcation; program algebra; concurrent
Kleene algebra.

1. Introduction

Rely and guarantee conditions. The rely-guarantee technique of Jones [Jon81, Jon83, Jon96] provides a composi-
tional approach to reasoning about concurrent programs. With hindsight, it is obvious that to achieve compositional
handling of concurrency, it is necessary to have some way of recording information about interference. This paper
generalises the way that interference is recorded. To allow reasoning about a process c in isolation, Jones used a rely
condition r, that is a binary relation on states. Every atomic step of the environment of c is assumed to satisfy the rely
condition r between its before and after states. Any process running in parallel with c also has a rely condition and
hence process c will need to ensure every atomic program step it makes satisﬁes the rely conditions of all processes
in its environment. To represent this Jones uses a guarantee condition g, that is also a binary relation on states. Every
atomic step of c must satisfy g and the relation g should be contained in the rely condition of every process in the
environment of c. Jones records a rely-guarantee speciﬁcation by generalising the judgements of Hoare logic [Hoa69]
to a quintuple of the form,

{p, r} c {g, q} .

Correspondence and offprint requests to: Ian.Hayes@itee.uq.edu.au

(1)

2

Ian J. Hayes

The process c satisﬁes the quintuple if, under the assumption that the initial state satisﬁes p and every atomic step
made by the environment satisﬁes r between its before and after states, every possible execution of c ensures that
every atomic program step made by c satisﬁes g, and the initial and ﬁnal states of the overall execution of c satisfy the
relational postcondition q.

Reﬁnement calculus. This paper uses a reﬁnement calculus approach [Bac81, BvW98, Mor88, Mor94, Mor87] rather
than Hoare logic because it allows for simpler presentation of algebraic laws of programming [HHH+87]. Reﬁnement
of one command c by another d is written “c (cid:118) d” and is read “c is reﬁned (implemented) by d”. The reﬁnement
calculus introduces a postcondition speciﬁcation command [q] in which the postcondition q is a binary relation on
states, and a precondition command {p} in which the precondition p is a set of states. The reﬁnement {p} ; [q] (cid:118) d
means d achieves the postcondition q between its before-state and after-state, provided its before-state satisﬁes p. As
an abbreviation the sequential composition operator “;” may be elided so that the above may be written {p} [q].

Generalised rely-guarantee. The main contribution of this paper is to generalise a rely condition r to a process i
specifying the assumed behaviour of interference from the environment. The actual environment should satisfy (i.e.
reﬁne) the process speciﬁcation i. Similarly, the guarantee condition g is generalised to a process j to be “guaranteed”
by the implementation. The process that behaves as a process c as well as respecting the guarantee process j is
represented by their weak conjunction j(cid:101)c, which is the process that behaves as both j and c unless one of them aborts.1
A Jones-style guarantee condition g on a terminating command c is represented by the process (cid:104)g(cid:105)(cid:16) (cid:101) c, where (cid:104)g(cid:105)
(cid:104)g(cid:105)(cid:16) is the process that iterates the atomic step (cid:104)g(cid:105) any ﬁnite number of times, zero or more. An example of a guarantee
process that cannot be expressed as a guarantee condition is the sequential composition (cid:104)id(cid:105)(cid:16) (cid:104)g(cid:105)(cid:104)id(cid:105)(cid:16), in which id
is the identity relation. It guarantees that a step satisfying g occurs exactly once but allows stuttering steps before and
after. The closest guarantee condition is g ∪ id but that allows any number, zero of more, of steps satisfying g ∪ id.
Section 3 explores the weak conjunction operator and its relationship to Jones-style guarantee conditions [JHC15].

represents a command that can perform a single atomic program step for which the before and after states satisfy g and

Rely quotients. To specify a process that reﬁnes (implements) c, while relying on its environment reﬁning process i,
a rely quotient operator c // i is introduced. The rely quotient c // i when run in parallel with i implements c,

c (cid:118) (c // i) (cid:107) i .

The operator “//” is chosen to be similar in appearance to the division operator, where in this context “(cid:107)” takes on
a role similar to multiplication. Taking “x // y” as the ceiling of their integer division (cid:100)x/y(cid:101) gives the best analogy:
x ≤ (cid:100)x/y(cid:101)× y. A terminating process speciﬁcation c with a Jones-style rely condition r is represented by the quotient
c // (cid:104)r(cid:105)(cid:16), where (cid:104)r(cid:105)(cid:16) represents the environment process, all atomic steps of which satisfy r. Section 4 explores the

properties of the rely quotient operator. Given the weak conjunction and rely quotient operators, the Jones quintuple
(1) is equivalent to the following reﬁnement.

{p} ((cid:104)g(cid:105)(cid:16) (cid:101) ([q] // (cid:104)r(cid:105)(cid:16))) (cid:118) c

(2)

Concurrency. The parallel introduction law of Jones makes use of both rely and guarantee conditions. In the more
general theory presented here, weak conjunction takes on the role of a guarantee and the rely quotient takes on the
role of a rely condition. Both generalised operators are used to give a general version a law for introducing a parallel
composition, which has a surprisingly simple and elegant proof (see Section 5).

Distribution laws. Section 6 examines the distribution properties of the rely quotient operator over the other oper-
ators. In some cases the general distribution laws for weak conjunction and rely quotient require provisos. However,
in the relational rely-guarantee model the provisos are all valid and hence the distribution properties hold without
proviso. In the general theory the provisos are explicit and hence it is possible to explore alternatives to Jones-style
rely-guarantee that allow more expressive rely conditions.

Relationship to relational rely-guarantee. Exploring the theory more generally leads to simpler laws that can be
specialised to the relational model. As an example consider the nesting of two rely processes i and j, i.e. (c // j) // i.
That corresponds to handling concurrent interference from both i and j and is equivalent to c // (i (cid:107) j), i.e. an effective

1 Earlier publications referred to weak conjunction as strict conjunction but the new name is preferred because the operator is weaker than the
(strong) conjunction operator that requires both its operands to abort for it to abort.

Generalised rely-guarantee concurrency

3

Let c and d be commands, C be a set of commands and f a monotonic function on commands. The following are the
primitive operators and commands used in the algebra.

c (cid:117) d, c (cid:116) d, c (cid:107) d, c (cid:101) d, c // d, c ; d, µf, νf, (cid:100) C, (cid:70) C, ⊥, (cid:62), nil, skip, chaos

The precedence of binary operators ranges from “(cid:117)” on the left having the lowest precedence to “;” on the right having
the highest precedence, although “(cid:117)” and “(cid:116)” have equal precedence. Unary operators have precedence over binary
operators. The sequential composition c ; d is abbreviated as c d.

Fig. 1. Operators and primitive commands

rely process of i (cid:107) j. A relational rely condition of r corresponds to a rely process of (cid:104)r(cid:105)(cid:16) and the nesting of two such
processes for rely conditions of r0 and r1 corresponds to the rely process of (cid:104)r0(cid:105)(cid:16) (cid:107) (cid:104)r1(cid:105)(cid:16), however, this process
is equivalent to (cid:104)r0 ∨ r1(cid:105)(cid:16), corresponding to a relational rely of r0 ∨ r1. This shows how the well known relational

rely-guarantee rule, that the effective rely of nested relational rely conditions is their disjunction, can be derived from
the more general view that the effective rely process of nested rely processes is their parallel composition.

Section 7 explores the relationship of the more general theory to the Jones-style relational guarantee and rely
conditions. The relational rely-guarantee theory of Jones [Jon96] is a model of the general algebraic theory presented
in this paper and hence the laws developed in the general theory are also valid for Jones’ theory.

Section 8 examines fair parallel and its impact on the rely quotient operator.

Contributions. The main contribution of this paper is to generalise rely and guarantee conditions from relations to
arbitrary processes. In order to make our results as widely applicable as possible, we have based our theory on a
relatively small set of deﬁnitions and axioms. Any model, such as the relational rely-guarantee model, that satisﬁes
the axioms can then make use of all the laws proved here.

Our core theory adds two speciﬁcation operators, weak conjunction and rely quotient, to the operators of a sim-
ple parallel programming language. The weak conjunction operator allows guarantees to be imposed on a process
[HJC14]. The rely quotient operator introduced in this paper allows rely conditions to be generalised to processes.
There are a number of advantages of exploring the more general operators. Both weak conjunction and rely quotient
have simple algebraic properties and this leads to simple and elegant proofs of laws involving these operators. The
approach leads to a nice separation of concerns because properties of weak conjunction (guarantees) and rely quotient
can be developed separately and then combined to give generalised equivalents of the main laws used for standard
rely-guarantee reﬁnements, which are more simply expressed and proven in the general theory. Further, it is much
simpler to devise new rely-guarantee reﬁnement laws because the algebra gives a rich theory of properties which
simplify discovering proofs.

As an example of the way in which the theory generalises rely and guarantee conditions, in the relational model,

as well as being able to express a relational rely condition via the process (cid:104)r(cid:105)(cid:16), one can express rely processes, such
as the sequence (cid:104)r0(cid:105)(cid:16) (cid:104)r1(cid:105)(cid:16), which cannot be expressed via a relational rely condition. The closest rely condition is
r0 ∨ r1 but that does not represent the fact that the rely transitions from r0 to r1 just once.

2. Basic commands and reﬁnement

Our presentation separates a core algebraic theory of processes from an instantiation of that theory as a relational
model similar to that used by Jones [CJ07]. Section 2.1 introduces the operators in our language. Section 2.2 covers
the theory of lattices on which the theory for the language is built. Section 2.3 gives the algebraic properties of basic
commands. Section 2.4 gives the relational model to provide an intuition for the behaviour of basic commands.

2.1. Operators and primitive commands

The operators and primitive commands of the core language are given in Figure 1. Typical commands are represented
by c, d, i and j; sets of commands by C and D; and monotonic functions from commands to commands by f. The

language includes non-deterministic choice, both binary (c (cid:117) d) and over a set of commands ((cid:100) C), which form
inﬁma with respect to the reﬁnement ordering, and their duals c (cid:116) d and ((cid:70) C), which form suprema. Additional

binary operators are parallel composition (c (cid:107) d), sequential composition (c ; d), a weak conjunction operator (c (cid:101) d)

4

Ian J. Hayes

Lattice

c0 (cid:117) (c1 (cid:117) c2) = (c0 (cid:117) c1) (cid:117) c2

c0 (cid:117) c1 = c1 (cid:117) c0
c (cid:117) c = c

c0 (cid:116) (c1 (cid:116) c2) = (c0 (cid:116) c1) (cid:116) c2

c0 (cid:116) c1 = c1 (cid:116) c0
c (cid:116) c = c
c0 (cid:117) (c0 (cid:116) c1) = c0
c0 (cid:116) (c0 (cid:117) c1) = c0

Fixed point axioms

µf = f (µf )
f (x) (cid:118) x ⇒ µf (cid:118) x

Complete lattice

c ∈ C ⇒ (cid:100) C (cid:118) c
(∀c ∈ C · d (cid:118) c) ⇒ d (cid:118)(cid:100) C
c ∈ C ⇒ c (cid:118)(cid:70) C
(∀c ∈ C · c (cid:118) d) ⇒ (cid:70) C (cid:118) d
c (cid:117) ((cid:70) D) =(cid:70){d ∈ D · c (cid:117) d}

Nondeterminism distributes over supremum

νf = f (νf )
x (cid:118) f (x) ⇒ x (cid:118) νf

(11)
(12)
(13)
(14)

(15)

(18)
(19)

(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)

(16)
(17)

Fig. 2. Axioms for lattices and ﬁxed points

explained in Section 3, and a rely quotient operator (c // d) explained in Section 4. Commands include least (µf) and
greatest (νf) ﬁxed points of monotonic functions over commands. Primitive commands include: the top element in
the reﬁnement lattice (cid:62) (called magic in the reﬁnement calculus); the bottom element ⊥ (called abort); the command
that terminates immediately, nil, which is the identity of sequential composition; the command that does nothing but
doesn’t constrain its environment, skip, which is the identity of parallel composition; and the command that can do
any non-aborting behaviour, chaos, which is the identity of weak conjunction.

2.2. Lattices and ﬁxed points
The theory for the language is built on a lattice of commands ordered by reﬁnement. The reﬁnement relation “(cid:118)” is
deﬁned in terms of the inﬁmum operator “(cid:117)”; reﬁnement is reﬂexive, anti-symmetric and transitive (a partial order).
Deﬁnition 1 (reﬁnement). For any c, d,
The lattice-theoretic axioms of the language are given in Figure 2. Com is the set of all commands and lattice inﬁmum,
“(cid:117)”, corresponds to nondeterministic choice.
• (Com,(cid:117),(cid:116)) forms a lattice with inﬁmum (greatest lower bound) “(cid:117)” and supremum (least upper bound) “(cid:116)”, i.e.

c (cid:118) d (cid:98)= (c (cid:117) d) = c. Equivalently c (cid:118) d ⇔ (c (cid:116) d) = d.

• The lattice is complete, i.e. the inﬁmum(cid:100) C and the supremum(cid:70) C exist for all sets of commands C, including

axioms (3–10) hold.

empty or inﬁnite C. The inﬁma and suprema satisfy axioms by (11–14).

• The inﬁmum (i.e. nondeterministic choice) distributes over arbitrary suprema (15).
• The bottom element of the lattice is ⊥. It is the identity of “(cid:116)” and an annihilator for “(cid:117)”.

⊥ (cid:98)=(cid:70){} =(cid:100) Com
(cid:62) (cid:98)=(cid:100){} =(cid:70) Com

(20)

c (cid:116) ⊥ = c = ⊥ (cid:116) c
c (cid:117) ⊥ = ⊥ = ⊥ (cid:117) c

(21)
(22)

• The top element of the lattice is (cid:62). It is the identity of “(cid:117)” and an annihilator for “(cid:116)”.

(24)
(25)
The following law can be used to handle reﬁnement to or from a nondeterministic choice [BvW98]. A common special

(23)

c (cid:117) (cid:62) = c = (cid:62) (cid:117) c
c (cid:116) (cid:62) = (cid:62) = (cid:62) (cid:116) c

case is if C (or D) is a singleton set, i.e.(cid:100){c} = c (or(cid:100){d} = d).
(∀d ∈ D · (∃c ∈ C · c (cid:118) d)) ⇒ ((cid:100) C) (cid:118) ((cid:100) D).

Lemma 1 (non-deterministic-choice). For any sets C and D over a complete lattice,

Generalised rely-guarantee concurrency

The notation {c ∈ C · f} stands for the set of values of the expression f for c an element of C.
Sequential

Identities

c0 (c1 c2) = (c0 c1) c2

c nil = c
nil c = c

c (d0 (cid:117) d1) = (c d0) (cid:117) (c d1)

((cid:100) C) d =(cid:100){c ∈ C · c d}

⊥ c = c

Parallel

c0 (cid:107) (c1 (cid:107) c2) = (c0 (cid:107) c1) (cid:107) c2

c0 (cid:107) c1 = c1 (cid:107) c0
c (cid:107) skip = c

((cid:100) C) (cid:107) d =(cid:100){c ∈ C · c (cid:107) d}

(30)
(31)
(32)
(33)
(34)
(35)

(36)
(37)
(38)
(39)

skip skip = skip
skip (cid:118) nil
Weak conjunction

c0 (cid:101) (c1 (cid:101) c2) = (c0 (cid:101) c1) (cid:101) c2

c0 (cid:101) c1 = c1 (cid:101) c0

c (cid:101) c = c
c (cid:101) chaos = c

chaos (cid:118) skip
chaos (cid:107) chaos = chaos

D (cid:54)= ∅ ⇒ c (cid:101) ((cid:100) D) =(cid:100){d ∈ D · c (cid:101) d}
c (cid:101) ((cid:70) D) =(cid:70){d ∈ D · c (cid:101) d}

5

(40)
(41)

(42)
(43)
(44)
(45)
(46)
(47)
(48)
(49)

Weak exchange axioms

(c0 (cid:107) c1) (cid:101) (d0 (cid:107) d1) (cid:118) (c0 (cid:101) d0) (cid:107) (c1 (cid:101) d1)
(c0 c1) (cid:101) (d0 d1) (cid:118) (c0 (cid:101) d0) (c1 (cid:101) d1)

(50)
(51)

Fig. 3. Axioms for core language of commands

The reverse implication does not hold in general, e.g. for C = {c0, c1} and D = {c0 (cid:117) c1}.
Lemma 2 (operator-monotonic). If a binary operator “◦” distributes over non-deterministic choice in both argu-
ments then, c0 (cid:118) c1 ∧ d0 (cid:118) d1 ⇒ c0 ◦ d0 (cid:118) c1 ◦ d1.

For a monotonic function f on a complete lattice, the least and greatest ﬁxed points of f, µf and νf, respectively,
satisfy axioms (16-19). As usual, µ(λx · f (x)) is abbreviated µx · f (x). The following lemma allows reasoning about
ﬁxed points [ABB+95, BvW98].
Lemma 3 (fusion). For any monotonic functions F , G and H on complete lattices with order (cid:118),

F (µG) (cid:118) µH provided F ◦ G (cid:118) H ◦ F and F distributes over arbitrary suprema
F (µG) = µH provided F ◦ G = H ◦ F and F distributes over arbitrary suprema
F (νG) (cid:119) νH provided F ◦ G (cid:119) H ◦ F and F distributes over arbitrary inﬁma
F (νG) = νH provided F ◦ G = H ◦ F and F distributes over arbitrary inﬁma

where F distributes over arbitrary suprema if F ((cid:70) C) = (cid:70){c ∈ C · F (c)} for all sets of commands C, and F
distributes over arbitrary inﬁma if F ((cid:100) C) =(cid:100){c ∈ C · F (c)} for all sets of commands C.

(26)
(27)
(28)
(29)

2.3. An algebra for concurrency

The properties of the operators in Figure 1 are given in terms of a set of axioms given in Deﬁnition 2. The axioms have
been split into groups which are discussed below. The main results of the paper depend only on these axioms. The
majority of the axioms are taken from existing algebraic theories of programs (such as [vW04, HMSW11]), the main
exceptions being the axioms for weak conjunction, including the exchange axioms. The axioms hold for the relational
model introduced in Section 2.4.
Deﬁnition 2 (concurrent-algebra). The set of commands Com satisﬁes the axioms given in Figure 3 in addition to
the axioms of lattices from Figure 2.
• (Com, ; , nil) forms a monoid with identity nil, i.e. axioms (30-32). Note that the operator “;” is elided, so that

“c ; d” is written “c d”.

6

Ian J. Hayes

(cid:62) c = (cid:62)

• Sequential composition distributes over ﬁnite non-deterministic choices on the left (33) and arbitrary inﬁma on the
right (34) and and hence it has a left annihilator of (cid:62) (52); ⊥ is a left annihilator of sequential composition ⊥ (35).
(52)
• (Com,(cid:107), skip) forms a monoid with identity skip in which “(cid:107)” is commutative, i.e. axioms (36–38). Note that
the identity of parallel composition is different to the identity of sequential composition; that allows a wider range
of models, included the relational model introduced in Section 2.4.
• Parallel distributes over non-deterministic choice of any set of commands (39), and hence has an annihilator of (cid:62).
(53)
• The identity of parallel composition, skip, sequentially composed with itself is equivalent to skip (40) and is
• (Com, (cid:101), chaos) forms a monoid with identity chaos in which “(cid:101)” is commutative and idempotent, i.e. axioms
• chaos allows any non-aborting behaviour including skip (46) and chaos in parallel with itself doesn’t make it
• Weak conjunction distributes over the non-deterministic choice of non-empty sets of commands by axiom (48) and

reﬁned by the identity of sequential composition, nil (41).

any more (or less) chaotic (47).

(cid:62) (cid:107) c = (cid:62)

(42–45).

hence it distributes over binary choices.
c (cid:101) (d0 (cid:117) d1) = (c (cid:101) d0) (cid:117) (c (cid:101) d1)

• Weak conjunction distributes over arbitrary suprema axiom (49) and hence it has an annihilator of ⊥.

c (cid:101) ⊥ = ⊥ = ⊥ (cid:101) c

(55)
• Weak conjunction does not distribute through either parallel or sequential composition, instead it satisﬁes the weak
exchange axioms (50) and (51). Note that axiom (50) is a reﬁnement rather than an equality because, on the left,
behaviour of c0 may synchronise with behaviour of either d0 or d1, whereas, on the right, it can only synchronise
with behaviour of d0; axiom (51) is similar; see Section 3 for more details.

Note that the set of all commands that reﬁne chaos forms a sub-lattice of all non-aborting commands.

The iteration operators are based on von Wright’s reﬁnement algebra [vW04]. Kleene algebra provides the ﬁnite
iteration operator c(cid:63), which iterates c zero or more times but only a ﬁnite number of times [Con71, Bli78, Koz97].
A generalisation of this more appropriate for modelling programs is the iteration operator, c◦, that iterates c zero or
more times, including the possibility of an inﬁnite number of iterations [vW04]. For both these operators the number
of iterations they take is non-deterministic.
Deﬁnition 3 (iteration). The iteration operators are deﬁned via least (µ) and greatest (ν) ﬁxed point operators.

(54)

(57)

c(cid:63) (cid:98)= (νx · nil (cid:117) c x)

c◦ (cid:98)= (µx · nil (cid:117) c x)

(56)

The iteration operators have corresponding induction and folding/unfolding lemmas [BvW98, BvW99, vW04].
Lemma 4 (fold/unfold). The iteration unfolding properties follow from ﬁxed point unfolding (18) and (16).

c◦ = nil (cid:117) c c◦

c(cid:63) = nil (cid:117) c c(cid:63)

(59)
Lemma 5 (induction). The iteration induction properties follow from Lemma 3 (fusion) and ﬁxed point induction
(19) and (17).

(58)

d (cid:117) c x (cid:118) x ⇒ c◦ d (cid:118) x

x (cid:118) d (cid:117) c x ⇒ x (cid:118) c(cid:63) d

(60)

(61)
We use the term “law” for theorems about our new operators and “lemma” for existing theorems from standard theory.
Laws and lemmas share their numbering sequence.
Law 6 (monotonic). If c (cid:118) d and c0 (cid:118) d0 and c1 (cid:118) d1, all of the following hold.
c0 (cid:101) c1 (cid:118) d0 (cid:101) d1

(65)
(66)
(67)
Proof. Property (62) holds because non-deterministic choice is associative, commutative and idempotent. The proofs
of (63–65) follow from Lemma 2 (operator-monotonic) because “;”, “(cid:107)” and “(cid:101)” distribute non-deterministic choice

c0 (cid:117) c1 (cid:118) d0 (cid:117) d1
c0 (cid:107) c1 (cid:118) d0 (cid:107) d1
c0 c1 (cid:118) d0 d1

c(cid:63) (cid:118) d(cid:63)
c◦ (cid:118) d◦

(62)
(63)
(64)

Generalised rely-guarantee concurrency

7

in both their left and right arguments. Properties (66) and (67) can be shown by induction, respectively, (60) and (61),
using (58) and (59) (see [vW04]). (cid:3)

2.4. A relational model

In this paper we focus on the algebraic laws satisﬁed by commands but it is useful to have a model to gain intuitions
and ensure the algebra is consistent. The model used corresponds to the rely-guarantee theory of Jones based on Aczel
traces [Acz83, dBHdR99, dR01, HJC14]. Typical single-state predicates are represented by p and binary relations on
states by g, q and r. The additional commands in the relational model are

π(r), (r), τ (p), {p}, (cid:104)q(cid:105),

[q] .

This set of commands is left open and may be extended with other commands, for example, tests, assignments, condi-
tionals and loops are added in [HJC14].
States (Σ) are modelled by a mapping from variable names to values. The set of program states Σ⊥ is extended
to include the undeﬁned state ⊥, which is used to denote that the process has aborted.2 An Aczel trace consists of an
initial state σ ∈ Σ and a sequence of steps, each of which is either a program step labelled Π(σ(cid:48)) or an environment
step labelled E(σ(cid:48)), where σ(cid:48) ∈ Σ⊥ is the program state after the step. In this paper the term “step” always means an
atomic step (either of a program or its environment). A terminating Aczel trace ends with a step labelled (cid:88). The step
Π(⊥) is an aborting step of the program and the step E(⊥) allows an aborting step by the environment. The special
steps (cid:88), Π(⊥) and E(⊥) can appear only as the last step of a (ﬁnite) trace. The set Trace is the set of all valid Aczel
traces. The notation [v1, v2, . . .] stands for the sequence containing v1, v2, . . ..
A set of traces T is preﬁx closed if (σ, [ ]) ∈ T for all σ ∈ Σ and whenever (σ, t) ∈ T and t(cid:48) is a preﬁx
of t, (σ, t(cid:48)) ∈ T . A set of traces T is abort closed if whenever (σ, t (cid:95) [Π(⊥)]) ∈ T , then for any valid trace
(σ, t (cid:95) t(cid:48)) ∈ Trace, (σ, t (cid:95) t(cid:48)) ∈ T . The set of all commands, Com, consists of all the preﬁx and abort closed subsets
of Trace.

The command π(r) performs a single program step with its before and after states related by r and terminates
(68), (r) is similar but performs an environment step (69), ⊥(r) represents an environment step that satisﬁes r or
allows a parallel process to abort (70), τ (p) terminates from states satisfying p only (71), ⊥ aborts immediately and
hence can do any behaviour whatsoever (72), (cid:62) can make no steps whatsoever (73), and nil terminates immediately
from any state (74). Recall that {x ∈ S · e} stands for the set of values of e for all values of x in the set S.

π(r) = preﬁxes({(σ, σ(cid:48)) ∈ r · (σ, [Π(σ(cid:48)), (cid:88)]})
(r) = preﬁxes({(σ, σ(cid:48)) ∈ r · (σ, [E(σ(cid:48)), (cid:88)]})
⊥(r) = (r) ∪ preﬁxes({σ ∈ Σ · (σ, [E(⊥)])})
τ (p) = preﬁxes({σ ∈ p · (σ, [(cid:88)]})

(68)
(69)
(70)
(71)

⊥ = Trace
(cid:62) = {σ ∈ Σ · (σ, [ ])}
nil = τ (Σ)

(72)
(73)
(74)

The set of traces of a non-deterministic choice(cid:100) C is the union(cid:83) C and the supremum(cid:70) C is the intersection(cid:84) C.

A trace of a sequential composition (c d) is any unterminated trace of c or a terminating trace t of c (minus the (cid:88) step)
followed by a trace of d that starts in the ﬁnal state of t. Note that an unterminated trace may be inﬁnite or it may be a
ﬁnite trace that does not end in (cid:88).
The traces of c (cid:107) d are formed by matching traces of c and d. A program step sc of c matches an environment
step sd of d if their states are the same, in which case the program step is the step taken by their parallel composition.
Identical environment steps of both c and d match to give an environment step of their parallel composition. The
following predicate deﬁnes matching a step sc of c with a step sd of d to give a step st of c (cid:107) d.

match step(sc, sd, st) (cid:98)= ∃σ ∈ Σ⊥ · sc = Π(σ) ∧ sd = E(σ) ∧ st = Π(σ) ∨
match trace((σc, tc), (σd, td), (σ, t)) (cid:98)= σc = σd = σ ∧ dom(tc) = dom(td) = dom(t) ∧

sc = E(σ) ∧ sd = Π(σ) ∧ st = Π(σ) ∨
sc = E(σ) ∧ sd = E(σ) ∧ st = E(σ) ∨
sc = (cid:88) ∧ sd = (cid:88) ∧ st = (cid:88)

(∀i ∈ dom(t) · match step(tc(i), td(i), t(i))

c (cid:107) d (cid:98)= abort close({t ∈ Trace | ∃tc ∈ c, td ∈ d · match trace(tc, td, t)})

2 The symbol ⊥ is overloaded between the undeﬁned state and the bottom of the lattice of commands, which corresponds to the aborted process.
As usual their meaning is resolved by context.

8

Ian J. Hayes

Two traces match if they have the same initial state and are the same length (including both being inﬁnite) and all their
corresponding steps match. The parallel composition of c and d consists of all their matching traces. The abort closure
ensures aborting traces can be reﬁned by any other behaviour.
A weak conjunction c (cid:101) d represents synchronised step-by-step execution of c and d unless one of them aborts.
Hence if both c and d can make a step Π(σ) then so can c (cid:101) d, if both c and d can make a step E(σ) then so can c (cid:101) d,
if both c and d can make a step (cid:88) then so can c (cid:101) d, but if either c or d can make an aborting step Π(⊥) then so can
c (cid:101) d. The properties of weak conjunction in the relational model are discussed in more detail in Section 3.2.
Other commands in the relational model are deﬁned as follows, where univ stands for the universal relation Σ× Σ

on states.

skip (cid:98)= (⊥(univ))◦
(cid:104)r(cid:105) (cid:98)= skip π(r) skip

{p} (cid:98)= τ (p) (cid:117) (τ (¬p)⊥)
(env r) (cid:98)= (π(univ) (cid:117) ⊥(r))◦ (nil (cid:117) (¯r)⊥)

(77)
(78)
The command skip does no program steps but allows its environment to do any steps, including abort. The atomic
step command (cid:104)r(cid:105) performs a single program step satisfying r (if possible) and allows its environment to do any steps.
The precondition command {p} characterises an assumption about the initial state — it terminates immediately if the
initial state satisﬁes p, otherwise it aborts immediately. The command (env r) characterises an assumption that all
steps of its environment satisfy the relation r; it aborts if its environment performs a step that does not satisfy r. The
relational commands satisfy the following laws [HJC14].

(75)
(76)

p0 ⊆ p1 ⇔ {p0} (cid:118) {p1}
r0 ⊆ r1 ⇔ (env r0) (cid:118) (env r1)
Whereas nil terminates immediately allowing no program or environment steps, skip allows any number of en-
vironment steps, including allowing the environment to abort. That ensures that c (cid:107) skip = c because any trace tc
of program, environment or termination steps of c is matched by a trace of skip to give the same trace tc. Note that
c (cid:107) nil either terminates immediately if c can, otherwise the trace becomes infeasible. Because nil terminates imme-
diately with no intervening environment steps, {p} nil{p} = {p}, but if nil is replaced by skip, environment steps
allowed by skip may change the state thus invalidating p and hence {p} skip{p} = {p} does not hold in general.

q1 ⊆ q0 ⇔ (cid:104)q0(cid:105) (cid:118) (cid:104)q1(cid:105)

(79)
(80)

(81)

3. Weak conjunction
A weak conjunction of commands c (cid:101) d behaves as both c and d provided neither aborts but aborts as soon as either c
or d aborts. If neither process aborts, c (cid:101) d is the same as their supremum c (cid:116) d (which in the relational model forms
the intersection of traces). Weak conjunction was introduced as part of a relational model in [HJC14] but here it is
viewed more abstractly via its axioms in Deﬁnition 2 (concurrent-algebra). In Section 3.1 a set of laws based only
on the axioms of weak conjunction are derived. Weak conjunction in the relational model is examined in Section 3.2,
while Section 3.3 looks at its use for representing relational guarantees and Section 3.4 presents a set of laws about
relational guarantees.

3.1. Laws for weak conjunction

This section presents a number of laws about weak conjunction that can be derived from the axioms presented in
Section 2.3.
Law 7 (reﬁne-conjunction). If c0 (cid:118) d and c1 (cid:118) d,
Proof. The proof follows by Law 6 (monotonic) part (65) and because weak conjunction is idempotent (44):
c0 (cid:101) c1 (cid:118) d (cid:101) d = d. (cid:3)
Law 8 (reﬁne-to-conjunction). If c (cid:118) d0 and c (cid:118) d1,
Proof. The proof follows because weak conjunction is idempotent (44) and by Law 6 (monotonic) part (65):
c = c (cid:101) c (cid:118) d0 (cid:101) d1 . (cid:3)

It is not the case that c (cid:118) c(cid:101)d in general, e.g. take d to be ⊥, however, if d reﬁnes the identity of weak conjunction,

c (cid:118) d0 (cid:101) d1 .

c0 (cid:101) c1 (cid:118) d .

chaos, it does hold.

Generalised rely-guarantee concurrency

9

Law 9 (conjoin-non-aborting). If chaos (cid:118) d,
Proof. The proof follows because chaos is the identity of weak conjunction (45) and by Law 6 (monotonic) part
(65): c = c (cid:101) chaos (cid:118) c (cid:101) d . (cid:3)
The following two laws highlight the difference between “(cid:101)” and “(cid:116)”. In general, c (cid:101) d (cid:118) c (cid:116) d but they coincide

c (cid:118) c (cid:101) d .

if both arguments are non-aborting.
Law 10 (conjunction-supremum). c (cid:101) d (cid:118) c (cid:116) d.
Proof. By axiom (13), both c (cid:118) c (cid:116) d and d (cid:118) c (cid:116) d, and hence by Law 7 (reﬁne-conjunction), c (cid:101) d (cid:118) c (cid:116) d . (cid:3)
Law 11 (conjunction-supremum-nonaborting). If chaos (cid:118) c and chaos (cid:118) d,
Proof. By Law 10 (conjunction-supremum) c (cid:101) d (cid:118) c (cid:116) d. By Law 9 (conjoin-non-aborting) because both c and d
reﬁne chaos, both c (cid:118) c (cid:101) d and d (cid:118) c (cid:101) d, and hence by axiom (14), c (cid:116) d (cid:118) c (cid:101) d. (cid:3)
Law 12 (conjunction-distribute).

c (cid:101) d = c (cid:116) d.

c (cid:101) (d0 (cid:101) d1) = (c (cid:101) d0) (cid:101) (c (cid:101) d1)
c (cid:101) (d0 (cid:107) d1) (cid:118) (c (cid:101) d0) (cid:107) (c (cid:101) d1)
c (cid:101) (d0 d1) (cid:118) (c (cid:101) d0) (c (cid:101) d1)

(82)
(83)
(84)
(85)
(86)
Proof. Property (82) follows because weak conjunction is idempotent (44), commutative (43) and associative (42). For
(83), assuming c (cid:118) c (cid:107) c,

c(cid:63) (cid:101) d(cid:63) (cid:118) (c (cid:101) d)(cid:63)
c◦ (cid:101) d◦ (cid:118) (c (cid:101) d)◦

if c (cid:118) c (cid:107) c
if c (cid:118) c c

(cid:118) by Law 6 (monotonic) part (65) assuming c (cid:118) c (cid:107) c
(cid:118) exchanging weak conjunction and parallel by axiom (50)

c (cid:101) (d0 (cid:107) d1)
(c (cid:107) c) (cid:101) (d0 (cid:107) d1)
(c (cid:101) d0) (cid:107) (c (cid:101) d1)

and for (84), assuming c (cid:118) c c,

(cid:118) by Law 6 (monotonic) part (65) assuming c (cid:118) c c
(cid:118) exchanging weak conjunction and sequential by axiom (51)

c (cid:101) (d0 d1)
(c c) (cid:101) (d0 d1)
(c (cid:101) d0) (c (cid:101) d1)

Property (85) holds by Lemma 5 (induction) for ﬁnite iteration (60), if

c(cid:63) (cid:101) d(cid:63) (cid:118) nil (cid:117) (c (cid:101) d) (c(cid:63) (cid:101) d(cid:63)),

which can be shown as follows.

c(cid:63) (cid:101) d(cid:63)
(nil (cid:117) c c(cid:63)) (cid:101) d(cid:63)
(nil (cid:101) d(cid:63)) (cid:117) (c c(cid:63) (cid:101) d(cid:63))
nil (cid:117) (c c(cid:63) (cid:101) d d(cid:63))
nil (cid:117) (c (cid:101) d) (c(cid:63) (cid:101) d(cid:63))

= by Lemma 4 (fold/unfold) part (58)
(cid:118) as weak conjunction distributes over non-deterministic choice (48)
(cid:118) by Law 7 (reﬁne-conjunction) as by (58) d(cid:63) = nil (cid:117) d d(cid:63) and hence d(cid:63) (cid:118) nil and d(cid:63) (cid:118) d d(cid:63)
(cid:118) exchanging weak conjunction and sequential by axiom (51)

For (86) the proof uses Lemma 3 (fusion) part (26) with function F = (λx · c◦ (cid:101) x), G = (λx · nil (cid:117) d x) and hence
µG = d◦, and H = (λx · nil(cid:117) (c (cid:101) d) x) and hence µH = (c (cid:101) d)◦. F , G and H are monotonic because “(cid:117)”, “;” and
“(cid:101)” are. Property (86) corresponds to F (µG) (cid:118) µH, and Lemma 3 (fusion) states that this holds if F ◦ G (cid:118) H ◦ F ,
i.e. for any x,

c◦ (cid:101) (nil (cid:117) d x) (cid:118) nil (cid:117) (c (cid:101) d) (c◦ (cid:101) x)

(87)

10

Ian J. Hayes

which holds as follows.

c◦ (cid:101) (nil (cid:117) d x)
(c◦ (cid:101) nil) (cid:117) (c◦ (cid:101) d x)
nil (cid:117) (c c◦ (cid:101) d x)
nil (cid:117) (c (cid:101) d) (c◦ (cid:101) x)

= distributing conjunction over nondeterministic choice (48)
(cid:118) by Law 7 (reﬁne-conjunction) as by (59) c◦ = nil (cid:117) c c◦ and hence c◦ (cid:118) nil and c◦ (cid:118) c c◦
(cid:118) exchanging weak conjunction and sequential by axiom (51)

(cid:125) are introduced.

Deﬁnition 4 (guarantee-iteration).

Lemma 3 (fusion) also requires that F distributes over arbitrary suprema, which holds because weak conjunction
distributes over arbitrary suprema (49). (cid:3)
The iterations c(cid:63) and c◦ iterating zero times, are equivalent to nil, which in the relational model allows no steps
the iteration operators c(cid:16) and c
at all, not even environment steps, but for use in guarantees, zero iterations should allow environment steps and hence
c(cid:16) (cid:98)= c(cid:63) skip
(cid:125) (cid:118) c(cid:16)
c
(cid:125) (cid:118) skip
c

Lemma 13 (iteration). The following properties follow from Lemma 4 (fold/unfold) and Lemma 5 (induction).

(cid:125) (cid:98)= c◦ skip

if c (cid:118) skip c
if c (cid:118) skip c

(cid:125)
(cid:125) (cid:118) c
c
(cid:125)
(cid:125) (cid:118) (c
)(cid:63)

(92)
(93)

(90)
(91)

(88)

(89)

c
c

(cid:125)

c

Law 14 (conjunction-distribute-guarantee). If c (cid:118) skip c,

(cid:125) (cid:101) d◦ (cid:118) (c

(cid:125) (cid:101) d)◦

c

(94)
Proof. The proof can be shown using Lemma 3 (fusion) part (26) with G = (λx · nil (cid:117) d x) and hence µG = d◦,
H = (λx · nil (cid:117) (c
(cid:125) (cid:101) d◦.
Note that F distributes over arbitrary suprema because weak conjunction distributes over arbitrary suprema (49). The
(cid:125) (cid:101) x) which holds as follows.
proviso for Lemma 3 (fusion) part (26) requires c

(cid:125) (cid:101) x) and hence F (µG) = c
(cid:125) (cid:101) d) (c

(cid:125) (cid:101) d)◦, and F = (λx · c
(cid:125) (cid:101) (nil (cid:117) d x) (cid:118) nil (cid:117) (c

(cid:125) (cid:101) d) x) and hence µH = (c

c

(cid:125) (cid:101) (nil (cid:117) d x)
(cid:125) (cid:101) nil) (cid:117) (c
(c
nil (cid:117) (c
nil (cid:117) (c

(cid:125) (cid:101) d x)
c
(cid:125) (cid:101) d) (c

(cid:125)

(cid:125) (cid:101) x)

(cid:125) (cid:101) d x)

= distributing weak conjunction over non-deterministic choice (48)
(cid:125) (cid:118) skip (cid:118) nil by (91) and (41) and c
(cid:118) by Law 7 (reﬁne-conjunction) as c
(cid:118) exchanging weak conjunction and sequential composition by axiom (51)

(cid:125) (cid:118) c

(cid:125)

(cid:125) by (92) as c (cid:118) skip c
c

(cid:3)

3.2. Weak conjunction in the relational model

In the relational model weak conjunction corresponds to synchronised execution of atomic steps by both processes
unless either process aborts, i.e. every non-aborting step taken by c (cid:101) d must be a step allowed by both c and d. If
either process aborts, the conjunction aborts (55). The weak conjunction of two atomic step commands (cid:104)g(cid:105) and (cid:104)r(cid:105) can
perform a program step that satisﬁes both g and r (95). An atomic step (cid:104)g(cid:105) allows any environment step whatsoever
and hence two atomic step commands synchronise trivially on environment steps. More generally, the ﬁrst program
steps of conjoined commands synchronise followed by the weak conjunction of the remainder of both commands (96).
If one command in a weak conjunction must do a program step but the other cannot, their conjunction never terminates
and does no program steps (97).

(cid:104)g(cid:105) (cid:101) (cid:104)r(cid:105) = (cid:104)g ∩ r(cid:105)

skip (cid:101) ((cid:104)g(cid:105) c) = skip(cid:62)

(97)

((cid:104)g(cid:105) c) (cid:101) ((cid:104)r(cid:105) d) = (cid:104)g ∩ r(cid:105) (c (cid:101) d)
The command chaos performs any sequence of non-aborting program steps and allows any environment steps,
while term allows only a ﬁnite sequence of non-aborting program steps and any environment steps. Both are deﬁned

(95)
(96)

in terms of the iteration operators that allow environment steps for zero iterations.

Generalised rely-guarantee concurrency

chaos (cid:98)= (cid:104)univ(cid:105)(cid:125)
r1 ⊆ r0 ⇒ (cid:104)r0(cid:105)(cid:16) (cid:118) (cid:104)r1(cid:105)(cid:16)
r1 ⊆ r0 ⇒ (cid:104)r0(cid:105)(cid:125) (cid:118) (cid:104)r1(cid:105)(cid:125)

11

(99)

(106)

(98)

term (cid:98)= (cid:104)univ(cid:105)(cid:16)
(cid:104)r0 ∪ r1(cid:105)(cid:16) = (cid:104)r0(cid:105)(cid:16) (cid:107) (cid:104)r1(cid:105)(cid:16)
(cid:104)r0 ∪ r1(cid:105)(cid:125) (cid:118) (cid:104)r0(cid:105)(cid:125) (cid:107) (cid:104)r1(cid:105)(cid:125)
= (cid:104)r(cid:105)(cid:125) (cid:107) (cid:104)r(cid:105)(cid:125)

(cid:104)r(cid:105)(cid:125)

Iterations of atomic steps satisfy the following properties [HJC14].

(100)
(101)

(102)
(103)
(104)
Properties (100) and (101) follow using (81) from (66) and (67), respectively.
In the relational model a command c preconditioned by the state predicate p is represented by ({p} c). If p holds
initially, {p} behaves as nil and hence ({p} c) behaves as c but if p does not hold initially, the preconditioned command
aborts. A precondition distributes into both a weak conjunction and into a parallel composition. These laws follow from
the deﬁnition of a precondition command (77) and distribution properties in the relational semantics.
Law 15 (precondition-conjunction).
Law 16 (precondition-parallel).

{p} (c (cid:101) d) = ({p} c) (cid:101) ({p} d) .

{p} (c (cid:107) d) = ({p} c) (cid:107) ({p} d) .

Morgan’s speciﬁcation command, [q], is reﬁned by any program that terminates with its initial and ﬁnal states

related by q provided there is no interference from the environment [Mor88].

[q] (cid:98)= (cid:100){σ ∈ Σ · τ ({σ}) term τ ({σ(cid:48) | (σ, σ(cid:48)) ∈ q})} (cid:101) (env id)

(105)
The behaviour of [q] consists of terminating traces that start in some state σ and terminate in a state σ(cid:48) such that
(σ, σ(cid:48)) ∈ q. It assumes all steps of its environment do not modify the state (i.e. satisfy the identity relation id).
Its behaviour includes ﬁnite infeasible traces starting from any state and traces ending in an inﬁnite sequence of
environment steps. Conjoining two speciﬁcations achieves the conjunction of their postconditions.

[q0] (cid:101) [q1] = [q0 ∩ q1]

3.3. Relationship to Jones-style guarantee

Jones introduced the idea of using a guarantee condition g, a binary relation between states, to express the fact that
every atomic program step a process makes is guaranteed to satisfy g between its before-state and after-state [Jon83].
The relation g is required to be reﬂexive so that stuttering steps are allowed. A guarantee g on a terminating command

c can be deﬁned in terms of a weak conjunction as (cid:104)g(cid:105)(cid:16) (cid:101) c. The weak conjunction with (cid:104)g(cid:105)(cid:16) restricts the behaviour
of c so that every atomic program step satisﬁes g. The command (cid:104)g(cid:105)(cid:16) is used rather than (cid:104)g(cid:105)(cid:63) so that zero iterations
corresponds to skip rather than nil and hence does not constrain environment steps in this case. More generally, if
c is not assumed to be terminating, a guarantee is represented by (cid:104)g(cid:105)(cid:125) (cid:101) c. Possibly inﬁnite iteration is used rather
than ﬁnite iteration because weak conjunction with ﬁnite iteration forces termination and hence is too strong [HJC14].
Termination of (cid:104)g(cid:105)(cid:125) (cid:101) c depends only on whether c terminates if its traces are restricted to program steps satisfying
g. The guarantee component (cid:104)g(cid:105)(cid:125) is non-aborting and hence any aborting behaviour can only arise from c. Using the
supremum operator (cid:104)g(cid:105)(cid:125) (cid:116) c would be too strong a guarantee because (cid:104)g(cid:105)(cid:125) has only non-aborting traces and hence
would mask any aborting behaviour of c.
either (cid:104)g(cid:105)(cid:16) or (cid:104)g(cid:105)(cid:125). By treating guarantees as processes more expressive guarantee conditions can be expressed,
for example, the process (cid:104)g0(cid:105)(cid:16) (cid:104)g1(cid:105)(cid:16) represents a guarantee of g0 initially, followed at some point by a switch to
a guarantee of g1. As another example, the process (cid:104)id(cid:105)(cid:16) (cid:104)g(cid:105)(cid:104)id(cid:105)(cid:16) represents a guarantee to perform a single step
satisfying g surrounded by any ﬁnite number of steps that don’t modify any variables. Neither of these guarantee
the guarantees are used. It is possible to encode a sequence such as (cid:104)g0(cid:105)(cid:16) (cid:104)g1(cid:105)(cid:16) via the use of an additional boolean
processes can be represented as a single guarantee relation unless additional variables that distinguish the phases of
variable b which is initially false: (¬b ∧ g0) ∨ (b ∧ g1 ∧ b(cid:48)), where it is assumed b is set to true for the transition from
a guarantee of g0 to g1.

A guarantee relation g in the style of Jones is represented here by an iterated atomic step satisfying the relation,

3.4. Laws for guarantees
If g0 ⊆ g1, then a guarantee of g0 is stronger than a guarantee of g1.

12

Ian J. Hayes

Law 17 (guarantee-strengthen). For any command c and relations g0 and g1 such that g0 ⊆ g1,

(cid:104)g1(cid:105)(cid:125) (cid:101) c (cid:118) (cid:104)g0(cid:105)(cid:125) (cid:101) c .

c (cid:118) (cid:104)g(cid:105)(cid:125) (cid:101) c .

Proof. By (101), (cid:104)g1(cid:105)(cid:125) (cid:118) (cid:104)g0(cid:105)(cid:125), and hence the law follows by Law 6 (monotonic) part (65). (cid:3)
Law 18 (guarantee-introduce).
Proof. The proof follows by Law 9 (conjoin-non-aborting) because by (98) chaos = (cid:104)univ(cid:105)(cid:125) (cid:118) (cid:104)g(cid:105)(cid:125) by (101). (cid:3)
Law 19 (conjunction-atomic-iterated).
Proof. The reﬁnement from left to right follows by Law 7 (reﬁne-conjunction) because by (101) both (cid:104)g0(cid:105)(cid:125) and (cid:104)g1(cid:105)(cid:125)
are reﬁned by (cid:104)g0 ∩ g1(cid:105)(cid:125). The reﬁnement from right to left can be proved using Lemma 5 (induction) part (61) using
(96) and (97). (cid:3)
Law 20 (guarantee-nested).
Proof. By Law 19 (conjunction-atomic-iterated), (cid:104)g0(cid:105)(cid:125) (cid:101) (cid:104)g1(cid:105)(cid:125)

(cid:104)g0(cid:105)(cid:125) (cid:101) (cid:104)g1(cid:105)(cid:125) (cid:101) c = (cid:104)g0 ∩ g1(cid:105)(cid:125) (cid:101) c

= (cid:104)g0 ∩ g1(cid:105)(cid:125). (cid:3)

(cid:104)g0(cid:105)(cid:125) (cid:101) (cid:104)g1(cid:105)(cid:125)

= (cid:104)g0 ∩ g1(cid:105)(cid:125)

A guarantee distributes through non-deterministic choice, weak conjunction, parallel and sequential composition,

and ﬁnite and inﬁnite iterations.
Law 21 (guarantee-distribute).

(cid:104)g(cid:105)(cid:125) (cid:101) (c d) (cid:118) ((cid:104)g(cid:105)(cid:125) (cid:101) c) ((cid:104)g(cid:105)(cid:125) (cid:101) d)

(cid:104)g(cid:105)(cid:125) (cid:101) (c (cid:117) d) = ((cid:104)g(cid:105)(cid:125) (cid:101) c) (cid:117) ((cid:104)g(cid:105)(cid:125) (cid:101) d)
(cid:104)g(cid:105)(cid:125) (cid:101) (c (cid:101) d) = ((cid:104)g(cid:105)(cid:125) (cid:101) c) (cid:101) ((cid:104)g(cid:105)(cid:125) (cid:101) d)
(cid:104)g(cid:105)(cid:125) (cid:101) (c (cid:107) d) (cid:118) ((cid:104)g(cid:105)(cid:125) (cid:101) c) (cid:107) ((cid:104)g(cid:105)(cid:125) (cid:101) d)

(107)
(108)
(109)
(110)
(111)
(112)
Proof. Property (107) holds because weak conjunction distributes over non-deterministic choice (48), and (108–111)
hold by the corresponding properties (82–85) of Law 12 (conjunction-distribute). For property (109) the proviso holds
because (cid:104)g(cid:105)(cid:125)
= (cid:104)g(cid:105)(cid:125) (cid:107) (cid:104)g(cid:105)(cid:125) by (104); and for property (110) the proviso holds because (cid:104)g(cid:105)(cid:125) (cid:118) (cid:104)g(cid:105)(cid:125) (cid:104)g(cid:105)(cid:125) by
(92). Property (111) holds by (85) because (cid:104)g(cid:105)(cid:125) (cid:118) ((cid:104)g(cid:105)(cid:125)
)(cid:63) by (93). Both (92) and (93) require the side condition
(cid:104)g(cid:105) (cid:118) skip(cid:104)g(cid:105), which holds by (76). Property (112) follows from Law 14 (conjunction-distribute-guarantee). (cid:3)

(cid:104)g(cid:105)(cid:125) (cid:101) c(cid:63) (cid:118) ((cid:104)g(cid:105)(cid:125) (cid:101) c)(cid:63)
(cid:104)g(cid:105)(cid:125) (cid:101) c◦ (cid:118) ((cid:104)g(cid:105)(cid:125) (cid:101) c)◦

Jones introduced the idea of a rely condition, a reﬂexive relation assumed to be satisﬁed by every atomic step of the

4. The rely quotient command
interference from the environment of a process [Jon83]. In essence it abstracts the environment by a process (cid:104)r(cid:105)(cid:16) that
process i. The rules of Jones then become a special case when i = (cid:104)r(cid:105)(cid:16) (see Section 7). To handle relies in the general

executes steps satisfying the rely condition r. In the general algebra the environment is represented by an arbitrary

algebra, a rely quotient operator “//” is introduced. It is deﬁned so that c // i in parallel with i implements c, i.e.,

c (cid:118) (c // i) (cid:107) i ,

and furthermore for any process d, if c (cid:118) d (cid:107) i then c // i (cid:118) d. For example, because (cid:104)r0 ∨ r1(cid:105)(cid:16) (cid:118) (cid:104)r0(cid:105)(cid:16) (cid:107) (cid:104)r1(cid:105)(cid:16)
holds in the relational model, one reﬁnement of the quotient (cid:104)r0 ∨ r1(cid:105)(cid:16) // (cid:104)r1(cid:105)(cid:16) is (cid:104)r0(cid:105)(cid:16).

The motivation for the rely quotient is similar to that for the weakest pre- and post-speciﬁcations of Hoare and
He [HH86], although they deal with residuals of sequential composition rather than parallel composition, and weakest
environment of Chaochen and Hoare [CH81, Cha82]. The rely quotient c // i is deﬁned as the non-deterministic choice
over all commands d satisfying the deﬁning property of the rely quotient: c (cid:118) d (cid:107) i.
Deﬁnition 5 (rely-quotient).

This deﬁnition is similar to deﬁning division over the positive integers in terms of multiplication and minimum ((cid:100)).
(cid:100)c/i(cid:101) (cid:98)=(cid:100){d | (c ≤ d × i)}

c // i (cid:98)= (cid:100){d | (c (cid:118) d (cid:107) i)} .

The only command d satisfying c (cid:118) d (cid:107) i might be the infeasible command (cid:62), in which case c // i is infeasible. In

(113)

Generalised rely-guarantee concurrency

13

particular, taking the interference i to be the aborting process ⊥ gives, c // ⊥ = (cid:100){d | (c (cid:118) d (cid:107) ⊥)} = (cid:62), unless

c = ⊥, in which case ⊥ // ⊥ = ⊥.

Because the rely quotient operation is deﬁned in terms of nondeterministic choice and parallel composition, its
instantiation in the relational model follows directly from its deﬁnition. For completeness, an expansion of its deﬁnition
in the relational model is given below, in which //r and (cid:107)r stand for the interpretations of these operators in the
relational model; recall that nondeterministic choice corresponds to set union and reﬁnement to set containment.

(cid:91){d ∈ Com | c ⊇ d (cid:107)r i}
(cid:91){d ∈ Com | c ⊇ abort close({t ∈ Trace | ∃td ∈ d, ti ∈ i · match trace(td, ti, t)})}

c //r i =

=

A full appreciation of the utility of the rely quotient operator ﬂows from its use in introducing a parallel composition
in Section 5 but ﬁrst we examine a set of basic laws that it satisﬁes.

4.1. Laws for rely quotients

The following law shows that the rely quotient command satisﬁes its motivating property (113). The law corresponds
to c ≤ (cid:100)c/i(cid:101) × i for positive integer division.
Law 22 (rely-quotient).
Proof. The notation {x | p · e} used below represents the set of values of the expression e for x ranging over values
that satisfy the predicate p.

c (cid:118) (c // i) (cid:107) i .

c (cid:118) (c // i) (cid:107) i

c (cid:118) (cid:100){d | (c (cid:118) d (cid:107) i)} (cid:107) i
c (cid:118) (cid:100){d | (c (cid:118) d (cid:107) i) · (d (cid:107) i)}

⇔ by Deﬁnition 5 (rely-quotient)
⇔ distributing parallel over non-deterministic choice (39)
⇐ by Lemma 1 (non-deterministic-choice)

∀d ∈ {d | (c (cid:118) d (cid:107) i)} · c (cid:118) (d (cid:107) i)

(cid:3)

(cid:3)

The following fundamental law shows that the rely quotient is the least command satisfying its deﬁning property. It
provides the basis for the proof of many of the laws that follow and shows the Galois connection between rely quotient
and parallel composition [Aar92, BCG02]. It corresponds to (cid:100)c/i(cid:101) ≤ d ⇔ c ≤ d ∗ i for positive integer division.
Law 23 (rely-reﬁnement).
Proof. For the proof from right to left assume c (cid:118) d (cid:107) i.

c // i (cid:118) d ⇔ c (cid:118) d (cid:107) i .

c // i (cid:118) d

(cid:100){d1 | (c (cid:118) d1 (cid:107) i)} (cid:118) d

⇔ by Deﬁnition 5 (rely-quotient)
⇐ by Lemma 1 (non-deterministic-choice)
⇐ by assumption d ∈ {d1 | (c (cid:118) d1 (cid:107) i)}

∃d0 ∈ {d1 | (c (cid:118) d1 (cid:107) i)} · d0 (cid:118) d
d (cid:118) d

⇒ by Law 6 (monotonic) part (63) as c // i (cid:118) d

c (cid:118) (c // i) (cid:107) i
c (cid:118) d (cid:107) i

The proof from left to right assumes c // i (cid:118) d and starts with Law 22 (rely-quotient).

The property in Law 23 (rely-reﬁnement) could be used as an alternative deﬁnition of the rely quotient operator.
From Galois theory, the rely quotient (lower adjoint) is uniquely deﬁned by the Galois connection provided parallel
distributes over non-deterministic choice (39).

Because skip is the identity of parallel composition, it is also the right identity of the rely quotient. This is similar

to 1 being the right identity of integer division (c/1 = c).

14

Ian J. Hayes

Law 24 (rely-identity-right).
Proof. The law holds by indirect equality if for all x, c // skip (cid:118) x ⇔ c (cid:118) x, which holds by Law 23 (rely-reﬁnement)
as follows: c // skip (cid:118) x ⇔ c (cid:118) x (cid:107) skip ⇔ c (cid:118) x. (cid:3)
The following two laws correspond to c ≤ d ⇒ (cid:100)c/i(cid:101) ≤ (cid:100)d/i(cid:101) and i ≤ j ⇒ (cid:100)c/j(cid:101) ≤ (cid:100)c/i(cid:101) for positive integer

c // skip = c

c (cid:118) d ⇒ (c // i) (cid:118) (d // i) .

division.
Law 25 (rely-monotonic).
Proof. By Law 23 (rely-reﬁnement), (c // i) (cid:118) (d // i) holds if c (cid:118) (d // i) (cid:107) i, which holds by the assumption c (cid:118) d
and Law 22 (rely-quotient) because c (cid:118) d (cid:118) (d // i) (cid:107) i . (cid:3)
i (cid:118) j ⇒ (c // j) (cid:118) (c // i) .
Law 26 (rely-weaken).
Proof. By Law 23 (rely-reﬁnement) (c // j) (cid:118) (c // i) holds if c (cid:118) (c // i) (cid:107) j, which holds as follows.
c(cid:118) by Law 22 (rely-quotient)
(c // i) (cid:107) i
(cid:118) by Law 6 (monotonic) part (63) as i (cid:118) j
(c // i) (cid:107) j

[Italic text between horizontal lines partitions out material that applies only to the relational model.]

(cid:3)
For relational rely conditions, if r1 ⊆ r0, then by (100), (cid:104)r0(cid:105)(cid:16) (cid:118) (cid:104)r1(cid:105)(cid:16), and applying Law 26 (rely-weaken) gives
(c // (cid:104)r1(cid:105)(cid:16)) (cid:118) (c // (cid:104)r0(cid:105)(cid:16)), i.e. the relational rely condition can be weakened in a reﬁnement.
A nested rely (c // j) // i corresponds to implementing c within environment j, all within in environment i, i.e. c is
implemented in environment i (cid:107) j. The next law corresponds to (cid:100)(cid:100)c/i(cid:101)/j(cid:101) = (cid:100)c/(i × j)(cid:101) for positive integer division.

Law 27 (rely-nested).
Proof. The law follows by indirect equality if for all x, (c // j) // i (cid:118) x ⇔ c // (i (cid:107) j) (cid:118) x, which is shown as follows.

(c // j) // i = c // (i (cid:107) j) .

⇔ by Law 23 (rely-reﬁnement)
⇔ by Law 23 (rely-reﬁnement)
⇔ by Law 23 (rely-reﬁnement)

(c // j) // i (cid:118) x
c // j (cid:118) x (cid:107) i
c (cid:118) x (cid:107) i (cid:107) j
c // (i (cid:107) j) (cid:118) x

(cid:3)
Because parallel is commutative, it follows that (c // j) // i = c // (i (cid:107) j) = c // (j (cid:107) i) = (c // i) // j.
For relational rely conditions by property (102), (cid:104)r0(cid:105)(cid:16) (cid:107) (cid:104)r1(cid:105)(cid:16) = (cid:104)r0 ∪ r1(cid:105)(cid:16), and hence by Law 27 (rely-nested)
nested relational relies of r0 and r1 give an effective rely of r0 ∪ r1.
(c // (cid:104)r1(cid:105)(cid:16)) // (cid:104)r0(cid:105)(cid:16) = c // ((cid:104)r0(cid:105)(cid:16) (cid:107) (cid:104)r1(cid:105)(cid:16)) = c // (cid:104)r0 ∪ r1(cid:105)(cid:16) .

(114)

5. Parallel-introduction law

The prime motivation of Jones [Jon83] for introducing rely and guarantee conditions was to support reasoning about
parallel compositions. In the current paper a guarantee condition is generalised to a weak conjunction with a process,
and a rely condition by a rely quotient by a process. Law 28 (parallel-introduce) provides an general law for introducing
a parallel composition. The guarantee j of the ﬁrst branch of the parallel corresponds to the rely of the second branch
and vice versa for i.

Generalised rely-guarantee concurrency

15

Law 28 (parallel-introduce).
Proof. By Law 22 (rely-quotient) both c (cid:118) (c // i) (cid:107) i and d (cid:118) (d // j) (cid:107) j and hence the proof follows using these
two properties in the ﬁrst step.

c (cid:101) d (cid:118) (j (cid:101) (c // i)) (cid:107) (i (cid:101) (d // j))

(cid:118) by Law 6 (monotonic) part (65) and parallel is commutative (37)
(cid:118) exchanging weak conjunction and parallel by axiom (50)

c (cid:101) d
((c // i) (cid:107) i) (cid:101) (j (cid:107) (d // j))
((c // i) (cid:101) j) (cid:107) (i (cid:101) (d // j))

(cid:3)

The simplicity and elegance of the proof of this fundamental law for handling rely-guarantee concurrency is an
indication that weak conjunction and rely quotient are well chosen abstractions. The relationship to the parallel law of
Jones is explored in Section 7 but ﬁrst distribution properties of rely quotients need to be explored.

6. Distribution of rely quotients

Law 28 (parallel-introduce) introduces rely quotients of the form c // i for some speciﬁcation c. One way of reﬁning
such a quotient is to reﬁne c, for example, c may be reﬁned to a sequential composition c0 c1. Law 25 (rely-monotonic)
then gives that c//i (cid:118) (c0 c1)//i. To further reﬁne this it is useful to have a distribution law that allows the rely quotient
to be distributed over the sequential composition, i.e. (c0 c1) // i (cid:118) (c0 // i) (c1 // i). A proviso is needed for this
reﬁnement to be valid (see Law 32 below). This section investigates laws for distributing rely quotients over the other
operators. A rely quotient distributes straightforwardly over both weak conjunction and non-deterministic choice.
Law 29 (rely-distribute-conjunction).
Proof. By Law 23 (rely-reﬁnement) the law is equivalent to c (cid:101) d (cid:118) ((c // i) (cid:101) (d // i)) (cid:107) i.

(c (cid:101) d) // i (cid:118) (c // i) (cid:101) (d // i)

c (cid:101) d
(cid:118) by Law 22 (rely-quotient) twice
((c // i) (cid:107) i) (cid:101) ((d // i) (cid:107) i)
(cid:118) exchanging weak conjunction and parallel by axiom (50)
((c // i) (cid:101) (d // i)) (cid:107) (i (cid:101) i)
= as “(cid:101)” is idempotent (44)
((c // i) (cid:101) (d // i)) (cid:107) i

(cid:3)

Law 30 (rely-distribute-choice).
Proof. By Law 23 (rely-reﬁnement) the law is equivalent to c (cid:117) d (cid:118) ((c // i) (cid:117) (d // i)) (cid:107) i.

(c (cid:117) d) // i (cid:118) (c // i) (cid:117) (d // i)

(cid:118) by Law 22 (rely-quotient) twice

c (cid:117) d
((c // i) (cid:107) i) (cid:117) ((d // i) (cid:107) i)
((c // i) (cid:117) (d // i)) (cid:107) i

= distributing parallel over non-deterministic choice (39)

(cid:3)

Distribution of the rely quotient over parallel requires a proviso on the interference i that i (cid:107) i (cid:118) i. That

distribution law follows from a more general law with a parallel in both arguments of the quotient.
Law 31 (rely-distribute-parallel).

(c (cid:107) d) // (i (cid:107) j) (cid:118) (c // i) (cid:107) (d // j)

(c (cid:107) d) // i (cid:118) (c // i) (cid:107) (d // i) if i (cid:107) i (cid:118) i

(115)
(116)

16

Ian J. Hayes

Proof. By Law 23 (rely-reﬁnement), (115) holds if c (cid:107) d (cid:118) (c // i) (cid:107) (d // j) (cid:107) i (cid:107) j, which holds as follows.

(cid:118) by Law 22 (rely-quotient) twice

c (cid:107) d
((c // i) (cid:107) i) (cid:107) ((d // j) (cid:107) j)
(c // i) (cid:107) (d // j) (cid:107) i (cid:107) j

= by associativity (36) and commutativity (37) of parallel

The proof of (116) uses (115) with j = i as follows.

(cid:118) by Law 26 (rely-weaken) using assumption i (cid:107) i (cid:118) i
(cid:118) by part (115) with j = i

(c (cid:107) d) // i
(c (cid:107) d) // (i (cid:107) i)
(c // i) (cid:107) (d // i)

(cid:3)
For a relational rely condition, if i = (cid:104)r(cid:105)(cid:16) then by (102), (cid:104)r(cid:105)(cid:16) (cid:107) (cid:104)r(cid:105)(cid:16) = (cid:104)r ∪ r(cid:105)(cid:16) = (cid:104)r(cid:105)(cid:16), and hence the proviso

for (116) holds in this case. The fact that the proviso for a relational rely condition holds allows rely conditions to be
distributed into any parallel composition.

Distribution of a rely quotient of a process i over a sequential composition requires that separate occurrences of i
running in parallel with each command in the sequence can be reﬁned to a single occurrence of i run in parallel with
the sequence as given by condition (117).
Law 32 (rely-distribute-sequential). If for process i,

∀c0, c1 · (c0 (cid:107) i) (c1 (cid:107) i) (cid:118) (c0 c1) (cid:107) i,

then

(c d) // i (cid:118) (c // i) (d // i) .

Proof. By Law 23 (rely-reﬁnement), (118) is equivalent to c d (cid:118) ((c // i) (d // i)) (cid:107) i.
c d(cid:118) by Law 22 (rely-quotient) twice
((c // i) (cid:107) i) ((d // i) (cid:107) i)
(cid:118) by assumption (117) with c0 = c // i and c1 = d // i
((c // i) (d // i)) (cid:107) i

(cid:3)
For a relational rely condition, if i = (cid:104)r(cid:105)(cid:16) then (c (cid:107) (cid:104)r(cid:105)(cid:16)) (d (cid:107) (cid:104)r(cid:105)(cid:16)) = (c d) (cid:107) (cid:104)r(cid:105)(cid:16) holds for any c, d and r

and hence proviso (117) holds. As with parallel, the use of a relational rely condition allows the rely to be distributed
into any sequential composition. In the general case, if proviso (117) does not hold the question arises as to what
alternative approaches could be used – as with Law 31 (rely-distribute-parallel) these are likely to depend on the form
of the interference.

Distribution of the rely quotient over an iteration requires the same side condition (117) on distribution of the
interference i over a sequential composition as for Law 32. The law uses the more general form c◦ d = µx · d (cid:117) c x.
This allows the law to be applied to a while loop while b do c, which can be deﬁned in the form (bc)◦¯b where b stands
for the test of the while loop succeeding and ¯b for it failing. Just developing a law for c◦ is problematic for the zero
iterations case because this corresponds to nil // i and nil // i (cid:118) d holds if and only if nil (cid:118) d (cid:107) i, which only holds
if i behaves as either nil or (cid:62).
Law 33 (rely-distribute-iteration). If

∀c0, c1 · (c0 (cid:107) i) (c1 (cid:107) i) (cid:118) (c0 c1) (cid:107) i,
(c◦ d) // i (cid:118) (c // i)◦ (d // i) .

holds for i,

(117)

(118)

(119)

Generalised rely-guarantee concurrency

17

Proof. By Law 23 (rely-reﬁnement) the law is equivalent to c◦ d (cid:118) ((c // i)◦ (d // i)) (cid:107) i and by Lemma 5 (induction)
it is sufﬁcient to show,

d (cid:117) c (((c // i)◦ (d // i)) (cid:107) i) (cid:118) ((c // i)◦ (d // i)) (cid:107) i,

(cid:118) by Law 22 (rely-quotient) applied to each of the ﬁrst d and c
(cid:118) by assumption (119) with c0 = c // i and c1 = (c // i)◦ (d // i)

which can be shown as follows.
d (cid:117) c (((c // i)◦ (d // i)) (cid:107) i)
((d // i) (cid:107) i) (cid:117) ((c // i) (cid:107) i) (((c // i)◦ (d // i)) (cid:107) i)
((d // i) (cid:107) i) (cid:117) (((c // i) (c // i)◦ (d // i)) (cid:107) i)
((d // i) (cid:117) (c // i) (c // i)◦ (d // i)) (cid:107) i
((nil (cid:117) (c // i) (c // i)◦) (d // i)) (cid:107) i
= folding using (16)
((c // i)◦ (d // i)) (cid:107) i

= distributing parallel over non-deterministic choice (39)

= factoring out d // i using (34)

(cid:3)
The proviso (119) holds for a relational rely i = (cid:104)r(cid:105)(cid:16) and hence Law 33 (rely-distribute-iteration) holds in this case.

The following laws combine distribution properties with the introduction of a parallel composition.

Law 34 (parallel-introduce-with-rely).

(c (cid:101) d) // i (cid:118) (j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) (d // (j1 (cid:107) i)))

Proof.

(cid:118) by Law 29 (rely-distribute-conjunction)
(cid:118) by Law 28 (parallel-introduce)

(c (cid:101) d) // i
(c // i) (cid:101) (d // i)
(j1 (cid:101) ((c // i) // j0)) (cid:107) (j0 (cid:101) ((d // i) // j1))
(j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) (d // (j1 (cid:107) i)))

= by Law 27 (rely-nested) twice

In the right side of the above law one branch of the parallel guarantees j1 and the other guarantees j0, and hence

(cid:3)
their parallel combination guarantees j1 (cid:107) j0.
Law 35 (parallel-introduce-with-rely-guarantee).

(j1 (cid:107) j0) (cid:101) (c (cid:101) d) // i (cid:118) (j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) (d // (j1 (cid:107) i))) .

Proof.

(j1 (cid:107) j0) (cid:101) ((c (cid:101) d) // i)
(cid:118) by Law 34 (parallel-introduce-with-rely)
(j1 (cid:107) j0) (cid:101) ((j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) (d // (j1 (cid:107) i))))
(cid:118) exchanging weak conjunction and parallel by axiom (50)
(j1 (cid:101) j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) j0 (cid:101) (d // (j1 (cid:107) i)))
(j1 (cid:101) (c // (j0 (cid:107) i))) (cid:107) (j0 (cid:101) (d // (j1 (cid:107) i)))

= as weak conjunction is idempotent (44)

(cid:3)
In the relational model by (103), (cid:104)g ∪ r(cid:105)(cid:125) (cid:118) (cid:104)g(cid:105)(cid:125) (cid:107) (cid:104)r(cid:105)(cid:125) and hence if j1 = (cid:104)g(cid:105)(cid:125) and j0 = (cid:104)r(cid:105)(cid:125) the effective
guarantee for Law 35 is g ∪ r.

18

Ian J. Hayes

7. Relationship to relational rely

This section explores the relationship to the Jones-style rely condition. Jones considered total correctness rules for
handling the implementation of a pre-post speciﬁcation in a context satisfying a rely condition [CJ07]. To instantiate
the general theory presented here for Jones-style rely-guarantee rules, termination needs to be handled. For a terminat-
ing command, such as a speciﬁcation [q], using a rely quotient of [q] //(cid:104)r(cid:105)(cid:125) leads to an infeasible speciﬁcation because
by Law 22 (rely-quotient) this requires

[q] (cid:118) ([q] // (cid:104)r(cid:105)(cid:125)

) (cid:107) (cid:104)r(cid:105)(cid:125)

the following.

but [q] is terminating and (cid:104)r(cid:105)(cid:125) has non-terminating behaviours and hence [q] // (cid:104)r(cid:105)(cid:125) must rule out such inﬁnite
behaviours of its environment. However, executable code cannot rule out behaviours of its environment and hence
using (cid:104)r(cid:105)(cid:125) for a rely quotient for a terminating command is not a feasible approach. Therefore the terminating iteration
(cid:104)r(cid:105)(cid:16) must be used. Choosing i and j be the processes (cid:104)r(cid:105)(cid:16) and (cid:104)g(cid:105)(cid:16), respectively, in Law 28 (parallel-introduce) gives

c (cid:101) d (cid:118) ((cid:104)g(cid:105)(cid:16) (cid:101) (c // (cid:104)r(cid:105)(cid:16))) (cid:107) ((cid:104)r(cid:105)(cid:16) (cid:101) (d // (cid:104)g(cid:105)(cid:16)))

(120)
Note that due to the use of a weak conjunction to enforce a guarantee, the ﬁrst branch of the parallel composition
is only required to maintain its guarantee condition g as long as its environment maintains its rely condition r. If
its environment does not maintain r the rely quotient can abort, at which point the whole branch of the parallel is
considered to have aborted and hence the guarantee no longer needs to be maintained.
The parallel introduction rule of Jones [Jon83] takes a postcondition of the form q0 ∩ q1 and introduces a parallel

composition in which the two branches ensure q0 and q1 respectively.
Law 36 (parallel-speciﬁcation).

{p} [q0 ∩ q1] (cid:118) ({p} ((cid:104)g(cid:105)(cid:16) (cid:101) ([q0] // (cid:104)r(cid:105)(cid:16)))) (cid:107) ({p} ((cid:104)r(cid:105)(cid:16) (cid:101) ([q1] // (cid:104)g(cid:105)(cid:16))))

Proof. Note that by (106) a speciﬁcation [q0 ∩ q1] is equivalent to [q0] (cid:101) [q1].

{p} [q0 ∩ q1]
= by (106)
{p} ([q0] (cid:101) [q1])
(cid:118) by Law 28 (parallel-introduce)
{p} (((cid:104)g(cid:105)(cid:16) (cid:101) ([q0] // (cid:104)r(cid:105)(cid:16))) (cid:107) ((cid:104)r(cid:105)(cid:16) (cid:101) ([q1] // (cid:104)g(cid:105)(cid:16))))
({p} ((cid:104)g(cid:105)(cid:16) (cid:101) ([q0] // (cid:104)r(cid:105)(cid:16)))) (cid:107) ({p} ((cid:104)r(cid:105)(cid:16) (cid:101) ([q1] // (cid:104)g(cid:105)(cid:16))))

= by Law 16 (precondition-parallel)

(cid:3)

The above corresponds to the Jones-style proof rule for introducing a parallel composition although phrased in

reﬁnement calculus form rather than as a quintuple.

8. Fair parallelism

This section highlights the parts of the theory that are inﬂuenced by the choice as to whether or not parallelism is
assumed to be fair. The semantics for parallel does not require fairness. A fair semantics would rule out traces ending
in an inﬁnite sequence of program steps of one process, if the other process could make a program step. Most algebraic
properties are independent of whether or not parallel is assumed to be fair. Fair parallel is denoted by c (cid:107)f d. It reﬁnes
the parallel operator used so far, which does not assume fairness.

c (cid:107) d (cid:118) c (cid:107)f d

(121)
If no fairness assumption is made about the parallel operator, the notion of termination of a process is weak as it means
a process terminates provided it is not permanently interrupted by its environment. For the program

x := 1; ((while x (cid:54)= 0 do skip) (cid:107) x := 0)

the while loop will not terminate unless the x := 0 is given a chance to set x to 0. If parallelism is not assumed to be
fair, the loop is not guaranteed to terminate even if it is not permanently interrupted; in fact the problem comes if it is

Generalised rely-guarantee concurrency

19

never interrupted by x := 0. However, if parallel is assumed to be fair, the right process will eventually set x to 0 and
the loop will terminate.

Because the deﬁnition of the rely quotient operator depends on the parallel operator there is different quotient

operator corresponding to fair parallel.
Deﬁnition 6 (fair-quotient).
From (121) it follows that c //f i (cid:118) c // i, that is, any implementation that handles any interference from process i
also handles fair interference from process i.

c //f i (cid:98)= (cid:100){d | (c (cid:118) d (cid:107)f i)}

In the relational model, the property
(cid:104)r0 ∪ r1(cid:105)(cid:125)

= (cid:104)r0(cid:105)(cid:125) (cid:107) (cid:104)r1(cid:105)(cid:125)

(122)
holds, but if parallel is fair (122) becomes a reﬁnement because the left command allows an inﬁnite sequence of steps
satisfying r0 (that do not satisfy r0 ∩ r1), while the right command does not allow such a sequence if parallel is fair.
In proving the laws in this paper, we have relied on (122) only being a reﬁnement, i.e. property (103), and hence our
laws also apply for fair parallel and fair quotient.

9. Related work

Dingel developed a reﬁnement calculus for rely-guarantee concurrency [Din00, Din02]. Like [HJC14] it is based on
relational rely and guarantee conditions but unlike [HJC14] and here, it makes use of a monolithic speciﬁcation which
is a four-tuple of pre, rely, guarantee and post conditions, rather than our separate commands and operators. The
approach used here has the beneﬁt of separating the different concepts and providing laws for each operator as well as
combinations of operators. The laws given here can be combined to derive laws similar to those of Dingel as well as
many other laws. The other major advance over Dingel is the generalisation to use processes for relies and guarantees.
Hoare et al. [HMSW11] have developed a Concurrent Kleene Algebra (CKA) and investigated its extension to a
rely/guarantee CKA. Their algebra includes the axiom (c(cid:62)) = (cid:62), which is not satisﬁed if c is either a non-terminating
process or ⊥ and hence they only consider partial correctness. The rely/guarantee CKA includes a sub-algebra of
commands called invariants, in which an invariant j satisﬁes

j (cid:118) nil
j (cid:118) j (cid:107) j
j (cid:118) j j

(123)
(124)
(125)
because in their algebra c (cid:107) d (cid:118) c d and hence (124) implies (125). Properties (124) and (125) match the properties
used in Law 12 (conjunction-distribute) parts (83) and (84). Properties (123) and (125) together ensure that j = j(cid:63)
and hence that j (cid:101) d(cid:63) = j(cid:63) (cid:101) d(cid:63) (cid:118) (j (cid:101) d)(cid:63) matching Law 12 (conjunction-distribute) part (85). In a rely/guarantee
CKA, for any c and d and any invariant j,

(c (cid:107) j) (d (cid:107) j) (cid:118) (c d) (cid:107) j ,

(126)

which matches our property (117). A rely/guarantee CKA does not require our property j (cid:107) j (cid:118) j but [HMSW11] does
not consider an equivalent of Law 31 (rely-distribute-parallel) for which this property is required. In a rely/guarantee
CKA a Jones-like rely-guarantee quintuple, written p r{d}c g there, is deﬁned in terms of a Hoare triple plus guarantee
condition, in which r and g are invariants (rather than relations).

p r{d}c g (cid:98)= p{r (cid:107) d}c ∧ d guar g ,

Our “equivalent” of (126) is of the form

g (cid:101) {p} (c // r) (cid:118) d ,

(127)
although the two differ due to the different approaches taken. Because g is an invariant the requirement d guar g in
(126) reduces to g (cid:118) d, which is stronger than the requirement in (127). Firstly, in (127) d is only required to satisfy
the guarantee from initial states satisfying the precondition p. Secondly and more subtly, c // r may abort because
its environment does not satisfy r and hence the left side of (127) aborts and so d no longer needs to maintain the
guarantee. This latter condition corresponds to Jones’ requirement that the implementation only needs to maintain the
guarantee condition as long as its environment maintains the rely condition [Jon83]. Our ability to use the weaker
requirement comes from the use of the weak conjunction operator, which is not available in CKA.

20

10. Conclusions

Ian J. Hayes

The main contribution of this paper is to explore the essence of the rely-guarantee approach to concurrency. Jones’
guarantee condition is generalised from a relation to a process by making use of a weak conjunction operator and his
rely condition from a relation to a process by introducing a rely quotient operator, which forms a residual with respect
to parallel composition (see Law 23 (rely-reﬁnement)). Both weak conjunction and rely quotient have simple algebraic
properties. The weak conjunction operator and parallel composition satisfy an exchange property (50) which leads to
a simple and elegant proof of Law 28 (parallel-introduce), which is the key law for introducing a parallel composition
in the generalised rely-guarantee theory. Because our theory allows non-terminating processes, it can handle total
correctness properties as well as reasoning about non-terminating processes.

Generalising rely-guarantee theory so that guarantees and relies are arbitrary processes rather than binary relations
has highlighted the important algebraic properties of rely-guarantee theory. In Law 12 (conjunction-distribute), for a
weak conjunction of a command to distribute over a parallel composition one needs proviso (128); to distribute over a
sequential composition one needs (129); and to distribute over ﬁnite iteration one needs (129) and (130).

c (cid:118) c (cid:107) c
c (cid:118) c c
c (cid:118) nil

(128)
(129)
(130)
Because all these properties hold if c is of the form (cid:104)g(cid:105)(cid:125) for any relation g, the choice by Jones to represent interfer-
ence by an (iterated atomic) relation, rather than a general process, means that Law 21 (guarantee-distribute) for the
Even within the relational model more expressive guarantees are possible, for example, a guarantee of (cid:104)g0(cid:105)(cid:16) (cid:104)g1(cid:105)(cid:16)
relational model does not require any provisos.
(cid:104)g0(cid:105)(cid:16) (cid:104)g1(cid:105)(cid:16) (cid:101) c
(cid:118) assuming c (cid:118) c0 c1
(cid:104)g0(cid:105)(cid:16) (cid:104)g1(cid:105)(cid:16) (cid:101) c0 c1
(cid:118) exchanging weak conjunction and sequential composition (51)
((cid:104)g0(cid:105)(cid:16) (cid:101) c0) ((cid:104)g1(cid:105)(cid:16) (cid:101) c1)

on c may lead to the following reﬁnement, in which c is reﬁned sequentially to match the guarantees.

Law 31 (rely-distribute-parallel) has a proviso of (131), and both Law 32 (rely-distribute-sequential) and Law 33

(rely-distribute-iteration) have a proviso of (132).

i (cid:107) i (cid:118) i

∀c0, c1 · (c0 (cid:107) i) (c1 (cid:107) i) (cid:118) (c0 c1) (cid:107) i

Because both these properties hold for i of the form (cid:104)r(cid:105)(cid:16) for any relation r, the laws do not require any provisos for
relational rely conditions thus simplifying the process of distributing relational rely conditions. Note that taking c0 and
c1 to both be skip in (132) gives i i (cid:118) i. An interesting question for future research is what other processes satisfy
the provisos required for the distribution properties to hold, or what other distribution properties can be used in their
place.

In this paper we have considered an example model based on relational rely-guarantee. The model is similar to that
used by others [CJ07, dBHdR99, Din02, dR01, HJC14] but even within the relational model, guarantees and relies are
treated more generally as processes. Other possible models for future consideration are an event-based model similar
to that used with Concurrent Kleene Algebra [HMSW11] or a model that handles concurrency in a hybrid setting.

(131)
(132)

Acknowledgements

The research reported here was supported by Australian Research Council Grant DP130102901. This paper has ben-
eﬁted from feedback from Robert Colvin, Cliff Jones, Jo˜ao Ferreira, Larissa Meinicke, Carroll Morgan, Kim Solin,
Georg Struth, Kirsten Winter and the anonymous referees but the remaining errors are all courtesy of the author.
Special thanks go to Julian Fell and Andrius Velykis for mechanising the proofs of the laws in Isabelle/HOL.

Generalised rely-guarantee concurrency

21

References

C. J. Aarts. Galois connections presented calculationally. Technical report, Department of Computing Science, Eindhoven University
of Technology, 1992. Afstudeer verslag (Graduating Dissertation).
Chritiene Aarts, Roland Backhouse, Eerke Boiten, Henk Doombos, Netty van Gasteren, Rik van Geldrop, Paul Hoogendijk, Ed Vo-
ermans, and Jaap van der Woude. Fixed-point calculus. Information Processing Letters, 53:131–136, 1995. Mathematics of Program
Construction Group.
P. H. G. Aczel. On an inference rule for parallel composition, 1983. Private communication to Cliff Jones http://homepages.
cs.ncl.ac.uk/cliff.jones/publications/MSs/PHGA-traces.pdf.
R.-J. R. Back. On correct reﬁnement of programs. Journal of Computer and System Sciences, 23(1):49–68, February 1981.
Roland Backhouse, Roy Crole, and Jeremy Gibbons, editors. Algebraic and Coalgebraic Methods in the Mathematics of Program
Construction. Springer, 2002.
Andrzej Blikle. Speciﬁed programming. In Edward K. Blum, Manfred Paul, and Satoru Takasu, editors, Mathematical Studies of
Information Processing, volume 75 of Lecture Notes in Computer Science, pages 228–251. Springer, 1978.
R.-J. R. Back and J. von Wright. Reﬁnement Calculus: A Systematic Introduction. Springer, New York, 1998.
R.-J.R. Back and J. von Wright. Reasoning algebraically about loops. Acta Informatica, 36:295–334, 1999.
Zhou Chaochen and C. A. R. Hoare. Partial correctness of communication protocols. In Technical Monograph PRG-20, Partial
Correctness of Communicating Processes and Protocols, pages 13–23. Oxford University Computing Laboratory, May 1981.
Zhou Chaochen. Weakest environment of communicating processes. In Proc. of the June 7-10, 1982, National Computer Conf.,
AFIPS ’82, pages 679–690, New York, NY, USA, 1982. ACM.
J. W. Coleman and C. B. Jones. A structural proof of the soundness of rely/guarantee rules. Journal of Logic and Computation,
17(4):807–841, 2007.
J.H. Conway. Regular Algebra and Finite Machines. Chapman & Hall, 1971.
F.S. de Boer, U. Hannemann, and W.-P. de Roever. Formal justiﬁcation of the rely-guarantee paradigm for shared-variable concur-
rency: a semantic approach. In Jeannette Wing, Jim Woodcock, and Jim Davies, editors, FM99 Formal Methods, volume 1709 of
Lecture Notes in Computer Science, pages 714–714. Springer Berlin / Heidelberg, 1999.
J¨urgen Dingel. Systematic Parallel Programming. PhD thesis, Carnegie Mellon University, 2000. CMU-CS-99-172.
J. Dingel. A reﬁnement calculus for shared-variable parallel and distributed programming. Formal Aspects of Computing, 14(2):123–
197, 2002.
W.-P. de Roever. Concurrency Veriﬁcation: Introduction to Compositional and Noncompositional Methods. Cambridge University
Press, 2001.
C.A.R. Hoare and Jifeng He. The weakest prespeciﬁcation. Fundamenta Informaticae, IX:51–84, 1986.

[Aar92]

[ABB+95]

[Acz83]

[Bac81]
[BCG02]

[Bli78]

[BvW98]
[BvW99]
[CH81]

[Cha82]

[CJ07]

[Con71]
[dBHdR99]

[Din00]
[Din02]

[dR01]

[HJC14]

[Hoa69]
[JHC15]

[Jon81]

[Jon83]

[Jon96]

[Koz97]
[Mor87]

[Mor88]
[Mor94]
[vW04]

[HH86]
[HHH+87] C. A. R. Hoare, I. J. Hayes, He Jifeng, C. Morgan, A. W. Roscoe, J. W. Sanders, I. H. Sørensen, J. M. Spivey, and B. A. Sufrin. Laws

of programming. Communications of the ACM, 30(8):672–686, August 1987. Corrigenda: CACM 30(9):770.
Ian J. Hayes, Cliff B. Jones, and Robert J. Colvin. Laws and semantics for rely-guarantee reﬁnement. Technical Report CS-TR-1425,
Newcastle University, July 2014.

[HMSW11] Tony Hoare, B. M¨oller, G. Struth, and I. Wehrman. Concurrent Kleene Algebra and its foundations. J. Log. Algebr. Program.,

80(6):266–296, 2011.
C. A. R. Hoare. An axiomatic basis for computer programming. Communications of the ACM, 12(10):576–580, 583, October 1969.
Cliff B. Jones, Ian J. Hayes, and Robert J. Colvin. Balancing expressiveness in formal approaches to concurrency. Formal Aspects
of Computing, 27(3):475–497, May 2015.
C. B. Jones. Development Methods for Computer Programs including a Notion of Interference. PhD thesis, Oxford University, June
1981. Printed as: Programming Research Group, Technical Monograph 25.
C.B. Jones. Tentative steps toward a development method for interfering programs. ACM Transactions on Programming Languages
and Systems, 5(4):596–619, October 1983.
C. B. Jones. Accommodating interference in the formal design of concurrent object-based programs. Formal Methods in System
Design, 8(2):105–122, March 1996.
Dexter Kozen. Kleene algebra with tests. ACM Trans. Prog. Lang. and Sys., 19(3):427–443, May 1997.
J. M. Morris. A theoretical basis for stepwise reﬁnement and the programming calculus. Science of Computer Programming,
9(3):287–306, 1987.
C. C. Morgan. The speciﬁcation statement. ACM Trans. Prog. Lang. and Sys., 10(3):403–419, July 1988.
C. C. Morgan. Programming from Speciﬁcations. Prentice Hall, second edition, 1994.
J. von Wright. Towards a reﬁnement algebra. Sci. of Comp. Prog., 51:23–45, 2004.

Index

Axiom

chaos-parallel-chaos, (47) 5*, 6
chaos-skip, (46) 5*, 6
conjunction-associative, (42) 5*, 6, 9
conjunction-commutes, (43) 5*, 9
conjunction-distribute-inﬁmum, (48) 5*, 6, 9, 10, 12
conjunction-distribute-supremum, (49) 5*, 6, 10
conjunction-exchange-parallel, (50) 5*, 6, 9, 15, 17, 20
conjunction-exchange-sequential, (51) 5*, 6, 9, 10, 20
conjunction-idempotent, (44) 5*, 8, 9, 15, 17
conjunction-identity, (45) 5*, 6, 9
greatest-ﬁxed-point-induction, (19) 4*, 5, 6
greatest-ﬁxed-point-unfold, (18) 4*, 6
inﬁmum-absorb-supremum, (9) 4*
inﬁmum-associative, (3) 4*, 4
inﬁmum-commutes, (4) 4*
inﬁmum-distribute-supremum, (15) 4*, 4
inﬁmum-greatest-lower-bound, (12) 4*
inﬁmum-idempotent, (5) 4*
inﬁmum-lower-bound, (11) 4*, 4
least-ﬁxed-point-induction, (17) 4*, 6
least-ﬁxed-point-unfold, (16) 4*, 5, 6, 17
parallel-associative, (36) 5*, 6, 16
parallel-commutes, (37) 5*, 15, 16
parallel-distribute, (39) 5*, 6, 13, 15, 17
parallel-identity, (38) 5*, 6
sequential-abort-zero-left, (35) 5*, 6
sequential-associative, (30) 5*, 5
sequential-distribute-nondet-left, (33) 5*, 6
sequential-distribute-nondet-right, (34) 5*, 6, 17
sequential-identity-left, (32) 5*, 5
sequential-identity-right, (31) 5*
skip-nil, (41) 5*, 6, 10
skip-skip, (40) 5*, 6
supremum-absorb-inﬁmum, (10) 4*, 4
supremum-associative, (6) 4*
supremum-commutes, (7) 4*
supremum-idempotent, (8) 4*
supremum-least-upper-bound, (14) 4*, 4, 9
supremum-upper-bound, (13) 4*, 9

Deﬁnition

bottom, (20) 4*
concurrent-algebra, 5*, 5, 8
fair-quotient, 19*
iteration, 6*
kleene-iteration-skip, (56) 6*
omega-iteration-skip, (57) 6*
reﬁnement, 4*
rely-quotient, 12*, 13

Law

conjoin-non-aborting, 9*, 9, 12
conjunction-atomic-iterated, 12*, 12
conjunction-distribute, 9*, 12, 19, 20
conjunction-distribute-guarantee, 10*, 12
conjunction-supremum, 9*, 9
conjunction-supremum-nonaborting, 9*
guarantee-distribute, 12*, 20
guarantee-introduce, 12*
guarantee-nested, 12*
guarantee-strengthen, 12*
monotonic, 6*, 8, 9, 12–15
parallel-introduce, 14, 15*, 15, 17, 18, 20

parallel-introduce-with-rely, 17*, 17
parallel-introduce-with-rely-guarantee, 17*, 17
parallel-speciﬁcation, 18*
precondition-conjunction, 11*
precondition-parallel, 11*, 18
reﬁne-conjunction, 8*, 9, 10, 12
reﬁne-to-conjunction, 8*
rely-distribute-choice, 15*
rely-distribute-conjunction, 15*, 17
rely-distribute-iteration, 16*, 17, 20
rely-distribute-parallel, 15*, 16, 19, 20
rely-distribute-sequential, 15, 16*, 16, 20
rely-identity-right, 14*
rely-monotonic, 14*, 15
rely-nested, 14*, 14, 17
rely-quotient, 13*, 13–18
rely-reﬁnement, 13*, 13–17, 20
rely-weaken, 14*, 14, 16

Lemma

fold/unfold, 6*, 9, 10
fusion, 5*, 6, 9, 10
induction, 6*, 9, 10, 12, 17
iteration, 10*
non-deterministic-choice, 4*, 13
operator-monotonic, 5*, 6

Property

atomic-conjoin-atomic, 10, (95) 10*
c-nil, 20, (130) 20*
c-par-i-seq-d-par-i-to-c-seq-d-par-i, 20, (132) 20*
c-to-c-parallel-c, 20, (128) 20*
c-to-c-seq-c, 20, (129) 20*
CKA-rg, 19, (126) 19*
conjunction-abort-zero, (55) 6*, 10
conjunction-distribute-conjunction, 9, (82) 9*, 12
conjunction-distribute-inﬁmum, (54) 6*
conjunction-distribute-kleene, 9, (85) 9*, 12, 19
conjunction-distribute-omega, 9, (86) 9*
conjunction-distribute-omega-omega, (94) 10*
conjunction-distribute-parallel, 9, (83) 9*, 19
conjunction-distribute-sequential, 9, (84) 9*, 19
conjunction-monotonic, 6, (65) 6*, 8, 9, 12, 15
fair-reﬁnes-parallel, (121) 18*, 19
fusion-gfp-eq, (29) 5*
fusion-gfp-geq, (28) 5*
fusion-lfp-eq, (27) 5*
fusion-lfp-leq, (26) 5*, 9, 10
fusion-property, (87) 9*
gen-rg, 19, (127) 19*
guarantee-distribute-conjunction, 12, (108) 12*
guarantee-distribute-kleene, 12, (111) 12*
guarantee-distribute-nondet, 12, (107) 12*
guarantee-distribute-omega, 12, (112) 12*
guarantee-distribute-parallel, 12, (109) 12*
guarantee-distribute-sequential, 12, (110) 12*
i-parallel-i-to-i, 20, (131) 20*
invariant-refsto-nil, 19, (123) 19*
invariant-refsto-parallel, 19, (124) 19*
invariant-refsto-sequential, 19, (125) 19*
kleene-induction, (60) 6*, 7, 9
kleene-monotonic, (66) 6*, 7, 11
kleene-unfold, (58) 6*, 7, 9
nil, 7, (74) 7*
non-skip-conjoin-non-skip, 10, (96) 10*, 12

22

Generalised rely-guarantee concurrency

23

nondet-abort-zero, (22) 4*
nondet-identity, (24) 4*
nondet-monotonic, 6, (62) 6*
omega-induction, (61) 6*, 7, 12
omega-monotonic, (67) 6*, 7, 11
omega-refsto-omega-kleene, (93) 10*, 12
omega-skip, 10, (91) 10*
omega-to-kleene, (90) 10*
omega-unfold, (59) 6*, 7, 10
parallel-atomic-kleene, (102) 11*, 14, 16
parallel-atomic-omega1, (104) 11*, 12
parallel-atomic-omega2, (103) 11*, 17, 19
parallel-atomic-omega3, 19, (122) 19*
parallel-introduce-relational, (120) 18*
parallel-monotonic, 6, (63) 6*, 13, 14
parallel-top-zero, (53) 6*
quintuple, (1) 1*, 2
quintuple-as-reﬁnement, (2) 2*
rely-distribute-iteration-assumption, (119) 16*, 17
rely-distribute-parallel-a, (115) 15*, 16
rely-distribute-parallel-b, (116) 15*, 16
rely-distribute-sequential, 16, (118) 16*
rely-distribute-sequential-assumption, 16, (117) 16*, 19
rely-nested-rel, (114) 14*

semantics-abort, 7, (72) 7*
semantics-atomicrel, (76) 8*, 12
semantics-chaos, (98) 11*, 12
semantics-env, (78) 8*
semantics-env-abort, 7, (70) 7*
semantics-env-step, 7, (69) 7*
semantics-guard, 7, (71) 7*
semantics-magic, 7, (73) 7*
semantics-precondition, (77) 8*, 11
semantics-program-step, 7, (68) 7*
semantics-skip, (75) 8*
semantics-term, (99) 11*
sequential-magic-zero-left, 6, (52) 6*
sequential-monotonic, (64) 6*
sequential-reﬁnes-omega, 10, (92) 10*, 12
skip-conjoin-non-skip, 10, (97) 10*, 12
spec-conjoin-spec, (106) 11*, 18
strengthen-postcondition-atomic, (81) 8*, 11
strengthen-postcondition-atomic-kleene, 11, (100) 11*, 14
strengthen-postcondition-atomic-omega, 11, (101) 11*, 12
supremum-identity, (21) 4*
supremum-magic-zero, (25) 4*
weaken-environment, (80) 8*
weaken-precondition, (79) 8*

