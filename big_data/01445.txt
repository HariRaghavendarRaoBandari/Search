6
1
0
2

 
r
a

M
4

 

 
 
]

O
L
.
s
c
[
 
 

1
v
5
4
4
1
0

.

3
0
6
1
:
v
i
X
r
a

Approximate Relational Hoare Logic for

Continuous Random Samplings

Tetsuya Sato1

Research Institute for Mathematical Sciences, Kyoto University, Kyoto, 606-8502, Japan

Abstract

Approximate relational Hoare logic (apRHL) is a logic for formal veriﬁcation of the diﬀerential privacy of
databases written in the programming language pWHILE. Strictly speaking, however, this logic deals only
with discrete random samplings. In this paper, we deﬁne the graded relational lifting of the subprobabilistic
variant of Giry monad, which described diﬀerential privacy. We extend the logic apRHL with this graded
lifting to deal with continuous random samplings. We give a generic method to give proof rules of apRHL
for continuous random samplings.

Keywords: Diﬀerential privacy, Giry monad, graded monad, relational lifting, semantics,

1

Introduction

Diﬀerential privacy is a deﬁnition of privacy of randomized databases proposed
by Dwork, McSherry, Nissim and Smith [7]. A randomized database satisﬁes ε-
diﬀerential privacy (written ε-diﬀerentially private) if for any two adjacent data,
the diﬀerence of their output probability distributions is bounded by the privacy
strength ε. Diﬀerential privacy guarantees high secrecy against database attacks
regardless of the attackers’ background knowledge, and it has the composition laws,
with which we can calculate the privacy strength of a composite database from the
privacy strengths of its components.

Approximate relational Hoare logic (apRHL) [2,16] is a probabilistic variant of
the relational Hoare logic [4] for formal veriﬁcation of the diﬀerential privacy of
databases written in the programming language pWHILE. In the logic apRHL, a
parametric relational lifting, which relate probability distributions, play a central
role to describe diﬀerential privacy in the framework of veriﬁcation. This para-
metric lifting is an extension of the relational lifting [10, Section 3] that captures
probabilistic bisimilarity of Markov chains [13] (see also [6, lemma 4]). The concept

1 Email:satoutet@kurims.kyoto-u.ac.jp

Sato

of diﬀerential privacy is described in the category of binary relation and mappings
between them, and veriﬁed by the logic apRHL.

Strictly speaking, however, apRHL deals only with random samplings of discrete
distributions, while the algorithms in many actual studies for diﬀerential privacy
are modelled with continuous distributions, such as, the Laplacian distributions
over real line. Therefore apRHL is desired to be extended to deal with random
continuous samplings.

1.1 Contributions

Main contributions of this paper are the following two points:

• We deﬁne the graded relational lifting of sub-Giry monad describing diﬀerential

privacy for continuous random samplings.

• We extend the logic apRHL [2,16] for continuous random samplings (we name

continuous apRHL) .

This graded relational lifting is developed without witness distributions of proba-
bilistic coupling, and hence is constructed in a diﬀerent way from the coupling-based
parametric lifting of relations given in the studies of apRHL [1,2,16].

In the continuous apRHL, we mainly extend the proof rules for relation com-
positions and the frame rule. We also develop a generic method to construct proof
rules for random samplings. By importing the new rules added to apRHL+ in [1],
we give a formal proof of the diﬀerential privacy of the above-threshold algorithm
for real-valued queries [8, Section 3.6].

1.2 Preliminaries

We denote by Meas the category of measurable spaces and measurable functions
between them and denote by Set the category of all sets and functions. The category
Meas is complete and cocomplete, and the forgetful functor U : Meas → Set
preserves products and coproducts. We also denote by ωCPO⊥ of the cateory of
ω-complete partial orders with the least element and continuous functions.

A Category of Relations between Measurable Spaces

We introduce the category BRel(Meas) of binary relations between measurable

spaces as follows:

• An object is a triple (X, Y, Φ) consisting of measurable spaces X and Y and a
relation R between X and Y (i.e. R ⊆ U X × U Y ). We remark that R does not
need to be a measurable subset of the product space X × Y .
• An arrow (f, g) : (X, Y, Φ) → (X′, Y ′, Φ′) is a pair of measurable functions f : X →
X′ and g : Y → Y ′ such that (U f × U g)(Φ) ⊆ Φ′.

When we write an object (X, Y, Φ) in BRel(Meas), we omit writing the underlying
spaces X and Y if they are obvious from the context. We write p for the forgetful
functor p : BRel(Meas) → Meas × Meas which extracting underlying spaces:
(X, Y, Φ) 7→ (X, Y ). We call an endofunctor F on BRel(Meas) a relational lifting
of an endofunctor E on Meas if (E × E)p = pF .

2

Sato

The Sub-Giry Monad

The Giry monad on Meas is introduced in [9] to give a categorical approach to
probability theory; each arrow X → Y in the Kleisli category of the Giry monad
bijectively corresponds to a probabilistic transition from X to Y , and the Chapman-
Kolmogorov equation corresponds to the associativity law of the Giry monad.

We recall the sub-probabilistic variant of the Giry monad, which we call the

sub-Giry monad (see also [17, Section 4]):
• For any measurable space (X, ΣX ), the measurable space (GX, ΣGX ) is deﬁned
as follows: the underlying set GX is the set of subprobability measures over X,
and the σ-algebra ΣGX is the coarsest one that makes the evaluation function
evA : GX → [0, 1] (mapping ν to ν(A)) measurable for each A ∈ ΣX.
• For each f : X → Y in Meas, Gf : GX → GY is deﬁned by (Gf )(ν) = ν(f−1(−)).
• The unit η is deﬁned by ηX (x) = δx, where δx is the Dirac measure centred on x.
• The multiplication µ is deﬁned by µX(Ξ)(A) =RGX evA d(Ξ). The Kleisli lifting
of f : X → GY is given by f ♯(ν)(A) =RX f (−)(A) dν (ν ∈ GX).
The monad G is commutative strong with respect to the cartesian product in Meas.
The strength st−,= : (−) × G(=) ⇒ G(− × =) is given by the product measure
stX,Y (x, ν) = δx⊗ν. The commutativity of G is given from the Fubini theorem. The
double strength dst−,= : G(−)×G(=) ⇒ G(−×=) is given by dstX,Y (ν1, ν2) = ν1⊗ν2.
The Kleisli category MeasG is often called the category SRel of stochastic rela-
tions [17, Section 3]. The category SRel is ωCPO⊥-enriched (with respect to the
cartesian monoidal structure) with the following pointwise order:

f ⊑ g ⇐⇒ ∀x ∈ X, B ∈ ΣY .f (x)(B) ≤ g(x)(B)

(f, g : X → Y in SRel).
The least upper bound supn∈N fn of any ω-chain f0 ⊑ f1 ⊑ ··· ⊑ fn ⊑ ···
is
given by (supn fn)(x)(B) = supn(fn(x)(B)). The least function of each SRel(X, Y )
(written ⊥X,Y ) is the constant function of the null-measure over Y . The continuity
of composition is obtained from the following two facts:
• From the deﬁnition of Lebesgue integral, for any ω-chain {νn} of subprobability
measures over X, RX f d(supn νn) = supnRX f dνn holds.
• From the monotone convergence theorem, we haveRX supn fn dν = supnRX fn dν.
This enrichment is equivalent to the partially additive structure on SRel [17, Section
5]: For any ω-chain {fn}n∈N of fn : X → Y in SRel, we have the summable sequence
{gn}n where g0 = f0 and gn+1 = fn+1 − fn.Conversely, for any summable sequence
{gn}n∈N, the functions fn =Pn

k=0 gn form an ω-chain.

Diﬀerential privacy

Throughout this paper, we deﬁne the approximate diﬀerential privacy as follows:

Deﬁnition 1.1 [[8, Deﬁnition 2.4], Modiﬁed] A measurable function c : Rm →
G(Rn) is (ε, δ)-diﬀerentially private if c(x)(A) ≤ exp(ε)c(y)(A) + δ holds for any
||x − y||1 ≤ 1 and A ∈ ΣRn, where || · ||1 is 1-norm of the Euclidean space Rm.

3

Sato

What we modify from the original deﬁnition [8, Deﬁnition 2.4] is the domain and
codomain of c; we replace the domain from N to R, and replace the codomain from
a discrete probability space to G(Rn). We apply this deﬁnition to the interpretation
of pWHILE programs. The input and output spaces can be other spaces: in section
4 we consider the above-threshold algorithm Above whose output space is Z. The
above modiﬁcation is essential in describing and verifying the diﬀerential privacy of
this algorithm because it takes a sample from Laplace distribution over real line.

2 A Graded Monad for Diﬀerential Privacy

The composition law of diﬀerential privacy plays crucial role to in the compositional
veriﬁcation of the diﬀerential privacy of database programs. Barthe, K¨opf, Olmedo,
and Zanella-B´eguelin constructed a parametric relational lifting describing diﬀeren-
tial privacy, and developed a framework for compositional veriﬁcation of diﬀerential
privacy [2].

Following this relational approach, we construct the parametric relational lifting
of Giry monad to describe diﬀerential privacy for continuous random samplings.
This lifting forms a graded monad on the category BRel(Meas) in the sense of
[11]. The axioms of graded monad correspond to the (sequential) composition law
of diﬀerential privacy.

2.1 Graded Monads

Deﬁnition 2.1 [11, Deﬁnition 2.2-bis] Let C be a category, and (M,·, 1,(cid:22)) be a
preordered monoid. An M -graded (or M -parametric eﬀect) monad on C consists of
• a collection {Te}e∈M of endofunctors on C,
• a natural transformation η : Id ⇒ T1,
• a collection {µe1,e2}e1,e2∈M of natural transformations µe1,e2 : Te1Te2 ⇒ Te1e2,
• a collection {⊑e1,e2}e1(cid:22)e2 of natural transformations ⊑e1,e2 : Te1 ⇒ Te2
satisfying
• µe,1 ◦ Teη = µ1,e ◦ ηTe = IdTe for any e ∈ M ,
• µ(e1e2),e3 ◦ µe1,e2Te3 = µe1,(e2,e3) ◦ Te1µe2,e3 for all e1, e2, e3 ∈ M ,
• ⊑e,e = IdTe for any e and ⊑e2,e3 ◦ ⊑e1,e2 = ⊑e1,e3 whenever e1 (cid:22) e2 (cid:22) e3,
• ⊑(e1e2),(e3e4) ◦µe1,e2 = µe3,e4 ◦ (⊑e1,e3 ∗⊑e2,e4) whenever e1 (cid:22) e3 and e2 (cid:22) e4.

An M -graded monad ({Te}e∈M , η, µe1,e2,⊑e1,e2) on C is called an M -graded
lifting of monad (T, ηT , µT ) on D along U : C → D if U Te = T U , U (η) = ηT U ,
U (µe1,e2) = µT U , and U (⊑e1,e2) = idT .

2.2 A Graded Relational Lifting of Giry Monad for Diﬀerential Privacy

Let M be the cartesian product of the monoids ([1,∞),×, 1) and ([0,∞), +, 0)
equipped with the product order of numerical orders. For each (γ, δ) ∈ M , we

4

deﬁne the following mapping of BRel(Meas)-objects by

Sato

G(γ,δ)Φ =


(ν1, ν2) ∈ GX × GY (cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

∀A ∈ ΣX, B ∈ ΣY .

Φ(A) ⊆ B =⇒ ν1(A) ≤ γν2(B) + δ


.

Proposition 2.2 {G(γ,δ)}(γ,δ)∈M forms an M -graded lifting of the monad (G×G, η×
η, µ × µ) along the forgetful functor p : BRel(Meas) → Meas × Meas.
Proof. Since the functor p is faithful, it suﬃces to show:
(i) Each G(γ,δ) is an endofunctor on BRel(Meas).
(ii) (idGX, idGY ) is an arrow G(γ,δ)Φ → G(γ ′,δ′)Φ in BRel(Meas) for all γ, γ′, δ, δ′

such that γ ≤ γ′ and δ ≤ δ′.

(iii) (ηX , ηY ) is an arrow Φ → G(1,0)Φ in BRel(Meas).
(iv) (µX , µY ) is an arrow G(γ,δ)G(γ ′,δ′)Φ → G(γγ ′,δ+δ)Φ in BRel(Meas) for all

γ, γ′, δ, δ′.

(i) Since the mapping (f, g) 7→ (Gf,Gg) is obviously functorial, it suﬃces to check
that (Gf,Gg) is an arrow G(γ,δ)Ψ → G(γ,δ)Φ in BRel(Meas) for any arrow (f, g) : Ψ →
Φ in BRel(Meas). This is proved from Φ(A) ⊆ B =⇒ Ψ(f−1(A)) ⊆ g−1(B) for
any A ∈ ΣX and B ∈ ΣY . (ii) Obvious. (iii) Obvious. (iv) It suﬃces to show
(µX × µY )(G(γ,δ)G(γ ′,δ′)Φ) ⊆ G(γγ ′,δ+δ)Φ for any Φ ⊆ X × Y .

First, the following equation holds:

∀(f, g) : Φ → ≤ in BRel(Meas).ZX

f dν1 ≤ γZY

G(γ,δ)Φ =(cid:26) (ν1, ν2)(cid:12)(cid:12)(cid:12)(cid:12)

g dν2 + δ(cid:27) ,
where ≤ is the numerical order relation on G1 ≃ [0, 1]. We omit the proof of this
equation. It can be shown in the same way as [12, Theorem 12].
Let (Ξ1, Ξ2) ∈ G(γ,δ)G(γ ′,δ′)Φ. Assume Φ(A) ⊆ B. We give (f, g) : G(γ ′,δ′)Φ →≤
in BRel(Meas) by f = max(evA − δ′, 0) and g = min(γ′ · evB, 1). They actually
satisfy f (ν1) ≤ g(ν2) for each (ν1, ν2) ∈ G(γ ′,δ′)Φ. Hence,
µX(Ξ1)(A) − δ′ ≤ZGX
≤ γZGX

(evA − δ′) dΞ1 ≤ZGX
g dΞ2 + δ ≤ γZGX

γ′evB dΞ2 + δ = γγ′µY (Ξ2)(B) + δ.

f dΞ1

This implies µX (Ξ1)(A) ≤ γγ′µY (Ξ2)(B) + δ + δ′.

✷

The M -graded lifting {G(γ,δ)}(γ,δ)∈M describes only one side of inequalities in
the deﬁnition of diﬀerential privacy. By symmetrising this, we obtain the follow-
ing M -graded lifting {G(γ,δ)}(γ,δ)∈M exactly describing the diﬀerential privacy for
continuous probabilities:

G(γ,δ) = G(γ,δ)(−) ∩ (G(γ,δ)(−)op)

op

.

5

Sato

Theorem 2.3 A measurable function c : Rm → G(Rn) is (ε, δ)-diﬀerentially pri-
vate if and only if (c, c) is an arrow { (x, y) | ||x − y||1 ≤ 1 } → G(exp(ε),δ)EqRn in
BRel(Meas).

In the original works [2,3] of apRHL, the following relational lifting (−)♯(γ,δ)
is introduced to describe diﬀerential privacy. This lifting relates two distributions
if there are intermediate distributions d1 and dR, called witnesses, whose skew
distance, deﬁned by ∆X
γ (dL, dR) = supC⊆X {|dL(C) − γdR(C)| ,|dR(C) − γdL(C)|},
is less than or equal to δ.

Deﬁnition 2.4 ([3, Deﬁnition 4], [16, Deﬁnition 4.3] and [1, Deﬁnition 8]) We
denote by D the subdistribution monad over Set. Let Ψ be a relation between
sets X and Y , and d1 ∈ DX and d2 ∈ DY be two subdistributions. We deﬁne the
relation Ψ♯(γ,δ) ⊆ DX ×DY as follows: (d1, d2) ∈ Ψ♯(γ,δ) if and only if there are two
subdistributions dL, dR ∈ D(X × Y ), called witnesses, such that
Dπ1(dL) = d1, Dπ2(dR) = d2, supp(dL) ⊆ Ψ, supp(dR) ⊆ Ψ, ∆X×Y
(dL, dR) ≤ δ.
Proposition 2.5 For any countable discrete spaces X and Y , and relation Ψ ⊆
X × Y , we have Ψ♯(γ,δ) ⊆ G(γ,δ)Ψ.
Proof. Suppose (d1, d2) ∈ Ψ♯(γ,δ) with witnesses dL and dR. For any A ⊆ X, since
supp(dL) ⊆ Ψ and (A × Y ) ∩ Ψ ⊆ X × Ψ(A), we obtain:

γ

d1(A) = Dπ1(dL)(A) = dL(A × Y ) = dL((A × Y ) ∩ Ψ) ≤ dL(X × Ψ(A))
≤ γdR(X × Ψ(A)) + δ = γDπ2(dR)(Ψ(A)) + δ = γd2(Ψ(A)) + δ.

This implies (d1, d2) ∈ G(γ,δ)Ψ. Since the construction of (−)♯(γ,δ) is symmetric, we
conclude (d1, d2) ∈ G(γ,δ)Ψ.

✷

We remark GX = DX for countable discrete space X. When X is not count-
able, we have the above results by embedding each d ∈ DX in the set DX′ of
subprobability distributions over the countable subspace X′ = X ∩ supp(d).
Corollary 2.6 We have Eq♯(γ,δ)

= G(γ,δ)EqX for each countable discrete space X.
Proof. (⊆) This inclusion is given from Proposition 2.5. (⊇) Suppose (d1, d2) ∈
G(γ,δ)EqX . This is equivalent to ∆X
is proved
by the witnesses given by dL =Px∈X d1(x) · δ(x,x) and dR =Px∈X d2(x) · δ(x,x). ✷

X

γ (d1, d2) ≤ δ. Hence (d1, d2) ∈ Eq♯(γ,δ)

X

3 The Continuous apRHL

We introduce a variant of the approximate probabilistic relational Hoare logic
(apRHL) to deal with continuous random samplings. We name it the continuous
apRHL.

3.1 The Language pWHILE

We recall and reformulate categorically the language pWHILE [2]. In this paper,
we mainly refer to the categorical semantics of a probabilistic language given in [5,

6

Sato

Section 2]. The language pWHILE is constructed in the standard way, hence we
sometimes omit the details of its construction.

3.1.1 Syntax
We introduce the syntax of pWHILE by the following BNF:

τ ::= bool | int | real | . . .
e ::= x | p(e1, . . . , em)
ν ::= d(e1, . . . , em)
i ::= x ← e | x
c ::= skip | null | I;C

$←− ν | if e then c1 else c2 | while e do c

Here, τ is a value type; x is a variable; p is an operation; d is a probabilistic operation;
e is an expression; ν is a probabilistic expression; i is an imperative; c is a command
(or program). We remark constants are 0-ary operations.

We introduce the following syntax sugars for simplicity:

if b then c = if b then c else skip

[while b do c]n =(if b then null else skip,

if b then c; [while b do c]k,

if n = 0

if n = k + 1

3.1.2 Typing Rules
We introduce a typing rule on the language pWHILE. A typing context is a ﬁnite
set Γ = {x1 : τ1, x2 : τ2, . . . , xn : τn} of pairs of a variable and a value type such that
each variable occurs only once in the context.

We give typing rules of pWHILE as follows:

Γ ⊢t e1 : τ1 . . . Γ ⊢t en : τn

p : (τ1, . . . , τn) → τ

Γ ⊢t p(e1, . . . , en) : τ

Γ, x : τ ⊢t e : τ
Γ, x : τ ⊢ x ← e

Γ ⊢ skip

x : τ ∈ Γ Γ ⊢t e1 : τ1 . . . Γ ⊢t en : τn

d : (τ1, . . . , τn) → τ

Here, the type (τ1, . . . , τn) → τ of each operation p and each probabilistic operation
d are assumed to be given in advance.

We easily deﬁne inductively the set of free variables of commands, expressions,

and probabilistic expressions (denoted by F V (c), F V (e), and F V (ν)).

3.1.3 Denotational Semantics
We introduce a denotational semantics of pWHILE in Meas. We give the interpre-
tations [[τ ]] of the value types τ :
• [[bool]] = B = 1 + 1 = {true, false} (discrete space)
• [[int]] = Z (discrete space)

7

Γ ⊢ i Γ ⊢ c

Γ ⊢ i; c

Γ ⊢ x $←− d(e1, . . . , en) : τ
Γ ⊢t b : bool Γ ⊢ c1 Γ ⊢ c2
Γ ⊢ if b then c1 else c2

Γ ⊢ null
Γ ⊢t b : bool Γ ⊢ c
Γ ⊢ while b do c

Sato

• [[real]] = R (Lebesgue measurable space)
We interpret a typing context Γ = {x1 : τ1, x2 : τ2, . . . , xn : τn} as the product space
[[τ1]] × [[τ2]] × ··· × [[τn]]. We interpret each operation p : (τ1, . . . τm) → τ as a mea-
surable function [[p]] : [[τ1]] × ··· × [[τm]] → [[τ ]], and each probabilistic operation
d : (τ1, . . . τm) → τ as [[d]] : [[τ1]] × ··· × [[τm]] → G[[τ ]]. Typed termsΓ ⊢t e : τ and
commands Γ ⊢ c are interpreted to measurable functions of the forms [[Γ]] → [[τ ]]
and [[Γ]] → G[[Γ]] respectively.

The interpretation of expressions are deﬁned inductively by:

[[Γ ⊢t x : τ ]] = πx : τ

[[Γ ⊢t p(e1, . . . , em)]] = [[p]]([[Γ ⊢t e1]], . . . [[Γ ⊢t em]])

The interpretation of commands are deﬁned inductively by:

[[Γ ⊢ skip]] = η[[Γ]]

[[Γ ⊢ null]] = ⊥[[Γ]],[[Γ]]

[[Γ ⊢ i; c]] = ([[Γ ⊢ c]])♯ ◦ [[Γ ⊢ i]]

$←− d(e1, . . . , em)]]

[[Γ ⊢ x
= G(ρ(x : τ,Γ)) ◦ st[[τ ]],[[Γ]] ◦ h[[d]]([[Γ ⊢t e1]], . . . [[Γ ⊢t em]]), id[[Γ]]i

[[Γ, x : τ ⊢ x ← e]] = η[[Γ,x : τ ]] ◦ ρ(x : τ,Γ) ◦ h[[Γ, x : τ ⊢ e]], id[[Γ,x : τ ]]i
[[Γ ⊢ if b then c1 else c2]] = [[[Γ ⊢ c1]], [[Γ ⊢ c2]]]◦ ∼=[[Γ]] ◦h[[Γ ⊢ b]], id[[Γ]]i

[[Γ ⊢ while b do c]] = sup
n∈N

[[Γ ⊢ [while e do c]n]]

Here,
• ρ(xk : τk,Γ) = hflil∈{1,2,...,n} : [[τk]]×[[Γ]] → [[Γ]], where Γ = {x1 : τ1, x2 : τ2, . . . , xn : τn},
fk = π2, and fl = πl ◦ π2 (l 6= k).
• ∼=X : 2 × X → X + X is the inverse of [hι1◦!X , idi,hι2◦!X , idi] : X + X → 2 × X,

which is obtained from the distributivity of the category Meas.

We remark that, from the commutativity of the monad G, if Γ ⊢ x : τ and x /∈ F V (c)
then [[Γ ⊢ c]] ∼= dst[[Γ′]],[[τ ]]([[Γ′ ⊢ c]] × η[[τ ]]) where Γ′ = Γ \ {x : τ}.

3.2 Judgements of apRHL

A judgement of apRHL is

c1 ∼γ,δ c2 : Ψ ⇒ Φ,

where c1 and c1 are commands, and Ψ and Φ are objects in BRel(Meas). We
call the relations Ψ and Φ the precondition and postcondition of the judgement
respectively. Inspired from the validity of asymmetric apRHL [2], we introduce the
validity of the judgement of apRHL.
Deﬁnition 3.1 Let Ψ and Φ be relations over the space [[Γ]]. A judgement c1 ∼γ,δ
c2 : Ψ ⇒ Φ is valid (written |= c1 ∼γ,δ c2 : Ψ ⇒ Φ) when ([[Γ ⊢ c1]], [[Γ ⊢ c2]]) is an
arrow Ψ → G(γ,δ)Φ in BRel(Meas).

We often write preconditions and postconditions in the following manner: Let
Γ = {x1 : τ1, x2 : τ2, . . . , xn : τn}. Assume Γ ⊢ e1 : τ and Γ ⊢ e2 : τ , and let R be a
relation on [[τ ]] (e.g. =, ≤,... ). We deﬁne the relation e1h1iRe2h2i on [[Γ]] by

(e1h1iRe2h2i) = { (m1, m2) ∈ [[Γ]] | [[Γ ⊢ e1]](m1)R[[Γ ⊢ e2]](m2) } .

8

3.3 Proof Rules

Sato

We mainly refer the proof rules of apRHL from [2,16], but we modify the [comp]
and [frame] rules to verify diﬀerential privacy for continuous random samplings.

x1 : τ1, x2 : τ2 ∈ Γ Γ ⊢t e1 : τ1 Γ ⊢t e2 : τ2
(ρ(x1 : τ1,Γ) ◦ h[[e1]], idi, ρ(x2 : τ2,Γ) ◦ h[[e2]], idi) : Ψ → Φ

|= x1 ← e1 ∼(1,0) x2 ← e2 : Ψ ⇒ Φ

[assn]

1 : τ . . . Γ ⊢t e1

Γ ⊢t e1
d : (τ1, . . . , τm) → τ
1, . . . , e1
|= x1

$←− d(e1

1 : τ . . . Γ ⊢t e2

m : τ Γ ⊢t e2
([[d]], [[d]]) : Ψ → G(γ,δ)(Eq[[τ ]]) in BRel(Meas)

m : τ x1 : τ, x2 : τ ∈ Γ

m) ∼(γ,δ) x2

$←− d(e2

1, . . . , e2

m) : Ψ′ ⇒ (x1h1i = x2h1i)

where Ψ′ = { ((g, a), (h, b)) | (a, b) ∈ Ψ, g, h ∈ Γ′ } (Γ = {x1 : τ1, . . . , xk : τk} ∪ Γ′).

[rand]

|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ′
|= c′1 ∼(γ ′,δ′) c′2 : Φ′ ⇒ Φ

|= c1; c′1 ∼(γγ ′,δ+δ′) c2; c′2 : Ψ ⇒ Φ

|= skip ∼(1,0) skip : Φ ⇒ Φ

[seq]

[skip]

Γ ⊢t b : bool Γ ⊢t b : bool Ψ ⇒ bh1i = b′h2i
|= c1 ∼(γ,δ) c′1 : Ψ ∧ bh1i ⇒ Φ |= c2 ∼(γ,δ) c′2 : Ψ ∧ ¬bh1i ⇒ Φ
|= if b then c1 else c2 ∼(γ,δ) if b′ then c′1 else c′2 : Ψ ⇒ Φ

[cond]

k=0 γk

Γ ⊢t e : int γ =Qn−1
Θ ⇒ b1h1i = b2h2i Θ ∧ eh1i ≥ n ⇒ ¬b1h1i
∀k : int. |= c1 ∼(γk,δk) c2 : Θ ∧ eh1i = k ∧ eh1i ≤ n =⇒ Θ ∧ eh1i > k

δ =Pn−1

k=0 δk

|= while b do c1 ∼(γ,δ) while b′ do c2 : Θ ∧ b1h1i ∧ eh1i ≥ 0 ⇒ Θ ∧ ¬b1h1i

[while]

|= c1 ∼(γ,δ) c2 : Ψ ∧ Θ ⇒ Φ |= c1 ∼(γ,δ) c2 : Ψ ∧ ¬Θ ⇒ Φ

[case]

|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ Ψ′ ⇒ Ψ Φ ⇒ Φ′

|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ
[weak]

|= c1 ∼(γ,δ) c2 : Ψ′ ⇒ Φ′

|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ
|= c2 ∼(γ,δ) c1 : Ψop ⇒ Φop

[op]

The relational lifting G(γ,δ) does not preserve every relation composition. However,
it preserve the composition of relations if the relations are measurable, that is, the
images and inverse images along them of mesurable sets are also measurable (see
also [12, Section 3.3]). Generally speaking, it is diﬃcult to check measurability of re-
latons, hence the continuous apRHL is weak for dealing with relation compositions.
However, we have the following two special cases:

• The equality/diagonal relation on any space is a measurable relation.
• Any relation between discrete spaces is automatically a measurable relation.

9

Sato

Hence, the following [comp] rule is an extension of the original [comp] rule in [2]:

Φ and Φ′are measurable relations
|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ |= c2 ∼(γ ′,δ′) c3 : Ψ′ ⇒ Φ′
|= c1 ∼(γγ ′,min(δ+γδ′ ,δ′+γ ′δ)) c3 : Ψ ◦ Ψ′ ⇒ Φ ◦ Φ′

[comp]

To deﬁne the [frame] rule in continuous apRHL, for any relation Θ on [[Γ]], we deﬁne
the following relation Range(Θ):

Range(Θ)

=(cid:8) (ν1, ν2)(cid:12)(cid:12) ∃A, B ∈ Σ[[Γ]].(A × B ⊆ Θ ∧ ν1(A) = ν1([[Γ]]) ∧ ν2(B) = ν2([[Γ]]))(cid:9) .

We deﬁne the [frame] rule with the construction Range(−):

|= c1 ∼(γ,δ) c2 : Ψ ⇒ Φ ([[c1]], [[c2]]) : Θ → Range(Θ)

|= c1 ∼(γ,δ) c2 : Ψ ∧ Θ ⇒ Φ ∧ Θ

[frame]

If [[Γ]] is countable discrete then the condition (ν1, ν2) ∈ Range(Θ) is equivalent to
supp(ν1) × supp(ν2) ⊆ Θ, and hence the above [frame] rule is an extension of the
original [frame] rule in [2].

Note that if the σ-algebra of the space [[τ ]] contains all singleton subsets, and Θ
does not restrict any variables in F V (c1)∪F V (c2) then ([[c1]], [[c2]]) : Θ → Range(Θ).
3.4 Soundness

The soundness of the [assn] and [case] are obtained from the composition of arrows
in BRel(Meas). The rule [skip] and [seq] are sound because G(γ,δ) is the graded re-
lational lifting of G×G along the forgetful functor U : BRel(Meas) → Meas2. The
rules [weak] and [op] are sound because G(γ,δ) is monotone with respect to the inclu-
sion order of relations, and preserves opposites of relations. The soundness of [rand]
is proved from Fubini theorem. The soundness of [cond] is proved by case analyses.
The soundness of [while] is obtained from ωCPO⊥-enrichment structure of SRel.
The soundness of [comp] is given by using the measurability of the postconditions.
Finally, the [frame] rule is proved from the strucure of Range(Θ).

3.5 Mechanisms

In this part, we give a generic method to construct the rules for random samplings,
and by instantiating the method we show the soundness of the proof rules in prior
researches:
[Lap] for Laplacian mechanism [7], [Exp] for Exponential mechanism
[14], [Gauss] for Gaussian mechanism [8, Theorem 3.22, Theorem A.1], and [Cauchy]
for the mechanism by Cauchy distributions [15].

Let f : X × Y → R be a positive measurable function, and ν be a measure over

Y . We deﬁne the following function fa : ΣY → [0, 1] by
fa(B) = RB f (a,−) dν
RY f (a,−) dν

10

.

Sato

We remark that the function f (a,−) : Y → R is measurable. If the function is not
‘almost everywhere zero’ and Lebesgue integrable, that is, 0 < RY f (a,−) dν < ∞
then fa(−) is a probability measure.

The following proposition, which is an extension of [2, Lemma 7], plays the

central role in the construction of sound proof rules for random samplings.

Proposition 3.2 Let f : X × Y → R be a positive measurable function, and ν be a
measure over Y . For all a, a′ ∈ X, γ, γ′ ≥ 1, δ ≥ 0, and Z ∈ ΣY (window set), if the
following three conditions hold then for any B ∈ ΣY , we have fa(B) ≤ γγ′fa′(B)+δ.
(i) 0 < 1
(ii) ∀b ∈ Z.f (a, b) ≤ γf (a′, b),

γ ′ RY f (a′,−) dν ≤RY f (a,−) dν < ∞

(iii) fa(Y \ Z) ≤ δ.

Laplacian mechanism [7].

σ exp(−|b−a|σ

We give the function f : R × R → R by f (a, b) = 2

), where σ > 0
is the variance of Laplacian mechanism. We introduce the probabilistic operation
Lapσ : real → real with [[Lapσ]] = f(−), whose measurability is shown from the
continuity of the mapping a 7→R β
We show (f(−), f(−)) : { (a, a′) | |a − a′| < r } → G(exp( r
σ ),0)EqR by instantiating
Proposition 3.2 as follows: If |a − a′| < r then the following parameters satisfy the
conditions (i)–(iii): γ = exp(r/σ), γ′ = 1, δ = 0, the function f , the Lebesgue mea-
sure ν over R, and the window Z = R. This implies (f(−), f(−)) : { (a, a′) | |a − a′| < r } →
G(exp( r

σ ),0)EqR since { (a, a′) | |a − a′| < r } and EqR are symmetric.

α f (a, x)dx (α, β ∈ R).

From the [rand] rule, the following rule is proved:

Γ ⊢t e1 : real Γ ⊢t e2 : real m1Ψm2 ⇒ |[[e1]]m1 − [[e2]]m2| < r

|= x

$←− Lapσ(e1) ∼(exp( r

σ ),0) y

$←− Lapσ(e2) : Ψ ⇒ xh1i = yh2i

[Lap]

Exponential mechanism [14, Modiﬁed].

Let D be the discrete Euclidian space Zn, and (R, ν) be a (positive) measure
space. Let q : D × R → R be a measurable function such that supb∈R |q(a, b) −
q(a′, b)| ≤ c · ||a − a′||1 for some c > 0. Suppose 0 < RR exp(εq(a,−)) dν < ∞
for any a ∈ D. We give the function f : D × R → R by f (a, b) = exp(εq(a, b)),
where ε > 0 is a constant. We add the value types D and R with [[D]]Γ = D and
[[R]]Γ = R to pWHILE, and introduce the probabilistic operation Exphq,ν,εi : D → R
with [[Exphq,ν,εi]] = f(−).

We show (f(−), f(−)) : { (a, a′) | ||a − a′| |1 < r } → G(exp(2εrc),0)EqR by instanti-
ating Proposition 3.2 as follows: Suppose ||a − a′||1 < r. The following parameters
then satisfy the conditions (i)–(iii): γ = γ′ = exp(εrc), δ = 0, the function f , the
given measure ν, and the window Z = R.

From the [rand] rule, the following rule is proved:

Γ ⊢t e1 : D Γ ⊢t e2 : D m1Ψm2 ⇒ ||[[e1]]m1 − [[e2]]m2||1 < r
$←− Exphq,ν,εi(e1) ∼(exp(2εrc),0) y

$←− Exphq,ν,εi(e2) : Ψ ⇒ xh1i = yh2i

|= x

[Exp]

11

Gaussian mechanism [8, Theorem 3.22, Theorem A.1].

Sato

We give the function f : R×R → R by f (a, b) = 1√2πσ2 exp(− (b−a)2

2σ2 ), where σ > 0
is the variance of Gaussian mechanism. We introduce the probabilistic operation
Gaussσ : real → real with [[Gaussσ]] = f(−), whose continuity is easily proved.

We obtain (f(−), f(−)) : { (a, a′) | |a − a′| < r } → G(γ,δ)EqR by instantiating
If |a − a′| < r, 1 < γ < exp(1), and γ′ = 1 hold,
Proposition 3.2 as follows:
and there is (3/2) < c such that 2 log(1.25/δ) ≤ c2 and (cr/log γ) ≤ σ, then the
parameters γ, γ′, and δ, the function f , and the Lebesgue measure ν over R satisfy
the conditions (i)–(iii) for the window Z =(cid:8) b(cid:12)(cid:12) |b − (a + a′)/2| ≤ (σ2 log γ/r)(cid:9).

From the [rand] rule, we obtain the following rule:

2 . (2 log( 1.25

∃c > 3
Γ ⊢t e1 : real Γ ⊢t e2 : real m1Ψm2 ⇒ |[[e1]]m1 − [[e2]]m2| < r

γ ≤ σ) 1 < γ < exp(1)

δ ) < c2 ∧ cr

|= x

$←− Gaussσ(e1) ∼(γ,δ) y

$←− Gaussσ(e2) : Ψ ⇒ xh1i = yh2i

[Gauss]

We can relax the above conditions for c to ((1 + √3)/2) < c and 2 log(0.66/δ) < c2
by changing the window Z to (cid:8) b(cid:12)(cid:12) b ≤ (a + a′)/2 + (σ2 log γ/r)(cid:9) when a ≤ a′ and
(cid:8) b(cid:12)(cid:12) b ≥ (a + a′)/2 − (σ2 log γ/r)(cid:9) when a′ ≤ a.

Mechanism of Cauchy distributions [15]

We give the function f : R × R → R by f (a, b) =

π((a−b)2+ρ2) . We introduce the
probabilistic operation Cauchyρ : real → real with [[Cauchyρ(e)]]Γm = f(−), whose
continuity is easily proved.

ρ

Let γ = 1 + r2+r√r2+4ρ2

. We obtain (f(−), f(−)) : { (a, a′) | |a − a′| < r } →
G(γ,0)EqR by instantiating Proposition 3.2 as follows: If |a − a′| < r then the pa-
rameters satisfy the conditions (i)–(iii): γ, γ′ = 1, δ = 0, the Lebesgue measure ν
over R, and the window Z = R.

2ρ2

From the [rand] rule, we obtain the following rule:

Γ ⊢t e : real m1Ψm2 ⇒ |[[e1]]m1 − [[e2]]m2| < r

|= x

$←− Cauchyρ(e1) ∼(γ,0) y

$←− Cauchyρ(e1) : Ψ ⇒ (πx × πy)−1(EqR)

[Cauchy]

4 An Example: The Above Threshold Algorithm

Barthe, Gaboardi, Gr´egoire, Hsu, and Strub extended the logic apRHL to the logic
apRHL+ with new proof rules to describe the sparse vector technique (see also [8,
Section 3.6]). They gave a formal proof of the diﬀerential privacy of above threshold
algorithm in the preprint [1] in arXiv.

In this section, we demonstrate that the above threshold algorithm with real-
valued queries is proved with almost the same proof as in [1]. The new proof rules
of apRHL+ are still sound in the framework of the continuous apRHL.

12

Sato

We consider the following algorithm AboveT:

Algorithm 1 The Above Threshold Algorithm ([1], Modiﬁed)

1: AboveT(T : real, Q : queries, d : data)

2:

3:

4:

5:

6:

7:

j ← 1; r ← |Q| + 1; T
while j < |Q| do

$←− Lapε/2(t);

$←− Lapε/4(eval(Q, i, d));
S
if T ≤ S ∧ r = |Q| + 1 then
r ← j;
j ← j + 1

We recall the setting of this algorithm. This algorithm has two ﬁxed parameters:
the threshold t : real and the set Q : queries of queries where |Q| : int is the
number of Q. The input variable is d : int, and the output variable is r : int. We
prepare the new value types queries and data with [[data]] = RN and queries =
int (alias), and the typings j : int, T : real, and S : real. We assume that an
operation eval : (queries, int, data) → real is given for evaluating i-th query in
Q for the input d. We require [[eval]] to be 1-sensitivity for the data d, that is,
||d − d′||1 ≤ 1 ⇒ |[[eval]](Q, i, d) − [[eval]](Q, i, d′)| ≤ 1.

The diﬀerential privacy of Above is characterised as follows:

|= AboveT ∼exp(ε),0 AboveT: ||dh1i − dh2i||1 ≤ 1 ⇒ rh1i = rh2i.

The following rules in apRHL+ are sound in the framework of continuous apRHL:

|= c1 ∼(γ,δ) c2 : Ψ ⇒ xh1i = xh2i

∀i : int. |= c1 ∼(γ,δi) c2 : Ψ ⇒ (xh1i = i ⇒ xh2i = i) Pi : int [[δi]] = δ
Γ ⊢t e1 : real Γ ⊢t e2 : real m1Ψm2 ⇒ |[[e1]]m1 + r′ − [[e2]]m2| < r
|= x $←− Lapσ(e1) ∼(exp( r

σ ),0) y $←− Lapσ(e2) : Ψ ⇒ xh1i + r′ = yh2i

[Forall-Eq]

[LapGen]

[LapNull]

Γ ⊢t e1 : real Γ ⊢t e2 : real
$←− Lapσ(e1) ∼(1,0) y

|= x
Hence we extend the contiuous apRHL by adding these rules, and therefore we
construct a formal proof almost the same proof as in [1] in the extended continous
apRHL.

$←− Lapσ(e2) : Ψ ⇒ xh1i − yh2i = e1h1i − e2h2i

x /∈ F V (e1)

y /∈ F V (e2)

The soundness of the rule [Forall-Eq] is proved from the following lemma:

Lemma 4.1 ([1, Proposition 6], Modiﬁed) If x : τ and the space [[τ ]] is count-
able discrete then

G(γ,δi)(xh1i = i ⇒ xh2i = i) ⊆ G(γ,Pi∈[[τ ]] δi)(xh1i = xh2i).

\i∈[[τ ]]

The soundness of the rule [LapGen] is proved from the rules [Lap] and [assn]

and the semantically equivalence [[x $←− Lapσ(e + r′); x ← x − r′]] = [[x $←− Lapσ(e)]].

The soundness of [LapNull] is proved by using the [LapGen] and [Frame] rules.

13

Sato

Formal Proof

We now demonstrate that the (ε, 0)-diﬀerential privacy of algorithm AboveT is

proved with almost the same proof as in [1].

From the [Forall-Eq] rule with variable r, it suﬃces to prove for all integer i,

|= AboveT ∼exp(ε),0 AboveT: ||dh1i − dh2i||1 ≤ 1 ⇒ (rh1i = i ⇒ rh2i = i).

We denote by c0 the sub-command consisting of the initialization line 2 of AboveT.
From the rules [assn], [LapGen] rule with r = r′ = 1, and σ = 2/ε, [seq], and [frame]
we obtain

|= c0 ∼exp(ε/2),0 c0 : ||dh1i − dh2i||1 ≤ 1 ⇒ ||dh1i − dh2i||1 ≤ 1 ∧ Ψ.

where

Ψ = Th1i + 1 = Th2i ∧ jh1i = jh2i ∧ jh1i = 1 ∧ rh1i = rh2i ∧ rh1i = |Q| + 1.

We denote by c1 and c2 the main loop and the body of the main loop respectively
(i.e. c1 = while (j < |Q|) do c2). We aim to prove the following judgement by
using the [while] rule:

|= c1 ∼exp(ε/2),0 c1 : (||dh1i − dh2i||1 ≤ 1 ∧ Ψ) ⇒ (rh1i = i ⇒ rh2i = i).

To prove this, it suﬃces to show the following cases for the loop body c2:
(i) If k < i then |= c2 ∼1,0 c2 : (Θ ∧ jh1i = k) ⇒ (Θ ∧ jh1i > k)
(ii) If k = i then |= c2 ∼exp(ε/2),0 c2 : (Θ ∧ jh1i = k) ⇒ (Θ ∧ jh1i > k)
(iii) If k > i then |= c2 ∼1,0 c2 : (Θ ∧ jh1i = k) ⇒ (Θ ∧ jh1i > k)
Here, we provide the following loop invariant as follows:

Θ =(jh1i < i ⇒ ((rh1i = |Q| + 1 ⇒ rh2i = |Q| + 1) ∧ (rh1i = |Q| + 1 ∨ rh1i < i)))

∧ (jh1i ≥ i ⇒ (rh1i = i ⇒ rh2i = i))
∧ ||dh1i − dh2i||1 ≤ 1 ∧ Th1i + 1 = Th2i ∧ jh1i = jh2i

The judgement in the case (i) is proved from the rules [seq], [assn], [cond], and
[frame] and the following fact obtained from the [LapNull] rule:

|=S $←− Lapε/4(eval(Q, i, d)) ∼1,0 S $←− Lapε/4(eval(Q, i, d)) :
(||dh1i − dh2i||1 ≤ 1) ∧ (Th1i + 1 = Th2i) ⇒ ((Sh1i < Th1i) ⇒ (Sh2i < Th2i)).
The case (ii) is proved from the rules [seq], [assn], [cond], and [frame] and the
following fact obtained from the [LapGen] rule:

|=S

$←− Lapε/4(eval(Q, i, d)) ∼exp(ε/2),0 S
(||dh1i − dh2i||1 ≤ 1 ∧ Th1i + 1 = Th2i) ⇒ (Sh1i + 1 = Sh2i ∧ Th1i + 1 = Th2i).

$←− Lapε/4(eval(Q, i, d)) :

The case (iii) is proved in the similar way as (i).

14

Acknowledgement

Sato

The author thanks Shin-ya Katsumata for many valuable comments and stimulating
discussions, Marco Gaboardi for helpful suggestions and the introduction of his
preprint [1] in arXiv, Masahito Hasegawa, Naohiko Hoshino, and Takeo Uramoto
for advices that contributed to improve the writing of this paper.

References

[1] Gilles Barthe, Marco Gaboardi, Benjamin Gr´egoire, Jastin Hsu, and Pierre-Yves Strub. Proving

Diﬀerential Privacy via Probabilistic Couplings. ArXiv e-prints, January 2016.

[2] Gilles Barthe, Boris K¨opf, Federico Olmedo, and Santiago Zanella-B´eguelin. Probabilistic relational
In Proceedings of the 39th Annual ACM SIGPLAN-SIGACT
reasoning for diﬀerential privacy.
Symposium on Principles of Programming Languages, POPL ’12, pages 97–110, New York, NY, USA,
2012. ACM.

[3] Gilles Barthe and Federico Olmedo. Beyond diﬀerential privacy: Composition theorems and relational
logic for f-divergences between probabilistic programs.
In FedorV. Fomin, R?si?? Freivalds, Marta
Kwiatkowska, and David Peleg, editors, Automata, Languages, and Programming, volume 7966 of
Lecture Notes in Computer Science, pages 49–60. Springer Berlin Heidelberg, 2013.

[4] Nick Benton. Simple relational correctness proofs for static analyses and program transformations. In
Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(POPL ’04), number MSR-TR-2005-26, page 43. ACM, January 2004.

[5] Daniel Brown and Riccardo Pucella. Categories of timed stochastic relations. Electronic Notes
in Theoretical Computer Science, 249:193 – 217, 2009. Proceedings of the 25th Conference on
Mathematical Foundations of Programming Semantics (MFPS 2009).

[6] E.P de Vink and J.J.M.M Rutten. Bisimulation for probabilistic transition systems: a coalgebraic

approach. Theoretical Computer Science, 221(1 - 2):271 – 293, 1999.

[7] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in
private data analysis. In Shai Halevi and Tal Rabin, editors, Theory of Cryptography, volume 3876 of
Lecture Notes in Computer Science, pages 265–284. Springer Berlin Heidelberg, 2006.

[8] Cynthia Dwork and Aaron Roth. The algorithmic foundations of diﬀerential privacy. Foundations and

Trends R(cid:13) in Theoretical Computer Science, 9(3-4):211–407, 2013.

[9] Mich`ele Giry. A categorical approach to probability theory. In B. Banaschewski, editor, Categorical
Aspects of Topology and Analysis, volume 915 of Lecture Notes in Mathematics, pages 68–85. Springer
Berlin Heidelberg, 1982.

[10] Bart Jacobs and Jesse Hughes. Simulations in coalgebra. Electronic Notes in Theoretical Computer
Science, 82(1):128–149, 2003. CMCS’03, Coalgebraic Methods in Computer Science (Satellite Event
for ETAPS 2003).

[11] Shin-ya Katsumata. Parametric eﬀect monads and semantics of eﬀect systems. In Proceedings of the
41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’14, pages
633–645, New York, NY, USA, 2014. ACM.

[12] Shin-ya Katsumata and Tetsuya Sato. Codensity Liftings of Monads. In Lawrence S. Moss and Pawel
Sobocinski, editors, 6th Conference on Algebra and Coalgebra in Computer Science (CALCO 2015),
volume 35 of Leibniz International Proceedings in Informatics (LIPIcs), pages 156–170, Dagstuhl,
Germany, 2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik.

[13] Kim Guldstrand Larsen and Arne Skou. Bisimulation through probabilistic testing. Information and

Computation, 94(1):1–28, 1991.

[14] Frank McSherry and Kunal Talwar. Mechanism design via diﬀerential privacy.

In Proceedings of
the 48th Annual IEEE Symposium on Foundations of Computer Science, FOCS ’07, pages 94–103,
Washington, DC, USA, 2007. IEEE Computer Society.

[15] Kobbi Nissim, Sofya Raskhodnikova, and Adam Smith. Smooth sensitivity and sampling in private
data analysis. In Proceedings of the Thirty-ninth Annual ACM Symposium on Theory of Computing,
STOC ’07, pages 75–84, New York, NY, USA, 2007. ACM.

[16] Federico Olmedo. Approximate Relational Reasoning for Probabilistic Programs. PhD thesis, Technical

University of Madrid, 2014.

[17] Prakash Panangaden. The category of markov kernels. Electronic Notes in Theoretical Computer
Science, 22:171 – 187, 1999. PROBMIV’98, First International Workshop on Probabilistic Methods in
Veriﬁcation.

15

Sato

This appendix will be deleted from the ﬁnal version of this paper.

A Appendix

We show some omitted proofs in this paper.

A.1 Proofs in Section 1.2

Proposition A.1 The composition of the category SRel = MeasG is continuous
with respect to the ordering ⊑.
Proof. Consider a measurable function h : Y → GZ and an ω-chain {fn : X →
GY }n with respect to ⊑. We ﬁx x ∈ X. Since the ω-chain of measures fn(x) are
bounded, and hence it conveges strongly (supn fn)(x). This implies that, from the
deﬁnition of Lebesgue integral, for any C ∈ ΣZ and x ∈ X, we obtain

(h♯ ◦ sup

n

fn)(x)(C) = (h♯(sup
n

fn)(x))(C)

=ZY

= sup

= sup

fn)(x))

n

h(−)(C) d((sup
n ZY
(h♯ ◦ fn)(x)(C).

n

h(−)(C) d(fn(x))

Consider a measurable function h′ : X → GY and an ω-chain {fn : Y → GZ}n with
respect to ⊑. From the monotone convergence theorem, for any C ∈ ΣZ and x ∈ X,
we have

(sup

n

fn)♯ ◦ h′(x)(C) = (h♯(sup
sup

n

fn)(x))(C)

=ZY

= sup

= sup

n

n

fn(−)(C) d(h′(x))
fn(−)(C) d(h′(x))
n ◦ h′)(x)(C).
(f ♯

n ZY

✷

Lemma A.2 If f1, f2 : X → GY satisfy f1 ⊑ f2 then f1 − f2 deﬁned by

(f1 − f2)(x)(B) = f1(x)(B) − f2(x)(B)

(for all x ∈ X, B ∈ ΣY )

is a measurable function X → GY .
Proof. For each x ∈ X, the ﬁniteness of the measures f1(x) and f2(x) imply the

16

Sato

countable additibity of (f1 − f2)(x) as follows:
Bn) = f1(x)(Xn

(f1 − f2)(x)(Xn

Bn) − f2(x)(Xn

Bn)

f2(x)(Bn)

f1(x)(Bn) −Xn
(f1(x)(Bn) − f2(x)(Bn))
(f1 − f2)(x)(Bn)

=Xn
=Xn
=Xn

where Pn Bn is the union of a countable disjoint collection B0, B1, .... Therefore
f1 − f2 is at least a function of the form X → GY .

The σ-algebra of GY is generated by the following countable collection:

{ ν ∈ GY | ν(A) ≤ α }

(A ∈ ΣY , α ∈ [0, 1] ∩ Q).

Since f1, f2 : X → GY , Aα
ΣY and α ∈ [0, 1] ∩ Q (i = 1, 2). We then calculate

i = fi−1({ ν ∈ GY | ν(A) ≤ α }) is measurable for all A ∈

(f1 − f2)−1({ ν ∈ GY | ν(A) ≤ α })
= { x ∈ X | (f1 − f2)(x)(A) ≤ α }
= { x ∈ X | f1(x)(A) − f2(x)(A) ≤ α }
= { x ∈ X | f1(x)(A) − α ≤ f2(x)(A) }
= \β∈[0,1]∩Q
= \β∈[0,1]∩Q
= \β∈[0,1]∩Q

2 ) ∪ Amin(1,α+β)

1

{ x ∈ X | f2(x)(A) ≤ β =⇒ f1(x)(A) − α ≤ β }

{ x ∈ X | f2(x)(A) ≤ β =⇒ f1(x)(A) ≤ min(1, α + β) }
((X \ Aβ

)

Hencer, the function f1 − f2 is measurable.

A.2 Proofs in Section 2.2

✷

We recall the deﬁnition of the indicator function χA : X → [0, 1] of a subset A ⊆ X:

χA(x) =(1,

0,

if x ∈ A
if x /∈ A

The subset A of X is a measurable if and only if the indicator function χA is a
measurable function : X → [0, 1].
Lemma A.3 The following equation holds for any (Φ, X, Y ) in BRel(Meas):

G(γ,δ)Φ =(cid:26) (ν1, ν2)(cid:12)(cid:12)(cid:12)(cid:12)

∀(f, g) : Φ → ≤ in BRel(Meas).ZX

f dν1 ≤ γZY

g dν2 + δ(cid:27) ,

17

Proof. We recall

Sato

.

in BRel(Meas).

∀A ∈ ΣX, B ∈ ΣY .

(ν1, ν2) ∈ GX × GY (cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

Φ(A) ⊆ B =⇒ ν1(A) ≤ γν2(B) + δ


G(γ,δ)Φ =

(⊇) Suppose the pair (ν1, ν2) satisﬁesRX f dν1 ≤ γRY g dν2 + δ for all (f, g) : Φ → ≤
Assume that A ∈ ΣX and B ∈ ΣY satisfy Φ(A) ⊆ B. The indicator functions
χA : X → [0, 1], χB : Y → [0, 1] are measurable, and satisfy χA(x) ≤ χB(y) for any
(x, y) ∈ Φ because (x, y) ∈ Φ ∧ x ∈ A =⇒ y ∈ Φ(A). These imply that (χA, χB)
is an arrow Φ → ≤ in BRel(Meas). We then obtain RX χA dν1 ≤ γRY χB dν2 + δ,
which is equivalent to ν1(A) ≤ γν2(B) + δ.
(⊆) Suppose (ν1, ν2) ∈ G(γ,δ)Φ. Take an arbitrary arrow (f, g) : Φ → ≤ in
BRel(Meas). We have f−1([β, 1]) ∈ ΣX and g−1([β, 1]) ∈ ΣY . We obtain Φ(f−1([β, 1])) ⊆
g−1([β, 1]) for any β ∈ [0, 1] because (x, y) ∈ Φ ∧ f (x) ≥ β =⇒ g(y) ≥ β. By the
deﬁniton of Lebesgue integration, we calculate as follows:

f dν1

ZX
= sup( n
Xk=0
≤ sup( n
Xk=0
≤ γ sup( n
Xk=0
= γZY

g dν2 + δ.

αkν1(f−1([

αk(γν2(g−1([

αkν2(g−1([

k

k

αl, 1]))(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Xl=0
αl, 1])) + δ)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Xl=0
αl, 1]))(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Xl=0

k

n

Xk=0

n

αk ≤ 1,∀k.(0 ≤ αk))
αk ≤ 1,∀k.(0 ≤ αk))
Xk=0
αk ≤ 1,∀k.(0 ≤ αk)) + δ

n

Xk=0

n ∈ N,{αk}n

k=1 s.t.

n ∈ N,{αk}n

k=1 s.t.

n ∈ N,{αk}n

k=1 s.t.

Here, the ﬁrst and last equality are given by deﬁnition of Lebesgue integration.
The ﬁrst inequallity is obtained from the assumption (ν1, ν2) ∈ G(γ,δ)Φ. The second
inequallity is obtained from the condition Pn

k=0 αk ≤ 1.

✷

A.3 Proofs in Section 3.4

Lemma A.4 The rule [rand] is sound.

Proof. We assume x1 6= x2 since the soundness is obvious when x1 = x2. We then
obtain Γ = Γ, x1 : τ, x2 : τ from the precondition of the rule [rand]. Hence, we may
assume [[Γ]] = [[Γ′]] × [[τ ]] × [[τ ]]. It suﬃces to show
(m1, m2) ∈ Ψ
=⇒ ([[Γ ⊢ x1

m)]](m2)) ∈ G(γ,δ)(Φ),

m)]](m1), [[Γ ⊢ x2

$←− d(e2

$←− d(e1

1, . . . , e1

1, . . . , e2

where

Φ = (x1h1i = x2h2i) = { (m1, m2) | πx1(m1) = πx2(m2) } .

18

Sato

Let (m1, m2) ∈ Ψ and A ∈ Σ[[Γ]]. We have Φ(A) = [[Γ′]] × [[τ ]] × Ax1, where Ax1 =
{ π3(m) | m ∈ A }. We remark that Ax1 is measurable, and therefore so is Φ(A).
m]](mi)) (i = 1, 2).

We denote by νi the measure [[d]]([[Γ ⊢t ei

1]](mi), . . . , [[Γ ⊢t ei

[[Γ ⊢ x1

$←− d(e1

1, . . . , e1

m)]](m1)(A) = G(ρ(x : τ,Γ)) ◦ st[[τ ]],[[Γ]] ◦ hν1, m1i(A)

χρ(x1 : τ,Γ)

= stG[[τ ]],[[Γ]](ν1, m1)(ρ(x1 : τ,Γ)−1(A))
= (ν1 ⊗ δm1)(ρ(x1 : τ,Γ)−1(A))
=Z[[τ ]]×[[Γ]]
=Za∈[[τ ]] Z[[Γ]]
=Z[[τ ]]

χρ(x1 : τ,Γ)

f dν1

−1(A) d(ν1 ⊗ δm1)

−1(A)(a,−) d(δm1 )! dν1

= (ν2 ⊗ δm2)(ρ(x2 : τ,Γ)−1([[Γ′]] × [[τ ]] × Ax1))
= (ν2 ⊗ δm2)(Ax1 )
=Z[[τ ]]

g dν2,

[[Γ ⊢ x2

$←− d(e2

1, . . . , e2

m)]](m2)(Φ(A)) = [[Γ ⊢ x2

$←− d(e2

1, . . . , e2

m)]](m2)([[Γ′]] × [[τ ]] × Ax1)

Where, f = χ(ρ(x1 : τ,Γ)(−,m1))−1(A) and g = χAx1
forms an arrow Eq[[τ ]] →≤ in BRel(Meas). Hence we obtain from Lemma A.3,

. The pair of these arrows (f, g)

[[Γ ⊢ x1

$←− d(e1

1, . . . , e1

m)]](m1)(A) ≤ γ[[Γ ⊢ x2

$←− d(e2

1, . . . , e2

m)]](m1)(A) + δ.

Since A is arbitrary, we conclude

([[Γ ⊢ x1

$←− d(e1

1, . . . , e1

m)]](m1), [[x2

$←− d(e2

1, . . . , e2

m)]](m2)) ∈ G(γ,δ)(Φ)

Lemma A.5 The rule [cond] is sound.

Proof. Let (m1, m2) ∈ Ψ. We have [[Γ ⊢ b]](m1) = [[Γ ⊢ b′]](m2) from the precondi-
tions of the rule [cond]. Since

[[Γ ⊢ if b then c1 else c2]] = [[[Γ ⊢ c1]], [[Γ ⊢ c2]]]◦ ∼=[[Γ]] ◦h[[Γ ⊢ b]], id[[Γ]]i,

✷

we have the following two cases:
(i) When [[Γ ⊢ b]](m1) = ι1(∗), we obtain

[[Γ ⊢ if b then c1 else c2]](m1) = [[Γ ⊢ c1]](m1)
[[Γ ⊢ if b′ then c′1 else c′2]](m2) = [[Γ ⊢ c′1]](m2)

19

Sato

We then obtain
([[Γ ⊢ if b then c1 else c2]](m1), [[Γ ⊢ if b′ then c′1 else c′2]](m2)) ∈ G(γ,δ)Φ.
(A.1)

(ii) When [[Γ ⊢ b]](m1) = ι2(∗), we obtain (A.1) similarly.
Lemma A.6 The rule [while] is sound.

Proof. We ﬁrst prove by induction on n:

✷

|=[while b1 do c1]n ∼(Qn−1

k=0 ,γk Pn−1

k=0 δk) [while b2 do c2]n :

Θ ∧ b1h1i ∧ eh1i ≥ k ⇒ Θ ∧ eh1i ≥ n + k

(A.2)

case: n = 0 We obtain |= null ∼(1,0) null : Θ ∧ b1h1i ∧ eh1i ≥ k ⇒ ∅ since

[[Γ ⊢ null]] is the null measure over [[Γ]]. We recall that the following equality:

[while bi do ci]0 = if bi then null else skip,

We obtain from the above equality, (A.2) by applying [skip], [cond], and [weak].

case: n = m + 1 From the precondition of [while] and the soundness of [case],

|= c1 ∼(γm,δm) c2 : Θ ∧ (eh1i = k) =⇒ (eh1i > k)

By the induction hypothesis,

|=[while b1 do c1]m ∼(Qm−1

k=0 ,γk Pm−1

k=0 δk) [while b2 do c2]m :

Θ ∧ b1h1i ∧ eh1i ≥ k ⇒ Θ ∧ eh1i ≥ m + k

From the soundness of the rule [seq], we obtain

|=c1; [while b1 do c1]m ∼(Qm

k=0,γk Pm

k=0 δk) c2; [while b2 do c2]m :

Θ ∧ b1h1i ∧ eh1i ≥ k ⇒ Θ ∧ eh1i ≥ m + 1 + k

From the soundness of [weak], [cond], and [skip] we conclude (A.2).

It is obvious that Θ ⇒ b1h1i = b2h2i implies

|= while b1 do c1 ∼(1,0) while b2 do c2 : Θ ∧ ¬ ∧ b1h1i ⇒ Θ ∧ ¬b1h1i.
From (A.2) and (A.3), and the soundness of [cond] and [seq], we obtain

(A.3)

|=[while b1 do c1]n; while b1 do c1 ∼(Qm

Θ ∧ b1h1i ∧ eh1i ≥ 0 ⇒ Θ ∧ ¬b1h1i

k=0 γk,Pm

k=0 δk) [while b2 do c2]n; while b2 do c2 :

Since SRel = MeasG is ωCPO⊥-enriched, for any command c and expression of
the type bool, we obtain [[Γ ⊢ [while b do c]n; while b do c]] = [[Γ ⊢ while b do c]].
Hence,

|=while b1 do c1 ∼(Qm

k=0 γk,Pm

k=0 δk) while b2 do c2 :

Θ ∧ b1h1i ∧ eh1i ≥ 0 ⇒ Θ ∧ ¬b1h1i

20

Sato

✷

Lemma A.7 The rule [frame] is sound.

Proof. Let (m1, m2) ∈ Ψ ∧ Θ, ν1 = [[Γ ⊢ c1]](m1), and ν2 = [[Γ ⊢ c2]](m2). Since
(ν1, ν2) ∈ Range(Θ), there exist A′, B′ ∈ Σ[[Γ]] such that A′ × B′ ⊆ Θ, and ν1(C) =
ν1(C ∧ A′) and ν2(D) = ν2(D ∧ B′) for all C, D ∈ Σ[[Γ]]. Suppose that A, B ∈ Σ[[Γ]]
satisfy (Φ ∧ Θ)(A) ⊆ B. Since A′ × B′ ⊆ Θ, we have (Φ ∧ (A′ × B′))(A) ⊆ B. This
implies Φ(A ∧ A′) ∧ B′ ⊆ B. Thus, Φ(A ∧ A′) ⊆ B + ([[Γ]] \ (B ∨ B′)). Therefore

ν1(A) = ν1(A ∧ A′) ≤ γν2(B + (M \ (B ∨ B′)) + δ

= γν2((B + (M \ (B ∨ B′)) ∧ B′) + δ ≤ γν2(B ∧ B′) + δ ≤ γν2(B) + δ.

Hence, (ν1, ν2) ∈ G(Θ ∧ Φ). Similarly, we obtain (ν1, ν2) ∈ (G(Θ ∧ Φ)op)op.
A.4 Proofs in Section 3.5

✷

Proposition A.8 (Proposition 3.2) Let f : X × Y → R be a positive measurable
function, and ν be a measure over Y . For all a, a′ ∈ X, γ, γ′ ≥ 1, δ ≥ 0, and
Z ∈ ΣY (window set), if the following three conditions hold then for any B ∈ ΣY ,
we have fa(B) ≤ γγ′fa′(B) + δ.
(i) 0 < 1
(ii) ∀b ∈ Z.f (a, b) ≤ γf (a′, b)
(iii) fa(Y \ Z) ≤ δ,
Proof. From the conditions of this proposition, we obtain for each B ∈ ΣY ,

γ ′ RY f (a′,−) dν ≤RY f (a,−) dν < ∞

fa(B) = fa(B ∩ Z) + fa(B \ Z)
+ δ

+ δ

≤

γRB∩Z f (a′,−) dν
RY f (a,−) dν
γRB∩Z f (a′,−) dν
≤
γ ′ RY f (a′,−) dν
≤ γγ′fa′(B) + δ.

1

Lemma A.9 (Laplacian Mechanism) If |a − a′| < r then the following param-
eters satisfy the conditions (i)–(iii): γ = exp(r/σ), γ′ = 1, δ = 0, the function
f : R × R → R deﬁned by f (a, b) = 2
), the Lebesgue measure ν over R,
and the window Z = R.

σ exp(−|b−a|σ

✷

Proof. The conditions (i) is satisﬁed, because the function f (a,−) is the density
function of Lapcacian distribution, and hence RR f (a,−)dν =RR f (a′,−)dν = 1.
The condition (iii) is automatically satisﬁed since R \ Z = ∅.
We now check that the condition (ii) is satisﬁed. The triangle inequality |b−a′| ≤
|a − a′| + |b − a| and the assumption |a − a′| < r imply:

f (a, b)
f (a′, b)

= exp(cid:18)|b − a′| − |b − a|

σ

(cid:19) ≤ exp(cid:18)|a − a′|

σ (cid:19) ≤ exp(cid:16) r
σ(cid:17)

21

Sato

This implies f (a, b) ≤ exp(r/σ)f (a′, b).
Lemma A.10 (Exponential Mechanism) Let D be the discrete Euclidian space
Zn, and (R, ν) be a (positive) measure space. Let q : D × R → R be a measurable
function such that supb∈R |q(a, b) − q(a′, b)| ≤ c · ||a − a′||1 for some c > 0. Suppose
0 <RR exp(εq(a,−)) dν < ∞ for any a ∈ D.
Suppose ||a − a′||1 < r. The following parameters then satisfy the conditions
(i)–(iii): γ = γ′ = exp(εrc), δ = 0, the function f : D × R → R deﬁned by f (a, b) =
exp(εq(a, b)) with ﬁxed ε > 0, the given measure ν, and the window Z = R.

✷

Proof. The condition (iii) is obviouslly satisﬁed.

The condtions (i) and (ii) is obtained from the following calculation: whenever

||a − a′||1 < r, we obtain

f (a, b)
f (a′, b)

= exp(cid:0)εq(a, b) − εq(a′, b)(cid:1) ≤ exp(cid:0)ε|q(a, b) − q(a′, b)|(cid:1)
≤ exp(cid:0)εc||a − a′||1(cid:1) ≤ exp (εcr)

✷

Lemma A.11 (Gaussian Mechanism: Relaxed Result of [8, Theorem A.1])
If |a − a′| < r, 1 < γ < exp(1), and γ′ = 1 hold, and c = σ log γ
satisﬁes
((1 + √3)/2) < c and 2 log(0.66/δ) < c2, then the parameters γ, γ′, and δ, the
function f : R × R → R deﬁned by f (a, b) = 1√2πσ2 exp(− (b−a)2
2σ2 ), and the Lebesgue
measure ν over R satisfy the conditions (i)–(iii) of Proposition 3.2 for the window
set Z given by

r

Z =((cid:8) b(cid:12)(cid:12) b ≤ (a + a′)/2 + (σ2 log γ/r)(cid:9) ,
(cid:8) b(cid:12)(cid:12) b ≥ (a + a′)/2 − (σ2 log γ/r)(cid:9) ,

if a ≤ a′
if a′ ≤ a.

Proof. We assume a′ ≤ a because in the case a′ > a, we can prove in the similar
way as a′ ≤ a.
The conditions (i) is satisﬁed, because for each a ∈ R the function f (a,−) is the
density function of Gaussian distribution, and henceRR f (a,−)dν =RR f (a′,−)dν =
3.2. Suppose Z = (cid:8) b(cid:12)(cid:12) b ≤ (a + a′)/2 + (σ2 log γ/r)(cid:9). Take an arbitrary b ∈ Z.

We prove that the given parameters satisafy the condition (ii) of Proposition

We then calculate as follows:

1.

f (a, b)
f (a′, b)

(cid:19)

2σ2

= exp(cid:18) (b − a′)2 − (b − a)2
= exp(cid:18) 1
≤ exp(cid:18) r
≤ exp(cid:18) r

σ2 (a − a′)(b −
a + a′
)(cid:19)
σ2 (b −
(cid:19) ≤ γ

2
σ2 log γ

σ2

r

a + a′

2

)(cid:19)

22

Sato

This implies ∀b ∈ Z.f (a, b) ≤ γf (a′, b).

We prove that given parameters satisfy the condition (iii). Let H = a+a′

2 +

σ2 log γ

r

2σ + σ log γ

, and let H′ = a′−a
Since c > ((1 + √3)/2), we have c − 1
2c − 1 > 0 Since −r < a′ − a, we obtain H′ > 1, and hence log(H′) > 0.
Since c2 > 2 log(0.66/δ), we have c2 > 2 log( 1

2c − 1 > 0. From log γ < 1, we obtain

.

r

c − log γ

2c , we then obtain H′2 > c2−1 > 2 log(

2π ). This implies c2 − 1 >
).
δ√2π

δq exp(1)

1

1

δ√2π

2 log(
Therefore, we conclude log(H′) + H′2/2 > log(

). Since H′ > c− log γ

2c > c− 1

1

δ√2π

).

We then obtain:

1

H

1

=

=

ZR\Z
σ√2π
σ√2π Z ∞
1
√2π Z ∞
√2π Z ∞
√2πH′

≤

≤

H ′

H ′

1

1

exp(cid:18)−
exp(cid:18)−
exp(cid:18)−

(x − a)2
2σ2 (cid:19) dν
(x − a)2
2σ2 (cid:19) dx
b2
2(cid:19) db

b
H′

b2

exp(cid:18)−
2(cid:19) db
2 (cid:19) ≤ δ.

H′2

exp(cid:18)−

This implies fa(R \ Z) ≤ δ.

A.5 Proofs in Section 4

✷

Lemma A.12 (Lemma 4.1) If x : τ and the space [[τ ]] is countable discrete then

G(γ,δi)(xh1i = i ⇒ xh2i = i) ⊆ G(γ,Pi∈[[τ ]] δi)(xh1i = xh2i).

\i∈[[τ ]]

Proof. Let [[Γ, x : τ ]] = [[τ ]] × [[Γ]]. Suppose (ν1, ν2) ∈ Ti∈[[τ ]] G(γ,δi)(xh1i = i ⇒
xh2i = i). Take an arbitrary A ∈ Σ[[Γ,x : τ ]]. Since [[τ ]] is countable discrete, we
decompose A = Pi∈[[τ ]]({i} × Ai). We may assume Ai 6= ∅ because {i} × ∅ = ∅.
Since (xh1i = i ⇒ xh2i = i)({i} × Ai) = {i} × [[Γ]], we obtain ν1({i} × Ai) ≤
γν2({i} × [[Γ]]) + δi for each i ∈ [[τ ]]. By summing them up, we obtain ν1(A) ≤
γν2((xh1i = xh2i)(A)) +Pi∈[[τ ]] δi.

✷

23

