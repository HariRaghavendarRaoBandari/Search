6
1
0
2

 
r
a

M
2

 

 
 
]
S
D
.
s
c
[
 
 

1
v
8
5
8
0
0

.

3
0
6
1
:
v
i
X
r
a

Pareto optimal matchings of students to courses

in the presence of prerequisites∗

Katar´ına Cechl´arov´a1, Bettina Klaus2 and David F. Manlove3

1Institute of Mathematics, Faculty of Science, P.J. ˇSaf´arik University,

Jesenn´a 5, 040 01 Koˇsice, Slovakia. Email katarina.cechlarova@upjs.sk.

2Faculty of Business and Economics, University of Lausanne, Internef 538,

CH-1015 Lausanne, Switzerland. Email Bettina.Klaus@unil.ch.

3School of Computing Science, Sir Alwyn Williams Building, University of Glasgow,

Glasgow, G12 8QQ, UK. Email david.manlove@glasgow.ac.uk.

Abstract

We consider the problem of allocating applicants to courses, where each applicant
has a subset of acceptable courses that she ranks in strict order of preference. Each
applicant and course has a capacity, indicating the maximum number of courses and
applicants they can be assigned to, respectively. We thus essentially have a many-to-
many bipartite matching problem with one-sided preferences, which has applications
to the assignment of students to optional courses at a university.

We consider additive preferences and lexicographic preferences as two means of
extending preferences over individual courses to preferences over bundles of courses.
We additionally focus on the case that courses have prerequisite constraints: we will
mainly treat these constraints as compulsory, but we also allow alternative prerequi-
sites. We further study the case where courses may be corequisites.

For these extensions to the basic problem, we present the following algorithmic
results, which are mainly concerned with the computation of Pareto optimal matchings
(POMs). Firstly, we consider compulsory prerequisites. For additive preferences, we
show that the problem of ﬁnding a POM is NP-hard. On the other hand, in the
case of lexicographic preferences we give a polynomial-time algorithm for ﬁnding a
POM, based on the well-known sequential mechanism. However we show that the
problem of deciding whether a given matching is Pareto optimal is co-NP-complete.
We further prove that ﬁnding a maximum cardinality (Pareto optimal) matching is
NP-hard. Under alternative prerequisites, we show that ﬁnding a POM is NP-hard
for either additive or lexicographic preferences. Finally we consider corequisites. We
prove that, as in the case of compulsory prerequisites, ﬁnding a POM is NP-hard for
additive preferences, though solvable in polynomial time for lexicographic preferences.
In the latter case, the problem of ﬁnding a maximum cardinality POM is NP-hard
and very diﬃcult to approximate.

∗Supported by VEGA grants 1/0344/14 and 1/0142/15 from the Slovak Scientiﬁc Grant Agency
(Cechl´arov´a), by the Swiss National Science Foundation SNFS (Klaus), by grant EP/K010042/1 from
the Engineering and Physical Sciences Research Council (Manlove), and by a Short-Term Scientiﬁc Mis-
sion from COST Action IC1205 on Computational Social Choice (Manlove). Part of this work was carried
out whilst the authors visited Corvinus University of Budapest, and whilst the third author visited P.J.
ˇSaf´arik University. This research was initiated during Dagstuhl Seminar 15241 on Computational Social
Choice: Theory and Applications [7]. We would like to thank the following Dagstuhl participants who
were involved in initial discussions regarding the results in this paper: Haris Aziz, P´eter Bir´o, Jiehua Chen
and Nicholas Mattei.

1

1

Introduction

Problems involving the allocation of indivisible goods to agents have gained a lot of atten-
tion in literature, since they model many real scenarios, including the allocation of pupils
to study places [4], workers to positions [22], researchers to projects [29], tenants to houses
[1] and students to courses [10], etc. We assume that agents on one side of the market
(pupils, workers, researchers, tenants, students) have preferences over objects on the other
side of the market (study places, positions, projects, courses, etc.) but not vice versa. In
such a setting where the desires of agents are in general conﬂicting, economists regard
Pareto optimality (or Pareto eﬃciency) as a basic, fundamental criterion to be satisﬁed
by an allocation. This concept guarantees that no agent can be made better oﬀ with-
out another agent becoming worse oﬀ. A popular and very intuitive approach to ﬁnding
Pareto optimal matchings is represented by the class of sequential allocation mechanisms
[24, 9, 8, 3].

In the one-to-one case (each agent receives at most one object, and each object can be
assigned to at most one agent) this mechanism has been given several diﬀerent names in
the literature, including serial dictatorship [1, 28], queue allocation [34], Greedy-POM [2],
sequential mechanism [8, 3] etc. Several authors independently proved that a matching
is Pareto optimal if and only if can be obtained by the serial dictatorship mechanism
(Svensson in 1994 [34], Abdulkadiroˇglu and S¨onmez in 1998 [1], Abraham et al. in 2004
[2], and Brams and King in 2005 [9]).

In general many-to-many matching problems (agents can receive more than one object,
and objects can be assigned to more than one agent), the sequential allocation mechanism
works as follows: a central authority decides on an ordering of agents (often called a policy)
that can contain multiple copies of an agent (up to her capacity). According to the chosen
policy, an agent who has her turn chooses her most preferred object among those that still
have a free slot. This approach was used in [3, 8], where the properties of the obtained
allocation with respect to the chosen policy and strategic issues are studied.

The serial dictatorship mechanism is a special case of the sequential allocation mech-
anism where the policy contains each agent exactly once, and when agent a is dealt with,
she chooses her entire most-preferred bundle of objects. The diﬃculty with serial dicta-
torship is that it can output a matching that is highly unfair. For example, it is easy to
see that if there are two agents a1 and a2, each with the same preference list over objects,
and each with the same capacity, which is equal to the length of their preference list, and
each object has capacity 1, the mechanism will give all acceptable objects to ai and no
objects to a3−i when the policy indicates that ai should choose ﬁrst (i ∈ {1, 2}).

In this paper we shall concentrate on one real-life application of this allocation problem
that arises in education, and so our terminology will involve applicants (students) for the
agents and courses for the objects. In most universities students have some freedom in
their choice of courses, but at the same time they are bound by the rules of the particular
university. A detailed description of the rules of the allocation process and the analysis of
the behaviour of students at Harvard Business School, based on real data, is provided by
Budish and Cantillon [10]. They assume that students have a linear ordering of individual
courses and their preferences over bundles of courses are responsive to these orderings.
The emphasis in [10] was on strategic questions. The empirical results conﬁrmed the
theoretical ﬁndings that, loosely speaking, dictatorships (where students choose one at
a time their entire most preferred available bundle) are the only mechanisms that are
strategy-proof and ex-post Pareto eﬃcient.

Another ﬁeld experiment in course allocation is described by Diebold et al. [14]. The
authors compared the properties of allocations obtained by the sequential allocation mech-
anism where the policy is determined by the arrival time of students (i.e., ﬁrst-come ﬁrst-

2

served) and by two modiﬁcations of the Gale-Shapley student-optimal mechanism, i.e.,
they assumed that courses may also have preferences or priorities over students. More-
over, they only considered the case when each student can be assigned to at most one
course.

In reality, a student can attend more courses, but not all possible bundles are feasible
for her. Cechl´arov´a et al. [12] considered explicitly-deﬁned notions of feasibility for bundles
of courses. For these feasibility concepts, a given bundle can be checked for feasibility for a
given applicant in time polynomial in the number of courses. Such an algorithm may check
for example if no two courses in the bundle are scheduled at the same time, or if the student
has enough budget to pay the fees for all the courses in the bundle, etc. Cechl´arov´a et al.
[12] found out that a suﬃcient condition for a general sequential allocation mechanism to
output a Pareto optimal matching is that feasible bundles of courses form families that are
closed with respect to subsets, and preferences of students over bundles are lexicographic.
They also showed that under these assumptions a converse result holds, i.e., each Pareto
optimal matching can be obtained by sequential allocation mechanism if a suitable policy
is chosen.

Prerequisites and corequisites

In this paper we deal with prerequisite and corequisite constraints. Prerequisite constraints
model the situation where a student may be allowed to subscribe to a course c only if she
subscribes to a set C ′ of other course(s). The courses in C ′ are usually called prerequisite
courses, or prerequisites, for c. For example, at a School of Mathematics, an Optimal
Control Theory course may have as its prerequisites a course on Diﬀerential Equations
as well as a course in Linear Algebra; a prerequisite for a Diﬀerential Equations course
could be a Calculus course, etc. On the other hand corequisite constraints model the
situation where a student takes course c1 if and only if she takes course c2. These courses
are referred to as corequisite courses, or corequisites. For example, a corequisite constraint
may act on two courses: one that is a theoretical programming course and the other that
is a series of corresponding programming lab sessions.

We consider three diﬀerent models involving prerequisite and corequisite constraints.
The ﬁrst model involves compulsory prerequisites, but we allow the possibility that diﬀer-
ent students may have diﬀerent prerequisite constraints. For example, for a doctoral study
program in Economics, an economics graduate may have as a prerequisite a mathemat-
ical course and, on the other hand, a mathematics graduate may have as a prerequisite
a course on microeconomics, etc. The second model concerns alternative prerequisites.
Here it is assumed that certain courses require that a student subscribes to at least one
of a set of other courses. For example, a course in mathematical modelling may require
that a student attends one of a range of courses that deal with a speciﬁc mathematical
modelling software package, such as Maple, MATLAB or Mathematica. Finally, the third
model considers corequisites. Here we assume that constraints on corequisite courses are
identical for all applicants.

As we assume that applicants express their preferences only over individual courses,
a suitable extension of these preferences to preferences over bundles of courses has to be
chosen. Among the most popular extensions are responsive preferences [31]. That is, an
applicant has responsive preferences over bundles of courses if bundle C ′ is preferred to
bundle C ′′ whenever C ′ is obtained from C ′′ by replacing some course in C ′′ by a more
preferred course not contained in C ′′. Responsiveness is a very mild requirement and
responsive preferences form a very wide and variable class. Therefore we shall restrict
our attention to two speciﬁc examples, namely additive [5, 8, 10] and lexicographic [16, 5,
33, 32, 35] preferences. Although lexicographic preferences can be modelled as additive

3

preferences by choosing appropriate weights [8], we would like to avoid this approach as it
requires very large numbers, moreover, assuming lexicographic preferences from the outset
leads to more straightforward algorithms.

To the best of our knowledge, matchings with prerequisite constraints have not been
studied yet from an algorithmic perspective. Some connections can be found in the litera-
ture on scheduling with precedence constraints [26], but, unlike in the scheduling domain,
there is no common optimality criterion for all the agents, since their desires are often
conﬂicting and all have to be taken into account.

We would however like to draw the reader’s attention to the works of Guerin et al. [19]
and Dodson et al. [15], who analyze a version of a course selection problem in greater depth,
using also probabilistic methods. Their work is a part of a larger research programme
that involves advising college students about what courses to study and when, taking into
account not only the required course prerequisites, but also the students’ course histories
and obtained grades. Based on this information, the authors try to estimate a student’s
ability to take multiple courses concurrently, with the goal to optimise the student’s total
expected utility and her chances of moving successfully toward graduation. Guerin et al.
and Dodson et al. consider also temporal factors, meaning that a student can only take
a certain course in the current semester if she has completed the necessary prerequisites
during previous semesters. By contrast, here we assume that students choose all their
courses as well as their necessary prerequisites simultaneously, and we concentrate on
computational problems connected with producing a matching that fulﬁls a global welfare
criterion.

Our contribution

As mentioned above, we will formally introduce three possible models of course allocation
involving prerequisites or corequisites. In the ﬁrst case the prerequisites are antisymmetric
and compulsory (i.e., a constraint might ensure that an applicant can subscribe to course
c1 only if she also subscribes to course c2, but she can attend c2 without attending c1). For
additive preferences we show that computing a Pareto optimal matching is an NP-hard
problem. In the case of lexicographic preferences we illustrate that the simple sequential
allocation mechanism and its natural modiﬁcation may output a matching that either
violates prerequisites or Pareto optimality. Therefore we stipulate that on her turn, an
applicant chooses her most preferred course together with all the necessary prerequisites.
Still, it is impossible to obtain each possible Pareto optimal matching in this way. It is also
unlikely that an eﬃcient algorithm will be able to produce all Pareto optimal matchings,
since the problem of checking whether a given matching admits a Pareto improvement is
NP-complete. Considering structural properties of Pareto optimal matchings, it is known
that ﬁnding a Pareto optimal matching with minimum cardinality is NP-hard, even in the
very restricted one-to-one model (naturally without prerequisites) [2], but here we show
that the problem of ﬁnding such a matching with maximum cardinality is also NP-hard.
The second model involving alternative prerequisites (i.e., where a constraint takes the
form that an applicant can attend course c1 only if she also attends either course c2 or
course c3) seems to be computationally the most challenging case. We show that although
a Pareto optimal matching always exists, it cannot be computed eﬃciently unless P=NP,
both under additive as well as lexicographic preferences of applicants.

For the third case with corequisites (i.e., an applicant can attend a course if and
only if she attends all its corequisites) we propose another modiﬁcation of the sequential
allocation mechanism for ﬁnding Pareto optimal matchings. If the corequisites for all the
applicants are the same, the model is closely related to matchings with sizes [6] or many-to-
many matchings with price-budget constraints [12], and we strengthen the existing results

4

by showing that the problem of ﬁnding a maximum size Pareto optimal matching is not
approximable within N 1−ε, for any ε > 0, unless P=NP, where N is the total capacity of
the applicants.

The organisation of the paper is as follows. In Section 2 we give formal deﬁnitions of
the problem models and deﬁne relevant notation and terminology. Sections 3, 4 and 5 deal
separately with the three diﬀerent models, involving compulsory prerequisites, alternative
prerequisites and corequisites respectively. Finally, Section 6 concludes with some open
problems and possible directions for future research.

2 Deﬁnitions and notation

2.1 Basic Course Allocation problem

An instance of the Course Allocation problem (ca) involves a set A = {a1, a2, . . . , an1} of
applicants and a set C = {c1, c2, . . . , cn2} of courses. Each course cj ∈ C has a capacity
q(cj) that denotes the maximum number of applicants that can be assigned to cj. Similarly
each applicant ai ∈ A has a capacity q(ai) denoting the maximum number of courses that
she can attend. The vector q denotes applicants’ and courses’ capacities. Moreover ai
has a strict linear order (preference list) P (ai) over a subset of C. We shall represent ai’s
preferences P (ai) as a simple ordered list of courses, from the most preferred to the least
preferred one. With some abuse of notation, we shall say that a course cj is acceptable to
applicant ai if cj ∈ P (ai), otherwise cj is unacceptable to ai. P denotes the n1-tuple of
applicants’ preferences.Thus altogether, the tuple I = (A, C, q, P) constitutes an instance
of ca.

An assignment M is a subset of A × C. The set of applicants assigned to a course
cj ∈ C will be denoted by M (cj ) = {ai ∈ A : (ai, cj ) ∈ M } and similarly, the bundle of
courses assigned to an applicant ai is M (ai) = {cj ∈ C : (ai, cj) ∈ M }. An assignment M
is a matching if, for each ai ∈ A, M (ai) ⊆ P (ai) and |M (ai)| ≤ q(ai), and for each cj ∈ C,
|M (cj )| ≤ q(cj). In the presence of prerequisites and corequisites, additional feasibility
constraints are to be satisﬁed by a matching, which will be deﬁned below.

An applicant ai ∈ A has additive preferences over bundles of courses if she has a utility
uai(cj) for each course cj ∈ C, and she prefers a bundle of courses C1 ⊆ C to another
bundle C2 ⊆ C if and only if Pcj ∈C1

uai(cj) > Pcj ∈C2

uai(cj).

Applicant ai compares bundles of courses lexicographically if, given two diﬀerent bun-
dles C1 ⊆ C and C2 ⊆ C she prefers C1 to C2 if and only if her most preferred course in
the symmetric diﬀerence C1 ⊕ C2 belongs to C1. Notice that the lexicographic ordering
on bundles of courses generated by a strict preference order P (ai) is also strict.

Applicant ai prefers matching M ′ to matching M if she prefers M ′(ai) to M (ai). We
say that a matching M ′ (Pareto) dominates a matching M if at least one applicant prefers
M ′ to M and no applicant prefers M to M ′.

A Pareto optimal matching (or POM for short), is a matching that is not (Pareto)
dominated by any other matching. As the dominance relation is a partial order over M,
the set of all matchings in I, and M is ﬁnite, a POM exists for each instance of ca.

2.2 Compulsory prerequisites

We now deﬁne the ﬁrst extension of ca involving compulsory prerequisites. Suppose that
for each applicant ai ∈ A, there is a partial order →ai on the set of courses C (i.e., →ai is
a reﬂexive, antisymmetric and transitive binary relation) representing the prerequisites of
applicant ai. It is easy to see that this partial order can be fully speciﬁed if for each cj ∈ C

5

its immediate prerequisites for ai are given.We now deﬁne the feasibility of a bundle of
courses relative to the constraints on compulsory prerequisites.

Deﬁnition 1. A bundle of courses C ′ ⊆ C is feasible for an applicant ai ∈ A if the
following three conditions are fulﬁlled:

(i) C ′ ⊆ P (ai) ;
(ii) |C ′| ≤ q(ai) ;
(iii) C ′ fulﬁls ai’s prerequisites, i.e., for each cj, ck ∈ C, if cj ∈ C ′ and cj →ai ck then

ck ∈ C ′.

A subset C ′ of a partially-ordered set C fulﬁlling condition (iii) is called a down-set
the inclusion minimal down-set of C (with respect to

→aicj

(see [13]). We shall denote by
ai’s prerequisites) that contains course cj.
For technical reasons, we assume that

→aicj ⊆ P (ai) for each ai ∈ A and each cj ∈ P (ai).
If this is not the case then we can easily modify the preference list of applicant ai either
→aicj , or we can append
by deleting a course cj if P (ai) does not contain all the courses in
the missing courses to the end of P (ai).

An instance I of the Course Allocation problem with (compulsory) PRequisites (capr)
comprises a tuple I = (A, C, q, P, →), where (A, C, q, P) is an instance of ca and → is
the n1-tuple of prerequisite partial orders →ai for each applicant ai ∈ A. In an instance of
capr, a matching M is as deﬁned in the ca case, together with the additional property
that, for each applicant ai ∈ A, M (ai) is feasible for ai.

In an instance of capr where the prerequisites are the same for all applicants, we may

drop the applicant subscript when referring to the prerequisite partial order →.

2.3 Alternative prerequisites

The second model is a variant of capr in which prerequisites need not be compulsory
but are in general presented in the form of alternatives. Formally, each applicant ai has
a mapping 7→ai: C → 2C with the following meaning: if cj 7→ai {ci1, ci2 , . . . , cik }, it must
then hold that if ai wants to attend course cj then she has to attend at least one of the
courses ci1, ci2 , . . . , cik too. We thus deﬁne a bundle of courses C ′ ⊆ C to be feasible for a
given applicant ai ∈ A if Conditions (i) and (ii) in Deﬁnition 1 are satisﬁed, and moreover,
for any course cj ∈ C ′, if cj 7→ai {ci1 , ci2, . . . , cik }, then cir ∈ C ′ for some r (1 ≤ r ≤ k).

An instance I of the Course Allocation problem with Alternative PRequisites (caapr)
comprises a tuple I = (A, C, q, P, 7→), where (A, C, q, P) is an instance of ca and 7→ is
the n1-tuple of mappings 7→ai for each applicant ai ∈ A.
In an instance of caapr, a
matching M is as deﬁned in the ca case, together with the additional property that, for
each applicant ai ∈ A, M (ai) is feasible for ai.

2.4 Corequisites

In the third and ﬁnal model we assume that constraints on courses are given in the form
of corequisites. We assume that corequisite constraints are not applicant-speciﬁc, and
hence there is a single reﬂexive, symmetric and transitive relation ↔ on C such that each
applicant is allowed to subscribe to a course cj ∈ C only if she also subscribes to each
ck ∈ C such that cj ↔ ck. Two courses cj, ck ∈ C with cj ↔ ck are said to be each other’s
corequisites. Relation ↔ is an equivalence relation on C and it eﬀectively partitions the
set of courses into equivalence classes C 1, C 2, . . . , C r. Hence an applicant can subscribe
either to all courses in one equivalence class or to none.

6

Formally, we deﬁne a bundle of courses C ′ ⊆ C to be feasible for a given applicant
ai ∈ A if Conditions (i) and (ii) in Deﬁnition 1 are satisﬁed, and moreover, for any two
courses cj, ck ∈ C, if cj ↔ ck then cj ∈ C ′ if and only if ck ∈ C ′. An instance I of the
Course Allocation problem with Corequisites (cacr) comprises a tuple I = (A, C, q, P, ↔),
where (A, C, q, P) is an instance of ca and ↔ is as deﬁned above. In an instance of cacr,
a matching M is as deﬁned in the ca case, together with the additional property that, for
each applicant ai ∈ A, M (ai) is feasible for ai.

3 Compulsory prerequisites

In the presence of compulsory prerequisites, we consider the case of additive preferences in
Section 3.1 and lexicographic preferences in Section 3.2. It turns out that the problem of
ﬁnding a POM under additive preferences is NP-hard, as we show in Section 3.1. Thus the
majority of our attention is focused on the case of lexicographic preferences in Section 3.2.
In that section we mainly consider algorithmic questions associated with the problems of
(i) ﬁnding a POM, (ii) testing a matching for Pareto optimality, and (iii) ﬁnding a POM
of maximum size.

3.1 Additive preferences

First we show that the assumption of additive preferences in capr makes it diﬃcult to
compute a POM.

Lemma 2. The problem of ﬁnding a most-preferred feasible bundle of courses of a given
applicant with additive preferences in capr is NP-hard.

Proof. We transform from the knapsack problem, which is deﬁned as follows. An in-
stance I of knapsack comprises a set of integers w1, w2, . . . , wn, p1, p2, . . . , pn, W, P . The
problem is to decide whether there exists a set K ⊆ {1, 2 . . . , n} such that Pi∈K wi ≤ W
and Pi∈K pi ≥ P . knapsack is NP-complete [21].

i=1{d1

i , d2

i , . . . , dwi−1

Let us construct an instance J of capr as follows. There is a single applicant a1
such that q(a1) = W . The set of courses is C ∪ D, where C = {c1, c2, . . . , cn} and
D = ∪n
}. For each course ci (1 ≤ i ≤ n), its utility for applicant a1 is
equal to pi. Moreover ci has wi − 1 prerequisites d1
. For each i (1 ≤ i ≤ n)
and j (1 ≤ j ≤ wi − 1), dj
i for a1, where the ε values are all positive, distinct
and add up to less than 1. They are selected simply to ensure that a1’s preferences over
individual courses are strict.
It is easy to see that in J, a1 has a feasible bundle with
utility at least P if and only if I is a yes-instance of knapsack.

i has utility εj

i

i , d2

i , . . . , dwi−1

i

In the case of just one applicant a1, a matching M is a POM if and only if a1 is
assigned in M her most-preferred feasible bundle of courses, otherwise M is dominated by
assigning a1 to this bundle. Hence the above lemma directly implies the following result.

Theorem 3. Given an instance of capr with additive preferences, the problem of ﬁnding
a POM is NP-hard.

Given the above negative result, we do not pursue additive preferences any further in

this section, and instead turn our attention to lexicographic preferences.

7

3.2 Lexicographic preferences

3.2.1 Finding a POM

In this section we explore variants of the sequential allocation mechanism, and show that
one formulation allows us to ﬁnd a POM in polynomial time. This mechanism, referred
to as SM-CAPR, does however have some drawbacks: it is not truthful (see Section 6) and
it is not able to compute all POMs in general.

In the context of course allocation when there are some dependencies among courses
(for instance the constraints on prerequisites in capr) the standard sequential mechanism
might output an allocation that does not fulﬁl some constraints on prerequisites. On the
other hand, if we require that an applicant can only choose a course if she is already
assigned all its prerequisites, the output may be a matching that is not Pareto optimal.
This is illustrated by the following example.

Example 4. Construct a capr instance in which A = {a1, a2} and C = {c1, c2, c3, c4}.
Each applicant has capacity 2 and each course has capacity 1. The prerequisites of both
applicants are the same, and are as follows:

The applicants have the following preference lists:

c1 → c3;

c2 → c4.

P (a1) : c1, c2, c4, c3

P (a2) : c2, c1, c3, c4

The sequential allocation mechanism with policy σ = a1, a2, a1, a2 will assign to appli-
cant a1 the bundle {c1, c4} and to applicant a2 the bundle {c2, c3}. Clearly, neither of the
assigned bundles fulﬁls the prerequisites.

Now suppose that in the sequential allocation mechanism an applicant is allowed to
choose the most-preferred undersubscribed course for which she already has all the prereq-
uisites. Let the policy start with a1, a2. Applicant a1 can choose neither c1 nor c2, as these
courses require a prerequisite that she is not assigned yet. So she chooses c4. Similarly,
applicant a2 will choose c3. When these applicants are allowed to pick their next course,
irrespective of the remainder of the policy, a1 must choose c2 and a2 must choose c1. So in
the resulting matching M we have M (a1) = {c2, c4} and M (a2) = {c1, c3}. This matching
is clearly not Pareto optimal, since both applicants will strictly improve by exchanging
their assignments.

Therefore we propose a variant of the sequential allocation mechanism, denoted by
SM-CAPR, that can be regarded as being “in between” the serial dictatorship mechanism
and the general sequential allocation mechanism. Suppose a policy σ is ﬁxed; again one
applicant can appear in σ several times, up to her capacity. Applicant ai on her turn
identiﬁes her most-preferred course cj that she has not yet considered, and that she is
satisfy the property that either (i) ck
not already assigned to.
→aicj not
has a free place or (ii) ck is already assigned to ai, and the number of courses in
already assigned to ai does not exceed the remaining capacity of ai, then ai is assigned
to ai then ai moves to the next
the bundle
course in her preference list until either she is assigned to some bundle or her preference
list is exhausted. This completes a single turn for ai.

→aicj . If it is impossible to assign bundle

→aicj

If all courses ck in

→aicj

For this approach we need an algorithm that decides whether applicant ai can be
→aicj . A subsidiary method called Explore, explicitly given in Algorithm 1, takes

assigned

8

Algorithm 1 Explore
Require: course cj where cj /∈ M (ai) and |M (cj)| < uj (capr instance I, matching M , applicant

ai, set S and Boolean feasible are global variables)

Ensure: if cj and each of its prerequisites either (i) has room for ai or (ii) is already assigned ai
then all courses not already assigned to ai are added to S and feasible is unchanged, otherwise
feasible is set to false

1: S := S ∪ {cj};
2: if cj is not a leaf node in

→aicj then

3:
4:
5:
6:
7:
8:
9:

for each ck ∈

→aicj \{cj} do

if ck /∈ M (ai) and not visited(ck) then

if |M (ck)| < q(ck) then
visited(ck) := true;
Explore(ck);

else

feasible := false;

as input a course cj where cj /∈ M (ai) and |M (cj )| < q(cj). Here it is assumed that the
matching M and the capr instance I are global variables. We use a set S, maintained as
that are not already assigned to
a global variable, to collect together the courses in
ai, assuming the whole bundle can be assigned to ai. An array of Booleans called ‘visited’
→aicj being visited more
is maintained as a global variable and used to prevent a course in
than once if there are several paths to it from predecessors. A further global variable, a
→aicj either has room for ai
Boolean ‘feasible’, initially true, remains true if each course in
or is already assigned to ai, and becomes false otherwise. Explore is a recursive algorithm
→aicj .
that performs a modiﬁed depth-ﬁrst search in the directed graph corresponding to

→aicj

The pseudocode for SM-CAPR is given in Algorithm 2. This algorithm constructs a
POM M in a given capr instance I relative to a given policy σ, with the aid of Explore.
It uses a Boolean ‘isAssigned’ to determine whether an applicant ai has been assigned
to some bundle of courses on her turn yet. When attempting to assign ai to the bundle
→aicj , it initialises the set S and the Boolean ‘feasible’ as described above in the context of
in preparation for the
Explore. It also sets the ‘visited’ Booleans for each course in
depth-ﬁrst search carried out by Explore. Once Explore returns, we can assign ai to the
→aicj that she is
bundle
not already assigned to; if so, ai is assigned to all such courses and ‘isAssigned’ is given
the value true.

→aicj as long as ‘feasible’ is true and ai has room for the courses in

→aicj

Notice that serial dictatorship will be obtained as a special case of SM-CAPR if all the

copies of one applicant form a substring (i.e., a contiguous subsequence) of the policy.

We now show that SM-CAPR constructs a POM.

Theorem 5. Algorithm SM-CAPR produces a POM for a given instance I of capr and
for a given policy σ in I.

Proof. It is straightforward to verify that the assignment M produced by SM-CAPR is
a matching in I. Suppose for a contradiction that M is not a POM. Then there exists
a matching M ′ that dominates M . Let A′ be the set of applicants who prefer their
assignment in M ′ to their assignment in M . For each aj ∈ A′, denote by sj the ﬁrst stage
of SM-CAPR when aj did not get a course, say cij , that is assigned to her in M ′. Stage sj
must have initiated a call to Explore(cij ) with applicant aj, for cij cannot be a prerequisite
for any course assigned to aj before stage sj. Clearly cij was not assigned to aj in M , and
cij is the most-preferred course in M ′(aj)\M (aj ). Let ak = arg minaj ∈A′{sj}.

9

Algorithm 2 SM-CAPR
Require: capr instance I and a policy σ
Ensure: return M , a POM in I
1: M := ∅;
2: for each applicant ai ∈ σ in turn do
3:
4:
5:
6:
7:
8:

cj := next course in ai’s list;
feasible := true;
if cj /∈ M (ai) and |M (cj)| < q(cj) then

S := ∅;
for each ck ∈

→aicj do

visited(ck) := false;

visited(cj) := true;
Explore(cj);
if feasible and |M (ai)| + |S| ≤ q(ai) then

for each ck ∈ S do

M := M ∪ {(ai, ck)};

isAssigned := true;

isAssigned := false;
while ai has not exhausted her preference list and not isAssigned do

9:
10:

11:
12:
13:
14:
15:

16:
17: return M ;

As cik ∈ M ′(ak), all the prerequisites of cik also belong to M ′(ak). Since sk is the ﬁrst
stage in which an applicant received a course in M ′ but not in M , all the courses assigned
in M to any applicant aj in previous stages also belong to M ′(aj), for otherwise M ′ does
not dominate M . Thus it was not the case that applicant ak failed to receive course cik
in M at stage sk because ak did not have room for cik and all of its prerequisites not
already assigned to her in M . Rather, applicant ak failed to receive course cik in M at
stage sk because at least one of the prerequisite courses of cik , say cr, was already full in
M before stage sk. It follows from our previous remark that in M ′, all the places in cr are
occupied by applicants other than ak. Thus cik cannot be assigned to ak in M ′ after all,
a contradiction.

To derive the complexity bound of the algorithm, let us ﬁrst observe that the com-
→aicj (cid:12)
plexity of Explore(cj ) is O(Dai ) when executed relative to applicant ai, where Dai = (cid:12)
.
(cid:12)(cid:12)
(cid:12)(cid:12)
This in turn is O(Rai) where Rai is the number of courses in →ai, which is obviously
O(n2) (recall that |C| = n2).

Thus the complexity of SM-CAPR is O(Ln2), where L is the total length of the appli-
cants’ preference lists. The complexity of the algorithm can be no better than this in the
worst case, as the following example shows.

Example 6. Consider a cacr instance in which A = {a1, a2, . . . , an} is the set of ap-
plicants and C = {c1, c2, . . . , c2n} is the set of courses, for some n ≥ 1. Assume that
each course has capacity 1, whilst each applicant has capacity n and ranks all courses in
increasing indicial order. Also suppose that the prerequisites for each applicant are as
follows:

c1 → c2 → · · · → c2n.

in the POM Mi (1 ≤ i ≤ n), ai is assigned the set of courses
There are n POMs:
{cn+1, cn+2, . . . , c2n} and no course is assigned to any other applicant. Given any policy,
let ai be the ﬁrst applicant considered during an execution of SM-CAPR. When Explore is
called on c1, 2n courses are checked, then Explore is called on c2 leading to 2n − 1 courses
being checked, and so on. This continues until Explore is called on cn+1, leading to the

10

matching Mi being constructed at this point. Note that even if the entire recursive process
were to halt as soon as |S| > q(ai), the total number of courses checked at this step of
SM-CAPR is still Ω(n2). Similarly, the number of courses checked at each other applicant’s
turn in the policy is also Ω(n2); the only diﬀerence is that in each such case SM-CAPR
determines that cn+i is full immediately, for each i (1 ≤ i ≤ n). The overall number of
steps used by SM-CAPR is then Ω(n3) = Ω(Ln2).

Our next example indicates that in general, SM-CAPR is not capable of generating all

POMs for a given capr instance.

Example 7. SM-CAPR is not able to produce all POMs, even in the case when there are
only two applicants a1, a2 and the capacity of each course is 1. We provide two instances
to illustrate this. In I1 the prerequisites of all applicants are the same. In I2 they are
diﬀerent, but each course has at most one prerequisite.

In I1, we have C = {c1, c2, c3}, and course c1 has two prerequisites as follows:

c1 → c2;

c1 → c3.

(1)

Each applicant has capacity 3 and the following preference list: c1, c2, c3.

Depending on the policy, SM-CAPR outputs either the matching that assigns all three
courses to a1, or the matching that assigns all three courses to a2. However, it is easy to
see that the two matchings that assign c2 to one applicant and c3 to the other one are also
Pareto optimal.

In I2, we have C = {c1, c2, c3}. Now the prerequisites of the applicants are diﬀerent:

c1 →a1 c3;

c2 →a2 c3,

(2)

Each applicant has capacity 2 and their preferences are as follows:

P (a1) : c1, c2, c3

P (a2) : c2, c1, c3.

There are 3 diﬀerent POMs, as follows:

M1(a1) = {c1, c3}, M1(a2) = ∅;
M2(a1) = ∅,
M3(a1) = {c2},

M2(a2) = {c2, c3};
M3(a2) = {c1, c3}.

SM-CAPR outputs M1 with policy σ = a1, a2 and M2 with policy σ = a2, a1. Notice

that M3 cannot be obtained by SM-CAPR.

Theorem 3 shows that ﬁnding a POM in the presence of additive preferences is NP-

hard. It is instructive to show where SM-CAPR can fail to ﬁnd a POM in this context,

Example 8. Let I be an instance of capr in which there are two applicants, a1, a2, each
of which has capacity 2, and four courses, c1, c2, c3, c4, each of which has capacity 1. The
prerequisites of both applicants are the same, and are as follows:

The utilities of the courses for the applicants are as follows:

c1 → c2;

c3 → c4.

ua1(c1) = ua2(c3) = 6
ua1(c3) = ua2(c1) = 4
ua1(c4) = ua2(c2) = 3
ua1(c2) = ua2(c4) = 0

Regardless of the policy, SM-CAPR constructs the matching M = {(a1, c1), (a1, c2), (a2, c3),
(a2, c4)}. M is not a POM as it is dominated by M ′ = {(a1, c3), (a1, c4), (a2, c1), (a2, c2)}.

11

3.2.2 Testing for Pareto optimality

In the previous subsection we gave a polynomial-time algorithm for constructing a POM
in an instance of capr. It is also reasonable to expect that alternative approach could
involve starting with an arbitrary matching, and for as long as the current matching M
is dominated, replace M by any matching that dominates it. However, the diﬃculty with
this method is that the problem of determining whether a matching is Pareto optimal is
computationally hard, as we demonstrate by our next result. This hardness result also
shows that there is unlikely to be a “nice” (polynomial-time checkable) characterisation
of a POM, in contrast to the case where there are no prerequisites [12]. We ﬁrstly deﬁne
the following problems:

Name: exact 3-cover
Instance: a set X = {x1, x2, . . . , x3n} and a set T = {T1, T2, . . . , Tm} such that for
each i (1 ≤ i ≤ m), Ti ⊆ X and |Ti| = 3.
Question: is there a subset T ′ of T such that Ti ∩ Tj = ∅ for each Ti, Tj ∈ T ′ and
∪Ti∈T ′Ti = X?

Name: dom capr
Instance: an instance I of capr and a matching M in I
Question: is there a matching M ′ that dominates M in I?

Theorem 9. dom capr is NP-complete even if each course has capacity 1 and has at
most one immediate prerequisite for each applicant.

Proof. Clearly dom capr is in NP. To show NP-hardness, we reduce from exact 3-cover,
which is NP-complete [21]. Let I be an instance of exact 3-cover as deﬁned above. For
each Ti ∈ T , let us denote the elements that belong to Ti by xi1, xi2, xi3 . Obviously, we
lose no generality by assuming that m ≥ n.

We construct an instance J of dom capr based on I in the following way. The
set of applicants is A = {a1, a2, . . . , am+1}. The capacities are q(ai) = 4 (1 ≤ i ≤ m)
and q(am+1) = 2n + m. The set of courses is C = T ∪ X ∪ Y ∪ W , where T =
{T1, T2, . . . , Tm}, X = {x1, x2, . . . , x3n}, Y = {y1, y2, . . . , ym} and W = {w1, w2, . . . , wm−n}.
(Some of the courses in J derived from the elements and sets in I are denoted by identical
symbols, but no ambiguity should arise.) The preferences of the applicants are:

P (ai) : Ti, [W ], yi, xi1, xi2, xi3
P (am+1) : y1, [X], [W ], y2, . . . , ym

(1 ≤ i ≤ m)

where the symbols [W ] and [X] denote all the courses in W and X, respectively, in an
arbitrary strict order. Recall that {xi1, xi2, xi3} ⊆ X (1 ≤ i ≤ m). The prerequisites of
applicants are:

ai : Ti →ai xi1 →ai xi2 →ai xi3

(1 ≤ i ≤ m)

am+1 : y1 →am+1 y2 →am+1 · · · →am+1 ym

Deﬁne the following matching:

M = {(ai, yi) : 1 ≤ i ≤ m} ∪ {(am+1, xj) : 1 ≤ j ≤ 3n)} ∪ {(am+1, wk) : 1 ≤ k ≤ m − n)}.

We claim that I admits an exact cover if and only if M is dominated in J.

For, suppose that {Tj1, Tj2, . . . , Tjn} is an exact cover in I. We construct a matching
M ′ in J as follows. For each k (1 ≤ k ≤ n), in M ′, assign ajk to Tjk and to ajk ’s
three prerequisites of Tjk that belong to X. Let A′ = {aj1, aj2, . . . , ajn, am+1} and let

12

A\A′ = {ak1, ak2, . . . , akm−n}. For each r (1 ≤ r ≤ m − n), in M ′, assign akr to wr.
Finally in M ′, assign am+1 to every course in Y . It is straightforward to verify that M ′
dominates M in J.

Conversely, suppose there exists a matching M ′ that dominates M in J. Then at least

one applicant must be better oﬀ in M ′ compared to M .

If am+1 improves, she must obtain y1 and so, due to her prerequisites, all the courses
in Y . This means that each applicant ai (1 ≤ i ≤ m) must obtain a course that she prefers
to yi.

Each such applicant ai can improve relative to M in two ways. Either she obtains
in M ′ a course in W , or she obtains Ti.
In the latter case then she must receive the
corresponding courses xi1, xi2, xi3 in M ′. In either of these two cases, since am+1 cannot
be worse oﬀ, she must obtain in M ′ the course y1 and hence all courses in Y .

This means that in M ′ all the applicants must strictly improve compared to M . As
there are only n − m courses in W , there are exactly n applicant in A\{am+1} – let these
applicants be {aj1, aj2, . . . , ajn} – who obtain a course in T and its three prerequisites in
X. As the capacity of each course is 1, it follows that {Tjk : 1 ≤ j ≤ n} is an exact cover
in I.

We remark that the variant of dom capr for additive preferences is also NP-complete
by Theorem 9, since lexicographic preferences can be viewed as a special case of additive
preferences by creating utilities that steeply decrease in line with applicants’ preferences
– see [8] for more details.

3.2.3 Finding large POMs

Example 7 shows that an instance of capr may admit POMs of diﬀerent cardinalities,
where the cardinality of a POM refers to the number of occupied course slots.
It is
known that ﬁnding a POM with minimum cardinality is an NP-hard problem even for
ha, the House Allocation problem (i.e., the restriction of ca in which each applicant and
each course has capacity 1) [2, Theorem 2]. However, by contrast to the case for ha [2,
Theorem 1] and ca [12, Theorem 6]), the problem of ﬁnding a maximum cardinality POM
in the capr context is NP-hard, as we demonstrate next via two diﬀerent proofs. Our
ﬁrst proof of this result shows that hardness holds even if the matching is not required to
be Pareto optimal.

We ﬁrstly deﬁne some problems. Let max capr and max pom capr denote the
problems of ﬁnding a maximum cardinality matching and a maximum cardinality POM
respectively, given an instance of capr. Let max capr-d denote the decision version of
max capr: given an instance I of capr and an integer K, decide whether I admits a
matching of cardinality at least K. We obtain max pom capr-d from max pom capr
similarly.

Theorem 10. max capr-d is NP-complete, even if each applicant has capacity 4 and
each course has capacity 1, and the prerequisites are the same for all applicants.

Proof. Clearly max capr-d is in NP. To show NP-hardness, we reduce from ind set-d
in cubic graphs; here ind set-d is the decision version of ind set, the problem of ﬁnding
a maximum independent set in a given graph. ind set-d is NP-complete in cubic graphs
[18, 27]. Let hG, Ki be an instance of ind set-d in cubic graphs, where G = (V, E)
is a cubic graph and K is a positive integer. Assume that V = {v1, v2, . . . , vn} and
E = {e1, e2, . . . , em}. For a given vertex vi ∈ V , let Ei ⊆ E denote the set of edges
incident to vi in G. Clearly |Ei| = 3 as G is cubic.

13

We form an instance I of max capr-d as follows. Let A be the set of applicants and
let V ∪ E be the set of courses, where A = {ai : vi ∈ V } (we use the same notation for the
vertices and edges in G as we do for the courses in I, but no ambiguity should arise.) Let
the capacity of each applicant be 4 and the capacity of each course be 1. The preference
list of each applicant is as follows:

ai : vi

[Ei]

(1 ≤ i ≤ n)

where the symbol [Ei] denotes all members of Ei listed in arbitrary order. For each vi ∈ V
and for each ej ∈ Ei, deﬁne the prerequisite vi → ej for all applicants. We claim that G
has an independent set of size at least K if and only if I has a matching of size at least
m + K.

For, suppose that S is an independent set in G where |S| ≥ K. Let A′ = {ai ∈ A :
vi ∈ S}. We form an assignment M in I as follows. For each applicant ai ∈ A′, assign ai
to vi plus the prerequisite courses in Ei. Then for each applicant ai /∈ A′, assign ai to any
remaining courses in Ei (if any). It is straightforward to verify that M is a matching in I.
Also |M | = m + |S| ≥ m + K, since every applicant ai ∈ A′ obtains vi and all prerequisite
courses in Ei, and then the applicants in A\A′ are collectively assigned to all remaining
unmatched courses in E.

Conversely suppose that M is a matching in I such that |M | ≥ m + K. Let S denote
the courses in V that are matched in M , and suppose that |S| < K. Then since |E| = m
and all courses have capacity 1, M ≤ |S| + |E| ≤ m + |S| < m + K, a contradiction. Hence
|S| ≥ K. We now claim that S is an independent set in G. For, suppose that vi and vj
are two adjacent vertices in G that are both in S. Then it is impossible for both ai and
aj to meet their prerequisites on vi and vj in I, respectively, a contradiction.

Corollary 11. max pom capr-d is NP-hard, even if each applicant has capacity 4 and
each course has capacity 1, and the prerequisites are the same for all applicants.

Proof. In the proof of Theorem 10, the matching M in I constructed from an independent
set S in G is in fact Pareto optimal. To see this, let σ be an ordering of the applicants
such that every applicant in A′ precedes every applicant in A\A′. Let M be the result of
running Algorithm SM-CAPR relative to the ordering σ. It follows by Theorem 5 that M
is a POM in I. The remainder of the proof of Theorem 10 can then be used to show that
max pom capr-d is NP-hard.

We now give an alternative proof of Corollary 11 for the case that the constructed
matching is required to be Pareto optimal. This gives NP-hardness for stronger restric-
tions on prerequisites than those given by Corollary 11. Our reduction involves a trans-
formation from the following problem:

Name: (2,2)-e3-sat
Instance: a Boolean formula B, where each clause in B has size three, and each
variable occurs exactly twice as an unnegated literal and exactly twice as a negated
literal in B.
Question: is B satisﬁable?

Theorem 12. max pom capr-d is NP-hard, even if each course has at most one pre-
requisite, and the prerequisites are the same for all applicants.

Proof. We ﬁrstly remark that, in view of Theorem 9, it is not known whether max pom
capr-d belongs to NP. We show NP-hardness for this problem via a reduction from (2,2)-
e3-sat as deﬁned above.

14

i , y2
i

Let B be an instance of (2,2)-e3-sat, where V = {v1, v2, . . . , vn} is the set of variables
and C = {c1, c2, . . . , cm} is the set of clauses. We construct an instance I of max pom
capr-d as follows. Let X ∪ Y be the set of courses, where X = {x1
i : 1 ≤ i ≤ n}
and Y = {y1
: 1 ≤ i ≤ n}. The courses in X correspond to the ﬁrst and second
occurrences of vi and ¯vi in B for each i (1 ≤ i ≤ n). Let A ∪ G be the set of applicants,
where A = {aj : 1 ≤ j ≤ m} and G = {g1
i : 1 ≤ i ≤ n}. Each course has capacity 1.
Each applicant in A has capacity 1, whilst each applicant in G has capacity 2. For each i
(1 ≤ i ≤ n), deﬁne the prerequisite y1
i , which is the same for all applicants. For each
j (1 ≤ j ≤ m) and for each s (1 ≤ s ≤ 3), let x(cs
j) denote the X-course corresponding to
the literal appearing at position s of clause cj in B. For example if the second position
of clause c5 contains the second occurrence of literal ¯vi, then x(c2
i . The preference
lists of the applicants are as follows:

5) = ¯x2

i → y2

i , x2

i , ¯x1

i , ¯x2

i , g2

P (aj) : x(c1
i , y2
P (g1
P (g2
i , y2

i ) : y1
i ) : y1

j ), x(c2
i , x1
i , ¯x1

i , x2
i
i , ¯x2
i

j ), x(c3
j )

(1 ≤ j ≤ m)
(1 ≤ i ≤ n)
(1 ≤ i ≤ n)

We claim that B has a satisfying truth assignment if and only if I has a POM of size
m + 4n.

i , ¯x1
i , x2

i ), (g2
i ), (g2

i ), (g1
i ) to M . On the other hand if f (vi)=false then add the pairs (g1
i ), (g2

For, suppose that f is a satisfying truth assignment for B. We form a matching M in
I as follows. For each i (1 ≤ i ≤ n), if f (vi)=true then add the pairs (g1
i ),
(g2
i ),
(g1
i ) to M . For each j (1 ≤ j ≤ m), at least one literal in cj is true
under f . Let s be the minimum integer such that the literal at position s of cj is true
under f . Course x(cs
j )) to M . It may be
veriﬁed that M is a POM of size m + 4n in I.

j) is still unmatched by construction; add (aj, x(cs

i , ¯x2
i , y1

i , y2
i , x1

i , y2

i , y1

i , y2

i , y2

i , y1

i ), (g1

i )} ⊆ M or {(g2

i ), (g2
i , y1
i , y2

Conversely suppose that M is a POM in I of size m + 4n. Then the cardinality of M
implies that every applicant is full in M . We ﬁrstly show that, for each i (1 ≤ i ≤ n),
i , y2
either {(g1
i , y1
i )} ⊆ M . Suppose this is not the case. As
a consequence of the prerequisites, if (gr
i ) ∈ M for some i (1 ≤ i ≤ n) and r ∈ {1, 2},
then (gr
i ) ∈ M . Suppose now that (gr
i ) ∈ M for some r ∈ {1, 2}, but (gr
i ) /∈ M .
Let M ′ be the matching obtained from M by removing any assignee of gr
i (if
i ) to M . Then M ′ dominates M , a contradiction.
such an assignee exists) and adding (gr
is unmatched in M . Let M ′ be the matching obtained from M by
Now suppose that y2
i
i , yr
removing any assignee of g1
i )
to M (r ∈ {1, 2}). Then M ′ dominates M , a contradiction. Thus the claim is established.
It follows that for each i (1 ≤ i ≤ n), either g1
i is matched in M to two members of X and
g2
i is matched in M to two members of Y , or vice versa.

i (if such an assignee exists) and adding (g1

i worse than y2

i worse than y2

i , y1

i , y1

Now create a truth assignment f in B as follows. For each i (1 ≤ i ≤ n), if (g1

i ) ∈
M , set f (vi)=true, otherwise set f (vi)=false. We claim that f is a satisfying truth
assignment for B. For, let j (1 ≤ j ≤ m) be given. Then (aj, x(cs
j )) ∈ M for some s
(1 ≤ s ≤ 3). If x(cs
i for some i (1 ≤ i ≤ n) and r (r ∈ {1, 2}) then f (vi) = T
by construction. Similarly if x(cs
i for some (1 ≤ i ≤ n) and r (r ∈ {1, 2}) then
f (vi) = F by construction. Hence f satisﬁes B.

j) = ¯xr

j) = xr

i , y1

The next example shows that the diﬀerence in cardinalities between POMs may be
arbitrary, and that SM-CAPR is not in general a constant-factor approximation algorithm
for max pom capr.

Example 13. Consider a capr instance I in which A = {a1, a2} and C = {c1, c2, . . . , cn}
for some n ≥ 1. Let the preferences of the applicants be

P (a1) : c1, c2, . . . , cn

P (a2) : cn

15

and let ci → ci+1 for each applicant (1 ≤ i ≤ n − 1). Assume that a1 has capacity n,
whilst the capacity of a2 and the capacity of every course is 1.

There are two POMs in I: if SM-CAPR is executed relative to the policy a1, a2 then
we obtain the POM M1 that assigns all the n courses to a1 and nothing to a2; if instead
the policy is reversed, we obtain the POM M2 that assigns nothing to a1 and the single
course cn to a2. Hence executing SM-CAPR relative to diﬀerent policies can give rise to
POMs with arbitrarily large diﬀerence in cardinality. It follows that SM-CAPR is not in
general a constant-factor approximation algorithm for max pom capr. However, notice
that in this example the cardinality of the downset of each course is not bounded by a
constant; enforcing such a condition could improve the approximation possibilities.

4 Alternative prerequisites

In this section we turn our attention to caapr, the analogue of capr in which prerequi-
sites need not be compulsory but may be presented as alternatives. We will show that,
in contrast to the case for capr, ﬁnding a POM is NP-hard, under either additive or
lexicographic preferences.

Recall that as capr is a special case of caapr, Lemma 2 implies that ﬁnding a most-
preferred bundle of courses under additive preferences is NP-hard. Now we prove the same
result for lexicographic preferences.

Lemma 14. Given an instance I of caapr and an applicant ai in I, the problem of
deciding whether I admits a matching in which ai receives her most-preferred course is
NP-complete.

Proof. Clearly the problem belongs to NP. To show NP-hardness, we reduce from vc-d,
the decision version of vc, which is the problem of ﬁnding a vertex cover of minimum size
in a given graph. vc-d is NP-complete [17]. Let hG, Ki be an instance of vc-d, where
G = (V, E) is a graph and K is a positive integer. Assume that V = {v1, v2, . . . , vn} and
E = {e1, e2, . . . , em}. We construct an instance I of caapr as follows. Let the set of
courses be V ∪ E ∪ {b} (again, we use the same notation for vertices and edges in G as
we do for courses in I, but no ambiguity should arise.) There is a single applicant a1 with
capacity m + K + 1 whose preference list is as follows:

P (a1) : b, e1, e2, . . . , em, v1, v2, . . . , vn.

Course b has a single compulsory prerequisite course e1, and each course ej (2 ≤ j ≤
m − 1) has a single compulsory prerequisite course ej+1. Moreover, all the E-courses have
(alternative) prerequisites; namely, for any j (1 ≤ j ≤ m), if course ej corresponds to the
edge ej = {vi, vk} then ej 7→a1 {vi, vk}. We claim that G admits a vertex cover of size at
most K if and only if I admits a matching in which a1 is assigned course b.

For, suppose that G admits a vertex cover S where |S| ≤ K. Form a matching M by
assigning a1 to the bundle B = {b} ∪ E ∪ S. Then B is a feasible bundle of courses for a1,
and b ∈ B.

Conversely, suppose I admits a matching M in which a1 is assigned a bundle containing
course b. Then, due to the prerequisites, B must contain all E-courses and for each course
in ej ∈ E, B must contain some course in vi ∈ V that corresponds to a vertex incident to
ej. Let S = B ∩ V . Clearly S is a vertex cover in G, and as q(a) = m + K + 1, it follows
that |S| ≤ K.

Corollary 15. The problem of ﬁnding the most-preferred feasible bundle of courses of a
given applicant with lexicographic preferences in caapr is NP-hard.

16

As noted in Section 3.1, in the case of just one applicant a1, a matching M is a POM
if and only if a1 is assigned in M her most-preferred feasible bundle of courses. Hence
Lemma 2 and Corollary 15 directly imply the following assertion.

Theorem 16. Given an instance of caapr the problem of ﬁnding a POM is NP-hard.
The result holds under either additive or lexicographic preferences.

We ﬁnally remark that, since capr is a special case of caapr, Theorem 9 implies that
the problem of determining whether a given matching M is a POM is co-NP-complete
for lexicographic preferences (and also for additive preferences by the remark following
Theorem 9).

5 Corequisites

In this section we focus on cacr, the extension of ca involving corequisite courses. As
in the case of capr, we will show that ﬁnding a POM in the presence of additive pref-
erences is NP-hard. Thus the majority of our attention is concerned with lexicographic
preferences. In this case we show how to modify the sequential mechanism in order to
obtain a polynomial-time algorithm for ﬁnding a POM in the cacr case. Moreover we
show that in cacr, the problem of ﬁnding a maximum cardinality POM is very diﬃcult
to approximate.

We begin with additive preferences. A simple modiﬁcation of the proof of Lemma 2
i for each r (1 ≤ r ≤ wi − 1)) gives the

(ensuring that, for each i (1 ≤ i ≤ n), ci ↔ dr
following analogue of Theorem 3.

Theorem 17. Given an instance of cacr with additive preferences, the problem of ﬁnding
a POM is NP-hard.

In view of Theorem 17, in the remainder of this section we assume that preferences are
lexicographic. In this case we can ﬁnd a POM eﬃciently by dealing with the corequisites
as follows. Let I be an instance of cacr, let σ be a policy in I, and assume the notation
deﬁned in Section 2.4. We lose no generality by supposing that each applicant either
ﬁnds all the courses in one equivalence class C k acceptable, or none of them. Replace all
the courses in C k by a single supercourse ck, whose capacity is equal to the sum of the
capacities of the courses in C k. For any applicant ai ∈ A who ﬁnds all courses in C k
acceptable, remove all such courses from ai’s list and replace them by ck; since preferences
are lexicographic, the position of ck in the modiﬁed preference list of ai is the position
of the most-preferred course of C k in her original list. Let I ′ denote the cacr instance
obtained from I by using this transformation.

The sequential mechanism for cacr can be executed on I ′ as follows. The mechanism
works according to a given policy σ in stages. In one stage, the applicant ai who next has
her turn according to σ, chooses her most-preferred supercourse ck to which she has not
yet applied. Applicant ai is assigned to ck if two conditions are fulﬁlled: (i) the number of
courses assigned to ai so far plus the cardinality of C k does not exceed q(ai), and (ii) each
course cj ∈ C k still has a free slot. If this is not possible, at the same stage ai applies to
her next supercourse until she is either assigned some supercourse or her preference list is
exhausted. Once the whole process terminates, let M ′ be the assignment of applicants to
supercourses in I ′ and construct the following assignment M in I from M ′:

M = {(ai, cj) : ai ∈ A ∧ cj ∈ C k ∧ (ai, ck) ∈ M ′}.

Let SM-CACR denote the mechanism that constructs M from I and σ. We next show

that SM-CACR always yields a POM; the proof is very similar to that of Theorem 5.

17

Theorem 18. Algorithm SM-CACR produces a POM for a given instance I of cacr and
for a given policy σ in I.

Proof. It is straightforward to verify that the assignment M produced by SM-CACR is
a matching in I. Suppose for a contradiction that M is not a POM in I. Denote by
M ′ the matching in I ′ that SM-CACR constructs. Then there exists a matching M ′′ that
dominates M ′ in I ′. Let A′ be the set of applicants who prefer, in I ′, their assignment in
M ′′ to their assignment in M ′. For each aj ∈ A′, denote by sj the ﬁrst stage of SM-CACR
when aj did not get a supercourse, say cij , that is assigned to her in M ′′. Clearly cij was
not assigned to aj in M ′, and cij is the most-preferred supercourse in M ′′(aj)\M ′(aj). Let
ak = arg minaj ∈A′{sj}.

Clearly cik ∈ M ′′(ak). Moreover since sk is the ﬁrst stage in which an applicant received
a supercourse in M ′′ but not in M ′, all the supercourses assigned in M ′ to any applicant aj
in previous stages also belong to M ′′(aj), for otherwise M ′′ does not dominate M ′. Thus
it was not the case that applicant ak failed to receive supercourse cik in M ′ at stage sk
because ak did not have room for cik in M ′. Rather, applicant ak failed to receive course
cik in M ′ at stage sk because at least one of the courses in C ik , say cr, was already full in
M ′ before stage sk. It follows from our previous remark that in M ′′, all the places in cr
are occupied by applicants other than ak. Thus cik cannot be assigned to ak in M ′′ after
all, a contradiction.

In the cacr model as deﬁned in Section 2.4, corequisite constraints are common to
all applicants.
In this setting, and after the modiﬁcation described prior to Theorem
18, in which courses are merged into supercourses, cacr becomes equivalent to cap, the
extension of ca with price-budget constraints described in [12]. For an instance I of
cap, it is known that for each POM M in I, there exists a policy σ such that executing
SM-CACR relative to σ produces M [12, Theorem 3]. Our next example presents an
observation about the behaviour of SM-CACR if we extend it to the variant of cacr in
which corequisite constraints are speciﬁc to individual applicants.

Example 19. The SM-CACR mechanism can be extended without diﬃculty to the variant
of cacr (considered in this example only) in which corequisites can be applicant-speciﬁc.
However it is no longer true that the mechanism is capable of reaching all POMs relative
to a suitable policy, as we now illustrate. Consider a cacr instance with two applicants
and three courses. Suppose that each applicant has capacity 2, and that each course has
capacity 1. Assume that the applicants have the following preference lists:

P (a1) :
P (a2) :

c1, c2, c3
c2, c1, c3

Assume that each applicant has as corequisites the ﬁrst and last courses on her list. Then
SM-CACR will return the matching {(ai, ci), (ai, c3)} if the ﬁrst applicant in the policy is
ai (i ∈ {1, 2}). However the matching M = {(a1, c2), (a2, c1)} is also Pareto optimal and
cannot be obtained by SM-CACR.

Given an instance of cap, the problem of ﬁnding a maximum cardinality POM is
NP-hard [12, Theorem 7]. Using the connection between cacr and cap described prior
to Example 19, the same is therefore true for max pom cacr, the problem of ﬁnding a
maximum cardinality POM, given an instance of cacr. We now strengthen this result by
showing that max pom cacr is very diﬃcult to approximate.

Theorem 20. max pom cacr is NP-hard and not approximable within a factor of N 1−ε,
for any ε > 0, unless P=NP, where N is the total capacity of the applicants.

18

Proof. Let ε > 0 be given. Let B be an instance of (2,2)-e3-sat, where V = {v1, v2, . . . , vn}
is the set of variables and C = {c1, c2, . . . , cm} is the set of clauses. Let β = (cid:6) 2
ε (cid:7) and let
α = nβ.

i , x2

i , ¯x2

i , ¯x1

i : 1 ≤ i ≤ n}, Y = {y1

We form an instance I of cacr as follows. Let X ∪ Y ∪ Z be the set of courses, where
X = {x1
i : 1 ≤ i ≤ n} and Z = {z1, z2, . . . , zD}, where
D = 6n(α − 1) + 1. The courses in X correspond to the ﬁrst and second occurrences of
vi and ¯vi in B for each i (1 ≤ i ≤ n). Let A ∪ G ∪ {b, h} be the set of applicants, where
A = {aj : 1 ≤ j ≤ m} and G = {g1
: 1 ≤ i ≤ n}. Each course has capacity 1. Each
applicant in A has capacity 1, each applicant in G has capacity 2, h has capacity 2n − m
and b has capacity D.

i , y2

i , g2
i

For each i (1 ≤ i ≤ n), courses y1

i and y2

are corequisites. For each j (1 ≤ j ≤ m) and for each s (1 ≤ s ≤ 3), x(cs
the proof of Theorem 12. The preference lists of the applicants are as follows:

i are corequisites. Also all the courses in Z
j) is as deﬁned in

j ), x(c3
j )

j ), x(c2
i , x1
i , ¯x1

P (aj) : x(c1
P (g1
i , y2
i ) : y1
P (g2
i , y2
i ) : y1
[X]
P (h) :
P (b) :
[X], [Z]

i , x2
i
i , ¯x2
i

(1 ≤ j ≤ m)
(1 ≤ i ≤ n)
(1 ≤ i ≤ n)

In the preference lists of h and b, the symbols [X] and [Z] denote all members of X and
Z listed in arbitrary strict order, respectively. In I the total capacity of the applicants,
denoted by N , satisﬁes N = D + 6n. We claim that if B has a satisfying truth assignment
then I has a POM of size D + 6n, whilst if B does not have a satisfying truth assignment
then any POM in I has size at most 6n.

i , ¯x1
i , x2

i , ¯x2
i , y1

i ), (g2
i ), (g2

i ), (g1
i ) to M . On the other hand if f (vi)=false then add the pairs (g1
i ), (g2

For, suppose that f is a satisfying truth assignment for B. We form a matching M in
I as follows. For each i (1 ≤ i ≤ n), if f (vi)=true then add the pairs (g1
i ),
(g2
i ),
(g1
i ) to M . For each j (1 ≤ j ≤ m), at least one literal in cj is true
under f . Let s be the minimum integer such that the literal at position s of cj is true
under f . Course x(cs
j )) to M . There
remain 2n − m courses in X that are as yet unmatched in M ; assign all these courses to
h. Finally assign all courses in Z to b in M . It may be veriﬁed that M is a POM of size
D + 6n in I.

j) is still unmatched by construction; add (aj, x(cs

i , y2
i , x1

i , y2

i , y1

Now suppose that f admits no satisfying truth assignment. Let M be any POM in
I. We will show that |M | ≤ 6n. Suppose not. Then |M | > 6n and the only way this
is possible is if at least one course in Z is matched in M . But only b can be assigned
members of Z in M , and since all pairs of courses in Z are corequisites, it follows that
M (b) = Z.

i , y2

We next show that, for each i (1 ≤ i ≤ n), either {(g1

i ),
i )} ⊆ M . Suppose this is not the case for some i (1 ≤ i ≤ n). As a consequence
i are unmatched in M . Let M ′
i (if such
i ) to M . Then M ′ dominates M , a

(g2
of the corequisite restrictions on courses in Y , y1
be the matching obtained from M by deleting any assignee of g1
an assignee exists) and by adding (g1
contradiction.

i )} ⊆ M or {(g2

i worse than y2

i ) and (g1

i and y2

i ), (g1

i , y1

i , y2

i , y1

i , y2

i , y1

We claim that each course in X is matched in M . For, suppose that some course x ∈ X
is unmatched. Then let M ′ be the matching obtained from M by unassigning b from all
courses in Z, and by assigning b to x. Then M ′ dominates M , a contradiction.

It follows that every course in X ∪ Y is matched in M . Since |X ∪ Y | = 6n and the
applicants in A ∪ G ∪ {h} have total capacity 6n, every applicant in A ∪ G ∪ {h} is full.
i ) ∈ M , set
f (vi)=true, otherwise set f (vi)=false. We claim that f is a satisfying truth assignment

Create a truth assignment f in B as follows. For each i (1 ≤ i ≤ n), if (g1

i , y1

19

j) = xr

for B. For, let j (1 ≤ j ≤ m) be given. Then (aj, x(cs
If x(cs
Similarly if x(cs
construction. Hence f satisﬁes B, a contradiction.

j )) ∈ M for some s (1 ≤ s ≤ 3).
i for some i (1 ≤ i ≤ n) and r (r ∈ {1, 2}) then f (vi)=true by construction.
i for some (1 ≤ i ≤ n) and r (r ∈ {1, 2}) then f (vi)=false by

j ) = ¯xr

Thus if B is satisﬁable then I admits a POM of size D +6n = 6n(α−1)+1+6n > 6nα.
If B is not satisﬁable then any POM in I has size at most 6n. Hence an α-approximation
algorithm for max pom cacr implies a polynomial-time algorithm to determine whether
B is satisﬁable, a contradiction to the NP-completeness of (2,2)-e3-sat.

It remains to show that N 1−ε ≤ α. On the one hand, N = 6n + D = 6nα + 1 ≤ 7nα =
β+1 . On the other hand, N = 6nα + 1 ≥ α = nβ ≥ 7β as we
β+1 . Thus

7nβ+1. Hence nβ ≥ N
may assume, without loss of generality, that n ≥ 7. It follows that 7− β

β+1 ≥ N − 1

β+1 7− β

β

α = nβ ≥ N

β

β+1 7− β

β+1 ≥ N

β

β+1 N − 1

β+1 = N

β−1

β+1 = N 1− 2

β+1 ≥ N 1−ε.

6 Open problems and directions for future research

We would like to conclude with several open problems and directions for future research.

1. Reﬁning the boundary between eﬃciently solvable and hard problems. In
the proofs of the NP-hardness and inapproximability results in this paper we had
some applicants whose preference lists were not complete and/or whose capacity was
not bounded by a constant. Will the hardness results still be valid if there are no
unacceptable courses and all capacities are bounded? These problems also call for a
more detailed multivariate complexity analysis. It might be interesting to determine
whether restricting some other parameters, e.g., the lengths of preference lists, may
make the problems tractable.

2. Indiﬀerences in the preference lists. In this paper, we assumed that all the
preferences are strict. If preference lists contain ties, sequential mechanisms have
to be carefully modiﬁed to ensure Pareto optimality. Polynomial-time algorithms
for ﬁnding a Pareto optimal matching in the presence of ties have been given in
the context of hat (the extension of ha where preference lists may include ties) by
Krysta et al. [25] and in its many-to-many generalisation cat (the extension of ca
where preference lists may include ties) by Cechl´arov´a et al. [11]. However as far as
we are aware, it remains open to extend these algorithms to the cases of capr and
cacr where preference lists may include ties.

3. Strategic issues. By a standard argument, one can ensure that the sequential
mechanism that lets each applicant on her turn choose her entire most-preferred
bundle of courses (i.e., the serial dictatorship mechanism) is strategy-proof even in
the case of prerequisites. However, serial dictatorship may be very unfair, as the ﬁrst
dictator may grab all the courses and leave nothing for the rest of the applicants.
Let us draw the reader’s attention to several economic papers that highlight the
special position of serial dictatorship among the mechanisms for allocation of mul-
tiple indivisible goods: serial dictatorship is the only allocation rule that is Pareto
eﬃcient, strategy-proof and fulﬁls some additional properties, namely non-bossiness
and citizen sovereignty [30], and population monotonicity or consistency [23]. We
were not able to obtain a similar characterization of serial dictatorship for capr.

As far as the general sequential mechanism is concerned, a recent result by Hosseini
and Larson [20] shows that no sequential mechanism that allows interleaving policies

20

(i.e., in which an ai is allowed to pick courses more than once, and between two turns
of ai another applicant has the right to pick a course) is strategy-proof, even in the
simpler case without any prerequisites. It immediately follows that SM-CAPR is not
strategy-proof. However, it is not known whether a successful manipulation can be
computed eﬃciently. Further, we have shown that in capr, not all POMs can be
obtained by a sequential mechanism. We leave it as an open question whether a
strategy-proof and Pareto optimal mechanism other than serial dictatorship exists
in capr.

References

[1] A. Abdulkadiroˇglu and T. S¨onmez. Random serial dictatorship and the core from
random endowments in house allocation problems. Econometrica, 66(3):689–701,
1998.

[2] D.J. Abraham, K. Cechl´arov´a, D.F. Manlove, and K. Mehlhorn. Pareto optimality
in house allocation problems. In Proceedings of ISAAC ’04: the 15th Annual Inter-
national Symposium on Algorithms and Computation, volume 3341 of Lecture Notes
in Computer Science, pages 3–15. Springer, 2004.

[3] H. Aziz, T. Walsh, and L. Xia. Possible and necessary allocations via sequential
mechanisms. In Proceedings of IJCAI 2015: the 24th International Joint Conference
on Artiﬁcial Intelligence, pages 468–474. AAAI Press, 2015.

[4] M. Balinski and T. S¨onmez. A tale of two mechanisms: student placement. Journal

of Economic Theory, 84(1):73–94, 1999.

[5] S. Barber`a, W. Bossert, and P.K. Pattanaik. Ranking sets of objects.

In S. Bar-
ber`a, P.J. Hammond, and C. Seidl, editors, Handbook of Utility Theory, volume 2,
chapter 17, pages 893–977. Kluwer Academic Publishers, 2004.

[6] P. Bir´o and E. McDermid. Matching with sizes (or scheduling with processing set

restrictions). Discrete Applied Mathematics, 164(1):61–67, 2014.

[7] C. Boutilier, B. Dorn, N. Maudet, and V. Merlin. Computational Social Choice:
Theory and Applications (Dagstuhl Seminar 15241). Dagstuhl Reports, 5(6):1–27,
2016.

[8] S. Bouveret and J. Lang. Elicitation-free protocol for allocating indivisible goods.
In Proceedings of IJCAI 2011: the 22nd International Joint Conference on Artiﬁcial
Intelligence, pages 73–78. AAAI Press, 2011.

[9] S.J. Brams and D.L. King. Eﬃcient fair division: Help the worst oﬀ or avoid envy?

Rationality and Society, 17(4):387–421, 2005.

[10] E. Budish and E. Cantillon. The multi-unit assignment problem: Theory and evidence
from course allocation at Harvard. American Economic Review, 102(5):2237–2271,
2012.

[11] K. Cechl´arov´a, P. Eirinakis, T. Fleiner, D. Magos, D.F. Manlove, I. Mourtos,
E. Ocel’´akov´a, and B. Rastegari. Pareto optimal matchings in many-to-many mar-
kets with ties. In Proceedings of SAGT 2015: the 8th International Symposium on
Algorithmic Game Theory, pages 27–39. Springer, 2015.

21

[12] K. Cechl´arov´a, P. Eirinakis, T. Fleiner, D. Magos, I. Mourtos, and E. Potpinkov´a.
Pareto optimality in many-to-many matching problems. Discrete Optimization,
14:160–169, 2014.

[13] B.A. Davey and H.A. Priestly. Introduction to lattices and order. Cambridge Univer-

sity Press, 1990.

[14] F. Diebold, H. Aziz, M. Bichler, F. Matthes, and A. Schneider. Course allocation via
stable matching. Business and Information Systems Engineering, 6(2):97–110, 2014.

[15] T. Dodson, N. Mattei, J.T. Guerin, and J. Goldsmith. An English-language argu-
mentation interface for explanation generation with Markov decision processes in the
domain of academic advising. ACM Transactions on Interactive Intelligent Systems,
3(3):18, 2013.

[16] P.C. Fishburn. Axioms for lexicographic preferences. Review of Economic Studies,

42(3):415–419, 1975.

[17] M.R. Garey and D.S. Johnson. Computers and Intractability. Freeman, San Francisco,

CA., 1979.

[18] M.R. Garey, D.S. Johnson, and L. Stockmeyer. Some simpliﬁed NP-complete graph

problems. Theoretical Computer Science, 1:237–267, 1976.

[19] J.T. Guerin, J. Hanna, L. Ferland, N. Mattei, and J. Goldsmith. The academic
advising planning domain. In Proceedings of WS-IPC-12: the 3rd Workshop on the
International Planning Competition, pages 1–5, 2012.

[20] H. Hosseini and K. Larson. Strategyproof quota mechanisms for multiple assignment
problems. Technical Report 1507.07064, Computing Research Repository, Cornell
University Library, 2015. Available from http://arxiv.org/abs/1507.07064.

[21] R.M. Karp. Reducibility among combinatorial problems. In R.E. Miller and J.W.
Thatcher, editors, Complexity of Computer Computations, pages 85–103. Plenum
Press, 1972.

[22] A.S. Kelso, Jr. and V.P. Crawford. Job matching, coalition formation and gross

substitutes. Econometrica, 50:1483–1504, 1982.

[23] B. Klaus and E. Miyagawa. Strategy-proofness, solidarity, and consistency for multi-
ple assignment problems. International Journal of Game Theory, 30:421–435, 2001.

[24] D.A. Kohler and R. Chandrasekaran. A class of sequential games. Operations Re-

search, 19(2):270–277, 1971.

[25] P. Krysta, D.F. Manlove, B. Rastegari, and J. Zhang. Size versus truthfulness in the
House Allocation problem. In Proceedings of EC 2014: the 15th ACM Conference on
Economics and Computation, pages 453–470. ACM, 2014.

[26] J. K. Lenstra and A.H.G. Rinnooy Kan. Complexity of scheduling under precedence

constraints. Operations Research, 26(1):22–35, 1978.

[27] D. Maier and J.A. Storer. A note on the complexity of the superstring problem.
Technical Report 233, Princeton University, Department of Electrical Engineering
and Computer Science, Princeton, NJ, October 1977.

22

[28] M. Manea. Serial dictatorship and Pareto optimality. Games and Economic Behavior,

61:316–330, 2007.

[29] D. Monte and N. Tumennasan. Matching with quorums. Economics Letters, 120:14–

17, 2013.

[30] S. P´apai. Strategyproof and nonbossy multiple assignments. Journal of Public Eco-

nomic Theory, 3(3):257–271, 2001.

[31] A.E. Roth. The college admissions problem is not equivalent to the marriage problem.

Journal of Economic Theory, 36:277–288, 1985.

[32] D. Saban and J. Sethuraman. A note on object allocation under lexicographic pref-

erences. Journal of Mathematical Economics, 50:283–289, 2014.

[33] L.J. Schulman and V.V. Vazirani. Allocation of divisible goods under lexicographic
preferences. Technical Report 1206.4366, Computing Research Repository, Cornell
University Library, 2012. Available from http://arxiv.org/abs/1206.4366.

[34] L.-G. Svensson. Queue allocation of indivisible goods. Social Choice and Welfare,

11(4):323–330, 1994.

[35] T. Todo, H. Sun, and M. Yokoo. Strategyproof exchange with multiple private en-
dowments. In Proceedings of AAAI 2014: the 28th AAAI Conference on Artiﬁcial
Intelligence, pages 805–811, 2014.

23

