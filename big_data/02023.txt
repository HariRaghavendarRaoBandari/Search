Supervisor Localization of Timed

Discrete-Event Systems under Partial

Observation and Communication Delay

Renyuan Zhang1 and Kai Cai2

Abstract

We study supervisor localization for timed discrete-event systems under partial observation and

communication delay in the Brandin-Wonham framework. First, we employ timed relative observability

to synthesize a partial-observation monolithic supervisor; the control actions of this supervisor include

not only disabling action of prohibitible events (as that of controllable events in the untimed case) but

also “clock-preempting” action of forcible events. Accordingly we decompose the supervisor into a set of

partial-observation local controllers one for each prohibitible event, as well as a set of partial-observation

local preemptors one for each forcible event. We prove that these local controllers and preemptors

collectively achieve the same controlled behavior as the partial-observation monolithic supervisor does.

Moreover, we propose channel models for inter-agent event communication and impose bounded and

unbounded delay as temporal speciﬁcations. In this formulation, there exist multiple distinct observable

event sets; thus we employ timed relative coobservability to synthesize partial-observation decentralized

supervisors, and then localize these supervisors into local controllers and preemptors. The above results

are illustrated by a timed workcell example.

Timed Discrete-Event Systems; Supervisor Localization; Partial Observation, Communication Delay.

Keywords

6
1
0
2

 
r
a

 

M
5
2

 
 
]

Y
S
.
s
c
[
 
 

2
v
3
2
0
2
0

.

3
0
6
1
:
v
i
X
r
a

I.

INTRODUCTION

In [1], [2] we developed a top-down approach, called supervisor localization, to the distributed control

synthesis of multi-agent discrete-event systems (DES). The essence of localization is the decomposition

1R. Zhang is with School of Automation, Northwestern Polytechnical University, China ryzhang@nwpu.edu.cn
2K. Cai is with Urban Research Plaza, Osaka City University, Japan kai.cai@eng.osaka-cu.ac.jp

of the monolithic (optimal and nonblocking) supervisor into local controllers for the individual agents. In

[3] we extended supervisor localization to timed DES (TDES) in the Brandin-Wonham framework [4];

in addition to local controllers (corresponding to disabling actions), a set of local preemptors is obtained

corresponding to clock-preempting actions. More recently in [5], we extended the untimed supervisor

localization to the case of partial observation. In particular, we combined localization with relative

observability [6] to ﬁrst synthesize a partial-observation monolithic supervisor, and then decompose the

supervisor into local controllers whose state changes are caused only by observable events.

In this paper, we further study supervisor localization for TDES under partial observation in the

Brandin-Wonham framework, thereby extending both [3] and [5]. We propose to ﬁrst synthesize a partial-

observation monolithic supervisor using the concept of timed relative observability [7]. Timed relative

observability is proved to be generally stronger than timed observability [8], weaker than normality [8],

and closed under set union. Therefore the supremal relatively observable (and controllable) sublanguage

of a given language exists and may be effectively computed [7]. Since this supremal sublanguage is

observable and controllable, it may be implemented by a partial-observation (feasible and nonblocking)

supervisor [8]. We then suitably extend the localization procedure in [3] to decompose the supervisor

into partial-observation local controllers and local preemptors for individual agents, and prove that the

derived local controlled behavior is equivalent to the monolithic one.

Moreover, we address the issue of communication delay. First, we introduce two types of channel

models for inter-agent event communication. The introduced models are treated as plant components,

and the requirements of bounded and unbounded delay are treated as temporal speciﬁcations imposed

on the plant. In this formulation, there are multiple distinct observable event sets. This is because the

occurrence of a communication event and sending that event are observable only to the sender, but not

observable to the receiver; on the other hand, the receiving of a communication event is observable only to

the receiver, but not observable to the sender. To deal with multiple observable event sets, we propose to

employ the concept of relative coobservability [7], which is closed under set union, to ﬁrst synthesize a set

of partial-observation decentralized supervisors, and then decompose these decentralized supervisors into

the respective local controllers/preemptors. Finally, we prove that the derived local controlled behavior

is identical to that achieved by the partial-observation decentralized supervisors.

The contributions of this paper are threefold. First, the proposed timed supervisor localization under

partial observation extends the untimed counterpart in [5]: not only is the monolithic supervisor’s disabling

action localized (as in the untimed case), but also its preemptive action is localized with respect to individ-

ual forcible events. Second, the proposed partial-observation supervisor localization of TDES also extends

2

the full-observation counterpart in [3]. Speciﬁcally, the new concepts of partial-observation control cover

and partial-observation preemption cover are deﬁned on the state set of the partial-observation supervisor;

roughly speaking, the latter corresponds to the powerset of the full-observation supervisor’s state set. In

this way, in the transition structure of the resulting local controllers/preemptors, only observable events can

lead to state changes. Third, in addition to partial observation, timed supervisor localization is extended

to address communication delay. A novel approach employing relative coobservability [7] is proposed,

which synthesizes partial-observation local controllers/preemptors tolerant of bounded and unbounded

delay of event communicaiton.

We note that distributed/decentralized supervisory control with communication delay has been exten-

sively studied (e.g. [9]–[13]). There are two approaches mostly related to our work. The ﬁrst is a veriﬁ-

cation approach, e.g. [9], [10], which ﬁrst synthesizes delay-free distributed controllers, and then veriﬁes

whether the distributed controllers tolerate speciﬁed communication delay. This approach is limited to

verifying the robustness of derived controllers, but does not supply a procedure to construct controllers

that are able to tolerate speciﬁed communication delay. The second approach is that of synthesis, e.g.

[11]–[13], which ﬁrst incorporates communication delay into the plant and speciﬁcation models, and then

applies decentralized control methods to synthesize distributed controllers that tolerate the communication

delay. In these works, observability, coobervability, delay-coobervability [12], or network observability

[13] are necessary for the existence of ditribtued controllers. However, these observability properties are

not closed under set union, and thus there generally does not exist the respective supremal sublanguage of

a given language. By contrast, we employ the recently proposed relative coobervability, which is closed

under set union and the supremal relatively coobservable sublanguage is effectively computable [7].

The paper is organized as follows. Section II reviews the preliminaries on the Brandin-Wonham

TDES framework. Section III formulates the partial-observation supervisor localization problem of TDES,

and Section IV develops the solution localization procedure. Section V investigates partial-observation

supervisor localization with communication delay by using the concept of relative coobervability. Finally

Section VI states our conclusions.

II. PRELIMINARIES

This section reviews supervisory control of TDES in the Brandin-Wonham framework [4], [14, Chap-

ter 9]. First consider the untimed DES model Gact = (A, Σact, δact, a0, Am); here A is the ﬁnite set of
activities, Σact the ﬁnite set of events, δact : A × Σact → A the (partial) transition function, a0 ∈ A
the initial activity, and Am ⊆ A the set of marker activities. Let N denote the set of natural numbers

3

{0, 1, 2, ...}, and introduce time into Gact by assigning to each event σ ∈ Σact a lower bound lσ ∈ N

and an upper bound uσ ∈ N ∪ {∞}, such that lσ ≤ uσ. Also introduce a distinguished event, written

tick, to represent “tick of the global clock”. Then a TDES model

G := (Q, Σ, δ, q0, Qm),

(1)

is constructed from Gact (refer to [4], [14, Chapter 9] for detailed construction) such that Q is the ﬁnite

set of states, Σ := Σact ˙∪{tick} the ﬁnite set of events, δ : Q × Σ → Q the (partial) state transition

function, q0 the initial state, and Qm the set of marker states.

Let Σ∗ be the set of all ﬁnite strings of elements in Σ = Σact ˙∪{tick}, including the empty string ǫ.
The transition function δ is extended to δ : Q × Σ∗ → Q in the usual way. The closed behavior of G is

the language L(G) := {s ∈ Σ∗|δ(q0, s)!} and the marked behavior is Lm(G) := {s ∈ L(G)|δ(q0, s) ∈
Qm} ⊆ L(G). Let K ⊆ Σ∗ be a language; its preﬁx closure is K := {s ∈ Σ∗|(∃t ∈ Σ∗) st ∈ K}. K is

said to be Lm(G)-closed if K ∩ L(G) = Lm(G). TDES G is nonblocking if Lm(G) = L(G).

To use TDES G in (1) for supervisory control, ﬁrst designate a subset of events, denoted by Σhib ⊆
Σact, to be the prohibitible events which can be disabled by an external supervisor. Next, and speciﬁc to

TDES, specify a subset of forcible events, denoted by Σf or ⊆ Σact, which can preempt the occurrence
of event tick. Now it is convenient to deﬁne the controllable event set Σc := Σhib
˙∪ {tick}. The
uncontrollable event set is Σuc := Σ \ Σc. A sublanguage K ⊆ Lm(G) is controllable if, for all s ∈ K,

EligK (s) ⊇

EligG(s) ∩ (Σuc ˙∪{tick})

if EligK (s) ∩ Σf or = ∅,

EligG(s) ∩ Σuc

if EligK (s) ∩ Σf or 6= ∅,




where EligK (s) := {σ ∈ Σ|sσ ∈ K} is the subset of eligible events after string s.

For partial observation, Σ is partitioned into Σo, the subset of observable events, and Σuo, the subset

of unobservable events (i.e. Σ = Σo ˙∪Σuo). Bring in the natural projection P : Σ∗ → Σ∗

o deﬁned by

P (ǫ) = ǫ;

P (σ) = 


ǫ,

σ,

if σ /∈ Σo,

if σ ∈ Σo;

(2)

P (sσ) = P (s)P (σ), s ∈ Σ∗, σ ∈ Σ.

As usual, P is extended to P : P wr(Σ∗) → P wr(Σ∗

o), where P wr(·) denotes powerset. Write P −1 :
o) → P wr(Σ∗) for the inverse-image function of P . A language K ⊆ Lm(G) is observable if

P wr(Σ∗

4

for every pair of strings s, s′ ∈ Σ∗ with P (s) = P (s′) there holds

(∀σ ∈ Σ)sσ ∈ K, s′ ∈ K, s′σ ∈ L(G) ⇒ s′σ ∈ K.

A supervisor V under partial observation is any map V : P (L(G)) → P wr(Σ). Then the closed-loop

system is V /G with closed behavior L(V /G) and marked behavior Lm(V /G) (:= L(V /G) ∩ Lm(G))

[8]. A supervisor V is nonblocking if Lm(V /G) = L(V /G), and admissible if for each s ∈ L(V /G),

(i) Σuc ⊆ V (P (s)) and

(ii)EligG(s) ∩ V (P (s)) ∩ Σf or = ∅, tick ∈ EligG(s)

⇒ tick ∈ V (P (s)).

It has been proved [8] that a nonblocking, admissible supervisory control V exists which synthesizes

a (nonempty) sublanguage K ⊆ Lm(G) such that Lm(V /G) = K if and only if K is observable,

controllable and Lm(G)-closed. While controllability and Lm(G)-closedness are properties closed under

set union, observability is not; consequently when K is not observable, there generally does not exist

the supremal observable (controllable and Lm(G)-closed) sublanguage of K.

Recently in [7], we proposed a new concept of relative observability, which is stronger than observ-

ability, but permits the existence of the supremal relatively observable sublanguage. Let C ⊆ Lm(G). A
language K ⊆ C is relatively observable (or C-observable), if for every pair of strings s, s′ ∈ Σ∗ with

P (s) = P (s′) there holds

(∀σ ∈ Σ)sσ ∈ K, s′ ∈ C, s′σ ∈ L(G) ⇒ s′σ ∈ K.

(3)

For an arbitrary sublanguage E ⊆ Lm(G), write CO(E) for the family of C-observable, controllable

and Lm(G)-closed sublanguages of E. Then CO(E) is nonempty (the empty language ∅ belongs) and

is closed under set union; CO(K) has a unique supremal element sup CO(E) given by

sup CO(E) = [{K|K ∈ CO(E)}

which may be effectively computed [6], [7]. Note that since relative observability is stronger than

observability, sup CO(E) is observable (controllable and Lm(G)-closed).

III. FORMULATION OF PARTIAL-OBSERVATION SUPERVISOR LOCALIZATION PROBLEM

Let the plant G be comprised of N component TDES

Gk = (Qk, Σk, δk, q0,k, Qm,k),

k = 1, ..., N.

(4)

5

Then G = Comp(G1, ..., GN ), where Comp is the composition operator deﬁned in [14, Chapter 9]
which is used to build complex TDES from simpler ones. Note that Σk need not be pairwise disjoint.

These agents are implicitly coupled through a speciﬁcation language E ⊆ Σ∗ that imposes a constraint

on the global behavior of G (E may itself be the composition of multiple component speciﬁcations). For

the plant G and the imposed speciﬁcation E, let the generator SUP = (X, Σ, ξ, x0, Xm) be such that

Lm(SUP) := sup CO(E ∩ Lm(G)).

(5)

We call SUP the controllable and observable controlled behavior. Note that SUP is not a partial-

observation supervisor (to be deﬁned in the next section), which can only contain observable events as

state changers. To rule out the trivial case, we assume that Lm(SUP) 6= ∅.

The control actions of SUP include (i) disabling prohibitible events in Σhib and (ii) preempting event
tick via forcible events in Σf or. Accordingly, the localization of SUP’s control actions under partial-
observation is with respect to not only each prohibitible event’s disabling action (just as the untimed

counterpart in [5]), but also each forcible event’s preemptive action. The latter is speciﬁc to TDES, for

which we introduce below the new concept of “partial-observation local preemptor”.

Let α ∈ Σf or be an arbitrary forcible event, which may or may not be observable. We say that a

generator

LOCP

α = (Yα, Σα, ηα, y0,α, Ym,α), Σα ⊆ Σo ∪ {α, tick}

is a partial-observation local preemptor for α if (i) LOCP

and (ii) if σ ∈ {α, tick} is unobservable, then σ-transitions are selﬂoops in LOCP

α preempts event tick consistently with SUP,
α , i.e. for all y ∈ Yα,

σ ∈ Σuo implies ηα(y, σ) = y.

First, condition (i) means that for all s ∈ Σ∗ if sα ∈ L(SUP), there holds

Pα(s).tick ∈ L(LOCP

α ), s.tick ∈ L(G) ⇔ s.tick ∈ L(SUP)

(6)

where Pα : Σ∗ → Σ∗

α is the natural projection. Notation s.tick means that event tick occurs after string
s and will be used henceforth. Note that speciﬁc to TDES, only when sα ∈ L(SUP) can tick-occurrence

after s be preempted by α in LOCP

α . Second, condition (ii) requires that only observable events may

cause state change in LOCP

α , i.e.

(∀y, y′ ∈ Yα, ∀σ ∈ Σα) y′ = ηα(y, σ)!, y 6= y′ ⇒ σ ∈ Σo.

(7)

Note that the event set Σα of LOCP

α in general satisﬁes

{α, tick} ⊆ Σα ⊆ Σo ∪ {α, tick};

6

in typical cases, both subset containments are strict. In fact, the events in Σα \ {α, tick} are com-

munication events that may be critical to achieve synchronization with other partial-observation local

preemptors/controllers. The Σα is not ﬁxed a priori, but will be determined as part of the localization

result presented in the next section.

Next, let β ∈ Σhib be an arbitrary prohibitible event, which may or may not be observable. A generator

LOCC

β = (Yβ, Σβ, ηβ, y0,β, Ym,β), Σβ ⊆ Σo ∪ {β}

is a partial-observation local controller for β if (i) LOCC

consistently with SUP, and (ii) if β is unobservable, then β-transitions are selﬂoops in LOCC

β enables/disables the event β (and only β)
β . The event
β in general satisﬁes {β} ⊆ Σβ ⊆ Σo ∪ {β}; in typical cases, both subset containments

set Σβ of LOCC
are strict. Like Σα above, Σβ will be generated as part of our localization result.

We are now ready to formulate the Partial-Observation Supervisor Localization Problem:

Construct a set of partial-observation local preemptors {LOCP

α |α ∈ Σf or} and a set of partial-

observation local controllers {LOCC

β | β ∈ Σhib} with

L(LOC) :=(cid:16) \

α∈Σf or

P −1
α L(LOCP

α )(cid:17)

∩(cid:16) \

β∈Σhib

P −1
β L(LOCC

β )(cid:17)

Lm(LOC) :=(cid:16) \

α∈Σf or

P −1
α Lm(LOCP

α )(cid:17)

∩(cid:16) \

β∈Σhib

P −1
β Lm(LOCC

β )(cid:17)

(8)

(9)

such that the collective controlled behavior of LOC is equivalent to the controllable and observable

controlled behavior SUP in (5) with respect to G, i.e.

L(G) ∩ L(LOC) = L(SUP),

Lm(G) ∩ Lm(LOC) = Lm(SUP).

Having a set of partial-observation local preemptors, one for each forcible event, and a set of partial-

observation local controllers, one for each prohitible event, we can allocate each preemptor/controller to

the agent(s) owning the corresponding forcible/prohitible event. Thereby we build for a multi-agent DES

a nonblocking distributed control architecture under partial observation.

7

IV. PARTIAL-OBSERVATION LOCALIZATION PROCEDURE

We solve the Partial-Observation Supervisor Localization Problem of TDES by developing a partial-

observation localization procedure for the preemptive and disabling action, respectively. The procedure

extends the untimed counterpart in [5]. In particular, localizing the preemption of event tick with respect

to each forcible event under partial observation is novel in the current TDES setup, for which we introduce

below the concept of “partial-observation preemption cover”.

Σ∗ → Σ∗

Let G = (Q, Σ, δ, q0, Qm) be the TDES plant, Σo ⊆ Σ the subset of observable events, and P :
o the corresponding natural projection. Also let SUP = (X, Σ, ξ, x0, Xm) be controllable and
observable controlled behavior (as deﬁned in (5)). We present the localization of preemptive and disabling

action in the sequel. To this end, we need the concept of uncertainty set.

For s ∈ L(SUP), let U (s) be the subset of states of SUP that may be reached by some string s′ that

looks like s, i.e.

U (s) = {x ∈ X|(∃s′ ∈ Σ∗)P (s) = P (s′), x = ξ(x0, s′)}.

We call U (s) the uncertainty set [5] of the state ξ(x0, s) associated with string s. Let U (X) := {U (s) ⊆
X|s ∈ L(SUP)}, i.e. U (X) is the set of uncertainty sets of all states (associated with strings in L(SUP))

in X. The size of U (X) is in general |U (X)| ≤ 2|X|.

The transition function associated with U (X) is ˆξ : U (X) × Σo → U (X) given by

ˆξ(U, σ) = [{ξ(x, u1σu2)|x ∈ U, u1, u2 ∈ Σ∗
With U (X) and ˆξ, deﬁne the partial-observation monolithic supervisor

uo}.

SUPO = (U (X), Σo, ˆξ, U0, Um),

(10)

where U0 = U (ǫ) and Um = {U ∈ U (X)|U ∩Xm 6= ∅}. It is known [14] that L(SUPO) = P (L(SUP))
and Lm(SUPO) = P (Lm(SUP)).

Now let x ∈ X be any state and σ ∈ Σc (= Σhib ˙∪{tick}) be a controllable event. We say that (1) σ

is enabled at x if ξ(x, σ)!; (2) σ (6= tick) is disabled at x if ¬ξ(x, σ)! and

(3) σ (= tick) is preempted at x if ¬ξ(x, tick)! and

(∃s ∈ Σ∗)ξ(x0, s) = x & δ(q0, sσ)!;

(∃s ∈ Σ∗)(∃σf ∈ Σf or)ξ(x0, s) = x & ξ(x, σf )! & δ(q0, s.tick)!;

(4) σ is not deﬁned at x if ¬ξ(x, σ)! and

(∀s ∈ Σ∗)ξ(x0, s) = x ⇒ ¬δ(q0, sσ)!.

8

Lemma 1. Given the controllable and observable controlled behavior SUP in (5), let U ∈ U (X),

x ∈ U, and σ ∈ Σc. If σ is enabled at x, then for all x′ ∈ U, either σ is also enabled at x′, or σ is not
deﬁned in G. On the other hand, if σ is disabled (resp. preempted) at x, then for all x′ ∈ U, either σ is

also disabled (resp. preempted) at x′, or σ is not deﬁned in G.

The proof is similar to that of Lemma 1 in [5].

A. Partial-Observation Localization of Preemptive Action

Under partial observation, the preemptive action after string s ∈ L(SUP) depends not on the single

state ξ(x0, s), but on the uncertainty set U (s), namely a state of SUPO.

Fix an arbitrary forcible event α ∈ Σf or. First deﬁne Etick : U (X) → {0, 1} according to

(∀U ∈ U (X)) Etick(U ) = 


1,

if (∃x ∈ U )ξ(x, tick)!,

0, otherwise.

Thus Etick(U ) = 1 means that tick is enabled at some state x ∈ U. Then by Lemma 1, at any other
state x′ ∈ U, tick is either enabled or not deﬁned. Then deﬁne Fα : U (X) → {0, 1} according to

(∀U ∈ U (X))

Fα(U ) =




1,

if (∃x ∈ U ) ξ(x, α)! & ¬ξ(x, tick)! &

((∃s ∈ Σ∗)ξ(x0, s) = x & δ(q0, s.tick)!),

0, otherwise.

Hence Fα(U ) = 1 if tick is preempted at some state x ∈ U, i.e. forcible event α is deﬁned at state x,
which effectively preempts the occurrence of event tick. Again by Lemma 1, at any other state x′ ∈ U,

tick is either preempted or not deﬁned. Note that at state x, α need not be the only forcible event that

preempts tick, for there can be other forcible events, say α′, deﬁned at x. In that case, Fα′(U ) = 1 holds

as well.

Based on the preemption information captured by Etick and Fα above, we deﬁne the preemption

consistency relation RP

α ⊆ U (X) × U (X) (for α) as follows.

Deﬁnition 1. For U, U ′ ∈ U (X), we say that U and U ′ are preemption consistent with respect to α,

written (U, U ′) ∈ RP

α , if Etick(U ) · Fα(U ′) = 0 = Etick(U ′) · Fα(U ).

Thus a pair of uncertainty sets (U, U ′) satisﬁes (U, U ′) ∈ RP

but not preempted by α at any state of U ′, and vice versa. It is easily veriﬁed that RP

α if tick is deﬁned at some state of U,
α is reﬂexive and

9

symmetric, but not transitive. Hence RP

α is not an equivalence relation. This fact leads to the deﬁnition

of a partial-observation preemption cover.

Deﬁnition 2. Let Iα be some index set, and CP
that CP

α is a partial-observation preemption cover with respect to α if

α = {Ui ⊆ U (X)|i ∈ Iα} be a cover on U (X). We say

(i) (∀i ∈ Iα, ∀U, U ′ ∈ Ui) (U, U ′) ∈ RP
α ,

(ii) (∀i ∈ Iα, ∀σ ∈ Σo)(∃U ∈ Ui)ˆξ(U, σ) 6= ∅ ⇒

(cid:0)(∃j ∈ Iα)(∀U ′ ∈ Ui)ˆξ(U ′, σ) 6= ∅ ⇒ ˆξ(U ′, σ) ∈ Uj(cid:1).

overlapping) cells Ui ∈ CP

A partial-observation preemption cover CP

α lumps the uncertainty sets U ∈ U (X) into (possibly
α , i ∈ Iα, according to (i) the uncertainty sets U that reside in the same cell Ui
must be pairwise preemption consistent, and (ii) for every observable event σ ∈ Σo, the uncertainty sets
U ′ that can be reached from any uncertainty set U ∈ Ui by a one-step transition σ must be covered by
the same cell Uj. Inductively, two uncertainty sets U and U ′ belong to a common cell of CP
α if and only
if U and U ′ are preemption consistent, and two future uncertainty sets that can be reached respectively

from U and U ′ by a given observable string are again preemption consistent.

two aspects. First, CP

The partial-observation preemption cover CP

α differs from its full-observation counterpart in [3] in
α is deﬁned on U (X), not on X; this is due to state uncertainty caused by partial
α only observable events in Σo are considered, not Σ; this is
to generate partial-observation local preemptors whose state transitions are triggered only by observable

observation. Second, in condition (ii) of CP

events. We call CP

α a partial-observation preemption congruence if CP

Having deﬁned a partial-observation preemption cover CP

α happens to be a partition on U (X).
α on U (X), we construct a generator Jα =

(Iα, Σo, ζα, i0,α, Im,α) and two functions ψα : Iα → {0, 1} and ψtick : Iα → {0, 1} as follows:

(i) i0,α ∈ Iα such that (∃U ∈ Ui0,α )x0 ∈ U ;

(ii) Im,α := {i ∈ Iα|(∃U ∈ Ui)Xm ∩ U 6= ∅};

(iii) ζα : Iα × Σo → Iα with ζα(i, σ) = j

if (∃U ∈ Ui) ˆξ(U, σ) ∈ Uj;

(iv) ψα(i) = 1 iff (∃U ∈ Ui)(∃x ∈ U ) ξ(x, α)!.

(v) ψtick(i) = 1 iff (∃U ∈ Ui) Etick(U ) = 1.

10

(11)

(12)

(13)

(14)

(15)

The function ψα(i) = 1 means that forcible event α is deﬁned at state i of Jα, and the function

ψtick(i) = 1 means that event tick is enabled at state i of Jα. Note that owing to cell overlapping, the
choices of i0,α and ζα may not be unique, and consequently Jα may not be unique. In that case we
simply pick an arbitrary instance of Jα.

Finally we deﬁne the partial-observation local preemptor LOCP

α = (Yα, Σα, ηα, y0,α, Ym,α) as follows:
Step (i) Yα = Iα, y0,α = i0,α, and Ym,α = Im,α. Thus the function ψα is ψα : Yα → {0, 1}, and the
function ψtick is ψtick : Yα → {0, 1}.
Step (ii) Σα = {α, tick} ∪ Σcom,α, where

Σcom,α := {σ ∈ Σo \ {α, tick} | (∃i, j ∈ Iα) i 6= j &

ζα(i, σ) = j}

(16)

Thus Σcom,α is the set of observable events that are not merely selﬂoops in Jα. It holds by deﬁnition

that {α, tick} ⊆ Σα ⊆ Σo ∪ {α, tick}, and Σcom,α contains the events of other local controllers that need

to be communicated to LOCα.

Step (iii) If α ∈ Σo, then ηα = ζα|Yα×Σα : Yα × Σα → Yα, i.e. ηα is the restriction of ζα to Yα × Σα. If
α ∈ Σuo, ﬁrst obtain ηα = ζα|Yα×Σα, then add α-selﬂoops ηα(y, α) = y to those y ∈ Yα with ψα(y) = 1.
Step (iv) If tick ∈ Σuo, then add tick-selﬂoops ηα(y, tick) = y to those y ∈ Yα with ψtick(y) = 1.

Lemma 2. The generator LOCP

α is a partial-observation local preemptor for α, i.e. (6) and (7) hold.

We postpone the proof of Lemma 2 after our main result, Theorem 1, in subsection IV-C.

By the same procedure, we generate a set of partial-observation local preemptors LOCP

α , one for each
forcible event α ∈ Σf or. We will verify below that these generated preemptors collectively achieve the
same tick-preemptive action as SUP did.

B. Partial-Observation Localization of Disabling Action

Next, we turn to the localization of disabling action, which is analogous to the treatment in [5] for the

untimed case. Fix an arbitrary prohibitible event β ∈ Σhib. Deﬁne Eβ : U (X) → {0, 1} according to

(∀U ∈ U (X)) Eβ(U ) iff (∃x ∈ U )ξ(x, β)!.

11

So Eβ(U ) = 1 if event α is enabled at some state x ∈ U. Also deﬁne Dβ : U (X) → {0, 1} according to

(∀U ∈ U (X))

Dβ(U ) =




1,

if (∃x ∈ U )¬ξ(x, β)! &

((∃s ∈ Σ∗)ξ(x0, s) = x & δ(q0, sβ)!),

0, otherwise.

Hence Dβ(U ) = 1 if β is disabled at some state x ∈ U. Now deﬁne M : U (X) → {0, 1} by M (U ) = 1
iff there exists x ∈ U such that x ∈ Xm; and T : U (X) → {0, 1} by T (U ) = 1 iff there exists s ∈ Σ∗

such that ξ(x0, s) ∈ U and δ(q0, s) ∈ Qm.

We deﬁne the control consistency relation RC

β ⊆ U (X) × U (X) with respect to β according to

(U, U ′) ∈ RC

β iff

Eβ(U ) · Dβ(U ′) = 0 = Eβ(U ′) · Dβ(U )

T (U ) = T (U ′) ⇒ M (U ) = M (U ′).

Let Iβ be some index set, and CC
partial-observation control cover with respect to β if

β = {Ui ⊆ U (X)|i ∈ Iβ} a cover on U (X). We say that CC

β is a

(i) (∀i ∈ Iβ, ∀U, U ′ ∈ Ui) (U, U ′) ∈ RC
β ,

(ii) (∀i ∈ Iβ, ∀σ ∈ Σo)(∃U ∈ Ui)ˆξ(U, σ) 6= ∅ ⇒

With the control cover CC

a partial-observation local controller LOCC

(cid:0)(∃j ∈ Iβ)(∀U ′ ∈ Ui)ˆξ(U ′, σ) 6= ∅ ⇒ ˆξ(U ′, σ) ∈ Uj(cid:1).
β on U (X), we construct, by the Steps (i)-(iii) above for a local preemptor,
β = (Yβ, Σβ, ηβ, y0,β, Ym,β) for prohibitible event β. Here,

the event set Σβ is Σβ = {β} ∪ Σcom,β, where

Σcom,β := {σ ∈ Σo \ {β} | (∃i, j ∈ Iβ)i 6= j, ζα(i, σ) = j}.

(17)

Lemma 3. The generator LOCC

β is a partial-observation local controller for prohitibile event β.

For a proof of Lemma 3, see [5, Lemma 2].

By the same procedure, we generate a set of partial-observation local controllers LOCC

β , one for each
prohitibile event β ∈ Σhib. We will verify below that these generated controllers collectively achieve the
same disabling action as SUP did.

12

C. Main Result

Here is the main result of this section, which states that the collective behavior of the partial-observation

local preemptors and local controllers generated by the localization procedure above is identical to the

monolithic controllable and observable SUP.

Theorem 1. The set of partial-observation local preemptors {LOCP

α |α ∈ Σhib} and the set of partial-
α |β ∈ Σhib} constructed above solve the Partial-Observation Super-

observation local controllers {LOCC

visor Localization Problem, i.e.

L(G) ∩ L(LOC) = L(SUP)

Lm(G) ∩ Lm(LOC) = Lm(SUP)

(18)

(19)

where L(LOC) and Lm(LOC) are as deﬁned in (8) and (9), respectively.

Since for every partial-observation preemption cover (resp. control cover), the presented procedure

constructs a local preemptor (resp. local controller), Theorem 1 asserts that every set of preemption and

control covers together generates a solution to the Partial-Observation Supervisor Localization Problem.

The localization algorithm in [5] for untimed DES can easily be adapted in the current TDES case,

the only modiﬁcation being to use the new deﬁnitions of partial-observation preemption and control

consistency given in Sections IV-A and IV-B. The complexity of the localization algorithm is O(n4);

since the size n of U (X) is n ≤ 2|X| in general, the algorithm is exponential in |X|.

Proof of Theorem 1: First, we prove (⊆) of (18), i.e. L(G) ∩ L(LOC) ⊆ L(SUP), by induction on the

length of strings.

For the base step, note that none of L(G), L(LOC) and L(SUP) is empty; and thus the empty

string ǫ belongs to all of them. For the inductive step, suppose that s ∈ L(G) ∩ L(LOC), s ∈ L(SUP)

and sσ ∈ L(G) ∩ L(LOC) for arbitrary event σ ∈ Σ; we must show that sσ ∈ L(SUP). Since

Σ = Σuc ˙∪Σhib ˙∪{tick}, we consider the following three cases.

(1) σ ∈ Σuc. Since L(SUP) is controllable, and sσ ∈ L(G) (i.e. σ ∈ EligG(s)), we have σ ∈

EligLm(SUP)(s). That is, sσ ∈ Lm(SUP) = L(SUP).

(2) σ = tick. By the hypothesis that s, s.tick ∈ L(LOC), for every forcible event α ∈ Σf or, s, s.tick ∈
P −1
α L(LOCP
α ). Let y = ηα(y0,α, Pα(s)); then ηα(y, tick)!. Since
tick may be observable or unobservable, we consider the following two cases.

α ), i.e. Pα(s), Pα(s).tick ∈ L(LOCP

(2.1) tick ∈ Σuo. It follows from the construction rule (iv) of LOCP

α that ηα(y, tick) implies that for the
state i ∈ I of the generator Jα corresponding to y (i.e. i = ζα(i0, P (s))), there holds ψtick(i) = 1. By the

13

deﬁnition of ψtick in (15), there exists an uncertainty set U ∈ Ui such that Etick(U ) = 1. Let ξ(x0, s) ∈ U ′;
then U ′ ∈ Ui. Since U and U ′ belong to the same cell Ui, by the deﬁnition of partial-observation
α . Thus Etick(U ) · Fα(U ′) = 0,
preemption cover they must be preemption consistent, i.e. (U, U ′) ∈ RP
which implies that Fα(U ′) = 0. The latter means that for all state x ∈ U ′, (i) ¬ξ(x, α)!, (ii) ξ(x, tick)!,
or (iii) (¬∃s ∈ Σ∗) (ξ(x0, s) = x and δ(q0, s.tick)!). First, Case (iii) is impossible for ξ(x0, s), because
by hypothesis that s ∈ L(SUP) and s.tick ∈ L(G), we have ξ(x0, s)! and δ(q0, s.tick)!. Next, Case
(ii) means directly that s.tick ∈ L(SUP). Finally, Case (i) implies that α /∈ EligLm(SUP)(s); note that
this holds for all β ∈ Σf or. Hence EligLm(SUP)(s) ∩ Σf or = ∅. Then by the fact that Lm(SUP) is
controllable and s.tick ∈ L(G), tick ∈ EligLm(SUP)(s), i.e. s.tick ∈ L(SUP).

(2.2) tick ∈ Σo. In this case, for the state i ∈ I of the generator Jα corresponding to y (i.e. i =

ζα(i0, P (s))), there holds ζα(i, tick)!. By the deﬁnition of ζα in (13), there exists an uncertainty set
U ∈ Ui such that ˆξ(U, tick)!. So Etick(U ) = 1. The rest of the proof is identical to Case (2.1) above,
and we conclude that s.tick ∈ L(SUP) as well.

sσ ∈ L(LOC) that sσ ∈ P −1

σ L(LOCC

σ ). So Pσ(sσ) ∈ L(LOCC

(3) σ ∈ Σhib. There must exist a partial-observation local controller LOCC

σ for σ. It follows from
σ ) and
σ ), namely, ησ(y0, Pσ(sσ))! and ησ(y0, Pσ(s))!. Let y := ησ(y0, Pσ(s)); then ησ(y, σ)!

σ L(LOCσ)C and s ∈ P −1

Pσ(s) ∈ L(LOCC

(because σ ∈ Σσ). Since σ may be observable or unobservable, we consider the following two cases.

(3.1) σ ∈ Σuo. It follows from the construction rules of LOCσ that ησ(y, σ)! implies that for the
state i ∈ I of the generator Jσ corresponding to y (i.e. i = ζσ(i0, P (s))), there holds ψσ(i) = 1. By the
deﬁnition of ψσ in (14), there exists an uncertainty set U ∈ Ui such that Eα(U ) = 1. Let ξ(x0, s) ∈ U ′;
then U ′ ∈ Ui. Since U and U ′ belong to the same cell Ui, by the deﬁnition of partial-observation control
σ . Thus Eσ(U ) · Dσ(U ′) = 0, which implies
cover they must be control consistent, i.e. (U, U ′) ∈ RC
Dσ(U ′) = 0. The latter means that for all states x ∈ U ′, either (i) ξ(x, σ)! or (ii) for all t ∈ Σ∗ with
ξ(x0, t) = x, δ(q0, tσ) is not deﬁned. Note that (ii) is impossible for ξ(x0, s) ∈ U ′, because sσ ∈ L(G).
Thus by (i), ξ(ξ(x0, s), σ)!, and therefore sσ ∈ L(SUP).

Case (3.2) σ ∈ Σo. In this case, for the state i ∈ I of the generator Jσ corresponding to y (i.e.

i = ζσ(i0, P (s))), there holds ζσ(i, σ)!. By the deﬁnition of ζσ in (13), there exists an uncertainty set
U ∈ Ui such that ˆξ(U, σ)!, i.e. Eσ(U ) = 1. The rest of the proof is identical to Case (3.1) above, and
we conclude that sσ ∈ L(SUP) in this case as well.

The (⊇) direct of (18), as well as equation (19) can be established similarly to [5].

Finally, we provide the proof of Lemma 2.

Proof of Lemma 2. We must prove (6) and (7).

14

First, for (⇒) of Eq. (6), let Pα(s).tick ∈ L(LOCP

α ), s.tick ∈ L(G) and sα ∈ L(SUP); we must
α L(LOCα), and thus Pα(s) ∈
α ), ηα(y, tick)!. The rest of the proof is

prove that s.tick ∈ L(SUP). Since s ∈ L(SUP), we have s ∈ P −1

L(LOCP

α ). Let y := ηα(y0, Pα(s))!; by Pα(s).tick ∈ L(LOCP

identical to the inductive case of proving (⊆) of (18), and we conclude that s.tick ∈ L(SUP).

Next, for (⇐) of Eq. (6), let s.tick ∈ L(SUP) and sα ∈ L(SUP); s ∈ L(SUP) and s.tick ∈ L(G)

are immediate, and it is left to show that Pα(s).tick ∈ L(LOCP
have for all σ ∈ Σf or, s.tick ∈ P −1
and thus Pα(s.tick) ∈ L(LOCP
Pα(s.tick) ∈ L(LOCP

α ). By s.tick ∈ L(SUP) and (18), we
α ),
α ). According to the deﬁnition of Σα, {tick} ⊆ Σα. Hence, Pα(s).tick =

σ L(LOCP

σ ). Because α ∈ Σhib, we have s.tick ∈ P −1

α L(LOCP

α ).

Finally, to prove (7), let y, y′ ∈ Yα and σ ∈ Σo and assume that y′ = ηα(y, σ) and y 6= y′; we prove

deﬁned. Further, according to the rules (iii) and (iv) of constructing LOCP

that σ ∈ Σo by contradiction. Suppose that σ ∈ Σuo. According to (13), for all i ∈ I, ζα(i, σ) is not
α , (1) for all y ∈ Y , ηα(y, σ)
is not deﬁned, contradicting to the assumption that y′ = ηα(y, α); (2) the selﬂoop ηα(y, α) = y is added
to ηα when ψα(y) = 1 or ψtick(y) = 1, which, however, contradicts the assumption that y 6= y′. So we
conclude that σ ∈ Σo.

(cid:3)

For illustration, the proposed partial-observation supervisor localization procedure for TDES is applied

to a case study on a timed workcell adapted from [14] in the next subsection.

D. Case Study: Timed Workcell

We illustrate partial-observation supervisor localization in TDES by studying a timed workcell example,

taken from [14, Chapter 9]. As displayed in Fig. 1, the workcell consists of two machines M1 and M2

linked by a one-slot buffer BUF. The untimed DES models of the machines are displayed in Fig. 2.

The workcell operates as follows. Initially the buffer is empty. With the event α1, M1 takes a workpiece
from the inﬁnite workpiece source. Subsequently M1 either breaks down (event λ1), or successfully
completes its work cycle, deposits the workpiece in the buffer (event β1). M2 operates similarly, but
takes its workpiece from the buffer (event α2), and deposits it when ﬁnished in the inﬁnite workpiece
sink. If a machine Mi (i = 1, 2) breaks down (event λi), then it will be started to repair (event µi), and

ﬁnally its repair will be ﬁnished (event ηi). Assign lower and upper time bounds to each event, with

notation (event, lower bound, upper bound), as follows:

15

Workpiece

Source

Workpiece

Sink

Fig. 1. Workcell: system conﬁguration

Fig. 2. Untimed DES models of Mi

0

1

3

2

0

1

0

1

Fig. 3. Control speciﬁcations: ∗ = {tick, α1, λ1, µ1, η1, β2, λ2, µ2, η2}, and ∗∗ = {α1, β1, λ1, η1, α2, β2, η2}

M1’s timed events :

(α1, 0, ∞) (β1, 1, 2) (λ1, 0, 2) (µ1, 0, ∞) (η1, 1, ∞)

M2’s timed events :

(α2, 0, ∞) (β2, 1, 1) (λ2, 0, 1) (µ2, 0, ∞) (η2, 2, ∞)

So αi, µi and ηi, i = 1, 2 are remote events (upper bound ∞), and βi and λi, i = 1, 2 are prospective

events (ﬁnite upper bounds). Now the TDES models of the two machine can be generated [14]; their

joint behavior is the composition of the two TDES, which is the plant to be controlled, i.e. PLANT =

Comp(M1, M2).

To impose behavioral constraints on the two machine’s joint behavior, we take Σf or = Σhib =
{αi, µi|i = 1, 2}, and Σuc = {βi, λi, ηi|i = 1, 2}. We impose the following control speciﬁcations: (S1)

BUF must not overﬂow or underﬂow; (S2) if M2 goes down, its repair must be started “immediately”,

and prior to starting repair of M1 if M1 is currently down. These two speciﬁcations are formalized as

generators BUFSPEC and BRSPEC, as represented in Fig. 3. So the overall speciﬁcation imposed

on the PLANT is represented by SPEC = BUFSPEC||BRSPEC.

Under partial observation, we consider the case that the subset of unobservable events Σuo = {α1, λ1, µ1, η1, β2}.

16

0

1

2

0

1

0

1

2

0

0

1

2

0

1

0

0

1

Fig. 4. Local preemptors and local controller under partial observation P (Σuo = {α1, λ1, µ1, η1, β2})

Namely, in M1, only event β1 is observable, and in M2, only event β2 is unobservable. We ﬁrst compute
as in (5) the controllable and observable controlled behavior SUP, which has 69 states and 139 transitions.

Then we apply partial-observation supervisor localization to construct partial-observation local preemptors

and partial-observation local controllers, respective for each forcible event and each prohitibile event. The

computation can be down by an algorithm adapted from [5], as discussed in Section IV.C. The results

are displayed in Fig. 4. It is veriﬁed that the collective controlled behavior of these local preemptors and

controllers is equivalent to that represented by SUP.

LOCC

LOCC

α1 will disable event α1 to prevent the overﬂow of the buffer. LOCP

α1 may preempt the occurrence
event tick by α1 when M2 is broken down (in this case, the buffer is empty and thus α1 may occur).
µ1 will disable event µ1 when M2 is broken down, as required by speciﬁcation (S2). The
occurrence of event µ1 will not preempt event tick (the repair of M1 has lower priority than that of
M2) and thus LOCP

µ1 has only one state.

LOCC

α2 will enable α2 (M2 get a workpiece from the buffer) when the buffer is full, i.e. M1 has
put a workpiece into the buffer. When the buffer is full and M1 has taken a workpiece from the source,

M2 will effectively (preempt the occurrence of tick by LOCP

α2) take a workpiece from the buffer, to

prevent the overﬂow of the buffer.

LOCC

µ2 always enable µ2 (start to repair M2) if it is eligible to occur, as required by speciﬁcation

17

Fig. 5. Distributed control architecture: Σo = {β1, α2, λ2, µ2, η2}

(S2). The repair of M2 must be started immediately if it is enabled, thus tick will be preempted by

LOCP

µ2 after M2 has broken down.

Finally, we allocate each partial-observation local preemptor/controller to the agent owning the cor-

responding forcible/prohibitible event, and build a distributed control architecture for this workcell, as

displayed in Fig. 5. A local preemptor/controller either directly observes an observable event generated by

the agent owning it, as denoted by solid lines in Fig. 5, or imports an observable event by communication

from other local preemptors/controllers, as denoted by the dashed lines. Note that only observable events

lead to state changes in the transition diagrams displayed in Fig. 4, and only the events that lead to state

changes are communicated.

V. PARTIAL-OBSERVATION LOCALIZATION OF TDES WITH COMMUNICATION DELAY

As illustrated in Fig. 5, a local preemptor/controller may either directly observe an event generated

by the agent owning it, or import an event by communication from other local preemptors/controllers.

From now on, we address the issue of communication delay: the event communications among the plant

components and their local controllers/preemptors are subject to inneglectable delays.

A. Communication Channel Models

By the supervisor localization procedure in Section IV, we obtained a set of partial-observation local

preemptors LOCP

observation local controllers LOCC

α (α ∈ Σf or) with communication event set Σcom,α (as in (16)), and a set of partial-
β (β ∈ Σhib) with Σcom,β (as in (17)). For each event in these
communication sets, consider that it is transmitted through a communication channel and subject to

delay.

Let Gl (l ∈ {1, ..., N }) be an agent with Σl, and denote by Σcom,l

the subset of events to be

18

(cid:86)

tick

0

tick

1

2

(cid:22)(cid:22)

d

tick

d+1

0

1

2

Fig. 6. Untimed DES model of bounded communication channel BCH(k, σ, l) and speciﬁcation SPEC BCHd(k, σ, l) of

delay bound d imposed on the channel.

communicated to Gl which is given by

Σcom,l = (cid:0) [

α∈Σl∩Σf or

(Σcom,α\Σl)(cid:1)

∪ (cid:0) [

β∈Σl∩Σhib

(Σcom,β \ Σl)(cid:1).

Let Gk (k ∈ {1, ..., N }) be another agent with Σk. Then the subset of events communicated from agent
Gk to Gl is

Σk,com,l = Σk ∩ Σcom,l.

(20)

Fix an event σ ∈ Σk,com,l and consider communication delay of σ. To meet a hard deadline of
an operation or to ensure system’s timely performance in practice, it may often be the case that the

communication delay of event σ is bounded by d ∈ N ticks. For this, we propose a channel model

BCH(k, σ, l), as displayed in Fig. 6; the model will be treated as a plant component.

We explain the model BCH(k, σ, l) as follows. (1) Event σ denotes that σ occurs in Gk and is sent
to the communication channel. (2) Event σ′ denotes that σ is received by Gl, and an acknowledgement
message is sent back to the channel. (3) Event σ′′ denotes that Gk receives the acknowledgement, which
will reset the channel to be idle (i.e. the channel is ready to send the next occurrence of σ). (4) Event

στ denotes “timeout”, which will reset the channel to idle if the transmission has not been completed in
a given time τ = d. The lower bounds of σ′ and σ′′ are both set to be 0 and the upper bounds to be d;

the lower and upper time bounds of στ are both τ . The requirement of delay bound d is represented by

the TDES SPEC BCHd(k, σ, l) displayed in Fig. 6. It is required that the time between Gk sends out
event σ and it receives acknowledgement σ′′ be no more than d ticks. SPEC BCHd(k, σ, l) will be
imposed as a temporal speciﬁcation.

In case there happens to be no speciﬁc deadline requirement on transmission of event σ ∈ Σk,com,l,
or simply no a priori knowledge is available of a delay bound on σ, it may be reasonable to consider

19

0

1

2

0

1

Fig. 7. Untimed DES model of unbounded communication channel CH(k, σ, l) and speciﬁcation SPEC CH(k, σ, l) of

unbounded delay imposed on the channel.

unbounded delay of σ-communication. This means that the transmission of σ may take indeﬁnite time

to complete, although it will complete eventually. For unbounded delay, we propose a channel model

CH(k, σ, l), as displayed in Fig. 7; the model will be treated as a plant component.

In CH(k, σ, l), the meaning of the event labels σ, σ′ and σ′′ are the same as those in bounded channel

BCH(k, σ, l). In this case, however, since the communication delay is unbounded, σ′ and σ′′ both have

lower bound 0 and upper bound ∞ (i.e. they may occur at any time after they become eligible to). The

requirement of unbounded delay is represented by the TDES SPEC CH(k, σ, l) displayed in Fig. 7;

SPEC CH(k, σ, l) will be imposed as a temporal speciﬁcation.

In the channel models above, we make the following choices. (1) Both events σ′ and σ′′ are uncon-

trollable, because it is not reasonable (if not impossible) to disable the receipt of a communication or

an acknowledgement; (2) event στ is uncontrollable but forcible, because its occurrence is supposed
to preempt tick; (3) events σ, σ′′ (and στ ) are observable to the sender Gk but unobservable to the
receiver Gl, while σ′ is observable to Gl but unobservable to Gk. This means that the agents G1,...,GN
generally have different subsets of observable events; this is a new feature of the current formulation

with communication delay.

B. Partial-Observation Supervisor Localization with Communication Delay

Recall from Section III that, in the delay-free case, we had plant G = Comp(G1, ..., GN ) over
Σ, speciﬁcation E ⊆ Σ∗, prohibitible event set Σhib, and forcible event set Σf or. For simplicity of
presentation, we assume here that the component agents Gk (given in (4)) have pairwise disjoint event
sets Σk (k ∈ N := {1, ..., N }); the more general case of event sharing among agents is presented in
[15].

Now for k, l ∈ N let Σk,com,l in (20) be partitioned as Σk,com,l = Σbd

the subset of communication events with bounded delay and Σud

˙∪Σud

k,com,l

k,com,l is
k,com,l the subset of those with unbounded

k,com,l, where Σbd

20

delay. First, the new plant ˜G including both the agents and the channels is

˜G = Comp(G,{BCH(k, σ, l)|σ ∈ Σbd

k,com,l, k, l ∈ N },

{CH(k, σ, l)|σ ∈ Σud

k,com,l, k, l ∈ N }).

The event set ˜Σ of ˜G is ˜Σ = Σ ∪ {σ′, σ′′, στ |σ ∈ Σbd
k,com,l, k, l ∈ N }.
Since all the added events σ′, σ′′ and στ are uncontrollable, the new subset of prohibitible events is
unchange, i.e. ˜Σhib = Σhib. Also, since στ is forcible, the new subset ˜Σf or of forcible events is ˜Σf or =
Σf or ∪ {στ |σ ∈ Σbd

k,com,l, k, l ∈ N }. Note that ˜Σc := ˜Σf or ˙∪{tick}, and ˜Σuc := ˜Σ \ ˜Σc.

k,com,l, k, l ∈ N } ∪ {σ′, σ′′|σ ∈ Σud

The speciﬁcations imposed on ˜G include both the original E and the bounded/unbounded delay

requirement of communication events. Thus the new speciﬁcation ˜E is

˜E = E || {Lm(SPEC BCHd(k, σ, l))|σ ∈ Σbd

k,com,l, k, l ∈ N }

|| {Lm(SPEC CH(k, σ, l))|σ ∈ Σud

k,com,l, k, l ∈ N }

where “||” denotes synchronous product [14].

As we have mentioned, a consequence of introducing the communication channels is that the agents
Gk (k ∈ N ) generally have distinct observable event sets. Hence the local preemptors/controllers to be
allocated to different agents will be required to have different observable event sets. To address this,
rather than synthesizing a monolithic supervisor, we propose to synthesize N decentralized supervisors
one for each observable event set ˜Σo,k (k ∈ N ) given by

˜Σo,k := (Σo \ Σcom,k) ∪ {σ, σ′′, στ |σ ∈ Σbd

k,com,l, l ∈ N , l 6= k}

∪ {σ, σ′′|σ ∈ Σub

k,com,l, k, l ∈ N , l 6= k}

∪ {σ′|σ ∈ Σl,com,k, l ∈ N , l 6= k}.

For the synthesis of decentralized supervisors, we employ the concept of relative coobservability [7].
o,k and C ⊆ Lm( ˜G) be an ambient language. A sublanguage K ⊆ C is relatively
Let ˜Pk : ˜Σ∗ → ˜Σ∗
coobervable (with respect to C, ˜G and ˜Pk, k ∈ N ), or simply C-coobservable, if for every k ∈ N and
every pair of strings s, s′ ∈ Σ∗ with ˜Pk(s) = ˜Pk(s′) there holds

(∀σ ∈ Σk) sσ ∈ K, s′ ∈ C, s′σ ∈ L( ˜G) ⇒ s′σ ∈ K.

Namely, relative coobservability of K requires that K be relatively observable with respect to each ˜Po,k
and Σk, k ∈ N . It is proved [7] that relative coobservability is in general stronger than coobservability,
weaker than conormality, and closed under set union. Therefore, there exists a unique supremal relatively

coobservable sublanguage of a given language, which may be effectively computed.

21

For the new plant ˜G and speciﬁcation language ˜E, write CCO( ˜E ∩ Lm( ˜G)) for the family of relatively
coobservable (and controllable, Lm( ˜G)-closed) sublanguages of ˜E ∩ Lm( ˜G). Then CCO( ˜E ∩ Lm( ˜G))
is nonempty (the empty language ∅ belongs) and has a unique supremal element

sup CCO( ˜E ∩ Lm( ˜G)) = [{K|K ∈ CCO( ˜E ∩ Lm( ˜G))}.

With some abuse of notation, let the generator SUP be such that

Lm(SUP) := sup CCO( ˜E ∩ Lm( ˜G)).

(21)

We call SUP the controllable and coobservable controlled behavior, and assume that Lm(SUP) 6= ∅.1
Next, for each observable event set ˜Σo,k (k ∈ N ), we construct as in (10) a partial-observation
decentralized supervisor SUPOk deﬁned over ˜Σo,k. It is well known that such constructed decentralized
supervisors SUPOk collectively achieve the same controlled behavior as SUP does. The control actions
of the supervisor SUPOk include (1) disabling prohibitible events in

and (2) preempting event tick via forcible events in

˜Σhib,k := Σk ∩ ˜Σhib.

˜Σf or,k := (Σk ∩ Σf or) ∪ {στ |σ ∈ Σbd

k,com,l, l ∈ N }

(22)

(23)

Note that ˜Σf or,k includes not only the forcible events in Σk ∩ Σf or, but also the forcible events στ in
those bounded channel models transmitting events σ ∈ Σk. Also, since Σk are pairwise distinct, so are
˜Σhib,k and ˜Σf or,k, (k ∈ N ), and therefore ˜Σhib = ˙Sk∈N
Finally, we apply the localization procedure developed in Section IV to decompose, one at a time,

˜Σhib,k and ˜Σf or = ˙Sk∈N

˜Σf or,k.

each decentralized supervisor SUPOk, k ∈ N . The result is a set of partial-observation local preemptors
α = (Yα, Σα, ηα, y0,α, Ym,α), one for each forcible event α ∈ ˜Σf or, as well as a set of local
LOCP
˜Σf or,k
β ) will be

β = (Yβ, Σβ, ηβ, y0,β, Ym,β), one for each β ∈ ˜Σhib. Owing to ˜Σf or = ˙Sk∈N

˜Σhib,k), one local preemptor LOCP

controllers LOCC
(resp. ˜Σhib = ˙Sk∈N
allocated to precisely one agent.

α (resp. one local controller LOCC

The following is the main result of this section, which asserts that the collective controlled behavior

of the resulting partial-observation local preemptors and local controllers is identical to that of SUP, thus

satisfying all the imposed communication delay requirements.

1The imposed temporal speciﬁcations of bounded/unbounded communication delay may cause Lm(SUP) = ∅, which means
that the delay requirements are too strong to be satisﬁed. In that case, we shall weaken the delay requirements by either decreasing

delay bounds of bounded-delay channels or reducing the number of unbounded-delay channels, until we obtain a nonempty

Lm(SUP).

22

Theorem 2. The set of partial-observation local preemptors {LOCP

α |α ∈ ˜Σhib} and the set of partial-
β |β ∈ ˜Σhib} derived above are control equivalent to the monolithic

observation local controllers {LOCC
supervisor SUP in with respect to the plant ˜G, i.e.

with

L( ˜G) ∩ L(LOC) = L(SUP)

Lm( ˜G) ∩ Lm(LOC) = Lm(SUP)

L(LOC) := (cid:16) \

α∈ ˜Σf or

P −1
α L(LOCP

α )(cid:17)

∩ (cid:16) \

β∈ ˜Σhib

P −1
β L(LOCC

β )(cid:17)

Lm(LOC) := (cid:16) \

α∈ ˜Σf or

P −1
α Lm(LOCP

α )(cid:17)

∩ (cid:16) \

β∈ ˜Σhib

P −1
β Lm(LOCC

β )(cid:17)

(24)

(25)

(26)

(27)

where Pα : ˜Σ∗ → Σ∗

α and Pβ : ˜Σ∗ → Σ∗
β.

The proof of Theorem 2 is similar to that of Theorem 1, which relies on the facts that (1) for each

forcible event, there is a corresponding partial-observation local preemptor that preempts event tick

consistently with SUP, and (2) for each prohibitible event, there is a corresponding partial-observation

local controller that disables/enables it consistently with SUP.

By the above localization approach, each agent Gk (k ∈ N ) acquires a set of partial-observation local
β |β ∈ ˜Σhib,k}.
Thus we obtain a distributed control architecture for multi-agent TDES under partial observation and

α |α ∈ ˜Σf or,k} and a set of partial-observation local controllers {LOCC

preemptors {LOCP

communication delay.

As described in Section IV.C, the partial-observation localization algorithm of constructing partial-

observation local preemptors and controllers has the complexity exponential in |X|, where X is the state

set of SUP. Introducing the communication channels will increase the state size of SUP and thus affects

the overall complexity. Assume that there are m1 unbounded channels CH(k, σ, l) (as displayed in Fig. 7)
and m2 bounded channels BCH(k, σ, l) (as displayed in Fig. 6) with delay bound d. Thus there are m1
generators SPEC CH(k, σ, l) and m2 generators SPEC BCHd(k, σ, l) representing the speciﬁcations
on unbounded and bounded delays respectively; the state sizes of the channels and speciﬁcations are listed

in Table I. Assume that for all channels, d ≤ c1 ∈ N, and the state size of the generator representing E

23

TABLE I.

STATE SIZES OF COMMUNICATION CHANNELS AND SPECIFICATIONS

TDES channels

state size

speciﬁcations

state size

CH(k, σ, l)

3

SPEC CH(k, σ, l)

BCH(k, σ, l)

(1/2*(d+2)(d+3))

SPEC BCHd(k, σ, l)

2

d+2

is c2. By (21), |X| ≤ 2|Q|∗f1∗c2∗f2, where f1 = 3m1(1/2 ∗ (c1 + 2)(c1 + 3))m2 is the states number of
the composition of all communication channels, and f2 = 2m1 ∗ (c1 + 2)m2 is the states number of the
synchronous product of all the speciﬁcations on the channels. So the complexity of partial-observation

localization procedure under communication delay is double-exponential in |Q| ∗ f1 ∗ c2 ∗ f2. It is true
that when the system is large-scale, the computation of local preemptors/controllers is impractical for

general computers. So in that case, the localization procedure should be combined with some efﬁcient

heterarchical supervisory synthesis approach (e.g. [16]); we will investigate the details in future work.

Proof of Theorem 2: We provide the proof of the (⊇) direction of (24) and (25) may be veriﬁed analogously
as in the proof of Theorem 1. Here we prove (⊆) of (24) by induction, i.e. L( ˜G) ∩ L(LOC) ⊆ L(SUP).
For the base step, note that none of L( ˜G), L(LOC) and L(SUP) is empty; and thus the empty
string ǫ belongs to all of them. For the inductive step, suppose that s ∈ L( ˜G) ∩ L(LOC), s ∈ L(SUP)
and sσ ∈ L( ˜G) ∩ L(LOC) for arbitrary event σ ∈ Σ; we must show that sσ ∈ L(SUP). Since
˜Σ = ˜Σuc ˙∪ ˜Σhib ˙∪{tick}, we consider the following three cases.

(1) σ ∈ ˜Σuc. Since L(SUP) is controllable, and sσ ∈ L( ˜G) (i.e. σ ∈ Elig ˜G(s)), we have σ ∈

EligLm(SUP)(s). That is, sσ ∈ Lm(SUP) = L(SUP).

s, s.tick ∈ P −1

(2) σ = tick. By the hypothesis that s, s.tick ∈ L(LOC), for every forcible event α ∈ ˜Σf or,k, k ∈ N ,
α,k). Let y = ηα(y0,α, Pα,k(s)); then
α and Pα

ηα(y, tick)!. The rest of the proof is similar to case (2) of proving Theorem 1, with LOCP

α,k), i.e. Pα,k(s), Pα,k(s).tick ∈ L(LOCP

α,kL(LOCP

replaced by LOCP

α,k and Pα,k respectively.

sσ ∈ L(LOC) that sσ ∈ P −1

(3) σ ∈ ˜Σhib. There must exist a partial-observation local controller LOCC

σ,k for σ. It follows from
σ,k) and
Pσ,k(s) ∈ L(LOCC
σ,k), namely, ησ,k(y0, Pσ,k(sσ))! and ησ,k(y0, Pσ,k(s))!. Let y := ησ,k(y0, Pσ,k(s));
then ησ,k(y, σ)! (because σ ∈ Σσ,k). The rest of the proof is similar to case (3) of proving Theorem 1,
with LOCC

σ,k). So Pσ,k(sσ) ∈ L(LOCC

σ and Pσ replaced by LOCC

σ,k and Pσ,k respectively.

σ,k L(LOCC

σ,k) and s ∈ P −1

σ,k L(LOCC

24

(cid:3)

0

1

2

0

1

2

Fig. 8.

Untimed DES model of bounded communication channel BCH(1, β1, 2) and the corresponding speciﬁcation

SPEC BCH1(1, β, 2).

0

1

2

0

1

Fig. 9.

Untimed DES model of unbounded communication channel CH(2, β2, 1) and the corresponding speciﬁcation

SPEC CH(2, β, 1).

For illustration, the proposed localization procedure is applied to study a timed workcell under bounded

and unbounded communication delay in the following subsection.

C. Timed WorkCell Example

We demonstrate the proposed partial-observation localization with communication delay by studying the

distributed control of the timed workcell example described in Section V. For illustration, we consider the

case that event β1 should be transmitted from M1 to M2 with delay bound 1 (tick), event β2 transmitted
from M2 to M1 with unbounded delay, and events µ1 and η1 are unobservable.

First, we create the bounded communication channel BCH(1, β1, 2) to transmit event β1, as displayed
in Fig. 8 and unbounded communication channel CH(2, β2, 1) to transmit event β2, as displayed in
Fig. 9. For the given delay bounds imposed on the channels, the speciﬁcations on the channels are

SPEC BCH1(1, β1, 2), and SPEC CH(2, β2, 1), as displayed in Fig. 8 and Fig. 9 respectively. The
lower and upper bounds of the newly added events are enumerated in Table II.

Then, the plant to be controlled is

NPLANT = Comp(M1, M2,

BCH(1, β1, 2), CH(2, β2, 1)),

25

TABLE II.

LOWER AND UPPER TIME BOUNDS OF EACH SIGNAL EVENT

event label

(lower, upper) bounds

event label

(lower, upper) bounds

β ′

1

β ′′

1

β1,τ

(0,1)

(0,1)

(1,1)

β ′

2

β ′′

2

(0,∞)

(0,∞)

TABLE III.

STATE SIZE OF PARTIAL-OBSERVATION LOCAL PREEMPTOR/CONTROLLER

Local preemptor

State size

Local controller

State size

LOCP
α1

LOCP
µ1

LOCP
α2

LOCP
µ2

LOCP

β1,τ

2

1

4

2

1

LOCC
α1

LOCC
µ1

LOCC
α2

LOCC
µ2

45

2

12

1

and the new speciﬁcation is

NSPEC =Sync(BUFSPEC, BRSPEC,

SPEC BCH1(1, β1, 2), SPEC CH(2, β2, 1)).

None of the newly added events are prohitible, so the subset of prohibitible events is ˜Σhib = {α1, µ1, α2, µ2}.
The timed out event β1,τ is forcible and thus the subset of forcible events is changed as ˜Σf or =
{α1, µ1, α2, µ2, β1,τ }. The subset of unobservable events for M1 is ˜Σuo,1 = {µ1, η1, β′
2 } (the
occurrence of β′
2 is observable to M1), and
the subset of unobservable events for M2 is ˜Σuo,2 = {µ1, η1, β1, β′′
2} (β′
1 is observable to M1).
Next, we compute the controllable and coobservable controlled behavior SUP as in (21) which has

2 represents that M1 has received the occurrence of β2, so β′
1 , β1,τ , β′

1, β2, β′′

671 states.

Finally, we apply the partial-observation supervisor localization procedure presented in Section IV
to construct a set of partial-observation local preemptors, one for each forcible event in ˜Σf or and a
set of partial-observation local controllers one for each prohibitible event in ˜Σhib. The state sizes of the
resulting local preemptors/controllers are displayed in Table III. It is veriﬁed that the collective controlled

behavior of these local preemptors and controllers is equivalent to SUP. The control logics of the partial-

observation local preemptors and controllers are similar to that of the full-observation local preemptors

and controllers, as described in Section V.

26

0

1

2

(i)(cid:3)

is(cid:3)unobservable

5

3

4

0

1

2

11

5

3

6

(ii)(cid:3)

is(cid:3)transmitted(cid:3)by(cid:3)

Fig. 10.

Partial-observation local controller LOCC

α2 for event α2. In case (i), β1 is unobservable to LOCC

α2 (Σuo =
1 is

{β1, µ1, η1, β2}). In case (ii), β1 is unobservable to LOCC

α2 , but is transmitted to LOCC

α2 by BCH(1, β1, 2) and thus β ′

observable to LOCC

α2. Here the ﬁgure of case (ii) displays part of the transition diagram of LOCC

α2 .

The event communication delays affects the control logics. For example, inspect the transition diagram

of LOCC

1) affects the control logics of LOCC

µ2; the recipient of event β1 (represented by β′

α2. For
illustration, consider the case that the sequence of events α1, tick, β1, tick has occurred, i.e., M1 has
taken a workpiece from the source (α1) and deposited it into the buffer (β1). Now, event α2 (M2 takes the
workpiece from the buffer) is eligible to occur. However, since β1 is unobservable to the local controller
LOCC
α2 will disable
event α2 to prevent the underﬂow of the buffer (the control strategy is displayed as case (i) in Fig. 10).
However, if the occurrence of β1 is transmitted by BCH(1, β1, 2) in 1 (the delay bound) ticks, LOCC
α2
will enable α2 in time, as displayed in case (ii) of Fig. 10.

α2 for α2 (the local controller does not know whether or not β1 has occurred), LOCC

Finally, we allocate each partial-observation local preemptor/controller to the agent owning the corre-

sponding forcible/prohibitible event, and thereby build a distributed control architecture for this workcell,

as displayed in Fig. 11. A local preemptor/controller may observe an event generated by the agent

owning it, as denoted by solid lines in Fig. 11, or imports an event by communication from other local

preemptors/controllers with no communication delay, as denoted by the dashed lines, or receives the

occurrence of an event through communication channels with communication delays (e.g. CH(2, β2, 1)
and BCH(1, β1, 2)). Since Lm(SUP) ⊆ ˜E = Lm(NSPEC) and the collective controlled behavior
of the local preemptors and controllers is equivalent to Lm(SUP), the system behavior satisﬁes the

speciﬁcation of communication delays on the channels.

27

Fig. 11. Distributed control architecture with communication delay. The acknowledgements of channels are not displayed in

the ﬁgure.

VI. CONCLUSIONS

In this paper, we have ﬁrst developed a partial-observation supervisor localization procedure to solve

the distributed control problem of multi-agent TDES. A synthesized monolithic supervisor is decomposed

into a set of partial-observation local controllers and a set of partial-observation local preemptors,

whose state changes are caused only by observable events. We have proved that the resulting local

controllers/preemptors collectively achieve the same controlled behavior as the monolithic supervisor

does.

Moreover, we have extended the partial-observation supervisor localization to the case where inter-

agent event communication is subject to bounded and unbounded delay. To address communication delay,

we have developed an extended localization procedure based on explicit channel models and relative

coobservability. We have proved that the resulting local controllers/preemptors collectively satisfy the

communication delay requirements. The above results are both illustrated by a timed workcell example.

In future research we shall extend the partial-observation localization procedure to study distributed

control of large-scale systems, by combing the proposed supervisor localization with some efﬁcient

heterarchical synthesis procedure, e.g. [16].

REFERENCES

[1] K. Cai and W. M. Wonham, “Supervisor localization: a top-down approach to distributed control of discrete-event systems,”

IEEE Trans. on Automatic Control, vol. 55, no. 3, pp. 605–618, 2010.

[2] ——, Supervisor Localization: A Top-Down Approach to Distributed Control of Discrete-Event Systems. Lecture Notes

in Control and Information Sciences, vol. 459, Springer, 2015.

[3] R. Zhang, K. Cai, Y. Gan, Z. Wang, and W. M. Wonham, “Supervision localization of timed discrete-event systems,”

Automatica, vol. 49, no. 9, pp. 2786–2794, 2013.

[4] B. Brandin and W. M. Wonham, “Supervisory control of timed discrete-event systems,” IEEE Trans. on Automatic Control,

vol. 39, no. 2, pp. 329–342, 1994.

28

[5] R. Zhang and K. Cai, “Supervisor localization of discrete-event systems under partial observation,” Technical Report, 2015,

available at http://arxiv.org/abs/1509.05498. Also see ”On supervisor localization based distributed control of discrete-event

systems under partial observation”, to appear in ACC 2016.

[6] K. Cai, R. Zhang, and W. M. Wonham, “Relative observability of discrete-event systems and its supremal sublanguages,”

IEEE Transactions on Automatic Control, vol. 60, no. 3, pp. 659–670, 2015.

[7] ——, “Relative observability and coobservability of timed discrete-event systems,” IEEE Transactions on Automatic

Control, published online, 2015.

[8] F. Lin and W. M. Wonham, “Supervisory control of timed discrete-event systems under partial observation,” IEEE

Transactions on Automatic Control, vol. 40, no. 3, pp. 558–562, 1995.

[9] R. Zhang, K. Cai, Y. Gan, and W. M. Wonham, “Distributed supervisory control of discrete-event systems with

communication delay,” Discrete Event Dynamic Systems, to appear, 2016.

[10] ——, “Delay-robustness in distributed control of timed discrete-event systems based on supervisor localization,”

International Journal of Control, to appear, 2016.

[11] G. Barrett and S. Lafortune, “Decentralized supervisory control with communicating controllers,” IEEE Trans. on

Automatic Control, vol. 45, no. 9, pp. 1620–1638, September 2000.

[12] S.-J. Park and K.-H. Cho, “Decentralized supervisory control of discrete event systems with communication delays based

on conjunctive and permissive decision structures,” Automatica, vol. 43, no. 4, pp. 738–743, April 2007.

[13] F. Lin, “Control of networked discrete event systems: dealing with communication delays and losses,” SIAM J. Control

and Optimization, vol. 52, no. 2, pp. 1276–1298, 2014.

[14] W. M. Wonham, Supervisory Control of Discrete-Event Systems.

Systems Control Group, ECE Dept, Univ. Toronto,

Toronto, ON, Canada, July 2015, available at http://www.control.utoronto.ca/DES.

[15] R. Zhang and K. Cai, “Supervisor localization of timed discrete-event systems under partial observation and communication

delay,” Technical Report, 2016, available at http://arxiv.org/abs/1603.02023.

[16] L. Feng and W. M. Wonham, “Supervisory control architecture for discrete-event systems,” IEEE Trans. Autom. Control,

vol. 53, no. 6, pp. 1449–1461, 2008.

29

