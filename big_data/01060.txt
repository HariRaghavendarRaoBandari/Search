Yes-no Bloom ﬁlter: A way of representing

1

sets with fewer false positives

Laura Carrea, Alexei Vernitski and Martin Reed

6
1
0
2

 
r
a

M
3

 

 
 
]
S
D
.
s
c
[
 
 

1
v
0
6
0
1
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

The Bloom ﬁlter (BF) is a space efﬁcient randomized data structure particularly suitable to represent
a set supporting approximate membership queries. BFs have been extensively used in many applications
especially in networking due to their simplicity and ﬂexibility. The performances of BFs mainly depends
on query overhead, space requirements and false positives. The aim of this paper is to focus on false
positives. Inspired by the recent application of the BF in a novel multicast forwarding fabric for
information centric networks, this paper proposes the yes-no BF, a new way of representing a set,
based on the BF, but with signiﬁcantly lower false positives and no false negatives. Although it requires
slightly more processing at the stage of its formation, it offers the same processing requirements for
membership queries as the BF. After introducing the yes-no BF, we show through simulations, that it
has better false positive performance than the BF.

Index Terms

probabilistic data structure, information representation, information centric networks

I. INTRODUCTION

The BF is a time and space efﬁcient data structure that is used to represent concisely a set
and allows highly efﬁcient set membership queries [1]. However, the BF has some probability of
giving false positives in a membership test; that is, an element may appear to belong to the set
when in fact it does not. Moreover, elements can be added to the set, but not removed. Because

Laura Carrea is afﬁliated with the School of Mathematical and Physical Sciences, University of Reading, UK and with
the School of Computer Science and Electronic Engineering, University of Essex, UK; Alexei Vernitski is afﬁliated with the
Department of Mathematical Sciences, University of Essex; Martin Reed is afﬁliated with School of Computer Science and
Electronic Engineering, University of Essex, UK

2

of their space-time efﬁciency, the BF has become very popular for network applications [2], [3].
In fact, BFs offer a representation which signiﬁcantly reduces space and time to query at the
cost of false positives. For many applications false positives can be tolerated or can be made
low enough so that the savings in space and time they offer justify their use. However, ﬁnding
methods to reduce false positives keeping the characteristics the BF offers is a challenge.

Many variants of the BF have been proposed. Some of them, like the retouched BF proposed in
[4], which is based on a randomized bit clearing, generates false negatives. Some other schemes
allow the deletion of elements [5] or counting the elements stored [6], [7]. Almeida [8] introduced
the scalable BF, a BF variant that reduces false positives adapting dynamically to the number
of elements stored, assuring a minimum false positive probability.

Recently, the complement Bloom Filter [9] has been proposed to reduce false positives. They
introduce the complement Bloom ﬁlter which explicitly stores all the elements of the universe
which are not in the set. Unlike most variants of the Bloom ﬁlter, the complement Bloom
ﬁlter produces false negatives, which are not tolerable in many applications. As is shown in the
numerical experiment in [9], the size of the complement ﬁlter must be very large, making the
construction difﬁcult to implement and not space-efﬁcient. Moreover, the complement ﬁlter is
static: it does not have any parameters whose values can be chosen to improve the performance,
unlike the construction proposed in this paper. Another structure which has been proposed to
reduce false positives is the optihash [10]. This variant has been inspired by the application of
the BF as a forwarding identiﬁer [11] in the information centric network architecture proposed
within the framework of the PSIRP/PURSUIT project [12], [13]. In this case, the BF becomes
a ﬁxed size forwarding identiﬁer that is placed in the packet header and encodes a complete
network path, or multicast tree, in a space/time efﬁcient manner. This strategy was introduced to
implement a forwarding layer replacing IP in applications such a clean-slate information centric
architecture but it has been suggested also to be a good alternative to MPLS labeling [14].

For the BF used as a network path encoding, a false positive means that trafﬁc may be
forwarded along links that were not intended to be part of the path. Thus, false positives may
cause bandwidth wastage or may generate a loop, which can cause major problems in the network.
Hence, there is an interest in minimizing the false positive occurrences for this application and
generally because of the BF wide applicability. For the application described in this paper, the
total length is also an important parameter as the BF will occupy part of the packet header.

3

In this paper, the yes-no BF is presented. The aim of the yes-no BF is to reduce the number of
false positives while keeping its properties of being a time and space efﬁcient data structure. First,
the classic BF is revised with a discussion on the false positive probability. Then, the yes-no BF
structure in introduced and presented in details and the false positive probability is analytically
evaluated. Also, an experimental analysis is carried out in order to evaluate the yes-no BF
performance for false positives with respect to the yes-no BF parameters and the characteristics
of the set which the structure represents. The average number of false positive occurrences of
the yes-no BF is ﬁrst analysed as a function of the set and data structure parameters and then it
is evaluated for the new forwarding mechanism which has been proposed within the framework
of the PSIRP/PURSUIT project. However, the data structure is general enough to be used in
other applications. The complexity of the processing required at the stage of the formation of the
yes-no BF is evaluated in terms of big O notation in comparison with the processing required
for the classic BF.

II. THE BLOOM FILTER

The BF is a compressed way of representing a set of elements, with some false positives but
no false negatives. A BF is a ﬁxed length Boolean array where a certain number of bits are set
to 1. Given a set S of elements to store in the BF, each element of the set S is represented with
its own BF, a Boolean array of a ﬁxed length m where up to k bits are set to 1. The bits are
set using k hash functions {h1, h2, ..., hk} applied to each element ei of the set

h1(ei), h2(ei), ...hk(ei) with ei ∈ E,
where the output of each hash is in the range {1, 2, ..., m}.

(i = 1, ...n),

(1)

Given the BF bei of each element of the set S, the whole set is represented by a Boolean
array, itself a BF, which can be interpreted as a logical disjunction of the BFs of its elements:

bS = be1 ∨ be1... ∨ ben.

(2)

Given a set T of elements to be queried, the membership test of an element in T can be
performed as a bitwise comparison between the BF of the set and the BF of the element. The
comparison is traditionally implemented as a logical conjunction on bS, the BF of the set and

TABLE I

TRUE TABLE OF A LOGICAL CONJUNCTION.

be

bS

be ∧ bS

0

0

1

1

0

1

0

1

0

0

0

1

be, the BF of the element to be queried:

bS ∧ be

 = be ⇒ e ∈ S

(cid:54)= be ⇒ e (cid:54)∈ S

,

4

(3)

namely if the logical conjunction is equal to the BF of the element to query then the element
necessarily belongs to the set otherwise it does not. Another way to interpret the set membership
query operation for the BF is to check bitwise if each bit of the BF of the element to query is
less than or equal to the corresponding bit in the BF representing the set. This is easy to verify
using the truth table of the logical conjunction reported in Table I, where be ∧ bS = be, then
be ≤ bS bitwise.

Because of the probabilistic nature of the BF, the BF can be only queried and its elements
can not be deleted. Moreover, the set membership test may give rise to a false positive: i.e. an
element appears to belong to the set even though it was not originally included in the BF. Let
us consider a BF of m bits. The probability that a speciﬁc bit is still 0 after all the elements in
S have been hashed with k hash functions is [3]:
1 − 1
m

(cid:19)kn

(4)

(cid:18)

p =

where n = |S| and where it has been assumed that the hash functions are perfectly random.

Given the BF bS of the set S and the set T of elements to be queried, let S the set of elements
e such that be ≤ bE, namely the set of elements that appears to belong to the set S after a
membership query. We can call S the set of the positives of the BF and S ⊂ S since the elements

5

Fig. 1. Set diagram for the elements included in the BF, the false positives and the elements to be queried.

in S deﬁnitely satisfy the condition. Then, the set F = S \ S is the set of the false positives.
The sets are schematically represented in Fig. 1, where S ∩ F = ∅.

For an element e (cid:54)∈ S, the probability that it belongs to the BF (namely that all the bits

h1(e), h2(e), ...hk(e) are set to 1) when tested for membership can be computed as [3]

(cid:32)

(cid:18)

(cid:19)kn(cid:33)k

fS = (1 − p)k =

1 −

1 − 1
m

,

(5)

where the assumption that if Bi and Bj are two distinct bits in the Bloom ﬁlter, the events
Bi = 1 and Bj = 1 are statistically independent has been made. However, this is not necessary
true as shown in [15]. Consequently, (5) is only an approximation of the false positive probability.
In particular, Bose in [15] showed that (5) a strict lower bound for any k ≥ 2 and proposed
a calculation of the false positive probability which is not though in closed form. A further
approximation of (5) is

fS ≈(cid:16)

1 − e− kn

m

(cid:17)k

(6)

being ex = lima→∞(cid:0)1 + x

(cid:1)a.

a

This probability is computed assuming that e (cid:54)∈ S, namely it is the conditional probability

[16]

fs = Pr[S|Sc]

(7)

where Sc = T \ S is the complement of S.

Instead, the probability of a false positive without assuming e ∈ Sc can be written as [17]

Pr[F ] = Pr[S \ S] = Pr[S] − Pr[S],

(8)

since S = S ∪ U and S ∩ U = ∅. The probability of S can be expressed as:

Pr[S] = Pr[S] Pr[S|S] + Pr[Sc] Pr[S|Sc].

Since Pr[S|S] = 1, Pr[S|Sc] = fS from (7) and Pr[Sc] = 1 − Pr[S], we obtain

Pr[S] = Pr[S] + (1 − Pr[S])fS

so that the probability of false positive for e ∈ T can be written as
Pr[F ] = Pr[S \ S] = (1 − Pr[S])fS.

6

(9)

(10)

(11)

If the condition e ∈ Sc is considered, namely e (cid:54)∈ S then Pr[S] = 0 and (11) becomes (7).

The advantages of the BF are that the calculations needed to build it, and test for membership,
are easy to program and very fast to perform, since only simple logical operations are required.
A limit of the BF is that its probabilistic nature gives rise to false positives. The aim of this
work is to propose a mechanism to limit the number of false positives.

The yes-no BF we propose is a new way of representing a set and it is based on the BF. It

III. THE YES-NO BF

is composed by two parts:

• the yes-ﬁlter encoding the set;
• the no-ﬁlter encoding the elements which generate false-positives.

It aims to offer a smaller number of false positives when compared to the BF and it can be
designed to have no false negatives. The main insight behind the yes-no BF is that, in many
applications, not only the elements belonging to the set but, more generally, all the elements
which will ever be queried are known when the data structure is formed.

Let U be the universe of all elements, S ⊆ U be the set of elements to be encoded in the
yes-no BF, and T ⊆ U \ S be the set of all the elements which do not belong to the set S and
whose membership in S is likely to be tested. Typically, T is a smaller set than U \ S.

The yes-no BF we propose, consists of a structure that not only has the function to encode the
elements of S, it has also some additional features to avoid actively the false positives during
the set membership test. Moreover, the yes-no BF aims to preserve the space-time efﬁciency
feature offered by the BF, although the structure requires slightly more processing but only at
the stage of its formation.

7

Fig. 2. Schematic representation of the yes-no BF structure.

As with the standard BF, we assume that the representation of a set consists, in total, of m

bits. These m bits are split into the following parts:
• p bits, to which we shall refer as the yes-ﬁlter;
• qr bits, where we shall refer to each of the q bits as to a no-ﬁlter.

so that m = p + qr and q << p. We shall refer to the above construction as the yes-no BF and
a schematic representation is shown in Fig. 2.

A. Representation of an element in U

Before describing the set construction we will introduce the construction of a single element
which will have a yes-ﬁlter and a single no-ﬁlter repeated r times. Two different sets of hash
functions are needed to represent each element e ∈ U with a yes-no BF structure:

• H = {h1, h2, ...hk} for the yes-ﬁlter
• W = {w1, w2, .., wk(cid:48)} for the no-ﬁlter

where generally k(cid:48) < k. Each hash function in H outputs values in {1, 2, ..p} while each hash
function in W outputs values in {1, 2, ..q}, with q << p and qr < p.

To construct the yes-ﬁlter the element e∈ S is hashed k times and the bits hi(e) in the yes-
ﬁlter are set to 1. To construct the no-ﬁlter the element e is hashed k(cid:48) times and the bits wj(e)
in the no-ﬁlter are set to 1. Note that each element e has only one no-ﬁlter. The yes-no BF
representation of the element e is constructed with its yes-ﬁlter and with r repetitions of the
no-ﬁlter. For convenience, we shall refer to these parts as the yes-ﬁlter and the no-ﬁlter of e.

As an example, we consider p = 13, q = 2, r = 2 as shown in Fig. 3. The number of hash
functions considered are k = 3 and k(cid:48) = 1, and h1(e) = 5, h2(e) = 2, h3(e) = 12 and w1(e) = 2.

B. Representation of a set in U

Given the set S of elements to encode in the yes-no BF and the set T ⊆ U \ S of elements
whose membership in S may be queried, the yes-no BF representing the set is constructed using

8

Fig. 3. An example of the yes-no BF structure for an element e.

the yes-ﬁlters of each element of the set S and the no-ﬁlters of the elements in T which produce
false positives when the yes-ﬁlter is queried. In particular, the yes-ﬁlter and the no-ﬁlters of the
set are constructed as described below.

1) The yes-ﬁlter: The yes-ﬁlter of the set S is formed as a disjunction of the yes-ﬁlters of

the all the elements e ∈ S, exactly as for a normal BF.

2) The no-ﬁlter: The no-ﬁlters of the set store the no-ﬁlters of the elements which generate
false positives when the yes-ﬁlter is queried. The yes-no ﬁlter reduces false positives compared
to the BF by keeping track, in an efﬁcient way, not only of the elements belonging to the set S
but also of the elements which generate false positives.

Let us analyse in detail the procedure to construct the no-ﬁlters of the set S. Firstly, the set
F ⊆ T of elements f which generate false positives is constructed using the membership query
procedure described for the BF (see Section II). Namely, the yes-ﬁlter of each of the elements
in T is checked against the yes-ﬁlter of the set. That is, if bit-wise each bit of the yes-ﬁlter of
an element in T is less than or equal to the yes-ﬁlter of the set S then necessarily this element
generates false positives and it will be an element of the subset F ⊆ T . Generally, |F| > r,
namely the number of false positives is greater than the number of no-ﬁlters. Consequently, each
of the no-ﬁlters of the set S will have to store more than one no-ﬁlter.

Each no-ﬁlter of the set is a BF which, obviously, may also give rise to false positives. A false
positive of a no-ﬁlter would mean that the element was not in reality a false positive for the
yes-ﬁlter even though the no-ﬁlter represents it as a false positive of the yes-ﬁlter. An element
which is not a false positive of the yes-ﬁlter may be an element which was added to the yes-ﬁlter.
Consequently, a false positive of the no-ﬁlter may represent a false negative of the yes-ﬁlter.
Fig. 4 shows the set R of elements that have been included in the no-ﬁlters, namely R ⊂ F .
Also, it shows the set G of the false positives of the no-ﬁlters which may have some elements
in S, namely the set G ∩ S is the set of the false negatives.

9

Fig. 4. Set diagram of the elements to include in the yes- and no-ﬁlters, the false positives of the yes- and the no-ﬁlters and
the elements to be queried for the case with false negatives.

Hence, in the construction it may be required to avoid false negatives in the yes-ﬁlter since
such false negatives may be more harmful1 than false positives. The following steps are proposed
for the construction of the no-ﬁlters of the set S in order to avoid false negatives, but the design
can be altered if false negative can be tolerated.

For each element in F , the algorithm will try in turn each no-ﬁlter stored in the yes-no ﬁlter
of the set to test if it does create a false negative. However, if none are suitable, then, this
particular false positive cannot be mitigated. Let us see in detail this construction.

• Given the no-ﬁlter vf1 of the ﬁrst false positive f1 ∈ Fyes and the ﬁrst no-ﬁlter v1 of the
1 is formed is formed between them to attempt to store the no-ﬁlter

set S, a disjunction v(cid:48)
of the ﬁrst false positive in the yes-no BF:

1 = vf1 ∨ v1.
v(cid:48)

(12)

• Then, to avoid false negatives, the following condition is checked for the no-ﬁlter of each

element e ∈ S:
– if the no-ﬁlter ve of each e ∈ S is greater than v(cid:48)

1, then none of the no-ﬁlters of the
elements in S is a false positive for the no-ﬁlter storing the false positives, namely

1for some applications like forwarding in information centric networks.

10

none of the elements in S can be a false negative. In this case, the ﬁrst no-ﬁlter of S
will be set as v(cid:48)
1.

– if the no-ﬁlter ve of any e ∈ S is less than or equal to v(cid:48)

1 then it may give raise to
false negative. In this case, the second no-ﬁlter v2 of the set S is attempted to be used
following the same steps as for the ﬁrst no-ﬁlter. If also the last ﬁlter vr satisfy this
condition then, f1 cannot be included in any of the no-ﬁlters and necessarily will be a
false positive.

This process is repeated for all the element in F and the set R of elements to store in the
no-ﬁlters is constructed. For convenience, we shall refer to the parts of the yes-no BF of the set
S as the yes-ﬁlter and the no-ﬁlters of the set S with respect to the set T . Fig. 5 shows the sets
when false negatives are avoided. In this case, G ∩ S = ∅.

We need to point out that the no-ﬁlter for each false positive occurrence can be placed in
anyone of the r no-ﬁlters of the set S. One would aim to choose the no-ﬁlters of the set S in
such a way that between them, they minimise the number of false positives. However, this is
a complex discrete optimisation problem; it is not unreasonable to conjecture that ﬁnding an
exact solution to it (that is, the smallest possible number of false positives, given a ﬁxed number
of no-ﬁlters) is NP-hard. The algorithm described above is a simple and fast greedy algorithm,
and we show in the experiments below that its performance provides better false positive rates
than the BF. However, in some implementations more time-consuming algorithms may be used,
which use the arsenal of operational research methods to further reduce false positive rates of
yes-no Bloom ﬁlters. Optimisation techniques to form the no-ﬁlters in a near-optimal way have
been proposed in [19].

C. Membership queries

Given an element t ∈ T , to perform a membership query the following steps are required.
• Firstly, the yes-ﬁlter of t is compared with the yes-ﬁlter of the set. If the yes-ﬁlter of t is
greater than the yes-ﬁlter of the set, the element t deﬁnitely does not belong to the set S. In
case that the yes-ﬁlter of t is less than or equal to the yes-ﬁlter of the set, the element t may
be either an element belonging to S, or a false positive. Thus, in this case, the following
step is performed.

11

Fig. 5. Set diagram of the elements to include in the yes- and no-ﬁlters, the false positives of the yes- and the no-ﬁlters and
the elements to be queried for the case with no false negatives.

• The no-ﬁlters of the set S are checked. If the no-ﬁlter of t is less than or equal to any
of the no-ﬁlters of the set then we can conclude that t was a false positive and therefore,
discarded. Otherwise, we assume that t was not a false positive of the yes-ﬁlter and that it
is an element of S.

To conclude, the yes-no BF is a generalisation of the standard BF: indeed, when r = 0, the
yes-no BF turns into the BF of length m. Keeping m ﬁxed, when r > 0, the length of the
yes-ﬁlter is reduced (compared with the case r = 0), producing an increased number of false
positives with high probability; however, at the same time, the no-ﬁlters reduce the number of
false positives as shown in the next section. The yes-no BF offers no false negatives.

IV. FALSE POSITIVE PROBABILITY OF THE YES-NO BF

Let us consider the case of yes-no BF with no false negatives in Fig. 5. The set S is the set of
elements to store in the yes-ﬁlter and the set S is the set of all the elements that, when tested,
appear to belong to the yes-ﬁlter. Consequently, S \ S = F is the set of the false positives of
the yes-ﬁlter.

The set R is the set of elements that are stored in the no-ﬁlter after the formation processing
described in Sec. III-B. The set R ⊂ F is the set of elements generating false positives for the
yes-ﬁlter which are stored in the no-ﬁlters. The set R is the set of all the elements that, when

12

tested, appear to belong to the no-ﬁlter. Consequently, R\ R = G is the set of the false positives
of the no-ﬁlter. In this case, G and S are disjoint.

If e ∈ S

c then e is discarded by the yes-ﬁlter and consequently it is not queried by the no-
ﬁlters. If e ∈ S than e is queried by the no-ﬁlter. The set S can be decomposed in the following
4 sets (see Fig. 5):

• S
• R
• (R \ R) ∩ S
• S \ S \ R
If e ∈ S, e belongs to the set S of elements that were stored in the yes-no BF.
If e ∈ R, then e was a false positive that has been discarded by the no-ﬁlters.
If e ∈ (R \ R) ∩ S = G ∩ F then e was a false positive of the no-ﬁlter but it was also a false

positive of the yes-ﬁlter so it was discarded by the no-ﬁlter.

If e ∈ S \ S \ R = F \ R then necessarily e is a false positive of the yes-no BF.
We call the set S \ S \ R = F \ R the set E.
Lemma. The probability of the set E can be formulated as

Pr[E] = (1 − Pr[S])fS +
−(Pr[S] + (1 − Pr[S])fS)fR − (1 − fR)Pr[R].

Proof:

The set S \ S is the union of the following disjoint sets:

S \ S = [S \ S \ R] ∪ [(R \ R) ∩ S] ∪ R

so that the probability Pr[E] = Pr[S \ S \ R] can be written as

Pr[E] = Pr[S \ S] − Pr[(R \ R) ∩ S] − Pr[R].

Now, Pr[S \ S] can be calculated as in (11):

Pr[S \ S] = (1 − Pr[S])fS.

The probability Pr[(R \ R) ∩ S] can be written as

Pr[(R \ R) ∩ S] = Pr[(R \ R)] − Pr[R \ S]

(13)

(14)

(15)

(16)

(17)

since the set R \ R is the union of the two disjoint sets (R \ R) ∩ S and R \ S as can be seen
in Fig. 5. Now, Pr[(R \ R)] can be computed as in (11):

Pr[(R \ R)] = (1 − Pr[R])fR.

(18)

13

while the probability Pr[R \ S] can be computed as

Pr[R \ S] = Pr[R ∩ S

c

] =

Regarding Pr[R|S

c

], since S

c

= Pr[S

] Pr[R|S
c ⊂ Rc, namely if e ∈ S

c

(19)
].
c, then necessarily e ∈ Rc, we can write

Pr[R|S

c

] = Pr[R|Rc] = fR.

Regarding Pr[S

c

] it can be expressed using (10) as:

Pr[S

c

] = 1 − Pr[S] = 1 − (Pr[S] + (1 − Pr[S])fS.

Using (21) and (20) we can rewrite (19) as

Pr[R \ S] = fR(1 − (Pr[S] + (1 − Pr[S])fS)).

Using (18) and (22) we can rewrite (17) as

Pr[(R \ R) ∩ S] = (1 − Pr[R])fR +
−(1 − (Pr[S] + (1 − Pr[S])fS))fR =
= (Pr[S] − Pr[R] + fS − Pr[S]fS)fR.

(20)

(21)

(22)

(23)

From (23) and (16) we can compute the probability of the false positives of the yes-no BF Pr[E]
deﬁned in (15) as

Pr[E] = (1 − Pr[S])fS +
−(Pr[S] + (1 − Pr[S])fS)fR − (1 − fR)Pr[R]

(24)

The probability Pr[E] in (24) is the false positive probability for e ∈ T for the yes-no BF.
It is very easy to verify that the probability of false positive of the yes-no BF is less than the
correspondent probability of false positive of a BF of the same size as the yes-ﬁlter:

Pr(E) < Pr(F )

(25)

14

where Pr(F ) is deﬁned in (11). This probability has been computed without assuming that
e ∈ S c. Instead, with the assumption that e ∈ S c, then the probability of false positives can be
written as

(26)
Since E ⊂ Sc, then Pr[E ∩ Sc] = Pr[E]. Consequently, given e ∈ Sc, Pr[Sc] = 1, Pr[S] = 0 and
the false positive probability in (24) becomes:

Pr[Sc]

.

Pr[E|Sc] =

Pr[E ∩ Sc]

Pr[E|Sc] = fS(1 − fR) − (1 − fR)Pr[R].

(27)
If we consider e ∈ Sc ∩ Rc, assuming that the no-ﬁlter has taken care of the false positives, then
Pr[R] = 0 and the false positive probability becomes:

Pr[E|Sc ∩ Rc] = fS(1 − fR).

(28)
Thus, assuming that e ∈ Sc ∩ Rc, the false positive probability of the yes-no BF depends on
the false positive probability of the yes-ﬁlter fS and on the probability 1 − fR for the no-ﬁlters,
where fR is the probability of false positives of the set of no-ﬁlters. It is easy to verify that the
probability of false positives of the yes-no BF Pr[E|Sc ∩ Rc] is smaller than the probability of
false positives of a Bloom ﬁlter of the same size of the yes-ﬁlter.

If only one no-ﬁlter is employed, the false positive probability can be explicitly written in
function of the yes-no BF parameters. The false positive probability of the yes-ﬁlter can be
approximated using (6):

The false positive probability fR of the no-ﬁlter can be approximated as

The false positive probability of the yes-no BF fE in (28) with one no-ﬁlter only could be
approximated as

fE =

1 − e− kn

p

1 − e− k(cid:48)n

q

.

(31)

(cid:17)k(cid:48)(cid:19)

However, since the choice of how to ﬁll the no-ﬁlters is related to a NP-hard problem (see
end of Sec. III-B2) it is not possible to express fR for a number of no-ﬁlters. For this reason,
since choices need to be made to implement yes-no BFs, simulations has been carried out to

.

(cid:17)k
(cid:17)k(cid:48)

.

p

1 − e− kn

fS ≈(cid:16)
fR ≈(cid:16)
(cid:17)k(cid:18)
1 −(cid:16)

1 − e− k(cid:48)n

q

(cid:16)

(29)

(30)

15

study the dependency of the number of false positive from the design parameters. As with the
standard BF, one would expect that the parameters deﬁning the structure of the yes-no BF have
to be decided upon in advance. The parameters that need to be selected are: m, r, p, q and the
values of k and k(cid:48) for the yes-ﬁlter and for the no-ﬁlters respectively.

V. EVALUATION OF THE YES-NO BF PERFORMANCE WITH RESPECT TO THE YES-NO BF

PARAMETERS

An experimental evaluation has been carried out in order to study the dependency of the false

positive rate from the yes-no BF parameters and from the set S characteristics.

The number of false positives for the yes-no BF has been quantiﬁed through simulations and
plotted against the average number of false positives of the correspondent BF calculated using
the approximate formula of the false positive probability fp in (5). Given the false positive
probability, the average number Fp of false positive occurrences can be computed as

(cid:88)

t∈T

Fp =

fp =| T | fp

(32)

since the probability is the same for each element in T .

The evaluation of the false positive performance has been carried out as function of the
cardinality of S and as a function of the yes-no BF parameters. The following values have been
used:

• m = 256, the total number of bits of the yes-no BF. This is a typical size for in-packet

forwarding applications [11]

• n = 30, the number of elements to store
• t = 100, the number of elements to query
• p = 160, the length of the yes-ﬁlter
• q = 32, the length of a no-ﬁlter
• so r = 3, the number of no-ﬁlters
• k = 4, the number of hash functions for the yes-ﬁlter
• k(cid:48) = 5, the number of hash function for the no-ﬁlter
Depending on the functionality studied each of these parameter has been varied across a

speciﬁc range as described in the following.

16

A. Evaluation of false positive performance as a function of the number of hash functions for
the yes-no BF

For the evaluation of false positive performance as a function of the number of hash functions
for the yes-ﬁlter the average number of false positive occurrences has been computed for 1 ≤
k ≤ 14. The plot in Fig. 6 shows the average number of false positives of the yes-no BF for
104 experiments together with the average number of false positive of the correspondent BF.

Fig. 6. Average number of false positive as a function of the number k of hash functions of the yes-ﬁlter. The dotted line
represents the average number of false positive of the correspondent BF of size m = 256.

The simulations show that the average number of false positive occurrences as a function of
the number of hash functions of the yes-ﬁlter has a minimum as for the classic BF. Moreover,
for small number of hash functions the number of false positive occurrences is much smaller for
the yes-no BF while for higher k the BF performs better. This is expected since the yes-ﬁlter
is smaller in length than the classic BF so as k increases the yes-ﬁlter becomes fuller than the
BF and the no-ﬁlter mechanism which improves the false positive cannot cope any longer. Just
to analyse the actual reduction in false positive occurrences, we also compare the performance
of the yes-no BF with a BF of the same size as the yes-ﬁlter. The no-ﬁlters mechanism clearly
reduces greatly the average number of fasle positive occurrences, as shown in Fig. 7, following
the results of the theoretical analysis of the false positive probability (25).

17

Fig. 7. Average number of false positive as a function of the number k of hash functions of the yes-ﬁlter. The dotted line
represents the average number of false positive of a BF of the same as the yes-ﬁlter m = 160.

For the evaluation of false positive performance as a function of the number of hash functions
for the no-ﬁlter the average number of false positive occurrences has been computed for 1 ≤
k(cid:48) ≤ 14. The plot in Fig. 8 shows the average number of false positives of the yes-no BF for
104 experiments together with the average number of false positive of the correspondent BF.

The simulations show that the average number of false positive occurrences as a function of
the number of hash functions of the no-ﬁlter has a minimum as for the classic BF. Changing the
number of hash functions of the no-ﬁlter does not inﬂuence greatly the number of false positive
occurrences and its value remains well below the correspondent value for the classic BF since
an appropriate value of k has been chosen for the number of hash function of the yes-ﬁlter.

B. Evaluation of false positive performance as a function of the number of elements to store in
the yes-no BF

For the evaluation of false positive performance as a function of the number of the elements
to store in the yes-no BF the average number of false positive occurrences has been computed
for 10 ≤ n ≤ 90. The plot in Fig. 9 shows the average number of false positives of the yes-no
BF for 104 experiments together with the average number of false positive of the correspondent
BF.

18

Fig. 8. Average number of false positive as a function of the number k(cid:48) of hash functions of the no-ﬁlter. The dotted line
represents the average number of false positive of the correspondent BF.

Fig. 9. Average number of false positive occurrences as a function of the number n of elements to store in the yes-no BF.
The dotted line represents the average number of false positive of the correspondent BF of m = 256 bits.

The simulations show that the average number of false positive occurrences as a function of
the number of elements to store in the yes-no BF is an increasing function as for the classic BF.
Moreover, for a number of elements lower than around 60 the yes-no BF offers a lower number

19

of false positive occurrences. After this threshold the classic BF performs better on average.
This is due to the fact that the number of bits dedicated to store the elements is smaller in the
yes-no BF. Just to analyse the actual reduction in false positive occurrences, we compare the
performance of the yes-no BF with a BF of the same size as the yes-ﬁlter. The yes-no BF offers
deﬁnitely much less number of false positive occurrences than the classic BF as shown in Fig.
10, following the results of the theoretical analysis of the false positive probability (25).

Fig. 10. Average number of false positive occurrences as a function of the number n of elements to store in the yes-no BF.
The dotted line represents the average number of false positive of the correspondent BF of m = 160 bits.

C. Evaluation of false positive performance as a function of the length of the no-ﬁlter

For the evaluation of false positive performance as a function of the length of the no-ﬁlter
the average number of false positive occurrences has been computed for 10 ≤ q < 60. The plot
in Fig. 11 shows the statistic of the average number of false positives of the yes-no BF for 104
experiments together with the average number of false positive of the correspondent BF. Fig. 12
show the averages together with the average number of false positive occurrences for the classic
BF.

The simulations show that the average number of false positive occurrences as a function of
the length of each no-ﬁlters has a minimum value. The number of false positive occurrences is
much lower than the correspondent value for the BF since appropriate values has been chosen for

20

Fig. 11. Statistics of number of false positive as a function of the length q of the no-ﬁlter.

Fig. 12. Average number of false positive occurrences as a function of the length q of the no-ﬁlter together with the number
of false positive occurrences of the classic BF (dotted line).

the other parameters. The length of each no-ﬁlter does not have a strong impact on the overall
results.

21

D. Evaluation of false positive performance as a function of the number of no-ﬁlters

For the evaluation of false positive performance as a function of the number of no-ﬁlters the
average number of false positive occurrences has been computed for 1 ≤ r ≤ 9. Firstly, we
consider the case in which the length p of the yes-ﬁlter is kept ﬁxed and consequently the total
length of the yes-no BF changes accordingly. Having p = 160, q = 32 and 1 ≤ r≤ 9, the total
length of the yes-no BF is m = p + qr as discussed in Sec. III. The plot in Fig. 13 shows
the average number of false positives of the yes-no BF for 104 experiments together with the
average number of false positive of the correspondent BF. The value of m is shown on the upper
x-axis.

Fig. 13. Average number of false positive occurrences as a function of the number r of no-ﬁlters, keeping the length of the
yes-ﬁlter ﬁxed, together with the number of false positive occurrences of the classic BF (dotted line). The length of the yes-no
BF is reported on the upper x-axis.

For r = 0, the yes-no BF becomes a classic BF where m = p = 160 while for greater r the
yes-no BF offers a lower number of false positives than the classic BF of the same length m.
This is expected since with more no-ﬁlters more false positives can be tracked.

Secondly, we consider the case in which the length m of the yes-no BF is kept ﬁxed and
consequently the length of the yes-ﬁlter changes accordingly. Having m = 256, q = 32 and
1 ≤ r≤ 7, the total length of the yes-ﬁlter is p = m − qr as discussed in Sec. III.

Fig. 14 shows the averages together with the average number of false positive occurrences for

the classic BF. The value of p is shown on the top x-axis.

22

Fig. 14. Average number of false positive occurrences as a function of the number r of no-ﬁlters keeping the total length of
the yes-no BF ﬁxed, together with the number of false positive occurrences of the classic BF (dotted line).The length of the
yes-ﬁlter is reported on the upper x-axis.

Again, when r = 0 the yes-no Bf becomes the classic BF, but as r increases the number of
false positive occurrences decreases. However, the function has a minimum since because the
total length of the yes-no BF is kept constant, the length p of the yes-ﬁlter will become smaller
and smaller generating too many false positives that the yes-no BF will be not be able to cope
with.

According to this study, we have chosen appropriate values of these parameters for the

application described in Sec. VIII.

VI. ALGORITHM COMPLEXITY

The processing required to form the yes-no BF can be quantiﬁed using the big O notation.
Regarding the construction of the yes-ﬁlter, the procedure is exactly the same as for the classic
BF so we do not consider this in this analysis since we want to quantify how much more
processing is required with respect to the classic BF. The complexity comes from the no-ﬁlters
formation and we analyse the case in which false negatives need to be avoided.

23

We assume that the operations to form and to query a BF can be parallelised.
First of all the set F , the set of the elements generating false positives has to be built. The
complexity of this operation can be quantiﬁed as O(|T|), where |T| is the cardinality of the set
T . This is because each element in the set T has to be checked.

Given F , if the false negatives can be tolerated then a greedy algorithm can be used to
choose in which no-ﬁlter of the set S the no-ﬁlter of the false positive can be stored. The time
complexity of a greedy algorithm can be generally estimated as linear in the number of false
positives O(|F|).

If the false negatives have to be avoided then an additional processing is required. In the worst
case scenario, the time complexity of the algorithm can be quantiﬁed as O(r |F||S|) since the
no-ﬁlter of each element in S has to be compared with the no-ﬁlter in consideration for each
false positive and in the worst case scenario this has to be repeated for all the no-ﬁlters.

Since the operation involved can be implemented as logical and, or and comparison we
can conclude that the processing overhead is only slightly more than for the classic BF at the
formation stage.

At the querying stage, the processing required by the yes-no BF is exactly the same as for
the BF, since the membership query can be implemented as a logical and and comparison for
both the data structure. BF and yes-no BF can answer membership queries in O(1) time.

VII. THE YES-NO BF FOR PACKET FORWARDING

The formulation of the yes-no BF has been inspired by the recent application of BFs in the
novel multicast forwarding fabric [11] of the PSIRP/PURSUIT information centric architecture.
However, structures like the BF and the yes-no BF can be used generally for packet forwarding
when the path is known. These structures are used as an encoding to identify paths (with one or
more destinations) and links between nodes. The yes-no BF representing an element described
in Sec. III-A is used to encode a link, where e would be a link descriptor. The yes-no BF
representing a set described in Sec. III-B is used to encode the path. Thus, the set of all links
is U, the set of links along the path is S, and the set of all the outgoing links from the nodes
along the path is T . Fig. 15 shows a schematic representation of a path of multiple destinations
where link belonging to the set S and the links belonging to the set T are differently depicted.

24

Fig. 15. Schematic representation of a path with multiple destinations.

The yes-no BF, encoding the path, is placed in the packet header. Note that slightly more
processing is required to construct the yes-no BF in comparison with the construction of the
BF: the false positive occurrences for the speciﬁc path have to be evaluated and the no-ﬁlters
have to be constructed. At a node, the yes-no BF of each outgoing link is stored. When the
packet arrives at the node, the membership query described in Sec. III-C is performed for each
of the outgoing links. Note that the membership query can be implemented with a logical and
operation and a comparison, exactly like the membership query for the BF. Therefore, we can
conclude that the yes-no BF requires a bit more processing at the stage of its formation but
the same processing for membership queries as the BF, so that the forwarding operation can be
implemented in line speed [11]. A query may result in a false positive, which translates, in our
forwarding scheme, into extra trafﬁc in the network. The match is possible along more than one
outgoing link per node so that multicast turns out to be the natural communication paradigm.
The formation of the yes-no BF is performed by an entity that has knowledge of the network
topology, this could a centralised entity [12].

VIII. EVALUATION OF THE YES-NO BF PERFORMANCE IN REALISTIC TOPOLOGIES

Although the evaluation of the yes-no BF performance could be carried out in artiﬁcially
generated topologies, we consider realistic topologies and we compare the false positive rates of
the yes-no BF and of the BF of the same size. The network topologies used in the simulation are
a collection from the Network Topology Zoo containing 261 network topologies [18]. In each
of these 261 networks, we select a long (relative to the topology) realistic forwarding path. The
forwarding path is represented as the set S containing all the links along the path, whereas all
the other links adjacent to the path, which are obviously not part of the path, are collected in

25

the set T . Second order false positives are not considered since the probability is multiplicative
and it can be considered negligible. For each of the elements of the sets S and T we consider
1000 random allocations of the position of the 1s for the yes-ﬁlter and the no-ﬁlter to simulate
the hashing. We build the yes-no BF for all the elements of S and T and calculate the number
of false positives as the average over the number of false positive occurrences for the 1000
allocations. The parameters deﬁning the yes-no BF used in the simulation are listed below:

• The total length of the yes-no BF and of the BF is m = 256 bits.
• The length of the yes-ﬁlter is p = 192 bits.
• The number of no-ﬁlters are r = 2.
• The length of each no-ﬁlter is r = 32 bits.
• The number k of hash functions used for the yes-ﬁlter is k = 4.
• The number k(cid:48) of hash functions used for the no-ﬁlters is k(cid:48) = 3.
• The number kBF of hash functions for the classic BF is kBF = 6.

These parameters have been chosen according to the analysis performed in Sec. V. The total
length, m matches typical lengths used in other studies and is comparable with the length of
the IPv6 header address ﬁelds. We do not claim that this is the optimal parameter set but the
aim of this paper is to show that the yes-no BF offers better false positive performance than
the classic BF. Fig. 16 shows the expected number of false positive occurrences of the yes-no
BF against the expected number of false positive occurrences of the BF, where it can be easily
seen that the yes-no BF offers a lower number of false positive occurrences. For example, the
top right point corresponds to a 28-hop path in the network from the TataNld topology [18]. If
the BF is used for forwarding along this path, one can expect, approximately, 0.92 false positive
occurrences; but if the yes-no BF is used, one can expect, approximately, 0.13 false positives.
The meaning of this is that if we use BFs, packets will almost certainly be diverted to a wrong
direction approximately at one point during their travel; however, if we use yes-no BFs, this will
only happen approximately to one out of eight possible yes-no BFs of the links in the network.
Note there are many very small networks for which neither the BF nor, of course, the yes-no BF
produce any false positives. They are not interesting for our comparison. On the diagram, they all
are represented by the point with the coordinates 0,0. Furthermore, there are two comparatively
large topologies, in which both the BFs and the yes-no BFs produce a relatively large number of

26

Fig. 16. The expected number of false positive occurrences of the yes-no BF against the BF.

Fig. 17. The false positive rate of the yes-no BF and of the BF against the number n of links along the path.

false positives, and, therefore, perhaps one would want to consider using a different forwarding
model.

Fig. 17 shows the false positive rate against the number of links along the path of the BF and
the yes-no BF. The result has been obtained averaging the false positive rate of paths on different
topologies having the same length. The false positive rate of the yes-no BF is consistently lower
than the false positive rate of the BF.

27

Fig. 18. The ratio between the false positive rate of the yes-no BF and of the BF as a function of the number of links encoded
in the data structure.

Fig. 18 shows the ratio of the false positive rate of the yes-no BF and of the BF fyn/fBF as
a function of the number of links (elements) encoded in the data structure, up to n = 35 links
where the yes-no BF offers a false positive rate which only a quarter of the correspondent false
positive rate of the BF.

IX. CONCLUSIONS

We have proposed a novel way of representing sets based on BFs, which we call the yes-no
BF. It requires slightly more processing at the stage of its formation and the same processing
for membership queries as the classic BF, but offers a considerably smaller number of false
positives and no false negatives. We have shown using computational experiments that the yes-
no BF outperforms the classic BF in the scenario of packet forwarding with in-packet path
encoding as introduced in the information-centric architecture PSIRP/PURSUIT. However, the
structure is general enough to be used in a wide variety of applications. Moreover, the yes-no
BF construction is dynamic and allows a choice of heuristics and optimization algorithms, as
demonstrated in [19].

ACKNOWLEDGMENT

REFERENCES

[1] B. Bloom, “Space/time trade-offs in hash coding with allowable errors,” Commun. ACM, vol. 13, no.7, pp. 422–426, 1970.

28

[2] A. Broder and M. Mitzenmacher, “Network applications of Bloom ﬁlters: A survey,” Internet Mathematics, vol. 1, no.4,

pp. 485–509, 2004.

[3] S. Takoma, C. Rothenberg, and E. Lagerspetz, “Theory and practice of Bloom ﬁlters for distributed systems,” IEEE

Communications Surveys and Tutorials, vol. 14(1), pp. 131–155, 2012.

[4] B. Donnet, B. Baynat, and T. Friedman, “Retouched Bloom ﬁlters: Allowing networked applications to trade off selected

false positives against false negatives.” Lisboa, Portugal: CoNEXT 2006, Dec 2006.

[5] C. Rothenberg, C. Macapuna, F. Verdi, and F. Magalhaes, “The deletable Bloom ﬁlter: a new member of the Bloom

family,” IEEE Communications Letters, vol. 14,no.6, pp. 557–559, 2010.

[6] L. Fan, P. Cao, J. Almeida, and A. Broder, “Summary cache: A scalable wide-area web cache sharing protocol,” IEEE/ACM

Transaction on Networking, vol. 8, no.3, pp. 281–293, 2000.

[7] D. Ficara, S. Giordano, G. Procissi, and F. Vitucci, “Multilayer compressed counting Bloom ﬁlters,” in Proceedings of the

27th Annual Joint Conference of the IEEE Computer and Communications Societies (INFOCOM), 2008, pp. 311–315.

[8] P. Almeida, C. Baquero, N. Preguica, and D. Hutchison, “Scalable Bloom ﬁlter,” Information Processing Letters, vol. 101,

no.6, pp. 255–261, 2007.

[9] H. Lim, J. Lee, and C. Yim, “Complement Bloom ﬁlter for identifying true positiveness of a Bloom ﬁlter,” IEEE

Communication Letters, vol. 19, no.11, pp. 1905–1908, 2015.

[10] L. Carrea, A. Vernitski, and M. Reed, “Optimized hash for network path encoding with minimized false positives,” Computer

Networks, vol. 58, pp. 180–191, 2014.

[11] P. Jokela, A. Zahemszky, C. E. Rothenberg, S. Arianfar, and P. Nikander, “LIPSIN: Line speed publish/subscribe inter-

networking.” Barcelona, Spain: ACM SIGCOMM ’09, Aug 2009.

[12] N. Fotiou, G. Polyzos, and D. Trossen, “Illustrating a publish/subscribe internet architecture,” Journal on Telecommunication

Systems - Springer, vol. 51, no. 4, pp. 233–245, 2012.

[13] D. Trossen, J. Riihijrvi, P. Nikander, P. Jokela, J. Kjllmand, and J. Rajahalme, “Designing, implementing and evaluating

a new internetworking architecture,” Computer Communications, vol. 35, no.17, pp. 2069–2081, 2012.

[14] A. Zahemszky, P. Jokela, M. Sarela, S. Ruponen, J. Kempf, and P. Nikander, “MPSS: Multiprotocol stateless switching.”

San Diego CA USA: 13th IEEE Global Internet Symposium 2010, Mar 2010.

[15] P. Bose, H. Guo, E. Kranakis, A. Maheshwari, P. Morin, J. Morrison, M. Smid, and Y. Tang, “On the false positive rate

of Bloom ﬁlters,” Inf. Process. Lett., vol. 108, no.4, pp. 210–213, 2008.

[16] A. Kirsch and M. Mitzenmacher, “Less hashing, same performance: Building a better Bloom ﬁlter,” Random Structures

and Algorithms, vol. 32, no.2, pp. 187–218, 2008.

[17] H. Lim, N. Lee, J. Lee, and C. Yim, “Reducing false positives of a Bloom ﬁlter using cross-checking Bloom ﬁlters,” Appl.

Math. Inf. Sci., vol. 8, no.4, pp. 1865–1877, 2014.

[18] S. Knight, H. Nguyen, N. Falkner, R. Bowden, and M. Roughan, “The Internet topology zoo,” IEEE Journal on Selected

Areas in Communications, vol. 29, no.9, pp. 1765–1775, 2011.

[19] X. Yang, A. Vernitski, and L. Carrea, “An approximate dynamic programming approach for improving accuracy of lossy

data compression by Bloom ﬁlters,” European Journal of Operational Research - IN PRESS.

