6
1
0
2

 
r
a

 

M
2
1

 
 
]
h
p
-
t
n
a
u
q
[
 
 

1
v
8
4
9
3
0

.

3
0
6
1
:
v
i
X
r
a

Universal fault-tolerant gates on nondegenerate stabilizer codes

Theodore J. Yoder, Ryuji Takagi, and Isaac L. Chuang
Massachusetts Institute of Technology, Cambridge, MA 02139

It is an oft cited fact that no quantum code can support a set of fault-tolerant logical gates that is
both universal and transversal. This no-go theorem is generally responsible for the interest in alter-
native universality constructions including magic state distillation. Widely overlooked, however, is
the possibility of non-transversal, yet still fault-tolerant, gates that work directly on small quantum
codes. Here we demonstrate precisely the existence of such gates. In particular, we show how the
limits of non-transversality can be overcome by performing rounds of intermediate error-correction
to create logical gates on stabilizer codes that use no ancillas other than those required for syn-
drome measurement. Moreover, the logical gates we construct, the most prominent examples being
Toﬀoli and controlled-controlled-Z, often complete universal gate sets on their codes. We detail
such universal constructions for the smallest quantum codes, the 5-qubit and 7-qubit codes, and
then proceed to generalize the approach. One remarkable result of this generalization is that any
nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Cliﬀord gates has
a universal set of fault-tolerant gates. Another is the interaction of logical qubits across diﬀerent
stabilizer codes, which, for instance, implies a broadly applicable method of code switching.

PACS numbers: 03.67.Pp, 03.67.Ac

I.

INTRODUCTION

One of the crucial concepts in error-correcting codes is
that of logical circuits – a set of circuits {Ci} that give
the ability to carry out a set of operations {Ui} directly
on encoded data, rather than performing the risky proce-
dure of decoding, applying Ui, and re-encoding. In fact,
the latter procedure is forbidden if we insist on each Ci
being a fault-tolerant logical circuit, for which the fail-
ure of any one component in Ci never leads to an un-
correctable error on the encoded data.
If, in addition,
the set {Ui} is universal for the computational model in
question (e.g. classical or quantum computation), then
the set of logical circuits {Ci} is said to be universal, and
the error-correcting code in question could in principle be
used for all computational purposes without ever needing
to decode, a hallowed ability in quantum halls especially,
where decoherence remains the bane of all practical im-
plementations of quantum algorithms.

In the quantum computational model, one paradigm
for designing fault-tolerant logical gates reigns supreme,
and that is transversality. A logical circuit is transversal
if all physical qubits have interacted with at most one
physical qubit from each code block, and if such a design
preserves the code space then it is automatically fault-
tolerant. Indeed, many quantum codes, such as Steane’s
7-qubit code [1], are highly regarded exactly because they
have important, and perhaps several important, transver-
sal gates.

Unfortunately, it is a well-known theorem [2–4] that
there is no quantum code with a universal set of transver-
sal logical circuits. This fact means other methods must
be used to perform universal,
fault-tolerant quantum
computation. The most common approach is that of
magic states [5, 6], encoded ancilla qubits that, combined
with available transversal circuits (usually implementing
Cliﬀord operations), serve to complete a universal set of

logical circuits (usually by implementing a T or Toﬀoli
gate).
Ideally, these magic states would be eﬃciently
constructible themselves, but current so-called distilla-
tion procedures actually incur large overheads in terms
of time and qubits [7], making magic states costly, espe-
cially for present-day experiments of only tens of qubits.
It is therefore fortunate that other approaches to by-
pass the universal-transversal no-go theorem exist. Some
involve code switching — the transversal circuits on two
codes together might complete a universal set, encourag-
ing development of a method to exchange data between
the two code spaces. Simple procedures have been de-
vised for conversions between speciﬁc codes, such as be-
tween the 5-qubit and 7-qubit [8] and between quantum
Reed-Muller codes [9]. Another workaround for the no-
go theorem uses tri-orthogonal subsystem codes [10], the
smallest of which is 15-qubits, to implement a universal,
transversal set of gates without code switching, but with
additional error-correction on the gauge qubits. Lastly,
concatenated coding can turn two codes with comple-
mentary transversal gate sets into a single large code with
a universal, but not transversal, gate set [11].

Here we

complement

the myriad previous ap-
proaches to universal fault-tolerance by developing non-
transversal, yet still fault-tolerant, circuits implement-
ing logical gates on stabilizer codes. We call this ap-
proach pieceable fault-tolerance. In fact, pieceable fault-
tolerance provably provides every error-correcting non-
degenerate stabilizer code at least one new fault-tolerant
gate. As examples, we create a logical CZ gate on the
5-qubit code (Section III) and logical CCZ gates on the
5-qubit (III) and 7-qubit (IV) codes, completing univer-
sal sets of gates on those codes. Also notable is that
our circuits use no ancillas other than those required for
error-correction — in particular, we use no magic-states.
Instead, our circuits feature multiple rounds of error cor-
rection, to correct errors before they propagate too badly

through the non-transversal circuit.

We also provide suﬃcient conditions for similar cir-
cuits to work on larger codes more generally (V). Non-
degeneracy is suﬃcient (albeit not necessary) for a code
to have a pieceably fault-tolerant gate, so a remarkable
result of this generalization is that any nondegenerate
stabilizer code with a universal set of fault-tolerant local
(i.e. single-qubit) Cliﬀord logical gates automatically has
a universal set of logical gates that are pieceably fault-
tolerant. Compare to magic states, where to achieve the
same universality, even with much more overhead, the
entire set of logical Cliﬀords is required [5]. Moreover,
nondegenerate CSS codes just need any fault-tolerant
local Cliﬀord to achieve the same universality. Finally,
we show that pieceable fault-tolerance can also perform
gates between diﬀerent codes, and thus act as a quite
general method of code switching.

Noteworthy ideas in the literature most closely related
to pieceable fault-tolerance are the code switching exam-
ple of Hill et. al. [8] and code deformations of Bombin
and Martin-Delgado [12, 13]. In the former, a circuit of
Cliﬀord gates with error-correction performed after each
gate is used to switch between the 5-qubit and 7-qubit
codes. In the latter, logical initialization, measurement,
and Cliﬀord gates are performed on surface codes by ma-
nipulating the geometry of the surface while correcting
errors as they arise. Both techniques are similar to piece-
able fault-tolerance as the code undergoes transforma-
tions to several intermediate codes, each with distance
large enough to correct any errors that may have arisen.
However, both also do not generate logical universality on
their own, something we show pieceable fault-tolerance
can indeed provide.

Achieving this universality also requires fundamentally
new tools. For instance, we develop original circuit de-
signs, called round-robin constructions, to perform our
logical gates. Additionally, we create an adaptive pro-
cedure for error-correction on the non-stabilizer interme-
diate codes we encounter. The proﬁtable use of non-
stabilizer codes is perhaps novel and interesting in it of
itself. A fault-tolerance overview, the deﬁnition of piece-
able fault-tolerance, and a summary of these new tools
are the goals of the next section.

II. A DESIGN METHODOLOGY FOR
FAULT-TOLERANT LOGICAL GATES

Quantum codes operate by the “ﬁght entanglement
with entanglement” [14] mantra — to protect sensitive
data from a noisy, nosy environment, introduce addi-
tional degrees of freedom and encode the data in globally
entangled states. Local errors have no chance of rearrang-
ing the long range entanglement to aﬀect the data, and
so our information is secure.

However, if we want to legitimately alter the data, this
same security becomes a hassle. To perform quantum
gates on the encoded data, we are forced to create cir-

2

cuits manipulating globally entangled states, and more-
over, these circuits must not corrupt the data, even if
they themselves are faulty! In this section, we overview
this design challenge, culminating in our solution, piece-
ably fault-tolerant logical gates.

A. Codes, logical operations, and error-correction

An (cid:74)n, k(cid:75) quantum code L using n physical qubits

to encode k data qubits is essentially a collection of 2k
orthogonal n-qubit code states {|0(cid:105),|1(cid:105), . . . ,|2k(cid:105)}. The
code space CL is the span of the code states.
In this
sense, quantum codes are nothing more than a strange
basis for a subspace of a larger Hilbert space.

However, to be practically useful the code states must
also satisfy certain properties. Not least of all, the code
states should be far enough separated that errors local-
ized to only a few physical qubits cannot undetectably
change any code states. Also, it would be preferable if
such error channels could be, not only detected, but re-
versed and the code space restored to normal.

Stabilizer codes [15–17] were the ﬁrst broad class of
quantum codes that could be designed with such error-
correcting properties, and they are still the most com-
mon, and promising, type of quantum code today. Stabi-
lizer codes are built on the foundation of the Pauli group.
The Pauli operators on a single-qubit are the familiar
σ0 = I, σ1 = X, σ2 = Y , σ3 = Z. The Pauli group on n
qubits Pn is made of tensor products of these,
σhj : a, hj ∈ {0, 1, 2, 3}}.

Pn = {ia

(1)

n(cid:79)

j=1

As for notation, given a Pauli operator p ∈ Pn we will
denote the ith member of the tensor product pi, the num-
ber of non-identity members of the tensor product as the
weight |p|, and the set of qubits on which p acts non-
identically as the support supp(p).
A subgroup of Pn, called the stabilizer group S, de-
ﬁnes the code space CL of a stabilizer code as the +1
eigenspace of all Pauli operators in S. In order for this
to be nontrivial, we must have −I⊗n (cid:54)∈ S, which is equiv-
alent to two conditions: ﬁrst, S is abelian, and second,
all g ∈ S have signs ±1 (no sign of ±i). Because every
Pauli operator has only ±1 eigenspaces of equal size, we
evidently need n− k independent Pauli operators to gen-
erate S and reduce the 2n dimensional Hilbert space of n
qubits to 2k = 2n/2n−k dimensional, the size of the code
space. These generators are not unique, but nevertheless

we will label (a canonical choice of) them (cid:101)Z1,(cid:101)Z2, . . .(cid:101)Zn−k

(2)
where (cid:104)·(cid:105) indicates a list of generators rather than a list
of all group elements.

Yet, this cannot be all there is to a stabilizer code, be-
cause only the code space, and not the code states, has so

and write

S = (cid:104)(cid:101)Z1,(cid:101)Z2, . . . ,(cid:101)Zn−k(cid:105),

far been deﬁned. To complete the stabilizer code, choose
real-signed Pauli operators Z 1, . . . , Z k and X 1, . . . , X k
from Pn that are independent from yet commute with
both the stabilizer generators and each other. The only
exception is for Z i and X i, which should anticommute
+1 eigenspace, the full group (cid:104)(cid:101)Z1, . . . ,(cid:101)Zn−k, Z 1, . . . , Z k(cid:105)
for each i. Since any set of n independent Pauli opera-
tors from Pn have a unique state in their simultaneous
are given by |b(cid:105) =(cid:81)
deﬁnes a state |0(cid:105). The remaining encoded basis states
j |0(cid:105) for all n-bit strings b. Ev-
idently, the X j operators act as encoded, or logical, X
gates and the Z j operators act as logical Z gates. Logical
Y gates are given by Y j = iX jZ j.

j X

bj

However, there is some freedom in choice of logical
operator even now. Indeed, any member of the stabilizer
coset Z iS acts exactly as Z i does on the code space, and
likewise with the cosets X iS and Y iS compared with X i
and Y i. The union of these 3k cosets and of the stabilizer
itself forms the normalizer,

N (S) = (cid:104)(cid:101)Z1, . . . ,(cid:101)Zn−k, Z 1, . . . , Z k, X 1, . . . , X k(cid:105).

(3)
The lowest weight element of N (S)\S has weight equal to
the code distance d, which can be conveniently thought
of as the fewest number of qubits which need to be acted
upon to undetectably alter the code states. The double
bracket notation for quantum codes is often extended

from(cid:74)n, k(cid:75) to include the code distance as in(cid:74)n, k, d(cid:75).
pose U =(cid:80)
U =(cid:80)

Nevertheless, logical versions of the Pauli operators are
not enough to perform arbitrary operations on encoded
data. We should deﬁne logical versions of other unitary
gates, say U , as well. Since the Pauli group Pk is a
complete basis for the k-qubit unitaries, we can decom-
ajpj for some aj ∈ R. A logical ver-
pj∈Pk
sion of U , call it U , should be similarly decomposed as
ajpjsj, where sj ∈ S and pj is the logical
version of pj wherein each occurrence of Xi, Yi, or Zi is
replaced by X i, Y i, or Z i, respectively. The freedom of
the stabilizer is present in the form of the arbitrary sj.
Slightly more generally, we deﬁne a logical operation as
any operator U that preserves the code space — that is,
U(|ψ(cid:105)) ∈ CL for all |ψ(cid:105) ∈ CL.

pj∈Pk

Where does error-correction ﬁt in this picture of code
states and code spaces? Well, one thing an error-
correction operation EC should not do is change code
states. That is, EC(|ψ(cid:105)) = |ψ(cid:105) for all |ψ(cid:105) ∈ CL. At the
risk of over-generalization, we will actually take this con-
dition as our deﬁnition — an error-correction operation
is any operation that preserves all code states. Note that
even the trivial I⊗n is an error-correction operation un-
der this deﬁnition. We deﬁne error-correction this way
because it makes our later deﬁnition of pieceable fault-
tolerance most general.

The usual notion of error-correction we shall call com-
plete error-correction EC.
In this case, for any Pauli
error E (note that all error channels can be decom-
posed into Pauli errors [18]) of weight less than d/2,

3
EC(E|ψ(cid:105)) = |ψ(cid:105). There are several known methods for
complete error-correction on quantum codes, including
methods due to Shor [19], Steane [20, 21], and Knill [22].
We assume that every stabilizer code L comes equipped
with a canonical method of complete error-correction and
denote it ECL.

B. Circuits, faults, and fault-tolerance

It is important to distinguish between what a logical
operation or error-correction does, which we deﬁned in
the previous section as code space preserving or code
state preserving, respectively, from its implementation,
a circuit. Circuits are constructed from basic operations
on physical qubits, including gates, |0(cid:105) state preparation,
and single-qubit measurement. The collection of allowed
physical operations, or components, will be denoted AP .
A circuit C then is nothing more than an ordered list of
these physical operations C = {cm, cm−1, . . . , c1}. If the
sequential action of these components, from right to left,
performs a logical unitary gate, then the circuit can be
called a logical circuit, and if it performs error-correction,
then it can be called an error-correction circuit. To be
most realistic, we could insist on dividing a circuit into
several time steps and require each qubit to be acted
upon during each time step, even if it is only by an iden-
tity operation. For most purposes we will treat circuits as
operators and combine them with multiplication C2 · C1,
with C1 applied before C2.

The fundamental problem we face in quantum error-
correction is that the physical components of any circuit
can be faulty and introduce errors to the qubits they act
upon. The standard model of faulty components, used in
essentially every discussion of fault-tolerance [17, 23–25],
restricts the way that a component c ∈ AP can fail by
saying that any faulty version of c can be modeled as c fol-
lowed by an arbitrary error channel acting on the qubits
in the support of c. A correlated error between diﬀerent
qubits therefore only arises when those qubits are explic-
itly coupled by a physical component. It is an interesting
and important fact that these analog-like error channels
can be “digitized” [18]. That is, from the perspective of
an error-correcting code, any error channel can be viewed
as the random application of an (unintended) Pauli oper-
ator. In turn, these Pauli operators can be decomposed
into single-qubit Pauli errors. For example, we already
discussed that any complete error correction of a distance
d quantum code can correct t < d/2 single-qubit errors.
The solution to the problem of faulty components is to
design fault-tolerant circuits. Such circuits are created
with a quantum code L with a complete error-correction
operator ECL in mind. We say a logical circuit C is fault-
tolerant (with respect to L) if any single faulty compo-
nent in the combined circuit C · ECL creates only errors
correctable by an ideal version of ECL performed after-
ward. Whether the circuit is fault-tolerant or not might
be said to be judged by this ﬁnal ideal ECL. Since errors

arising from faulty components in the middle of C · ECL
must be propagated to the end of the circuit before be-
ing corrected, it is crucial that components of C do not
couple too many qubits within a single code block so
that the spread of errors is limited. Also, in correspon-
dence with the exREC formalism [25], it is important
to include the leading complete error-correction, because
input errors to C arise from faults in the previous round
of error-correction.

The deﬁnitions of fault-tolerance and of faulty com-
ponents suggest the following suﬃcient design methodol-
ogy for logical gates — a logical circuit is evidently fault-
tolerant if all qubits interact (either directly or indirectly)
with fewer than t qubits in any other code block and fewer
than t− 1 qubits in their own blocks and t < d/2. In this
case, called t-transversality [11], the standard model of
faulty components implies that any one code block can-
not accumulate more than t single-qubit errors assuming
only a single faulty component. For d = 3 codes, the es-
sential concept is 1-transversality, a property which most
current logical circuit designs possess.

However, it can be proved that transversality is not
enough — for no quantum code can we create a quan-
tum universal set of logical gates with transversal circuits
alone [3, 4]. This fact has prompted other techniques of
logical circuit design to complete a universal logical gate
set. Some of the largest breakthroughs have been uni-
versality with transversal Cliﬀord gates and magic an-
cillas [5], with a transversal gate set but with a gauge
qubit reset [10], with non-transversal constructions on
large codes built as concatenations of smaller codes with
complementary transversal gate sets [11], and with code-
switching techniques [8, 9] to switch between codes with
complementary transversal gate sets.

C. Pieceable fault-tolerance

We now deﬁne our method to provide universality
without transversality. We are motivated by a sim-
ple idea: even if an entire logical circuit is not fault-
tolerant, parts of the circuit may be. If we perform error-
correction partway through the circuit, perhaps we can
quell the propagation of errors before they become uncor-
rectable. This idea was used before in the fault-tolerant
code switching technique of Hill et. al. [8], and here we
provide a generalization, one that succeeds in making
even some non-Cliﬀord circuits fault-tolerant.

To make this idea precise, begin with a logical circuit C
for some logical gate for a quantum code L. Decompose
this logical circuit into pieces C = Cm·Cm−1·. . .·C1. Af-
ter each partial logical gate Ci, there is still a code space
and code states, and if L was a stabilizer code there is
still a stabilizer and logical Pauli operators (though each
may be non-Pauli if Ci is non-Cliﬀord). Thus, we can
insert code state preserving operations, error-corrections
ECi, after each piece without altering the logical eﬀect

4

of C. We now have a modiﬁed circuit,

(cid:101)C = ECm · Cm · ECm−1 · Cm−1 · . . . · EC1 · C1.
If such a modiﬁed circuit can be found and (cid:101)C is fault-

(4)

tolerant in the traditional sense, then we say that C is
pieceably fault-tolerant (in m pieces). We also make a
distinction between any ancilla qubits used during the
circuit pieces Ci, called functional ancillas, and those
used during ECi, called error-correction ancillas. All of
our constructions use no functional ancillas.

A few things should be clariﬁed about the deﬁnition.
First, a traditionally fault-tolerant circuit C is evidently

pieceably fault-tolerant in one piece because (cid:101)C = EC1 ·

C = C is traditionally fault-tolerant when we take EC1
to be the trivial error-correction I⊗n.

Second, we include the ﬁnal error-correction ECm even
though the code space has already returned to that of
L because, for full generality, we may want to perform
a round of error-correction before we have our circuit’s
fault-tolerance judged by the ideal ECL, as the exREC
deﬁnition says. For instance, we will see examples where
the intermediate error-corrections share classical syn-
drome data with ECm so that the set of errors ECm
corrects is diﬀerent than that ECL would. If ECm is not
needed, however, it can always be set to I⊗n and remain
in line with the deﬁnition.

Third, whenever the stabilizer becomes non-Pauli, in-
termediate error-corrections will be trickier than simply
CAT state measurement of all stabilizers. In those cases,
we must be extra careful to construct circuits that correct
all errors we need to correct without introducing errors
that cannot be corrected in the next round. The quan-
tum error-correcting conditions [18], although providing
a necessary condition for such error-correcting circuitry
to exist, do not provide a suﬃcient one.

Finally, note that we do not require an intermediate
error-correction ECj to correct all errors resulting from
one fault in the previous circuitry. Although suﬃcient
to guarantee pieceable fault-tolerance, such a condition
is not necessary. Indeed, to simplify the circuitry of ECj
and mitigate the number of errors it might introduce it-
self, we will often intentionally let errors slip by an inter-
mediate error-correction as long as they are correctable
in some subsequent round (often the ﬁnal round).

At this point, it may not actually be clear that piece-
able fault-tolerance is going to do anything interesting.
Nevertheless, our spirits might be buoyed by the example
in Hill et. al. [8]. After all, being able to switch from the
5-qubit to 7-qubit codes in a pieceably fault-tolerant fash-
ion immediately endows the 5-qubit code with a piece-
ably fault-tolerant CZ gate, because the 7-qubit code has
a transversal one.

In Section III, we will construct a signiﬁcantly sim-
pler CZ gate for the 5-qubit code by a pieceably fault-
tolerant construction in two pieces. Our CZ construc-
tion also suggest a similar design for a pieceably fault-
tolerant logical CCZ gate on the 5-qubit code. Notably,

this completes a universal set of gates for the 5-qubit
code, which already has a transversal set of single-qubit
Cliﬀords. In Section IV, we develop a similar CCZ con-
struction for the 7-qubit code. Moreover, in Section V,
we show that all nondegenerate stabilizer codes have a
pieceably fault-tolerant logical gate equivalent to CCZ
under local Cliﬀord gates. But wait. There is more that
is possible with pieceable fault-tolerance. For any two
diﬀerent nondegenerate stabilizer codes, we can perform
some logical gate locally Cliﬀord equivalent to a CZ gate
between them. This for instance allows pieceably fault-
tolerant SWAP gates between diﬀerent codes (when they
have appropriate fault-tolerant local Cliﬀords), provid-
ing perhaps the broadest method of code switching yet
known, at least when no functional ancillas are used. Fi-
nally, each of these statements generalizes to ChZ and
ChX gates, where h is an integer specifying the number
of control qubits (e.g. C1Z is a CZ gate and C2Z is a
CCZ. We will denote what is usually called CNOT by
CX and Toﬀoli by C2X = CCX).

D. Additional pieceable concepts

We take the time now to introduce some terminology
applying to pieceably fault-tolerant circuits in general.
We use these concepts, too, for our speciﬁc constructions.
Let us ﬁrst try to envision what the code stabilizer
might look like after several pieces C1r = Cr·Cr−1·. . .·C1
of the logical circuit. We will assume C1r is unitary for
this discussion. Basic stabilizer theory tells us that, if
the stabilizer group began as S ≤ Pn, then after C1r, we
†
will have Sr = {C1rsC
1r : s ∈ S}. If C1r is non-Cliﬀord,
then at least some members of Sr may be non-Pauli. How
does error-correction work for such a stabilizer?

(cid:80)

First, note that while members of Sr might not be
Pauli, each is at least both hermitian and unitary, be-
cause all s ∈ S were. Each also still has two eigenspaces,
with eigenvalues ±1, that are equally sized. The circuit
in Fig. 1a still serves to measure elements of Sr. So again
we can measure a generating set of Sr and apply a re-
covery operation. What has changed is that the recovery
may not be a member of Pn.
How does this correction work exactly? Given a set of
errors E = {Ei}, decompose each error into a sum Ei =
j Fij of operators Fij, each of which either commutes
or anticommutes with every element of N (Sr). This is
possible because each element of N (Sr) is hermitian and
unitary. The old set of errors E is correctable if the new
set of errors F = {Fij} is correctable, and the latter is
correctable exactly when Fij and Fhk having the same
commutation relations with elements of Sr implies that
both have the same commutation relations with elements
of N (Sr). The recovery is performed by measuring a
generating set of Sr to ﬁnd a syndrome and applying
to the code qubits some Fij with commutation relations
corresponding to that syndrome.

The procedure just described is essentially the error-

5

correcting conditions [26, 27] for codes deﬁned by a sta-
bilizer that is not necessarily Pauli, but still hermitian
and unitary. However, as we have already mentioned in
Section II C, it is important to also do this correction in
a manner introducing few input errors to the next piece.
What form can these input errors take? We ﬁrst need
to recognize that some errors are contagious, in the sense
that they propagate other errors within some piece Ci.
We deﬁne the set of contagious errors of a pieceable cir-
cuit C as

EC = {E ∈ Pn : ∃i s.t. [E, Ci] (cid:54)= 0}.

(5)

All other errors, however, those that commute with all
pieces Ci, are allowable input errors. Also, we can never
prevent error-correction from introducing single-qubit er-
rors to the next piece, and so single-qubit errors must also
be allowable input errors.

So our goal at intermediate error-correction should be
to correct all contagious errors and do so in such a way
that only noncontagious and single-qubit errors are ever
possibly allowed to enter the next piece of the circuit.
An immensely helpful tool in this regard is the constant
stabilizer of the circuit C, which we deﬁne as

SC = {s ∈ S : ∀i, [s, Ci] = 0}.

(6)

The beneﬁt of SC, which note is a subgroup of the whole
stabilizer S, is that all its members remain Pauli through-
out the entirety of the pieceable circuit C. The upshot is
that we can always measure elements of SC with the CAT
state method, Fig. 1c, and be assured that this process
will not introduce more than a single-qubit error to the
code qubits. The other stabilizers, those we call noncon-
stant because they do not commute with some piece of
C, are not guaranteed to have the same property, failing
speciﬁcally when they are non-Pauli.

This suggests an adaptive error-correction procedure
to be used whenever we have both constant and non-
Pauli nonconstant stabilizers. We will require that con-
stant stabilizers can detect all contagious errors. The
procedure begins by measuring the constant stabilizers.
If an error is not detected, then we know that no conta-
gious errors have occurred. We can therefore let whatever
errors have occurred (if any) pass through uncorrected.
If an error has been detected, then we know a fault has
occurred, and, barring a second fault, future stabilizer
measurements will be faultless. Thus, measure the non-
constant stabilizers, deduce what error has occurred, and
correct it.

Notice that the constant stabilizers have been used to
guarantee that the measurement of the nonconstant sta-
bilizers proceeds reliably, without any faults. We will
call this a reliability guarantee on the nonconstant stabi-
lizers. This is necessary because faulty measurement of
nonconstant stabilizers can introduce contagious errors
to the next piece of the circuit, which may allow errors
to spread out-of-hand. Consider for instance failure of
the CCZ gate in Fig. 1d.

ful in general will be detailed later in Section V, and in
particular as Algs. 1 and 2.

6

As for pieceable constructions, one type of circuit is our
main innovation in logical circuits and makes our system-
atic study of pieceable fault-tolerance possible. We call
it the round-robin design. Given an h-qubit gate U and
disjoint sets of qubits Λ1, Λ2, . . . , Λh, the round-robin cir-

cuit of U on {Λi} is(cid:89)
(cid:89)

··· (cid:89)

j1∈Λ1

j2∈Λ2

jh∈Λh

U (j1, j2, . . . , jh).

(7)

robin circuits, we will refer to qubits in Λ =(cid:83)h

All of our new pieceably fault-tolerant logical construc-
tions in fact are of the round-robin variety with diﬀerent
choices of U and the sets Λi. When it comes to round-
j=1 Λj as
active qubits and any non-ancilla qubits not in Λ as idle.

III. THE 5-QUBIT CODE

Having overviewed the design of logical circuits in the-
ory and deﬁned our particular method, we now get our
hands dirty and do some actual circuit designing, be-
ginning with the 5-qubit code. We show how to make
fault-tolerant CZ and CCZ gates on the 5-qubit code.
More than these are possible in the formalism of piece-
able fault-tolerance, but we save the most general proofs
until Section V. Our goal here is to present concrete ex-
amples of pieceably fault-tolerant logic on a small quan-
tum code. This includes examples of contagious errors,
constant stabilizers, PARSEC, and round-robin circuits,
concepts which were introduced only very broadly in the
previous section.

A. Transversal gates

The 5-qubit quantum code, a (cid:74)5, 1, 3(cid:75) stabilizer code,

was one of the earliest quantum codes to be discovered
[27, 28] and is the smallest quantum code of distance 3.
The stabilizer and normalizer of the 5-qubit code can be
written as

(cid:42) ZZXIX

(cid:43)

S5 =

XZZXI
IXZZX
XIXZZ
Z 5 = −XIZIX
X 5 = −Y IXIY.

(8)

(9)

(10)

Notice that we have deviated from the standard presen-
tation of Z 5 = ZZZZZ and X 5 = XXXXX to versions
that are equivalent under multiplication by stabilizers,
and also have the lowest possible weight.

It is well-known that the 5-qubit code supports a uni-
versal, transversal set of single-qubit Cliﬀord operations.

FIG. 1:
(a) The method to measure a hermitian and unitary
n-qubit operator U [18]. When the result of the Z-basis mea-
surement is b = ±1 the state of the lower qubit is projected
into the ±1 eigenspace of U . (b) The method applied to mea-
suring a Pauli XIZ on three code qubits. (c) The method
√
made fault-tolerant by using a veriﬁed 2-qubit CAT state,
2CAT = (|00(cid:105) + |11(cid:105))/
2 [19]. The measurement is now of
the parity of the ancilla qubits. (d) The CAT state method for
measuring a non-Pauli operator X1CZ(2, 3). Strictly speaking
this measurement is not fault-tolerant, because the failure of
the CCZ gate can cause two errors on the code qubits (which
is generally uncorrectable if the code has distance 3). This is
why we are so careful about measuring non-Pauli operators.

A second guarantee can be given for a nonconstant sta-
bilizer as well, which, while not strictly necessary, is con-
venient when we want to think about errors as Paulis. To
deﬁne this guarantee, imagine that we have a set of Pauli
errors E ⊆ Pn entering an intermediate error-correction
stage. Rather than applying a non-Pauli recovery, as the
generalized error-correction conditions described above
say to do, we want to apply Pauli recovery operations
only. Measurement of a stabilizer generator g eliminates
the possibility of some Pauli errors, but to measure g re-
quires knowing that each possible Pauli error remaining
either commutes or anticommutes with g. For generators
of the constant stabilizer g ∈ SC this is trivial, but for
a nonconstant stabilizer t ∈ S \ SC, there is no reason a
priori to assume the commutation guarantee for t is true.
The way we solve this problem is with a four-step
procedure — (1) measure the constant stabilizers, (2)
partially correct some Pauli errors so that commutation
guarantees exist on nonconstant stabilizers, (3) measure
the nonconstant stabilizers, and (4) complete the re-
covery. Notice that steps (1), (3), (4) we had already
planned to use to assure a reliability guarantee. Step
(2) has been added so that recovery, though now split
into two stages (2) and (4), consists entirely of Pauli op-
erators. We call this our Procedure for Adaptive, Reli-
able Stabilizer Error-Correction or PARSEC, and it will
play a prominent role in our non-Cliﬀord pieceably fault-
tolerant constructions.

We note that PARSEC generally has these four-steps,
but because it is adaptive some may be skipped in any
one instance, and there are other variations depending
on the code. The PARSEC variants we ﬁnd most use-

code to an equivalent (cid:74)5, 1, 3(cid:75) code, which we will refer

to as the 5(cid:48)-qubit code, with

(cid:43)

(cid:42) −Y ZXIZ

−ZZZXI
−IXZZZ
−ZIXZY

S(cid:48)
5 =

(cid:48)
5 = ZIZIZ
(cid:48)
5 = XIXIX.

Z

X

7

(12)

(13)

(14)

Label qubits in the ﬁrst code block jA and qubits in the
second code block kB. Now it is simple to check that the
round-robin circuit of CZ gates,

CZ(jA, kB),

(15)

(cid:89)

j,k∈{1,3,5}

5 ⊗ S(cid:48)

which contains nine CZ gates total, preserves the stabi-
lizer S(cid:48)
5 and also eﬀects the appropriate transforma-
tion on the normalizers of codeblocks A and B,
Z A ⊗ I B → Z A ⊗ I B, I A ⊗ Z B → I A ⊗ Z B,
X A ⊗ I B → X A ⊗ Z B, I A ⊗ X B → Z A ⊗ X B.

(17)

(16)

Note that in this round-robin instance, the qubits 1, 3, 5
of either block are the active qubits, and qubits 2, 4 are
the idle qubits.

Breaking the round-robin circuit Eq. (15) after any six
CZs that touch no single qubit more than twice, is suf-
ﬁcient to guarantee pieceable fault-tolerance. One ex-
ample of such a decomposition is shown in Fig. 3. To
use the language of Section II B, the pieces should be 2-
transversal. The intuitive explanation of why this works,
is that, while the 5-qubit code can only correct single-
qubit errors when errors are randomly distributed across
all code qubits, if errors are restricted to two known loca-
tions, then all errors on those two qubits are correctable.
By sharing information about the stabilizers they have
measured, code blocks A and B can both correct indi-
vidual, uncorrelated errors if they exist, and inform each
other about possible propagation of errors from one block
to the other, a propagation that will aﬀect at most two
known qubits in the other block.

Anthropomorphizing aside, we can actually check that
all errors introduced by components in Fig. 3(a) are cor-
rectable by measuring the stabilizers of the appropriate

code after Fig. 3(a). The code in question is a(cid:74)10, 2, 3(cid:75)

stabilizer code with stabilizer generators

(cid:42) −Y ZXIZIIZIZ −ZIZIIZIXZY

−ZZZXIIIIII −IIIIIIXZZZ
−IXZZZIIIII −IIIIIZZZXI
−ZIXZY ZIIIZ −ZIIIZY ZXIZ

(cid:43)

S10 =

.

(18)

Note that the ﬁrst and last rows of generators, those with
Pauli weight on both blocks, are nonconstant stabilizers,
and the remaining four generators are constant stabiliz-
ers, since they commute with the round-robin circuit,

FIG. 2: Transversal implementations of (a) the octahedral
gate K = SH and (b) the Hadamard gate H on the 5-qubit
code.

To begin with, for sx, sy, sz ∈ {−, +}, all eight members
of the family of single-qubit octahedral gates

√
Ksxsysz = ei π
3

3

(sxX+syY +szZ),

(11)

sxsysz

are transversal on the 5-qubit code in the obvious way
K sxsysz = K⊗5
. A special case that we will name
√
and use often is K+++ = SH := K, where S = diag(1, i)
and H = (X + Z)/
2. The set of transversal single-
qubit Cliﬀord operations can therefore be completed by
implementing a logical Hadamard gate as H = PπH⊗5,
where Pπ is an appropriate permutation of the ﬁve qubits,
one example of which is shown in Fig. 2b.

Gottesman [29] gave a way to complete the set of fault-
tolerant Cliﬀord operations on the 5-qubit code. He
noted that a three-qubit Cliﬀord gate T3 is transversal
on the 5-qubit code, and supplemented with measure-
ment and single-qubit Cliﬀord gates, can provide a fault-
tolerant implementation of CX as well. There are a cou-
ple downsides to this approach. First, T3 is a complicated
gate. To implement T3 on physical qubits will likely re-
quire compiling into simple one- and two-qubit Cliﬀord
gates, as experiments will not have direct access to T3.
Second, implementing logical CX with T3 requires the
use of ﬁve functional ancilla qubits making up the third
5-qubit code block that is eventually measured and dis-
carded.

B. Pieceably fault-tolerant CZ

Our ﬁrst goal is to develop a pieceably fault-tolerant
logical circuit for CZ on the 5-qubit code that uses no
functional ancilla qubits.
In fact, our pieceably fault-
tolerant circuit consists of only two pieces. Moreover, we
will be able to easily generalize this design to pieceably
fault-tolerant logical CCZ (in four pieces) on the 5-qubit
code.

Both pieces of the pieceably fault-tolerant circuit for
logical CZ are shown in Fig. 3. This is our ﬁrst example
of a useful round-robin construction, accompanied by a
prologue and epilogue of local Cliﬀord gates. The story
begins with a local unitary transformation K1Y3K5 on
both code blocks. These Cliﬀord gates take the 5-qubit

8

which qubits (at most two of them) in block A and which
qubits (again at most two) in block B may have errors.
This reduces to correcting two errors in known locations
on the 5(cid:48)-qubit code. Finally, the three cases of case (2)
— one Z error propagated through the ﬁrst relevant CZ,
one Z error propagated through the second relevant CZ,
or a Z error propagated through both relevant CZs —
can be checked explicitly to give diﬀerent syndromes on
the nonconstant stabilizers of the block receiving the Z
errors.

It is interesting to consider that the intermediate error-
correction procedure we have just described actually uses
only 84 non-trivial syndromes out of a total 28 − 1 = 255
possible. The remaining syndromes do not correspond
to errors that can arise in the standard model of faulty
components from just one component failing, but they
will allow the correction of some errors arising from two
faulty components.

It should be noted that the ﬁnal error-correction for
our logical CZ construction can be taken to be a canonical
error-correction, consisting of two copies of the canonical
error-correction for the 5-qubit code. This works because
the ﬁnal piece of the round-robin circuit, Fig. 3b, is 1-
transversal.

C. T will always require functional ancillas

We have described how to obtain the entirety of the
Cliﬀord group fault-tolerantly on the 5-qubit code, with-
out any ancillas other than those needed for error-
correction. A ﬁnal logical gate is needed, however, to
complete a universal set of fault-tolerant gates. From
the perspective of universality, there are many choices
we could make — any gate outside the Cliﬀord group
will do [4]. Nevertheless, from the perspective of fault-
tolerance, some gates are indeed forbidden from being
implemented without overhead in the form of functional
ancillas. The T = diag(1, eiπ/4) gate is one of these.

To show that a fault-tolerant T -gate on the 5-qubit
code cannot be implemented without functional ancillas,
even in a pieceably fault-tolerant fashion, begin by not-
ing that a logical T cannot be implemented with only
single-qubit gates and qubit swaps — that is, T is not a
transversal gate on the 5-qubit code. This follows from
the second theorem of Zeng et. al. [4], where they show
that no stabilizer code has a universal, transversal set of
gates even on one encoded qubit. Since T is not transver-
sal, any logical T construction with no ancillas must use
a multi-qubit gate between some number of the ﬁve code
qubits (e.g. see Fig. 4). Look at the chronologically last
such multi-qubit gate. After that gate, if the circuit re-
ally implements a logical T gate, the codespace will be
locally unitary equivalent to the codespace of the 5-qubit
code. Thus, because the 5-qubit code is a perfect code,
we know that no multi-qubit errors will be correctable
(as long as all single-qubit errors must simultaneously be
correctable, which is always the case). We conclude that

FIG. 3: Circuits Ca (a) and Cb (b) such that CCZ = Cb · Ca
is a pieceably fault-tolerant implementation of CZ on the 5-
qubit code. The intermediate error correction, done after (a),
is described in the text, while the ﬁnal error correction after
(b) can be taken as two copies of the canonical 5-qubit error-
correction, which is the canonical error-correction for the ten-
sor product of two 5-qubit codes. In the notation of the deﬁ-

nition of pieceable fault-tolerance (cid:101)CCZ = Cb · EC1 · Ca. To do

a logical CX from the top code block to the bottom change
all physical CZs to physical CXs from qubits in the top to
those in the bottom. The intermediate error-correction will
still succeed in correcting all single faults if all stabilizers of
the corresponding intermediate code are measured.

Eq. (15). We will also refer to the generators on the left
as belonging block A and those on the right as belonging
to B, since they are the transformations of the generators
in Eq. (12) for their respective blocks.

Assume only one component in Fig. 3a has failed, and
propagate the resulting Pauli errors to the end of the
subcircuit, where we will measure the stabilizer genera-
tors in Eq. (18) in a fault-tolerant fashion. A generator
is said to trigger if we measure that stabilizer and ﬁnd a
−1 eigenstate. Note ﬁrst that errors on idle qubits do not
propagate (are noncontagious) and only trigger the gen-
erators of one block. Likewise, Pauli Z errors on active
qubits are noncontagious. We can thus reduce to three
cases: (1) a single error in a single block (2) a conta-
gious (X or Y ) error on an active qubit in one block that
propagates at least one Z error to the second block and
(3) a contagious error on one active qubit in each block
(caused by a failed CZ), both of which may propagate Z
errors.

First, note that these three cases are easily distin-
guished. Case (1) we already noted triggers only the
generators of one block. Case (2) has some generators of
each block trigger, but if the X or Y error has occurred
in block A then the constant stabilizers of block B will
never trigger, though at least one of the nonconstant sta-
bilizers of B will.
In case (3), on the other hand, at
least one constant stabilizer from each block will trigger.
We are left to argue that errors within each case can be
distinguished.
Case (1) reduces to the 5(cid:48)-qubit code of Eq. (12) being
able to correct all single-qubit errors. In case (3), from
the trigger pattern of the constant stabilizers, we can de-
duce exactly which CZ failed. This then means we know

9

adaptive variety termed PARSEC in Section II D, since,
unlike the logical CZ case of Section III B, intermediate
in the logical CCZ circuit the code space is no longer that
of a stabilizer code.

The pieceably fault-tolerant CCZ circuit is shown in
Fig. 5. The general idea is no diﬀerent from the design
of the fault-tolerant CZ. First, transform all three code
blocks into the 5’-qubit code in Eq. (12) by applying the
single-qubit unitaries K1Y3K5. Second, apply the round-

robin CCZ circuit(cid:89)

j,k,l∈{1,3,5}

CCZ(jA, kB, lC),

(19)

†
1Y3K

containing 33 = 27 CCZs total. Finally, transform each
†
5.
block back to the standard 5-qubit code with K
Checking that Eq. (19) implements a logical CCZ on
the 5’-qubit code is only slightly more diﬃcult than
checking that Eq. (15) implements logical CZ. The
CCZ = diag(1, 1, 1, 1, 1, 1, 1,−1) gate is in the third level
of the Cliﬀord hierarchy [31]. Moreover, it treats all three
qubits symmetrically, commutes with Pauli Zs, and acts
on Pauli Xs like

CCZ(XII)CCZ = XII × CZ(2, 3).

(20)

We must verify the same action of Eq. (19) on the 5’-
qubit codes’ logical operators Z A, Z B, Z C, X A, X B, X C
and preservation of the stabilizer.

The latter is simple. Since each stabilizer generator has
an even number of X or Y operators on the active qubits
(again qubits 1, 3, 5 of each block), any CZs introduced
to the stabilizer by Eq. (20) will cancel by the end of the
round-robin circuit, Eq. (19).

As for the transformation of the logical operators, we
can note that Z Q for code blocks Q = A, B, C trivially
does not change. Since X Q is odd weight and is sup-
ported by Pauli Xs on only the active qubits, we ﬁnd

X AI BI C −→ X AI BI C

CZ(jB, kC),

(21)

(cid:89)

j,k∈{1,3,5}

and likewise for X B and X C. However, we have already
argued in Section III B that the latter product of CZs,
the round-robin CZ circuit from Eq. (15), is exactly a
logical CZ on the 5’-qubit code (in this case on blocks B
and C), and so Eq. (21) is the logical version of Eq. (20),
as required.

We now show that the round-robin CCZ circuit of
Eq. (19) is pieceably fault-tolerant. The decomposition
proceeds similarly to that of the round-robin CZ circuit.
Group the CCZs of Eq. (19) into pieces such that, in any
piece, no single qubit interacts with more than two qubits
of another block (i.e. each piece is 2-transversal). One
possibility, with four pieces, is shown in Fig. 5. We will
perform error-correction after each piece, to be described
shortly.

However, let us ﬁrst note the form of the stabilizer at
any of the three intermediate error-corrections. There are

FIG. 4: A logical Zθ = exp(iθZ/2) gate for the 5-qubit
code. The case θ = π/4 corresponds to a T -gate. This con-
struct, like any logical T -gate circuit using no functional an-
cillas, is not fault-tolerant nor even pieceably fault-tolerant.
However, this does not mean such designs are entirely use-
less. For instance, the above circuit provides a fault-tolerant

circuit for T in the (cid:74)75, 1, 3(cid:75) code formed by concatenating
the (cid:74)15, 1, 3(cid:75) Reed-Muller code [23, 30] within the 5(cid:48)-qubit

code (the code resulting from applying K1Y3K5 to the 5-qubit
code, see Eq. (12)), because the Reed-Muller code has both
transversal T and transversal CX logical constructs. This
same idea of concatenating codes to produce a larger code
with a greater, and sometimes even universal, set of fault-
tolerant logical gates is used to great eﬀect in [11].

the last multi-qubit gate will always have the potential
to introduce uncorrectable errors if we use no functional
ancillas to implement T on the 5-qubit code.

The same argument works for any non-transversal
single-qubit gate and any code that is unable to correct
all errors on all subsets of multiple code qubits. For in-
stance, the 7-qubit code also needs functional ancillas for
a logical T -gate, because the classical codes underlying
its CSS construction are perfect.

When functional ancilla qubits are used, a pieceably
fault-tolerant logical circuit for T does exist for the 5-
qubit code by our construction of a pieceably fault-
tolerant CCZ in the next section and the universality
that it bestows. But it is also interesting to note other
constructions in the literature. First, there are the magic
state constructions due to Shor [19] and Bravyi and Ki-
taev [5]. Alternatively, code switching techniques, ﬁrst
from the 5-qubit to 7-qubit code [8], and then from the
7-qubit to 15-qubit code [10], also give a fault-tolerant
method of implementing T , since it becomes transversal
once we have transferred to the 15-qubit code.

D. Pieceably fault-tolerant CCZ

In this section, we describe a pieceably fault-tolerant
implementation of the CCZ gate on the 5-qubit code,
thereby completing a fault-tolerant universal set of gates
for the smallest quantum error-correcting code. Unlike
fault-tolerant T -gate implementations, this construction
requires no functional ancilla qubits.
It is however a
pieceably fault-tolerant design of four pieces, so there
are four rounds of error-correction to contend with. The
error-correction procedures themselves are novel, of the

10

FIG. 5: The round-robin circuit for CCZ between three code blocks each with three active qubits (e.g. qubits 1, 3, 5 for a
5’-qubit code block and qubits 5, 6, 7 for a 7-qubit code block). Idle code qubits are omitted. The circuit is broken into four
pieces (a), (b), (c), (d), each of which is 2-transversal, and therefore an appropriate error-correction performed after each piece
will ensure pieceable fault-tolerance (see text). This circuit design is quite versatile. For instance, this idea performs a CCZ on
the 5(cid:48)-qubit code (Section III D), on the 7-qubit code (Section IV B), and between 5(cid:48)- and 7-qubit code blocks, among other
possibilities (Section V). On some codes (see Section V for explicit conditions), including the 5(cid:48)- and 7-qubit codes, replacing
the CCZs with CCXs or CCYs will also implement logical CCX or logical CCY, respectively.

four stabilizer generators corresponding to each block, for
a total of twelve. For instance, the four from block A at
any intermediate error-correction will have the form,

(cid:42) −Y ZXIZ × CZA1

−ZZZXI
−IXZZZ
−ZIXZY × CZA4

(cid:43)

SA =

,

(22)

where it is understood that these generators con-
tain I⊗5 on blocks B and C and CZA1 and CZA4
are products of CZs between blocks B and C. For
instance, after the ﬁrst piece of Fig. 5, CZA4 =
CZ(1B, 1C)CZ(1B, 3C)CZ(3B, 1C)CZ(3B, 3C)CZ(5B, 5C).
The stabilizer generators for blocks B and C are of a
similar form. Again, two stabilizer generators per block,
six total, have changed (the nonconstant stabilizers) and
two per block have not (the constant stabilizers).

Of course,

the nonconstant

stabilizers have not
changed when we just look at the qubits on their home
block. We will use this fact, because if we have ensured
at most Z errors in the other blocks (this is the meaning
of commutation guarantees in this case), then the non-
constant stabilizers in block A (for instance) will act just
as the original stabilizer generators in terms of detecting
errors on A.
Assume that a single faulty component in the previous
circuitry, say ECk · Ck ····· EC1 · C1, will, if anything, in-
troduce either noncontagious errors or single-qubit errors
to the (k + 1)th piece, Ck+1. It can be veriﬁed that the
intermediate error-correction procedure we describe next
actually does ensure this — only noncontagious errors
will pass, and, assuming no earlier fault in the circuit,
a failure in the error-correction itself will introduce at

Algorithm 1: PARSEC

Input : (1) h + 1 code blocks partway through a

round-robin circuit.
(2) Each block has an error-correcting constant
stabilizer.

Output: (1) h + 1 code blocks free of contagious errors.

(2) The locations of noncontagious errors if
there are multiple per block.

• Measure the constant stabilizers of all blocks
• If two or more blocks have triggered: \\faulty ChZ

− For each triggered block:

- Apply X to the aﬀected qubit
- Note possible spread of Z errors to other
blocks
• If one block triggered: \\single error in that block
− Measure nonconstant stabilizers of that block
− Correct the error
− Note possible spread of Z errors to other blocks
• If no blocks triggered: \\at most noncontagious errors
− Do nothing

A procedure for doing intermediate error-correction in
the non-stabilizer codes encountered partway through
the round-robin constructions of Theorem V.1. If the
circuit described here were to contain a single fault, and
the previous round-robin circuitry did not, then at most
a single-qubit error will be introduced to the code qubits.

most a single-qubit error. The latter property is because
we only measure nonconstant stabilizers when we have a
reliability guarantee (see Section II D).

We implement error-correction ECk+1 using PARSEC,
Alg. 1. But why does it work for the 5-qubit code? We
go through the procedure step-by-step. Begin by mea-

suring the constant stabilizers of each block (six total).
Since these are Paulis, we can measure them in standard
fashion (e.g. via a CAT state ancilla ´a la Shor [19] with
repeats and majority voting). Notice that any conta-
gious errors will be detected by these constant stabilizer
measurements. Indeed if constant stabilizers from two or
three diﬀerent blocks have triggered (case (1)), we know
for sure that a CCZ has failed, since this is the only way
just one failure could introduce errors detectable by the
constant stabilizers into two diﬀerent blocks. We also
know that the errors are contagious. These errors are
immediately correctable modulo noncontagious errors —
we know where the errors have occurred from the consis-
tent syndrome, and can apply X to the aﬄicted qubits,
leaving at most Z errors.
If constant stabilizers have
just triggered in one block (case (2)), then we know that
at worst noncontagious errors are present in the other
blocks, and that the triggered block has at most a single-
qubit error. If no constant stabilizers have triggered (case
(3)), then at worst noncontagious errors have occurred.
In case (1), having found and corrected contagious er-
rors, we know where Z errors might possibly be. By the
way the pieces are constructed (i.e. 2-transversally), at
most two Z errors will be present in each block. Now
we could just measure all nonconstant stabilizers (see for
example Fig. 1d), with reliability and commutation guar-
antees from having detected and corrected the X errors,
and this would give enough information to correct the
Z errors. But luckily, the Z errors will not propagate
further, so we can just leave them until the ﬁnal error-
correction, when all stabilizers are Pauli again and so
simple to measure. This means we have to inform the
ﬁnal error-correction of the locations of these Z errors,
and this is why that information is listed as an “output”
in Alg. 1. If the ﬁnal error-correction gets no informa-
tion from the intermediates, it should revert to canonical
form, correcting one arbitrary error per block.

In case (2), if the constant stabilizers of block Q have
triggered we have, assuming just one faulty component,
reliability and commutation guarantees on the noncon-
stant stabilizers of block Q. Measuring them (and this
time, but only this time, the nonconstant stabilizers must
be measured), we can deduce what and where the error
in block Q is. Correct the error in block Q. If the error
had occurred on an idle qubit, we are done. If the error
was on an active qubit, however, then we know where the
possible Z errors may be in other blocks. Again, inform
the ﬁnal error-correction.

Though case (3) might appear the most straightfor-
In this case,
ward, it is actually the most interesting.
we could go ahead and measure all nonconstant stabiliz-
ers of all blocks, and therefore ﬁnd the locations of, at
most, one Z error per block. However, there is a problem
with this approach — we have no reliability guarantee!
Having detected no error, the measurement of the non-
constant stabilizers during ECk+1 could itself contain the
ﬁrst fault of the circuit, and it might result in a conta-
gious error entering the next piece of the circuit Ck+2.

11

This is a problem, because to analyze of cases (1) and (2)
we assumed one faulty component in ECk·Ck·····EC1·C1
causes either a noncontagious error or a single-qubit error
to enter Ck+1, and the same assumption must hold for
k → k +1. We therefore cannot measure the nonconstant
stabilizers in case (3).

The solution to this problem is, of course, that we do
not actually need to correct the Z errors, as we have
already seen. They will not propagate further, and so
can just be corrected at the ﬁnal error-correction. Since
there is only at most one per block, we do not even need
to give the ﬁnal error-correction special instruction.

Next, we mention the how the same PARSEC proce-
dure is general enough to work on the 7-qubit code as
well. But it can also be made somewhat simpler, by
virtue of the 7-qubit code being CSS.

IV. 7-QUBIT CODE

A. Transversal gates

The 7-qubit code is the most frequently studied of the
small stabilizer codes, trumping the 5-qubit code in this
metric despite its larger size. One advantage of the 7-
qubit code is its complete set of transversal Cliﬀord gates
— all three of H, S, and CNOT are transversal in the
simplest way, as 7 copies of the physical gate applied
qubitwise (e.g. H = H⊗7). It is also a code grounded in
classical coding theory, being the smallest member of the
CSS code family.

Here we brieﬂy record stabilizer and normalizer of this

(cid:74)7, 1, 3(cid:75) code. Normalizers, like those of the 5-qubit code

previously, are reduced to minimum weight.

(cid:28) XXXXIII ZZZZIII

(cid:29)

XXIIXXI ZZIIZZI
XIXIXIX ZIZIZIZ

S7 =

Z 7 = IIIIZZZ
X 7 = IIIIXXX.

(23)

(24)

(25)

Transversality of H, S, and CNOT can easily be veriﬁed.

B. Pieceably fault-tolerant CCZ

The logical CCZ circuit for the 7-qubit code circuit

consists entirely of the round-robin CCZ circuit

CCZ(jA, kB, lC)

(26)

(cid:89)

j,k,l∈{5,6,7}

with error-correction after each subcircuit of CCZs.
These circuit pieces, like those in the case of the 5-qubit
code, should be made 2-transversal. Qubits 5, 6, 7 of each
block are active qubits and the remainder are idle qubits.
Checking that Eq. (26) implements a logical CCZ fol-
lows the same logic as in the 5-qubit case. The stabilizer

generators will all be preserved because the ﬁrst three
each have an even number of Xs on the active qubits
and the last three commute with Eq. (26). The normal-
izer Z 7 will also be preserved for the same commutation
reason. However, X 7 will change,

(cid:89)

j,k∈{5,6,7}

X AI BI C −→ X AI BI C

CZ(jB, kC)

(27)

with the analogous transformation on the normalizers of
blocks B and C. The thing to note is that the round-
robin product of CZs in Eq. (27) is also, just like for the
5-qubit code, a logical CZ on the 7-qubit code. And so
Eq. (27) is the correct logical transformation consistent
with a logical CCZ.

The pieces of Eq. (26) consist of one group of nine
CCZs and three groups of six, just like the 5-qubit case
(see Fig. 5 again). The 7-qubit code also has some sta-
bilizer generators that become non-Pauli as the round-
robin CCZ circuit progresses, namely the second and
third, the nonconstant stabilizers, and some generators
that do not change at all, the ﬁrst and the last three.
Although the ﬁrst is a constant stabilizer, it is trivially
so (all Paulis on active qubits are Is), so only the last
three, those of Z-type, need be concerned when we say
to measure constant stabilizers. Our job now is to argue
that the pieces in Fig. 5 can all be error-corrected without
introducing uncorrectable errors into the next piece.

The key to intermediate error-correction in the 7-qubit
case is that all contagious X errors can be corrected by
measuring only the constant stabilizers, while nonconta-
gious Z errors commute through the circuit to the end.
Because the 7-qubit code is CSS it can detect and correct
one X error per block using only measurement of the ﬁrst
three stabilizers in Eq. (23). Conveniently and not coin-
cidentally, at most one X or Y error will occur per block
as well, resulting from failure of a physical CCZ. Having
learned the locations of X or Y errors, the intermediate
error-correction can then tell the ﬁnal error-correction
where to look for Z errors, at most two of them per block
in known locations. The ﬁnal error-correction measures
all stabilizers (which are Pauli once we have returned to
the tensor product of three 7-qubit code spaces) and ap-
plies recovery using its syndrome plus the information
from any intermediate error-corrections.

Notice, no non-Pauli stabilizers were ever measured!
Yet, we still managed to correct any single component
failure in the circuit Fig. 5. Not having to measure non-
constant stabilizers is a feature of all our round-robin
constructions on CSS codes. Indeed, this modiﬁed PAR-
SEC we call CSS PARSEC, outlined in Alg. 2.

V. CONDITIONS FOR PIECEABLE

FAULT-TOLERANCE IN STABILIZER CODES

The previous two sections, Section III about construct-
ing pieceably fault-tolerant circuits for the 5-qubit code,

12

Algorithm 2: CSS PARSEC

Input : (1) h + 1 code blocks partway through a

round-robin circuit.
(2) Each block has an error-correcting constant
stabilizer.
(3) Each constant stabilizer also distinguishes
between contagious errors and errors on idle
qubits.

Output: (1) h + 1 code blocks free of contagious errors.

(2) The locations of noncontagious errors if
there are multiple per block.

• Measure the constant stabilizers of all blocks
• If any block has triggered:

− For each triggered block:

- If error is contagious, apply X to aﬀected
qubit and note spread of Z errors to other
blocks
- If error is on an idle qubit, do nothing

• If no blocks triggered:

− Do nothing

An error-correction procedure achieving the same goals
as PARSEC, but without ever having to measure the
nonconstant stabilizers of any block. The CSS in the
procedure’s name stems from the fact that any
normalizer of a CSS code that consists entirely of Xs
and Is or of Zs and Is will have a constant stabilizer
satisfying the third input condition (but not necessarily
the second, though nondegeneracy of the code is
suﬃcient to do so).

and Section IV about similar constructions for the 7-
qubit code, left one burning theoretical question open:
for what codes do there exists pieceably fault-tolerant
constructions for interesting gates?

In this section, we explore this question in detail. we
ﬁnd several remarkable results, including the fact that
all nondegenerate stabilizer codes with distance at least
three have a pieceably fault-tolerant gate that is locally
Cliﬀord equivalent to ChZ. For codes already endowed
with transversal local Cliﬀord gates, this is enough for
universality. Our general constructions also work be-
tween blocks in diﬀerent codes as well, implying a method
of code switching with pieceable circuits.

Because we found round-robin circuits so useful in Sec-
tions III and IV, we will continue studying them in this
section, only in more generality. In the ﬁrst part of this
section, we have two main concerns. Our ﬁrst is to make
logical gates from round-robin circuits. Only after do
we state further conditions so that the logical circuits
are also pieceably fault-tolerant, which comes alongside
a general method for piecing round-robin circuits into
few pieces. In the second part of this section, our con-
cern is the identiﬁcation of well-known codes and fami-
lies of codes that can attain universal sets of logical gates
through pieceable fault-tolerance.

A. Pieceable constructions in general

To ﬁnd logical uses for round-robin circuits, we deﬁne
a particular h + 1 qubit gate, a generalization of ChZ.
Given a trit string {j0, j1, . . . , jh} with jm ∈ {1, 2, 3}, let

Γ(σj0, σj1 , . . . , σjh ) = A†(cid:16)

(cid:17)

ChZ

A,

(28)

where A = (cid:78)h

m=0 K 3−jm. Recall that (σ1, σ2, σ3) =
(X, Y, Z) and K = SH. Notice that Γ(Z, Z, . . . , Z) =
ChZ. Likewise, Γ(X, Z, . . . , Z) is a ChX with target the
0th qubit, and Γ(X, X, . . . , X) is a symmetric gate anal-
ogous to ChZ but in the X-basis. We will also abuse
notation slightly to write Γ-gates in terms of Pauli op-
erators, like Γ(p) where p ∈ Ph+1 and |p| = h + 1. So
Γ(Z⊗h+1) = ChZ as well.

13

form consisting of all Zs or Is, must have an even number
of Xs and Y s on supp(pj). Thus, the round-robin CZ
circuit will preserve all stabilizers s. Likewise, pj is also
preserved.

Now, to argue the other normalizers transform cor-
rectly, we argue by induction on h. Start with h = 1,
where the round-robin circuit is of CZ gates. A normal-
izer l ∈ N (S0)\ S0 of the 0th code that is not a logical p0
operator, will necessarily anticommute with p0. There-
fore, l has an odd number of Xs and Y s on supp(p0) and
so l → l ⊗ p1 under the action of the round-robin CZ
circuit. The symmetric argument holds for the 1st code
block.
Now the inductive step with h + 2 code blocks. The
same fact stands that for code j if l ∈ N (Sj) \ Sj and
l (cid:54)∈ pjSj, then {l, pj} = 0 and so l has an odd number of
Xs and Y s on supp(pj). However, now this means that

(cid:89)

With round-robin circuits we can at least implement
logical versions of all Γ-gates on all stabilizer codes. We
save the argument for fault-tolerance of the construction
for later.

l → l

qi∈supp(pi)

i(cid:54)=j

ChZ(q0, . . . , qj−1, qj+1, . . . , qh+1).

Theorem V.1. Consider any h + 1 stabilizer codes
L0, L1, L2, . . . , Lh each encoding a single qubit. For all
h and all p ∈ Ph+1 with |p| = h + 1, there is a round-
robin circuit, perhaps conjugated by local Cliﬀord gates,
that implements logical Γ(p).

Proof. Choose a logical pj operator for code j and
denote it pj. For instance, if pj = Z then pj indicates a
logical Z operator of code j. With these choices of logical
operators made, build the following circuit.

1. By applying local Cliﬀord gates, change every pj
into a form consisting of only Pauli Zs and Is with
positive sign. This of course changes the stabilizer
and other normalizers of the codes accordingly. We
call this the Z-form of the code with respect to pj.

2. Apply the round-robin circuit of ChZ on the sets

supp(p0), supp(p1), . . . , supp(ph).

3. Reverse the Cliﬀord gates of step (1) to return the

codes to their original form.

The only non-trivial part of proving this “prologue,
round-robin, epilogue” construction works is in showing
that a round-robin ChZ circuit acts as logical Γ(p) on
codes in Z-form. To that purpose, from now on we will
just assume the h + 1 codes are already in Z-form.

How does Γ(p) act on Paulis?

It should be clear,
generalizing Eq. (16) for the CZ and Eq. (20) for
if qj ∈ {I, pj} and
the CCZ, that Γ(p)qjΓ(p) is qj
qjΓ(p0, . . . , pj−1, pj+1, . . . , ph) otherwise (where it is to
be understood that the h-qubit Γ-gate here applies to
all qubits except qubit j). We have to argue the same
statements hold logically after the round-robin circuit of
ChZs and, moreover, that the stabilizer is preserved.
Tackle the latter point ﬁrst. A stabilizer of the jth
code s ∈ Sj, since it commutes with pj and pj is in a

But by induction, the product of ChZ gates is logical
Γ(p0, . . . , pj−1, pj+1, . . . , ph+1). This is exactly the eﬀect
(cid:4)
we wanted.
To show that the circuits presented in the proof of
Theorem V.1 are pieceably fault-tolerant requires speci-
ﬁcation of where and how intermediate error-correction
should be done. We will put additional conditions on a
stabilizer code to guarantee that such intermediate error-
correction can be done. The idea behind these condi-
tions is simply a generalization of the procedure used in
the 5-qubit and 7-qubit cases. At an intermediate error-
correction, we will ﬁrst measure the constant stabilizers,
which remain Pauli throughout the round-robin circuit,
and correct errors that we can correct before measuring
any non-Pauli stabilizers (using some measurement cir-
cuit like Fig. 1d). Our conditions amount to the existence
of an appropriate group of constant stabilizers for each
code involved.

Because each code can be diﬀerent, it makes sense to
place conditions on the individual codes rather than all
h + 1 codes together. To do this, we should deﬁne con-
stant stabilizers for the individual codes. We could con-
sider taking from the stabilizer S of code j only the stabi-
lizers that commute with the round-robin circuit C. But
recall from the proof of Theorem V.1 that the round-
robin circuit itself depends on a normalizer p ∈ N (S)\ S
of code j — it is wired to all qubits in the support of
p. Therefore, in the end, the constant stabilizer of code
j depends only on which normalizer p we choose. We
therefore propose the constant stabilizer of a normalizer
be deﬁned as

SC(p) = {g ∈ S : ∀i ∈ supp(p), [gi, pi] = 0}.

(29)

Notice that SC(p) is a subgroup of S, and in fact SC(p)
is a proper subgroup if and only if d ≥ 2, where d
is the code distance. Examples for the 5-qubit code

include SC(ZZZZZ) = {IIIII} and SC(XIZIX) =
(cid:104)IXZZX, XZZXI(cid:105). We emphasize that this deﬁnition
of the constant stabilizer by way of a normalizer, Eq. (29),
is really a special case of the more general deﬁnition,
Eq. (6), when the pieceable circuit in question is a round-
robin circuit like in Theorem V.1.

The same logic that changed the constant stabilizer
from depending on the round-robin circuit to depending
on a normalizer applies to the contagious errors. Accord-
ingly, deﬁne the contagious errors of a normalizer p (on
an n-qubit code block) to be

EC(p) = {E ∈ Pn : |E| = 1, [E, p] (cid:54)= 0}.

(30)
We have included the additional condition |E| = 1, be-
cause after a single fault contagious errors can never af-
fect more than one qubit per code block in our round-
robin constructions.
It is important to study how SC(p) and EC(p) inter-
act. After all, we saw in the 5-qubit and 7-qubit code ex-
amples that the constant stabilizer detecting contagious
errors is key to PARSEC. So we will say that SC(p) is
error-detecting if all errors in EC(p) anticommute with
some member of SC(p). Likewise, we say SC(p) is error-
correcting if it can distinguish between all contagious er-
rors, at least modulo noncontagious errors. These def-
initions can be rephrased in terms of the distance of a
certain classical code related to the stabilizer code and
normalizer in question (see Appendix A). This relation
to classical coding should not be unexpected — after the
local Cliﬀord transformation of the codes to Z-form in
Theorem V.1, the stabilizers with only Zs on the active
qubits are the constant ones, and the contagious errors
are Xs (and Y s, but these are just Xs modulo a noncon-
tagious Z).

The following theorem establishes pieceable fault-
tolerance for the round-robin constructions of Theo-
rem V.1, along an upper bound on the number of pieces
required.

Theorem V.2. Consider h + 1 stabilizer
L0, L1, L2, . . . , Lh such that

codes

1. Each Lj encodes a single qubit and has code dis-

tance dj ≥ 3.

2. For all j, Lj has a logical pj operator with an error-
correcting constant stabilizer and weight, say, wj.

cal Γ(p) using at most (cid:81)h

Then, there is a pieceably fault-tolerant circuit for logi-
j=0 mj/ minj mj pieces, where
mj = (cid:100)wj/(dj − 1)(cid:101).
Proof. We ﬁrst establish that a decomposition C = Cm ·
Cm−1 · . . . · C1 of the round-robin circuit C is good, in
the sense that intermediate error-correction after each Ck
will succeed in correcting all contagious errors, if for all
k = 1, 2, . . . , m and all i, j ∈ {0, 1, . . . , h} all qubits in
Λi are connected to at most dj − 1 qubits in Λj by gates
in Ck. Once we come up with an intermediate error-
correction procedure that works given this connectivity

14

condition, we will set about piecing the circuit to achieve
it.

All intermediate error-corrections proceed according to
PARSEC, Alg. 1. We got through this general procedure
now, and indicate where we use the assumptions of the
theorem. First, measure all constant stabilizers of all the
code blocks. There are now three cases to consider.

1. If two or more blocks have triggered, we know that
a ChZ has failed, because there is no other way
to get a contagious error in more than one block.
Since the constant stabilizers are error-correcting,
and we know the errors are indeed contagious, we
can locate the aﬀected qubits and apply X, convert-
ing them to at most noncontagious Z errors on the
active qubits. However, we must also note which
qubits the aﬀected qubits had interacted with dur-
ing the last piece of the circuit — those qubits
might have picked up Z errors. Luckily, there are
at most dj − 1 such qubits in block j by our piec-
ing of the circuit. Make note of those locations and
inform the ﬁnal error-correction.

2. If only one block (say j) has triggered, we do not
yet know whether the constant stabilizers have de-
tected a contagious error on the active qubits or an
error on the idle qubits, but we do know there is at
most a single-qubit error in this block. To ﬁnd out
if it is contagious, measure the nonconstant stabi-
lizers of block j. Fortunately, we can do so (with
a circuit like Fig. 1(d)) because we have ensured a
reliability guarantee on this nonconstant stabilizer
measurement by having detected that some fault
had already occurred. We also have commutation
guarantees for the nonconstant stabilizers of block
j, since no contagious errors have been detected on
the other blocks. The nonconstant stabilizers of
block j have the form of a Pauli on the qubits of
block j and Ch−1Z gates on the other blocks. The
commutation guarantees assure us that only the
Pauli part will be involved in error-detection. Since
this Pauli part is the same as it was in the original
code Lj, we have reduced the problem to correcting
a single error with code Lj. Code Lj can do this
correction modulo its own stabilizers. However,
the nonconstant stabilizers have since changed, so
we must ensure that the error-correction does not
happen modulo the nonconstant stabilizers. The
fact that the constant stabilizer of block j is error-
correcting ensures this, however. More precisely,
there can be no nonconstant stabilizers of code Lj
with weight two (see Appendix A, Lemma A.1(4)).
After correcting the error,
if it was contagious,
make note of where it could have spread to other
code blocks, and inform the ﬁnal error-correction.

3. If no blocks have triggered, at most there is a single-
qubit noncontagious error per block. These errors
will not spread, and they can be corrected by the
ﬁnal error-correction.

The ﬁnal error-correction at the end of the round-robin
circuit is special in a diﬀerent way than the intermediate
error-corrections. Since the codespace is once again sta-
bilizer, we can measure a complete generating set. Nor-
mally, this would allow us to correct at least one error
per block (since dj ≥ 3 for all j), and it will do so if
case (3) occurred in the intermediate error-corrections.
However, if case (1) or (2) occurred in an intermediate
error-correction then we will instead switch to correcting
at most dj − 1 noncontagious errors in block j, using the
information about the locations of those errors, which
was sent to the ﬁnal error-correction by the intermediate
error-correction that detected them.

One might wonder if something like PARSEC is really
necessary for intermediate error-correction? In Appendix
B, however, we show that, provided we use lowest weight
normalizers as our pj, intermediate in the round-robin
circuit the codespace is non-stabilizer. Therefore, some
procedure diﬀerent from the conventional stabilizer error-
correction is required.

Now we can group the physical ChZ gates of the round-
robin circuit C according to the connectivity condition —
in any one piece of the circuit, a qubit is connected to at
most dj − 1 qubits of block j. First, take the wj qubits
of Lj and partition them into sets of size at most dj − 1.
Thus, Λj = λj1 ∪ λj2 ∪ ··· ∪ λjmj where mj = (cid:100)wj/(dj −
1)(cid:101). Note that C = RM · RM−1 · . . . · R1 where Rj are
round-robin circuits of ChZ on sets λ0i0, λ1i1, . . . λhih for
some ik indices dependent on j and M = m0m1 . . . mh.
Eﬀectively, each code block is now made of mj “compos-
ite qubits” and C can be viewed as a round-robin circuit
of “composite gates” (themselves round-robin circuits) on
these composite qubits. The connectivity rule for pieces
on the composite objects is that within a piece, no com-
posite qubit may be involved in more than one composite
gate. Since the smallest set of composite qubits has size
minj mj, this is how many composite gates we can ﬁt
j=0 mj/ minj mj, as we wanted
(cid:4)

into one piece. Thus, (cid:81)h

to show.

Whether the number of pieces used by Theorem V.2 is
optimal is a question that is maybe best answered for spe-
ciﬁc codes. For instance, even ordering the ChZ gates dif-
ferently within a piece changes the set of possible errors at
an intermediate point. In general, any code will have un-
used syndromes at an intermediate error-correction (such
as we noted for the 5-qubit code CZ), which may be ex-
ploitable through clever, code-speciﬁc circuit design.

We brieﬂy note that the fact that each code Lj encodes
a single qubit is not necessary in the proofs of Theo-
rems V.1,V.2. Indeed, the same arguments go through
for doing Γ-gates between any h + 1 encoded qubits, tak-
ing (your choice of) one encoded qubit from each k ≥ 1
code block. Generally, however, because we are not con-
sidering gates between encoded qubits in the same block
anyway, we prefer to simplify to the k = 1 case.

B. Universality through pieceable means

15

We now use the theorems from the previous section
to construct universal sets of fault-tolerant logical gates
on nondegenerate stabilizer codes. To do so, we have
to prove facts about the constant stabilizers of stabilizer
codes. The main technical result, proven in Appendix A,
is the following lemma.

Lemma V.3. Given a nondegenerate(cid:74)n, 1, d(cid:75) stabilizer

code with d ≥ 3 and stabilizer S, if p ∈ N (S) \ S has
|p| = d, then SC(p) is error-correcting.

It follows that, since all stabilizer codes have a nor-
malizer with weight d, all nondegenerate stabilizer codes
have a normalizer with an error-correcting constant
stabilizer. Therefore, using Theorem V.2, we have
that any nondegenerate stabilizer code with d ≥ 3
has pieceably fault-tolerant circuits for at least one of
Γ(ZZZ), Γ(XXX), Γ(Y Y Y ). With appropriate single-
qubit gates, along with state preparation and measure-
ment circuits we know exist for any stabilizer code, any
one of these can form a universal set. In fact, for each of
the three Γ-gates, adding a single qubit Cliﬀord gate that
does not commute with the gate will suﬃce for univer-
sality. For example, Γ(ZZZ) plus H is universal [32, 33],
as is Γ(Y Y Y ) plus SHS. The octahedral gates Eq. (11)
commute with none of these three Γ-gates, and so always
complete a universal set.

The upshot of the brief argument of the previous para-

graph are the following corollaries.

Corollary V.4. Any nondegenerate stabilizer code with
a complete fault-tolerant set of logical local Cliﬀord gates
has a universal set of fault-tolerant logical gates.

Corollary V.5. Any nondegenerate linear stabilizer
code with distance d ≥ 3 has a fault-tolerant and uni-
versal set of logical gates.

Obviously, the assumptions of Corollary V.4 are a bit
stronger than necessary given our argument above, but
for the sake of concise statement without referring at
all to constant stabilizers, we have strengthened them.
Corollary V.5 follows from the fact that GF(4)-linear
codes (like the 5-qubit code) always have transversal oc-
tahedral gates, such as K.

We have a similar logical progression for CSS codes.

In this case, from Appendix A we have the lemma

Lemma V.6. Any nondegenerate(cid:74)n, 1, d(cid:75) CSS code with

d ≥ 3 and stabilizer S has two normalizers p1, p2 ∈
N (S) \ S with SC(p1) and SC(p2) both error-correcting
and {p1, p2} = 0.
The corresponding corollary is

Corollary V.7. Any nondegenerate CSS code with a
fault-tolerant logical local Cliﬀord gate has a universal
set of fault-tolerant logical gates.

This corollary is true because by Lemma V.6 CSS codes
have pieceably fault-tolerant circuits for at least two of
Γ(ZZZ), Γ(XXX), Γ(Y Y Y ). Every single-qubit Cliﬀord
gate fails to commute with at least two of these three Γ-
gates, and as we noted above Corollary V.4 this suﬃces
for universality. The conclusion of Corollary V.7 would
similarly hold true for any code satisfying the conclusion
of Lemma V.6.

Finally, we have a code-switching corollary.

Corollary V.8. For any two nondegenerate stabilizer
codes, each of which either (a) is CSS with a logical local
Cliﬀord gate or (b) possesses a complete fault-tolerant
set of logical local Cliﬀords, there exists a logical SWAP
between them.

This is simply a result of having CX from one code to
the other, in both directions. It is perhaps more interest-
ing to note the implication of a scheme for doing uni-
versal computation with any nondegenerate CSS code
L through code-switching, employing an ancilla code-
block. Using Lemma V.6, we agree to encode L such
that l1 is a logical Z operator and l2 is logical X. Then,
code-switching is possible between L and any code indi-
cated in Corollary V.8, including codes like the 7-qubit
and 15-qubit which together provide a universal set of
transversal gates. The same argument also works for
any code satisfying the conclusion of Lemma V.6, and
can also work to interact qubits encoded in the same
block by switching some to ancillary blocks ﬁrst. Though
not likely to be practical, these possibilities demonstrate
some of the ability of pieceable fault-tolerance once func-
tional ancillas are allowed.

Degenerate codes are conspicuously absent from our
results in this section. However, it should be noted that
Theorem V.2 is essentially the ﬁnal word on whether
a code has some pieceably fault-tolerant Γ-gate or not.
Some degenerate codes do indeed have error-correcting
constant stabilizers for some normailizer, such as Shor’s
9-qubit code.
It is also worth noting that because we
are dealing with fault-tolerance for a single fault (per-
haps better named 1-fault-tolerance) which is an essen-
tially distance three concept, that really nondegenerate
in the lemmas and corollaries of this section means: no
weight two stabilizers. This provides a strengthening of
Lemmas V.3 and V.6 (proofs follow from Lemma A.1
in Appendix A) from requiring a nondegenerate code to
requiring a code without weight two stabilizers, though,
again, considering only 1-fault-tolerance, these are essen-
tially the same idea regardless.

VI. CONCLUSION

Although we have developed fault-tolerant universal
sets of logical gates for many stabilizer codes, there is
more design space to explore. For instance, it is nat-
ural to ask questions such as, what other logical gates

16

can be implemented in a pieceably fault-tolerant man-
ner, with or without functional ancillas, or, what are the
fewest functional ancillas necessary to implement a given
gate pieceably fault-tolerantly in a given code? Some in-
teresting target gates for these questions might be the
controlled-Hadamard and controlled-phase gates, which
are powerful gates from a universality perspective as well
[34], or important single-qubit gates such as T [35]. Sim-
ilarly, universal gates between logical qubits encoded in
the same code block are also worth studying.

Another direction to explore is in ﬁnding more codes
that support universal sets of pieceable fault-tolerant
gates. All of our results, namely Corollaries V.4, V.5
and V.7, provide suﬃcient conditions for pieceable uni-
versality, but not necessarily necessary ones. We already
raised the question of degenerate codes, and if there is al-
ways some pieceable Γ-gates that can be constructed on
them, like for Shor’s 9-qubit code. Of course, once func-
tional ancillas are allowed, magic states can also be used,
so perhaps this question would make the most sense with
an ancilla restriction. Moreover, we have restricted our-
selves to stabilizer codes, an assumption which it would
also be interesting to lift.

A related extension is to consider more robust fault-
tolerance in higher distance codes. We have considered
distance three codes and built circuits that can recover
from single faults. To do this, we generally require a re-
liability guarantee on measurements of nonconstant sta-
bilizers. However, the full power of a distance d = 2t + 1
code is in recovering from t faults. Certainly our con-
structions on higher distance, nondegenerate CSS codes
are pieceably t-fault-tolerant, since in that case, using
CSS PARSEC, there is never need to measure noncon-
stant stabilizers. However, can PARSEC generalize to
provide t-fault-tolerant pieceable gates on other codes?

Finally, there is the question of eﬃciency. A complete
comparison of pieceable fault-tolerance against other
known means of achieving logical universality on several
codes with respect to fault-tolerance threshold, ancilla
qubits required, and circuit depth is warranted. Also, we
expect that along with rigorous threshold calculations
will come an inevitable wave of micro-optimizations to
pieceable fault-tolerance as we have laid it out here. For
instance, changing from a CAT state syndrome measure-
ment scheme for intermediate error-correction to some-
thing like a Steane [20, 21] or Knill [22] scheme (except
for the non-Pauli measurements) is likely to have thresh-
old increasing eﬀects. We also cannot ignore the pos-
sibility of macro-optimizations — for instance, replacing
the round-robin circuit with a simpler, but still pieceably
fault-tolerant, design customized for a particular code.

The authors would like to thank Andrew Cross,
Graeme Smith, and John Smolin for insightful discus-
sions about this work. We gratefully acknowledge fund-
ing from NSF RQCC Project No. 1111337 and ARO
quantum algorithms program. T.J.Y. also thanks the
DoD NDSEG and R.T. acknowledges the support of the
Takenaka scholarship and Frank fellowship.

Appendix A: Classical codes within quantum ones

There is a useful description of the constant stabilizer
SC(p) (see Eq. (29)) that comes along with an (eﬃcient)
algorithm for ﬁnding it. Recall that the stabilizer S of

an(cid:74)n, k, d(cid:75) quantum code can be written as a bifurcated

binary matrix, [17, 36]

S = [A|B]

(A1)

with n − k rows and 2n columns.
corresponds

Pauli of (cid:101)Zj is I, X, Y, Z if and only if (Ajk, Bjk) =

to stabilizer generator (cid:101)Zj.

The jth row
The kth

(0, 0), (1, 0), (1, 1), (0, 1). The signs of the stabilizer gen-
erators, either ±1, can be stored separately, but are un-
necessary for our purposes. The normalizer l can likewise
be written as [a|b], for (row) vectors a and b of length n.
Now consider two transformations of this representa-
tion. First, we will apply local Cliﬀord gates to put p
into Z-form, [(cid:126)0|b(cid:48)]. This causes S to change correspond-
ingly as well. Then, restrict S and p to the “window”
W = supp(p) by removing all columns from their binary
matrix representations that correspond to qubits outside
W . Now pW = [(cid:126)0|(cid:126)1] for length |p| vectors of 0s and 1s,
and SW = [A(cid:48)|B(cid:48)]. Since we can swap qubits within W
(corresponding to switching columns of SW ) and multi-
ply stabilizer generators (corresponding to adding rows of
SW modulo two) without changing pW , we can perform
Gaussian elimination so that

(cid:20) Ir D B1 B2

0 0 B3 B4

(cid:21)

SW =

17

We observe that those same rows H = [B3B4] represent
the parity check matrix of a classical code. We call this
the classical code C(p) induced by p on quantum code
L. Not all rows of H are necessarily linearly indepen-
dent, but the essential parity checks can be recovered
by removing linearly dependent rows.
It is also worth
mentioning that the ﬁrst r rows of SW correspond to a
minimal generating set for the nonconstant stabilizers.

The error-correcting properties of C(p) are directly re-
lated to the error-correcting properties of SC(p). Indeed,
SC(p) is error-detecting if and only if C(p) has classi-
cal code distance dC(p) ≥ 2. Likewise, SC(p) is error-
correcting if and only if C(p) has classical code distance
dC ≥ 3. The classical errors detected or corrected, re-
spectively, are exactly the contagious errors from EC(p),
Eq. (30).

We now show the following.

Lemma A.1. Let L be an (cid:74)n, 1, d(cid:75) stabilizer code with

stabilizer S and p ∈ N (S) \ S.
(1) If d ≥ 2 and |p| < 2d − 1, then C(p) exists and has

distance dC(p) ≥ 2.

(2) If p is minimum weight within its coset, there are no
nonconstant stabilizers of weight two, and C(p) exists
with dC(p) ≥ 2, then dC(p) ≥ 3.

(3) If d ≥ 3, |p| = d, and L is nondegenerate, then

dC(p) ≥ 3.

.

(A2)

(4) If dC(p) ≥ 3, then there are no nonconstant stabilizers

of weight two.

Letting r be the rank of A(cid:48), the heights of the blocks are
r and n − k − r and the widths are r,|p| − r, r,|p| − r.
So Ir is the r × r identity matrix. Note r ≤ |p| − 1,
because the ﬁrst r rows of SW represent stabilizers that
must commute with p, and the fact that Ir has only one
1 per row implies D must have an odd number of 1s per
row, and thus its width cannot be zero.

We remark oﬀhand that, for codes encoding one qubit,
|p| =
if p has minimum weight within its coset (i.e.
min{|p(cid:48)| : p(cid:48) ∈ pS}), then a stronger fact is true, namely
r = |p| − 1. This is so because all errors restricted to
the support of p, consisting of only Pauli Zs and Is, and
with weight < |p| are detectable. Exactly half of these
detectable errors must also be correctable, because, for
any such error E, only E and pE will have the same
syndrome. Thus,

(cid:18)(cid:18)|p|

(cid:19)

+

1

(cid:18)|p|
(cid:19)

2

1
2

(cid:19)(cid:19)

(cid:18) |p|

|p| − 1

+ ··· +

= 2|p|−1 − 1

(A3)
such errors are correctable. Only the ﬁrst r stabilizers in
SW have the possibility to trigger on these errors. Thus,
to have enough unique syndromes to correct them all, we
must have r ≥ |p| − 1.

Continuing our discussion of the constant stabilizer
SC(p), we now notice that SC(p) is generated by the sta-
bilizers corresponding to the last n − k − r rows of SW .

(5) If L is nondegenerate CSS and l consists only of Pauli

Zs and Is or only of Xs and Is, then dC(p) ≥ d.

Given the correspondence between the error-correcting
properties of SC(p) and C(p) discussed above, it should
be clear that part (3) of Lemma A.1 results directly in
the proof of Lemma V.3. Part (5) of Lemma A.1 implies
Lemma V.6 after one notices that, for any CSS code,
there is always a normalizer in Z-form (only Zs and Is)
and another in X-form (only Xs and Is), and these be-
long to diﬀerent cosets of the stabilizer [37]. Part (4) of
Lemma A.1 is used in the proof of Theorem V.2.

Proof of Lemma A.1. Note that (3) is merely a con-
sequence of (1) and (2). To prove the ﬁrst two, we ac-
if d ≥ 2 and for all
tually show something stronger:
l ∈ N (S) \ S we have dC(l) ≤ 2, then there is a weight
two stabilizer. The argument here proceeds recursively
— we either ﬁnd a weight two stabilizer or we ﬁnd a nor-
malizer with smaller weight than we began with. At the
bottom of the recursion (i.e. |p| < 2d − 1 or p minimum
weight within its coset) we will get (1) and (2).
We work with the windowed stabilizer, Eq. (A2), win-
dowed on l ∈ N (S) \ S.
If H = [B3B4] does not ex-
r = n − k), then we choose a column from
ist (i.e.
B = [B1B2], say column k, and deﬁne B = {j : Bjk = 1}.
j∈B ZjXk, whose weight notice is |e| ≤ |l|,
commutes with all stabilizers but anticommutes with l.

Then e = (cid:81)

Therefore, e ∈ N (S) \ S and el ∈ N (S) \ S. So, |e| ≥ d
and |l| − |e| + 1 ≥ d together imply d ≤ |e| ≤ |l| − d + 1.
Thus, because d ≥ 2, |e| ≤ |l| − 1, and we found a lower
weight normalizer.

e = (cid:81)
and e =(cid:81)

If H = [B3B4] does exist, then it either has a column
of 0s (distance dC(l) = 1) or has two identical columns
(distance dC(l) = 2).
In the former case, let the col-
umn of 0s be k and deﬁne B(cid:48) = {j : Bjk = 1} and
j∈B(cid:48) ZjXk. The argument proceeds as before,
so we omit it. But in the latter case, say the identical
columns are k1 and k2. Deﬁne B12 = {j : Bjk1 (cid:54)= Bjk2}
ZjXk1Xk2 . Note |e| ≤ |l| and addition-
ally e commutes with all stabilizers and l, so e ∈ lS or
e ∈ S. In the former case, if |e| = |l|, then el ∈ S has
weight two. In the latter case, el ∈ lS and |el| ≤ |l|. If
|el| = |l|, then B12 ⊆ {k1, k2}, implying |e| = 2.

j∈B12

The assumptions of (1) mean that if we started this
recursive process with l = p, we would only be able to
conclude that H has no column of 0s and thus dC(p) ≥
2. Likewise, if we started with the assumptions of (2)
instead, the conclusion would be dC(p) ≥ 3.

Part (4) is simple to prove in contrapositive. If there is
a nonconstant stabilizer of weight two, it must have the
form Xk1Xk2 , Xk1 Yk2, Yk1 Xk2, or Yk1Yk2 on two qubits
k1, k2 ∈ supp(p). Since X and Y are the same from
the perspective of commutation with constant stabilizers,
we can consider just the ﬁrst case.
In that case, the
constant stabilizers cannot distinguish between Xk1 and
Xk2 , which means C(p) is not error-correcting.

Finally, we ﬁnish with the last part (5). This one is
comparatively simple. Recall the stabilizer of a CSS code
can always be written like [38, 39]

S =

.

(A4)

(cid:21)

(cid:20) H1

0
0 H2

Thus, if p is in Z-form (consists only of Zs and Is), then
H2 is the check matrix of the classical code C(p). But
since the quantum code has distance d and is nondegen-
erate, this classical code must have distance at least d as
well. Likewise, if p is in X-form, then H1 is the check
matrix of C(p), which must also have distance at least d.
(cid:4)

Appendix B: Nonstabilizer intermediate codes

Here we show that the codes we encounter intermedi-
ate in the round-robin constructions of Theorem V.1 are
in fact nonstabilizer codes. This implies that doing com-
plete error-correction, rather than just correcting conta-
gious errors as we do with PARSEC, will likely require
the discovery of new tools. Only a few examples are
known of doing error-correction on non-stabilizer codes,
such as CWS codes [40].

In particular we prove the following:

Lemma B.1. Assume that we use normalizers with
weight minimal within their coset to construct logical Γ-
gates with h ≥ 2 in Theorem V.1. At any point in the

18

round-robin circuit, if the codespace is not equal to the
codespace at the beginning of the round-robin circuit, the
codespace is non-stabilizer.

Proof. Assume we have converted each of the h + 1 code
blocks into Z-form. We take h ≥ 2 because our conclu-
sion is obviously false for round-robin CZ constructions.
Then the stabilizer of any one code block, before any
gates of the round-robin are applied takes the form of
Sj = (cid:104)tj1, . . . , tjr, sj1, . . . , sjm(cid:105) where m = n − 1. We
have written nonconstant stabilizer generators as t and
constant stabilizer generators as s. We assume that, as
in the proof of Lemma A.1, we have found a maximal set
of constant stabilizers. Also, let pj denote the Z-form
normalizer of code j, the one with minimal weight.

Let S denote the complete stabilizer of all h + 1 codes
before any round-robin gates have been applied. The
transformation of S after some number of gates, a sub-
circuit C, will be denoted S(cid:48), and the transformation of
Sj as S(cid:48)
jk = tjkGjk, where Gjk is a prod-
uct of Ch−1Z gates on the qubits in code blocks other
than block j. However, this is the extent of the trans-
formation of the stabilizer — the constant stabilizers are
preserved, s(cid:48)

j. Notice that t(cid:48)

jk = sjk.

There are three properties of Gjk to note: (1) G2

jk = I
(2) Gjk = 1
jk are Pauli operators
Mjk
(with ±1 signs) consisting of only Zs and Is and Mjk > 0
is normalization (3) [Gjk, suv] = 0 for all j, k, u, v.
Let P (cid:48) denote the projector onto the codespace after

jk, where gm

m gm

(cid:80)

C. Explicitly,

P (cid:48) =

1
NS

(cid:88)

g∈S(cid:48)

g =

1
NS

(cid:88)

g∈S

CgC†,

(B1)

where NS is just normalization so that P (cid:48)2 = P (cid:48). We
want to show that there is no subgroup T of the Pauli
group such that

(cid:89)

g∈T

P (cid:48) =

1
NT

g.

(B2)

To prove P (cid:48) is not of this stabilizer form, it is suﬃcient
to show that two terms in the Pauli decomposition of P (cid:48)
have coeﬃcients that diﬀer in magnitude. Since the con-
stant stabilizers are part of the Pauli decomposition of P (cid:48)
and their coeﬃcients have unit magnitude, we only need
to ﬁnd a Pauli in the decomposition with a coeﬃcient of
magnitude less than one.

jk. This is because g0

If all Gjk are identity we are in the original codespace.
Therefore, one of Gjk is not identity. Now, Gjk cannot
be a single Pauli term Gjk = g0
jk, as
a non-identity Pauli consisting of Zs and Is, has some −1
eigenstate |b(cid:105) with b a weight one bit string. However,
for Gjk, as a product of Ch−1Z gates with h ≥ 2, all
eigenstates of this form have eigenvalue +1. Since Gjk
√
consists of at least two diﬀerent terms then 1/Mjk, the
normalization of Gjk, must be at most 1/

2.

We now argue that, for all m, tjkgm

jk appears only once
in the Pauli decomposition of P (cid:48), namely as part of the
decomposition of tjkGjk. If no other gl
jk exists such that
gl
jkgm
jk is a stabilizer, this is certainly true. After all,
tjk as a nonconstant stabilizer can only appear on block
j from one combination of stabilizer generators, namely
from tjkGjk itself. Indeed, it is the case that gl
jk can-
not be a stabilizer, as this would imply a constant (since
both gl
jk consist of Zs and Is) stabilizer exists in

jk and gm

jkgm

19
at least one block i (cid:54)= j that could be multiplied by the
(cid:4)
normalizer pi to get a lower weight normalizer.
This lemma can be used to verify that an intermedi-
ate codespace is non-stabilizer.
In particular, it says,
in the case of using lowest weight normalizers for the
construction, that if any nonconstant stabilizer tjk takes
the intermediate form tjkGjk, where Gjk is a product of
Ch−1Z gates not equal to identity, then the codespace is
non-stabilizer.

[1] A. M. Steane, Physical Review Letters 77, 793 (1996).
[2] X. Chen, H. Chung, A. W. Cross, B. Zeng, and I. L.

Chuang, Physical Review A 78, 012353 (2008).

[3] B. Eastin and E. Knill, Physical Review Letters 102,

110502 (2009).

[4] B. Zeng, A. Cross, and I. L. Chuang, Information Theory,

IEEE Transactions on 57, 6272 (2011).

pp. 56–65.

[20] A. M. Steane, Physical Review Letters 78, 2252 (1997).
[21] A. Steane, Fortschritte der Physik 46, 443 (1998).
[22] E. Knill, Nature 434, 39 (2005).
[23] E. Knill, R. Laﬂamme, and W. Zurek (1996).
[24] C. Zalka, arXiv preprint quant-ph/9612028 (1996).
[25] P. Aliferis, D. Gottesman, and J. Preskill, Quantum In-

[5] S. Bravyi and A. Kitaev, Physical Review A 71, 022316

formation & Computation 6, 97 (2006).

(2005).

[26] E. Knill and R. Laﬂamme, Physical Review A 55, 900

[6] S. Bravyi and J. Haah, Physical Review A 86, 052329

(1997).

(2012).

[27] C. H. Bennett, D. P. DiVincenzo, J. A. Smolin, and W. K.

[7] A. G. Fowler, S. J. Devitt, and C. Jones, Scientiﬁc reports

Wootters, Physical Review A 54, 3824 (1996).

3 (2013).

[8] C. D. Hill, A. G. Fowler, D. S. Wang, and L. C. Hol-
lenberg, Quantum Information & Computation 13, 439
(2013).

[28] R. Laﬂamme, C. Miquel, J. P. Paz, and W. H. Zurek,

Physical Review Letters 77, 198 (1996).

[29] D. Gottesman, Physical Review A 57, 127 (1998).
[30] A. M. Steane, Information Theory, IEEE Transactions

[9] J. T. Anderson, G. Duclos-Cianci, and D. Poulin, Phys-

on 45, 1701 (1999).

ical review letters 113, 080501 (2014).

[10] A. Paetznick and B. W. Reichardt, Physical Review Let-

[31] D. Gottesman and I. L. Chuang, Nature 402, 390 (1999).
[32] Y. Shi, Quantum Information & Computation 3, 84

ters 111, 090505 (2013).

(2003).

[11] T. Jochym-OConnor and R. Laﬂamme, Physical Review

Letters 112, 010505 (2014).

[33] D. Aharonov, arXiv preprint quant-ph/0301040 (2003).
[34] A. Y. Kitaev, Russian Mathematical Surveys 52, 1191

[12] H. Bombin and M. Martin-Delgado, Journal of Physics

(1997).

A: Mathematical and Theoretical 42, 095302 (2009).

[13] H. Bombin, New Journal of Physics 13, 043005 (2011).
[14] J. Preskill, in Proceedings of the Royal Society of Lon-
don A: Mathematical, Physical and Engineering Sciences
(The Royal Society, 1998), vol. 454, pp. 385–410.

[15] D. Gottesman, Physical Review A 54, 1862 (1996).
[16] A. R. Calderbank, E. M. Rains, P. W. Shor, and N. J.

Sloane, Physical Review Letters 78, 405 (1997).

[17] D. Gottesman, arXiv preprint quant-ph/9705052 (1997).
[18] M. A. Nielsen and I. L. Chuang, Quantum computation
and quantum information (Cambridge university press,
2010).

[19] P. W. Shor, in Foundations of Computer Science, 1996.
Proceedings., 37th Annual Symposium on (IEEE, 1996),

[35] P. O. Boykin, T. Mor, M. Pulver, V. Roychowdhury, and
F. Vatan, Information Processing Letters 75, 101 (2000).
[36] S. Aaronson and D. Gottesman, Physical Review A 70,

052328 (2004).

[37] M. M. Wilde, Physical Review A 79, 062322 (2009).
[38] A. R. Calderbank and P. W. Shor, Physical Review A

54, 1098 (1996).

[39] A. Steane, in Proceedings of the Royal Society of Lon-
don A: Mathematical, Physical and Engineering Sciences
(The Royal Society, 1996), vol. 452, pp. 2551–2577.

[40] Y. Li, I. Dumer, M. Grassl, and L. P. Pryadko, Physical

Review A 81, 052337 (2010).

