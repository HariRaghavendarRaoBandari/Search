A Relation Between Network Computation and

Functional Index Coding Problems

Department of Electrical Communication Engineering, Indian Institute of Science, Bengaluru 560012, KA, India

Email: {anindya.g, bsrajan}@ece.iisc.ernet.in

Anindya Gupta and B. Sundar Rajan

1

6
1
0
2

 
r
a

M
 
7
1

 
 
]
T
I
.
s
c
[
 
 

1
v
5
6
3
5
0

.

3
0
6
1
:
v
i
X
r
a

Abstract—In contrast to the network coding problem wherein
the sinks in a network demand subsets of the source messages,
in a network computation problem the sinks demand functions
of the source messages. Similarly, in the functional index coding
problem, the side information and demands of the clients include
disjoint sets of functions of the information messages held by the
transmitter instead of disjoint subsets of the messages, as is the
case in the conventional index coding problem. It is known that
any network coding problem can be transformed into an index
coding problem and vice versa. In this work, we establish a
similar relationship between network computation problems and
a class of functional index coding problems, viz., those in which
only the demands of the clients include functions of messages. We
show that any network computation problem can be converted
into a functional index coding problem wherein some clients
demand functions of messages and vice versa. We prove that
a solution for a network computation problem exists if and only
if a functional index code (of a speciﬁc length determined by
the network computation problem) for a suitably constructed
functional index coding problem exists. And, that a functional
index coding problem admits a solution of a speciﬁed length if
and only if a suitably constructed network computation problem
admits a solution.

Index Terms—Network Coding, Network Computation, In-
network Computation, Index Coding, Functional Index Coding.

I. INTRODUCTION

Conventional communication networks, like the Internet,
ensure transfer of information generated at some nodes to
others. It is known that network coding affords throughput gain
over routing in such networks [1]–[7], and given a network
and the demanded source messages at each sink, the network
coding problem is to design a network code that maximizes
the rate of information transfer from the source nodes to
the sinks. But in some networks, like a sensor networks for
environmental monitoring, nodes may be interested not in
the messages generated by some other nodes but in one or
more functions of these messages. Designing a network code
that maximizes the frequency of target functions computation,
called the computing capacity, per network use at the sinks is
known as the network computing problem [8]. This subsumes
the network coding problem as a special case. Environmental
monitoring in an industrial unit is an application of network
computation where relevant parameter may include tempera-
ture and level of exhaust gases which may assist in preventing
ﬁre and poisoning due to toxic gases respectively.

A simple way to perform network computation is to com-
municate all the messages relevant to the function required

at each sink using either network coding or routing. This is
not only highly inefﬁcient in terms of bandwidth usage and
power consumption but also undesirable in certain settings.
For example, in an election, who voted whom is to be kept
conﬁdential but
the sum total of votes received by each
candidate is to be publicized. An efﬁcient way is that function
computation be performed in-network, i.e., in a distributed
manner. The intermediate nodes on the paths between the
sources and the sinks perform network coding and commu-
nicate coded messages such that the sinks may compute their
desired functions without having to know the value of the
arguments. For example, if the maximum temperature is of
interest in a sensor network, then each sensor node need only
communicate the maximum of its own temperature reading and
the message it receives on its incoming edges, which may be
raw measurements or maximum temperatures of some sets of
nodes, and communicate it to its neighbor on the path towards
the sink node; the sink can then take maximum of the messages
it receives to obtain the maximum temperature reading among
all the nodes. Thus, network computation is performed in a
distributed fashion without having to communicate measure-
ment of each sensor node to the sink.

In [9], bounds on rate of computing symmetric functions
(invariant to argument permutations), like minimum, maxi-
mum, mean, median and mode, of data collected by sensors
in a wireless sensor network at a sink node were presented.
The notion of min-cut bound for the network coding problem
[2] was extended to the function computation problem in a
directed acyclic network with multiple sources and one sink
in [8]. The case of directed acyclic network with multiple
sources, multiple sinks and each sink demanding the sum
of source messages was studied in [10]; such a network is
called a sum-network. Relation between linear solvability of
multiple-unicast networks and sum-networks was established.
Furthermore, insufﬁciency of scalar and vector linear network
codes to achieve computing capacity for sum-networks was
shown. Coding schemes for computation of arbitrary functions
in directed acyclic network with multiple sources, multiple
sinks and each sink demanding a function of source messages
were presented in [11]. In [12], routing capacity, linear coding
capacity and nonlinear coding capacity for function computa-
tion in a multiple source single sink directed acyclic network
were compared and depending upon the demanded functions
and alphabet (ﬁeld or ring), advantage of linear network coding
over routing and nonlinear network coding over linear network
coding was shown.

The index coding problem was introduced in [13] and
ﬁnds potential commercial application in dissemination of
popular multimedia content in wireless ad hoc networks and
using digital video broadcast. An instance of the index coding
problem comprises a source, which generates a ﬁnite number
of messages, and a set of receivers. Each receiver knows a
subset of messages, called the Has-set, and demands another
subset of messages, called the Want-set. The objective is to
make a minimum number of encoded transmissions over a
noiseless broadcast channel such that the demands of all the
clients are satisﬁed upon reception of the same. Graph theory
has been extensively used to study this problem [14]–[17].
The case where the Has-sets includes linear combination of
messages was studied in [18] and [19]; such a scenario may
arise if some clients fail to receive some coded transmissions,
possibly due to power outage, bad weather, intermittent signal
reception, etc., and the transmitter will have to compute a new
index code after every transmissions taking into account the
updated caches, which may now include coded messages.

The functional index coding problem was recently proposed
in [20] as a generalization of the conventional index coding
problem. In a functional index coding problem, the Has- and
Want-sets of users may contain functions of messages rather
than only a subset of messages as is the case in a conventional
index coding problem. Thus, the conventional index coding
problem and the scenarios studied in [18] and [19] are special
cases of the functional index coding problem. In [20], bounds
on codebook size were obtained and a graph coloring approach
to obtaining a functional index code was given.

In [21], it was shown that any network coding problem can
be reduced to an index coding problem and that a network
coding problem admits a linear solution if and only if a linear
index code of a speciﬁc length (determined by the network
coding problem) exists for the corresponding index coding
problem. This relationship was extended to include nonlinear
codes in [22]. In [22], a method, similar to that given in [21], to
convert a network coding problem to an index coding problem
was given. It was shown that a network code for the former
problem exists if and only if an index code of a speciﬁc length
(determined by the network coding problem) exists; methods
to convert an index code to a network code and vice versa
were also given.

A. Contributions and Organization

In this paper, we explore the relationship of network com-
putation and a class of functional index coding problems. The
contributions of this paper are as follows:

1) In Section III, we give a method to construct a functional
index coding problem from a given network computation
problem (Deﬁnition 1). In the resulting functional index
coding problem, only the Want-sets of the clients include
functions of messages and the Has-sets are all subsets of
the message set (like in the conventional index coding
problem).

2) We show that a network code to perform in-network
computation of the functions demanded by the sinks
exists if and only if the corresponding functional index

2

coding problem admits a solution of a speciﬁc length,
which is determined by the original network (Theorem 1
in Section III). We give a method to convert a functional
index code for the obtained functional
index coding
problem into a network code for the original network
computation problem and vice versa. Thus, in order to
obtain a network code for a given network computation
problem, we convert it into a functional index coding
problem, construct a functional index code, and then
convert the functional index code to a network code for
the given network computation problem.

3) In Section IV, we show that any functional index coding
problem with only Want-sets containing functions of
messages can be converted as a network computation
problem (Deﬁnition 2). We prove that the functional index
coding problem admits a solution of a speciﬁc length if
and only if the network computation problem obtained
from it admits a solution (Proposition 1).

In Section II, relevant preliminaries of network computation
and functional index coding problems are given. We conclude
the paper with a summary of work presented and possible
directions of future work in Section V.

II. NETWORK MODEL

A brief overview of network computation and functional
index coding problems are presented in this section. A q-ary
ﬁnite ﬁeld is denoted by Fq and the set {1, 2, . . . , n} is denoted
by [n], for some positive integer n. All vectors are row vectors.
A realization of a random variable Z taking value from Fn
q ,
for some positive integer n, is denoted by z. A set containing
one element s is denoted by {s}.

A. Network Computation

A network is represented by a ﬁnite directed acyclic graph
N = (V, E), where V is the set of nodes and E = E ∪ ˜E is the
set of directed error-free links (edges), where the edges in E
correspond to the links between the nodes in the network and
the edges in ˜E correspond to the source messages generated
in the network. The sets of incoming and outgoing links of a
node w ∈ V are denoted by In(w) and Out(w) respectively.
For an edge e = (u, v) ∈ E from a node u to v, u and v
are called, respectively, its tail and head and In(e) = In(u),
i.e., In(e) is the set of edges which terminate at the node
at which e originates. The network may have multiple source
nodes and each may generate multiple messages. The source
messages are represented by tailless edges ˜ek ∈ ˜E that
terminate at a source node. The total number of messages
generated in the network is K = | ˜E| and are denoted by
random variables X1, X2, . . . , XK, where, for every k ∈ [K],
Xk is uniformly distributed over Fnk
q , for some positive integer
nk. Let NK = n1+n2+. . .+nK. Let X = (X1, X2, . . . , XK).
A realization of X is denoted by x = (x1, x2, . . . , xK), where
. The capacity
xk ∈ Fnk
q
of a link e ∈ E between nodes in the network is ne and
Ye is the associated random variable, i.e., ye ∈ Fne
q . Note
that for a source edge ˜ek ∈ ˜E,
the capacity is nk and
the associated random variable is Y˜ek = Xk respectively.

for all k ∈ [K] and x ∈ FNK

q

: FNK

The set of sink nodes is denoted by T . A sink node t
demands nt functions Gt = {gt,1(X), gt,2(X), . . . , gt,nt(X)},
q → Fq for all i ∈ [nt]. Let Gt(X) =
where gt,i
(gt,1(X), gt,2(X), . . . , gt,nt(X)). For a realization x of X,
Gt(x) = (gt,1(x), gt,2(x), . . . , gt,nt(x)) is the vector of func-
tion values sink t wishes to compute. The demands are denoted
by headless edges (not included in E) originating at sink nodes.
A network computation problem F (N (V, E), X, {Gt : t ∈
T }) is speciﬁed by the underlying network, the source mes-
sages, and the demands of each sink.

A network code {fe : e ∈ E} ∪ {Dt : t ∈ T } for a
network computation problem F (N (V, E), X, {Gt : t ∈ T })
is an assignment of a local encoding kernels fe to each edge
e ∈ E and a decoding function Dt to each sink t ∈ T . For
any e ∈ E, fe takes in (Ye′ )e′∈In(e) as input argument and
outputs Ye, i.e.,

3

(hi,1(z), hi,2(z), . . . , hi,|Hi|(z)) is the Has-value known to Ri
and Wi(z) = (wi,1(z), wi,2(z), . . . , wi,|Wi|(z)) as the Want-
value Ri is interested in computing.

The conventional index coding problem correspond to the
case in which all the Has- and Want-set are subsets of Z.
The case in which the Has-sets of the clients include linear
combinations of messages and the Want-sets are subsets of Z
was considered in [18] and [19].

A functional index code for a given I(Z, R) comprises an

encoding map

M : FNK

q −→ Fℓ

q

and a decoding function ˆDRi for every receiver Ri ∈ R, where

ˆDRi : Fℓ

q × F|Hi|

q −→ F|Wi|

q

and satisﬁes

fe : (Ye′ )e′∈In(e) 7−→ Ye.

ˆDRi(M(Z), Hi(Z)) = Wi(Z)

(4)

For any sink t ∈ T ,
(Ye′ )e′∈In(t)) as input argument and outputs Gt(X), i.e.,

the decoding map Dt

takes in

Dt : (Ye′ )e′∈In(t) 7−→ Gt(X)

(1)

for every realization x of X, x ∈ Fn1+n2+...+nK

.

q

The global encoding kernels {Fe : e ∈ E} and the decoding
functions {Dt : t ∈ T } give an alternate description of a
network code. For any edge e, Fe maps X to Ye (and thus, the
distribution of Ye depends upon the network code). Given the
local encoding kernels, the global encoding kernels for each
edge can be deﬁned by induction on an ancestral ordering
of the edges in the graph as follows [22, Sec. II]. For every
tailless edge ˜ek ∈ ˜E denoting the source message Xk, let
F˜ek (X) = Xk be the global encoding kernel. Then, for any
edge e ∈ E,

Fe(X) = fe (cid:0)(Fe′ (X))e′∈In(e)(cid:1) .

Also, by (1),

Dt (cid:0)(Fe′ (X))e′∈In(t)(cid:1) = Gt(X),

for every realization x of X, x ∈ FNK

.

q

(2)

(3)

B. Functional Index Coding

An instance I(Z, R) of a functional index coding problem

comprises

1) a transmitter equipped with the message vector Z =
(Z1, Z2, . . . , ZK), where, for every k ∈ [K], Zk is
uniformly distribute over Fnk
for some positive integer
q
nk and

2) a set of clients or receivers, R = {R1, R2, . . . , R|R|},
where Ri = (Hi, Wi) for all Ri ∈ R. For any re-
ceiver Ri, Hi = {hi,1(Z), hi,2(Z), . . . , hi,|Hi|(Z)} and
Wi = {wi,1(Z), wi,2(Z), . . . , wi,|Wi|(Z)} are the Has-
and Want-sets respectively, where hi,j , wi,l : FNK
q → Fq
for 1 6 j 6 |Hi| and 1 6 l 6 |Wi| (NK =
n1 + . . . + nK).

Let Hi(Z) = (hi,1(Z), hi,2(Z), . . . , hi,|Hi|(Z)) and
Wi(Z) = (wi,1(Z), wi,2(Z), . . . , wi,|Wi|(Z)). For a realiza-
tion z = (z1, z2, . . . , zK) of Z at the transmitter, Hi(z) =

for every realization z of Z, z ∈ FNK

.

q

q } ⊆ Fℓ

Here ℓ is the length of the functional index code. Let
q denote the codebook of the
BM = {M(z) : z ∈ FNK
code deﬁned by M. The transmitter broadcasts ℓ length code-
words, M(z), and the receivers use their respective decoding
functions to obtain the values of their desired functions. The
objective of code design is to minimize ℓ so that maximum
throughput gain is achieved.

III. FROM NETWORK COMPUTATION PROBLEM TO

FUNCTIONAL INDEX CODING PROBLEM

In this section, we obtain a functional index coding problem
from a network computation problem and show that a given
network computation problem is feasible if and only if the
corresponding functional index coding problem is. The proof
technique followed is similar to that of [22, Th. 1].

Deﬁnition 1: Let F (N (V, ˜E ∪ E), X, {Gt

t ∈ T })
be a network computation problem with K messages
X1, X2, . . . , XK, where, for every k ∈ [K], Xk is uniformly
distributed over Fnk
for some positive integer nk, the capacity
q
of an edge e ∈ E is ne for some positive integer ne, and,
every sink t ∈ T demands a set of nt functions, Gt =
{gt,1(X), gt,2(X), . . . , gt,nt(X)} for some positive integer nt.
A functional index coding problem IF (Z, R) can be obtained
as follows:

:

1) The transmitter has access to the message vector Z =
( ˆX, ˆY ), where ˆX = ( ˆXk)k∈[K] and ˆY = ( ˆYe)e∈E. A
message ˆXk, k ∈ [K], is uniformly distributed over Fnk
and a message ˆYe, e ∈ E, is uniformly distributed over
for every e ∈ E. The quantities nk, k ∈ [K], and ne,
Fne
e ∈ E, are speciﬁed by the network computation problem
F.

q

q

2) The set R = RE ∪ RT ∪ {Rall} of |E| + |T | + 1 clients

is deﬁned as follows:

• RE = {Re : e ∈ E}, where the Has- and Want-sets
of Re are He = { ˆYe′ : e′ ∈ In(e)} and We = { ˆYe}
respectively for any e ∈ E.

• RT = {Rt : t ∈ T }, where the Has- and Want-
: e ∈ In(t)} and

sets of Rt are Ht = { ˆYe

Wt = {gt,1( ˆX), gt,2( ˆX), . . . , gt,nt( ˆX)} respectively
for any t ∈ T .

• The Has-set of the client Rall is { ˆXk : k ∈ [K]} and

its Want-sets is { ˆYe : e ∈ E}.

Note that in the functional index coding problem obtained
from a network computation problem using the above deﬁni-
tion
a) the Has-set of every receiver will be a subset of the

messages { ˆX1, ˆX2, . . . , ˆXK , ˆYe1 , ˆYe2 , . . . , ˆYe|E| } and

b) only the Want-sets of the receivers in RT , i.e., the receivers
corresponding to sinks in the starting network computation
problem, will contain functions of messages.
Theorem 1: For a given network computation problem
F (N (V, ˜E ∪ E), X, {Gt
: t ∈ T }), let IF (Z, R) be the
corresponding functional index coding problem constructed
using Deﬁnition 1. Then, a network code for F exists if and
only if a functional index code of length Pe∈E ne exists for
IF .
Proof: Let NK = Pk∈[K] nk and NE = Pe∈E ne. To
prove the theorem, we will show that any network code for F
can be converted into a functional index code of length NE
for IF and vice versa.

Converting a network code into a functional index code:
Suppose there is a network code for F and let {fe : e ∈ E},
{Fe : e ∈ ˜E}, and {Dt : t ∈ T } be its local encoding kernels,
global encoding kernels, and decoding functions respectively.

Deﬁne a map

M : FNK +NE

q

−→ FNE

q

by

M(Z) = (Me(Z))e∈E = ( ˆYe + Fe( ˆX))e∈E ,

(5)

where Me : Z = ( ˆX, ˆY ) 7→ ˆYe + Fe( ˆX), for any e ∈ E.
We will verify that broadcasting (Me(Z))e∈E satisﬁes all the
receivers of IF by constructing a decoding map for each
receiver using the local and global encoding kernels and the
decoding functions speciﬁed by the network code. The length
of this code is Pe∈E ne = NE.
1) A receiver Re ∈ RE knows He = { ˆYe′ : e′ ∈ In(e)}
and wants We = { ˆYe}. Note that He(Z) = ( ˆYe′ )e′∈In(e)
and We(Z) = ˆYe. The decoding map ˆDRe is obtained as
follows:

• Compute Fe′ ( ˆX) = Me′ (Z) − ˆYe′ for each e′ ∈
In(e) using the known information ˆYe′ and the
broadcast message Me′(Z).

• Then, using (2), compute

Fe( ˆX) = fe (cid:16)(Fe′ ( ˆX))e′∈In(e)(cid:17) .

• The demanded message is ˆYe = Me(Z) − Fe( ˆX).

Thus, for a receiver Re ∈ RE, the map

ˆDRe (cid:16) (Me(Z))e∈E , ( ˆYe′ )e′∈In(e) (cid:17) =

Me(Z) − fe (cid:16)(Me′ (Z) − ˆYe′ )e′∈In(e)(cid:17) = ˆYe

(6)

satisﬁes (4) and hence is a decoding function for Re.

4

2) A receiver Rt ∈ RT knows Ht = { ˆYe′ : e′ ∈ In(t)}
and wants Wt = {gt,1( ˆX), gt,2( ˆX), . . . , gt,nt( ˆX)}. Note
that Ht(Z) = ( ˆYe′ )e′∈In(t) and Wt(Z) = Gt( ˆX). The
decoding map ˆDRt is obtained as follows:

• Compute Fe′ ( ˆX) = Me′(Z)− ˆYe′ for each e′ ∈ In(t)
using the known information ˆYe′ and the broadcast
message Me′ (Z).

• Then, by (3)

Gt( ˆX) = Dt (cid:16)(Fe′ ( ˆX))e′∈In(t)(cid:17) .

Thus, for a receiver Rt ∈ RT , the map
ˆDRt (cid:16) (Me(Z))e∈E , ( ˆYe′ )e′∈In(t) (cid:17) =

Dt (cid:16) (Me′ (Z) − ˆYe′ )e′∈In(t) (cid:17) = Gt( ˆX) (7)

satisﬁes (4) and hence is a decoding function for Rt.

3) Since Rall knows all ˆXk, k ∈ [K], and demands all ˆYe,

e ∈ E, the decoding function for receiver Rall is

ˆDRall (cid:16)(Me(Z))e∈E , ˆX(cid:17) = (cid:16)Me(Z) − Fe( ˆX)(cid:17)e∈E

= ( ˆYe)e∈E.

(8)

Thus, any network code for F can be converted into a
functional index code of length NE for IF using (5), (6),
(7), and (8).

We now prove the converse.
Converting a functional index code into a network code:
Assume that a functional index of length NE is given for
IF (Z, R), i.e., an encoding map M and decoding functions
{ ˆDRe : Re ∈ RE}∪{ ˆDRt : Rt ∈ RT }∪{ ˆDRall} are speciﬁed.
We will construct a network code for the network computation
problem F (N (V, ˜E ∪ E), X, {Gt : t ∈ T }), i.e., specify local
encoding kernels for edges in E and decoding functions for
sinks in T , using the given functional index code. Let BM ⊆
FNE

denote the codebook.

q

q

q

Since Rall can decode its demanded messages,

it must
be true that M(ˆx, ˆy) 6= M(ˆx, ˆy′) for every ˆx ∈ FNK
such that ˆy 6= ˆy′ (otherwise, if
and every ˆy, ˆy′ ∈ FNE
M(ˆx, ˆy) = M(ˆx, ˆy′) = m (say),
then, given ˆx and the
broadcast codeword m, Rall will not be able to distinguish
between ˆy and ˆy′).1 Thus, for each ˆx ∈ FNK
, the elements
q } are all distinct and hence
of Bˆx = {M(ˆx, ˆy) : ˆy ∈ FNE
(since Bˆx ⊆ BM ⊆
|Bˆx| = qNE . Consequently, Bˆx = FNE
and |Bˆx| = qNE ). Thus, given any m ∈ BM and any
FNE
, there exists a unique realization ˆyˆx of ˆY such that
ˆx ∈ FNK
M(ˆx, ˆyˆx) = m. Speciﬁcally, let m = 0, where 0 is the all
zero NE-tuple, and A0 = {(ˆx, ˆyˆx) : ˆx ∈ FNK
, M(ˆx, ˆyˆx) =
, there
0}. Note that |A0| = qNK (since for each ˆx ∈ FNK
exists a unique ˆyˆx with M(ˆx, ˆyˆx) = 0). Let ˆyˆx = (ˆye,ˆx)e∈E.
Then, by (4), for every (ˆx, ˆyˆx) ∈ A0

q

q

q

q

q

q

ˆDRe (M(ˆx, ˆyˆx), He(ˆx, ˆyˆx)) = ˆDRe (cid:0)0, (ˆye′,ˆx)e′∈In(e)(cid:1)

= ˆye,ˆx

(9)

′, HR(z) = HR(z

1For every receiver R in a functional index coding problem I(Z, R), if, for
′), then an encoding
some z 6= z
map M must satisfy M(z) 6= M(z
′), otherwise the demands of R will not
be met [20, Prop. 1]. This constraint on the encoding map is referred to as
the generalized exclusive law [20, Def. 3].

′) and WR(z) 6= WR(z

for every receiver Re ∈ RE and

ˆDRt (M(ˆx, ˆyˆx), Ht(ˆx, ˆyˆx)) = ˆDRt (cid:0)0, (ˆye′,ˆx)e′∈In(t)(cid:1)

= Gt(ˆx)

(10)

for every receiver Rt ∈ RT , and ˆDRall (M(ˆx, ˆyˆx), ˆx) =
ˆDRall (0, ˆx) = ˆyˆx.

For an edge e ∈ E, deﬁne a map
fe : FPe′ ∈In(e) ne′

q

−→ Fne
q

by

fe (cid:0)(Ye′ )e′∈In(e)(cid:1) = ˆDRe (cid:0)0, (Ye′ )e′∈In(e)(cid:1)

(11)

and for a sink t ∈ T , deﬁne a map
Dt : FPe′∈In(t) ne′

q

−→ Fnt
q

by

Dt (cid:0)(Xe′ )e′∈In(t)(cid:1) = ˆDRt (cid:0)0, (Ye′ )e′∈In(t)(cid:1) .

(12)

We will verify that {fe : e ∈ E} ∪ {Dt : t ∈ T } is a network
code for F.

Let x be an arbitrary realization of X and (ˆx, ˆyˆx) be the

element of A0 such that x = ˆx.

Recall that a tailless edge ˜ek ∈ ˜E, k ∈ [K], represents a
source message Xk and that Y˜e = Xk. First we will show
that y = ˆyˆx, i.e., ye = ˆye,ˆx for every e ∈ E, by induction on
an ancestral ordering of edges in E as follows. Let an edge
e ∈ E originate at a source node such that In(e) ⊆ ˜E (or
In(e) ∩ E = ∅) (base case of induction). Then, by (11) and
(9),

ye = fe (cid:0)(ye′ )e′∈In(e)(cid:1) = ˆDRe (cid:0)0, (ye′ )e′∈In(e)(cid:1) = ˆye,ˆx.

Now let for some edge e ∈ E, every e′ ∈ In(e) satisﬁes
ye′ = ˆye′,ˆx (induction hypothesis). Then, again by (11) and
(9),

ye = fe (cid:0)(ye′ )e′∈In(e)(cid:1) = ˆDRe (cid:0)0, (ye′ )e′∈In(e)(cid:1) = ˆye,ˆx.

Thus, ye = ˆye,ˆx for every e ∈ E.

Now consider any t ∈ T . Then, by (12) and (10),
Dt (cid:0)(ye′ )e′∈In(t)(cid:1) = ˆDRt (cid:0)0, (ye′ )e′∈In(t)(cid:1)

= ˆDRt (cid:0)0, (ˆye′,ˆx)e′∈In(t)(cid:1) = Gt(ˆx)
= Gt(x),

which is the required function value at t.

Thus, (11) and (12) deﬁne a network code for F.
Remark 1: In the proof of the converse of Theorem 1, we
chose m to be 0 to deﬁne a network code ((11) and (12)).
Instead of 0, m can be chosen to be any element of FNE
to
deﬁne a network code. Thus, for any m ∈ FNE

,

q

q

fe (cid:0)(Ye′ )e′∈In(e)(cid:1) = ˆDRe (cid:0)m, (Ye′ )e′∈In(e)(cid:1)
Dt (cid:0)(Xe′ )e′∈In(t)(cid:1) = ˆDRt (cid:0)m, (Ye′ )e′∈In(t)(cid:1)

is a network code.

Example 1: Consider the network computation problem
given in Fig. 1. There are 11 source nodes each generating
a 10-bit long message and there is only one sink which wants

5

X3

X7

X6

e4

X3

X9

m

a

x

{

e

X

8

9
e

6,

Y

e

3}

}
4
e
Y

,
7

X
{
x
a
m

X1

X4

e1

X1

X2

X5

e2

X2

X
2

e

3

m

ax{X
e

5

4,Y

e

1}

}

e 2

{ X 5 ,
e

Y

6

x

m a

m

ax{X
e

7

5,Y

e

2}

X8

m

a

x{X

e

1

0

8,Y

e

5,Y

e

6}

}

7

e

9, Y

1

e 1
x { X

m a

X10

m

a

x

{

X

e

1

2

1

0,

Y

}

9

e

, Y

8

e

X11

1, Y

1

3

e 1
x { X

a

e

1

0,

Y

e

1

1}

t

m

Fig. 1. A function computation problem.

max{X1, X2, . . . , X11}

to compute the maximum among the decimal equivalents of
messages. All dashed and solid edges have capacity 10 bits
(NE = 130). By max, we mean the maximum of the decimal
equivalent. The local encoding kernels are given adjacent to
the edges. The local and global encoding kernels of edges
e1, e2, . . . , e13 are given in Table I below.

Ye

fe (cid:16)(Ye′ )e′∈In(e)(cid:17)

Fe(X1, . . . , X11)

TABLE I

X3

X3

X1

X1

X2

X2

X2

X2

Ye1
Ye2
Ye3
Ye4
Ye5
Ye6
Ye7
Ye8
Ye9
Ye10
Ye11
Ye12 max{Ye10 , Ye11 , X10} max{X1, X2, X4, X5, X8, X9, X10}
Ye13 max{Ye8 , Ye9 , X11}

max{Ye1 , X4}
max{Ye2 , X5}
max{Ye2 , X5}
max{Ye3 , X6}
max{Ye4 , X7}

max{X2, X3, X6, X7, X11}

max{X1, X2, X4, X5, X8}

max{Ye5 , Ye6 , X8}

max{X2, X5, X9}

max{Ye7 , X9}

max{X2, X5}

max{X1, X4}

max{X3, X7}

max{X2, X5}

max{X2, X6}

The decoding function for sink t is

Dt(Ye12 , Ye13 ) = max{Ye12 , Ye13 } = max{X1, X2, . . . , X11}.

The corresponding functional index coding problem ob-
tained using Deﬁnition 1 is given by the ﬁrst three columns of
Table II at the top of the following page. The message vector
is ( ˆX, ˆY ) = ( ˆX1, . . . , ˆX11, ˆYe1 , . . . , ˆYe13 ) and each message
is a 10-bit word. A functional index code obtained using (5)
is given in Table III. The decoding maps of clients obtained
using (6),(7), and (8) are given in the last column of Table II
(by Me we mean Me( ˆX, ˆY ) for all e ∈ E).
(cid:3)
Example 2: Consider the network computation problem
given in Fig. 2. Each message takes value from the binary
ﬁeld and each edge has a capacity of 1 bit. The corresponding
functional index coding problem obtained using Deﬁnition 1
is given by the ﬁrst three columns of Table IV. The message
vector is ( ˆX, ˆY ) = ( ˆX1, . . . , ˆX4, ˆYe1 , . . . , ˆYe18 ) and each
message takes value from the binary ﬁeld. A functional index

Client

Has-set

Want-set

TABLE II

Re1
Re2
Re3
Re4
Re5
Re6
Re7
Re8
Re9
Re10
Re11
Re12
Re13
Rt

ˆX1
ˆX2
ˆX2
ˆX3

ˆX4, ˆYe1
ˆX5, ˆYe2
ˆX5, ˆYe2
ˆX6, ˆYe3
ˆX7, ˆYe4

ˆX8, ˆYe5 , ˆYe6

ˆX9, ˆYe7

ˆX10, ˆYe10 , ˆYe11
ˆX11, ˆYe8 , ˆYe9

ˆYe1
ˆYe2
ˆYe3
ˆYe4
ˆYe5
ˆYe6
ˆYe7
ˆYe8
ˆYe9
ˆYe10
ˆYe11
ˆYe12
ˆYe13

ˆYe12 , ˆYe13 max{ ˆX1, . . . , ˆX11}
ˆY1, ˆY2, ˆY3, ˆY4, ˆY5,

Rall

ˆX1, . . . , ˆX11

ˆY6, ˆY7, ˆY8,
ˆY9, ˆY10, ˆY11,

ˆY12, ˆY13

Decoding Map

Me1 + ˆX1
Me2 + ˆX2
Me3 + ˆX2
Me4 + ˆX3

Me5 + max{Me1 + ˆYe1 , ˆX4}
Me6 + max{Me2 + ˆYe2 , ˆX5}
Me7 + max{Me2 + ˆYe2 , ˆX5}
Me8 + max{Me3 + ˆYe3 , ˆX6}
Me9 + max{Me4 + ˆYe4 , ˆX7}

Me10 + max{Me5 + ˆYe5 , Me6 + ˆYe6 , ˆX8}

Me11 + max{Me7 + ˆYe7 , ˆX9}

Me12 + max{Me10 + ˆYe10 , Me11 + ˆYe11 , ˆX10}
Me13 + max{Me8 + ˆYe8 , Me9 + ˆYe9 , ˆX11}

max{Me12 + ˆYe12 , Me13 + ˆYe13 }

6

TABLE III

ˆYe + Fe( ˆX)
ˆYe1 + ˆX1
ˆYe2 + ˆX2
ˆYe3 + ˆX2
ˆYe4 + ˆX3

ˆYe5 + max{ ˆX1, ˆX4}
ˆYe6 + max{ ˆX2, ˆX5}
ˆYe7 + max{ ˆX2, ˆX5}
ˆYe8 + max{ ˆX2, ˆX6}
ˆYe9 + max{ ˆX3, ˆX7}

ˆYe10 + max{ ˆX1, ˆX2, ˆX4, ˆX5, ˆX8}

ˆYe11 + max{ ˆX2, ˆX5, ˆX9}

ˆYe12 + max{ ˆX1, ˆX2, ˆX4, ˆX5, ˆX8, ˆX9, ˆX10}

ˆYe13 + max{ ˆX2, ˆX3, ˆX6, ˆX7, ˆX11}

Me( ˆX, ˆY )

Me1
Me2
Me3
Me4
Me5
Me6
Me7
Me8
Me9
Me10
Me11
Me12
Me13

(Me1 + ˆX1, Me2 + ˆX2, Me3 + ˆX2, Me4 + ˆX3, Me5 + max{ ˆX1, ˆX4},
Me6 + max{ ˆX2, ˆX5}, Me7 + max{ ˆX2, ˆX5}, Me8 + max{ ˆX2, ˆX6},

Me9 + max{ ˆX3, ˆX7}, Me10 + max{ ˆX1, ˆX2, ˆX4, ˆX5, ˆX8}, Me11 + max{ ˆX2, ˆX5, ˆX9},

Me12 + max{ ˆX1, ˆX2, ˆX4, ˆX5, ˆX8, ˆX9, ˆX10}, Me13 + max{ ˆX2, ˆX3, ˆX6, ˆX7, ˆX11})

TABLE IV

Client

Has-set

Want-set

Decoding Map

Client

Has-set

Want-set

Decoding Map

Re1
Re2
Re3
Re4
Re5
Re6
Re7
Re8
Re9
Re10
Re11
Re12

ˆX1, ˆX2
ˆX1, ˆX2
ˆX1, ˆX2
ˆX3, ˆX4
ˆX3, ˆX4
ˆX3, ˆX4

ˆYe1
ˆYe1
ˆYe1

ˆYe2 , ˆYe4
ˆYe2 , ˆYe4
ˆYe2 , ˆYe4

Me1 + ˆX1
Me2 + ˆX2

Me3 + ˆX1 + ˆX2
Me4 + ˆX3 + ˆX4

Me5 + ˆX4
Me6 + ˆX3

ˆYe1
ˆYe2
ˆYe3
ˆYe4
ˆYe5
ˆYe6
ˆYe7
ˆYe8
ˆYe9
ˆYe10 Me10 + Me2 + ˆYe2 + Me4 + ˆYe4
ˆYe11 Me11 + Me2 + ˆYe2 + Me4 + ˆYe4
ˆYe12 Me12 + Me2 + ˆYe2 + Me4 + ˆYe4

Me7 + Me1 + ˆYe1
Me8 + Me1 + ˆYe1
Me9 + Me1 + ˆYe1

Re13
Re14
Re15
Re16
Re17
Re18
Rt1
Rt2
Rt3
Rt4
Rt5
Rt6

ˆYe3 , ˆYe5
ˆYe3 , ˆYe5
ˆYe3 , ˆYe5

ˆYe6
ˆYe6
ˆYe6

ˆYe7 , ˆYe10
ˆYe8 , ˆYe13
ˆYe9 , ˆYe16
ˆYe11 , ˆYe14
ˆYe12 , ˆYe17
ˆYe15 , ˆYe18

ˆYe13
ˆYe14
ˆYe15
ˆYe16
ˆYe17
ˆYe18

ˆX1 + ˆX2 + ˆX3 + ˆX4

ˆX2 + ˆX4
ˆX1 + ˆX3
ˆX1 + ˆX3
ˆX2 + ˆX4

ˆX1 + ˆX2 + ˆX3 + ˆX4

Me13 + Me3 + ˆYe3 + Me5 + ˆYe5
Me14 + Me3 + ˆYe3 + Me5 + ˆYe5
Me15 + Me3 + ˆYe3 + Me5 + ˆYe5

Me16 + Me6 + ˆYe6
Me17 + Me6 + ˆYe6
Me18 + Me6 + ˆYe6

Me7 + ˆYe7 + Me10 + ˆYe10
Me8 + ˆYe8 + Me13 + ˆYe13
Me9 + ˆYe9 + Me16 + ˆYe16
Me11 + ˆYe11 + Me14 + ˆYe14
Me12 + ˆYe12 + Me17 + ˆYe17
Me15 + ˆYe15 + Me18 + ˆYe18

Client

Has-set

Want-set

Decoding Map

ˆX1, ˆX2,
ˆX3, ˆX4

Rall

ˆY1, . . . , ˆY6
ˆY7, . . . , ˆY12
ˆY13, . . . , ˆY18 Me13 + ˆX1 + ˆX2 + ˆX4, Me14 + ˆX1 + ˆX2 + ˆX4, Me15 + ˆX1 + ˆX2 + ˆX4, Me16 + ˆX3, Me17 + ˆX3, Me18 + ˆX3)

Me7 + ˆX1, Me8 + ˆX1, Me9 + ˆX1, Me10 + ˆX2 + ˆX3 + ˆX4, Me11 + ˆX2 + ˆX3 + ˆX4, Me12 + ˆX2 + ˆX3 + ˆX4,

(Me1 + ˆX1, Me2 + ˆX2, Me3 + ˆX1 + ˆX2, Me4 + ˆX3 + ˆX4, Me5 + ˆX4, Me6 + ˆX3,

code for the same is given in Table V, and the decoding maps
of clients obtained using (6),(7), and (8) are given in the last
column of Table IV.

X1

s1

e2

e1

X2

X3

e3

e4

X4

s2

e6

e5

e7

e8

e9

e10

e12

e11

e13

e14

e15

e16

e18

e10

Me( ˆX, ˆY )

Me1
Me2
Me3
Me4
Me5
Me6
Me7
Me8
Me9

ˆYe + Fe( ˆX)
ˆYe1 + ˆX1
ˆYe2 + ˆX2

ˆYe3 + ˆX1 + ˆX2
ˆYe4 + ˆX3 + ˆX4

ˆYe5 + ˆX4
ˆYe6 + ˆX3
ˆYe7 + ˆX1
ˆYe8 + ˆX1
ˆYe9 + ˆX1

TABLE V

Me( ˆX, ˆY )

ˆYe + Fe( ˆX)

Me10
Me11
Me12
Me13
Me14
Me15
Me16
Me17
Me18

ˆYe10 + ˆX2 + ˆX3 + ˆX4
ˆYe11 + ˆX2 + ˆX3 + ˆX4
ˆYe12 + ˆX2 + ˆX3 + ˆX4
ˆYe13 + ˆX1 + ˆX2 + ˆX4
ˆYe14 + ˆX1 + ˆX2 + ˆX4
ˆYe15 + ˆX1 + ˆX2 + ˆX4

ˆYe16 + ˆX3
ˆYe17 + ˆX3
ˆYe18 + ˆX3

t1

t2

t3

t4

t5

t6

X1 + X2+
X3 + X4

X2 + X4

X1 + X3 X1 + X3

X2 + X4

Fig. 2. A function computation problem.

X1 + X2+
X3 + X4

The local encoding kernels obtained using (11) (by setting
Me = 0 for all e ∈ E and replacing ˆXk with Xk and ˆYe with
Ye in the last column of Table IV) and the resulting global

encoding kernels (by (2)) are given in Table VI.

2) The set of vertices is V = S ∪ T ∪ B.

7

Ye

fe

Fe

X1

X1

X2

X2

Ye1
Ye2
Ye3 X1 + X2 X1 + X2
Ye4 X3 + X4 X3 + X4
Ye5
Ye6
Ye7
Ye8
Ye9

Ye1
Ye1
Ye1

X3

X3

X1

X1

X1

X4

X4

TABLE VI

Ye

Ye10
Ye11
Ye12
Ye13
Ye14
Ye15
Ye16
Ye17
Ye18

fe

Fe

Ye2 + Ye4 X2 + X3 + X4
Ye2 + Ye4 X2 + X3 + X4
Ye2 + Ye4 X2 + X3 + X4
Ye3 + Ye5 X1 + X2 + X4
Ye3 + Ye5 X1 + X2 + X4
Ye3 + Ye5 X1 + X2 + X4

Ye6
Ye6
Ye6

X3

X3

X3

In Table VII below, the decoding maps for sinks t1, . . . , t6
obtained using (12) (by setting Me = 0 for all e ∈ E and
replacing ˆYe with Ye in the last column of Table IV) are
veriﬁed to output desired function at each sink by substituting
values of Ye, e ∈ E, from the last column (global encoding
kernels) of Table VI.

TABLE VII

Decoding Map

Ye7 + Ye10 = X1 + (X2 + X3 + X4)

Ye8 + Ye13 = X1 + (X1 + X2 + X4) = X2 + X4

Ye9 + Ye16 = X1 + X3

Ye11 + Ye14 = (X2 + X3 + X4) + (X1 + X2 + X4) = X1 + X3

Ye12 + Ye17 = (X2 + X3 + X4) + X3 = X2 + X4

Ye15 + Ye18 = (X1 + X2 + X4) + X3

Sink

t1

t2

t3

t4

t5

t6

Thus, Table VI is a network code for network computation
(cid:3)

problem of Fig. 2.

IV. FROM FUNCTIONAL INDEX CODING PROBLEM TO

NETWORK COMPUTATION PROBLEM

In the previous section, we showed that any network compu-
tation problem can be converted into a functional index coding
problem wherein only the Want-sets of some of the receivers
included functions of source messages. In this section, we
obtain a network computation problem from a given func-
tional index coding problem with only Want-sets containing
functions of messages and show that solution to one problem
can be converted into a solution for the other.

Deﬁnition 2: Let I(Z, R) be a functional index coding
problem with K messages Z1, Z2, . . . , ZK, where, for every
k ∈ [K], Zk is uniformly distributed over Fnk
for some
q
positive integer nk and R = {R1, R2, . . . , RM } is the
set of M clients. For any client Ri,
is a
subset of the messages set {Z1, Z2, . . . , ZK} and its Want-
includes some functions of the messages, Wi =
set Wi
{wi,1(Z), wi,2(Z), . . . , wi,|Wi|(Z)}, where NK = n1 + . . . +
q → Fq for 1 6 l 6 |Wi|. That is, only
nK and wi,l : FNK
the Want-sets of the clients include functions of messages.
Let ℓ be a positive integer. A network computation problem
FI(N (S ∪T ∪B, ˜E ∪E), X, {Gt : t ∈ T }) can be constructed
as follows:

its Has-set Hi

• S = {s1, s2, . . . , sK} is the set of K source vertices.

Source sk generates message Xk.

• T = {t1, t2, . . . , tM } is the set of M sink nodes. Sink

tm demands the functions in the set Gtm = Wm.

• B = {vB, v′

B}.

3) The set ˜E is the set of tailless source edges, where
˜E = {˜e1, ˜e2, . . . , ˜eK} (˜ek terminates at sk, corresponds
to Xk, and has capacity nk) and the set of directed
network edges is E = E1 ∪ E2 ∪ E3 ∪ {eB}.

• E1 = {(sk, tm) : Zk ∈ Hm, sk ∈ S, tm ∈ T }. The

capacity of an edge (sk, tm) ∈ E1 is nk.

• E2 = {(sk, vB) : sk ∈ S} and the capacity of an

edge (sk, vB) is nk.

• E3 = {(v′

B, tm) : tm ∈ T } and the capacity of an

edge (v′

B, tm) is ℓ.

• eB = (vB , v′

B) and the capacity of this edge is ℓ.

Remark 2: a) Since the demands of the sink tm in FI and
the client Rm in I are the same, Gtm(x) = Wm(x) for
every x ∈ FNK

.

q

b) Node vB is the only node in the network that has in-
degree greater than one and hence the only node that can
perform coding operations. The node vB has access to
all the source messages X1, X2, . . . , XK via the edges
in E2 and each sink tm ∈ T has access to all
the
information received by v′
B via the edges in E3. Thus,
the node vB and the coded message it passes on the edges
B) in the network computation problem correspond,
(vB , v′
respectively, to the transmitter (that knows all the messages
Z1, Z2, . . . , ZK and performs coding operations) and the
functional index code it broadcasts (received by all the
clients) in the functional index coding problem.

c) The node v′

B simply forwards the coded message it receives

from vB to all the sinks tm ∈ T via the edges in E3.

d) The edges in E1 represent the Has-sets of the clients; there
is an edge from sk to tm in the network if and only if
client Rm knows Zk. Also, In(tm) = {(sk, tm) : Zk ∈
B, tm)} and |In(tm)| = |Hm| + 1 for every
Hm} ∪ {(v′
tm ∈ T (or, equivalently Rm ∈ R). In other words, through
an edge (sk, tm) ∈ E1, tm receives Xk, i.e.,

(Xk)k:(sk ,tm)∈In(tm) = Hm(X),

(13)

B , tm) it receives the coded message

and through edge (v′
on edge eB.
Proposition 1: For a given functional index coding problem
I(Z, R) (with only Want-sets containing functions of mes-
sages), let FI(N (S ∪ T ∪ B, ˜E ∪ E), X, {Gt : t ∈ T }) be
the corresponding network computation problem constructed
using Deﬁnition 2. Let ℓ be a positive integer. Then, a
functional index code of length ℓ for I exists if and only
if a network code for FI exists.

Proof: Let NK = n1 + n2 + . . . + nK. We will show that
any network code for FI can be converted into a functional
index code of length ℓ for I and vice versa.

1) The message vector X = Z,

i.e., K messages
X1, X2, . . . , XK are generated in the network and Xk =
Zk for all k ∈ [K].

Converting a network code into a functional index code:
Suppose there is a network code for FI and let FeB be
the global encoding kernel of the edge eB (since this is the

only edge that carries coded message) and {Dtm : tm ∈ T }
be the set of decoding functions of sinks. Then by (3) and
Remark 2(d), for every sink tm ∈ T we have

Dtm (cid:0)FeB (X), (Xk)k:(sk ,tm)∈In(tm)(cid:1) = Gtm(X).

(14)

By (14) and (13)

TABLE VIII

Has-set

Want-set

Decoding Map

R1 X2, X3 M aj(X1 + X6, X2 + X3, X4) M aj(C1 , X2 + X3, C2 + X3)

R2 X4, X5

X1 + X5 + X6, X3

(C1 + X5, C2 + X4)

R3 X3, X6 X2 + X5, X1 + X3 + X6

R4 X1

X6

C3, C1 + X3

C1 + X1

8

Dtm (cid:0)FeB (X), (Xk)k:(sk ,tm)∈In(tm)(cid:1) =

Dtm(FeB (X), Hm(X)) = Gtm(X).

Deﬁne a map M : FNK

q → Fℓ

q by

M(Z) = FeB (Z)

(15)

(16)

(X1 +X6, X3 +X4, X2 +X5). The decoding function of each
client is given in the last columns of Table VIII.

The network computation problem obtained using Deﬁni-
tion 2 is given in Fig. 3. The capacity of each dash-dotted
edge is ℓ(> 0).

and a map ˆDRm for every client Rm ∈ R by

ˆDRm(M(Z), Hm(Z)) = Dtm(M(Z), Hm(Z)).

(17)

For any receiver Rm ∈ R, by (17), (16), (15), and Re-
mark 2(a), we have

ˆDRm(M(Z), Hm(Z)) = Dtm(M(Z), Hm(Z))

= Dtm(FeB (Z), Hm(Z)) = Gtm(Z)
= Wm(Z)

and hence ˆDRm satisfy (4). Thus, (16) deﬁnes a functional
index code for I(Z, R) with decoding maps ˆDRm, Rm ∈ R,
as deﬁned in (17).

Converting a functional index code into a network code:
Assume that a functional index code of length ℓ is given for
I(Z, R), i.e., an encoding map M and decoding functions
{ ˆDRm : Rm ∈ R} are speciﬁed. We will construct a network
code for the network computation problem FI, i.e., specify
the global encoding kernel of the edge eB (since this the only
edge that carries coded message) and decoding functions Dtm
for each sink in tm ∈ T , using the given functional index
code.

By (4), for every client Rm we have

ˆDRm(M(Z), Hm(Z)) = Wm(Z).

Deﬁne a map FeB : FNK

q → Fℓ

q by

FeB (X) = M(X).

(18)

(19)

For every sink tm ∈ T , deﬁne a map Dtm that takes data
received on the incoming edges of the sink tm as input by
Dtm (cid:0)FeB (X), (Xk)k:(sk ,tm)∈In(tm)(cid:1) =

ˆDRm (cid:0)FeB (X), (Xk)k:(sk ,tm)∈In(tm)(cid:1) .

(20)

By (20), (13), (18), and Remark 2(a)

Dtm (cid:0)FeB (X), (Xk)k:(sk ,tm)∈In(tm)(cid:1) =

ˆDRm(M(X), Hm(X)) = Wm(X) = Gtm(X).

Thus, (19) and (20) deﬁne a network code for FI.

Example 3: Consider the functional index coding problem
given by the ﬁrst three columns of Table VIII. Each message
takes value from a binary ﬁeld. Majority function is denoted by
M aj, M aj(a, b, c) = ab+bc+ac, a, b, c ∈ {0, 1}. An optimal
functional index code that satisﬁes all clients is (C1, C2, C3) =

X1

X2

X3

X4

X5

X6

s1

s2

s3

s4

s5

s6

vB

ℓ

v′

B

t1

t2

t3

t4

M aj(X1 + X6, X2 + X3, X4)

X3

X1 + X5 + X6

X2 + X5 X6

X1 + X5 + X6

Fig. 3. Network computation problem corresponding to Table VIII.

By Proposition 1, a code for the network computation prob-
lem exists if and only if ℓ > 3 since minimum 3 transmissions
are required for the given functional index coding problem.
A network code that satisﬁes all sink demands is obtained by
assigning FeB (X1, . . . , X6) = (X1 + X6, X3 + X4, X2 + X5)
as the global encoding kernel of edge eB = (vB , v′
B). Upon
receiving this coded message and the source messages on the
incoming links, each sink can compute the value of its desired
function.
(cid:3)

V. DISCUSSION

In this paper, we established a relationship between network
computation problems and the class of functional index coding
problems in which only the demands of the clients include
functions of messages. We gave a method to convert any
network computation problem into a functional index coding
problem with some clients demanding functions of messages
and proved that the network computation problem admits a
solution if and only if all the clients’ demands in the corre-
sponding functional index coding problem can be satisﬁed in
a speciﬁc number of transmissions (determined by the original
network computation problem). We gave a method to convert
a network code into a functional index code and vice versa.
This means that algorithms to solve functional index coding
problems can be used to obtain network codes for network
computation problems. Next, given a functional index coding

problem in which some clients demand functions of messages
but the side information of each client is a subset of the
message set known to the transmitter, we construct a network
computation problem and show that a functional index code
of a speciﬁed length for the former problem exists if and only
if a network code for the latter problem exists.

In this paper, we have considered only the functional index
coding problem in which only the demands of the clients
include functions and not the side information known to them
a priori. A direction of future work is to ﬁnd what kind of
networks and problems can be obtained from and converted
to the functional index coding problems in which the side
information can also include functions of messages known to
the transmitter.

ACKNOWLEDGMENT

This work was supported partly by the Science and Engi-
neering Research Board (SERB) of Department of Science and
Technology (DST), Government of India, through J.C. Bose
National Fellowship to B. Sundar Rajan.

REFERENCES

[1] R. Ahlswede, N. Cai, S.-Y. R. Li, and R. W. Yeung, “Network Infor-
mation Flow,” IEEE Trans. Inf. Theory, vol. 46, no. 4, pp. 1204-1216,
July 2000.

[2] R. W. Yeung, Information Theory and Network Coding. New York, NY,

USA: Springer, 2008.

[3] R. K¨oetter and M. M´edard, “An Algebraic Approach to Network
Coding,” IEEE/ACM Trans. Netw., vol. 11, no. 5, pp. 782-795, October
2003.

[4] T. Ho, M. M´edard, R. K¨oetter, D. R. Karger, M. Effros, J. Shi, and
B. Leong, “A Random Linear Network Coding Approach to Multicast,”
IEEE Trans. Inf. Theory, vol. 52, no. 10, pp. 4413-4430, October 2006.
[5] T. Ho and D. S. Lun, Network Coding An Introduction. New York, NY,

USA: Cambridge University press, 2008.

[6] C. Fragouli and E. Soljanin, “Network Coding Applications,” Found.

Trends Netw., vol. 2, no. 2, pp. 135-269, 2007.

[7] R. Dougherty, C. Freiling, and K. Zeger, “Insufﬁciency of Linear Coding
in Network Information Flow,” IEEE Trans. Inf. Theory, vol. 51, no. 8,
pp. 2745-2759, August 2005.

9

[8] R. Appuswamy, M. Franceschetti, N. Karamchandani, and K. Zeger,
“Network Coding for Computing: Cut-set Bounds,” IEEE Trans. Inf.
Theory, vol. 57, no. 2, pp. 1015-1030, February 2011.

[9] A. Giridhar and P. R. Kumar, “Computing and Communicating Func-
tions Over Sensor Networks,” IEEE J. Sel. Areas Commun., vol. 23, no.
4, pp. 755-764, April 2005.

[10] B. K. Rai and B. K. Dey, “On Network Coding for Sum-Networks,”

IEEE Trans. Inf. Theory, vol. 58, no. 1, pp. 50-63, January 2012.

[11] V. Shah, B. K. Dey, and D. Manjunath, “Network Flows for Function
Computation,” IEEE J. Sel. Areas Commun., vol. 31, no. 4, pp. 714-730,
April 2013.

[12] R. Appuswamy, M. Franceschetti, N. Karamchandani, and K. Zeger,
“Linear Codes, Target Function Classes, and Network Computing
Capacity,” IEEE Trans. Inf. Theory, vol. 59, no. 9, pp. 5741-5753,
September 2013.

[13] Y. Birk and T. Kol, “Informed-Source Coding-on-Demand (ISCOD) over
Broadcast Channels,” in Proc. IEEE INFOCOM, San Francisco, CA,
USA, 1998, vol. 3, pp. 1257-1264.

[14] Z. Bar-Yossef, Y. Birk, T. S. Jayram, and T. Kol, “Index Coding with
Side Information,” IEEE Trans. Inf. Theory, vol. 57, no. 3, pp. 1479-
1494, March 2011.

[15] N. Alon, A. Hassidim, E. Lubetzky, U. Stav, and A. Weinstein, “Broad-
casting with Side Information,” in Proc. IEEE Symp. Found. Comput.
Sci, Philadelphia, PA, USA, 2008, pp. 823-832.

[16] E. Lubetzky and E. Stav, “Nonlinear Index Coding Outperforming the
Linear Optimal,” IEEE Trans. Inf. Theory, vol. 55, no. 8, pp. 3544-3551,
August 2009.

[17] L. Ong and C. K. Ho, “Optimal Index Codes for a Class of Multicast
Networks With Receiver Side Information,” in Proc. IEEE Int. Conf.
Commun., Ottawa, ON, Canada, 2012, pp. 2213-2218.

[18] K. W. Shum, M. Dai, and C. W. Sung, “Broadcasting with Coded Side
Information,” in Proc. IEEE Int. Symp. Personal Indoor and Mobile
Radio Commun., Sydney, NSW, Australia, 2012, pp. 89-94.

[19] N. Lee, A. G. Dimakis, and R. W. Heath, “Index Coding With Coded
Side-Information,” IEEE Commun. Lett., vol. 19, no. 3, pp. 319-322,
March 2015.

[20] A. Gupta and B. S. Rajan, “Error-Correcting Functional Index Codes,
Generalized Exclusive Laws and Graph Coloring,” 16 October 2015.
[Online]. Available: http://arxiv.org/abs/1510.04820. (Part of this work
has been accepted for presentation at IEEE Int. Conf. Commun., Kuala
Lumpur, Malaysia, 2016.)

[21] S. El Rouayheb, A. Sprintson, and C. Georghiades, “On the Index
Coding Problem and its Relation to Network Coding and Matroid
Theory,” IEEE Trans. Inf. Theory, vol. 56, no. 7, pp. 3187-3195, July
2010.

[22] M. Effros, S. El Rouayheb, and M. Langberg, “An Equivalence Between
Network Coding and Index Coding,” IEEE Trans. Inf. Theory, vol. 61,
no. 5, pp. 2478-2487, May 2015.

