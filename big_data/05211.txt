6
1
0
2

 
r
a

 

M
6
1

 
 
]

.

A
N
h
t
a
m

[
 
 

1
v
1
1
2
5
0

.

3
0
6
1
:
v
i
X
r
a

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND

ADAPTIVE MESH REFINEMENT APPLIED TO SIMULATIONS OF

THE COMPRESSIBLE EULER EQUATIONS∗

RALF DEITERDING† , MARGARETE O. DOMINGUES ‡ , S ˆONIA M. GOMES§ , AND

KAI SCHNEIDER¶

Abstract. We present a detailed comparison between two adaptive numerical approaches to
solve partial diﬀerential equations (PDEs), adaptive multiresolution (MR) and adaptive mesh re-
ﬁnement (AMR). Both discretizations are based on ﬁnite volumes in space with second order shock-
capturing, and explicit time integration either with or without local time-stepping. The two methods
are benchmarked for the compressible Euler equations in Cartesian geometry. As test cases a 2D
Riemann problem, Lax-Liu #6, and a 3D ellipsoidally expanding shock wave have been chosen. We
compare and assess their computational eﬃciency in terms of CPU time and memory requirements.
We evaluate the accuracy by comparing the results of the adaptive computations with those obtained
with the corresponding FV scheme using a regular ﬁne mesh. We ﬁnd that both approaches yield
similar trends for CPU time compression for increasing number of reﬁnement levels. MR exhibits
more eﬃcient memory compression than AMR and shows slightly enhanced convergence; however, a
larger absolute overhead is measured for the tested codes.

Key words. adaptive numerical methods, conservation laws, Euler equations, multiresolution,

mesh reﬁnement, local time stepping

AMS subject classiﬁcations. 65M50, 65Y20, 76M12

1. Introduction. Adaptive discretization methods for solving nonlinear PDEs
have a long tradition in scientiﬁc computing, see e.g., [9]. They are motivated by the
computational complexity of real world problems which often involve a multitude of
active spatial and temporal scales. Adaptivity can be understood in the sense that the
computational eﬀort is concentrated at locations and time instants where it is neces-
sary to ensure a given numerical accuracy, while eﬀorts may be signiﬁcantly reduced
elsewhere. Typical applications are combustion problems with thin chemical reaction
zones, ﬂuid and plasma turbulence showing self-organization into coherent vortices,
and more generally, most kinds of interface and boundary layer type problems.

One of the essential ingredients of fully adaptive schemes is a reliable error es-
timator for the solution. It can be provided by Richardson extrapolation, auxiliary
solutions of adjoint problems [2], gradient based approaches or wavelet coeﬃcients
[49, 14, 12, 42, 26, 38, 47]. However, there is a price for adaptivity, since the com-
putational cost per unknown may increase signiﬁcantly. Hence, an adaptive method
can only be eﬃcient when the data compression is suﬃciently large to compensate the
additional computational cost, and this is problem dependent. To perform eﬃcient
adaptive simulations there is an eﬀort that has to be made to design algorithms and

∗AN EARLY VERSION OF THIS PAPER HAS APPEARED PREVIOUSLY IN ESAIM PRO-

CEEDINGS, 16:181–194, 2009 [21].

†Aerodynamics and Flight Mechanics Research Group, University of Southampton, Highﬁeld

Campus, Southampton SO17 1BJ, United Kingdom, r.deiterding@soton.ac.uk

‡Laborat´orio Associado de Computa¸c˜ao e Matem´atica Aplicada (LAC), Coordenadoria dos Lab-
orat´orios Associados (CTE), Instituto Nacional de Pesquisas Espaciais (INPE), Av. dos Astronautas
1758, 12227-010 S˜ao Jos´e dos Campos, S˜ao Paulo, Brazil, margarete.domingues@inpe.br

§Universidade Estadual de Campinas (Unicamp), IMECC, Rua S´ergio Buarque de Holanda, 651,

Cidade Universit´aria Zeferino Vaz, 13083-859, Campinas SP Brazil, soniag@ime.unicamp.br

¶M2P2-CNRS & Centre de Math´ematiques et d’Informatique (CMI), Universit´e d’Aix-Marseille,

39 rue F. Joliot-Curie, 13453 Marseille Cedex 13, France, kschneid@cmi.univ-mrs.fr

1

2

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

data structures, the latter are usually based on graded trees, hash-tables, linked lists
or multi-domains.

In the present paper, adaptive computations of 2D and 3D compressible Euler
equations are presented. The goal is to compare, for the same prescribed accuracy,
the eﬃciency in terms of CPU time and memory compression of two approaches:
the adaptive multiresolution (MR) method and the adaptive mesh reﬁnement (AMR)
method. We consider global time stepping and scale-dependent local time stepping.
Both methods are based on explicit ﬁnite volume (FV) discretizations on adaptive
meshes, with schemes in space and time of second order accuracy. Our interest in
comparing MR and AMR methods in the current paper can be seen as a step towards
detailed benchmarking, which has been started with a preliminary 2D case study in
[21]. Beside considering 3D results, we use an improved version of the MR Carmen
code where the memory allocation has been changed and the computational eﬃciency
of the underlying FV scheme has been increased. A detailed analysis of CPU time
and memory compression including error assessment allows for a sound evaluation of
the MR and AMR methods.

The block-structured AMR technique for hyperbolic PDEs has been pioneered by
Berger and Oliger [6]. While the ﬁrst approach utilized rotated reﬁnement meshes,
AMR denotes today especially the variant of Berger and Collela [4] that allows only
reﬁnement patches aligned to the coarse mesh. The eﬃciency of this algorithm, in
particular for instationary supersonic gas dynamical problems, has been demonstrated
in Bell et al. [3]. Several implementations of the AMR method for single processor
computers [5, 28] and parallel systems [3, 37, 45, 16] have been presented; variants
utilizing simpliﬁed data structures have also been proposed [41]. For an overview of
the AMR method and its implementation we refer to [20].

Multiresolution techniques have been developed after AMR, and became popular
for hyperbolic conservation laws going back to the seminal work of Harten [30] in the
context of FV schemes and cell-average MR analysis. Starting point is an FV scheme
for hyperbolic conservation laws on a regular mesh. Subsequently, a discrete mul-
tiresolution analysis is used to avoid expensive ﬂux computations in smooth regions,
ﬁrst without reducing memory requirements, e.g., for 1D hyperbolic conservation laws
[30, 7], 2D hyperbolic conservation laws [8], 2D compressible Euler equations [11], 2D
hyperbolic conservation laws with curvilinear patches [15] and unstructured meshes
[1, 13]. A fully adaptive version, still in the context of 1D and 2D hyperbolic conserva-
tion laws, has been developed to reduce also memory requirements [29, 35, 14]. This
algorithm has been extended to 3D and to parabolic PDEs [49, 48], and more recently
to self-adaptive global and local time-stepping by M¨uller and Stiriba and ourselves in
[43, 24, 25, 27]. Therewith the solution is represented and computed on a dynami-
cally evolving automatically adapted mesh. Diﬀerent strategies have been proposed
to evaluate the ﬂux without requiring full knowledge of ﬁne mesh cell-average values.
The MR approach has also been used in other discretization contexts. For instance,
the Sparse Point Representation (SPR) method is the ﬁrst fully adaptive MR scheme,
introduced in [32, 33] in the context of ﬁnite diﬀerences and point-value MR analysis,
leading to both CPU time and memory reduction. This approach has been explored
in applications of the SPR method in [23], and more recently in [46] for parallel im-
plementation of the MR method for FV discretizations. For comprehensive literature
about the subject, we refer to the books [12, 42] and our review papers [50, 26].

The outline of the paper is the following: ﬁrst, we sketch the set of compressible
Euler equations together with their ﬁnite volume discretization in space and an explicit

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

3

scheme in time. Then, we brieﬂy summarize the MR and AMR strategies. In the main
part, we show and discuss the numerical results for two test problems, one in 2D and
one in 3D. Final remarks and conclusions based on the performed computations are
drawn in Section 5.

2. Numerical methods. For the study of the present paper we consider FV
discretizations of the 3D compressible Euler equations given in the conservation form

(2.1)

∂tq + ∇ · f (q) = 0,

with q = (ρ, ρv, ρe)T , where ρ = ρ(x, t) is the density, v = v(x, t) is the velocity
vector with components (v1, v2, v3), and e = e(x, t) is the energy per unit of mass.
All variables are functions of time t and position x = (x1, x2, x3). The ﬂux function
f = (f1, f2, f3)T is given by

(2.2)

f1 =

ρv1
ρv2
1 + p
ρv1v2
ρv1v3

(ρe + p)v1









, f2 =

ρv2
ρv1v2
ρv2
2 + p
ρv2v3

(ρe + p)v2









, f3 =

ρv3
ρv1v3
ρv2v3
ρv2
3 + p
(ρe + p)v3





,





where the pressure p = p(x, t) satisﬁes the ideal gas constitutive relation

(2.3)

p = ρRT = (γ − 1) ρ(cid:18)e −

|v|2

2 (cid:19) ,

where T = T (x, t) is the temperature, γ = 1.4 the speciﬁc heat ratio and R a speciﬁc
gas constant. In the 2D formulation, the 3rd components of the vectors vanish and
the variables only depend on x1 and x2.

As reference discretization for equations in the conservation form (2.1), we con-
sider the numerical solution represented by the vector Q(t) of the approximated cell
averages

(2.4)

Qi,j,k(t) =

1

|Ωi,j,k| ZΩi,j,k

q(x, t) dx

on cells Ωi,j,k of a uniform mesh of the computation domain Ω. For space discretiza-
tion, a FV method is chosen, which results in a system of ordinary diﬀerential equa-
tions of the form

(2.5)

dQ
dt

= −F(Q),

where F(Q) denotes the vector of numerical ﬂux function diﬀerences with respect
to each cell. In all numerical schemes throughout this paper enhanced AUSM-type
numerical ﬂux functions with comparable second order accurate reconstruction and
ﬂux limiting are used. For all MR simulations, including the corresponding reference
FV solution, a second order MUSCL scheme with an AUSM+ ﬂux vector splitting
scheme [40] and van Albada limiter is applied. In all AMR computations, also in-
cluding the corresponding reference FV solution, a standard unsplit shock-capturing
MUSCL scheme with Minmod limiter and AUSMDV ﬂux-vector splitting is adopted
[53].

For time integration, approximate solutions Qn at a sequence of time instants
tn are obtained using explicit ordinary diﬀerential equation solvers. Here, an explicit

4

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

second order Runge-Kutta (RK2) scheme is used for MR, and the MUSCL-Hancock
approach [17, 52] is used for AMR. While both approaches correspond to using a
second order accurate explicit midpoint rule for temporal integration, the key diﬀer-
ence of the MUSCL-Hancock method is that it utilizes the exact ﬂux function in the
intermediate time step instead of the AUSM-type numerical ﬂux. This makes this
method slightly less accurate but computationally cheaper.

In summary, six numerical discretizations are considered. For both MR and AMR,
FV reference solutions are computed using the corresponding numerical scheme. In
addition, we perform in both cases either global or local time stepping. In the following
subsections we brieﬂy describe ﬁrst the MR and then the AMR method.

2.1. Adaptive multiresolution method. The adaptive MR scheme belongs
to a class of adaptive hybrid methods which are formed by two basic parts: the oper-
ational part and the representation part. The operational part consists of an accurate
and stable discretization of the partial diﬀerential operators. In the representation
part, wavelet tools are employed for the MR analysis of the discrete information.

The principle in MR methods is the transformation of the cell averages given
by the FV discretization into a multiscale representation. A hierarchy of nested
meshes endowed with projection and prediction operators to perform the inter-level
transformations are the main building blocks [30, 31]. The numerical solution at the
highest resolution level is transformed into a set of coarser scale approximations plus
a series of prediction errors corresponding to wavelet coeﬃcients. These coeﬃcients
describe the diﬀerence between subsequent resolutions. The main idea is then to use
the decay of the wavelet coeﬃcients to estimate the local regularity of the solution
[12, 42]. In regions where the solution is smooth these coeﬃcients are small, while they
have large magnitude in regions of steep gradients or discontinuities. An adaptive
MR representation of the numerical solution can then be obtained by a compact
multiscale representation which is constructed by removing the wavelet coeﬃcients
whose magnitude is smaller than a chosen threshold [49, 14].

A natural way to store the compact MR representation is to use a tree data struc-
ture. Locally reﬁned adaptive meshes create incomplete trees, cf. Fig. 1. The adaptive
computations are performed on the leaves of the tree, deﬁned as nodes without chil-
dren, where the cell averages are stored. In this procedure, gradedness of the tree is
imposed, i.e., only one level of diﬀerence is permitted between subsequent neighbors.
For the complete time evolution cycle, three basic operations are considered:

Reﬁnement: The solution may change in time, the adaptive MR mesh at tn
may not be suﬃcient at the next time step. Thus, a preventive action is necessary to
account for possible translation or creation of ﬁner structures in the solution between
subsequent time steps. Before performing the time evolution, the solution is interpo-
lated onto an extended mesh. For this the adaptive mesh at tn is reﬁned by one level
while maintaining the gradedness.

Time evolution: First, to ensure conservation of the ﬂux computations between
diﬀerent levels it is necessary to add virtual leaves, as illustrated in Figure 1, right.
The time evolution operation is applied only on the leaves of the extended mesh,
but not on the virtual ones [49]. There is a possibility to save further CPU time by
evolving the solution with level dependent time steps, instead of a global time step.
This MRLT scheme with a given time step ∆tn at the ﬁnest level L, evolves the cells
at coarser levels 0 ≤ ℓ < L with larger time steps ∆tn
ℓ = 2L−ℓ∆tn. Required missing
values are interpolated in time at intermediate time steps.

Coarsening: The regions of smoothness of the solution can change after the

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

5

Fig. 1. Leaves of an adaptive 3D MR mesh, left. Sketch of the corresponding octree structure,

middle. Leaves (plain) and virtual leaves (dashed) of an adaptive 2D MR mesh, right.

time evolution. Hence, the adaptive MR mesh must be checked if a coarser mesh is
suﬃcient for an accurate representation of the computed solution. A multiresolution
analysis is performed and the thresholding of the wavelet coeﬃcients determines the
cells where the mesh can be coarsened.

The cell-average MR analysis used in the present paper corresponds to a third
order prediction operator based on quadratic polynomial interpolation of the cell aver-
ages. The adaptive MR scheme and its MRLT version, cf. [24, 26], are implemented
in the code Carmen1 originally developed by Roussel [49]. Here an optimized ver-
sion of the Carmen code is used where the runtime has been improved for both the
MR and the FV method. The implementation is in C++ throughout and consists of
approximately 20, 000 lines of code (LOC) in total.

Gl,m deﬁne the domain Gl := SMl

2.2. Adaptive mesh reﬁnement method. The AMR method [6, 4, 3] follows
a patch-oriented reﬁnement approach, where non-overlapping rectangular submeshes
m=1 Gl,m of an entire level l = 0, . . . , L. As the
construction of reﬁnement proceeds recursively, a hierarchy of submeshes successively
contained within the next coarser level domain is created, as illustrated in Figure 2.
Note that the recursive nature of the algorithm allows only the addition of one new
level in each reﬁnement operation. The patch-based approach does not require spe-
cial coarsening operations; submeshes are simply removed from the hierarchy. The
coarsest possible resolution is thereby restricted to the level 0 mesh. Usually, it is
assumed that all mesh widths on level l are rl-times ﬁner than on the level l − 1, i.e.,
∆tl = ∆tl−1/rl and ∆xn,l = ∆xn,l−1/rl, with rl ∈ N, rl ≥ 2 for l > 0 and r0 = 1,
which ensures that a time-explicit FV scheme remains stable under a CFL-type con-
dition on all levels of the hierarchy.

The numerical update is applied on the level l by calling a single-mesh routine
implementing the FV scheme in a loop over all the submeshes Gl,m. The regularity
of the input data allows a straightforward implementation of the scheme and further
permits optimization to take advantage of high-level caches, pipelining, etc. New
reﬁnement meshes are initialized by interpolating the vector of conservative quantities
Q from the next coarser level. However, data in cells already reﬁned is copied directly
from the previous reﬁnement patches. Ghost (also know as halo) cells around each
patch are used to decouple the submeshes computationally. Ghost cells outside of
the root domain G0 are used to implement physical boundary conditions. Ghost

1The Carmen code is open access and available at

https://github.com/waveletApplications/carmen.git.

6

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

AdvanceLevel(l)

Repeat rl times

Set ghost cells of Ql(t)
If time to remesh

Remesh(l)

UpdateLevel(l)
If level l + 1 exists

Set ghost cells of Ql(t + ∆tl)
AdvanceLevel(l + 1)
Average Ql+1(t + ∆tl) onto

Ql(t + ∆tl)

Flux correction of Ql(t + ∆tl)

t := t + ∆tl

Fig. 2. Recursive AMR algorithm in 2D, and typical hierarchy of rectangular submeshes.

cells in Gl have a unique interior cell analogue and are set by copying the data value
from the patch where the interior cell is contained (synchronization). For l > 0,
internal boundaries can also be used. If recursive time step reﬁnement is employed,
ghost cells at the internal reﬁnement boundaries on the level l are set by time-space
interpolation from the two previously calculated time steps of level l − 1. Otherwise,
spatial interpolation from the level l − 1 is suﬃcient.

The characteristic of the AMR algorithm is that reﬁnement patches overlay
coarser mesh data structures, instead of being embedded, again avoiding data frag-
mentation. Values of cells covered by ﬁner submeshes are subsequently overwritten
by averaged ﬁne mesh values, which, in general, would lead to a loss of conservation
on the coarser mesh. A remedy to this problem is to replace the coarse mesh nu-
merical ﬂuxes at reﬁnement boundaries with the sum of ﬁne mesh ﬂuxes along the
corresponding coarse cell boundary. Details about this ﬂux correction can be found
in [4, 17, 18]. The basic recursive AMR algorithm is formulated in Fig. 2 (left). New
reﬁnement meshes on all the higher levels are created by calling Remesh() at a given
level l. The level l by itself is not modiﬁed. To consider the nesting of the level
domains already in the mesh generation, Remesh() starts at the highest level to be
reﬁned and proceeds down to l + 1. After evaluating the reﬁnement indicators and
ﬂagging cells for reﬁnement, a special clustering algorithm [3] is used to create new
reﬁnement patches until the ratio between ﬂagged and all cells in every new submesh
is above a prescribed threshold 0 < ηtol ≤ 1.

In the present paper, all the AMR computations have been carried out using the
AMROC (Adaptive Mesh Reﬁnement in Object-oriented C++) framework [16, 22]2.
At the present time, the AMR core of AMROC consists of approximately 46, 000
LOC in C++ and approximately 6, 000 LOC for visualization and data conversion.
Similarly to the AMR inter-level transfer operations (interpolation, averaging), the
employed FV update routine is coded in Fortran-77 and all the codes are compiled
with standard compiler optimizations (-O3 with loop unrolling, inlining, etc.) using
the GNU compiler suite on the benchmark system with Intel-i7-2.2 GHz quad-core
processor. Although AMROC permits large-scale MPI-parallel AMR computations
[19, 44], the present investigation uses only the serial algorithm of the software.

The original recursively adaptive AMR method with time step reﬁnement is de-
noted here as AMRLT. In order to provide a comparison to the MR method, we also
employ the same implementation without local time stepping under the name AMR.

2The latest open access release of AMROC is available at http://www.vtf.website.

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

7

Note that the performance of this variant could be improved by skipping some of the
adaptation steps provided that reﬁnement coverage is correspondingly enlarged. Yet,
such optimizations have not been investigated here. As reﬁnement indicators, scaled
gradient criteria of the form

(2.6)

|w(Qi+αi ,j+αj ,k+αk ) − w(Qi,j,k)| > ǫw,

with αi, αj, αk ∈ {0, 1}, are applied to density and pressure (w = ρ and w = p).
As it is common practice [4], a layer of one additional cell width is also tagged for
the reﬁnement around each reﬁnement ﬂag to ensure that the ﬂagged feature does
not leave the reﬁnement region during the next time step. Furthermore, AMROC
allows for the additional application of a heuristic local error indicator based on a
Richardson estimation [4, 6]. For the test problems of Section 4, however, scaled
gradient and Richardson error estimation criteria were found to give virtually identical
mesh reﬁnement and the benchmarked computations only utilized the former.

3. Error assessment. The goal of the adaptive MR and AMR computations
is to obtain the solution with a signiﬁcant gain in CPU time and memory while
preserving the accuracy of the corresponding FV scheme on the regular ﬁnest mesh.
To quantify the accuracy of the adaptive simulations the discrete L1-error is computed.
For that a reference FV solution on a ﬁner mesh restricted onto the current uniform
mesh level L is used.

For the MR methods, with or without local time stepping (a = MR or MRLT),
the adaptive solution is recursively projected up to the desired ﬁnest uniform mesh of
level L with a step size ∆xL. The goal is to obtain ˜Qa
(i,j) using third order cell-average
interpolation. The discrete error is then evaluated on the domain Ω as

(3.1)

L1(Q) = Xi,j,k

| ˜Qa

i,j,k − Qr

i,j,k|∆x2
L,

where Qr
i,j,k denotes the projection of the reference solution down to the desired level
L. For the two AMR cases, considering again either global or local time stepping,
the error is evaluated as the sum of the L1-error computed on the domain Ωl without
higher reﬁnement, i.e.,

(3.2)

where
(3.3)

L1(Q) = L1(∆xL, ΩL) +

L−1

Xl=0

L1(∆xl, Ωl \ Ωl+1),

L1(∆x, Ω) = Xi,j,k

|Qa

i,j,k − Qr

i,j,k|∆x2,

denotes the L1-norm on the domain Ω. The projection of the reference solution from
the ﬁner uniform mesh down to the desired mesh with step size ∆x is denoted by
Qr

i,j,k. The index a stands for either AMR or AMRLT.

To evaluate the performance of the adaptive codes, i.e., CPU, memory and mesh
compression rates, including accuracy perturbation, and overhead, diﬀerent measures
are introduced. The CPU time compression rate is deﬁned as the ratio between the
CPU time required to compute the solution at the ﬁnal instant using the adaptive
method a and the one required to compute the same solution using the ﬁne-mesh FV
method

(3.4)

CPU time compression rate =

CP U a
CP U F V ,

8

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

The ratio of the average memory requirement and the number of cells NC of the ﬁnest
uniform mesh deﬁnes the memory compression rate in the adaptive computations,

(3.5)

memory compression rate =

1
N a

I

I PN a

n=1 Ca,n
NC

,

where N a
I is the number of performed time steps, and Ca,n denotes the sum of cells
of the entire hierarchy at t = tn. Similarly, mesh compression can be deﬁned as the
ratio of the average leaf requirement (i.e., the average number of required degrees
of freedom to represent the numerical solution) and the number of cells of the ﬁnest
uniform mesh

(3.6)

mesh compression rate =

1
N a

I

I PN a

n=1 La,n
NC

.

In the adaptive codes, typically a perturbation error is introduced. This results in
larger errors of the adaptive solution compared to the FV solution on the ﬁnest uni-
form mesh. Suitable thresholding guarantees that this perturbation does indeed not
deteriorate the convergence order of the underlying FV scheme. The accuracy pertur-
bation is measured by the relative diﬀerence between the error given by the reference
FV scheme and the error introduced by the adaptive method,

(3.7)

accuracy perturbation =

|LF V

1

1(Q)|

(Q) − La
LF V
(Q)

1

.

Evolving the solution in each cell of the computational domain using adaptive compu-
tations is expected to be more expensive in terms of CPU time than using the reference
scheme on the uniform mesh. Hence, an essential question is to know whether the
reduction in the number of degrees of freedom required to represent the adaptive nu-
merical solution compensates the additional computational overhead induced by the
adaptive algorithm. The overhead of the adaptive computations can be evaluated by

(3.8)

Γa =

CP U a
n=1 La,n

,

I

PN a

which denotes the average CPU time per leaf spent to evolve the solution in the
computational domain. Therefore, the ratio Γa/ΓF V , where ΓF V denotes the CPU
time per leaf on the regular mesh, should be greater than one. Consequently, the
overhead per iteration and per leaf of the adaptive computation is deﬁned by

(3.9)

overhead =

Γa
ΓF V − 1.

4. Numerical results. In the following, the results of the diﬀerent MR and
AMR simulations are presented and compared with corresponding FV reference com-
putations considering two Riemann problems, one in two and one in three space
dimensions.

4.1. 2D Riemann problem: Lax-Liu conﬁguration #6. First we consider
a classical Riemann problem for gas dynamics proposed in [39] known as Lax-Liu
benchmark #6. This conﬁguration is initially discussed in [55, 51]. As this is a 2D
problem, v3 ≡ 0 holds true, the remaining vector components only depend on x1
and x2, and Eq. (2.1) reduces to ∂tq + ∂x1f1(q) + ∂x2f2(q) = 0. The computational

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

9

Initial Values for the Lax-Liu conﬁguration #6.

Table 1

Variables

Domain position

Density(ρ)
Pressure (p)
Velocity component (v1)
Velocity component (v2)

I

1.00
1.00
0.75
-0.50

II

2.00
1.00
0.75
0.50

III
1.00
1.00
-0.75
0.50

IV
3.00
1.00
-0.75
-0.50

x2

II

I

III

IV

x1

domain is the square Ω = [0, 1]2 with outﬂow boundary conditions. The domain is
divided into four quadrants, where the initial data are set constant in each quadrant,
according to the values given in Table 1. The simulations are performed until the ﬁnal
time te = 0.25. This benchmark only involves contact discontinuities and generates
swirling motion in the clockwise direction. Figure 3, left shows the reference solution
computed with the FV scheme of the AMR method on a regular mesh with 40962
grid points which is used to evaluate the errors of the AMR and MR computations.3
Figures 3, right and 4, right illustrate, respectively, the adaptive solutions obtained
with MR and AMR at the ﬁnal time te, using L = 10 levels. The corresponding
adaptive meshes are also shown in Figure 4. We observe that in the MR case the
mesh is sparser and better adapted to the solution compared to the AMR case.

The underlying FV schemes of MR and AMR are benchmarked on uniform ﬁne
meshes with NC = N 2 FV cells, where N = {128, 256, 512, 1024}, (correspond-
ing to the scale levels L = {7, 8, 9, 10}). To reach the ﬁnal instant te, NI time
steps are performed, where NI = {160, 320, 640, 1280}, respectively. Note that in
all adaptive simulations NI time steps are performed as well. In both cases we ob-
serve convergence of the FV schemes towards the reference solution with a rate of
about one, as shown in Table 2. The FV scheme of MR yields slightly smaller er-
rors with slightly higher convergence rates.
In the MR and MRLT computations
we studied the inﬂuence of the wavelet threshold, and considered diﬀerent values
ǫ = 0.0005, 0.0008, 0.0028, 0.0025, 0.0023, 0.0010, which were ﬁxed for all levels. For
the MR and MRLT schemes, decreasing the threshold parameter ǫ has the eﬀect of
improving the accuracy to some extent, but mesh compression deteriorates for very
small ǫ. In Table 2 only results for ǫ = 0.0023 are presented. Similarly to the FV
case, we observe decaying errors for increasing L with the same rates of about one.
This shows that the wavelet thresholding well preserves the order of the underlying
FV scheme.

The AMR and AMRLT computations use a base mesh of 64 cells and a reﬁnement
factor of 2 at all levels. The full block-structured AMR algorithm is used here, includ-
ing conservative correction at reﬁnement boundaries and hierarchical time stepping.
Reﬁnement is based on the scaled gradient of the density with threshold ǫρ = 0.05.
Again, we observe, similar to the FV case, decaying errors for increasing L with rates
slightly below one. The diﬀerence in the absolute errors between the MR/MRLT
and AMR/AMRLT simulations is due to the use of slightly diﬀerent FV schemes. In
particularly, the FV errors of the AMR/AMRLT code are slightly larger, which is
consistent with the employed second order method, as discussed in Section 2. How-

3Computation of the reference solution on the uniform 40962 grid used 8 nodes with Intel-Xeon-
3.4GHz dual-core processors of a typical GNU/Linux cluster and required ∼ 3.5 h wall time to
complete 5120 time steps. Note that all benchmarked computations were run in serial.

10

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

Fig. 3. Left: reference solution – isolines of density (0 ≤ ρ ≤ 3.2, with step 0.008) at the ﬁnal
time te for the 2D Riemann problem Lax-Liu conﬁguration #6. The computation is performed on
a 40962 mesh using the FV volume scheme with AUSMDV ﬂux. Right: MR solution, using L = 10
and ǫ = 0.0023.

Fig. 4. Adaptive solutions and meshes for the 2D Riemann problem Lax-Liu conﬁguration #6
at the ﬁnal time te, using L = 10: Left: MR mesh with ǫ = 0.0023. Right: AMR solution and mesh.

ever, the small perturbation rates of Table 2 as well as the similar memory and mesh
compression rates (diﬀering only 2 − 4%) of Table 3 indicate that both methods per-
form a comparable adaptation.
It can be noted that the MR/MRLT compression
rates decrease faster providing evidence for a more sophisticated adaptation criterion.
Table 4 presents the absolute computing time of both codes and the corresponding
CPU time compression rates. Comparing the absolute CPU times already for the FV
unigrid cases, it is important to point out that the two benchmarked implementations
have vastly diﬀerent absolute computational performance. When running in FV mode,
the MR/MRLT code is about a factor of 9.5 slower than the AMR/AMRLT code
and an accordingly larger absolute computing time is consequently also measured in
the adaptive simulations. In order to allow nevertheless a comparison, and to assess
both mathematical approaches independent of mere implementation aspects as well as
minor diﬀerences in the numerical discretizations applied, we employ the CPU time
compression rate. For the highest resolved MR/MRLT simulations the CPU time
compression is slightly better than for AMRLT, which is consistent with the better
mesh compression rates seen in Table 3, and thus signiﬁcantly better than for AMR.
Contrary to the AMRLT computations, the present MRLT scheme does not improve
the results signiﬁcantly with respect to MR. This issue of local time stepping in MR is
also discussed in [24]. MRLT is most beneﬁcial for unbalanced trees, i.e., localization

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

11

Accuracy of 2D computations with thresholds ǫ = 0.0023 and ǫρ = 0.05 in the MR and AMR

Table 2

cases, respectively.

L

7
8
9
10

L

7
8
9
10

FV

MR

L1(ρ)

Rate

L1(ρ)

Rate

0.0390781
0.0236107
0.0128030
0.0056620

0.727
0.883
1.177

0.0374855
0.0225061
0.0122309
0.0056208

0.736
0.880
1.122

FV

AMR

L1(ρ)

Rate

L1(ρ)

Rate

0.0458873
0.0293788
0.0174213
0.0091630

0.643
0.754
0.927

0.0436478
0.0279279
0.0165780
0.0089999

0.644
0.752
0.881

Pert.
[%]
4.03
4.68
4.47
0.73

Pert.
[%]
4.88
4.93
4.84
1.78

MRLT

L1(ρ)

Rate

0.0376881
0.0226217
0.0123496
0.0059899

0.736
0.873
1.044

AMRLT

L1(ρ)

Rate

0.0456108
0.0291994
0.0173483
0.0093855

0.643
0.751
0.886

Pert.
[%]
3.51
4.19
3.54
5.79

Pert.
[%]
0.60
0.61
0.42
2.43

Accumulated cell (C) and leaf (L) counts in 106 elements of adaptive 2D computations and

resulting memory and grid compression rates.

Table 3

L

7
8
9
10

L

7
8
9
10

Cn

Pn
2.16
11.2
50.3
210

Cn

Pn
1.84
9.79
50.1
239

MR

MRLT

Ln

[%] Pn
82.5
53.5
30.0
15.7

1.46
7.35
32.4
135

AMR

Ln

[%] Pn
70.3
46.7
29.9
17.8

1.39
7.35
37.6
180

Cn

[%] Pn
55.8
35.1
19.3
10.1

2.12
11.0
49.9
207

Cn

[%] Pn
52.9
35.0
22.4
13.4

1.88
10.3
51.4
242

Ln

[%] Pn
80.7
52.3
29.8
15.4

1.43
7.19
32.2
133

Ln

AMRLT
[%] Pn
71.8
48.9
30.6
18.0

1.28
6.80
33.3
154

[%]
54.5
34.3
19.2
9.91

[%]
49.0
32.4
19.9
11.4

of small scale features of the solution, expensive ﬂux evaluation, and larger number
of well-localized active scales. Therefore, for few active cells on ﬁne scales (e.g., point
singularities) the speed-up becomes larger compared to the MR scheme with global
time stepping. Similar results are also found by M¨uller and Stiriba [43] for their
MRLT computations for space dimensions larger than one.

As predicted by an analytic cost estimate in [24], we found that the actual speed-
up of local time stepping depends on the distribution of the active cells. If the majority
of the cells is active on ﬁne scales, the MRLT scheme is less eﬃcient with respect to the
MR scheme, whereas for few active cells on ﬁne scales the speed-up becomes larger.
In these cases, performing one large time step at a coarse level instead of several time
steps on ﬁne scale cells becomes indeed more eﬃcient.

When analyzing overhead rates according to Eq. (3.9), one notices that the rel-
ative mesh adaptation overhead rises in all approaches when increasing the number
of levels L. The respective variants without local time stepping exhibit a steeper in-
crease than the LT methods as coarser grid cells are updated signiﬁcantly more often.

12

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

Computing times and CPU time compression rates for 2D computations.

Table 4

L

7
8
9
10

FV
[s]

27.22
212.4
1683
13727

MR

MRLT

[s]

24.42
124.4
555.0
2380

[%]
89.7
58.6
33.0
17.3

[s]

23.61
118.7
538.0
2278

[%]
86.7
55.9
32.0
16.6

FV
[s]

2.901
23.36
181.6
1420

AMR

[s]

3.864
19.76
99.10
489.3

[%]
133
85.0
54.6
34.5

AMRLT
[s]

[%]
86.2
54.1
33.5
20.2

2.489
12.64
60.90
287.4

Breakdown of CPU time in % spent in main task groups for 2D computations at L = 10.

Table 5

Task group

Numerics
Temp. data
Boundary cond.
MR tree org.
Level transfer
Memory (c-lib)
Unassigned

FV
36.18
33.06
5.52
–
–
21.79
3.45

MR
NLT
26.30
16.67
2.60
40.63
1.93
6.45
5.42

Task group

Numerics
AMR data org.
Clustering
Flagging
Lever transfer

LT
25.30
16.62
2.55
40.28
2.03
6.23 Memory (c-lib)
6.45

Unassigned

AMR
NLT
64.44
6.72
10.84
2.32
4.92
4.47
6.29

LT
71.55
4.16
6.86
1.32
4.08
5.11
6.92

FV
93.73
–
–
–
–
4.87
1.40

For the highest reﬁned computations with L = 10, the overhead is 158% for AMR
and 77.0% for AMRLT. When the overhead is calculated based on the performance
of the MR code run in FV unigrid mode, the corresponding overhead rates for MR
and MRLT are only 72.3% and 67.5%, respectively. Measured in relative terms, the
MR/MRLT algorithms are more eﬃcient than AMR/AMRLT, which is due to the
unnecessary update of respective coarser cells independent of higher level coverage.
However, if the performance numbers from the AMR code run in FV unigrid mode
would be used for the sake of direct comparison, the overhead rates for MR and MRLT
would jump to 1560% and 1513%, respectively. This underscores that exactly identi-
cal numerical discretizations and implementations in the same programming language
of comparable quality and level of optimization are a prerequisite for meaningful head
to head benchmarking of adaptive solution methods. Yet, due to the complexity of
the involved codes, these requirements can generally never be met in practice, which
explains the lack of published quantitative comparisons in this ﬁeld and provides evi-
dence for the beneﬁt of our approach using primarily relative performance measures.
In order to better understand nevertheless the absolute performance of the used
computer codes, a breakdown of the CPU time of the highest resolved adaptive com-
putations at L = 10 is provided in Table 5. This benchmark analysis has been
obtained by using the perf tool. The tabulated items in the ﬁrst group list major
tasks already present in the respective FV implementations. The second group lists
algorithmic tasks that have to be carried out in addition in the adaptive programs as
they could be distinguished and unambiguously classiﬁed from within the performance
analysis tool. The last group lists the expense of system calls for dynamic memory
management and the accumulation of operations which have too insigniﬁcant cost for
detailed classiﬁcation.
It can be seen from Table 5 that temporary data creation,
handling and deletion are a considerable portion of the FV-MR code. This code is a

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

13

cell-oriented implementation of a Cartesian unstructured grid, while the FV method
in the AMR code is implemented for a generic structured block and allocates all nec-
essary temporary data in advance. In the adaptive case, creation and organization
of the hierarchical data becomes a visible portion of the computing time for both ap-
proaches. It can be seen that particularly orchestration of the unstructured quad-tree
in the MR/MRLT approach, cf. Fig. 1, is rather expensive. In principle, organizing
the more general mesh reﬁnement tree in the AMR/AMRLT case is even more in-
volved; however, thanks to clustering individual cells into blocks of considerable size
the number of leaves of this general tree, cf. Fig. 2, is magnitudes smaller and the
overhead accordingly reduced. A non-negligible portion of the AMR approach is the
clustering operation, which generates rectangular blocks from ensembles of individual
cells.
It is obvious that in the variant without local time step reﬁnement (AMR)
the adaptation overhead is increased, since in the runs reported here complete mesh
adaptation is allowed in every time step.

4.2. 3D ellipsoidally expanding shock wave. For the next test problem, we
consider the expansion of an ellipsoidal shock wave in three space dimensions. The
3D Euler equations are solved in the computational domain Ω = [−2, 2]3 until the
ﬁnal simulation time te = 0.28. Outﬂow boundary conditions are applied at all sides
of the domain. The initial ellipsoid is speciﬁed by

(4.1)

r = r(cid:16) x1r
a (cid:17)2

b (cid:17)2
+(cid:16) x2r

c (cid:17)2
+(cid:16) x3r

,

where x1r = x1 cos(θ) − x2 sin(θ), x2r = (x1 sin(θ) + x2 cos(θ)) cos(φ) − x3 sin(φ),
x3r = (x1 sin(θ) + x2 cos(θ)) sin(φ) + x3 cos(φ), with stretching and rotational param-
eters rc = 3
4 . Initial conditions in density ρ
and energy density ρe are set as

3 , b = 1, c = 3, θ = π

5 , a = 1

3 , and φ = π

(4.2)

ρ = (cid:26) 0.125 ,

1 ,

r < rc ,
r ≥ rc ,

ρe = (cid:26) 0.25 ,

2.5 ,

r < rc ,
r ≥ rc ,

while the velocity vector is initially zero, i.e., v1 = v2 = v3 = 0 everywhere. For
convergence analysis, we consider a reference solution computed with AUSMDV nu-
merical ﬂux and second order MUSCL-Hancock reconstruction with Minmod-limiter
in the primitive variables ρ, vn, p. The resolution is 10243 cells on a uniform mesh,
where automatic time step adjustment based on CFL ≈ 0.4 is used.4

The AMR and AMRLT computations use a base mesh of 83 cells and a reﬁne-
ment factor 2 at all levels. As in the 2D example, the entire block-structured AMR
algorithm is applied, including a conservative correction at the reﬁnement boundaries
and hierarchical time stepping. The reﬁnement is based on scaled gradients of density
and pressure with the thresholds ǫρ = ǫp = 0.05. The used mesh generation eﬃciency
is ηtol = 80 %, meaning that each patch can contain up to 20 % of cells not ﬂagged for
reﬁnement. For the MR and MRLT computations, the threshold parameter ǫ = 0.013
is applied at all resolution levels.

The Figs. 5 and 6 assemble 2D cuts normal to the coordinate directions at the
ﬁnal time te. The left image of Fig. 6 shows the plane in the origin in the view
direction (1, 0, 0), the middle one displays the plane in the origin in the view direction

4While all benchmarked 3D simulations where run in serial, only the computation of this reference
solution on the uniform 10243 grid was performed on 512 processors on an IBM-BG/P used in SMP
mode, which required ∼ 9.2 h wall time to complete 460 time steps.

14

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

Fig. 5. 3D ellipsoidally expanding shock-wave at time te. Upper row: Isolines of 2D cuts of
density for the FV reference solution computed on 10243 mesh, down-sampled to 2563, corresponding
to L = 8. Lower row: Isolines of 2D cuts of density for the MR computation with L = 8.

(0, −1, 0), and the right image shows the plane through the origin in the view direction
(0, 0, −1). In Fig. 5, we compare the FV reference computation obtained with L = 10
and down-sampled to L = 8 with the MR computations for L = 8. Shown are only
isolines of density (ρ between 0.05 and 0.95 at intervals 0.05). Figure 6 displays the
2D cuts and the corresponding adaptive meshes. Inspecting these graphics, we ﬁnd
that both the MR and the AMRLT adaptive computation agree well with the down-
sampled FV reference solution. As expected, both adaptive grids concentrate cells in
regions of steep gradients present in the solution. We also observe that the MR mesh
is better adapted to the solution than the block-structured AMR mesh, i.e., the MR
mesh is sparser. Similar to the previous section, we perform a detailed analysis of the
computations. The underlying FV schemes of the adaptive methods are benchmarked
on uniform meshes ﬁrst with NC = N 3 cells, where N = {32, 64, 128, 256}, which
corresponds to the levels L = {5, 6, 7, 8}. To reach the ﬁnal time instant te, NI time
steps are performed, where NI = {8, 32, 64, 128}, respectively. The number of time
steps NI is the same in all adaptive simulations.

The accuracy of the diﬀerent schemes is analyzed in Table 6 by considering the
L1 error of density with respect to the reference solution, down-sampled to the cor-
responding level. The behavior of the L1 errors is very similar to the previous 2D
study. For all cases, the error decreases as the number of levels L is increased. Since
again slightly diﬀerent FV schemes are employed (cf. Section 2), the MR/MRLT
computations and their baseline FV scheme exhibit smaller absolute errors than the
AMR/AMRLT methods and their respective FV scheme. For this conﬁguration, all
methods show a convergence order being slightly above one at the ﬁnest level. We
also observe that the adaptive computations with all four methods preserve the con-
vergence order of the underlying FV scheme particularly well and even better than in
the 2D investigation, which can be seen in Table 6 reﬂected in the very small error
perturbation rates.

Table 7 gives the total cell and leaf counts over the time steps and the corre-

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

15

Fig. 6. Adaptation for 3D shock-wave at time te. Upper row: AMRLT computation with L = 8.
3D visualization of 2D cuts of density in the diﬀerent planes ( y − z plane at x = 0, x − z plane at
y = 0, x − y plane at z = 0), Middle row: Isolines of 2D cuts of density for the AMRLT computation
with L = 8, superimposing the reﬁnement levels in gray. Lower row: Subset of the adaptive MR
mesh with L = 8 projected onto the planes shown in middle row, considering all cells with positions
in the interval [−0.35, 0.35] in the perpendicular direction of the respective plane.

sponding memory and mesh compression rates. To keep the computational eﬀort for
the 3D case reasonable, the total numbers of used cells and leafs at the ﬁnest level
L = 8 is comparable to the 2D values of Table 3 at the respective ﬁnest level L = 10.
Comparing the cell and leaf counts in Table 7 with Table 3, one ﬁnds that cell and
leaf count increase roughly by a factor of 8 to 10 for each additional level in the 3D
case, while factors 4 to 5 are found in the adaptive 2D simulations. This is consistent
with an isotropic reﬁnement by a factor of 2 in the third dimension. Since the num-
ber of integrated cells in the FV simulations rises by the same factor, memory and
mesh compression rates decrease with comparable factors in both the 2D and the 3D
conﬁguration. However, in the 3D case the convergence is enhanced, with generally
smaller compression ratios than in 2D at all levels except the coarsest one. Again, it
can be noted that for MR/MRLT the compression rates decrease slightly faster than
for the AMR schemes but the diﬀerence is generally smaller than in the 2D case.

Denoting by d the spatial dimension, the number of integrated cells in the FV
simulations rises exactly by the factor 2d+1 at the next ﬁner level. The absolute CPU
times of Table 8 exhibit the expected factor of ∼ 16 increase for both FV schemes

16

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

Accuracy of the 3D computations for the two FV schemes, MR and MRLT, and AMR and

AMRLT using diﬀerent levels of reﬁnement.

Table 6

L

5
6
7
8

L

5
6
7
8

FV

MR

L1(ρ)

Rate

L1(ρ)

Rate

0.386740
0.227130
0.121120
0.053677

0.768
0.907
1.174

0.387222
0.227270
0.121157
0.054001

0.769
0.908
1.166

FV

AMR

L1(ρ)

Rate

L1(ρ)

Rate

0.472266
0.309526
0.184180
0.086319

0.610
0.749
1.093

0.472295
0.309659
0.184503
0.087123

0.609
0.747
1.083

Pert.
[%]
0.12
0.06
0.03
0.60

Pert.
[%]
0.00
0.04
0.18
0.93

MRLT

L1(ρ)

Rate

0.387230
0.227278
0.121248
0.055429

0.769
0.906
1.129

AMRLT

L1(ρ)

Rate

0.472313
0.309662
0.184430
0.086900

0.609
0.748
1.086

Pert.
[%]
0.13
0.07
0.11
3.26

Pert.
[%]
0.00
0.04
0.14
0.67

Accumulated cell (C) and leaf (L) counts in 106 elements of adaptive 3D computations and

resulting memory and mesh compression rates.

Table 7

L

5
6
7
8

L

5
6
7
8

Cn

Pn
0.41
3.39
25.3
220

Cn

Pn
0.34
2.62
22.1
220

MR

MRLT

Ln

[%] Pn
78.0
40.4
18.9
10.2

0.26
2.03
16.3
147

AMR

Ln

[%] Pn
65.3
31.3
16.5
10.2

0.26
1.97
16.6
165

Cn

[%] Pn
48.8
24.2
12.1
6.86

0.40
3.32
24.8
217

Cn

[%] Pn
49.4
23.5
12.4
7.68

0.34
2.60
21.9
219

Ln

[%] Pn
77.1
39.6
18.5
10.1

0.26
2.00
15.9
146

Ln

AMRLT
[%] Pn
65.5
30.9
16.3
10.2

0.27
1.89
16.1
165

[%]
49.0
23.8
11.9
6.78

[%]
50.9
22.6
12.0
7.68

at all levels. In FV mode, the 3D MR/MRLT code is roughly a factor of 7.2 slower
than the 3D AMR/AMRLT code, which is an improvement compared to the 2D case.
As in 2D, MR and MRLT methods show very little diﬀerence in run time, where the
ineﬃciency of the AMR method without local time step reﬁnement, already observed
in 2D, is actually clearly reduced in the 3D case. This behavior can be explained by
the fact that the beneﬁt of time step reﬁnement can be expected to remain constant
while the overall workload increases by a factor of 2 with each additional spatial
dimension. The overhead after Eq. (3.9) for the AMR and AMRLT computations at
L = 8 is 180% and 120%, respectively. For the MR and MRLT runs at this level,
the overhead rate is 131% and 129% when being computed based on the performance
of the MR code in FV unigrid code, and 1558% and 1542% when the AMR code in
unigrid mode would be used as a somewhat questionable FV reference. See Section 4.1
for a discussion. Comparing the results with the 2D case of the previous section, one
ﬁnds that the relative mesh adaptation overhead of the AMR/AMRLT computations
rises considerably less than for MR/MRLT. A consequence of this behavior is that

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

17

Computing times and CPU time compression rates for 3D computations.

Table 8

L

5
6
7
8

FV
[s]

7.495
115.0
1832
28842

MR

MRLT

[s]

8.456
67.29
509.0
4571

[%]
113
58.5
27.8
15.8

[s]

8.414
65.34
492.0
4477

[%]
112
56.8
26.9
15.5

FV
[s]

1.143
16.79
260.9
4010

AMR

[s]

1.250
10.66
87.73
863.5

[%]
109
63.5
33.6
21.5

AMRLT
[s]

[%]
90.8
48.5
25.8
16.9

1.038
8.145
67.43
676.7

Breakdown of CPU time in % spent in main task groups for 3D computations at L = 8.

Table 9

Task group

Numerics
Temp. data
Boundary cond.
MR tree org.
Level transfer
Memory (c-lib)
Unassigned

FV
34.44
38.99
8.15
–
–
12.61
5.81

MR
NLT
23.43
16.21
4.18
34.48
1.42
5.77
14.51

Task group

LT
23.23
16.03
4.17
34.56
1.44
5.69 Memory (c-lib)

Numerics
AMR data org.
Clustering
Flagging
Lever transfer

14.88

Unassigned

AMR
NLT
69.51
7.84
2.54
2.64
9.10
3.77
4.60

LT
74.04
5.52
2.25
1.61
7.86
3.92
4.80

FV
92.12
–
–
–
–
5.51
2.37

the overhead in terms of the leaf updates is now consistently smaller for the AMRLT
case than for MR but particularly also for MRLT. This result is diﬀerent than in
Section 4.1. However, for L ≥ 6 the adaption overhead of the AMR method without
local time stepping is still larger than the overhead of MR or MRLT.

An explanation for the enhanced performance of the AMRLT method might be
found in Table 9 that shows again a breakdown of the ﬁnest resolved adaptive com-
putation as obtained by the perf tool. The breakdown in major task groups is the
same as in Table 5. Although the unassigned portion has substantially risen in the
MR/MRLT cases, the time spent in the core FV update routine has shrunk slightly
while for AMR and AMRLT this portion has risen by about 5 and 2.5 %, respectively.
Further, the portion of the clustering algorithm has been reduced considerably in the
3D case. An explanation for this behavior might be that the ﬂow phenomenon to be
reﬁned is more localized in the 3D simulations and meshes are coarser.

4.3. Software design aspects. The observed diﬀerences in performance war-
rant a deeper discussion of the internal data structures and algorithmic solutions
adopted in the computer codes which were employed for this study.

The Carmen MR/MRLT code follows an object-oriented design whose base class
is a Cell that stores the vector of state for a single FV cell. When the code is operating
in unigrid mode, a consecutive array of Cell elements is allocated; in MR/MRLT mode
each Cell is a member of an object of type Node. In order to incorporate each Node
object into the graded tree structure, Node has a pointer to its parent and possibly
an array with 2d pointers to the children nodes. Depending on the dynamic mesh
evolution, Node objects are dynamically allocated or deleted individually, using the
standard C++ commands new and delete. The children array remains unallocated
for leaf nodes. When the numerical update is performed in Carmen, the nodes of the
graded tree are recursively visited starting from a single root node. If the node is

18

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

a leaf, numerical ﬂuxes are evaluated by querying the neighbor nodes for their cell-
wise vector of state. All numerical ﬂuxes along the cell boundary are then computed
and their sum stored in Cell. This cell-oriented approach minimizes the memory
footprint but requires two evaluations of the computationally expensive numerical
ﬂuxes per facet, even when the code is run in FV unigrid mode. Since the graded
tree is genuinely unstructured and the data are not stored consecutively in memory,
the necessary tree traversal is computationally very costly as can be seen in Tables 5
and 9 (MR tree organization). Since only recursive tree traversal starting at the root
node is currently supported, the execution of a higher level local time step requires
a loop over all Node elements of the entire tree data structure, which explains the
rather similar computing times of MR and MRLT.

The performance for accessing data through the tree in Carmen could be enhanced
by implementing a recursive storage pattern that ensures data locality in memory,
e.g., by employing a generalized space ﬁlling curve algorithm to deﬁne a recursive
sequential ordering of the multi-dimensional cells of the Cartesian mesh, cf.
[54].
The index information for the space ﬁlling curve as well as the local neighbor and
parent/child information of the tree nodes could be encoded very eﬀectively in bit
[10]. Double ﬂux computations could be relatively easily avoided by
patterns, cf.
adding available numerical ﬂuxes at once to the vector of state of both neighboring
cells or by introducing a more complex tree traversal operator.

In the object-oriented design of block-based AMR software it is common to in-
troduce a Box class deﬁning a rectangular area in integer index space. A list of Box
objects speciﬁes the grid topology of every reﬁnement level and a Patch class adds
consecutive data storage to each Box. Depending on the stencil width of the numerical
method, layers of ghost cells are created in addition. In AMROC, the allocation of
Patch objects and their internal data arrays is also done with the standard C++ new
and delete commands but note that thanks to clustering typically several hundreds
of cells together in a single patch, the number of memory management requests is
much smaller than in Carmen. After the ghost cells of the Patch objects of one level
have been properly set, the FV update function can be called in a simple loop over
all patches. In unigrid mode, this corresponds to a straightforward block-based FV
code on a rectangular grid and the computational performance hence is quasi-optimal.
Each numerical ﬂux is computed only once per patch; double ﬂux evaluations occur
only along the boundary facets that a patch shares with a neighbor of the same
level. In explicit FV methods the computing costs are dominated by the numerical
ﬂux evaluations, which in combination with the faster MUSCL-Hancock reconstruc-
tion approach (cf. Section 2.2) explains well why the absolute costs for the portion
Numerics in Tables 5 and 9 are roughly 2 to 2.5 times smaller in the AMROC code.

5. Conclusions. In the present paper, fully adaptive computations of the 2D
and 3D compressible Euler equations are presented and two approaches for introducing
adaptivity, i.e., MR and adaptive mesh reﬁnement, are compared and benchmarked
in detail. For the same accuracy, the eﬃciency in terms of CPU time and memory
compression of these two adaptive methods has been assessed. For time integration
either global time stepping or scale-dependent local time stepping techniques of second
order Runge-Kutta type are used. The main diﬀerences between MR and AMR is
in the way the adaptive meshes are stored and how the error estimators are deﬁned.
The MR method uses a graded tree data structure and thresholding of the wavelet
coeﬃcients, corresponding to the details between two consecutive levels, to deﬁne the
adaptive mesh. The AMR method uses a series of regular data blocks on the diﬀerent

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

19

levels and relies on scaled gradient criteria based on pressure and density to trigger
the mesh reﬁnement and coarsening. Although in both approaches the thresholds
are chosen to impose approximately the same accuracy relative to a uniform grid
computation, MR methods beneﬁt from a rigorous and potentially more accurate
regularity analysis, while for AMR methods rigorous error estimators are not available.
Therefore, threshold values of AMR have to be tuned for a given problem, whereas
in MR, in principle, the threshold is independent of the problem.

The computational results show that the MR method generally presents larger
compression rates and has a prinicipal potential for obtaining larger gains in CPU
time than the AMR method. The improved compression rates observed for the MR
method are the consequences of a mathematically more sound adaptation criterion
as well as applying a patch-based reﬁnement in the AMR method, which leads to a
larger number of total cells to avoid data fragmentation.

When absolute CPU times are the primary concern, this investigation has un-
derscored the importance of utilizing hierarchical data structures that preserve some
memory coherence on computing data and use auxiliary data to avoid repeated gener-
ation of topological and numerical information. While the fulﬁllment of these require-
ments is rather naturally embedded into the block-based AMR approach, it comes at
the cost of a more complicated base implementation. On the other hand, the cell-
based quad- or octree approach can be implemented prototypically with comparably
little code; yet, the realization of a high-performance library for adaptive tree data
is at least as involved, cf. [36, 54, 10], as devising a high-performance AMR library,
[45, 34, 20]. In relative terms, the beneﬁt of the MR approach has been clearly
cf.
demonstrated. However, the herein employed prototype code falls far short compared
to the AMR approach in absolute compute time and – with local time stepping – even
in relative adaption overhead for the 3D problem considered.

Our next step will be to implement MR analysis as a mesh reﬁnement criterion
for the AMR/AMRLT algorithms, which will combine the natural high computational
eﬃciency of the block-based approach with a mathematically rooted error indicator,
requiring less user adjustment. This paper has underscored that for typical, shock-
dominated gas dynamical problems solved with explicit FV schemes the choice of
data structures and adaptation algorithms has a higher impact on computational
performance than the mathematical rigor of the mesh reﬁnement criterion.

Acknowledgments. MOD and SG thankfully acknowledge ﬁnancial support
from Ecole Centrale de Marseille (ECM), Funda¸c˜ao de Amparo a Pesquisa do Estado
de S˜ao Paulo - FAPESP, and the Brazilian Research Council - CNPq, Brazil. KS
thanks the ANR project “SiCoMHD” for ﬁnancial support. The authors also thank
the CEMRACS 2012 summer program, where part of this study was done. We are
grateful to D. Foug`ere and V. E. Mencone for their computational assistance.

REFERENCES

[1] R. Abgrall and A. Harten. Multiresolution representation in unstructured meshes. SIAM J.

Numer. Anal., 35(6):2128–2146, 1998.

[2] R. Becker and R. Rannacher. An optimal control approach to a-posteriori error estimation. In
A. Iserles, R. Becker, R. Rannacher, and P. G. Ciarlet, editors, Acta Numerica, volume 10,
pages 1–102. Cambridge University Press, 2001.

[3] J. Bell, M. Berger, J. Saltzman, and M. Welcome. Three-dimensional adaptive mesh reﬁnement

for hyperbolic conservation laws. SIAM J. Sci. Comput., 15(1):127–138, 1994.

[4] M. Berger and P. Colella. Local adaptive mesh reﬁnement for shock hydrodynamics. J. Comput.

Phys., 82:64–84, 1988.

20

R. DEITERDING, M. O. DOMINGUES, S. M. GOMES, AND K. SCHNEIDER

[5] M. Berger and R. J. LeVeque. Adaptive mesh reﬁnement using wave-propagation algorithms

for hyperbolic systems. SIAM J. Numer. Anal., 35(6):2298–2316, 1998.

[6] M. Berger and J. Oliger. Adaptive mesh reﬁnement for hyperbolic partial diﬀerential equations.

J. Comput. Phys., 53:484–512, 1984.

[7] B. L. Bihari. Multiresolution schemes for conservation laws with viscosity. J. Comput. Phys.,

123:207–225, 1997.

[8] B. L. Bihari and A. Harten. Multiresolution schemes for the numerical solution of 2-D conser-

vation laws I. SIAM J. Sci. Comput., 18(2):315–354, 1996.

[9] A. Brandt. Multi-level adaptive solutions to boundary-value problems. Mathematics of Com-

putations, 31(183):333–390, April 1977.

[10] C. Burstedde, L. C. Wilcox, and O. Ghattas. p4est: Scalable algorithms for parallel adaptive
mesh reﬁnement on forests of octrees. SIAM Journal on Scientiﬁc Computing, 33(3):1103–
1133, 2011.

[11] G. Chiavassa and R. Donat. Point value multi-scale algorithms for 2D compressible ﬂow. SIAM

J. Sci. Comput., 23(3):805–823, 2001.

[12] A. Cohen. Wavelet methods in numerical analysis. In P. G. Ciarlet and J. L. Lions, editors,

Handbook of Numerical Analysis, volume VII. Elsevier, Amsterdam, 2000.

[13] A. Cohen, N. Dyn, S. M. Kaber, and M. Postel. Multiresolution ﬁnite volume schemes on

triangles. J. Comput. Phys., 161:264–286, 2000.

[14] A. Cohen, S. M. Kaber, S. M¨uller, and M. Postel. Fully adaptive multiresolution ﬁnite volume

schemes for conservation laws. Math. Comp., 72:183–225, 2003.

[15] W. Dahmen, B. Gottschlich-M¨uller, and S. M¨uller. Multiresolution schemes for conservation

laws. Numer. Math., 88(3):399–443, 2001.

[16] R. Deiterding. AMROC - Blockstructured Adaptive Mesh Reﬁnement in Object-oriented C++.

http://amroc.sourceforge.net.

[17] R. Deiterding. Parallel adaptive simulation of multi-dimensional detonation structures. PhD

thesis, Brandenburgische Technische Universit¨at Cottbus, Sep 2003.

[18] R. Deiterding. Construction and application of an AMR algorithm for distributed memory
computers. In T. Plewa, T. Linde, and V. G. Weirs, editors, Adaptive Mesh Reﬁnement
- Theory and Applications, volume 41 of Lecture Notes in Computational Science and
Engineering, pages 361–372. Springer, 2005.

[19] R. Deiterding. A parallel adaptive method for simulating shock-induced combustion with de-

tailed chemical kinetics in complex domains. Comp. Struct., 87:769–783, 2009.

[20] R. Deiterding. Block-structured adaptive mesh reﬁnement - theory, implementation and appli-

cation. ESAIM Proceedings, 34:97–150, 2011.

[21] R. Deiterding, M. O. Domingues, S. M. Gomes, O. Roussel, and K. Schneider. Adaptive
multiresolution or adaptive mesh reﬁnement? A case study for 2d Euler equations. ESAIM
Proceedings, 16:181–194, 2009.

[22] R. Deiterding, R. Radovitzki, S. Mauch, F. Cirak, D. J. Hill, C. Pantano, J. C. Cummings,
and D. I. Meiron. Virtual Test Facility: A virtual shock physics facility for simulating the
dynamic response of materials. http://www.vtf.website.

[23] M. O. Domingues, S. M. Gomes, and L. M. A Diaz. Adaptive wavelet representation and

diﬀerenciation on block-structured grids. Appl. Num. Math., 47:421–437, 2003.

[24] M. O. Domingues, S. M. Gomes, O. Roussel, and K. Schneider. An adaptive multiresolution
scheme with local time stepping for evolutionary PDEs. J. Comp. Phys., 227:3758–3780,
2008.

[25] M. O. Domingues, S. M. Gomes, O. Roussel, and K. Schneider. Space-time adaptive mul-
tiresolution methods for hyperbolic conservation laws: Applications to compressible Euler
equations. Appl. Num. Math., 59:2303–2321, 2009.

[26] M. O. Domingues, S. M. Gomes, O. Roussel, and K. Schneider. Adaptive multiresolution

methods. ESAIM Proceedings, 34:1–96, 2011.

[27] M. O. Domingues, O. Roussel, and K. Schneider. An adaptive multiresolution method for

parabolic pdes with time-step control. Int. J. Numer. Meth. Engng., 78:652–670, 2009.

[28] H. Friedel, R. Grauer, and C. Marliani. Adaptive mesh reﬁnement for singular current sheets
in incompressible magnetohydrodynamics ﬂows. J. Comput. Phys., 134(1):190–198, 1997.
[29] B. Gottschlich-M¨uller and S. M¨uller. Adaptive ﬁnite volume schemes for conservation laws
based on local multiresolution techniques. In R. Jeltsch and M. Frey, editors, Hyperbolic
Problems: Theory, Numerics, Applications, volume 129. ISNM, Inter. Ser. Numer. Math.,
1999.

[30] A. Harten. Multiresolution algorithms for the numerical solution of hyperbolic conservation

laws. Comm. Pure Appl. Math., 48:1305–1342, 1995.

[31] A. Harten. Multiresolution representation of data: a general framework. SIAM J. Numer.

COMPARISON OF ADAPTIVE MULTIRESOLUTION AND AMR

21

Anal., 33(3):385–394, 1996.

[32] M. Holmstr¨om. Wavelet Based Methods for Time Dependent PDEs. PhD thesis, Uppsala

University, 1997.

[33] M. Holmstr¨om. Solving hyperbolic PDEs using interpolating wavelets. SIAM J. Sci. Comput.,

21(2):405–420, 1999.

[34] R. D. Hornung, A. M. Wissink, and S. H. Kohn. Managing complex data and geometry in

parallel structured AMR applications. Engineering with Computers, 22:181–195, 2006.

[35] M. Kaibara and S. M. Gomes. A fully adaptive multiresolution scheme for shock computa-
tions. In E.F. Toro, editor, Godunov Methods: Theory and Applications, volume . Klumer
Academic/Plenum Publishers, 2001.

[36] A. M. Khokhlov. Fully threaded tree algorithms for adaptive reﬁnement ﬂuid dynamics simu-

lations. J. Comput. Phys., 143:519–543, 1998.

[37] S. R. Kohn and S. B. Baden. A parallel software infrastructure for structured adaptive mesh

methods. In Proc. of the Conf. on Supercomputing ’95, December 1995.

[38] D. Kolomenskiy, J.-C. Nave, and K. Schneider. Adaptive gradient-augmented level set method
with multiresolution error estimation. J. Sci. Comput., 2015. doi:10.1007/s10915-015-0014-
7, in press.

[39] P. D. Lax and X. D. Liu. Solution of two-dimensional Riemann problems of gas dynamics by

positive schemes. SIAM J. Sci. Comput., 19(2):319–340, 1998.

[40] M.-S. Liou. A sequel to AUSM: AUSM+. J. Comput. Phys., 129:364–382, 1996.
[41] P. MacNeice, K. M. Olson, C. Mobarry, R. deFainchtein, and C. Packer. PARAMESH: A
parallel adaptive mesh reﬁnement community toolkit. Computer Physics Communications,
126:330–354, 2000.

[42] S. M¨uller. Adaptive multiscale schemes for conservation laws, volume 27 of Lectures Notes in

Computational Science and Engineering. Springer, Heidelberg, 2003.

[43] S. M¨uller and Y. Stiriba. Fully adaptive multiscale schemes for conservation laws employing

locally varying time stepping. J. Sci. Comput., 30(3):493–531, 2007.

[44] C. Pantano, R. Deiterding, D. J. Hill, and D. I. Pullin. A low-numerical dissipation patch-
based adaptive mesh reﬁnement method for large-eddy simulation of compressible ﬂows.
J. Comput. Phys., 221:63–87, 2007.

[45] C. A. Rendleman, V. E. Beckner, M. Lijewski, W. Crutchﬁeld, and J B. Bell. Parallelization
of structured, hierarchical adaptive mesh reﬁnement algorithms. Computing and Visual-
ization in Science, 3, 2000.

[46] D. Rossinelli, B. Hejazialhosseini, D. Spampinato, and P. Koumoutsakos. Multicore/multi-
gpu accelerated simulations of multiphase compressible ﬂows using wavelet adapted grids.
SIAM J. Sci. Comput., 33:512–540, 2011.

[47] D. Rossinelli, B. Hejazialhosseini, W. van Rees, M. Gazzola, M. Bergdorf, and P. Koumout-
sakos. Mrag-i2d: Multiresolution adapted grids for remeshed vortex methods on multicore
architectures. J. Comput. Phys., 288:1–18, 2015.

[48] O. Roussel and K. Schneider. An adaptive multiresolution method for combustion problems:

application to ﬂame ball - vortex interaction. Comp. Fluids, 34(7):817–831, 2005.

[49] O. Roussel, K. Schneider, A. Tsigulin, and H. Bockhorn. A conservative fully adaptive mul-

tiresolution algorithm for parabolic PDEs. J. Comput. Phys., 188(2):493–523, 2003.

[50] K. Schneider and O. V. Vasilyev. Wavelet methods in computational ﬂuid dynamics. Annu.

Rev. Fluid. Mech., 42:473–503, 2010.

[51] C. W. Schulz-Rinne, J. P. Collis, and H. M. Glaz. Numerical solution of the Riemann problem

for two-dimensional gas dynamics. SIAM J. Sci. Comput., 14:1394–1414, 1993.

[52] E. F. Toro. Riemann solvers and numerical methods for ﬂuid dynamics. Springer, 1997.
[53] Y. Wada and M. S. Liou. An accurate and robust ﬂux splitting scheme for shock and contact

discontinuities. SIAM J. Sci. Comput., 18(3):633–657, 1997.

[54] T. Weinzierl and M. Mehl. Peano – A traversal and storage scheme for octree-like adaptive
cartesian multiscale grids. SIAM Journal on Scientiﬁc Computing, 33(5):2732–2760, 2011.
[55] T. Zhang and Y. Zheng. Conjecture on the structure of solutions the Riemann problem for

two-dimensional gas dynamics systems. SIAM J. Math. Anal., 21:593–630, 1990.

