6
1
0
2

 
r
a

 

M
1
1

 
 
]
I

A
.
s
c
[
 
 

1
v
5
1
5
3
0

.

3
0
6
1
:
v
i
X
r
a

Dimension Coupling: Optimal Active Learning

of Halfspaces via Query Synthesis

Lin Chen1, Hamed Hassani2, and Amin Karbasi1

1 Department of Electrical Engineering, Yale University

2 Computer Science Department, ETH Zurich

March 14, 2016

Abstract

In this paper, we consider the problem of actively learning a linear classiﬁer
through query synthesis where the learner can construct artiﬁcial queries in order
to estimate the true decision boundaries. This problem has recently gained a lot of
interest in automated science and adversarial reverse engineering for which only
heuristic algorithms are known. In such applications, queries can be constructed
de novo to elicit information (e.g., automated science) or to evade detection with
minimal cost (e.g., adversarial reverse engineering).

We develop a general framework, called dimension coupling (DC), that 1) re-
duces a d-dimensional learning problem to d − 1 low-dimensional sub-problems,
2) solves each sub-problem efﬁciently, and 3) appropriately aggregates the results
and outputs a linear classiﬁer. We consider the three most common scenarios in
the literature: idealized noise-free, independent noise realizations, and agnostic
settings. We show that the DC framework avoids the curse of dimensionality: its
computational complexity in all three cases scales linearly with the dimension.
Moreover, in the noiseless and noisy cases, we show that the query complexity of
DC is near optimal (within a constant factor of the optimum algorithm). We also
develop an agnostic variant of DC for which we provide strong theoretical guaran-
tees. To further support our theoretical analysis, we compare the performance of
DC with the existing work in all three settings. We observe that DC consistently
outperforms the prior arts in terms of query complexity while often running orders
of magnitude faster.

Introduction

In contrast to the passive model of supervised learning, where all the labels are pro-
vided without any interactions with the learning mechanism, the key insight in active
learning is that the learning algorithm can perform signiﬁcantly better if it is allowed to
choose which data points to label. This approach has found far-reaching applications,
including the classical problems in AI (e.g., classiﬁcation [17], information retrieval
[16], speech recognition [8]) as well as the modern ones (e.g., interactive recommender
systems [10], optimal decision making [9]).

1

achieve an estimation error of ǫ [6].

In statistical learning theory, one assumes that a set of hypotheses H along with a
set of unlabeled data points X are given, where each data point x ∈ X is drawn i.i.d.
from some distribution D. Classical probably approximately correct (PAC) bounds
then yield the sample complexity (i.e., the number of required i.i.d. examples) from D
to output a hypothesis h ∈ H that will have estimation error at most ǫ with probability
at least 1 − δ, for some ﬁxed ǫ, δ > 0. Here, the estimation error is deﬁned as error(h) =

case of learning a halfspace, i.e., when h∗ ∈ Rd perfectly separates the data points into
a linear separator with an estimation error ǫ. In contrast, a simple counting argument

Prx∼D[h(x) ≠ h∗(x)], where h∗ is the unknown true hypothesis. In the realizable
positive and negative labels, it is known that with ˜O(d~ǫ)1 i.i.d. samples one can ﬁnd
based on sphere packing shows that any algorithm needs Ω(d log(1~ǫ)) examples to

If one is not careful, active learning may require more samples than passive learn-
ing to achieve the same estimation error. One setting that is guaranteed to perform at
least as well as passive learning is pool-based active learning [12]: a set of unlabeled
examples are drawn i.i.d. where instead of obtaining all labels at once, the learning
algorithm sequentially decides which labels to request and which ones to discard. The
key challenge is to develop an algorithm that requests informative labels from the pool
in such a way that the remaining labels can be inferred as quickly as possible. A prin-
cipled way is to deﬁne a version space V containing all hypotheses consistent with the
labels obtained so far and try to shrink it signiﬁcantly by requesting new labels from
the pool. An effective but computationally expensive method is the halving algorithm,
also referred to as generalized binary search (GBS), where at each iteration the next
example to label is chosen in such a way that it approximately cuts the version space
by one half. The new version space is constructed and the process is repeated until the
estimation error is less than ǫ. In many cases, computing the version space is compu-
tationally prohibitive. Dasgupta [6], in the idealized case that the labels are noise-free

ing this bound is generally intractable. Perhaps the most common query methods that
approximate the idealized halving algorithm are uncertainty sampling [12] and query-

and there exists a realizable linear separator, showed that one requires ˜O(d log2(1~ǫ))
labels, an exponential improvement over ˜O(d~ǫ). Unfortunately,the algorithm achiev-
by-committee (QBC) [7]. Freund et al. [7] showed that QBC requests ˜O(d log(1~ǫ))
reduction in sample complexity, requiring ˜O(d2 log(1~ǫ)) labels. Unfortunately, most

labels, but comes at the price of prohibitive computational cost in each iteration. Sim-
ilarly, Balcan et al. [4] showed that uncertainty sampling also achieves an exponential

approximation methods are only guaranteed to work if the pool size grows exponen-
tially fast in each iteration. Hence, one needs to always store a large amount of data in
addition to computing a complex version space.

An attractive alternative to the pool-based framework is query synthesis [3]: a
learner can request for any unlabeled data instance from the input space, including
queries that the learner synthesizes from scratch. This way the pool size limitation
is entirely eliminated. In many recent applications, ranging from automated science
[11], to robotics [5], and to adversarial reverse engineering [13], query synthesis is the
appropriate model. For instance, in security-sensitive applications (e.g., spam ﬁlters

1We use the ˜O notation to ignore terms that are logarithmic or dependent on δ.

2

and intrusion detection systems) that routinely use machine learning tools, a growing
concern is the ability of adversarial attacks to identify the blind spots of the learning
algorithms. Concretely, classiﬁers are commonly deployed to detect miscreant activ-
ities. However, they are attacked by adversaries who generate exploratory queries to
elicit information that in return allows them to evade detection [14]. In this work, we
show how an adversary can use active learning methods by making synthetically de
novo queries and thus identify the linear separator used for classiﬁcation.

We should emphasize that in active learning via synthesized queries the learning
algorithm can query the label of any points (irrespective of the underlying distribution
D) in order to explore the hypothesis space. However, for evaluating the performance
of the algorithm in terms of the estimation error, one may use the distribution D. This
is quite different from pool-based framework where queries should be among the data
points drawn i.i.d. from the underlying distribution D.

There is little known about the theoretical performance of actively learning a linear
classiﬁer via query synthesis. The closest work to our efforts is [2] where they pro-
pose a heuristic algorithm that approximates the version space by a convex body with
promising empirical results in the noise-free setting. Their method is not appropriate
for high dimensional data, as its computational complexity scales cubically with the
dimension. Moreover, their algorithm fails in the presence of noise.

In this paper, we develop a framework, called Dimension Coupling (DC), with the
following guarantees. In the noiseless setting, we show that its computational com-

˜ǫ) and its query complexity is ˜O(d log 1

plexity is ˜O(d log 1
setting, we show that the computational complexity of DC is ˜O(d(log 1
its query complexity is ˜O(d(log 1

˜ǫ). Similarly, in the noisy
˜δ)2) and
˜δ)). Note that in both settings the computa-

tional complexity scales linearly with the dimension. Moreover, the query complexity
in both settings is near-optimal. Finally, we generalize our results to the agnostic case.
Our empirical experiments demonstrate that DC runs orders of magnitude faster than
the existing methods.

˜ǫ + log 1

˜ǫ + log 1

Problem Formulation

in Rd. Let us emphasize here that the only information we obtain from a query is the

where ei is the ith standard basis vector, will only reveal the sign of the ith component
of h∗ (and nothing further about its value).

Our objective is to estimate an unknown halfspace H∗ ={x ∈ Rd ∶⟨h∗, x⟩ > 0}, using
as few queries as possible. Here,⟨⋅, ⋅⟩ is the standard inner product of the Euclidean
space (also ⋅ denotes the Euclidean norm), h∗ is some (hidden) unit vector that we
want to estimate, and a generic query is of the form sign(⟨h∗, x⟩) where x is selected
sign of the inner product and not the value. E.g., the queries of the form sign(⟨h∗, ei⟩),
In the noiseless setting, we observe the true outcome of the query, i.e. sign⟨h∗, x⟩ ∈
{1, −1}. In the noisy setting, the outcome is a ﬂipped version of the true sign with
independent ﬂip probability ρ. That is, denoting the outcome by Y we have Y ∈{−1, 1}
and Pr[Y ≠ sign⟨h∗, x⟩] ∶= ρ < 1~2.
we only query the points on the unit sphere Sd−1 ={x ∈ Rd ∶x = 1}. Hence, we term

Since the length of the selected vector x will not affect the outcome of the query,

3

X = Sd−1 as the query space. All possible unit vectors also reside on the unit sphere
Sd−1. Therefore, the initial version space, denoted by H, is also Sd−1.
As aforementioned, to evaluate the performance of halfspace learning algorithms,
we assume that unlabeled data points are drawn from the distribution D with a con-

ǫ, δ > 0, we seek an algorithm that (i) adaptively selects vectors x1, x2, ⋯, (ii) observes

tinuous probability density function fD. The estimation error is deﬁned as error(h) =
Prx∼D[h(x) ≠ h∗(x)] = ∫ 1{h(x) ≠ h∗(x)}fD(x)dx ≤ 4MD arcsin(h − h∗~2),
where MD = maxx fD(x). To make sure the estimation error error(h) ≤ ǫ , it suf-
ﬁces to ensureh − h∗ < ǫD, where ǫD = 2 sin[ǫ~(4MD)]; e.g., when D is uni-
form, ǫD = 2 sin(πǫ~2). Therefore, hereinafter we only discuss how to guarantee
h − h∗ < ǫD with high probability (say, at least 1 − δ). We report all the results
in terms ofh − h∗ but it is easy to convert them to the estimation error. Thus, given
the (noisy) responses to each query sign⟨h∗, xi⟩, (iii) and outputs, using as few queries
as possible, an estimate ˆh of h∗ such thatˆh − h∗ < ǫ with probability at least 1 − δ.
i=1 is an arbitrarily chosen
i = 1).
i=1 within a given precision by using

Suppose that h∗ has the form h∗ = ∑d
orthonormal basis for Rd. We assume w.l.o.g. that h∗ is normalised (i.e., ∑d
the (noisy) responses to the selected sign queries. The key insight here is that this
task can be partitioned in a divide-and-conquer fashion into many smaller tasks, each

Our objective is then to learn the coefﬁcients{ci}d
involving a few dimensions. The ﬁnal answer (the values of{ci}d

i=1) will then be
obtained by aggregating the answers of these subproblems.
Example 1. Assume h∗ = c1e1 + c2e2 + c3e3 + c4e4, where ei’s are the standard basis
vectors for R4. Deﬁne

Dimension Coupling Based Framework

i=1 ciei, where{ei}d

i=1 c2

ˆe1 = c1e1 + c2e2
+ c2
2

, ˆe2 = c3e3 + c4e4
+ c2
4

c2

3

1

c2
2ˆe1 +c2

3

Note here that ˆe1 is the (normalised) orthogonal projection of h∗ onto span{e1, e2}
and ˆe2 is the (normalised) orthogonal projection of h∗ onto span{e3, e4}. Consider
relation h∗ =c2

the following procedure to learn h∗: ﬁrst ﬁnd out what ˆe1 and ˆe2 are, and then use the
4ˆe2 to ﬁnd h∗ based on the orthonormal vectors
ˆe1, ˆe2. By this procedure, the original “four-dimensional” problem has been broken
into three “two-dimensional” problems.

+ c2

+ c2

1

For general d, the idea is similar: We break the problem into at most d − 1 “two-
dimensional” problems that each can be solved efﬁciently. More formally, let us as-

sume that we have an algorithm, called DC2(e1, e2, ǫ, δ), that takes as input two or-

thonormal vectors e1, e2 and outputs with probability at least 1 − δ a vector ˆe with the
following three properties:

ˆe ∈ span{e1, e2},ˆe = 1,ˆe − h∗,e1e1+h∗,e2e2

⟨h∗,e1⟩e1+⟨h∗,e2⟩e2 < ǫ.

In other words, the unit vector ˆe is within a distance ǫ to the (normalised) projection of

h∗ onto the subspace span{e1, e2}. In the next section, we will explain in detail how

4

,

+ c2
2j

(1)

h∗ =

d
Q
i=1

ciei =

ˆcj

c2j−1e2j−1 + c2je2j

to design an optimal candidate for DC2 that uses (noisy) responses to queries of the

form sign⟨x, h∗⟩. In the current section, we explain a framework DC that estimates
h∗ using at most d − 1 calls to DC2 (a formal description is given in Algorithm 1).
Consider the decomposition h∗ = ∑d
i=1 ciei. For simplicity assume that d is an even
number. We can write
d~2
Q
j=1

c2
where in the last step we have taken ˆcj ≜c2
is the (normalised) orthogonal projection of h∗ onto span{e2j−1, e2j}. Hence, by using
DC2(e2j−1, e2j, ǫ, δ) we can obtain, with probability at least 1 − δ, a good approxima-
j=1 ˆcj ˆej. Since h∗ is now expressed (approximately) in terms of d~2 known or-
thonormal vectors{ˆej}d~2
j=1, we have effectively reduced the dimensionality of problem
from d to d~2. The idea is then to repeat the same procedure as in (1) to the newly
obtained representation of h∗. Hence, by repeating this procedure at most log2 d times
we will reach a vector which is the ﬁnal approximation of h∗.
Algorithm 1 Dimension Coupling (DC)

tion ˆej (within a distance ǫ) of this projection. Therefore, for small enough ǫ we have
h∗ ≈ ∑d~2

2j. Now, note that c2j−1e2j−1+c2j e2j

2j−1
+ c2

c2

2j−1+c2

2j

2j−1

while d > 2

Input: an orthonormal basis E ={e1, e2, . . . , ed} of Rd.
1. for j = 1 to⌊d~2⌋
Replace the two vectors e2j−1, e2j in E with the vector DC2(e2j−1, e2j, ǫ, δ).
2. Set d←⌈d~2⌉ .
return DC2(e1, e2, ǫ, δ).

end while

end for

Theorem 2. For DC (outlined in Algorithm 1) we have:

1. DC will call the two-dimensional subroutine DC2 at most d − 1 times.

2. Provided that the output of DC2 is with probability 1 − δ within distance ǫ of
6d , DC ensures an estimation error of at most 6ǫd with

the true value and ǫ ≤ 1
probability at least 1 − δd.

We defer the proof of all theorems to the appendix. As a result of Theorem 2, if we
desire the framework DC to estimate h∗ within distance ˜ǫ and with probability at least
6d and δ = ˜δ
1 − ˜δ, then it is enough to ﬁx the corresponding parameters of DC2 to ǫ = ˜ǫ
d .

5

DC2: Solving in 2 Dimensions

.

(2)

+ c2

2 =

1

by h⊥, i.e.,

Before illustrating the algorithm DC2, let us review some notation. Given two or-

sign⟨x, h∗⟩ = sign⟨x, h⊥⟩ .

h⊥ = ⟨h∗, e1⟩ e1 +⟨h∗, e2⟩ e2
⟨h∗, e1⟩ e1 +⟨h∗, e2⟩ e22

thonormal vectors e1, e2 we denote the (normalised) projection of h∗ onto span{e1, e2}
The objective of DC2(e1, e2, ǫ, δ) is to ﬁnd a unit vector ˆe ∈ span{e1, e2} such that
ˆe − h⊥ < ǫ. In fact, we require the latter to hold with probability at least 1 − δ.
Any unit vector inside span{e1, e2}, e.g., h⊥, can equivalently be represented as a
pair(c1, c2) on the two-dimensional unit circle S1 (e.g., h⊥ = c1e1 + c2e2 and c2
1). To simplify notation, we use a point(c1, c2) ∈ S1 and its corresponding unit vector
c1e1+c2e2 interchangeably. In this setting, it is easy to see that for any x ∈ span{e1, e2}

(3)
We take a Bayesian approach. In the beginning, when no queries have been performed,
DC2 assumes no prior information about the vector h⊥. Therefore, it takes the uniform
2π ) as its prior belief about h⊥. After performing
each query, the posterior (belief) about h⊥ will be updated according to the observation.
this manner, DC2 runs in total of Tǫ,δ rounds, where in each round a speciﬁc query
is selected and posed to the oracle. The number Tǫ,δ will be speciﬁed later (see The-
orems 3 and 4). Upon the completion of round Tǫ,δ, the algorithm returns as its ﬁnal

distribution on S1 (with pdf p0(h) = 1
We let pm(h) denote the (pdf of the) posterior after performing the ﬁrst m queries. In
output a vector ˆe ∈ S1 that maximises the posterior pdf pTǫ,δ(h). If there are multiple

such maximisers, it picks one arbitrarily. We now proceed with a detailed description
of DC2 (a formal description is provided in Algorithm 2). We ﬁrst consider the simpler
noise-free case and the other settings will follow afterwards.
Noise-Free Case: We explain DC2 (outlined in Algorithm 2) with the help of a run-
ning example given in Figure 1. As we will see, after each round of DC2 the possible
region that h⊥ can belong to will be “halved”.
We ﬁrst note that as the initial distribution p0 is assumed to be the uniform distri-
bution on S1, the vector x1 (see step 2-(a) of Algorithm 2) can indeed be any point on
the unit circle S1. Thus, DC2 chooses x1 arbitrarily on S1. By (3), using the query

easy to verify that only half of S1 can possibly contain h⊥ (see Figure 1). Let us denote

sign⟨x1, h∗⟩ will also give us the value of sign⟨x1, h⊥⟩. Depending on this value, it is
this region by R1. Hence, the probability distribution p1(h) (which is our current be-
lief about h⊥) is updated as follows: for h ∉ R1 we have that p1(h) = 0, and as all the
points inside the half-circle R1 are equiprobable, we have for h ∈ R1 that p1(h) = 1~π.
In other words, at time m = 0 the vector h⊥ could have been anywhere on the unit
circle, but, after round m = 1 it can only belong to the half-circle R1. Thus, after the
ﬁrst round, DC2 “halves” the admissible region of h⊥. Continuing in this theme, it is
not hard to verify that (see Figure 1) at round m = 2 the value of p2(h) is non-zero and
uniform only on a region R2 which is a quarter-circle. In an inductive manner, letting
Rm−1 denote the admissible region (sector) at round m − 1 (see Figure 1) and assum-
ing that pm−1 is only non-zero and uniform on the sector Rm−1, then xm at round m is

6

Algorithm 2 DC2
Input: orthonormal vectors e1, e2, estimation error at most ǫ, success probability at
least 1 − δ.

1. Set p0(h) to be uniform, i.e., ∀h ∈ S1 ∶ p0(h) = 1~2π.

2. for m = 1 to Tǫ,δ

arbitrarily.

(a) ﬁnd a vector xm ∈ S1 which is a solution to the following equation:

∫S 1 sign⟨x, h⟩ pm−1(h)dh = 0. If there are multiple solutions, choose one
(b) ask from the oracle the value of sign⟨xm, h∗⟩.
pm−1(h) to pm(h).

(c) based on the response obtained from the oracle, update the distribution

end for

3. return ˆe = arg maxh∈S 1 pTǫ,δ(h).

Figure 1: An example to illustrate DC2 in the noiseless setting. In the ﬁrst round, x1 is arbitrarily chosen
on S 1. For the choice in the ﬁgure, we have sign ⟨x1, h∗⟩ = sign ⟨x1, h⊥⟩ = −1. For any point h above the
red line we have that sign ⟨x, h⟩ = −1 and for the points outside this half-circle the result is +1. Therefore,
the distribution (pdf of) p1 is uniform on the region above the red line and is zero below it. For round m = 2
it is easy to see that the direction of x2 should be along the red line. For x2 chosen as in the ﬁgure, we
have sign ⟨x2, h∗⟩ = +1 and hence at the end of the second round DC2 concludes that the vector h⊥ could
uniformly be any point inside R2. In a generic round m, any vector orthogonal to the mid-point of sector
Rm−1 can be considered as a candidate for xm. For the choice in the ﬁgure, we have sign ⟨xm, h⊥⟩ = −1.
Thus, at the end of round m, DC2 concludes that h⊥ can uniformly be any point inside Rm.

precisely the vector that is orthogonal to the midpoint of the sector Rm−1. Therefore,
after observing the value of sign⟨xm, h∗⟩, the admissible region Rm is the better half
of Rm−1 that is compatible with the observation (i.e., it contains h⊥). Also, Rm is again
a sector and pm will be uniform on Rm and zero outside. It is also easy to see that the
circular angle for the sector Rm is π
Theorem 3. Consider DC in the absence of noise (ρ = 0). If we let Tǫ,δ =⌈log2
ǫ⌉,

then it outputs a vector that is within a distance ǫ of h⊥.

2m . The following statement is now immediate.

π

7

A few comments are in order: The above guarantee for DC2 holds with probability
one and thus the parameter δ is irrelevant in the noiseless setting. Furthermore, during
each round of DC2, the distribution pm can be represented by only two numbers (the
starting and ending points of the sector Rm), and the vector xm can be computed ef-
ﬁciently (it is the orthogonal vector to the midpoint of Rm). Therefore, assuming one
unit of complexity for performing the queries, DC2 can be implemented with complex-

ity O(Tǫ,δ). Finally, by using Theorem 2, we conclude that DC requires ˜O(d log 1
ǫ)
queries with computational complexity ˜O(d log 1
ǫ).

In general, DC2 follows a similar procedure as in the noiseless case
Noisy Case:
except that the distributions pm does not look as simple. However, as we now dis-
cuss, these distributions can still be stored efﬁciently and as a result the vector xm
can be computed efﬁciently. Indeed, (the pdf of) pm is piecewise constant on the unit
circle (see Figure 2). More precisely, at any round m, there are at most 2m points
u1, u2, ⋯, u2m that are ordered clock-wise on the unit-circle and pm is constant when

We refer to Figure 2 for a schematic illustration. Once a noisy response to the query

step 2-(a) of Algorithm 2), DC2 ﬁrst ﬁnds a line that passes through the centre of S1 and
cuts S1 into two “halves” which have the same measure with respect to pm. Note that

restricted to each of the sectors[ui, ui+1). At round m + 1, in order to ﬁnd xm+1 (see
ﬁnding such a line can be done in O(m) steps because pm has the piecewise constant
property. Once such a line is found, it is then easy to see that xm+1 can be any of the two
points orthogonal to the line. As a result, DC2 at round m + 1 can ﬁnd xm+1 in O(m)
operations. We denote the half-circle containing xm+1 by R+ and the other half by R−.
sign⟨xm+1, h∗⟩ is obtained, the probability distribution pm will be updated to pm+1 in
the following way. First, consider the event that the outcome of sign⟨xm+1, h∗⟩ is +1.
We have pm(sign⟨xm+1, h∗⟩ = +1) =(1−ρ) pm(R+)+ρ pm(R−) = 1~2, and similarly
pm(sign⟨xm+1, h∗⟩ = +1) = 1~2. Therefore, by Bayes theorem we obtain the follow-
ing update rules for pm+1. If we observe that sign⟨xm+1, h∗⟩ = +1, then for h ∈ R+ we
have pm+1(h) = 2(1 − ρ)pm(h) and for h ∈ R− we have pm+1(h) =(2ρ)pm(h). Also,
if we observe that sign⟨xm+1, h∗⟩ = −1, then for h ∈ R+ ∶ pm+1(h) =(2ρ)pm(h) and
for h ∈ R− ∶ pm+1(h) = 2(1 − ρ)pm(h). (note that the factor of 2 here is due to the
normalization.) It is easy to verify that pm+1 is also a piecewise constant distribution
(now on 2(m + 1) sectors; see Fig. 2).
Theorem 4. In the noisy setting (with independent ﬂip probability ρ), having

is sufﬁcient to guarantee that DC2 outputs with probability at least 1 − δ a vector that
, T1 =

8 log 2
δ

Tǫ,δ ≥ M + max{T0, T1, T2, T3} = O(log

8

8 log 1
8πǫ

, T2 =

log(2(1−ρ))

is within a distance ǫ of h⊥. Here, we have M =⌈
log(2(1−ρ))log(2M) + log(
Theorem 2 indicates that DC requires ˜O(d(log 1
cussed above, the computational complexity of DC2 is O(T 2
δ)2).
putational complexity ˜O(d(log 1

+ log 1

+ log 1

4

ǫ

ǫ

8

(4)

1

1
ǫ

+ log

δ)
− log(4ρ(1−ρ))⌉, T0 =
log(2(1−ρ))) and T3 = 24ρ log2 1−ρ

log(2(1−ρ))

2 log 2
δ

ρ

δ).
log2(2(1−ρ))log(M) + log( 4

δ)) queries. Also, as dis-
ǫ,δ). Hence, DC has com-

Figure 2: Upon the completion of round m (left ﬁgure), the distribution (pdf of) pm is constant over each
of the sectors [ui, ui+1). In the next round (right ﬁgure), in order to ﬁnd xm+1, DC2 ﬁrst ﬁnds a diagonal
line (red line) which separates two half-circles (R+ and R−) that each has measure 1~2 w.r.t pm. The vector
xm+1 will then be one of the two points on the unit circle that are orthogonal to this line. For updating pm
to pm+1, we note that all the points inside R+ get the same factor (either 2ρ or 2(1 − ρ) depending on the
outcome of the query). The same is true for R−. Thus, pm+1 is again a piecewise constant pdf but now on
2(m + 1) sectors.

Agnostic Case: A common approach used in the agnostic setting is the empirical
risk minimization (ERM), which generates queries by independently sampling from
the marginal distribution of X, i.e., PX , and then selects a unit vector that minimizes
the number of errors made on these n queries. We follow a similar approach as in [15].
Suppose that we are given a query budget of n. We allocate n~3 queries to DC and let
h1 denote the unit vector selected by DC. Then we allocate n~3 queries to ERM and let
h2 denote the unit vector proposed by ERM using its n~3 queries. Consider the region
∆ that h1 and h2 disagree on, i.e., ∆ ={x ∈ Sd−1 ∶ h1(x) ≠ h2(x)}. Let P∆ be the
restriction of the probability measure PX on ∆. Here we sample the remaining n~3
queries from ∆ according to P∆. We write ˆR∆(hi) for the average number of errors
made by hi on the sampled n~3 queries. Finally, we set R∆(hi) = E[ ˆR∆(hi)]. The
ˆR∆(h) as the ﬁnal result.
algorithm will output ˆh = arg minh∈{h1,h2}
bility in expectation E[R(ˆh)] ≤ min{E[R(h1), E[R(h2)]} + 2 3

Theorem 5. Using the above procedure we have the following bounded error proba-
ne , where n is the

number of queries and e is the base of the natural logarithm.

Empirical Results

In this section, we extensively evaluate the performance of DC against the following
baselines:

• RANDOM-SAMPLING: Queries are generated by sampling uniformly at random
from the unit sphere Sd−1.
• UNCERTAINTY-SAMPLING: Queries are sampled uniformly at random from the

orthogonal complement of w, where w is the vector learned by linear SVM.

9

100

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

10-1

10-2

10-3

50

Random
Uncertainty
Bagging
Spectral
DC

100

150

Number of Queries

100

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

10-1

10-2

10-3

200

Random
Uncertainty
Bagging
Spectral
DC

100

150

200

250

300

Number of Queries

100

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

10-1

10-2

10-3

10-4

350

400

450

Random
Uncertainty
Bagging
Spectral
DC

200

400

600

Number of Queries

800

1000

(a) Noise-free (d = 25)

(b) Noise-free (d = 50)

(c) Noise-free (d = 100)

Random
Uncertainty
Bagging
Spectral
DC

102

100

10-2

10-4

i

 

e
m
T
n
o
i
t
u
c
e
x
E
e
v

 

i
t
a
l
e
R

10-6

10-8

d = 25

d = 50

Dimension

d = 100

(d) Execution time (noise-free)

Random
Uncertainty
Bagging
Repetitive
DC

102

100

10-2

i

 

e
m
T
n
o
i
t
u
c
e
x
E
e
v

 

l

i
t
a
e
R

10-4

10-6

Random
Uncertainty
Bagging
DC
Repetitive

700

800

100

200

300
Number of Queries

400

500

600

(e) Noisy (d = 25)

DC (noise = 0.01)
DC (noise = 0.1)
DC (noise = 0.2)
Rep. (noise = 0.01)
Rep. (noise = 0.1)
Rep. (noise = 0.2)

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

101

100

10-1

10-2

10-3

10-4

101

100

10-1

10-2

10-3

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

 

r
o
r
r
E
n
o
i
t
a
m

i
t
s
E

101

100

10-1

10-2

10-3

10-4

0.45

0.4

0.35

0.3

0.25

0.2

0.15

0.1

y
t
i
l
i

b
a
b
o
r
P
 
r
o
r
r
E

Random
Uncertainty
Bagging
DC
Repetitive

200

400

600

800 1000 1200 1400 1600 1800

Number of Queries

(f) Noisy (d = 50)

Random
Uncertainty
Bagging
DC

600

700

d = 25

Dimension

d = 50

10-4

0

2

4

6

Number of Queries

8

10
# 104

0.05

0

100

200

300

400

500

Number of Queries

(g) Execution time (noisy)

(h) Noisy (d = 1000)

(i) Agnostic (d = 25)

Figure 3: Figures 3a, 3b, and 3c show the estimation error as we increase the number
of queries, for d = 25, 50, 100, respectively. Fig. 3d shows the corresponding execution
times. Fig. 3e and 3f show the estimation error as we increase the number of queries for
d = 25, 50 and the noise level ρ = 0.1. The corresponding execution times are shown
in Fig. 3g. Fig. 3h presents the estimation error of DC and REPETITIVE-DC as we
increase the number of queries for d = 1000 and noise levels ρ = 0.01, 0.1, 0.2. Finally,
Fig. 3i demonstrates the error probability w.r.t. the number of queries in the agnostic
setting for d = 25.

• QUERY-BY-BAGGING: The bag size is set to 20 and 1000 queries are generated

at each iteration. The query with the largest disagreement is picked [1].

• SPECTRAL: The version space is approximated by the largest ellipsoid consistent
with all previous query-label pairs. Then, at each iteration a query is selected to
approximately halve the ellipsoid [2].

• REPETITIVE-DC: In the noisy setting, one easy way to apply DC is to query

each point R times and use the majority rule to determine its label.

Our metrics to compare different algorithms are: a) estimation error, b) query com-
plexity, and c) execution time. In particular, as we increase the number of queries we

10

measure the average estimation errors and execution times for all the baselines (with
90% conﬁdence intervals). By nature, in active learning via query synthesis, all data
points and queries are generated synthetically. For all the baselines, we used the fastest
available implementations in MATLAB.

Noise-free setting: Figures 3a, 3b and 3c (with dimension d = 25, 50, 100, respec-
tively) show that in terms of estimation error, DC outperforms all other baselines,
and signiﬁcantly outperforms RANDOM-SAMPLING, UNCERTAINTY-SAMPLING and
QUERY-BY-BAGGING. Note that the estimation errors are plotted in log-scales. In
terms of execution times, we see in Fig. 3d that DC runs three orders of magni-
tude faster than other baselines. Training an SVM at each iteration for RANDOM-
SAMPLING, UNCERTAINTY-SAMPLING and QUERY-BY-BAGGING comes with a huge
computational cost. Similarly, SPECTRAL requires solving a convex optimization prob-
lem at each iteration; thus its performance drastically deteriorates as the dimension
increases, which makes it infeasible for many practical problems.

Noisy setting: We set the noise level to ρ = 0.1 and compare the performance of DC
against RANDOM-SAMPLING, UNCERTAINTY-SAMPLING, QUERY-BY-BAGGING, and
REPETITIVE-DC (for R = 5). As mentioned in [2], and we have also observed in our
experiments, SPECTRAL does not work even for small amounts of noise as it incor-
rectly shrinks the version space and misses the true linear separator. We see again in
Figures 3e and 3f (for d = 25, 50) that DC signiﬁcantly outperforms all other meth-
ods in terms of estimation error as we increase the number of queries. Figure 3g
shows that DC still runs ∼100 times faster than RANDOM-SAMPLING, UNCERTAINTY-
SAMPLING, and QUERY-BY-BAGGING. Clearly, DC has a higher computational cost
than REPETITIVE-DC, as DC performs a Bayesian update after each query. Finally,
as we increase the dimension to d = 1000, RANDOM-SAMPLING, UNCERTAINTY-
SAMPLING, and QUERY-BY-BAGGING become signiﬁcantly slower. Hence, in Fig. 3h
we only show how the estimation error (for noise levels ρ = 0.01, 0.1, 0.2) decreases
for DC and REPETITIVE-DC with more queries.

Agnostic setting: We sample a set of size 1000 from the Von Mises–Fisher dis-
tribution (the analog of the normal distribution on Sd−1) and compute the empiri-
cal error . The noise level at each point is drawn independently from the truncated

normal N(0.1, 0.5) on [0, 0.5]. Fig. 3i shows the error probability of RANDOM-

SAMPLING, UNCERTAINTY-SAMPLING, QUERY-BY-BAGGING and AGNOSTIC-DC
(for d = 25). Both AGNOSTIC-DC and UNCERTAINTY-SAMPLING achieve an error
probability ∼0.1 after 700 queries. However, as shown by Theorem 5, AGNOSTIC-DC
has a strong theoretical guarantee which, by contrast, other baselines do not have.

11

References

[1] N. Abe and H. Mamitsuka. Query learning strategies using boosting and bagging.

In ICML, page 1. Morgan Kaufmann Pub, 1998.

[2] I. Alabdulmohsin, X. Gao, and X. Zhang. Efﬁcient active learning of halfspaces

via query synthesis. In AAAI 2015, 2015.

[3] D. Angluin. Queries and concept learning. Machine learning, 1988.

[4] M.-F. Balcan, A. Broder, and T. Zhang. Margin based active learning. In Learning

Theory, pages 35–50. Springer, 2007.

[5] D. A. Cohn, Z. Ghahramani, and M. I. Jordan. Active learning with statistical

models. JAIR, 1996.

[6] S. Dasgupta. Analysis of a greedy active learning strategy. Advances in neural

information processing systems, 17:337–344, 2005.

[7] Y. Freund, H. S. Seung, E. Shamir, and N. Tishby. Selective sampling using the

query by committee algorithm. Machine learning, 1997.

[8] D. Hakkani-Tur, G. Riccardi, and A. Gorin. Active learning for automatic speech

recognition. In ICASSP), volume 4, pages IV–3904. IEEE, 2002.

[9] S. Javdani, Y. Chen, A. Karbasi, A. Krause, J. A. Bagnell, and S. Srinivasa. Near

optimal bayesian active learning for decision making. AISTAT, 2014.

[10] A. Karbasi, S. Ioannidis, and L. Massoulie. Comparison-based learning with rank

nets. ICML, 2012.

[11] R. D. e. a. King. The automation of science. Science, 2009.

[12] D. D. Lewis and W. A. Gale. A sequential algorithm for training text classiﬁers. In
Proceedings of the 17th annual international ACM SIGIR conference on Research
and development in information retrieval, 1994.

[13] D. Lowd and C. Meek. Adversarial learning. In KDD, pages 641–647. ACM,

2005.

[14] B. Nelson, B. I. Rubinstein, L. Huang, A. D. Joseph, S. J. Lee, S. Rao, and J. Ty-

gar. Query strategies for evading convex-inducing classiﬁers. JMLR, 2012.

[15] R. Nowak. Noisy generalized binary search. Advances in neural information

processing systems, 21:1366–1374, 2009.

[16] S. Tong and E. Chang. Support vector machine active learning for image retrieval.
In Proceedings of the 9th ACM international conference on Multimedia, pages
107–118. ACM, 2001.

[17] S. Tong and D. Koller. Support vector machine active learning with applications

to text classiﬁcation. JMLR, 2:45–66, 2002.

12

Appendix A: Proof of Theorem 2

of DC2. As a result, if the probability of success for DC2 is at least 1 − δ, then by the

At each round of DC, the value of d is replaced by⌈ d
2⌉. It is thus not hard to verify
that DC runs in⌊log2 d⌋ rounds until d ≤ 2 and in total there are at most d − 1 usages
union bound the probability of success of DC is at least 1 −(d − 1)δ.
we run DC with an input being an orthonormal set{e1, e2, ⋯, ed} where ei, h∗ ∈ RK
orthogonal projection of h∗ into span{e1, e2, ⋯, ed}. More precisely, we deﬁne

for some K ≥ d. We prove that DC outputs a vector that is close to the (normalised)

For the last part of the theorem, we prove a more general statement: Assume that

(5)

h⊥ =

∑d

i=1⟨ei, h∗⟩ei
⟨ei, h∗⟩ei .

Then, DC runs in log2 d rounds, calls DC2 d − 1 times, and outputs with probability at

above, we can conclude that DC runs in log2 d times and uses DC2 d − 1 times. Also,
again by the union bound, with probability at least 1 − δd all the outputs of DC2 are a
close estimate (within distance ǫ) of their corresponding objective. Thus, by assuming
that all the calls of DC2 have been successful (which happens w.p. at least 1 − δd), we

least 1 − δd a vector ˆh for whichh⊥ − ˆh < 6ǫd. In exactly similar way as discussed
use an inductive argument to prove thath⊥ − ˆh < 6ǫd. We use induction on d. For

d = 2 the result is clear. We now prove the result when d = k assuming that it holds
for all d < k. For simplicity, we assume that k is an even number, i.e, k = 2t (the proof
follows very similarly for k being odd). We can then write

ˆcjh⊥j ,

(6)

h⊥ =

=

ciei =

d
t
Q
Q
i=1
j=1
c2j−1ej+c2j e2j
c2
2j−1+c2

2j

+ c2

2j−1

2j and h⊥j

where ˆcj =c2
cisely the (normalised) orthogonal projection of h∗ (and also h⊥) onto span{e2j−1, e2j}.
by the output of DC2(e2j−1, e2j, ǫ, δ) which we denote by ˆej. Let us now deﬁne the

As we explained in Section , in the ﬁrst round of DC each vector h⊥j will be replaced

c2j−1ej+c2j e2j
c2
2j−1+c2

. Note that h⊥j

vector ˆh⊥ as

is pre-

=

2j

It is easy to verify that  h⊥1   = 1 as{ˆe1, ˆe2, ⋯, ˆet} is an orthonormal set. By the

assumption of the induction, the ﬁnal output of DC, which we denote by ˆh⊥, will
be within the distance 6ǫt of ˆh⊥. That is,

h⊥1

=

∑t

j=1⟨h⊥, ˆej⟩ˆej
∑t
j=1⟨h⊥, ˆej⟩2

  h⊥1
− ˆh⊥   < 6ǫt.
  h⊥ − h⊥1   < 6ǫt.

13

We now prove that

(7)

(8)

From (7) and (8) the induction hypothesis will be immediate as we can write

It thus remains to prove (8).

Firstly, we deﬁne β ≜∑t

  h⊥ − ˆh⊥   ≤  h⊥ − h⊥1   +  h⊥1

− ˆh⊥   < 6ǫt + 6ǫt = 6ǫd.

β

β

β

∑t

j=1⟨h⊥, ˆej⟩2. We have
j=1⟨h⊥, ˆej⟩ˆej
  h⊥ − h⊥1   =   h⊥ −
  
j=1⟨h⊥, ˆej⟩ˆej
=    βh⊥ − ∑t
  
=   (β − 1)h⊥ + h⊥ − ∑t
j=1⟨h⊥, ˆej⟩ˆej
j=1⟨h⊥, ˆej⟩ˆej
β   +   h⊥ − ∑t
  .
≤   1 − β
j=1⟨h⊥, ˆej⟩2 −⟨h⊥, h⊥j⟩2 
j=1 ⟨h⊥, ˆej⟩ −⟨h⊥, h⊥j⟩  ⟨h⊥, ˆej⟩ +⟨h⊥, h⊥j⟩ 
j=1  h⊥   ⋅  ˆej − h⊥j   ⋅(  h⊥   ⋅  ˆej   +  h⊥   ⋅  h⊥j  )

≤ 2ǫt,

t
Q

t
Q

  

β

≤

≤

Secondly, we have

 β2 − 1  =   t

Q

β ∈[√1 − 2ǫt,√1 + 2ǫt],
1√1 − 2ǫt
  1 − β
β   ≤ max{
j=1⟨h⊥, ˆej⟩ˆej   =   t
  h⊥ −
j=1⟨h⊥, h⊥j⟩h⊥j

− 1, 1 −

t
Q

Q

1√1 + 2ǫt} ≤ 2ǫt.
−⟨h⊥, ˆej⟩ˆej   ≤ 2ǫt.

Fourthly, similar as above we can show that

Now, by plugging (10), (11) and (12) into (9) we get (8).

(9)

(10)

(11)

(12)

where the last step follows from  h⊥   =  h⊥j   =  ˆej   = 1 and  ˆej − h⊥j   ≤ ǫ. Hence, by

noting the fact that 2ǫt = ǫd ≤ 1

6 we obtain

and

14

Appendix B: Proof of Theorem 4

quence. At the m-th round of DC2, if ζm = 1 (which takes place with independent

Let{ζn, n ≥ 1} be a sequence of independent and identically distributed (iid) Bernoulli(ρ)
random variables. Denote by(F , Ω, Pr) the probability space generated by this se-
probability ρ) then we observe a ﬂipped version of sign⟨xm, h∗⟩. Also, if ζm = 0 we
observe the correct version of sign⟨xm, h∗⟩.
Consider a query of the form sign⟨x, h∗⟩. This query divides the unit circle into
two parts (half-circles) depending on the sign of⟨x, h∗⟩ (see Figure 4). The two parts
are: (i) Preferred part: all h such that sign⟨x, h⟩ = sign⟨x, h⊥⟩, and (ii) Unpreferred
part: all h such that sign⟨x, h⟩ = − sign⟨x, h⊥⟩. The two parts can be separated by a

line ℓx that passes through the origin. We refer to Figure 4 for a schematic explanation.

the preferred part of the query. Otherwise, we say that the query does not prefer z.

Figure 4: For any point z above the line ℓx we have⟨z, h⊥⟩ = ⟨x, h⊥⟩. Once we
perform the query⟨x, h⊥⟩, it is more likely that the (noisy) response is indeed the true
value⟨x, h⊥⟩. Therefore, the region above the line ℓx is in general preferred by the
query. In the ﬁgure, the sector(y, z) is cut by the line ℓx and the sector(z, x) is not.
Also,(z, x) lies in the preferred part of the query⟨x, h⊥⟩.
In this setting, we say that the query sign⟨x, h∗⟩ prefers a point z if z belongs to
Also, we frequently use the line ℓx rather than the query sign⟨x, h∗⟩ when it causes no
ambiguity. Finally, for a region A on the unit circle say that the query sign⟨x, h∗⟩ cuts
deﬁne the distance d(x, y) to be the length of the (smaller) sector between them (see
Figure 4). Clearly, we have d(x, y) ≥x − y2.
At round m of DC2 a vector xm is chosen and the (noisy) outcome of sign⟨xm, h∗⟩
unpreferred parts have equal measures under pm−1, i.e., pm−1(Fxm) = pm−1(Uxm) =
we conduct the query sign⟨xm, h∗⟩. As the result of the query is noisy, we have two

the region A if and only if the line ℓx passes through region A. Otherwise, we say that
the query does not cut A. If ℓx does not cut A, then ℓx prefers A if A is in the preferred
part and does not prefer A otherwise (see Figure 4). Finally, for two points x, y we

2 . Let us see what happens to pm (the posterior belief about h⊥ at round m) after

is observed. As explained in Section ??, xm is chosen in a way that the preferred and

1

15

follows

pm is updated as follows

if h ∈ Fxm,
if h ∈ Uxm.

different update rules depending on each of the following cases: (i) ζm = 0, i.e., we

observe the correct value sign⟨xm, h∗⟩. In this case, the measure pm is updated as
(ii) ζm = 1, i.e., we observe the ﬂipped value − sign⟨xm, h∗⟩. In this case, the measure

pm+1(h) =⎧⎪⎪⎨⎪⎪⎩
2(1 − ρ)pm(h)
(2ρ)pm(h)
pm+1(h) =⎧⎪⎪⎨⎪⎪⎩(2ρ)pm(h)
2(1 − ρ)pm(h)
Pr∃y ∈ S1 ∶ d(y, h⊥) > ρ and pTǫ,δ(y) ≥ pTǫ,δ(h⊥)(cid:6) < δ.

Clearly, the result of the theorem follows from (13). For better illustration, we assume

Consider the number Tǫ,δ given in (4). Our goal is to show that

w.l.o.g that h⊥ =(0, 1). Consider a point y on the right-hand side of the unit circle
2 . Also, Consider points z0, zK such that d(z0, h⊥) = ǫ~4 and
such that d(y, h⊥) > ǫ
d(h⊥, zK) = ǫ~2. We now divide the sector starting with z0 and ending with zK into
K ∶= Tǫ,δ + 1 pints. That is, for i = 1, 2, ⋯, K we denote by zi the point that d(h⊥, zi) =
(see Figure 5). Also, for i ≥ 1, we let the sector starting with zi−1 and

if h ∈ Fxm,
if h ∈ Uxm.

(13)

+ i

ǫ
4

ǫ

4(Tǫ,δ+1)

Figure 5: Different regions for the proof of Theorem 4.

ǫ

ǫ

8π⋅(Tǫ,δ +1)

(as Ai  =

ending with zi be denoted by Ai. Note that in the very beginning of the algorithm

DC2 has in total Tǫ,δ rounds and in each round m it conducts a query with an

when we have uniform measure on the unit circle, each of the regions Ai has p0(Ai) =
associated line ℓxm. We let M ∶=⌈
log 4(ρ(1−ρ))⌉ and consider the following events:

• E1: There is at least M lines which separate zK from h⊥ or equivalently, there

4(Tǫ,δ +1)

2 log 2
δ

).

is at least M lines that cut the region(h⊥, zK).

• E2,j (1 ≤ j ≤ K): The region Aj is not cut by any of the lines ℓ1, ℓ2, . . . , ℓTǫ,δ .

16

1

(14)

∩ E2,j] .

2 and pTǫ,δ(y) ≥ pTǫ,δ(h⊥).

pigeon-hole principle there is always a region Aj that is not cut by any of the lines. We
can write:

Tǫ,δ +1
Q
j=1
Now using Lemma 6 (stated below), we have

• E3: ∃y such that d(y, h⊥) > ρ
j=1 E2,j(cid:6) = 1 as we have Tǫ,δ queries and hence by the
It is easy to see that Pr⋃K
Pr[E3]
= Pr[E3 ∩ E1] + Pr[E3 ∩ Ec
1]
Pr[E3 ∩ Ec
≤ Pr[E3  E1] +
Pr[E3  E1] ≤ Pr[E3  E1] ≤(4ρ(1 − ρ)) M
∩ E2,j] ≤ Pr[E2,j ∩ Ec
1] ,
1] ≤(M − 1)(θ1 + θ2),
1] ≤(Tǫ,δ + 1)M(θ1 + θ2),

Let us now bound Pr[E3 ∩ Ec
and using the fact that E2,j  =

Pr[E3 ∩ Ec
Pr[E2,j ∩ Ec
Pr[E2,j ∩ Ec

where θ1 and θ2 are given in Lemma 7 with m← Tρ,δ and k← M . Now, we show that
the above expression is upper bounded by δ~2, and hence by using relations (14) and

(15), we get the proof of the main theorem.

The value of T0 is chosen in such a way that we have

∩ E2,j] . We have

we obtain from Lemma 7 that

Tǫ,δ +1
Q
j=1

4(Tǫ,δ +1)

and thus

(16)

(15)

2 ≤

δ
2

.

1

1

ρ

.

.

4

4

log(2(1 − ρ))
log(2(1 − ρ))
log(1 − 2ρ)
log(2(1 − ρ))

2ρ log 1−ρ
ρ

2

.

2⎫⎪⎪⎪⎬⎪⎪⎪⎭
⎞⎠

(17)

(18)

(19)

(20)

≤

δ
4

.

Now, by plugging in (17)-(20) into the values of θ1 and θ2 in (16) we conclude that the
right side of (16) is bounded by δ
2 .

T1 ensures that

T2 and ensures that

Finally, T3 ensures that

2 log(Tǫ,δ + 1)

Tǫ,δ − M

≤

2

Tǫ,δ − M

log

8π
ǫ

≤

2M

Tǫ,δ − M

log(2ρ) ≤
⎛⎝

T − M

6

−ρ

17

(Tǫ,δ + 1)M exp⎧⎪⎪⎪⎨⎪⎪⎪⎩

We have for β > 0 that

Lemma 6. Let x1, x2, ⋯, xm be the vectors chosen by DC2 up to round m with Fxi

and Uxi being their associated preferred and unpreferred parts (i.e. pi−1(Fxi) =
pi−1(Uxi) = 1~2). Consider two points h1, h2 such that h1 ∈ ∩m
i=1Uxi.
Pr[pm(x) < pm(y)] ≤(4ρ(1 − ρ))m .
Proof. For i ∈[m], deﬁne the random variable Zi as Zi ≜ log pi(x)
(1 − 2ζi) log 1−ρ

. Using the update
rules of pi that we explained above, it is easy to see that for i ≥ 1: Zi = Zi−1 +
ρ . Also, as p0 is uniform over S1 we have Z0 = 0. We thus have

i=1Fxi and h2 ∈ ∩m

ρ . Hence,

Zm = ∑m

pi(y)

i=1(1 − 2ζi) log 1−ρ

ρ

1 − ρ

m
Q

Pr[Zm ≤ 0]
= Prlog
i=1(1 − 2ζi) ≤ 0
= Pr m
2
≤ (4ρ(1 − ρ)) m

Q
i=1

ζi ≥

2 ,

1

where the last step follows directly from the so called Chernoff bound.

We note that the vector h⊥ is always a member of the preferred part of any test. As

a result, at any round of DC2 we have that h⊥ ∈ ∩m
Lemma 7. Consider a region A on the unit circle which does not contain h⊥. As-
sume we are at round m of DC2 where a sequence of queries with associated lines
ℓx1 , ℓx2 , . . . , ℓxm have been conducted. We deﬁne events E1 and E2 as

i=1Fxi.

• E1 ≜ None of the lines ℓxi cuts A;

• E2 ≜ At most k of the lines do not prefer A,

where k is an an integer. We have

where

and

6

m−k log 2π

Pr[E1 ∩ E2] ≤ k(θ1 + θ2),
 A )
log(2(1 − ρ)) − 2
⎛⎝
ρ log( 1−ρ
ρ )
log(2(1 − ρ)) + 2k
m−k log(2ρ)
⎛⎝
ρ log( 1−ρ
ρ )

6

,

.

2⎫⎪⎪⎪⎬⎪⎪⎪⎭
⎞⎠
2⎫⎪⎪⎪⎬⎪⎪⎪⎭
⎞⎠

m − k

−ρ

m − k

−ρ

θ1 = exp⎧⎪⎪⎪⎨⎪⎪⎪⎩
θ2 = exp⎧⎪⎪⎪⎨⎪⎪⎪⎩

18

Proof. We have

where we deﬁne

Pr[E1 ∩ E2] ≤ Pr[E2  E1] ≤

k
Q
j=1

Pr[E2,j  E1] ,

(21)

E2,j ≜ Exactly j lines do not prefer A.

conduct the i-th query and condition on event E1 (i.e. given that none of the lines cut

that the line ℓxi does not cut A, Zi has different update rules depending on the two
cases whether the line ℓxi prefers A or does not prefer A. (i) ﬁrst case: if the line ℓxi

We will now calculate Pr[E2,j  E1] . In the beginning, p0 puts a uniform measure on
A and hence p0(A) =  A 2π . Let us ﬁrst investigate the dynamics of pi−1(A) when we
A). In this setting, we deﬁne the random variables Zi = log pi(A). At time i, assuming
prefers A, then we know that either with probability 1 − ρ (if ζi = 0) we have pi(A) =
2(1−ρ)pi−1(A) and with probability ρ (if ζi = 1) we have pi(A) =(2ρ)pi−1(A). Thus,
we can write Zi = Zi−1 + Fi, where Fi ≜ ζi log(2ρ) +(1 − ζi) log(2(1 − ρ)). (ii) second
where Ui ≜ ζi log(2(1 − ρ)) +(1 − ζi) log(2ρ). Now, in order to ﬁnd an upper bound
on Pr[E2,j  E1], we assume without loss of generality that in the ﬁrst m − j rounds

we the lines are as in the ﬁrst case and in the last j rounds the lines are as in the second
case (note that any other given order of the lines is statistically equivalent to this simple
order that we consider).

case: if ℓxi does not prefer A, then using a similar argument we obtain Zi = Zi−1 + Ui,

Zm = Z0 +

m−j
Q
i=1

+

Fi +

m
Q

i=m−j+1
Fi +

Ui

m
Q

Ui.

Fi +

m
Q

i=m−j+1

m−j
Q
i=1

m−j
Q
i=1

= log2 A 2π
Pr[E2,j  E1]
≤ Pr⎡⎢⎢⎢⎣log2 p0(A) +
= Pr⎡⎢⎢⎢⎣
α1 = Pr⎡⎢⎢⎢⎢⎣
α2 = Pr⎡⎢⎢⎢⎢⎢⎣

Now, noting that pm(A) ≤ 1 and hence log pm(A) ≤ 0, we obtain
Ui ≤ 0⎤⎥⎥⎥⎦
 A ⎤⎥⎥⎥⎦
A⎤⎥⎥⎥⎥⎦
Ui ≤ 0⎤⎥⎥⎥⎥⎥⎦

m−j
Q
i=1+

Let us now deﬁne

i=m−j+1
2π

m−j
Q
i=1

i=m−j+1

2π

Fi ≤ log

Fi +

m
Q

Fi +

m
Q

i=m−j+1

m−j

2

Q
i=1

Ui ≤ log2

and

m−j

2

19

Using the union bound, we have

Now, to bound α1 we obtain after some simpliﬁcations that

Pr[E2,j  E1] ≤ α1 + α2.

and by using the Chernoff bound we get

To bound α2 we can similarly write after some simple steps that

(22)

(23)

(24)

2

m−j

Q
i=1

α1 = Pr⎡⎢⎢⎢⎢⎣
α1 ≤ exp⎧⎪⎪⎪⎨⎪⎪⎪⎩
α2 ≤ Pr⎡⎢⎢⎢⎢⎢⎣
α2 ≤ exp⎧⎪⎪⎪⎨⎪⎪⎪⎩

m−j
Q
i=1+

m−j

2

ζi ≥ ρ ×

m − j

2

×

log(2(1 − ρ)) − 2

ρ log 1−ρ
ρ

m−j log 2π
 A 

−ρ

m − j

6

m − j

ζi ≥ ρ ×

m−j log 2π

⎛⎝

log(2(1 − ρ)) − 2
ρ log( 1−ρ
ρ )
log(2(1 − ρ)) + 2j

ρ log 1−ρ
ρ

2

,

⎤⎥⎥⎥⎥⎦

 A )

2⎫⎪⎪⎪⎬⎪⎪⎪⎭
⎞⎠
m−j log(2ρ)
2⎫⎪⎪⎪⎬⎪⎪⎪⎭
⎞⎠

.

⎤⎥⎥⎥⎥⎥⎦

.

,

and using the Chernoff bound we get

m − j

−ρ

6 ⎛⎝

log(2(1 − ρ)) + 2j
m−j log(2ρ)
ρ )
ρ log( 1−ρ

We further note that both of the upper bounds on α1 and α2 decrease when we increase
j. Hence, the proof of the theorem follows by letting j = k in (23) and (24), and also
plugging these bounds into (21).

Appendix C: Proof of Theorem 5

nγ2

Pr[ ˆδ − δ  ≥ γ] ≤ 2 exp−

First of all, we consider Pr[R(ˆh) > min{R(h1), R(h2)}]. Let δ ≜ R∆(h1) − R∆(h2)
and ˆδ ≜ ˆR∆(h1) − ˆR∆(h2). By Hoeffding’s inequality, we have
6  .
If δ > 0, then letting γ = δ yields that Pr[ˆδ < 0] ≤ 2 exp(−nδ2~6). Therefore
Pr[ ˆR∆(h1) < ˆR∆(h2)] ≤ 2 exp(−nδ2~6). Since we know that R∆(h1) > R∆(h2)
(δ > 0), we have R(h1) > R(h2) because h1 and h2 agree on the complement of
∆. Thus R(ˆh) > min{R(h1), R(h2)} with probability at most 2 exp(−nδ2~6). Sim-
ilarly if δ < 0, then we have Pr[ˆδ > 0] ≤ 2 exp(−nδ2~6). Therefore Pr[ ˆR∆(h1) >
ˆR∆(h2)] ≤ 2 exp(−nδ2~6). Since R(h1) < R(h2), hence R(ˆh) > min{R(h1), R(h2)}

20

with probability at most 2 exp(−nδ2~6). In sum, we have R(ˆh) > min{R(h1), R(h2)}
with probability at most 2 exp(−n R∆(h1) − R∆(h2) 2~6).
Let δn denote 2 exp(−n R∆(h1) − R∆(h2) 2~6). Now we want to bound E[R(ˆh) 
h1, h2]. We have

where the last inequality holds because R(h1) − R(h2)  ≤ R∆(h1) − R∆(h2) .
When u =3~n, the function f(u) = 2ue−nu2~6 achieves its maximum 2 3

Thus we obtain that

ne .

.

E[R(ˆh)  h1, h2]
≤ (1 − δn) min{R(h1), R(h2)} + δn max{R(h1), R(h2)}
= min{R(h1), R(h2)} + δn R(h1) − R(h2) 
= min{R(h1), R(h2)} + 2 R(h1) − R(h2) 
exp(−n R∆(h1) − R∆(h2) 2~6
≤ min{R(h1), R(h2)} + 2 R(h1) − R(h2) 
exp(−n R(h1) − R(h2) 2~6,
E[R(ˆh)  h1, h2] ≤ min{R(h1), R(h2)} + 2 3
E[R(ˆh)] ≤ E[min{R(h1), R(h2)] + 2 3
≤ min{E[R(h1), E[R(h2)]} + 2 3

ne

ne

.

ne

By Jensen’s inequality, we conclude that

21

