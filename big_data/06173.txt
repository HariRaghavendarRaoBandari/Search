The Two-Modular Fourier Transform

of Binary Functions

Yi Hong, Senior Member, IEEE, Emanuele Viterbo, Fellow, IEEE, and Jean-Claude Belﬁore, Member, IEEE

1

6
1
0
2

 
r
a

M
 
0
3

 
 
]
T
I
.
s
c
[
 
 

2
v
3
7
1
6
0

.

3
0
6
1
:
v
i
X
r
a

Abstract—In this paper, we provide a solution to the open
problem of computing the Fourier transform of a binary function
deﬁned over n-bit vectors taking m-bit vector values. In partic-
ular, we introduce the two-modular Fourier transform (TMFT)
of a binary function f : G → R, where G = (Fn
2 , +) is the
group of n bit vectors with bitwise modulo two addition +,
and R is a ﬁnite commutative ring of characteristic 2. Using
the speciﬁc group structure of G and a sequence of nested
subgroups of G, we deﬁne the fast TMFT and its inverse. Since
the image R of the binary functions is a ring, we can deﬁne the
convolution between two functions f : G → R. We then provide
the TMFT properties, including the convolution theorem, which
can be used to efﬁciently compute convolutions. Finally, we derive
the complexity of the fast TMFT and the inverse fast TMFT.

Index Terms—Two-modular Fourier transform, binary func-

tions, binary groups, group ring

I. INTRODUCTION

tool

The Fourier transform is a fundamental

in signal
processing for spectral analysis and is often used to transform
a convolution between two real- or complex-valued functions
into the product of the respective transforms. In discrete-
time signal processing, numerical evaluation of the Fourier
transform is based on the fast-Fourier transform (FFT), which
enables to efﬁciently compute convolutions [1].

More generally, the Fourier transforms of functions over
ﬁnite Abelian groups f : G → C (complex ﬁeld) or f : G → Z
(ring of integers) have been extensively studied [5]. For com-
plex valued functions, when the group G is cyclic, the Fourier
transform is the well-known discrete Fourier transform [5]. For
complex valued functions, and when G is the additive group
of Fn
2 , where F2 is the binary ﬁeld, the Fourier transform is
provided by the well known Hadamard transform, commonly
used for analyzing Boolean functions [4]. In computer science,
harmonic analysis of Boolean functions is a powerful tool,
which is used in the theory of computational complexity (cf.
the PCP Theorem in [3, Chap. 22]).

The Fourier transform of f : G → C, when G is ﬁnite and
non-Abelian, is based on the complex matrix representations of
the non-Abelian group [5]. This Fourier transform satisﬁes the
convolution theorem, which converts time-domain convolu-

Yi Hong and Emanuele Viterbo are with the Department of Electrical
and Computer Systems Engineering, Faculty of Engineering, Monash Uni-
versity, VIC 3800, e-mail: {yi.hong, emanuele.viterbo}@monash.edu. Jean-
Claude Belﬁore is with Communications and Electronics Dept., Telecom
ParisTech, Paris, France, email:
jean-claude.belﬁore@telecom-paristech.fr.
This paper was presented in part in the IEEE Information Theory workshop,
April 2015, Jerusalem, Israel.

This work is supported by the Australian Research Council Discovery

Project with ARC DP160101077.

tions between functions into the product of the corresponding
transforms.

The concept of Fourier transform was also extended to
functions f : G → K deﬁned over ﬁnite group G taking values
in a ﬁnite ﬁeld K, except for the case where the characteristic
of the ﬁeld divides the order of the group. In general, for
f : G → R, where G is an arbitrary group and R is a ring of
prime characteristic p co-prime with the order of G, its Fourier
transform is called the p-modular Fourier transform, which is
similar to that of f : G → C, when G is non-Abelian, but
uses ﬁnite ﬁeld matrix representations of G [5].

An application of the p-modular Fourier transform, when G
is Abelian, enables to describe Reed-Solomon codes and their
decoding algorithms by a frequency domain interpretation [2].
In Reed-Solomon codes, R is the ﬁnite ﬁeld F2n and the
Abelian group G is the cyclic multiplicative group of F2n.
In this case, the order of G is 2n − 1, which is not divisible
by the characteristic 2 of the ﬁeld. However, when the order of
the group is divisible by the characteristic p, and especially in
the case of p = 2 and |G| = 2n (the order of G), the Fourier
transform has never been deﬁned before.

In this paper, we provide a solution to this problem by
introducing the two-modular Fourier transform (TMFT) of a
2 , +) is the group
binary function f : G → R, where G = (Fn
of n bit vectors with bitwise modulo two addition + and R
is a ﬁnite commutative ring of characteristic 2. Furthermore,
using the speciﬁc group structure of G and a sequence of
nested subgroups, we introduce the fast TMFT and its inverse
TMFT (ITMFT).

The TMFT is based on the two-modular two-dimensional
representations of the additive group of F2 and deﬁnes n + 1
“spectral components” as matrices over “0” and “1” in R of
size 2k×2k, for k = 0 . . . , n. To develop ITMFT, we introduce
a new operator which extracts the top right corner element of
these matrices, since the trace operator used in the traditional
Fourier transform is not valid when the characteristic of the
ring R, p = 2, divides the order of the group |G| = 2n.

When the ring R = F2 = {0, 1}, the Hadamard transform
for f : G → C can be used for faster convolution computa-
tions, since we can map F2 to {+1, −1} ⊂ C by y = 2x − 1.
However, if there is no such map from R to C then the
traditional Fourier transform for f : G → C cannot be used
for computing convolutions of f : G → R functions. With
our TMFT, we can provide the convolution theorem, since the
TMFT preserves the multiplicative structure of the ring R, and
enables efﬁcient computations of multiplications in the group
ring R[G] [10] of functions f : G → R. Finally, we discuss
the implementation and complexity of the fast TMFT and its

inverse.

We expect the TMFT to have broad applications to problems
in coding theory and computer science, for example, in reliable
computation of binary functions, network coding, cryptogra-
phy, and classiﬁcation of binary functions [11].

The rest of this paper is organized as follows. Section II
reviews the classical concept of Fourier transforms of func-
tions deﬁned over additive groups taking values in complex
or ﬁnite ﬁelds. In Section III, we present TMFT and fast
TMFT of a binary function f : G → R deﬁned over a
ﬁnite commutative ring R of characteristic 2. In Section IV
we present the corresponding ITMFTs, and in Section V, we
prove the convolution theorem. In Section VI, we discuss the
implementation aspects and complexity of the proposed TMFT
and ITMFT.

II. BACKGROUND

In this section, we review the classical concept of Fourier
transforms of functions deﬁned over additive groups taking
values in complex or ﬁnite ﬁelds. We highlight the essential
mathematical ideas that are later used to deﬁne the TMFT. In
the following we assume the reader is familiar with the basic
notions of group, subgroup, quotient group, homomorphism,
the fundamental homomorphism theorem, ring, and ﬁeld [8].

A. Algebraic view of the discrete Fourier transform

The discrete Fourier transform (DFT) is deﬁned for N sam-
ples of a real (or complex) discrete time function f : ZN → C,
where ZN = {0, 1, . . . , N − 1} is the time axis. We can
think of f as discrete-time periodic function by N samples.
The DFT provides the well known discrete spectrum of such
function. We observe that the time axis ZN has an additive
group structure given by G , (ZN , +) with addition mod
N . Hence we can think of f : G → C as a complex valued
function over the Abelian group G.

Let the vector f = (f [n])N −1

n=0 contain the N values of the
time-domain function f : G → C. Then the DFT of f is given
by the frequency-domain vector ˆf = ( ˆf [k])N −1

k=0 , where

ˆf [k] =

f [n]e−2π nk
N ,

k = 0, . . . , N − 1,

(1)

N −1Xn=0

represents the transform of f as a function ˆf : G → C. The
corresponding frequency index k also ranges in ZN and the
frequency axis has the same group structure as G. The inverse
discrete Fourier transform (IDFT) of ˆf is given by

f [n] =

1
N

N −1Xk=0

ˆf [k]e2π nk
N ,

k = 0, . . . , N − 1.

(2)

The well known DFT matrix F = {e−2π nk

N }N −1

n,k=0 is a

unitary matrix such that

ˆf T = Ff T

and

f T =

FHˆf T

1
N

(3)

2

two ‘descriptions’ of the signal f [n] in different coordinate
systems, namely the time basis and the frequency basis.

We show how the group structure of the time axis can
provide more insight into the DFT operation by using the
notions of group representations and characters (see Appendix
A for a brief review).

For the cyclic group G = (ZN , +), the scalar representation
ρk is the homomorphism from G to the unit circle in the
complex plane S = {z ∈ C : |z| = 1}, given by

ρk : G → Sk ⊂ S

ρk(n) , e−2π nk

N

for k = 0, . . . , N − 1, and the image of ρk is the set of distinct
points on the unit circle

Sk , Im(ρk) =n1, e−2π k

N , e−2π 2k

N , · · · , e−2π (N −1)k

N o .

The representation ρk is a group homomorphism transform-
ing G into the group of complex roots of unity Sk, i.e., for
any g1, g2 ∈ G

ρk(g1 + g2) = ρk(g1)ρk(g2)

since

e−2π (g1 +g2)k

N

= e−2π g1 k

N e−2π g2 k
N .

We now illustrate the relation between the DFT and the
representation of a cyclic group using the example below with
G = (Z6, +).

Example 1: Using Deﬁnition A.2 (see Appendix A) in
the scalar case, Table I illustrates all the inequivalent scalar
representations ρk : G → Sk for k = 0, . . . , 5. Some
representations are faithful (e.g., ρ1 and ρ5), the others are
not. According to the fundamental homomorphism theorem
of groups [8, Th. 1.5.6],
the image Sk is isomorphic to
the quotient group G/Ker(ρk), where Ker(ρk) is a normal
subgroup of G.
(cid:3)

We can formally rewrite the DFT in (1) as

ˆf [k] =Xg∈G

f [g]ρk(g)

k = 0, . . . , N − 1

(4)

Let (·)∗ denote complex conjugation. Then we observe that the
pairwise orthogonal complex vectors ψk = [ρ∗
k(g)]g∈G, form
the discrete Fourier basis vectors in CN (i.e., the columns
of the DFT matrix F in (3)). This is shown in Table II for
G = (Z6, +). The formal DFT in (4) can also be interpreted
as the complex scalar product

ˆf [k] = hf , ψki

k = 0, . . . , N − 1

(5)

which gives the projection of the time domain vector f along
the Fourier basis vector ψk.

We now discuss how the fast Fourier transform (FFT)
naturally stems from the group structure of G = (ZN , +).
From the fundamental homomorphism theorem [8, Th. 1.5.6],
since Ker(ρk) is a subgroup of G, the direct product of Ker(ρk)
and G/Ker(ρk) is isomorphic to G, i.e.,

where (·)T and (·)H denote transposition and Hermitian
transposition of a matrix, respectively. The vectors f and ˆf are

G = {g = u + v|u ∈ Ker(ρk), v ∈ G/Ker(ρk)}

∼= Ker(ρk) × G/Ker(ρk),

(6)

TABLE I

DFT EXAMPLE WITH G = (Z6, +).

Sk = Im(ρk) = {ρk(g), g ∈ G = {0, 1, 2, 3, 4, 5}}

Ker(ρk), G/Ker(ρk)

3

0

0

0

0

0

0

5

1

1

5

3

3

3

4

2

4

2

2

4

2

4

{1}

{0, 1, 2, 3, 4, 5}, {0}

{1, e− 2π

6 , e− 4π

6 , e− 6π

6 , e− 8π

6 , e− 10π

6 }

{1, e− 4π

6 , e− 8π

6 }

{0}, {0, 1, 2, 3, 4, 5}

{0, 3}, {0, 2, 4}

{1, −1}

{0, 2, 4}, {0, 3}

{1, e 4π

6 , e 8π

6 }

{1, e 2π

6 , e 4π

6 , e 6π

6 , e 8π

6 , e 10π

6 }

{0, 3}, {0, 2, 4}

{0}, {0, 1, 2, 3, 4, 5}

k

0

1

2

3

4

5

FOURIER BASIS VECTORS DFT EXAMPLE WITH G = (Z6, +).

TABLE II

1
1

2
1

6

e+ 2π
e+ 4π
6
−1
e− 4π
e− 2π

6

6

6

e+ 4π
e+ 8π

6

1

6

e− 8π
e− 4π

6

3
1

e+ 6π

6

1
−1
1

e− 6π

6

4
1

5
1

6

e+ 8π
e+ 4π

6

1

6

e− 4π
e− 8π

6

6

e+ 10π
e+ 8π
6
−1
e− 8π
e− 10π

6

6

ψ0
ψ1
ψ2
ψ3
ψ4
ψ5

g ∈ G
ρ∗
0(g)
ρ∗
1(g)
ρ∗
2(g)
ρ∗
3(g)
ρ∗
4(g)
ρ∗
5(g)

0
1
1
1
1
1
1

and

ρk(u) = ρk(0) = 1 ∈ Sk

for all u ∈ Ker(ρk) .

(7)

Then we can compute the DFT more efﬁciently as

ˆf [k] = Xg∈G

f [g]ρk(g)

= Xv∈G/Ker(ρk) Xu∈Ker(ρk)
 Xu∈Ker(ρk)
= Xv∈G/Ker(ρk)
 Xu∈Ker(ρk)
= Xv∈G/Ker(ρk)

f [u + v]ρk(u + v)

f [u + v]ρk(u) ρk(v)
f [u + v] ρk(v)

(8)

for k = 0, . . . , N − 1. The last equality in (8) is due to
(7). From (8), we observe how the number of multiplications
reduces from |G|2 = N 2 to

|G/Ker(ρk)| .

Xk

In the above example, the number of multiplications reduces
from 36 to 21. Note that by taking advantage of the Hermitian
symmetry of the DFT matrix F, the number of multiplications
can be further reduced to 12.

B. Fourier Transform of f : G → C for arbitrary G

The classical notion of Fourier transform over arbitrary
ﬁnite groups is based on the n-dimensional representations
of group elements by complex n × n matrices in GL(n, C)
(see Appendix A). It generalizes the well known discrete
Fourier transform, which is naturally deﬁned over a cyclic
group (additive Abelian group). In the general case where G
is non-Abelian, the group element representations are matrices
and we have

Deﬁnition 1: ([5]) Given a ﬁnite group G,

the Fourier
transform of a function f : G → C evaluated for a given
representation ρ : G → GL(dρ, C) of G, of dimension dρ, is
given by the dρ × dρ matrix

ˆf (ρ) =Xg∈G

f (g)ρ(g).

The complete Fourier transform is obtained by considering
all the ρ’s in the set {ρk} of all inequivalent irreducible
representations of G (see Appendix A).
(cid:3)
Deﬁnition 2: ([5]) The inverse Fourier transform evaluated

at g ∈ G is given by

f (g) =

1

|G|Xk

dρk Tr(cid:16)ρk(g−1) ˆf (ρk)(cid:17)

(9)

where |G| is the order of the group G.

(cid:3)
Note that Deﬁnitions 1 and 2 generalize the DFT/IDFT for
the Abelian group G = (ZN , +). The above Fourier transform
is well deﬁned for complex valued functions over ﬁnite groups
G and can be used to transform convolution in the ‘time-
domain’ deﬁned as1 ([5])

(f1 ∗ f2)(g) = Xh∈G

f1(h−1g)f2(h) for all g ∈ G (10)

1We adopt the conventional multiplicative group notation for non-Abelian

groups.

into the product of the ‘frequency domain’ transforms, i.e., [5]

\(f1 ∗ f2)(ρ) = ˆf1(ρ) ˆf2(ρ) .

C. Fourier Transform of f : G → K

We now consider the Fourier transform of functions over
a ﬁnite group G taking values in a ﬁnite ﬁeld K = Fpn of
prime characteristic p, where n is positive integer. Let α be a
primitive element of K [12], then we can list all the elements
in Fpn as {0, 1, α, . . . , αpn−2}.

Deﬁnition 3: ([12]) For an Abelian group G = (ZN , +),
where N is a divisor of pn − 1 and p is coprime with N , we
deﬁne the ﬁnite ﬁeld Fourier transform of f : ZN → Fpn as

ˆf [k] =

f [n]αnk

N −1Xn=0
N −1Xk=0

and its ﬁnite ﬁeld inverse Fourier transform as

f [n] =

1
N

ˆf [k]α−nk.

(cid:3)
The ﬁnite ﬁeld inverse Fourier transform exists only if p is
co-prime with N = |G|. This deﬁnition can be reformulated
as in (4) using the scalar representations ρk : G → K that are
deﬁned by N vectors

[1, αk, α2k, . . . , α(N −1)k]

for k = 0, . . . , N − 1.

We note that this Fourier transform is only deﬁned when
G = (ZN , +) is isomorphic to a subgroup of the cyclic
multiplicative group of Fpn. For any other non-Abelian group
G, we need to modify Deﬁnition 1 by replacing the group rep-
resentations with the p-modular representations of G deﬁned
below.

Deﬁnition 4: A p-modular representation of a group G
over a ﬁeld K of prime characteristic p is a group ho-
momorphism π : G 7→ GL(n, K), such that
the binary
operation of two group elements corresponds to the matrix
multiplication.
(cid:3)

III. THE TWO-MODULAR FOURIER TRANSFORM OF

BINARY FUNCTIONS

We now focus on binary functions (i.e., from n bit vectors
to m bit vectors) f : G → R where G = (Fn
2 , +) is the
group of n-bit binary vectors with bitwise mod two addition
+, and R is a ﬁnite commutative ring of characteristic 2. For
example, we can choose R = (Fm
2 , +, ∧), where addition
and multiplication are deﬁned by bitwise + (XOR) and ∧
(AND) binary logic operators, respectively. Another example
is a polynomial ring F2[X]/φ(X), where φ(X) is an arbitrary
polynomial of degree m. In the special case where φ(X) is
an irreducible polynomial, R is the ﬁnite ﬁeld K = F2m.
The elements of R can be represented as binary coefﬁcient
polynomials of degree less than m, where the ring operations
are polynomial addition and multiplication mod φ(X). In the
following, we will denote the zero and one elements of the
ring R as 0 and 1, and 1 + 1 = 0 ∈ R. In the special case of

4

2 , +, ∧), we have 0 → 0m and 1 → 1m, where
R = (Fm
0m and 1m denote the m-bit all-zero and all-one vectors.
Nevertheless, we use 0 and 1 in all cases for simplicity of
notation.

For convenience of notation, we will label the n-bit vectors
b = (b1, . . . , bn) ∈ G using the corresponding decimal values
{0, . . . , 2n − 1}, i.e.,

and its inverse as

D(b) =

bk2n−k

nXk=1

b , D−1(j)

(11)

(12)

for any decimal j ∈ {0, . . . , 2n − 1}. In the following, we
will ﬁrst introduce the two-modular representations of binary
groups. Then we will introduce the TMFT and the fast TMFT.

A. Two-modular representations of binary groups

Deﬁnition 5: The two-modular representation of the binary
group C2 = (F2, +) = {0, 1} is deﬁned as 2 × 2 matrices over
{0, 1} ∈ R, i.e., π1(C2) = {E0, E1}, where

π1(0) = E0 ,(cid:18) 1 0

0 1 (cid:19) and π1(1) = E1 ,(cid:18) 1 1
0 1 (cid:19) .

Lemma 1: The n-fold direct product group Cn

(cid:3)
2 , +)
can be faithfully represented as the Kronecker product of the
representations of C2, i.e.,

2 = (Fn

πn(Cn

2 ) , π1(C2) ⊗ · · · ⊗ π1(C2)
) ⊗ π1(C2).

= πn−1(Cn−1

2

(13)

Speciﬁcally, the matrix representation of a group element b =
(b1, . . . , bn) is,

Eb , π1(b1) ⊗ · · · ⊗ π1(bn).

(14)

(cid:3)
Proof: We need to show that πn is an injective homomor-
phism. For n = 0 and 1, it is straightforward. For n ≥ 2,
we prove it by induction using the recursion (13). Thus it is
enough to consider the case n = 2 and show that π2 is a group
homomorphism between C2

2 and π2(C2

2 ), i.e., that

π2(b1 + c1, b2 + c2) = π2(b1, b2) · π2(c1, c2),

or equivalently,

E(b1+c1,b2+c2) = E(b1,b2) · E(c1,c2) .

From (13) we have π2 = π1 ⊗ π1 then

E(b1,b2) · E(c1,c2) = (Eb1 ⊗ Eb2 ) · (Ec1 ⊗ Ec2)

= (Eb1 Ec1) ⊗ (Eb2 Ec2 )
= E(b1+c1,b2+c2) .

(15)

Then, we note that Eb = I2n holds only for b = 0n. This
proves the homomorphism is injective, since the kernel of πn
is only the all zero binary vector.
(cid:3)
Finally we deﬁne the representation of the trivial group {0}

as π0({0}) , 1 ∈ R.

Example 2: The two-modular representation of G = F2

2 is

given by:

E00 =
E10 =

1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1

1 0 1 0
0 1 0 1
0 0 1 0
0 0 0 1

 E01 =
 E11 =

1 1 0 0
0 1 0 0
0 0 1 1
0 0 0 1

1 1 1 1
0 1 0 1
0 0 1 1
0 0 0 1


 .

(cid:3)
We list below a few simple properties of the representation
matrices.

upper triangular and antidiagonal symmetric.

Property 1: The 2 × 2 matrices E0 and E1 are upper
triangular and have antidiagonal symmetry. Hence, any Eb
deﬁned by the Kroneker product in (14) is also upper triangular
and antidiagonal symmetric.
(cid:3)
Property 2: Any linear combination of Eb matrices is
(cid:3)
Property 3: From Lemma 1, we have Eb = I2n only for
b = 0n, where I2n denotes the 2n × 2n identity matrix. (cid:3)
Property 4: The top right corner element of Eb is 1 only
(cid:3)
Property 5: The main diagonal of Eb’s is all 1s, and hence

for b = 1n.

the top left corner element is always 1.

B. The TMFT and the fast TMFT

Let us consider a sequence of nested subgroups Hk ∼= Ck
2

of G = Cn

2 , namely

H0 = {0n} ⊳ H1 ⊳ · · · ⊳ Hk ⊳ · · · ⊳ Hn−1 ⊳ G

(16)

where {0n} denotes the trivial group with only one element,
the n-bit zero vector.

There are many possible choices for such sequence Hk ∼=
2 and we now choose a speciﬁc one, which results in a
Ck
simpler notation. In particular, we choose Hk, k = 1, . . . , n,
to be the set of n-bit vectors with the ﬁrst n − k bits set to
zero, i.e.,

Hk = {(0, . . . , 0, bn−k+1, . . . , bn)|bi ∈ {0, 1}} ∼= Ck
2 ,

(17)

and k = 1, . . . , n. Then we consider the quotient groups
G/Hk, which are the sets of n-bit vectors with the last k
bits set to zero, i.e.,

G/Hk =

{0n}

{(b1, . . . , bn−k, 0, . . . , 0)|bi ∈ {0, 1}}

k = 1, . . . n − 1
k = n

(18)
Table III shows an example of G, H1, H2, G/H1, and
G/H2 for n = 3 bits, where we index each element using
its corresponding decimal value from (11). Let dk ∈ Hk be
the n-bit all-zero vector except for its (n − k + 1)-th bit set
to 1, i.e.

dk = (0, . . . , 0

,

n−k

| {z }

n−k+1

1|{z}

, 0, . . . , 0

)

k−1

| {z }

NESTED SUBGROUPS AND CORRESPONDING QUOTIENT GROUPS OF C3
2

TABLE III

5

D(g)

0
1
2
3
4
5
6
7

G
000
001
010
011
101
101
110
111

H1
000
001

G/H1

000
010
100
110

0
1

0
2
4
6

H2
000
001
010
011

G/H2

000
100

0
1
2
3

0
4

Let us consider the binary subgroups of Hk generated by
dk, i.e., hdki = Hk/Hk−1 = {0, dk} ∼= C2 and Hk/hdki =
Hk−1. Then we have the following decomposition

= Hk/hdki

× hdki

× G/Hk

k = 1, . . . , n

(19)

2k−1

{z

}

|{z}2

2n−k

| {z }

G|{z}2n
|
Hk/hdki =

k = 1

where cardinalities of the component subgroups are indicated
below each one and
{0n}
{(0, . . . , 0, bn−k+2, . . . , bn)|
bi ∈ {0, 1}} ∼= Ck−1

k = 2, . . . , n

(20)
For any g = (b1, . . . , bn) ∈ G, we have g = u + v or
g = u + v + dk, where u = (0, . . . , 0, bn−k+2, . . . , bn) ∈
Hk/hdki for k = 2, . . . , n (or u ∈ {0n} for k = 1), and
v = (b1, . . . , bn−k, 0, . . . , 0) ∈ G/Hk for k = 1, . . . , n − 1
(or v ∈ {0n} for k = n). The element dk is the n-bit all-zero
vector except for its (n − k + 1)-th bit set to 1, as deﬁned
above.

2

We now deﬁne σk : Hk/hdki → Ck

2 as a map converting the
n bit vectors in Hk/hdki to k bit vectors in Ck
2 , which removes
the ﬁrst n − k zero bits of the n bit vectors of Hk/hdki.
Speciﬁcally, for any u ∈ Hk/hdki, we have

0

k = 1.

(0, bn−k+2, . . . , bn) k = 2, . . . , n

(21)

We note that Im(σk) does not contain any pair of complemen-
tary vectors. All the complementary vectors are in the Im(σk),
where

1

k = 1.

(1, ¯bn−k+2, . . . , ¯bn) k = 2, . . . , n

(22)

where ¯bi represents the binary complement of bi ∈ {0, 1}.

Lemma 2: The map σk is a homomorphism, i.e., given
u1, u2 ∈ Hk/hdki, we have σk(u1 + u2) = σk(u1) + σk(u2)
and σk(0n) = 0k, but the map σk is not.
(cid:3)
Proof: The proof is straightforward.
(cid:3)
2 , k = 1, . . . , n, be a map with image
Im(τk) = Ck
2 , which deﬁnes the k-bit vector index b = τk(g)
of Eb = Eτk(g), for all g ∈ G. In particular, for any g ∈ G,
τk(g) is deﬁned as

Let τk : G 7→ Ck

σk(u)

σk(u)

if g = u + v for some
u ∈ Hk/hdki and v ∈ G/Hk
if g = u + v + dk for some
u ∈ Hk/hdki and v ∈ G/Hk

(23)

σk(u) ,(cid:26)

σk(u) ,(cid:26)

τk(g) ,

Lemma 3: The map τk : G 7→ Ck

2 is a group homomor-
phism, i.e., τk(g + w) = τk(g) + τk(w), for g, w ∈ G, and
Ker(τk) = G/Hk.
(cid:3)
Proof: The proof is given in Appendix B.
(cid:3)
representations
πk(τk(g)) = Eτk(g) of G, with image Im(πk) = πk(Ck
2 ) =
{Eτk(g) : g ∈ G} with 2k elements isomorphic to the nested
subgroups Hk, i.e.,

now consider

two-modular

We

the

H0 ∼= Im(π0) = {1}
H1 ∼= Im(π1) = {E0, E1}
H2 ∼= Im(π2) = {E00, E01, E10, E11}
H3 ∼= Im(π3) = {E000, E001, E010, E011,
E100, E101, E110, E111}

...

the Fourier basis ‘vectors’ ψk = [Eτk(g) : g ∈ G] are the 2n-
component vectors (indexed by g) of 2k × 2k matrices from
the set Im(πk).

The projection of f on the k-th Fourier basis vector ψk, for
k = 0, . . . , n, gives the corresponding Fourier coefﬁcient ˆfk,
which is a 2k × 2k matrix.

Deﬁnition 6: (TMFT). We deﬁne the k-th Fourier coefﬁ-

cients of the TMFT for k = 1, . . . , n as the 2k × 2k matrix

ˆfk = hf, ψki ,Xg∈G

f (g)Eτk(g)

(24)

where Eτk(g) is the g-th element of the vector ψk and for
k = 0 we deﬁne

ˆf0 = hf, ψ0i ,Xg∈G

f (g)

(25)

and we refer to ˆf0 as the ‘DC-component’ of f .

(cid:3)
We are now ready to deﬁne the fast TMFT to compute (24)
more efﬁciently by collecting the terms with the same Eτk(g).

Lemma 4: (fast TMFT) The k-th Fourier coefﬁcients ˆfk
of the fast TMFT for k = 1, . . . , n can be efﬁciently computed
as


 Xv∈G/Hk
f (u + v) Eσk(u)
ˆfk = Xu∈Hk/hdki
f (u + dk + v) Eσk(u)
+ Xv∈G/Hk

For k = 0, (25) holds as is.

(cid:3)
Proof: We note that, in Deﬁnition 6, for g ∈ G, there are 2n
matrices Eτk(g) of size 2k × 2k in the computation of ˆfk, k =
1, . . . , n. Among these matrices Eτk(g), there are 2k distinct
ones in pairs of Eσk(u) and Eσk(u), where u ∈ Hk/hdki,
according to (26). Hence, the fast TMFT can collect the 2n−k
terms with the same Eτk(g), leading to a reduced computation
complexity (see details on complexity analysis in Section VI).
(cid:3)

(26)

6

✁
❆

r

✁
✁

1
❆
❆

✁
✁

❆
❆

r

✑
◗
✁
E0
✁

❆
✑
❆
◗
E1

r

✑

◗

✑

✑

◗

◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

E00

r

✑✑

◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

E11

r

✑

◗

✑

✑

◗

◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

E01

r

✑✑

◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

E10

r

E000

r

E111

r

E011

r

E100

r

E001

r

E110

r

E010

r

E101

r

u ∈ H1/hd1i, H2/hd2i, H3/hd3i

Fig. 1. Labeling tree the Fourier basis elements. The nodes in level k are
labeled with the 2k × 2k representations Eτk(g) of u ∈ Hk/hdk i.

Example 3: The Fourier coefﬁcients of the fast TMFT for
2 can be computed using H1 and H2

a function over G = C3
deﬁned in (17) as

f (g)

f ((000)

ˆf0 =Xg∈G
ˆf1 =Xv∈G/H1
|{z}u
ˆf2 = Xu∈H2/hd2i Xv∈G/H2
ˆf3 = Xu∈H3/hd3i

+v)E0 + f ((000)

+ (001)

|{z}u

|{z}d1

f (u+v)Eσ2(u)+f (u+(010)+v)Eσ2(u)

(27)

+v)E1 (28)

(29)
(30)

f (u)Eσ3(u) + f (u + (100))Eσ3(u)

The sum indices in (27), (28), (29), and (30) are based
upon these group elements listed in Table III. For example,
in (29), given hd2i = {000, 010}, according to (20) and (21),
we choose u ∈ H2/hd2i = {000, 001}, and thus we obtain
the corresponding σ2(u) ∈ {00, 01} with the associated ma-
trices {E00, E01}. Then σ2(u) ∈ {11, 10} and the associated
matrices are {E11, E10}.

Similarly, in (30), given hd3i = {000, 100}, we choose
u ∈ H3/hd3i = {000, 001, 010, 011}, which yields σ3(u) ∈
{000, 001 010, 011} with the associated matrices {E000, E001,
E010, E011}, and σ3(u) ∈ {111, 110, 101, 100} with the
associated matrices {E111, E110, E101, E100}.

In Fig. 1, we illustrate how to efﬁciently bit-label all the E
matrices using a binary tree structure. At level k in the tree,

f0 + f2 + f4 + f6

b1b20
✑
◗

r

✁
✁

✑

◗

✑

✑

◗

◗

✁
✁

✁
❆

r

✁
✁

❆
❆

b1b2b3

0fj

P7

❆
❆

❆
❆

r

✑
◗
b1b21

✑

◗

✑

✑

◗

◗

f1 + f3 + f5 + f7

f0 + f4
✑✑

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

b100

r

000, f0

r

100, f4

r

f2 + f6
◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

b110

r

f1 + f5
✑✑

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

b101

r

f3 + f7
◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

b111

r

010, f2

r

110, f6

r

001, f1

r

101, f5

r

011, f3

r

111, f7

r

v ∈ G, G/H1, G/H2

Fig. 2. Labeling tree of the arguments of f in the sums in (26) that multiply
the Fourier basis elements. The bit vector labels of the elements in G are
obtained by letting b1, b2, and b3 vary in {0, 1}.

(f0 + f2 + f4 + f6)E0

✑

✑

◗

◗

✑

◗

r

✑
◗
✁
✁
✁

r

✁
✁
❆
❆

✁
✁

❆
❆

0fj

P7

❆
❆
✑
❆
◗

r

✑

◗

✑

✑

◗

◗

(f1 + f3 + f5 + f7)E1

(f0 + f4)E00

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

✑✑

r

(f2 + f6)E11
◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

r

(f1 + f5)E01

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

✑✑

r

f0E000

r

f4E111

r

f2E011

r

f6E100

r

f1E001

r

f5E110

r

(f3 + f7)E10
◗◗

✘✘✘✘✘✘✘
❳❳❳❳❳❳❳

r

f3E010

r

f7E101

r

ˆf0

ˆf1

ˆf2

ˆf3

Fig. 3.
Labeling tree of the multiplications of the arguments of f in the
sums in (26) and the corresponding E matrices, resulting in the fast TMFT
coefﬁcients.

7

let b(k) = τk(g) denote a k bit vector, then

Eb(k) ∈ [u∈Hk/hdki

{Eσk(u), Eσk(u)} k = 1, . . . , n

where g = u + v or g = u + v + dk for some u ∈ Hk/hdki
and v ∈ G/Hk. At level k, a node labeled with Eb(k) splits
into two branches leading to an upper node labeled by E0,b(k)
(prepend 0) and a lower node labeled by E1,b(k) (complement
bits of b(k) and prepend 1). This pair of nodes with a common
parent correspond to Eσk+1(u) and Eσk+1(u), respectively.

From Deﬁnition 4, we note that the Fourier coefﬁcient
matrices ˆfk in the fast TMFT are linear combination of the
Ebk matrices, weighted by a sum of the time domain samples
of the function f given in (26). Fig. 2 illustrates how we label
the nodes for v ∈ G/Hk. For convenience of notation, the time
domain samples in Fig. 2 are denoted by fj = f (g), j = D(g),
for any g ∈ G. At level k, in each pair of the nodes with a
common parent, the upper binary vector represents the u + v
and the lower represents u + v + dk, where v ∈ G/Hk for
a given u. This tree can be used to compute the sums over
v ∈ G/Hk in (26).

Combining the labels from both trees in Figs. 1 and 2 yields
the combined tree structure illustrated in Fig. 3. For each pair
of nodes at level k with the same parent node at level k − 1,
we compute

and

 Xv∈G/Hk
 Xv∈G/Hk

f (u + v) Eσk(u)
f (u + dk + v) Eσk(u)

(31)

(32)

respectively, where Eσk(u) and Eσk (u) are the node labels from
Fig. 1, while the arguments of f in the sums are given by the
node labels from Fig. 2. Using Fig. 3, we can explicitly rewrite
the fast TMFT coefﬁcients in (27), (28), (29), and (30) as

ˆf0 = f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7
ˆf1 = (f0 + f2 + f4 + f6)E0 + (f1 + f3 + f5 + f7)E1
ˆf2 = (f0 + f4)E00 + (f2 + f6)E11

+(f1 + f5)E01 + (f3 + f7)E10

ˆf3 = f0E000 + f4E111 + f2E011 + f6E100

+f1E001 + f5E110 + f3E010 + f7E101

(33)

(non-fast TMFT) are shown in Table IV.

Alternatively, the Fourier basis vectors ψk in Deﬁnition 6
(cid:3)
Example 4: The TMFT of a Dirac function over G, i.e.,

δ0(0) = 1 and 0 otherwise, is given by

[δ0(g) = [1, E0, . . . , E0n ] = [1, I2, . . . , I2n ]

i.e., the list of Fourier coefﬁcient matrices is made up of
identity matrices of increasing size.
(cid:3)
Example 5: The TMFT of the indicator function of the

element g0 ∈ G, i.e.,

δg0 (g) =(cid:26) 1

0

g = g0
otherwise

TABLE IV

THE FOURIER BASIS VECTORS FOR G = C3
2

D(g)
Eτ0(g)
Eτ1(g)
Eτ2(g)
Eτ3(g)

0
1
E0
E00
E000

1
1
E1
E01
E001

2
1
E0
E11
E011

3
1
E1
E10
E010

4
1
E0
E00
E111

5
1
E1
E01
E110

6
1
E0
E11
E100

7
1
E1
E10
E101

ψ0
ψ1
ψ2
ψ3

8

is given by

2 yields \δ(11)(g) =
(cid:3)

\δg0 (g) =(cid:2)1, Eτ1(g0), . . . , Eτn(g0)(cid:3) .

For example, g0 = (11) ∈ G = C2

(cid:2)1, Eτ1(11), Eτ2(11)(cid:3) = [1, E1, E10].

IV. THE INVERSE TWO-MODULAR FOURIER TRANSFORM
In the case of binary functions considered in this paper,
Deﬁnition 2 cannot be applied since the 1
|G| Tr(·) operator is
undeﬁned. In fact |G| does not have an inverse and the trace
of any representation matrix Eb is always zero, having an
even number of ones on the diagonal (see Property 5). To
overcome this problem, we introduce the matrix operator Φk :
2 ) → C2 from the set of two-modular representations of
πk(Ck
Ck

2 to {0, 1}, for k = 1, . . . , n.
Deﬁnition 7: Let Eb be the 2k × 2k representation of a k-
2 , then we deﬁne the matrix operator

bit binary vector b ∈ Ck
on Eb as

Φk(Eb) , Eb[1, 2k] ∈ {0, 1}

i.e., Φk extracts the top-right corner element of the matrix Eb.
(cid:3)
As observed in Property 4, only b = 1k yields Φk(Eb) = 1,
while any other binary vector representation is mapped to zero.

Lemma 5: The operator Φk is linear, i.e.,

Φk(αEa + βEb) = αΦk(Ea) + βΦk(Eb)

and

Φk(EaEb) = Φk(EbEa)

(34)

2 .
for any α, β ∈ R, and a, b ∈ Ck
Proof: The proof is straightforward.

Lemma 6: Let Ea and Eb be the 2k × 2k representation
2 , respectively. We have

of the k-bit binary vectors a, b ∈ Ck

Φk(EaEb) = Φk(Ea+b)

= (cid:26) 1

0

iff a + b = 1 (or a = ¯b)

otherwise .

(35)

Proof: The proof is straightforward.

(cid:3)
(cid:3)
Theorem 1: (Inverse TMFT). The inverse TMFT is given

by

fj = ˆf0 +

nXk=1

Φk(cid:16) ˆfkEτk(D−1(j))(cid:17) j = 0, . . . , 2n − 1 (36)

where D−1(j) = (cn, . . . , ck, . . . , c1) 2, with ck ∈ {0, 1} and
τk is given in (23).
(cid:3)

2To simplify notation, we have reversed the order of the bit indices of ck.

(cid:26)

and

Proof: Recalling (18), (19), (20), and dk = (0, . . . , bn−k+1 =
1, 0, . . . , 0) (the n-bit all-zero vector except for bn−k+1 = 1),
we have

u + v

= (b1, . . . , bn−k, 0, bn−k+2, . . . , bn)
u + v + dk = (b1, . . . , bn−k, 1, bn−k+2, . . . , bn)

(37)

for k = 2, . . . , n − 1, while in the special cases of k = 1 and
k = n, we have respectively

(cid:26)
(cid:26)

u + v

= (b1, . . . , bn−k, 0)
u + v + d1 = (b1, . . . , bn−k, 1)

u + v

= (0, b2, . . . , bn)
u + v + dn = (1, b2, . . . , bn)

(38)

(39)

We then rewrite the right-hand side of (36) in its binary form
as (40).

For any k ∈ {1, . . . , n}, based on the binary representation
D−1(j) = (cn, . . . , ck, . . . , c1) and the deﬁnition of τk in (23),
we have that:

• Eτk(D−1(j)) = Eσk(˜u) holds when D−1(j) ∈ {˜u +
v | v ∈ G/Hk}, which implies ck = 0 and
˜u = (0, . . . , 0, ck−1, . . . , c1). For such ˜u, only the
term f (b1, . . . , bn−k, ¯ck = 1, ck−1, . . . , c1)
in the
sum over u remains, since Φk(Eσk (˜u)Eτk(D−1(j))) =
Φk(Eσk (˜u)Eσk(˜u)) = 1. All
terms can-
cel, since Φk(Eσk(u)Eσk(˜u)) = 0 for all u, and
Φk(Eσk (u)Eσk(˜u)) = 0 for all u 6= ˜u.

the other

• Eτk(D−1(j)) = Eσk(˜u) holds when D−1(j) ∈ {˜u +
v + dk | v ∈ G/Hk}, which implies ck = 1 and
˜u = (0, . . . , 0, ck−1, . . . , c1). For such ˜u, only the term
f (b1, . . . , bn−k, ¯ck = 0, ck−1, . . . , c1) in the sum over u
remains, since Φk(Eσk (˜u)Eσk(˜u)) = 1, while the other
terms cancel, since Φk(Eσn(u)Eσk(˜u)) = 0 for all u and
Φk(Eσk (u)Eσk(˜u)) = 0 for all u 6= ˜u.

Then (40) simpliﬁes to

f (b1, . . . , bn)

Xb1,...,bn
(v)Xb1,...,bn−1
(v)Xb1,...,bn−k

+

+

f (b1, . . . , bn−1, ¯c1) + · · ·

f (b1, . . . , bn−k, ¯ck, ck−1, . . . , c1)

(41)

(42)

(43)

+ · · · + f (¯cn, cn−1, . . . , c1) .

two

Adding

summations

the ﬁrst
yields
f (b1, . . . , bn−1, c1) due to the characteristic 2 of
R (bitwise XOR addition). Progressively adding the summa-
f (b1, . . . , bn−k, ck, . . . , c1).

Pb1,...,bn−1
tions up to (42) yieldsPb1,...,bn−k

(41)

in

Φk(cid:16) ˆfkEτk(D−1(j))(cid:17)

f (b1, . . . , bn) +

ˆf0 +

nXk=1
(v)Xb1,...,bn

(v)Xb1,...,bn−1

=

+

+

(v)Xb1,...,bn−k


(u)Xb2,...,bn


f (b1, . . . , bn−1, 0|{z}c1
+f (b1, . . . , bn−1, 1|{z}c1

)Φ1(Eσ1(u)=0Eτ1(D−1(j)))

+ · · ·

, bn−k+2, . . . , bn)Φk(Eσk (u)Eτk(D−1(j)))

)Φ1(Eσ1(u)=1Eτ1(D−1(j)))
, bn−k+2, . . . , bn)Φk(Eσk(u)Eτk(D−1(j)))

+ · · ·


f (b1, . . . , bn−k, 0|{z}ck
+f (b1, . . . , bn−k, 1|{z}ck

(u)Xbn−k+2,...,bn

f ( 0|{z}cn

, b2, . . . , bn)Φn(Eσn(u)Eτn(D−1(j))) + f ( 1|{z}cn

, b2, . . . , bn)Φn(Eσn(u)Eτn(D−1(j)))

9

.

(40)

yields

Deﬁnition 8: Given a pair of functions r and s : G → R

we deﬁne the convolution product f : G → R as

Finally
(43)
f (cn, . . . , ck, . . . , c1) = fj. This completes the proof.

summations

adding

up

all

to

(cid:3)
Example 6: Following Example 3, given Fourier coefﬁ-
cients ˆf0, ˆf1, ˆf2 and ˆf3 in (33) for a function over G = C3
2 ,
the inverse Fourier transform can be computed as

f0 =ˆf0 + Φ1( ˆf1E0) + Φ2( ˆf2E00) + Φ3( ˆf3E000)
f1 =ˆf0 + Φ1( ˆf1E1) + Φ2( ˆf2E01) + Φ3( ˆf3E001)
f2 =ˆf0 + Φ1( ˆf1E0) + Φ2( ˆf2E11) + Φ3( ˆf3E011)
f3 =ˆf0 + Φ1( ˆf1E1) + Φ2( ˆf2E10) + Φ3( ˆf3E010)
f4 =ˆf0 + Φ1( ˆf1E0) + Φ2( ˆf2E00) + Φ3( ˆf3E111)
f5 =ˆf0 + Φ1( ˆf1E1) + Φ2( ˆf2E01) + Φ3( ˆf3E110)
f6 =ˆf0 + Φ1( ˆf1E0) + Φ2( ˆf2E11) + Φ3( ˆf3E100)
f7 =ˆf0 + Φ1( ˆf1E1) + Φ2( ˆf2E10) + Φ3( ˆf3E101)

(cid:3)

V. TMFT PROPERTIES

Theorem 2: (Linearity of TMFT). Given a pair of func-
tions r and s : G → R, let ˆr = [ˆr0, . . . , ˆrk, . . . , ˆrn] and
ˆs = [ˆs0, . . . , ˆsk, . . . , ˆsn] be the lists of Fourier coefﬁcients
matrices of TMFT (i.e., ˆrk and ˆsk are 2k × 2k matrices), the
TMFT of the linear combination of r and s is given by

\αr + βs = αˆr + βˆs

= [αˆr0 + βˆs0, . . . , αˆrk + βˆsk, . . . , αˆrn + βˆsn]

for α, β ∈ R.

(cid:3)

Proof: The proof is straightforward.
Next, we specialize the deﬁnition of convolution in (10) for

the case of the additive group G = Cn
2 .

f (g) = r(g) ∗ s(g) = Xg′∈G

r(g′ + g)s(g′) for g ∈ G.

(cid:3)
It can be easily shown that the convolution product is commu-
tative. Now we present the convolution theorem when using
TMFT.

Theorem 3: (Convolution Theorem). Given a pair of
functions r and s : G → R, let ˆr = [ˆr0, . . . , ˆrk, . . . , ˆrn] and
ˆs = [ˆs0, . . . , ˆsk, . . . , ˆsn] be the lists of Fourier coefﬁcients
matrices of TMFT (i.e., ˆrk and ˆsk are 2k × 2k matrices), we
obtain Fourier transform of the convolution product as

(cid:3)
Proof: Using Deﬁnition 6, we can simply write the product

Substituting w = g + g′, we obtain

r(g)Eτk(g) Xg′∈G

of the k-th Fourier coefﬁcient matrices of r and s as
s(g′)Eτk(g′) .

dr ∗ s = ˆr ⊙ ˆs , [ˆr0ˆs0, . . . , ˆrk ˆsk, . . . , ˆrnˆsn] .
ˆrk ˆsk =Xg∈G
ˆrk ˆsk = Xw∈GXg∈G
= Xw∈GXg∈G
= Xw∈GXg∈G
= Xw∈G

r(g)s(g + w)Eτk(w)

r(g)s(g + w)Eτk(g)Eτk(g+w)

(r ∗ s)(w)Eτk (w) .

r(g)s(g + w)Eτk(g)Eτk(g)+τk(w)

The second equality is based on the fact that τk is group
homomorphism (see Lemma 3).
(cid:3)

(44)

Theorem 4: (Shifting Property). Given the function f :

Lemma 8: The total complexity of the ITMFT is given by

10

G → R and its TMFT

ˆfk =Xg∈G

f (g)Eτk(g) k = 1, . . . , n

and a given shift a ∈ G then the Fourier transform of f (g + a)
is given by

Xg∈G

f (g + a)Eτk(g+a) =Xg∈G

f (g + a)Eτk(g)Eτk(a) .

(45)

If f (g + a) = f (g) for all g ∈ G, then the above Fourier
transform becomes

Xg∈G

f (g + a)Eτk(g+a) = ˆfkEτk(a) .

(46)

(cid:3)

Proof: The proof is straightforward.

VI. IMPLEMENTATION AND COMPLEXITY

The evaluation of the TMFT only requires additions (and
no multiplications) in the ring R, since the Eb matrices only
contain zeros and ones in R. Hence, we deﬁne the complexity
as the number of additions in the ring R. For convenience of
exposition, we will begin by analyzing the complexity of the
ITMFT.

A. Complexity of ITMFT

The following lemma enables us to count the number of ring
additions needed to compute one term Φk( ˆfkEτk(D−1(j))) in
(36), for any k = 0, . . . , n and j = 0, . . . , 2n −1. We note that
the top right corner of the matrix product is given by the scalar
product ﬁrst row of ˆfk and the last column of Eτk(D−1(j)).

Lemma 7: Given an n-bit vector b and the corresponding
representation matrix Eb,
let v be the ﬁrst row (or the
transposed last column) of the matrix Eb and let wH (b) and
wH (v) be their Hamming weights, then
wH (v) = 2wH (b) .

(47)

(cid:3)
Proof: We ﬁrst prove this lemma when v is the ﬁrst row
of the matrix Eb. For n = 1, (47) is true by deﬁnition of E0
and E1. By induction on the number of bits, we assume (47)
is true for a k-bit vector b(k), i.e., wH (v(k)) = 2wH (b(k)),
where v(k) is the ﬁrst row of Eb(k) . When one more bit bk+1
is appended to b(k) the matrix representation becomes

Eb(k+1) = Eb(k) ⊗ Ebk+1 .

CITMFT =

3n+1 + 1

2

+ (n − 2)2n .

(48)

(cid:3)
Proof: The total complexity of the ITMFT takes into
accounts i) the number of terms in ˆfk to be added when
computing Φk( ˆfkEτk(D−1(j))), for k = 1, . . . , n; and ii) the
number of additions of terms Φk( ˆfkEτk(D−1(j))) in (36).

Let w = wH (b) be the Hamming weight of the k-bit
vector b associated with the matrix Eτk(D−1(j)). The number
of elements of the matrix ˆfk to be added when computing
Φk( ˆfkEτk(D−1(j))) is determined by the number of ones in the
last column of Eτk(D−1(j)), which is 2w according to Lemma
7. Then the number of additions is one less, i.e., 2w − 1. Since
there are only 2k distinct Eτk(D−1(j)) for each k, we need to
run over all the weights w of the k-bit vector corresponding
to the matrix Eτk(D−1(j)) for k = 1, . . . , n. This results in a
complexity of

nXk=1
w(cid:19)2w −

w(cid:19)(2w − 1) .
kXw=0(cid:18)k
w(cid:19)# =
kXw=0(cid:18)k

nXk=1

We simplify (49) to

nXk=1" kXw=0(cid:18) k

(49)

(50)

(3k − 2k) .

On the other hand,

the number of additions of terms
Φk( ˆfkEτk(D−1(j))) in (36) is n2n. Finally, we obtain the total
complexity

CITMFT =

nXk=1

(3k − 2k) + n2n =

3n+1 + 1

2

− 2n+1 + n2n .

(51)
(cid:3)

B. Complexity of the fast TMFT

From Lemma 4, we note that the Fourier coefﬁcient matrices
ˆfk of the fast TMFT are linear combination of the matrices Eb,
weighted by the scalar values. Following (14) and Property
1, the matrices Eb are the k-fold Kroneker products of the
2 × 2 upper triangular and anti-diagonal symmetric matrices
E0, E1. This provides a simple algorithm (see Fig. 4), in which
any ˆfk can be entirely reconstructed from its ﬁrst row entries.
Hence, we only need to compute and store the ﬁrst row of the
matrices ˆfk, which is a linear combination of the ﬁrst rows of
matrices Eb. Then the complexity can be derived by counting
the Hamming weights of the ﬁrst rows of matrices Eb. We
have the following Lemma.

Lemma 9: The total complexity of the fast TMFT is given

From the deﬁnition of the Kroneker product and the matrices
E0 and E1, we have:

wH (v(k+1)) =(cid:26) wH (v(k))

2wH(v(k))

if bk+1 = 0
if bk+1 = 1

by

Hence the weight of the ﬁrst row doubles for every bit that is
equal to one in b.

Based on the anti-diagonal symmetry noted in Property 1,
under the same assumptions, (47) is also valid when vT is the
last column of Eb.
(cid:3)

CFTMFT =

3n+1 + 1

2

− 2n+1 .

(52)

(cid:3)
Proof: For each ˆfk, k = 1, . . . , n, given k bit vector b with
Hamming weight w = wH (b), we let vb denote the ﬁrst row
vector of a Eb matrix with Hamming weight wH (vb) = 2w,

11

1.
2.
3.
4.
5.
6.
7.
8.
9.

Input: v (ﬁrst row of ˆfk), k number of bits
for j = 0 : k − 1

w = zeros(2j, 2k);
for i = 1 : 2j+1 : 2k − 2j

w(1 : 2j, (i + 2j) : (i + 2j + 2j − 1)) = v(1 : 2j, i : i + 2j − 1);

end
v = [v; w];

end
return v (complete matrix ˆf )

Fig. 4. Algorithm to ﬁnd the full ˆfk from its ﬁrst row.

according to Lemma 7. We prove the complexity of the fast
TMFT in the following steps.

1) We start from the leaf nodes at level n in the tree, as
shown for example in Fig. 3. The total number of terms
to be added is given by the sum of the Hamming weights
of all vectors vb at level n, i.e.,

wH (vb) =

Xb

nXw=0(cid:18)n

w(cid:19)2w = 3n .

The corresponding addition count is given by

K1 = 3n − 2n

(53)

level k is given by

n−1Xk=1

K2 =

(3k −2k)−(2k −1)+(2k −1) =

(3k −2k) .

(55)
3) At k = 0, we have ˆf0, already available at level n.

Hence, the ﬁnal complexity is

n−1Xk=1

CFTMFT = K1+K2 =

(3k−2k) =

3n+1 + 1

2

−2n+1 .

nXk=1

(cid:3)

since we have 2n separate sums to compute the ﬁrst
row elements. By direct computation, we note that the
j=0 fj. This
needs to be computed only once and is used throughout
the following steps.

ﬁrst term in the ﬁrst row of ˆfn is ˆf0 =P2n−1

in this row ( ˆf0 = P2n−1

2) At level k (1 ≤ k < n) in the tree, we only focus on the
ﬁrst row of each matrix ˆfk, except for the ﬁrst element
j=0 fj), which has been already
computed at level n. Since the ﬁrst term in vb is always
one (see Property 5), for each ˆfk, the total number of
terms to be added is given by the sum of wH (vb) − 1
of all vectors vb at level k, i.e.,

C. Complexity of TMFT

Lemma 10: The total complexity of TMFT is given by

CTMFT = 3n+1 − (n + 4)2n + n + 1 .

(56)

(cid:3)
Proof: The proof is similar to that of the fast TMFT and

can be derived by modifying (54) and (55).

1) At level n, the complexity of TMFT is the same as K1 =
3n − 2n in (53) of the fast TMFT, since both methods
have the same 2n distinct matrices Eb.
2) At level k = 1, . . . , n − 1, (54) becomes

(wH (vb)−1) =

Xb

kXw=0(cid:18)k

w(cid:19)(2w−1) = 3k−2k, (54)

for k = 1, . . . , n − 1. The last equality is due to (50).
The corresponding additions count is given by (3k −
2k) − (2k − 1), since we have 2k − 1 separate sums to
compute the 2k − 1 elements of the ﬁrst row.
At each level k, there are extra addition operations that
are performed to compute the partial sum of the time
f (u + v) in (31) and
f (u+v+dk) in (32). Note that we can ignore
the partial sum coefﬁcient of E0 at level k, since, by
excluding the ﬁrst element of the ﬁrst row of E0, the
remaining elements are all zeros. Hence, the extra count
for such addition is 2k − 1. This can be also interpreted
using the tree structure in Fig. 3: the number of additions
simply coincides with the number of nodes at level k,
after excluding node E0. Then, the complexity at all

domain samples, i.e., Pv∈G/Hk
Pv∈G/Hk

Xb

(wH (vb) − 1) = 2n−k

kXw=0(cid:18)k

w(cid:19)(2w − 1)

= 2n−k(3k − 2k) .

(57)

Pn−1

and the corresponding additions count

is given by
k=1 2n−k(3k − 2k) − (2k − 1), since we have 2k − 1
separate sums to compute the 2k − 1 elements of the
ﬁrst row.
Note that (57) has an extra 2n−k scaling factor, when
compared to (54). As observed in the proof of Lemma
4, ˆfk of TMFT is the linear combination of the 2n
matrices Eb, weighted by the scalar values. Among all
the 2n matrices Eb, there are 2k distinct ones and 2n−k
repetitions of each distinct one, which causes the extra
scaling factor in (57).
Note that, for TMFT, there is no partial sum of the
time domain samples in (31) and (32), and thus no extra
addition count of 2k + 1 in (55). Then, the complexity

in (55) becomes

APPENDIX

12

n−1Xk=1

K2 =

2n−k(3k − 2k) − (2k − 1), k = 1, . . . , n − 1 .

(58)
3) At level 0, as discussed in the fast TMFT, no extra
computation complexity is needed, since f0 is already
available at
the ﬁnal complexity of
TMFT is

level n. Hence,

CTMFT = K1 + K2 = 3n+1 − (n + 4)2n + n + 1 .

Remark 1: Comparing the complexity of TMFT in (56) and
the fast TMFT in (52), we obtain the asymptotic ratio of
CTMFT over CFTMFT as

(cid:3)

lim
n→∞

CTMFT
CFTMFT

= 2

(59)

(cid:3)
Remark 2: We can now compare the complexity of a con-
volution in the time domain to the complexity when using the
fast TMFT. The convolution in Deﬁnition 8 requires |G|2 = 4n
multiplications in the ring R. On the other hand, if we apply
the convolution theorem, we need to compute two fast TMFT’s
and one ITMFT for a total of

3

2(cid:0)3n+1 − 2n+2 + 1(cid:1) + n2n

additions in the ring R.

(cid:3)

VII. CONCLUSIONS

In this paper we have deﬁned the two-modular Fourier
transform of a binary function f : G → R over G = Cn
2
with values in a ﬁnite commutative ring R of characteristic
2. This new Fourier transform is based on k-dimensional
representations of a sequence of nested subgroups Hk = Ck
2
of G. Using the speciﬁc group structure of G, we have
highlighted the steps that lead to the fast version of the two-
modular Fourier transform and its inverse. In particular, this
new inverse Fourier transform signiﬁcantly deviates from the
traditional modular inverse Fourier transform, which is only
valid for the case where the characteristic of the ring R does
not divide the order of the group G. The major difference is
that the trace operator is replaced by a new operator, which
extracts the top right corner element of a matrix.

We then provided the TMFT properties including linearity,
shifting property and the convolution theorem, which enables
to efﬁciently compute convolutions (multiplications in the
group ring R[G]). We also presented the exact complexity
of fast TMFT and its inverse.

This Fourier transform may have broad applications to
problems, where binary functions need to be reliably computed
or in classiﬁcation of binary functions.

Deﬁnition A.1: An n–dimensional

A. Basic Deﬁnitions of Group Representation and Characters
representation of a
group G is a group homomorphism from G to the group of
n × n invertible matrices over a ﬁeld K, i.e.,

ρ : G → GL(n, K)

such that

ρ(g1g2) = ρ(g1)ρ(g2)

∀g1, g2 ∈ G .

If the homomorphism is injective, we say the representation
is faithful. We also deﬁne the kernel of ρ as Ker(ρ) = {g ∈
G : ρ(g) = In}.
(cid:3)
Note that this homomorphism transforms the group operation
on a pair of elements to matrix multiplication of the corre-
sponding representation matrices. Since matrix multiplication
is non-commutative these representations are useful to study
non-Abelian groups. When dealing with Abelian groups scalar
(one-dimensional) representations are commonly used [8].
Deﬁnition A.2: Given two representations of a group G

ρ1 : G → GL(n, K)

ρ1(g) = Vg

and

ρ2 : G → GL(n, K)

ρ2(g) = Wg

where g ∈ G, we say ρ1 and ρ2 are equivalent, if there exists
an invertible matrix A such that ρ2(g) = A · Vg · A−1 = Wg,
for all g ∈ G. Otherwise, we say ρ1 and ρ2 are inequivalent.
In the scalar case, two representations are equivalent only if
they coincide, i.e., ρ1(g) = ρ2(g) for all g ∈ G.
(cid:3)
Deﬁnition A.3: A ﬁnite dimensional complex representa-
tion ρ : G → GL(n, C) is irreducible if the only subspace
V ⊆ Cn that is invariant under all the matrix transformations
ρ(g), for all g ∈ G, is either V = Cn or V = 0.
(cid:3)
Deﬁnition A.4: Given a representation ρ of a group G, the

character of ρ is the function χρ : G → K given by

χρ(g) = Tr(ρ(g))

∀g ∈ G

where Tr(·) is the trace of the matrix.
(cid:3)
Note that a one-dimensional representation coincides with its
character and hence it is a group homomorphism. However, in
general the character of a matrix representation is not a group
homomorphism.

B. Proof of Lemma 3

According to (23), for any g, w, g + w ∈ G, we have

τk(g) =
τk(w) =

σk(u1)

σk(u1)

σk(u2)

σk(u2)

if g = u1 + v1 for some
u1 ∈ Hk/hdki and v1 ∈ G/Hk
if g = u1 + v1 + dk for some
u1 ∈ Hk/hdki and v1 ∈ G/Hk

if w = u2 + v2 for some
u2 ∈ Hk/hdki and v2 ∈ G/Hk
if w = u2 + v2 + dk for some
u2 ∈ Hk/hdki and v2 ∈ G/Hk

(60)

(61)

if g + w = (u1 + u2)+(v1 + v2)
for some
u1, u2, (u1 + u2) ∈ Hk/hdki
and v1, v2, v1 + v2 ∈ G/Hk

if g + w = (u1 + u2)

Hk/hdki and v1, v2, v1 + v2 ∈ G/Hk. We obtain the
same result as the previous case by swapping g and w.
This proves τk to be group homomorphism. According to
the fundamental homomorphism theorem, we have Ker(τk) =
G/Hk.
(cid:3)

13

τk(g+w)=

σk(u1 + u2)

σk(u1 + u2)



ACKNOWLEDGEMENT

We thank Dr Lakshmi Natarajan for fruitful discussions and

the anonymous reviewers for their valuable comments.

REFERENCES

[1] A.V. Oppenheim and R.W. Schafer, Discrete-Time Signal Processing,

3rd Edition, Prentice-Hall, Signal Processing Series, 2010.

[2] R.E. Blahut, “A Universal Reed-Solomon Decoder,” IBM J. Research &

Development, Vol. 28, No. 2, pp. 150–158, Mar. 1984.

[3] S. Arora and B. Barak, Computational Complexity: A Modern Approach,

Cambridge University Press, 2009.

[4] R. O’Donnell, Analysis of Boolean Functions, Cambridge University

Press, 2014.

[5] A. Terras, Fourier Analysis on Finite Groups and Applications, Cam-

bridge University Press, 1999.

[6] D. Benson, Modular Representation Theory. New Trends and Methods,

Lecture Notes in Mathematics 1081, 2nd edition 2006.

[7] Krister hlander and Hans Munthe-Kaas, “Applications of the General-
ized Fourier Transform in Numerical Linear Algebra” BIT Numerical
Mathematics Dec. 2005, vol. 45, n. 4, pp. 819–850

[8] V.P. Snaith, Groups, Rings and Galois Theory (Second Edition) World

Scientiﬁc Publishing Co. Pte. Ltd., 2003, ISBN 981-238-576-2.

[9] R.S. Stankovic, C. Moraga, and Jaakko T. Astola, Readings in Fourier
Analysis on Finite Non-Abelian Groups, TICSP Series #5, September
1999, ISBN 952-15-0284-3.

[10] D.S. Passman, The algebraic structure of group rings New York: John

Wiley & Sons, 1977, ISBN: 0471022721.

[11] Claude Carlet, “Vectorial Boolean Functions for Cryptography”, Book
Chapter in Boolean Models and Methods in Mathematics, Computer
Science, and Engineering ed. by Yves Crama and Peter L. Hammer,
Cambridge University Press, pp. 398-472, 2010.

[12] J. M. Pollard, “The Fast Fourier Transform in a Finite Field”, Mathe-

matics of Computation, vol. 25, no. 114, pp. 365-374, 1971.

+(v1 + v2) + dk

for some
u1, u2, (u1 + u2) ∈ Hk/hdki
and v1, v2, v1 + v2 ∈ G/Hk

(62)
There are four combinations of g and w that we will analyze
to prove it is a group homomorphism.

1) When g = u1 + v1 and w = u2 + v2 for some u1, u2 ∈
Hk/hdki and v1, v2 ∈ G/Hk, we have g + w = (u1 +
u2) + (v1 + v2), for some u1, u2, (u1 + u2) ∈ Hk/hdki
and v1, v2, v1 + v2 ∈ G/Hk. From (62), we have

τk(g + w) = σk(u1 + u2) .

(63)

On the other hand, based on (60), (61) and Lemma 2,
we have

τk(g) + τk(w) = σk(u1) + σk(u2) = σk(u1 + u2) (64)

Comparing (63) and (64), we have τk(g + w) = τk(g) +
τk(w).

2) When g = u1 + v1 + dk, and w = u2 + v2 + dk for
some u1, u2 ∈ Hk/hdki and v1, v2 ∈ G/Hk, we have
g+w = (u1+u2)+(v1+v2) for some u1, u2, (u1+u2) ∈
Hk/hdki and v1, v2, v1 + v2 ∈ G/Hk. From (62) and
Lemma 2, we have

τk(g + w) = σk(u1 + u2) = σk(u1) + σk(u2)

(65)

and

τk(g) + τk(w) = σk(u1) + σk(u2)

= 1k + σk(u1) + 1k + σk(u2)
= σk(u1) + σk(u2)

(66)

Comparing (65) and (66), we have τk(g + w) = τk(g) +
τk(w).

3) When g = u1 + v1 and w = u2 + v2 + dk for some
u1, u2 ∈ Hk/hdki and v1, v2 ∈ G/Hk, we have g +w =
(u1 + u2) + (v1 + v2) + dk, for some u1, u2, (u1 + u2) ∈
Hk/hdki and v1, v2, v1 + v2 ∈ G/Hk. We have

τk(g + w) = σk(u1 + u2)

= 1k + σk(u1 + u2)
= 1k + σk(u1) + σk(u2)

(67)

and

τk(g) + τk(w) = σk(u1) + σk(u2)

= 1k + σk(u1) + σk(u2) . (68)

Comparing (67) and (68), we have τk(g + w) = τk(g) +
τk(w).

4) When g = u1 + v1 + dk and w = u2 + v2, for some
u1, u2 ∈ Hk/hdki and v1, v2 ∈ G/Hk, we have g +w =
(u1 + u2) + (v1 + v2) + dk, for some u1, u2, (u1 + u2) ∈

