Comparing Convolutional Neural Networks

to Traditional Models for Slot Filling

Heike Adel and Benjamin Roth and Hinrich Sch¨utze
Center for Information and Language Processing (CIS)

LMU Munich

Oettingenstr. 67, 80538 Munich, Germany

6
1
0
2

 
r
p
A
4

 

 
 
]
L
C
.
s
c
[
 
 

2
v
7
5
1
5
0

.

3
0
6
1
:
v
i
X
r
a

heike@cis.lmu.de

Abstract

We address relation classiﬁcation in the con-
text of slot ﬁlling, the task of ﬁnding and eval-
uating ﬁllers like “Steve Jobs” for the slot X
in “X founded Apple”. We propose a convo-
lutional neural network which splits the input
sentence into three parts according to the re-
lation arguments and compare it to state-of-
the-art and traditional approaches of relation
classiﬁcation. Finally, we combine different
methods and show that the combination is bet-
ter than individual approaches. We also ana-
lyze the effect of genre differences on perfor-
mance.

1

Introduction

Structured knowledge about the world is useful for
many natural language processing (NLP) tasks, such
as disambiguation, question answering or semantic
search. However, the extraction of structured infor-
mation from natural language text is challenging be-
cause one relation can be expressed in many differ-
ent ways. The TAC Slot Filling (SF) Shared Task
deﬁnes slot ﬁlling as extracting ﬁllers for a set of
predeﬁned relations (“slots”) from a large corpus of
text data. Exemplary relations are the city of birth
of a person or the employees or founders of a com-
pany. Participants are provided with an evaluation
corpus and a query ﬁle consisting of pairs of enti-
ties and slots. For each entity slot pair (e.g. “Ap-
ple” and “founded by”), the systems have to return
the second argument (“ﬁller”) of the relation (e.g.
“Steve Jobs”) as well as a supporting sentence from
the evaluation corpus. The key challenge in slot

ﬁlling is relation classiﬁcation: given a sentence s
of the evaluation corpus containing the name of a
queried entity (e.g., “Apple”) and a ﬁller candidate
(e.g., “Steve Jobs”), we need to decide whether s ex-
presses the relation (“founded by”, in this case). We
will refer to the mentions of the two arguments of
the relation as name and ﬁller. Performance on re-
lation classiﬁcation is crucial for slot ﬁlling since its
effectiveness directly depends on it.

In this paper, we investigate three complementary

approaches to relation classiﬁcation.

The ﬁrst approach is pattern matching, a leading
approach in the TAC evaluations. Fillers are vali-
dated based on patterns. In this work, we consider
patterns learned with distant supervision and pat-
terns extracted from Universal Schema relations.

The second approach is support vector machines.
We evaluate two different feature sets: a bag-of-
word feature set (BOW) and more sophisticated skip
n-gram features.

Our third approach is a convolutional neural net-
work (CNN). CNNs have been applied to NLP tasks
like sentiment analysis, part-of-speech tagging and
semantic role labeling. They can recognize phrase
patterns independent of their position in the sen-
tence. Furthermore, they make use of word embed-
dings that directly reﬂect word similarity (Mikolov
et al., 2013). Hence, we expect them to be ro-
bust models for the task of classifying ﬁller candi-
dates and to generalize well to unseen test data. In
this work, we train different variants of CNNs: As
a baseline, we reimplement the recently developed
piecewise CNN (Zeng et al., 2015). Then, we ex-
tend this model by splitting the contexts not only for

Currently,

pooling but also for convolution (contextwise CNN).
there is no benchmark for slot ﬁll-
ing. Therefore, it is not possible to directly com-
pare results that were submitted to the Shared Task
to new results. Comparable manual annotations for
new results, for instance, cannot be easily obtained.
There are also many different system components,
such as document retrieval from the evaluation cor-
pus and coreference resolution, that affect Shared
Task performance and that are quite different in na-
ture from relation classiﬁcation. Even in the sub-
task of relation classiﬁcation, it is not possible to
directly use existing relation classiﬁcation bench-
marks (e.g. Riedel et al. (2013), Hendrickx et al.
(2010)) since data and relations can be quite differ-
ent. Many benchmark relations, for instance, corre-
spond to Freebase relations but not all slots are mod-
eled in Freebase and some slots even comprise more
than one Freebase relation. While most relation clas-
siﬁcation benchmarks either use newswire or web
data, the SF task includes documents from both do-
mains (and discussion fora). Another difference to
traditional relation classiﬁcation benchmarks arises
from the pipeline aspect of slot ﬁlling. Depending
on the previous steps, the input for the relation clas-
siﬁcation models can be incomplete, noisy, include
coreferent mentions, etc.

The ofﬁcial SF Shared Task evaluations only as-
sess whole systems (with potential subsequent faults
in their pipelines (Pink et al., 2014)). Thus, we ex-
pect component wise comparisons to be a valuable
addition to the Shared Task: With comparisons of
single components, teams would be able to improve
their modules more speciﬁcally. To start with one
of the most important components, we have created
a benchmark for slot ﬁlling relation classiﬁcation,
based on 2012 – 2014 TAC Shared Task data.
It
will be described below and published along with
this paper.1 In addition to presenting model results
on this benchmark dataset, we also show that these
results correlate with end-to-end SF results. Hence,
optimizing a model on this dataset will also help im-
proving results in the end-to-end setting.

In our experiments, we found that our models suf-
fer from large genre differences in the TAC data.
Hence, the SF Shared Task is a task that conﬂates an

1http://cistern.cis.lmu.de

investigation of domain (or genre) adaptation with
the one of slot ﬁlling. We argue that both problems
are important NLP problems and provide datasets
and results for both within and across genres. We
hope that this new resource will encourage others
to test their models on our dataset and that this will
help promote research on slot ﬁlling.

In summary, our contributions are as follows.
(i) We investigate the complementary strengths and
weaknesses of different approaches to relation clas-
siﬁcation and show that their combination can better
deal with a diverse set of problems that slot ﬁlling
poses than each of the approaches individually. (ii)
We propose to split the context at the relation ar-
guments before passing it to the CNN in order to
better deal with the special characteristics of a sen-
tence in relation classiﬁcation. This outperforms the
state-of-the-art piecewise CNN. (iii) We analyze the
effect of genre on slot ﬁlling and show that it is an
important conﬂating variable that needs to be care-
fully examined in research on slot ﬁlling. (iv) We
provide a benchmark for slot ﬁlling relation classiﬁ-
cation that will facilitate direct comparisons of mod-
els in the future and show that results on this dataset
are correlated with end-to-end system results.

Section 2 gives an overview of related work. Sec-
tion 3 discusses the challenges that slot ﬁlling sys-
tems face. In Section 4, we describe our slot ﬁlling
models. Section 5 presents experimental setup and
results. Section 6 analyzes the results. We present
our conclusions in Section 7 and describe the re-
sources we publish in Section 8.

2 Related Work

Slot ﬁlling. The participants of the SF Shared Task
(Surdeanu, 2013) are provided with a large text cor-
pus. For evaluation, they get a collection of queries
and need to provide ﬁllers for predeﬁned relations
and an offset of a context which can serve as a justi-
ﬁcation. Most participants apply pipeline based sys-
tems. Pink et al. (2014) analyzed sources of recall
losses in these pipelines. The results of the systems
show the difﬁculty of the task: In the 2014 evalua-
tion, the top-ranked system had an F1 of .37 (Angeli
et al., 2014a). To train their models, most groups use
distant supervision (Mintz et al., 2009). The top-
ranked systems apply machine learning based ap-

proaches rather than manually developed patterns or
models (Surdeanu and Ji, 2014). The methods for
extracting and scoring candidates range from pat-
tern based approaches (Gonz`alez et al., 2012; Liu
and Zhao, 2012; Li et al., 2012; Qiu et al., 2012;
Roth et al., 2014) over rule based systems (Varma
et al., 2012) to classiﬁers (Malon et al., 2012; Roth
et al., 2013). The top ranked system from 2013
used SVMs and patterns for evaluating ﬁller candi-
dates (Roth et al., 2013); their results suggest that
n-gram based features are sufﬁcient to build reli-
able classiﬁers for the relation classiﬁcation module.
They also show that SVMs outperform patterns.

CNNs for relation classiﬁcation. Zeng et al.
(2014) and Dos Santos et al. (2015) apply CNNs to
the relation classiﬁcation SemEval Shared Task data
from 2010 and show that CNNs outperform other
models. We train CNNs on noisy distant supervised
data since (in contrast to the SemEval Shared Task)
clean training sets are not available. Malon et al.
(2012) describe a CNN for slot ﬁlling that is based
on the output of a parser. We plan to explore pars-
ing for creating a more linguistically motivated input
representation in the future.

Baseline models. In this paper, we will compare
our methods against traditional relation classiﬁca-
tion models: Mintz++ (Mintz et al., 2009; Surdeanu
et al., 2012) and MIMLRE (Surdeanu et al., 2012).
Mintz++ is a model based on the Mintz features (lex-
ical and syntactic features for relation extraction). It
was developed by Surdeanu et al. (2012) and used
as a baseline model by them. MIMLRE is a graph-
ical model designed to cope with multiple instances
and multiple labels in distant supervised data. It is
trained with Expectation Maximization.

Another baseline model which we use in this work
is a piecewise convolutional neural network (Zeng
et al., 2015). This recently published network is de-
signed especially for the relation classiﬁcation task
which allows to split the context into three parts
around the two relation arguments. While it uses
the whole context for convolution, it performs max
pooling over the three parts individually. In contrast,
we propose to split the context even earlier and ap-
ply the convolutional ﬁlters to each part separately.
Genre dependency. There are many studies
showing the genre dependency of machine learn-
ing models. In 2012, the SANCL Shared Task fo-

cused on evaluating models on web data that have
been trained on news data (Petrov and McDonald,
2012). The results show that POS tagging perfor-
mance can decline a lot when the genre is changed.
For other NLP tasks like machine translation or sen-
timent analysis, this is also a well-known challenge
and domain adaptation has been extensively stud-
ied (Glorot et al., 2011; Foster and Kuhn, 2007).
We do not investigate domain adaptation per se, but
show that the genre composition of the slot ﬁlling
source corpus poses challenges to genre independent
models.

3 Challenges of Slot Filling

Slot ﬁlling includes NLP challenges of various na-
tures. Given a large evaluation corpus, systems ﬁrst
need to ﬁnd documents relevant to the entity of
the query. This involves challenges like alternate
names for the same entity, misspellings of names
and ambiguous names (different entities with the
same name). Then for each relevant document, sen-
tences with mentions of the entity need to be ex-
tracted, as well as possible ﬁllers for the given slot.
In most cases, coreference resolution and named en-
tity recognition tools are used for these tasks. Fi-
nally, the systems need to decide which ﬁller candi-
date to output as the solution for the given slot. This
step can be reduced to relation classiﬁcation. It is
one of the most crucial parts of the whole pipeline
since it directly inﬂuences the quality of the ﬁnal
output. The most important challenges for rela-
tion classiﬁcation for slot ﬁlling are little or noisy
(distant supervised) training data, data from differ-
ent domains and test sentences which have been ex-
tracted with a pipeline of different NLP components.
Thus, their quality directly depends on the perfor-
mance of the whole pipeline. If, for example, sen-
tence splitting fails, the input can be incomplete or
too long.
If coreference resolution or named en-
tity recognition fails, the relation arguments can be
wrong or incomplete.

4 Models for Relation Classiﬁcation
Patterns. The ﬁrst approach we evaluate for rela-
tion classiﬁcation is pattern matching. For a given
sentence, the pattern matcher classiﬁes the relation
as correct if one of the patterns matches; otherwise

In particular, we apply
the candidate is rejected.
two different pattern sets: The ﬁrst set consists of
patterns learned using distant supervision (PATdist).
They have been used in the SF challenge by the top-
ranked system in the 2013 Shared Task (Roth et al.,
2013). The second set contains patterns from univer-
sal schema relations for the SF task (PATuschema).
Universal schema relations are extracted based on
matrix factorization (Riedel et al., 2013).
In this
work, we apply the universal schema patterns ex-
tracted for slot ﬁlling by Roth et al. (2014).

Support vector machines (SVMs). Our sec-
ond approach is support vector machines. We eval-
uate two different feature sets: bag-of-word fea-
tures (SVMbow) and skip n-gram features (SVM-
skip). Based on the results of Roth et al. (2013), we
will not use additional syntactic or semantic features
for our classiﬁers. For SVMbow, the representation
of a sentence consists of a ﬂag and four bag-of-word
vectors. Let m1 and m2 be the mentions of name
and ﬁller (or ﬁller and name) in the sentence, with
m1 occurring before m2. The binary ﬂag indicates
in which order name and ﬁller occur. The four BOW
vectors contain the words in the sentence to the left
of m1, between m1 and m2, to the right of m2 and
all words of the sentence. For SVMskip, we use the
previously described BOW features and additionally
a feature vector which contains skip n-gram features.
They wildcard tokens in the middle of the n-gram
(cf. Roth et al. (2013)). In particular, we use skip
3-grams, skip 4-grams and skip 5-grams. A possi-
ble skip 4-gram of the context “, founder and direc-
tor of”, for example, would be the string “founder
of”, a pattern that could not have been directly ex-
tracted from this context otherwise. We train one
linear SVM (Fan et al., 2008) for each relation and
feature set and tune parameter C on dev.

Convolutional neural networks (CNNs). CNNs
are increasingly applied in NLP (Collobert et al.,
2011; Kalchbrenner et al., 2014). They extract n-
gram based features independent of the position in
the sentence and create (sub-)sentence representa-
tions. The two most important aspects that make this
possible are convolution and pooling. Max pooling
(Collobert et al., 2011) detects the globally most rel-
evant features obtained by local convolution.

Another promising aspect of CNNs for relation
classiﬁcation is that they use an embedding based in-

put representation. With word embeddings, similar
words are represented by similar vectors and, thus,
we can recognize (near-)synonyms – synonyms of
relation triggers as well as of other important con-
text words.
If the CNN has learned, for example,
that the context “is based in” triggers the relation lo-
cation of headquarters and that “based” has a simi-
lar vector representation as “located”, it may recog-
nize the context “is located in” correctly as another
trigger for the same relation even if it has never seen
it during training. In the following paragraphs, we
describe the different variants of CNNs which we
evaluate in this paper. For each variant, we train
one binary CNN per slot and optimize the number
of ﬁlters (∈ {300, 1000, 3000}), the size of the hid-
den layer (∈ {100, 300, 1000}) and the ﬁlter width
(∈ {3, 5}) on dev. We use word2vec (Mikolov et al.,
2013) to pre-train word embeddings (dimensionality
d = 50) on a May-2014 English Wikipedia corpus.
Piecewise CNN. Our baseline CNN is the model
developed by Zeng et al. (2015). It represents the
input sentence by a matrix of word vectors, applies
several ﬁlters for convolution and then divides the
resulting n-gram representation into left, middle and
right context based on the positions m1 and m2 of
name and ﬁller (see SVM description). For each of
the three parts, one max value is extracted by pool-
ing. The results are passed to a softmax classiﬁer.

Contextwise CNN. In contrast to the piecewise
CNN, we propose to split the context before con-
volution as shown in Figure 1. Hence, similar to
our BOW vectors for the SVM, we split the origi-
nal context words into left, middle and right context.
Then, we apply convolution and pooling to each of
the contexts separately. In contrast to the piecewise
CNN, there is no convolution across relation argu-
ments. Thus, the network learns to focus on the con-
text words and cannot be distracted by the presence
of (always present) relation arguments. The ﬁlter
weights W are shared for the three contexts. Our in-
tuition is that the most important sequence features
we want to extract by convolution can appear in two
or three of the regions. Weight sharing also reduces
the number of parameters and increases robustness.
We also found in initial experiments that sharing ﬁl-
ter weights across left, middle, right outperformed
not sharing weights. The results of convolution are
pooled using k-max pooling (Kalchbrenner et al.,

ear combination of the scores of the models:

(cid:88)

qCMB =

αmqm

m=1...M

where qm is the score of model m and αm is its
weight (optimized on dev using grid search). All
weights sum to 1.

For a comparison of different combination possi-
bilities, see, for example, (Viswanathan et al., 2015).

5 Experiments and Results
5.1 Training Data
We used distant supervision for generating training
data. We created a set of (subject, relation, object)
tuples by querying Freebase (Bollacker et al., 2008)
for relations that correspond to the slot relations.
Then we scanned the following corpora for sen-
tences containing both arguments of a relation in the
tuple set: (i) the TAC source corpus (TAC, 2014), (ii)
a snapshot of Wikipedia (May 2014), (iii) the Free-
base description ﬁelds, (iv) a subset of Clueweb2,
(v) a New York Times corpus (LDC2008T19). The
resulting sentences are positive training examples.
Based on the tuple set, we selected negative exam-
ples by scanning the corpora for sentences that (i)
contain a mention of a name occurring in a tuple,
(ii) do not contain the correct ﬁller, (iii) contain a
mention different from the correct ﬁller, but with the
same named entity type (based on CoreNLP NER
(Manning et al., 2014)). All negative examples for
date slots, for instance, are sentences containing an
incorrect date.

This procedure gave us a large but noisy train-
ing set for most slots.
In order to reduce incor-
rect labels, we applied a self-training procedure: We
trained SVMs on the SF dataset created by Angeli
et al. (2014b). With the resulting SVMs, we pre-
dicted labels for our training set.
If the predicted
label did not match the distant supervised label, we
deleted the corresponding training example (Min et
al., 2012). This procedure was conducted in sev-
eral iterations on different chunks of the training set.
Finally, the SF dataset and the ﬁltered training ex-
amples were merged. (We do not use the SF dataset
directly because (i) it provides few examples per slot

2http://lemurproject.org/clueweb12

Figure 1: Contextwise CNN for relation classiﬁcation

2014): only the k = 3 maximum values of each
ﬁlter application are kept. The pooling results are
then concatenated to a single vector and extended
by a ﬂag indicating whether the name or the ﬁller
appeared ﬁrst in the sentence.

In initial experiments, we found that a fully con-
nected hidden layer after convolution and pooling
leads to a more powerful model. It connects the rep-
resentations of the three contexts and, thus, can draw
conclusions based on cooccurring patterns across
contexts. Therefore, the result vector after convolu-
tion and pooling is fed into a fully connected hidden
layer. A softmax layer makes the ﬁnal decision.

For a fair comparison of models, we also add a
hidden layer to the piecewise CNN and apply k-
max pooling there as well. Thus, the number of pa-
rameters to learn is the same for both models. We
call this model CNNpieceExt. The key difference
between CNNpieceExt and CNNcontext is the time
when the context is split into three parts: before or
after convolution. This affects the windows of words
to which the convolutional ﬁlters are applied.

Model combination (CMB). To combine a set M
of models for classiﬁcation, we perform a simple lin-

 w1   w2   …  wc-1 wc  <> wc+1  wc+2 …  w2c-1 w2c <> w2c+1w2c+2 … w3c-1w3c wordvector, case indicatork-max poolingk-max poolingk-max pooling* W* W* Wflattenflattenflatten0 | 1softmaxfully connected MLPnh hidden unitsleft contextmiddle contextright context1/0concatinput sentencesplit at relation arguments(min: 1, max: 4960) and (ii) it consists of exam-
ples for which the classiﬁers of Angeli et al. (2014b)
were indecisive, i.e., presumably contexts that are
hard to classify.) Since their contexts are similar, we
also merged city, state-or-province and country slots
to one location slot.

5.2 Evaluation Data
One of the main challenges in building and evaluat-
ing relation classiﬁcation models for SF is the short-
age of training and evaluation data. Each group has
their own datasets and comparisons across groups
are difﬁcult. Therefore, we have developed a script
that creates a clean dataset based on manually an-
notated system outputs from previous Shared Task
evaluations. In the future, it can be used by all par-
ticipants to evaluate components of their slot ﬁlling
systems.3 The script only extracts sentences that
contain mentions of both name and ﬁller.
It con-
ducts a heuristic check based on NER tags to de-
termine whether the name in the sentence is a valid
mention of the query name or is referring to another
entity. In the latter case, the example is ﬁltered out.
One difﬁculty is that many published offsets are in-
correct. We tried to match these using heuristics. In
general, we apply ﬁlters that ensure high quality of
the resulting evaluation data even if that means that
a considerable part of the TAC system output is dis-
carded.
In total, we extracted 39,386 high-quality
evaluation instances out of the 59,755 system output
instances published by TAC and annotated as either
completely correct or completely incorrect.

A table in the supplementary material4 gives
statistics: the number of positive and negative exam-
ples per slot and year (without duplicates). For 2013,
the most examples were extracted. The lower num-
ber for 2014 is probably due to the newly introduced
inference across documents. This limits the number
of sentences with mentions of both name and ﬁller.
The average ratio of positive to negative examples is
1:4. The number of positive examples per slot and
year ranges from 0 (org:member of, 2014) to 581
(per:title, 2013), the number of negative examples
from 5 (org:website, 2014) to 1886 (per:title, 2013).

3http://cistern.cis.lmu.de. We publish scripts

since we cannot distribute data.

4also available at http://cistern.cis.lmu.de

In contrast to other relation classiﬁcation bench-
marks, this dataset is not based on a knowledge
base (such as Freebase) and unrelated text (such as
web documents) but directly on the SF assessments.
Thus, it includes exactly the SF relations and ad-
dresses the challenges of the end-to-end task: noisy
data, possibly incomplete extractions of sentences
and data from different domains.

We use the data from 2012/2013 as development

and the data from 2014 as evaluation set.

5.3 Experiments
We evaluate the models described in Section 4, se-
lect the best models and combine them.

Experiments with patterns. First, we compare
the performance of PATdist and PATuschema on our
dataset. We evaluate the pattern matchers on all slots
presented in Table 1 and calculate their average F1
scores on dev. PATdist achieves a score of .35, PAT-
uschema of .33. Since it performs better, we use
PATdist in the following experiments.

Experiments with SVMs. Second, we train and
evaluate SVMbow and SVMskip. Average F1 of
SVMskip and SVMbow are .62 and .59, respec-
tively. Thus, we use SVMskip. We expected that
SVMskip beats SVMbow due to its richer feature
set, but SVMbow performs surprisingly well.

Experiments with CNNs. Finally, we compare
the performance of CNNpiece, CNNpieceExt and
CNNcontext. While the baseline network CNN-
piece (Zeng et al., 2015) achieves F1 of .52 on dev,
CNNpieceExt has an F1 score of .55 and CNNcon-
text an F1 of .60. The difference of CNNpiece and
CNNpieceExt is due to the additional hidden layer
and k-max pooling. The considerable difference
in performance of CNNpieceExt and CNNcontext
shows that splitting the context for convolution has
a positive effect on the performance of the network.
Overall results. Table 1 shows the slot wise re-
sults of the best patterns (PATdist), SVMs (SVM-
skip) and CNNs (CNNcontext). Furthermore,
it
provides a comparison with two baseline models:
Mintz++ and MIMLRE. SVM and CNN clearly out-
perform these baselines. They also outperform PAT
for almost all slots. The difference between dev and
eval results varies a lot among the slots. We suspect
that this is a result of genre differences in the data
and analyze this in Section 6.4.

per:age
per:alternate names
per:children
per:cause of death
per:date of birth
per:date of death
per:empl memb of
per:location of birth
per:loc of death
per:loc of residence
per:origin
per:parents
per:schools att
per:siblings
per:spouse
per:title
org:alternate names
org:date founded
org:founded by
org:loc of headqu
org:members
org:parents
org:subsidiaries
org:top memb empl
average

Mintz++ MIMLRE
eval
dev
.73
.84
.03
.29
.76
.48
.36
.76
1.0
.60
.45
.67
.37
.38
.56
.22
.43
.65
.18
.14
.46
.40
.64
.65
.75
.75
.66
.59
.27
.58
.49
.40
.48
.49
.73
.41
.65
.60
.13
.20
.16
.58
.17
.32
.35
.32
.35
.46
.42
.53

eval
.71
.03
.43
.42
.60
.45
.36
.22
.41
.11
.48
.59
.78
.59
.23
.39
.46
.71
.62
.19
.06
.14
.43
.44
.41

dev
.83
.29
.77
.75
.99
.67
.41
.56
.66
.15
.42
.68
.76
.64
.59
.49
.50
.42
.70
.14
.55
.36
.35
.37
.54

PATdist
eval
dev
.80
.69
.50
.50
.10
.07
.11
.44
.57
.67
.32
.30
.22
.24
.30
.30
.00
.13
.03
.10
.11
.13
.27
.38
.26
.27
.50
.14
.53
.40
.48
.42
.71
.70
.40
.47
.62
.39
.39
.30
.29
.03
.18
.31
.56
.32
.53
.46
.36
.35

SVMskip
eval
dev
.86
.74
.02
.35
.81
.68
.82
.32
1.0
.67
.54
.79
.36
.42
.59
.27
.34
.64
.33
.31
.64
.65
.79
.65
.71
.78
.68
.60
.32
.67
.48
.54
.62
.62
.70
.57
.74
.77
.43
.42
.13
.70
.20
.37
.37
.38
.55
.43
.48
.62

CNNcontext
eval
dev
.76
.83
.04
.32
.82
.61
.52
.77
.77
1.0
.48
.72
.37
.41
.59
.23
.28
.63
.23
.20
.39
.43
.65
.78
.55
.72
.70
.63
.30
.67
.57
.46
.66
.65
.71
.64
.68
.80
.43
.45
.04
.65
.16
.41
.44
.36
.43
.53
.46
.60

CMB

dev
.86
.50
.87
.82
1.0
.79
.47
.74
.70
.31
.65
.72
.79
.65
.78
.59
.72
.68
.85
.50
.76
.52
.42
.58
.68

eval
.77
.50
.76
.31
.67
.54
.39
.36
.35
.31
.59
.71
.71
.70
.57
.46
.67
.68
.77
.46
.13
.21
.49
.51
.53

Table 1: Performance on Slot Filling benchmark dataset (dev: data from 2012/2013, eval: from 2014). CMB denotes the combina-
tion of PATdist, SVMskip and CNNcontext.

Slot wise results of the other models (PAT-
uschema, SVMbow, CNNpiece, CNNpieceExt) can
be found in the supplementary material.

Comparing PAT, SVM and CNN,5 different pat-
terns emerge for different slots. Each is best on a
subset of the slots (see bold numbers). This indi-
cates that relation classiﬁcation for slot ﬁlling is not
a uniform problem: each slot has special properties
and the three approaches are good at modeling a
different subset of these properties. Given the big
differences, we expect to gain performance by com-
bining the three approaches. Indeed, CMB (PATdist
+ SVMskip + CNNcontext), the combination of the
three best performing models, obtains the best re-
sults in average (in bold).

Section 6.3 shows that the performance on our
dataset is highly correlated with SF end-to-end per-
5In prior experiments, we also compared with recurrent neu-
ral networks. RNN performance was comparable to CNNs, but
required much more training time and parameter tuning. There-
fore, we focus on CNNs in this paper. See also Vu et al. (2016).

formance. Thus, our results indicate that a combina-
tion of different models ist the most promising ap-
proach to getting good performance on slot ﬁlling.

6 Analysis
6.1 Contribution of Each Model
To see how much each model contributes to CMB,
we count how often each weight between 0.0 and
1.0 is selected for the linear interpolation. The re-
sults are plotted as a histogram (Figure 2). A weight
of 0.0 means that the corresponding model does not
contribute to CMB. We see that all three models con-
tribute to CMB for most of the slots. The CNN, for
instance, is included in the combination for 14 of 24
slots.

6.2 Comparison of CNN to Traditional Models
Our motivation for using a CNN is that convolution
and max pooling can recognize important n-grams
independent of their position in the sentence. To in-

Figure 2: # times each weight is selected in CMB

Figure 3: Analysis of convolution and pooling

vestigate this effect, we select for each CNN the top
ﬁve kernels whose activations are the most corre-
lated with the ﬁnal score of the positive class. Then
we calculate which n-grams are selected by these
kernels in the max pooling step. This corresponds to
those n-grams which are recognized by the kernel to
be the most informative for the given slot. Figure 3
shows the result for an example sentence express-
ing the slot relation org:parents. The height of a bar
is the number of times that the 3-gram around the
corresponding word was selected by k-max pooling;
e.g., the bar above “newest” corresponds to the tri-
gram “its newest subsidiary”. The ﬁgure shows that
the convolutional ﬁlters are able to learn phrases that
trigger a relation, e.g., “its subsidiary”. In contrast
to patterns, they do not rely on exact matches. The
ﬁrst reason is embeddings. They generalize similar
words and phrases by assigning similar word vectors
to them. For PAT and SVM, this type of generaliza-
tion is more difﬁcult. The second type of generaliza-
tion that the CNN learns concerns insertions, similar
to skip n-gram features. The recognition of impor-
tant phrases in convolution is robust against inser-
tions. An example is “newest” in Figure 3, a word
that is not important for the slot.

A direct comparison of results with PAT shows
that the CNN has better eval scores for about 67%
of the slots (see Table 1). Our reasoning above can
explain this. Compared to the SVM, the CNN gen-
eralizes better to unseen data in only 42% of all
cases. The fact that this does not happen in more
cases shows the power of the skip n-gram features
of the SVM: they also provide a kind of generaliza-
tion against insertions. The SVM might also need
less data to train than the CNN. Nevertheless, the

ﬁnal scores show that the CNN performs almost as
well as the SVM in average (.60 vs .62 on dev, .46 vs
.48 on eval) and contributes to a better combination
score.

6.3 Correlation with End-to-end Results
In this section, we show that using the dataset we
provide with this paper allows tuning classiﬁcation
models for the end-to-end SF task. For each model
and each possible combination of models, we cal-
culate average results on our evaluation set as well
as ﬁnal F1 scores when running the whole slot ﬁll-
ing pipeline with our in-house system. The best re-
sults of our slot ﬁlling system are an F1 of .29 on
the 2013 queries and of .25 on the 2014 queries. We
calculate Pearson’s correlation coefﬁcient to assess
correlation of relation classiﬁcation and end-to-end
performances for the n different system conﬁgura-
tions (i.e., model combinations). The correlation of
the results on our eval dataset with the SF results on
2013 queries is .89, the correlation with the SF re-
sults on 2014 queries is .82. This conﬁrms that good
results on the dataset we propose lead to good results
on the slot ﬁlling end-to-end task.

6.4 Effect of Genre and Time
The TAC source corpus consists of about 1M news
documents, 1M web documents and 100K docu-
ments from discussion forums (TAC, 2014). The
distribution of these different genres in the extracted
assessment data is as shown in Table 2.

The proportion of non-news more than doubled
from 12.5% to 26.6%. Thus, when using 2012/2013
as the development and 2014 as the test set, we are
faced with a domain adaptation problem.

 0 2 4 6 8 10 12 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1number of weight selectionPATSVMCNN 1 2 3 4Infuturequarters,<filler>'sutilitydivisionwillincludeitsnewestsubsidiary,<name>railroad.pooling resulttop 1top 3top 5news
web + forums

2014
2012/3
87.5% 73.4%
12.5% 26.6%

Table 2: Distribution of genres

In this section, we show the effect of domain dif-
ferences on our models in more detail. For our genre
analysis, we retrain our models on genre speciﬁc
training sets WEB and NEWS⊂ and show within-
genre as well as cross-genre evaluations. To avoid
performance differences due to different training set
sizes, we reduced the news training set to the same
size as the web training set. We refer to this subset
as NEWS⊂.

Cross-genre evaluation. Table 3 shows results
of testing models trained on genre-speciﬁc data: on
data of the same genre and on data of the other genre.
We present results only for a subset of relations in
this paper, however, the numbers for the other slots
follow the same trends.

Models trained on news (left part) show clearly
higher performance in the within-genre evaluation
than cross-genre. For models trained on web (right
part), this is different. We suspect that the reason
is that web data is much noiser and thus less pre-
dictable, even for models trained on web. For all
evaluations, the differences among dev and eval are
quite large. Especially for slot ﬁlling on web (bot-
tom part of Table 3), the results on dev do not seem
much related to the results on eval. This domain ef-
fect increases the difﬁculties of training robust re-
lation classiﬁcation models for slot ﬁlling.
It can
also explain why optimizing models for unseen data
(with unknown genre distributions) as in Table 1 is
challenging. Since slot ﬁlling by itself is a challeng-
ing task, even in the absence of domain differences,
we will distribute two splits: a split by year and a
split by genre. For training and tuning models for
the slot ﬁlling research challenge, the year split can
be used to cover the challenge of mixing different
genres. For experiments on domain adaptation or
genre-speciﬁc effects, our genre split can be used.

7 Conclusion

In this paper, we presented different approaches to
slot ﬁlling relation classiﬁcation: patterns, support
vector machines and convolutional neural networks.

Train on NEWS⊂
CNN
SVM

Train on WEB
CNN
SVM

ev dev

ev dev

ev dev

s
w
e
n
n
o
t
s
e
T

dev
.79 .80 .88 .87
per:age
.85 .86 .78 .78
per:children
.74 .64 .76 .71
per:spouse
.22 .32 .69 .67
org:alt names
org:loc headqu .51 .50 .53 .51
.30 .32 .29 .34
org:parents
.33 .73 .57 .83
per:age
.59 .33 .70 .33
per:children
.52 .50 .60 .57
per:spouse
.27 .19 .51 .37
org:alt names
org:loc headqu .39 .46 .43 .44
.09 .08 .11 .07
org:parents

ev
.78 .76 .85 .83
.75 .80 .00 .07
.77 .65 .73 .67
.65 .70 .66 .66
.51 .53 .53 .50
.26 .33 .30 .34
.00 .67 .57 .83
.63 .57 .00 .00
.56 .57 .67 .62
.60 .49 .56 .38
.44 .48 .36 .47
.10 .08 .15 .08
Table 3: Genre speciﬁc F1 scores. Genre speciﬁc training data
(of the same sizes). Top: news results. Bottom: web results.

b
e
w
n
o
t
s
e
T

We investigated their complementary strengths and
weaknesses and showed that their combination can
better deal with a diverse set of problems that slot
ﬁlling poses than each of the approaches individu-
ally. We proposed a contextwise CNN which out-
performs the recent state-of-the-art piecewise CNN.
Furthermore, we analyzed the effect of genre on slot
ﬁlling and showed that it needs to be carefully ex-
amined in research on slot ﬁlling. Finally, we pro-
vided a benchmark for slot ﬁlling relation classiﬁ-
cation that will facilitate direct comparisons of ap-
proaches in the future.

8 Additional Resources
We publish the scripts that we developed to extract
the annotated evaluation data and our splits by genre
and by year as well as the dev/eval splits.

Acknowledgments
Heike Adel is a recipient of the Google European
Doctoral Fellowship in Natural Language Process-
ing and this research is supported by this fellowship.
This research was also supported by Deutsche

Forschungsgemeinschaft: grant SCHU 2246/4-2.

We would like to thank Gabor Angeli for his help

with the Mintz++ and MIMLRE models.

References
[Angeli et al.2014a] Gabor Angeli, Sonal Gupta, Melvin
Jose, Christopher D. Manning, Christopher Re, Julie
Tibshirani, Jean Y. Wu, Sen Wu, and Ce Zhang.
2014a. Stanfords 2014 slot ﬁlling systems. In TAC.

[Angeli et al.2014b] Gabor Angeli,

Julie Tibshirani,
Jean Y. Wu, and Christopher D. Manning. 2014b.
Combining distant and partial supervision for relation
extraction. In EMNLP.

[Bollacker et al.2008] Kurt Bollacker, Colin Evans,
Praveen Paritosh, Tim Sturge, and Jamie Taylor.
a collaboratively created graph
2008.
In ACM
database for structuring human knowledge.
SIGMOD.

Freebase:

[Collobert et al.2011] Ronan Collobert, Jason Weston,
L´eon Bottou, Michael Karlen, Koray Kavukcuoglu,
and Pavel Kuksa. 2011. Natural language processing
(almost) from scratch. JMLR.

[Dos Santos et al.2015] C´ıcero Nogueira Dos Santos,
Bing Xiang, and Bowen Zhou. 2015. Classifying re-
lations by ranking with convolutional neural networks.
In ACL.

[Fan et al.2008] Rong-En Fan, Kai-Wei Chang, Cho-Jui
Hsieh, Xiang-Rui Wang, and Chih-Jen Lin.
2008.
LIBLINEAR: A library for large linear classiﬁcation.
JMLR.

[Foster and Kuhn2007] George Foster and Roland Kuhn.
2007. Mixture-model adaptation for SMT. In Work-
shop on SMT.

[Glorot et al.2011] Xavier Glorot, Antoine Bordes, and
Yoshua Bengio. 2011. Domain adaptation for large-
scale sentiment classiﬁcation: A deep learning ap-
proach. In ICML.

[Gonz`alez et al.2012] E. Gonz`alez,

H. Rodr´ıguez,
J. Turmo, P. R. Comas, A. Naderi, A. Ageno,
E. Sapena, M. Vila, and M. A. Mart´ı. 2012. The
TALP participation at TAC-KBP 2012. In TAC.

[Hendrickx et al.2010] Iris Hendrickx, Su Nam Kim, Zor-
nitsa Kozareva, Preslav Nakov, Diarmuid ´O S´eaghdha,
Sebastian Pad´o, Marco Pennacchiotti, Lorenza Ro-
mano, and Stan Szpakowicz. 2010. Semeval-2010
task 8: Multi-way classiﬁcation of semantic relations
between pairs of nominals. In SemEval. ACL.

[Kalchbrenner et al.2014] Nal Kalchbrenner,

Edward
Grefenstette, and Phil Blunsom. 2014. A convolu-
tional neural network for modelling sentences.
In
ACL.

[Li et al.2012] Yan Li, Sijia Chen, Zhihua Zhou, Jie Yin,
Hao Luo, Liyin Hong, Weiran Xu, Guang Chen, and
Guo Jun. 2012. PRIS at TAC 2012 KBP track.
In
TAC.

[Liu and Zhao2012] Fang Liu and Jun Zhao.

2012.
Sweat2012: Pattern based English slot ﬁlling system
for knowledge base population at TAC 2012. In TAC.

[Malon et al.2012] Christopher Malon, Bing Bai, and
Kazi Saidul Hasan. 2012. Slot-ﬁlling by substring
extraction at TAC KBP 2012 (team papelo). In TAC.

John Bauer,

[Manning et al.2014] Christopher D. Manning, Mihai
Jenny Finkel, Steven J.
Surdeanu,
Bethard, and David McClosky. 2014. The Stanford
CoreNLP natural language processing toolkit. In ACL:
System Demonstrations.

[Mikolov et al.2013] Tomas Mikolov, Kai Chen, Greg
Corrado, and Jeffrey Dean. 2013. Efﬁcient estimation
of word representations in vector space. In Workshop
at ICLR.

[Min et al.2012] Bonan Min, Xiang Li, Ralph Grishman,
and Ang Sun. 2012. New york university 2012 system
for KBP slot ﬁlling. In TAC.

[Mintz et al.2009] Mike Mintz, Steven Bills, Rion Snow,
and Dan Jurafsky. 2009. Distant supervision for rela-
tion extraction without labeled data. In ACL-IJCNLP.
[Petrov and McDonald2012] Slav Petrov and Ryan Mc-
Donald. 2012. Overview of the 2012 shared task on
parsing the web. In SANCL.

[Pink et al.2014] Glen Pink, Joel Nothman, and James R
Curran. 2014. Analysing recall loss in named entity
slot ﬁlling. In EMNLP.

[Qiu et al.2012] Xin Ying Qiu, Xiaoting Li, Weijian Mo,
Manli Zheng, and Zhuhe Zheng. 2012. GDUFS at slot
ﬁlling TAC-KBP 2012. In TAC.

[Riedel et al.2013] Sebastian Riedel, Limin Yao, Andrew
McCallum, and Benjamin M Marlin. 2013. Rela-
tion extraction with matrix factorization and universal
schemas. In HLT-NAACL.

[Roth et al.2013] Benjamin Roth, Tassilo Barth, Michael
Wiegand, Mittul Singh, and Dietrich Klakow. 2013.
Effective slot ﬁlling based on shallow distant supervi-
sion methods. In TAC.

[Roth et al.2014] Benjamin Roth, Emma Strubell, John
Sullivan, Lakshmi Vikraman, Kate Silverstein, and
Andrew McCallum. 2014. Universal schema for slot-
ﬁlling, cold-start KBP and event argument extraction:
UMAss IESL at TAC KBP 2014. In TAC.

[Surdeanu and Ji2014] Mihai Surdeanu and Heng Ji.
2014. Overview of the English slot ﬁlling track at the
TAC 2014 knowledge base population evaluation. In
TAC.

[Surdeanu et al.2012] Mihai Surdeanu, Julie Tibshirani,
Ramesh Nallapati, and Christopher D Manning. 2012.
Multi-instance multi-label learning for relation extrac-
tion. In EMNLP-CoNLL.

[Surdeanu2013] Mihai Surdeanu. 2013. Overview of the
TAC 2013 knowledge base population evaluation: En-
glish slot ﬁlling and temporal slot ﬁlling. In TAC.

[TAC2014] TAC. 2014. Task description for English slot
ﬁlling at TAC KBP 2014. http://surdeanu.

info/kbp2014/KBP2014_TaskDefinition_
EnglishSlotFilling_1.1.pdf.

[Varma et al.2012] Vasudeva Varma, Bhaskar Ghosh, Mo-
han Soundararajan, Deepti Aggarwal, and Priya Rad-
hakrishnan. 2012. IIIT Hyderabad at TAC 2012. In
TAC.

[Viswanathan et al.2015] Vidhoon

Viswanathan,
Nazneen Fatema Rajani, Yinon Bentor, and Raymond
Mooney. 2015. Stacked ensembles of information
extractors for knowledge-base population. In ACL.

[Vu et al.2016] Ngoc Thang Vu, Heike Adel, Pankaj
Gupta, and Hinrich Sch¨utze. 2016. Combining re-
current and convolutional neural networks for relation
classiﬁcation. In HLT-NAACL.

[Zeng et al.2014] Daojian Zeng, Kang Liu, Siwei Lai,
Guangyou Zhou, and Jun Zhao. 2014. Relation clas-
siﬁcation via convolutional deep neural network.
In
COLING.

[Zeng et al.2015] Daojian Zeng, Kang Liu, Yubo Chen,
and Jun Zhao. 2015. Distant supervision for rela-
tion extraction via piecewise convolutional neural net-
works. In EMNLP.

