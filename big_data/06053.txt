6
1
0
2

 
r
a

 

M
2
2

 
 
]

B
D
.
s
c
[
 
 

2
v
3
5
0
6
0

.

3
0
6
1
:
v
i
X
r
a

Negation in SPARQL

Renzo Angles1 and Claudio Gutierrez2

1 Dept. of Computer Science, Universidad de Talca, Chile
2 Dept. of Computer Science, Universidad de Chile, Chile

Abstract. This paper presents a thorough study of negation in SPARQL.
The types of negation supported in SPARQL are ﬁrstly formalized and
their main features discussed. Then, we study the expressive power of
the corresponding negation operators. At this point, we identiﬁed a sim-
ple and minimal SPARQL algebra which could be used, instead of the
original SPARQL algebra, to implement the graph pattern operations.
Finally, we analyze the negation operators in terms of their compliance
with elementary axioms of set theory.

1

Introduction

The notion of negation has been largely studied in database query languages,
mainly due to their implications in aspects of expressive power and computa-
tional complexity [7,8,9,14,18]. There have been proposed several and distinct
types of negations, and it seems diﬃcult to get agreement about a standard
one. Such heterogeneity comes from intrinsic properties and semantics of each
language, features that determine its ability to support speciﬁc type(s) of nega-
tion(s). For instance, rule-based query languages (e.g. Datalog) usually imple-
ment “negation by failure”, algebraic query languages (e.g. the relational alge-
bra) usually include a Boolean-like diﬀerence operator, and SQL-like query lan-
guages support several versions of negation, and operators that combine negation
with subqueries (e.g. NOT EXISTS).

The case of SPARQL is no exception. SPARQL 1.0 did not had any explicit
form of negation in its syntax, but could simulate negation by failure. For the
next version, SPARQL 1.1, the incorporation of negation generated a lot of
debate. As result, SPARQL 1.1 provides four types of negation: negation of
ﬁlter constraints, by using the Boolean NOT operator (!); negation as failure,
implemented as the combination of an optional graph pattern and the bound
operator; diﬀerence of graph patterns, expressed by the MINUS operator; and
existential negation of graph patterns, expressed by the NOT-EXISTS operator.
The main positive and negative aspects of these types of negation are re-
marked in the SPARQL speciﬁcations, and more detailed discussions are avail-
able in the records of the SPARQL working group3. However, to the best of our
knowledge, there exists no formal study about negation in SPARQL. This is the
goal we tackle throughout this document.

3 https://www.w3.org/2009/sparql/wiki/Design:Negation

In this paper we present a thorough study of negation in SPARQL. First, we
formalize the syntax and semantics of the diﬀerent types of negation supported
in SPARQL, and discuss their main features. Then, we study the relationships
(in terms of expressive power) among the negation operators, ﬁrst at the level of
the SPARQL algebra, and subsequently at the level of SPARQL graph patterns.
Finally, we present a case-by-case analysis of the negation operations with respect
to their compliance with elementary axioms of set theory.

It would be good to have a simple version of negation operators that conform
to a know intuition. This is the other main contribution of this paper. First
we introduce the DIFF operator as another way of expressing the negation of
graph patterns (it is the SPARQL version of the EXCEPT operator of SQL).
The semantics of DIFF is based on a simple diﬀerence operator introduced at
the level of the SPARQL algebra. With this new diﬀerence operator, we show
that one can deﬁne a minimal algebra (i.e. projection, selection, join, union and
simple diﬀerence) which is able to express the original SPARQL algebra. We
show that this algebra is also able to deﬁne the SPARQL operators, thus it can
be considered a sort of “core” SPARQL algebra. Additionally, we show that the
DIFF operator behaves well regarding its compliance with well known axioms
of set theory.

Organization of the paper. The syntax and semantics of SPARQL graph patterns
are presented in Section 2. In Section 3, we discuss the main characteristics of the
types of negation supported by SPARQL. The expressive power of the negation
operators is studied in Section 4. In Section 5, we analyze set-theoretic properties
of two negation operators. Finally, some conclusions are presented in Section 6.

2 SPARQL graph patterns

The deﬁnition of SPARQL graph patterns will be presented by using the formal-
ism presented in [15], but in agreement with the W3C speciﬁcations of SPARQL
1.0 [16] and SPARQL 1.1 [10]. Particularly, graph patterns will be studied as-
suming bag semantics (i.e. allowing duplicates in solutions).

RDF graphs. Assume two disjoint inﬁnite sets I and L, called IRIs and literals
respectively. An RDF term is an element in the set T = I ∪ L4. An RDF triple is
a tuple (v1, v2, v3) ∈ (I ∪ B) × I × T where v1 is the subject, v2 the predicate and
v3 the object. An RDF Graph (just graph from now on) is a set of RDF triples.
The union of graphs, G1 ∪ G2, is the set theoretical union of their sets of triples.
Additionally, assume the existence of an inﬁnite set V of variables disjoint from
T . We will use var(α) to denote the set of variables occurring in the structure α.

4 In addition to I and L, RDF and SPARQL consider a domain of anonymous resources
called blank nodes. The occurrence of blank nodes introduces several issues that are
not discussed in this paper. Based on the results presented in [11], we avoid the
use of blank nodes assuming that their absence does not largely aﬀect the results
presented in this paper.

p

q

true

p ∧ q p ∨ q
true
true
true
true
true
true
false false
true
true error error
false
false
true
false false false false
false error false error
error
true
error false false error
error error error error

true error

p

¬p
false
true
true
false
error error

Table 1. Three-valued logic for evaluating selection formulas.

A solution mapping (or just mapping from now on) is a partial function
µ : V → T where the domain of µ, dom(µ), is the subset of V where µ is deﬁned.
The empty mapping, denoted µ0, is the mapping satisfying that dom(µ0) = ∅.
Given ?X ∈ V and c ∈ T , we use µ(?X) = c to denote the solution mapping
variable ?X to term c. Assigning the expression µ?X→c denotes a mapping such
that dom(µ) = {?X} and µ(?X) = c. Given a ﬁnite set of variables W ⊂ V , the
restriction of a mapping µ to W , denoted µ|W , is a mapping µ′ satisfying that
dom(µ′) = dom(µ) ∩ W and µ′(?X) = µ(?X) for every ?X ∈ dom(µ) ∩ W . Two
mappings µ1, µ2 are compatible, denoted µ1 ∼ µ2, when for all ?X ∈ dom(µ1) ∩
dom(µ2) it satisﬁes that µ1(?X) = µ2(?X), i.e., when µ1 ∪ µ2 is also a mapping.
Note that two mappings with disjoint domains are always compatible, and that
the empty mapping µ0 is compatible with any other mapping.

A selection formula is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I ∪ L then (?X = c), (?X =?Y ) and bound(?X) are atomic selection
formulas; (ii) If F and F ′ are selection formulas then (F ∧ F ′), (F ∨ F ′) and
¬(F ) are boolean selection formulas. The evaluation of a selection formula F
under a mapping µ, denoted µ(F ), is deﬁned in a three-valued logic (i.e. with
values true, false, and error) as follows:

– If F is ?X = c and ?X ∈ dom(µ), then µ(F ) = true when µ(?X) = c and

µ(F ) = false otherwise. If ?X /∈ dom(µ) then µ(F ) = error.

– If F is ?X =?Y and ?X, ?Y ∈ dom(µ), then µ(F ) = true when µ(?X) =
µ(?Y ) and µ(F ) = false otherwise. If either ?X /∈ dom(µ) or ?Y /∈ dom(µ)
then µ(F ) = error.

– If F is bound(?X) and ?X ∈ dom(µ) then µ(F ) = true else µ(F ) = false.
– If F is a complex selection formula then it is evaluated following the three-

valued logic presented in Table 1.

We say that a mapping µ satisﬁes a selection formula F , denoted µ ⊢ F , iﬀ
µ(F ) = true. On the contrary, we use µ 0 F when µ(F ) = false or µ(F ) = error.
A multiset (or bag) of solution mappings is an unordered collection in which
each solution mapping may appear more than once. A multiset will be repre-
sented as a set of solution mappings, each one annotated with a positive integer

which deﬁnes its multiplicity (i.e. its cardinality). We use the symbol Ω to denote
a multiset and card(µ, Ω) to denote the cardinality of the mapping µ in the multi-
set Ω. In this sense, it applies that card(µ, Ω) = 0 when µ /∈ Ω. We use Ω0 to de-
note the multiset {µ0} such that card(µ0, Ω0) > 0 (Ω0 is called the join identity).
The domain of a solution mapping Ω is deﬁned as dom(Ω) = Sµ∈Ω dom(µ).

SPARQL algebra. Let Ω1, Ω2 be multisets of mappings, W be a set of variables
and F be a selection formula. The SPARQL algebra for multisets of mappings
is composed of the operations of projection, selection, join, diﬀerence, left-join,
union and minus, deﬁned respectively as follows:
– πW (Ω1) = {µ′ | µ ∈ Ω1, µ′ = µ|W }
where card(µ′, πW (Ω1)) = Pµ′=µ|W

card(µ, Ω1)

– σF (Ω1) = {µ ∈ Ω1 | µ ⊢ F }

where card(µ, σF (Ω1)) = card(µ, Ω1)

– Ω1 ⋊⋉ Ω2 = {µ = (µ1 ∪ µ2) | µ1 ∈ Ω1, µ2 ∈ Ω2, µ1 ∼ µ2}

where card(µ, Ω1 ⋊⋉ Ω2) = Pµ=(µ1∪µ2) card(µ1, Ω1) × card(µ2, Ω2)

– Ω1 \F Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, (µ1 ≁ µ2) ∨ (µ1 ∼ µ2 ∧ (µ1 ∪ µ2) 0 F )}

where card(µ1, Ω1 \F Ω2) = card(µ1, Ω1)

– Ω1 ∪ Ω2 = {µ | µ ∈ Ω1 ∨ µ ∈ Ω2}

where card(µ, Ω1 ∪ Ω2) = card(µ, Ω1) + card(µ, Ω2)

– Ω1 − Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2 ∨ dom(µ1) ∩ dom(µ2) = ∅}

where card(µ1, Ω1 − Ω2) = card(µ1, Ω1)
– Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \F Ω2)

where card(µ, Ω1qy⋊⋉ F Ω2) = card(µ, σF (Ω1 ⋊⋉ Ω2)) + card(µ, Ω1 \F Ω2)

Syntax of SPARQL graph patterns. A SPARQL graph pattern is deﬁned recur-
sively as follows:

– A tuple from (I ∪ L ∪ V ) × (I ∪ V ) × (I ∪ L ∪ V ) is a graph pattern called a

triple pattern. 5

– If P1 and P2 are graph patterns then (P1 AND P2), (P1 UNION P2),

(P1 OPT P2), (P1 MINUS P2) and (P1 NOT-EXISTS P2) are graph patterns.
– If P1 is a graph pattern and C is a ﬁlter constraint (as deﬁned below) then

(P1 FILTER C) is a graph pattern.

A ﬁlter constraint is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I ∪L then (?X = c), (?X =?Y ) and bound(?X) are atomic ﬁlter constraints;
(ii) If C1 and C2 are ﬁlter constraints then (!C1), (C1 || C2) and (C1 && C2)
are complex ﬁlter constraints. Given a ﬁlter constraint C, we denote by f (C) the
selection formula obtained from C. Note that there exists a simple and direct
translation from ﬁlter constraints to selection formulas and viceversa.

Given a triple pattern t and a mapping µ such that var(t) ⊆ dom(µ), we
denote by µ(t) the triple obtained by replacing the variables in t according
to µ. Overloading the above deﬁnition, we denote by µ(P ) the graph pattern
obtained by the recursive substitution of variables in every triple pattern and
ﬁlter constraint occurring in the graph pattern P according to µ.

5 We assume that any triple pattern contains at least one variable.

Semantics of SPARQL graph patterns. The evaluation of a SPARQL graph pat-
tern P over an RDF graph G is deﬁned as a function JP KG (or JP K where G
is clear from the context) which returns a multiset of solution mappings. Let
P1, P2, P3 be graph patterns and C be a ﬁlter constraint. The evaluation of a
graph pattern P over a graph G is deﬁned recursively as follows:

1. If P is a triple pattern t, then JP KG = {µ | dom(µ) = var(t) ∧ µ(t) ∈ G}

where each mapping µ has cardinality 1.

2. J(P1 AND P2)KG = JP1KG ⋊⋉ JP2KG
3. If P is (P1 OPT P2) then

(a) if P2 is (P3 FILTER C) then JP KG = JP1KGqy⋊⋉ C JP3KG
(b) else JP KG = JP1KGqy⋊⋉

(true)JP2KG
4. J(P1 MINUS P2)KG = JP1KG − JP2KG
5. J(P1 NOT-EXISTS P2)KG = {µ | µ ∈ JP1KG ∧ Jµ(P2)KG = ∅}
6. J(P1 UNION P2)KG = JP1KG ∪ JP2KG
7. J(P1 FILTER C)KG = {µ | µ ∈ JP1KG ∧ µ ⊢ f (C)}

3 Types of negation in SPARQL

We can distinguish four types of negation in SPARQL: negation of ﬁlter con-
straints, negation as failure, negation by MINUS and negation by NOT-EXISTS.
The main features of these types of negation will be discussed in this section.

Negation of ﬁlter constraints. The most basic type of negation in SPARQL
is the one allowed in ﬁlter graph patterns by including constraints of the form
(!C). Following the semantics of SPARQL, a graph pattern (P FILTER(!C)),
returns the mappings µ in JP K such that µ satisﬁes the ﬁlter constraint (!C), i.e.
µ does not satisfy the constraint C.

Considering that the evaluation of a graph pattern could return mappings
with unbound variables (similar to NULL values in SQL), SPARQL uses a three-
valued logic for evaluating ﬁlter graph patterns, i.e. the evaluation of a ﬁlter
constraint C can result in true, false or error. For instance, given a mapping µ,
the constraint ?X = 1 evaluates to true when µ(?X) = 1, false when µ(?X) 6= 1,
and error when ?X /∈ dom(µ). Note that FILTER eliminates any solutions that
result in false or error. Recalling the semantics deﬁned in Table 1, we have that
(!C) evaluates to true when C is false, false when C is true, and error when C
is error. This type of negation, called strong negation [19], allows to deal with
incomplete information in a similar way to the NOT operator of SQL.

The negation of ﬁlter constraints is a feature well stablished in SPARQL and
does not deserve major discussion. In the rest of the paper we concentrate our
interest on the negation of graph patterns.

Negation as failure. SPARQL 1.0 does not include an operator to express
the negation of graph patterns. In an intent of patching this issue, the SPARQL
speciﬁcation remarks that the negation of graph patterns can be implemented as

a combination of an optional graph pattern and a ﬁlter constraint containing the
bound operator (see [16], Sec. 11.4.1). This style of negation, called negation as
failure in logic programming, can be illustrated as a graph pattern P of the form
((P1 OPT P2) FILTER(! bound(?X))) where ?X is a variable of P2 not occurring
in P1. Note that, the evaluation of P returns the mappings of J(P1 OPT P2)K
satisfying that variable ?X is unbounded, i.e. ?X does not match P2. In other
words, P returns “the solution mappings of P1 that are not compatible with the
solutions mappings of P2”.

Unfortunately, there are two issues with the above approach. (i) ?X cannot be
an arbitrary variable (e.g. P2 could be in turn an optional pattern (P3 OPT P4)
where only variables in P3 are useful to check); (ii) There may be no variable to
check unboundedness (i.e. when var(P1) ∩ var(P2) = ∅). These and other issues
were presented in [5]. A general solution is included in the Appendix.

In order to facilitate the study of negation by failure in SPARQL, we intro-

duce the operator DIFF as an explicit way of expressing it.

Deﬁnition 1 (DIFF). Let P1 and P2 be graph patterns. The DIFF operator is
deﬁned as J(P1 DIFF P2)K = {µ1 ∈ JP1K | ∀µ2 ∈ JP2K,µ1 ≁ µ2}.

It is very important to note that the DIFF operator is not deﬁned in SPARQL
1.0 nor in SPARQL 1.1. However, it can be directly implemented with the dif-
ference operator of the algebra of solution mappings.

Negation by MINUS. SPARQL 1.1 introduced the MINUS operator as an ex-
plicit way of expressing the negation (or diﬀerence) of graph patterns. Note that
DIFF and MINUS have similar deﬁnitions. The diﬀerence is given by the restric-
tion about disjoint mappings included by the MINUS operator. Such restriction,
named Antijoin Restriction inside the SPARQL working group6, was introduced
to avoid solutions with vacuously compatible mappings. Such restriction causes
diﬀerence results for DIFF and MINUS. Basically, if P1 and P2 do not have vari-
ables in common then J(P1 DIFF P2)K = ∅ whereas J(P1 MINUS P2)K = JP1K.

Note that both, DIFF and MINUS resemble the EXCEPT operator of SQL[13],
i.e. given two SQL queries Q1 and Q2, the expression (Q1 EXCEPT Q2) allows
to return all rows that are in the table obtained from Q1 except those that
also appear in the table obtained from Q2. Considering that EXCEPT makes
reference to the diﬀerence of two relations (tables), we can say that DIFF and
MINUS allow to express the diﬀerence of two graph patterns.

Negation by NOT-EXISTS. Another type of negation deﬁned in SPARQL
1.1 is given by the NOT-EXISTS operator. The main feature of this type of
negation is the possible occurrence of correlation. Given a graph pattern P =
(P1 NOT-EXISTS P2), we will say that P1 and P2 are correlated when var(P1) ∩
var(P2) 6= ∅, i.e. there exist variables occurring in both P1 and P2, and such

6 http://lists.w3.org/Archives/Public/public-rdf-dawg/2009JulSep/0030.html

variables are called correlated variables. In this case, the evaluation of P is at-
tained by replacing variables in P2 with the corresponding values given by the
current mapping µ of JP1K, and testing whether the evaluation of the graph
pattern µ(P2) returns no solutions. This way of evaluating correlated queries is
based on the nested iteration method [12] of SQL. The correlation of variables
in NOT-EXISTS introduces several issues that have been studied in the context
of subqueries in SPARQL [3,4]. Some of these issues are discussed in Section 4.2.
DIFF, MINUS and NOT-EXISTS are three diﬀerent ways of expressing nega-
tion in SPARQL. DIFF and MINUS represent the diﬀerence of two graph pat-
terns whereas NOT-EXISTS tests the presence of a graph pattern.

4 Expressive Power

Let us recall some deﬁnitions related to expressive power. By the expressive
power of a query language, we understand the set of all queries expressible in
that language [1]. We will say that an operator O is expressible in a language L
iﬀ a subset of the operators of L allow to express the same queries as O. Finally,
a language L contains a language L′ iﬀ every operator of L′ is expressible by L.
In this section, we study the expressive power of SPARQL and its types of
negation. First, we introduce a “core” algebra of multisets of mappings which
contains the original SPARQL algebra, but having the advantage of being simple
and minimal. Such core algebra is used later to study the expressiveness of the
SPARQL operators.

4.1 The core SPARQL algebra

Let us introduce a core algebra for SPARQL which is simple and minimal. This
algebra is simple because it is based on basic and standard operations, and
minimal because such set of operations is enough to express all the high-level
operators of the SPARQL language. We will prove that such core algebra contains
the original SPARQL algebra.

Recall that the SPARQL algebra, deﬁned in Section 2, is composed by the op-
erators of projection, selection, join, union, left-join and minus. Our core algebra
is based on a new operator called “simple diﬀerence”.

Deﬁnition 2 (Simple diﬀerence). The simple diﬀerence between two solution
mappings, Ω1 and Ω2, is deﬁned as Ω1 \ Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2}
where card(µ1, Ω1 \ Ω2) = card(µ1, Ω1).

Deﬁnition 3 (Core SPARQL algebra). The core SPARQL algebra is com-
posed by the operations of projection, selection, join, union and simple diﬀerence.

Next, we will show that the core SPARQL algebra contains the original
SPARQL algebra. Speciﬁcally, we will show that the operators of diﬀerence,
left-join and minus (of the SPARQL algebra) can be simulated with the simple
diﬀerence operator (of the core SPARQL algebra).

Lemma 1. The diﬀerence operator (of the SPARQL algebra) is expressible in
the core SPARQL algebra.

Proof. Recall that the diﬀerence operator is deﬁned as
Ω1 \F Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, (µ1 ≁ µ2) ∨ (µ1 ∼ µ2 ∧ (µ1 ∪ µ2) 0 F )}.
According to the SPARQL 1.1 speciﬁcation (see the full deﬁnition of LeftJoin in
Sec.18.5), Ω1 \F Ω2 can be redeﬁned as the union of two sets:
{µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2} and
{µ1 ∈ Ω1 | ∃µ2 ∈ Ω2, µ1 ∼ µ2 ∧ (µ1 ∪ µ2) 0 F }.
Note that the ﬁrst set corresponds exactly to (Ω1 \ Ω2). Additionally, the second
set can be simulated with the expression (Ω1 \ (Ω1 \ (σ¬F (Ω1 ⋊⋉ Ω2)))). Hence,
we have that

Ω1 \F Ω2 = (Ω1 \ Ω2) ∪ (Ω1 \ (Ω1 \ (σ¬F (Ω1 ⋊⋉ Ω2)))).

Lemma 2. The left-join operator (of the SPARQL algebra) is expressible in the
core SPARQL algebra.

Proof. Recall the left-join operator is deﬁned as
Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \F Ω2).
Considering that the diﬀerence expression (Ω1 \F Ω2) can be expressed with
simple diﬀerence (Lemma 1), we have that

Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ ((Ω1 \ Ω2) ∪ (Ω1 \ (Ω1 \ (σ¬F (Ω1 ⋊⋉ Ω2))))).

Lemma 3. The minus operator (of the SPARQL algebra) is expressible in the
core SPARQL algebra.

Proof. Note that the diﬀerence between Ω1 − Ω2 and Ω1 \ Ω2 is given by the
condition dom(µ1) ∩ dom(µ2) = ∅. Intuitively, it applies that (Ω1 − Ω2) = Ω1
when dom(Ω1) ∩ dom(Ω2) = ∅. In the case that dom(Ω1) ∩ dom(Ω2) 6= ∅, the
rewriting is a little more tricky.

Recall that the operation Ω1 − Ω2 is deﬁned by the set

S = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2 ∨ dom(µ1) ∩ dom(µ2) = ∅}.
Note that the complement of S in Ω1 is the set
Sc = {µ1 ∈ Ω1 | ∃µ2 ∈ Ω2, µ1 ∼ µ2 ∧ dom(µ1) ∩ dom(µ2) 6= ∅}.
Assuming that dom(Ω1) ∩ dom(Ω2) = {?X1, . . . , ?Xn}, (Ω1 − Ω2) can be simu-
lated with an expression of the form Ω1 \ (σF (Ω1 ⋊⋉ Ω3)) where Ω3 is a copy of
Ω2 where every variable Xi has been replaced with a free variable X ′
i, and F is
a selection formula of the form (. . . (?X1 =?X ′
n).
Note that, the expression σF (Ω1 ⋊⋉ Ω3) returns the set Sc, which is subtracted
from Ω1 to obtain S. It is easy to see that the proposed equivalent expression pre-
serves the cardinalities. Hence, we have proved that (Ω1 − Ω2) can be simulated
with (Ω1 \ Ω2).

2) . . . )∧?Xn =?X ′

1∧?X2 =?X ′

Based on Lemmas 1, 2 and 3, we can present our main result about the

expressive power of the core SPARQL algebra.

Theorem 1. The core SPARQL algebra contains the original SPARQL algebra.

This result implies that the original SPARQL algebra could be implemented
by a subset of the original operators (projection, selection, join and union), plus
the simple diﬀerence operator.

4.2 SPARQLDIFF: A core fragment with negation

Let us redeﬁne the DIFF operator by using the simple diﬀerence operator of the
core algebra as follows:

J(P1 DIFF P2)K = JP1K \ JP2K.

Assume that SPARQLDIFF is the language deﬁned (recursively) by graph pat-
terns of the form (P AND P ′), (P UNION P ′), (P DIFF P ′) and (P FILTER C).
Next, we will show that SPARQLDIFF can express a fragment of SPARQL whose
NOT-EXISTS graph patterns satisfy a restricted notion of correlated variables.

Expressing OPTIONAL and MINUS with DIFF Here, we show that the
OPT and MINUS operators can be expressed in SPARQLDIFF by using the DIFF
operator.

Lemma 4. The OPT operator is expressible in SPARQLDIFF.

Proof. Recall the semantics of optional graph patterns as presented in Section
2. Given a graph pattern P of the form (P1 OPT P2), we have two cases:
(i) if P2 is (P3 FILTER C) then JP K = JP1Kqy⋊⋉ C JP3K;
(ii) else, JP K = JP1Kqy⋊⋉
Note that this deﬁnition follows an operational semantics in the sense that the
evaluation of (P1 OPT P2) depends on the structure of P2, i.e. when P2 is a ﬁlter
graph pattern applies case (i), otherwise case (ii) . Let us analyze both cases.

(true)JP2K.

Case (i): We have that JP1Kqy⋊⋉ CJP3K = σF (Ω1 ⋊⋉ Ω3) ∪ (Ω1 \F Ω3) where
Ω1 = JP1K, Ω3 = JP3K and F = f (C). If we rewrite the expression (Ω1 \F Ω3)
using simple diﬀerence (Lemma 2), we obtain the expression
σF (Ω1 ⋊⋉ Ω3) ∪ ((Ω1 \ Ω3) ∪ (Ω1 \ (Ω1 \ (σ¬F (Ω1 ⋊⋉ Ω3))))).
Similarly, the graph pattern (P1 OPT(P3 FILTER C)) can be rewritten as

(((P1 AND P3) FILTER C) UNION
((P1 DIFF P3) UNION(P1 DIFF(P1 DIFF((P1 AND P3) FILTER(!C)))))).

Case (ii): We have that JP1Kqy⋊⋉

(true)JP2K = σ(true)(Ω1 ⋊⋉ Ω2) ∪ (Ω1 \(true) Ω2)
where Ω1 = JP1K and Ω2 = JP2K. According to the SPARQL 1.1 speciﬁcation
(see the full deﬁnition of LeftJoin in Sec.18.5), the expression Ω1 \(true) Ω2 can
be expressed as the union of the sets {µ1 ∈ Ω1 | ∀µ2 ∈ JP2K,µ1 ≁ µ2} and
{µ1 ∈ Ω1 | ∃µ2 ∈ JP2K,µ1 ∼ µ2 ∧(µ1 ∪µ2) 0 true}, where the ﬁrst set corresponds
to (Ω1 \ Ω2) and the second set will always be empty. Hence, JP1Kqy⋊⋉
(true)JP2K =
(Ω1 ⋊⋉ Ω2) ∪ (Ω1 \ Ω2), and consequently ((P1 OPT P2) FILTER(true)) can be
rewritten as ((P1 AND P2) UNION(P1 DIFF P2)).

Hence, we can use the above transformation to simulate the operational se-

mantics of OPT by using DIFF, i.e. OPT is expressible in SPARQLDIFF.

Lemma 5. The MINUS operator is expressible in SPARQLDIFF.

Proof. Given a graph pattern (P1 MINUS P2), we have that:
(i) If var(P1) ∩ var(P2) = ∅ then J(P1 MINUS P2)K = JP1K.
(ii) Else, J(P1 MINUS P2)K = Ω1 − Ω2 where Ω1 = JP1K and Ω2 = JP2K.
Recalling the simulation of (Ω1 − Ω2) with (Ω1 \ Ω2) presented in Lemma 3,
we have that (P1 MINUS P2) can be rewritten to a graph pattern of the form
(P1 DIFF((P1 AND P3) FILTER C)) where P3 and C must be created by follow-
ing a procedure similar to the one described in Lemma 3. Hence, we have proved
that MINUS can be expressed in SPARQLDIFF.

Expressing NOT-EXISTS with DIFF In order to give a basic idea of the
expressive power of NOT-EXISTS, we will analyze its relationship with the
DIFF operator. Given the graph patterns P = (P1 NOT-EXISTS P2) and P ′ =
(P1 DIFF P2), the basic case of equivalence between P and P ′ is given when
var(P1) ∩ var(P2) = ∅. Note that, the non occurrence of correlated variables
between P1 and P2 implies that, both P and P ′ are restricted to test whether
P2 returns an empty solution. In spite of this equivalence, there are cases where
P and P ′ are not equivalent.

Lemma 6. The NOT-EXISTS operator is not expressible in SPARQLDIFF.

Proof. We can provide a counter example to show that NOT-EXISTS allows to
express queries which are not supported in SPARQLDIFF . Assume a database
of persons and their ages. The following graph pattern returns the persons with
the highest age (i.e. it simulates the MAX aggregate operator of SPARQL 1.1):

((?X :age ?A) NOT-EXISTS ((?Y :age ?B)

FILTER (!(?Y = ?X) && (?B >?A))).

Note that this query cannot be expressed in SPARQLDIFF, in particular by using
the DIFF operator. The key point is that the correlation of variables allows to
ﬁlter the mappings in the second graph pattern, which will be used to evaluate
the current mapping of the ﬁrst pattern. In contrast, in the DIFF operator,
each mapping of the ﬁrst graph pattern is evaluated against all the mappings of
the second graph pattern. In other words, the correlation of variables allows a
selective negation of mappings.

Despite the above negative result, it will be interesting to identify a subset of
NOT-EXISTS graph patterns that can expressed by using the DIFF operator.
Such fragment will be called SPARQLNEX and is deﬁned as follows.

Deﬁnition 4 (SPARQLNEX). Let us deﬁne SPARQLNEX as the fragment of
SPARQL where each graph pattern of the form (P NOT-EXISTS P ′) satisﬁes
the following conditions:

1. For each graph pattern of the form (P1 NOT-EXISTS P2), (P1 MINUS P2)
or (P1 OPT P2) occurring in P ′, it satisﬁes that every correlated variable
occurring in P2 also occurs in P1;

2. For each graph pattern of the from (P1 UNION P2) occurring in P ′, it satis-

ﬁes that every correlated variable occurs in both P1 and P2;

3. For each graph pattern of the form (P1 FILTER C) occurring in P ′, it satis-

ﬁes that every correlated variable occurring in C also occurs in P1.

Note that, SPARQLNEX does not allow graph patterns of the form

(P1 NOT-EXISTS(P2 NOT-EXISTS P3)) where P3 contains correlated variables
occurring in P1 but not occurring in P2. That is, the correlated variables of a
graph pattern must be in the scope of the immediate outer NOT-EXISTS graph
pattern where they are declared. Now, we can establish the relationship between
this fragment of NOT-EXISTS graph patterns and the DIFF operator.

Lemma 7. The NOT-EXISTS graph patterns allowed in SPARQLNEX are ex-
pressible in SPARQLDIFF.

Proof. Let P be a graph pattern in SPARQLNEX. Consider that ﬂat(P ) is a
recursive function which replaces every graph pattern (P1 NOT-EXISTS P2) in
P by a graph pattern (P1 DIFF P2). We need to proof that P and ﬂat(P ) are
equivalent. Recalling the conditions introduced for SPARQLNEX (see Deﬁnition
4), we have that for any graph pattern (P1 NOT-EXISTS P2) it satisﬁes that
the domain of JP2K contains all the correlated variables with P1. Given such
condition, it is easy to see that J(P1 DIFF P2)K returns the same solutions than
J(P1 NOT-EXISTS P2)K. Note that, in both cases the cardinality of the solutions
is determined by the cardinality of P1. Hence, we have proved that the subset
of NOT-EXISTS graph patterns is expressible in SPARQLDIFF.

Based on Lemmas 4, 5 and 7, we can present our main result about the

expressive power of the DIFF operator and SPARQLDIFF.

Theorem 2. SPARQLDIFF contains SPARQLNEX.

This theorem implies that SPARQLNEX can be implemented by using the
subset of operators deﬁned by SPARQLDIFF (i.e. AND, UNION, FILTER and
DIFF). Hence, we have a “core” fragment of SPARQL supporting the negation
of graph patterns.

5 Properties of the SPARQL negation operators

In this section we evaluate the negation operators in terms of elementary equiv-
alences found in set theory. Speciﬁcally, we consider the following axioms con-
cerning set-theoretic diﬀerences [17]:

(a) A \ A ≡ ∅
(b) A \ ∅ ≡ A
(c) ∅ \ A ≡ ∅
(d) A \ (A \ (A \ B)) ≡ A \ B
(e) (A ∩ B) \ B ≡ ∅
(f ) (A \ B) ∩ B ≡ ∅

(g) A \ (A ∩ B) ≡ A \ B
(h) A ∩ (A \ B) ≡ A \ B
(i) (A \ B) ∪ B ≡ A ∪ B
(j) (A ∪ B) \ B ≡ A \ B
(k) A \ (B ∩ C) ≡ (A \ B) ∪ (A \ C)
(l) A \ (B ∪ C) ≡ (A \ B) ∩ (A \ C)

Our motivation to consider these equivalences is given by the intrinsic nature
of expressing negation in SPARQL, i.e. the diﬀerence of graph patterns. More-
over, set-theoretic equivalences are supported by other database languages like
relational algebra and SQL. Recalling that SPARQL works under bag semantics,
we will evaluate the behavior of the negation operators by examining both, set
and bag semantics.

Let us deﬁne the notion of equivalence between graph patterns. Two graph
patterns P1 and P2 are equivalent, denoted by P1 ≡ P2, if it satisﬁes that
JP1KG = JP2KG for every RDF graph G. In order to evaluate the set-based
equivalences in the context of SPARQL, we need to assume two conditions:

(1) As a general rule, a set-based operator requires of two “objects” with the
same structure (e.g. two tables with the same schema). Such requirement
is implicitly satisﬁed in SPARQL thanks to the deﬁnition of solution map-
pings as partial functions. Basically, if we ﬁx the set of variables V , then
we have that for every pair of solution mappings Ω1 and Ω2 it satisﬁes that
dom(Ω1) = dom(Ω2), i.e. Ω1 and Ω2 have the same domain of variables (even
when some variables could be unbounded). Hence, set-based operations like
union and diﬀerence can be applied to the algebra of solution mappings.

(2) SPARQL does no provide an explicit operator for intersecting two graph
patterns P1 and P2, i.e. the solution mappings which belong both to JP1K
and JP2K. Note however, that a graph pattern (P1 AND P2) resembles the
intersection operation (under set-semantics) when JP1K and JP2K have the
same domain of variables. Recalling condition (1), we will assume that the
AND operator could be used to play the role of the intersection operator in
the set-theoretic equivalences deﬁned above.

Given the above two conditions, we can apply a direct translation from a
set-theoretic equivalence to a graph pattern equivalence. Speciﬁcally, the set-
diﬀerence operator will be mapped to a SPARQL negation operator (DIFF, MI-
NUS or NOT-EXISTS), the set-intersection operator will be mapped to AND,
and the set-union operator will be replaced by UNION. Considering the spe-
ciﬁc features of NOT-EXISTS (i.e. correlation of variables), we will restrict our
analysis to DIFF and MINUS.

Let P1, P2, P3, P4 and P5 be graph patterns satisfying that JP1K = ∅,
JP2K = {µ0}, var(P3) = var(P4) and var(P3) ∩ var(P5) = ∅. By combining
the above four graph patterns, we conducted a case-by-case analysis consisting
of twenty ﬁve cases for equivalences (a)-(j) and one hundred twenty ﬁve cases
for equivalences (k) and (l). The diﬀerences between set and bag semantics were
specially considered for equivalences (h), (i), (k) and (l). Next, we present our
ﬁndings.

DIFF satisﬁes most equivalences with exception of (h), (i), (k) and (l). Equiv-
alence (h) presents ﬁve cases which are not valid under bag semantics, although
they are valid under set semantics. A similar condition occurs with ten and seven
cases for equivalences (k) and (l) respectively. Additionally, we found ten cases
which are not satisﬁed by equivalence (i).

MINUS does not satisfy equivalences (e) to (l). We found several cases where
equivalences (e), (f), (g), (j) and (k) are not satisﬁed. Similarly, there exist mul-
tiple cases where equivalences (h), (i) and (l) do not apply under bag semantics,
but works for set semantics. We would like to remark that the “odd results”
presented by the MINUS operator arise because the restriction about disjoint
solution mappings introduced in its deﬁnition.

In summary, we have that each negation operator presents a particular be-
havior for the axioms studied here. Although none of them was able to satisfy all
the axioms, we think that it does not mean that they are bad deﬁned. In fact, the
heterogeneity of the operators is a motivation to study their intrinsic properties
and to try the deﬁnition of a set of desired properties for negation in SPARQL.
The details about our case-by-case analysis are included in the Appendix.

6 Conclusions

In this paper we presented a systematic analysis of the types of negation sup-
ported in SPARQL 1.0 and SPARQL 1.1. After introducing the standard rela-
tional negation (the DIFF operator) we were able to built a core and intuitive
algebra (the same as the standard relational algebra) in SPARQL and prove that
it is able to deﬁne the graph pattern operators.

We think that having a clear understanding of the operators of a language
(in this case, the operators of negation of SPARQL) helps both, developers of
databases, and users of the query language. We also think that the core language
we identiﬁed (which is precisely the well known and intuitive relational algebra)
is a much more easy way to express queries for database practitioners, who learn
from the beginning SQL, which now with this new algebra, can be found in the
world of SPARQL.

References

1. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley

(1995)

2. Angles, R., Gutierrez, C.: The Expressive Power of SPARQL. In: Proceedings of
the 7th International Semantic Web Conference (ISWC). pp. 114–129. No. 5318 in
LNCS (2008)

3. Angles, R., Gutierrez, C.: SQL Nested Queries in SPARQL. In: Proc. of the 4th

Alberto Mendelzon Workshop on Foundations of Data Management (2010)

4. Angles, R., Gutierrez, C.: Subqueries in SPARQL. In: Proc. of the 5th Alberto

Mendelzon Workshop on Foundations of Data Management (2011)

5. Angles, R., Gutierrez, C.: Negation in SPARQL. In: Talk at 8th Alberto Mendelzon

International Workshop on Foundations of Data Management (AMW) (2014)

6. Arenas, M., P´erez, J.: Querying Semantic Web Data with SPARQL. In: 30th ACM

Symposium on Principles of Database Systems (PODS) (2011)

7. B´ar´any, V., Cate, B.T., Segouﬁn, L.: Guarded negation. J. ACM 62(3), 22:1–22:26

(Jun 2015)

8. Bidoit, N.: Negation in rule-based database languages: A survey. Theor. Comput.

Sci. 78(1), 3–83 (Jan 1991)

9. Gelfond, M., Lifschitz, V.: Classical Negation in Logic Programs and Disjunctive

Databases. New Generation Computing 9(3), 365–386 (1991)

10. Harris, S., Seaborne, A.: SPARQL 1.1 Query Language - W3C Recommendation.

http://www.w3.org/TR/2013/REC-sparql11-query-20130321/ (March 21 2013)

11. Hogan, A., Arenas, M., Mallea, A., Polleres, A.: Everything you always wanted to

know about blank nodes. Journal of Web Semantics 27(1) (2014)

12. Kim, W.: On optimizing an SQL-like nested query. ACM Transactions on Database

Systems (TODS) 7(3), 443–469 (1982)

13. Melton, J., Simon, A.R.: SQL:1999 Understanding Relational Language Compo-

nents. Morgan Kaufmann (May 2001)

14. Naqvi, S.A.: Negation as failure for ﬁrst-order queries. In: Proceedings of the Fifth
ACM SIGACT-SIGMOD Symposium on Principles of Database Systems. pp. 114–
122. ACM, New York, NY, USA (1986)

15. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. ACM

Transactions on Database Systems (TODS) 34(3), 1–45 (2009)

16. Prud’hommeaux, E., Seaborne, A.: SPARQL Query Language for RDF.
W3C Recommendation. http://www.w3.org/TR/2008/REC-115-sparql-query-
20080115/ (January 15 2008)

17. Suppes, P.: Axiomatic Set Theory. The University Series in Undergraduate Math-

ematics, D. Van Nostrand Company, Inc. (1960)

18. Wagner, G.: A database needs two kinds of negation. In: 3rd Symposium on Math-
ematical Fundamentals of Database and Knowledge Base Systems Rostock, Ger-
many, May 6–9, 1991 Proceedings. pp. 357–371 (1991)

19. Wagner, G.: Web rules need two kinds of negation. In: Proc. of Int. Workshop on
Principles and Practice of Semantic Web Reasoning. pp. 33–50. Springer Berlin
Heidelberg (2003)

A Simulation of Negation as Failure in SPARQL

In order to present a general solution about the simulation of negation by failure
in SPARQL, we need to introduce the notion of RDF Dataset and the GRAPH
operator.

An RDF dataset D is a set {G0, hu1, G1i, . . . , hun, Gni} where each Gi is
a graph and each uj is an IRI. G0 is called the default graph of D and it is
denoted dg(D). Each pair hui, Gii is called a named graph; deﬁne name(Gi)D =
ui and gr(ui)D = Gi. The set of IRIs {u1, . . . , un} is denoted names(D). Every
dataset satisﬁes that: (i) it always contains one default graph (which could be
empty); (ii) there may be no named graphs; (iii) each uj is distinct; and (iv)
blank(Gi) ∩ blank(Gj) = ∅ for i 6= j. Finally, the active graph of D is the graph
Gj used for querying D.

Next, we also extend the graph pattern evaluation function. The evaluation
of a graph pattern P over a dataset D with active graph G will be denoted as
JP KD
G returns
the multiset of mappings that matches the dataset D according to the graph
pattern P .

G (or JP KG where D is clear from the context). Speciﬁcally, JP KD

Let us extend the (recursive) deﬁnition of graph pattern. Given a graph
pattern P and n ∈ I ∪ V , we have that (n GRAPH P ) is also a graph pattern.
The semantics of (n GRAPH P ) is given as follows:

– If u ∈ I then J(u GRAPH P )KD = JP KD

G where G = gr(u)D

– If ?X ∈ V then J(?X GRAPH P )KD = Sv∈names(D)(JP KD

gr(v)D

⋊⋉ {µ?X→v})

We are ready to begin our analysis. In Section 3, we argued that the Negation
by Failure, and also (P1 DIFF P2), can be simulated by using a graph pattern of
the form

((P1 OPT P2) FILTER(! bound(?X)))

(1)

where ?X is a variable of P2 not occurring in P1. Unfortunately, there are two
issues with this solution:

– Variable ?X cannot be an arbitrary variable. For example, P2 could be in
turn an optional pattern (P3 OPT P4) where only variables in P3 are relevant
to evaluate the condition (! bound(?X)).

– If P1 and P2 do not have variables in common, then there is no variable ?X

to check unboundedness.

Angles and Gutierrez [2] identiﬁed these problems and proposed a solution

for them. The solution was shown to have a small bug.

Perez’s solution. A second approach which ﬁxed the bag was presented in [6],
where the authors propose that (P1 DIFF P2) can be simulated by the pattern

((P1 OPT (P2 AND (?X1 ?X2 ?X3))) FILTER ¬ bound(?X1))

(2)

where ?X1, ?X2, ?X3 are fresh variables mentioned neither in P1 nor in P2.

This solution works well when the empty graph pattern is not allowed in the
grammar. In the presence of it, the counter example is given when P1 and P2 are
empty graph patterns and the default graph is the empty graph. In this case, we
have that J(P1 DIFF P2)KD

G0 = ∅ whereas J(2)KD

G0 = {Ω0} .

Polleres’s solution. A third proposal was sketched by Axel Polleres in the mailing
list of the SPARQL W3C Working Group, and discussed with the authors of
this paper during the year 2009. The proposed solution is deﬁned formally in
the following proposition.

Proposition 1. Let P1, P2 be graph patterns. We have that (P1 DIFF P2) is
equivalent to

(((P1 OPT P2) AND(g GRAPH (?X:p :o))) FILTER ¬ bound(?X))

(3)

where g is a named graph containing the single triple (:s :p :o) and ?X is a free
variable.

JP1K JP2K J(P1 DIFF P2)K

JP3K

JP4K

JP3K JP4K

G0 6= ∅

G0 = ∅

∅
∅
1
∅ Ω0
2
∅ Ω2
3
∅
4 Ω0
5 Ω0 Ω0
6 Ω0 Ω2
∅
7 Ω1
8 Ω1 Ω0
9 Ω1 Ω1
10 Ω1 Ω2
11 Ω1 Ω3

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

Ω1 \ Ω2

Ω1 \ Ω2 Ω1 \ Ω2

∅

∅

∅

∅
∅
∅
∅
∅
∅
Ω0 Ω0
∅
Ω0
–
–
–
–
–
–
–
–
–
–
–
–

Table 2. Comparison of two implementations of diﬀerence of SPARQL graph patterns.
Assume that Ω0 = {µ0} (join identity), and Ω1, Ω2, Ω3 are sets of mappings distinct
of Ω0. Additionally, dom(Ω1) ∩ dom(Ω2) 6= ∅ and dom(Ω1) ∩ dom(Ω3) = ∅. P3 and P4
are the graph patterns presented in Equations 2 and 3 respectively. Note that, JP4K is
equivalent to J(P1 DIFF P2)K in all the cases, whereas JP3K fails when G0 = ∅ (i.e. the
default graph G0 is the empty graph).

Proof. In order to prove that the above equivalence holds, we have analyzed
the corner cases for (P1 DIFF P2). In Table 2, we compare the evaluation of the
graph patterns presented in Proposition 1, considering all the possible solutions
for JP1K and JP2K, and including the special case when the default graph is
the empty graph. We showed that the evaluation of both graph patterns are
equivalent for all the cases. Additionally, Table 2 includes the results for the
graph pattern presented in Equation 2, and shows that it fails in the case (5)
when the default graph is the empty graph as described before.

B Case-by-case analysis

Let P∅, P1, P2 and P3 be graph patterns satisfying that JP∅K = ∅, JP1K 6=
∅, JP2K 6= ∅ and JP3K 6= ∅. Also assume that Ω1, Ω2 and Ω3 are solutions
mappings satisfying that dom(Ω1) ∩ dom(Ω2) 6= ∅, dom(Ω1) ∩ dom(Ω3) = ∅ and
dom(Ω2) ∩ dom(Ω2) = ∅ Finally, recall that Ω0 denotes the multiset consisting
of exactly the empty mapping µ0.

We will show, for each axiom, examples of cases not satisﬁed by the negation
operators. We will use a generic operator NEG to denote any of the operators
used in our analysis, i.e. DIFF and MINUS.

Axiom (a): (P1 NEG P2) ≡ ∅ .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (b): (P1 NEG P∅) ≡ P1

.

Both, DIFF and MINUS satisfy in all the cases.

Axiom (c): (P∅ NEG P1) ≡ ∅ .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (d): (P1 NEG(P1 NEG(P1 NEG P2))) ≡ (P1 NEG P2) .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (e): ((P1 AND P2) NEG P2) ≡ P∅

.

– DIFF satisﬁes in all the cases.
– MINUS fails in four cases. For instance, if JP1K = Ω0 and JP2K = Ω0 then

J((P1 AND P2) MINUS P2)K = Ω0 instead of ∅.

Axiom (f ): ((P1 NEG P2) AND P2) ≡ P∅

.

– DIFF satisﬁes in all the cases.
– MINUS fails in eleven cases. For instance, if JP1K = Ω0 and JP2K = Ω2 then

J((P1 MINUS P2) AND P2)K = Ω2 instead of ∅.

Axiom (g): (P1 NEG(P1 AND P2)) ≡ (P1 NEG P2) .

– DIFF satisﬁes in all the cases.
– MINUS fails in seven cases. For instance, if JP1K = Ω1 and JP2K = Ω0 then

J(P1 MINUS(P1 AND P2))K = Ω0 whereas J(P1 MINUS P2)K = Ω1.

Axiom (h): (P1 AND(P1 NEG P2)) ≡ (P1 NEG P2) .

– Both, DIFF and MINUS fail under bag semantics, in ﬁve and twelve cases

respectively.

– For instance, both operators fail when JP1K = Ω1 and JP2K = ∅ such that

J(P1 AND(P1 NEG P2))K = Ω1 ⋊⋉ Ω1 whereas J(P1 NEG P2)K = Ω1.

Axiom (i): ((P1 NEG P2) UNION P2) ≡ (P1 UNION P2) .

– DIFF generates distinct solutions in ten cases, and fails under bag semantics

in four cases. For instance, if JP1K = Ω0 and JP2K = Ω1 then
((P1 DIFF P2) UNION P2) = Ω1 whereas (P1 UNION P2) = Ω0 ∪ Ω1.

– MINUS fails under bag semantics in three cases. For instance, if JP1K = Ω1

and JP2K = Ω1 then J((P1 MINUS P2) UNION P2)K = Ω1 whereas
J(P1 UNION P2)K = Ω1 ∪ Ω1.

Axiom (j): ((P1 UNION P2) NEG P2) ≡ (P1 NEG P2) .

– DIFF satisﬁes in all the cases.
– MINUS fails in four cases. For instance, if JP1K = Ω1 and JP2K = Ω0 then

J((P1 UNION P2) MINUS P2)K = Ω1 ∪ Ω0 whereas J(P1 MINUS P2)K = Ω1.

Axiom (k): (P1 NEG(P1 AND P 3)) ≡ ((P1 NEG P1) UNION(P1 NEG P3)
.

– DIFF fails in ten cases under bags semantics. For instance, if JP1K = Ω1,
JP2K = Ω0 and JP3K = Ω2 then J(P1 DIFF(P1 AND P 3))K = Ω2 whereas
J((P1 DIFF P1) UNION(P1 DIFF P3)K = (Ω2 \ Ω1) ∪ Ω2.

– MINUS generates distinct solutions in twenty two cases, and fails under bag
semantics in sixty ﬁve cases. For instance, if JP1K = Ω0, JP2K = Ω1 and
JP3K = Ω1 then J(P1 MINUS(P1 AND P 3))K = Ω0 whereas
J((P1 MINUS P1) UNION(P1 MINUS P3)K = Ω1.

Axiom (l): (P1 NEG(P1 UNION P 3)) ≡ ((P1 NEG P1) AND(P1 NEG P3)
.

– Under bag semantics, DIFF and MINUS fail in seven and forty eight cases

respectively.

– For instance, both operators fail when JP1K = Ω0, JP2K = Ω0 and JP3K = Ω1

such that J(P1 NEG(P1 UNION P 3))K = Ω1 and
J((P1 NEG P1) AND(P1 NEG P3)K = Ω1 ⋊⋉ Ω1.

