6
1
0
2

 
r
a

 

M
5
1

 
 
]

.

R
P
h
t
a
m

[
 
 

1
v
6
9
8
4
0

.

3
0
6
1
:
v
i
X
r
a

POLYNOMIAL TIME COMPUTABLE TRIANGULAR ARRAYS FOR

ALMOST SURE CONVERGENCE

†
VLADIMIR DOBRI ´C

, MARINA SKYERS, AND LEE J. STANLEY

the standard normal on (0, 1).

i=1 εi(x)2−i, with each εi(x) ∈ {0, 1} and εi(x) = 0
for inﬁnitely many i. Let Ri(x) := (−1)1+εi(x) and {Sn} be the random walk on Z deﬁned
weakly to the standard normal distribution on (0, 1). It is well known that there are S∗

i=1 Ri. By the Central Limit Theorem, the sequence (cid:8)Sn/

Abstract. For x ∈ (0, 1), write x =(cid:80)∞
on (0, 1) : Sn =(cid:80)n
in distribution to Sn, for which Skorokhod showed that(cid:8)S∗
n,i|1 ≤ i ≤ n, n ∈ Z+(cid:17)
(cid:16)
(cid:16)

We introduce a general method for constructing from {Ri} triangular array representations
R∗
n,i is a mean 0, variance 1 Rademacher
random variable depending only on the ﬁrst n bits of the binary expansion of x ∈ (0, 1).
(cid:17)
These representations are strong in that for each n, S∗
n is equal to the sum of the i.i.d family,
n,i|1 ≤ i ≤ n
R∗
, pointwise, as a function on (0, 1), not just in distribution. Our construction
method gives a bijection between the set of all representations with these properties and the
set of sequences, {πn}, where each πn is a permutation of {0, . . . 2n − 1} with the property
that we call admissibility.

n(cid:9) converges
n(cid:9) converges almost surely to

n}, where each R∗

n, equal

of {S∗

√

n/

√

We show that the complexity of any sequence of admissible permutations is bounded below
by the complexity of 2n, the exponential function on natural numbers with base 2. We explicitly
construct three such sequences which are polynomial time computable and whose complexity
is bounded above by the complexity of the function we denote by SBC (for sum of binomial
coeﬃcients), closely related to the binomial distributions with parameter p = 1/2. We also
initiate the study of some additional ﬁne properties of admissible permutations.

1. Introduction

n(cid:88)

i=1

n} converges weakly to the standard normal.

1.1. Motivation. Let {Ri|i ∈ Z+} be an i.i.d sequence of random variables, each with mean 0
Ri be the nth partial sum; thus, by the classical
and variance 1, and for each n > 0, let Sn =
√
Central Limit Theorem, the sequence {Sn/
It
n}, deﬁned on (0, 1) (equipped with
is well known, [11], that that there is another sequence, {S∗
n} converges
Lebesgue measure), with each S∗
almost surely to Z, the standard normal. However, is there a general method for obtaining, for
n,i equal in distribution to Ri, and whose
sum is equal (literally, pointwise, not just in distribution) to S∗
n? Once such families are obtained,
they provide a strong triangular array representation of {S∗
n}. This is the natural counterpart,
for almost sure convergence, of the standard notion of triangular array representation.
At this level of generality, the problem appears to be quite diﬃcult. This paper begins the
investigation of the problem in the simple but important setting where the sequence {Sn} is the

√
n equivalent in distribution to Sn, such that {S∗
n/

n,i|1 ≤ i ≤ n(cid:1), with each R∗

each n, an i.i.d. family(cid:0)R∗

Date: 8 March, 2016.
2010 Mathematics Subject Classiﬁcation. Primary 60G50, 60F15 ; Secondary 68Q15, 68Q17, 68Q25.
Key words and phrases. Central Limit Theorem, Almost Sure Convergence, Strong Triangular Array Repre-

sentations, Admissible Permutations, Polynomial Time Computability, Sums of Binomial Coeﬃcients.

Skyers and Stanley dedicate this paper to the memory of our dear departed friend and co-author, Vladimir
Dobri´c. The important contribution of S. Buss will be explicitly acknowledged at various points in the body of
the paper. We would also like to thank P. Clote and A. Nerode for helpful discussions of complexity issues, and
to thank Nerode for pushing us to improve our upper complexity bounds and suggesting the connection between
tameness and continuity. We are indebted to our Lehigh colleagues, Vince Coll, Daniel Conus, Rob Neel and Joe
Yukich for many helpful comments and suggestions.

1

(equiprobable) random walk on Z with domain (0, 1). For 0 < x < 1, write x =(cid:80)∞

i=1 εi(x)2−i,
with each εi(x) ∈ {0, 1} and εi(x) = 0 for inﬁnitely many i. For 1 ≤ i ≤ n and 0 < x < 1,
we take Ri(x) = (−1)1+εi(x); this gives the simplest expression for the Sn. Even in this simple
√
n is extremely chaotic and the disorder increases with n. One
setting, the behavior of the Sn/
manifestion of this chaos is an easy consequence of the LIL, [7], [8] for example: for almost all
n is a non-
x, limn→∞Sn(x)/
decreasing step function, mirroring the almost sure convergence of the sequence of normalizations.
n for n = 6, 7 are included below. Sn is shown in magenta, while S∗

n = −∞. On the other hand, each S∗

n = ∞ and limn→∞Sn(x)/

The graphs of Sn and S∗

√

√

n

is shown in green.

Figure 1. S6, S∗

6

Figure 2. S7, S∗

7

Since S∗

n is equal in distribution to Sn, it follows that S∗

n does have triangular array repre-
sentations. But what about strong ones, in the sense of the ﬁrst paragraph? Specializing to this
setting, the problem laid out in that paragraph can be restated as follows.

Question 1. How do we obtain strong triangular array representations,(cid:0)R∗

n,i|n ∈ Z+, 1 ≤ i ≤ n(cid:1),

of {S∗

n}? What do the R∗

n,i look like, as functions of x?

n}?

The LIL has implications, here, as well. For example, for each n, at least one of the R∗
We will give an explicit procedure for obtaining the sought-after R∗

depend on more than one bit. Also, the R∗
an additional property; they are trim in that, for ﬁxed n, each R∗
(ε1(x), . . . , εn(x)). This leads naturally to the next question.
Question 2. What are the trim, strong triangular array representations of {S∗

n,i must depend on n, not just on i.

n,i, and they will have
n,i(x) will depend only on

n,i must

Our procedure starts from any sequence {πn}, where each πn is a permutation of {0, . . . , 2n − 1}
with the additional property of being admissible. Any permutation, π, of {0, . . . , 2n − 1}, can be
viewed as permuting the level n dyadic intervals (by permuting their indices). This provides a
rearrangement of (0, 1). Such a permutation is admissible iﬀ S∗
n results when the corresponding
rearrangement is followed by applying Sn (as a function). This is made precise in Equation (1)
of subsection (1.2).

For each n, the passage from πn to(cid:0)R∗
permutations, our procedure generates all possible suitable families(cid:0)R∗
n,i is trim. The passage from (cid:0)R∗

n,i|1 ≤ i ≤ n(cid:1) is explicit, canonical and one-to-one and
n,i|1 ≤ i ≤ n(cid:1), where each
n,i|1 ≤ i ≤ n(cid:1) to πn is given by Equation (3), also in (2.2).

R∗
The obvious extension to a canonical bjection between sequences of admissible permutations and
trim strong triangular array representations of {S∗
n} is given by Corollary 1. Thus Theorem 1
and Corollary 1 answer Questions 1 and 2.
Since almost sure convergence is such a restrictive condition, it is natural to ask how hard it is
to produce the trim strong triangular array representations of {S∗
n} and what additional special

is given by Equation (2) of the proof of Theorem 1 in (2.2). Further, as πn varies over admissible

2

properties they must have. As with the existence of trim strong triangular array representations,
prior to this paper, very little was known; to our knowledge, the questions in the previous
sentence have not been considered until now. Once we know how to associate sequences of
admissible permutations to trim strong triangular array representations, it becomes natural to
pursue these questions in terms of the complexity of the associated sequences. The second half
of the paper carries out such a complexity analysis, motivated by the following questions.
Question 3. Are there trim, strong triangular representations of {S∗
n} of low complexity?
Question 4. Are there trim, strong triangular array representations of {S∗
as possible from the above representation of {Sn} and which are also of low complexity?

n} which diﬀer as little

We explicitly construct three trim, strong triangular array representations of quite low com-
plexity, as measured by the complexity of their classifying sequences of admissible permutations,
{Fn} , {Gn} and {Hn}. Our basic complexity estimate is that they are all polynomial time
computable (we make this precise in subsection (1.2)). This is the content of Theorem 2, in
subsection (3.4), for {Fn} and of Theorem 3, in subsection (4.2), for {Gn} and {Hn}. These
results therefore answer Question 3 aﬃrmatively. Since {Gn} and {Hn} are constructed so as to
diﬀer as little as possible from the representation of {Sn} by {Ri}, Theorem 3 answers Question
4 aﬃrmatively.
The proofs of Theorems 2 and 3 yield the somewhat sharper result that each of {Fn} , {Gn}
and {Hn} is very simply computed in terms of the function we denote by SBC (for Sum of Bino-
mial Coeﬃcients) introduced in Deﬁnition 1 in subsection (3.1). This function is very naturally
associated with the binomial distributions with parameter p = 1/2. The computation of each
of the three sequences in terms of SBC is a counterpart to the result that 2n has a very simple
expression in terms of any sequence, {πn}, of admissible permutations. Thus, the complexity of
each of {Fn} , {Gn} and {Hn} is bracketed in the fairly narrow range between that of 2n and
that of SBC. We shed further light on the relationship between SBC and {Fn} in Corollary 4 of
subsection (3.5); discussion is deferred until (1.3.5) and Section 3.
While their properties are indeed rather special, the trim strong triangular array represen-
tations corresponding to {Fn} , {Gn} and {Hn} are, perhaps surprisingly, not so diﬃicult to
produce, since they are of low complexity. At least in this context, the “cost” of the passage from
√
n} to the (trim) strong triangular array representa-
n} and the weakly covergent {Sn/
{Ri/
√
tions of the almost surely convergent {S∗
n} turns out to be surprisingly modest. Progress
n/
has been made in the direction of extending our methods to a more general setting. This will be
the subject of a planned sequel to this paper.

√

This paper grows out of Chapters 3 and 4 of Skyers’ dissertation, [12], written with Stanley
as advisor. Dobri´c, served as a “co-advisor”, and provided the inspiration and impetus for the
entire project. For recent work related to Skorokhod’s work, in a rather diﬀerent vein than this
paper, see [2], [3].
1.2. Preliminaries, Notation, Conventions. Let X be a random variable (on any probability
space). Let FX be the cumulative distribution of X. By the quantile of X (denoted by X∗),
we mean the random variable on (0, 1) (equipped with Lebesgue measure, λ, on Borel sets, B)
deﬁned by:
It is well-known that X and X∗ are equal in distribution. Skorokhod, [11], showed that if {Xn}
is a sequence of random variables (on any probability space) converging weakly to X, then the
sequence of quantiles, X∗
In order to compare the structure of the initial sequence to that of the sequence of quantiles,
the probability space of the Xn should be ((0, 1), B, λ), as above. In what follows, we work
exclusively in this probability space.
In this paper, i, j, k, m, n will always denote non-negative integers (elements of N). Most often,
we will have n > 0. We use |X| for the cardinality of a set, X. To emphasize that a union is a

disjoint union we use (cid:116) or(cid:70) rather than the usual ∪ or(cid:83). When the nature of the index set is

n, converges almost surely to X∗.

X∗(x) := inf{t ∈ R|FX (t) ≥ x} .

3

clear or has been established, we use {ai} to denote the sequence (possibly ﬁnite, possibly multi-
indexed) whose term, for index i, is ai. We use χY,U to denote the characteristic (or indicator)
function of a set Y , viewed as a subset of an ambient set U, the domain of the characteristic
function. When U is clear from context, we will omit it in the subscript. This notation is intended
to cover the situation where Y is a relation, i.e. where U is a set of d − tuples for some ﬁxed
d > 1.

For integers, n > 0, and 0 ≤ k < 2n, Dn,k denotes the kth level n dyadic interval:

Dn,0 =(cid:0)0, 2−n(cid:1) , and for 0 < k < 2n, Dn,k =(cid:2)2−nk, 2−n(k + 1)(cid:1) .

n are constant on each level n dyadic interval. A permutation, π, of

Note that both Sn and S∗
{0, 1, . . . , 2n − 1} is admissible if
(1)

for all k ∈ {0, 1, . . . , 2n − 1} , all x ∈ Dn,k and all y ∈ Dn,π(k), S∗

n(x) = Sn(y).

In several places, we will have a function, φ, with domain (0, 1), which, for some n, is constant
on each of the Dn,k. We then use Iφ (“Iφ” for the integer version of φ) to denote the function
with domain {0, . . . , 2n − 1}, whose value at k is the constant value of φ on Dn,k. Thus, for
example, ISn and IS∗
We adopt a similar convention for subsets, X ⊆ (0, 1), such that X is a union of level n dyadic
intervals. We will then use IX to denote the set of k such that Dn,k ⊆ X. Strictly speaking, in
both cases (function or subset) the dependence on the speciﬁc n involved should be part of the
notation, but, in all instances, this will already be incorporated into the notation used for the
speciﬁc φ or X involved.

n will denote the integer versions of Sn and S∗

n, respectively.

Our basic complexity estimate is in terms of polynomial time computability. This notion is
robust across diﬀerent detailed models of computations, each of which has its own sensible notion
of “elementary operation”. Accordingly, as is customary, we omit a detailed development of what
is involved in this notion.

If f is a function of d natural number arguments, f is polynomial time computable (P-TIME) iﬀ
for some polynomial, p(n), the value of f can be computed in at most p(n) elementary operations
whenever all arguments are smaller than 2n. This is consistent with the usual treatments ( e.g.
[4] or [10]), which, for the most part, treat arguments and values as bitstrings or vectors of
bitstrings, rather than in terms of the encoded natural numbers. In some important instances,
f will have 1 + d arguments, the ﬁrst of which is viewed as being n itself (the argument of p.) In
this context, the requirement is that at most p(n) elementary operations are required to compute
f (n, x1, . . . , xd) whenever each xi < 2n. Polynomial-time decidable (P-TIME decidable) relations
are ones whose characteristic functions are P-TIME.

i=0

i

1.3. Summary and Further Discussion of Results. By Corollary 1, the existence of trim
strong triangular array representations of {S∗
n} reduces to the existence of sequences of ad-
missible permutations, which further reduces to the existence of admissible permutations of
{0, . . . , 2n − 1}, for each n. This is established in part 2 of Lemma 1 of (3.1); the precise state-

(cid:1)!(cid:1) of them. This count builds on a more concrete characterization

ment is that there are(cid:81)n

(cid:0)(cid:0)n

of admissibility developed, among other things, in (3.1).
In (3.2), Corollary 2 pulls together the statements of Theorem 1, Corollary 1 and part 2 of
Lemma 1 to give the existence proof for trim strong triangular array representations of {S∗
n}.
Proposition 1 builds on Corollary 2 by constructing a strong but non-trim triangular array
representation starting from a trim strong one. Proposition 2, which also builds on some of the
material from (3.1), is a “non-persistence” result in that it shows that in any sequence {πn} of
admissible permutations, πn never persists to be a subfunction of πn+1, and that in any trim
n}, for any n > 0, it is never
possible for all of the R∗
n+1,i. This provides another proof
of the second consequence of the LIL mentioned following Question 1 in (1.1) and highlights
some important ways in which the trim strong triangular array representations of {S∗
n} must
diﬀer from the simple representation {Ri} of {Sn}.

strong triangular array representation(cid:0)R∗

n,i|n > 0, 1 ≤ i ≤ n(cid:1) of {S∗

n,i to persist to be the corresponding R∗

4

1.3.1. The role of trimness. Proposition 1 shows that trimness does not “come for free”. Given
that there can be no strong triangular array representation for {S∗
n,i depends
on only one bit, trimness is a natural “next best hope”. Its central role in Theorem 1 and Corollary
1 is further evidence for its naturality, as is the following equivalent characterization of trimness,
suggested by A. Nerode.
Let Vn be {−1, 1}n. Let V be the topological product of the Vn equipped with the discrete
topologies and let V be the set of points of V. Suppose that for n ≥ i, R(cid:48)
n,i is a Rademacher
n}). This provides us with a transformation, T , from (0, 1) to V , by
nor that it represents {S∗

random variable on (0, 1) (we are not necessarily assuming, yet, that(cid:8)R(cid:48)
n,n(x)(cid:1). It is then clear that the condition:
taking T (x)n :=(cid:0)R(cid:48)

n} in which each R∗

(cid:9) is a triangular array

n,i

n,1(x), . . . , R(cid:48)

for all i ≤ n, R(cid:48)

n,i depends at most on ε1, . . . εn

is equivalent to the condition:

the associated transformation T is Lipschitz-continuous with δ = .

Then, specializing to the situation where the R(cid:48)
n,i do furnish a strong triangular array represen-
tation of {S∗
n}, the second displayed formula provides our equivalent characterization of trimness.
We are grateful to A. Nerode for suggesting that we seek this type of characterization, and for
the observation that the transformation T can be feasibly implemented, since the implementa-
tion would satisfy a strong form of bounded memory; this is an equivalent refomulation of the
Lipschitz continuity.

1.3.2. Transition to Complexity: 2n is a lower bound. In (3.3) we introduce the natural encoding,
Π of a sequence, {Πn}, of admissible permutations, and explicitly begin to deal with complexity
issues. It is here that we really begin to exploit the “toolkit” material developed in (3.1). We
prove Proposition 3, which establishes that the exponential function, 2n, is a lower bound for the
complexity of any such sequence {Πn}. Our approach to this, and to related questions, will be
brieﬂy outlined in (1.3.5), below and more fully discussed at the start of Section 3.

1.3.3. Preview of Theorem 2. While Corollary 2 settles the question of the existence of trim
n}, in Deﬁnition 4 ((3.4)) we explicitly construct the
strong triangular array representations of {S∗
sequence {Fn} of admissible permutations. Building on Proposition 4 and Corollary 3, Theorem
2 answers Question 3 aﬃrmatively by establishing that F , the natural encoding of this sequence,
is P-TIME and can be simply computed in terms of SBC. We also give an even cleaner and
simpler deﬁning expression for 2n in terms of F , improving slightly on the proof of Proposition
3. The discussion of Corollary 4, proved in (3.5), is deferred until (1.3.5) and Section 3.

1.3.4. Preview of Theorem 3. The aﬃrmative answer to Question 4 is provided by Theorem 3,
proved in (4.2). In (4.1), culminating in Deﬁnition 7, we construct {Gn}, a variant of the sequence,
{Fn}. Among admissible permutations of {0, . . . , 2n − 1}, Gn is maximal for agreement with the
identity function. Thus, the extent to which trim strong triangular array representations of {S∗
n}
must diﬀer from the canonical representation of {Sn} is measured by the extent to which the Gn
diﬀer from the identity permutations.
The construction of {Gn} is also motivated by a rather diﬀerent notion of complexity: that of
an individual admissible permutation. This also motivates the construction of {Hn}, the other
variant of {Fn} (Deﬁnition 11 of (4.1)). We impose additional natural properties on the Gn and
Hn to guarantee that their orbit structures will be simpler than the orbit structures of the Fn.
While Remark 6 and Deﬁnition 7 immediately make it clear that each Gn is admissible, this is
a more substantial issue for the Hn and is established in Proposition 5 of (4.1), the analogue for
{Hn} of Remark 6.
The analogue of Theorem 2 for the natural encodings, G, of {Gn}, and H, of {Hn} is provided
by Theorem 3. The expression for 2n in terms of G is fairly close to the one in terms of F , but for
H, we content ourselves with the general lower bound statement of Proposition 3. This diﬀerence
between F and G, on the one hand, and H, on the other, is foreshadowed by the discussion at

5

the end of (3.5), and revisited at the end of (4.1). Similar issues, also discussed at the end of
(4.1), are obstacles to obtaining a genuine analogue of Corollary 4 for G or H. The proof that
each of G and H is P-TIME and is simply and explicitly computed in terms of SBC proceeds
by analogy to Theorem 2, and follows the general approach sketched in (1.3.5). This builds on
Proposition 6, which plays the role of the combination of Proposition 4 and Corollary 3.

1.3.5. Complexity Issues. For the lower bounds, established by Equation (6) of Proposition 3,
Equation (8) of Theorem 2, and Equation (13) of Theorem 3, the approach is to express 2n
explicitly and uniformly in n, using the sum of at most n values (including repeated values) of
the function involved. All of the corresponding arguments are obtained from n, very simply,
explicitly, and uniformly in n. In Equation (6), there are n distinct values involved, and the sum
of these values is incremented by 1 to obtain 2n. In Equation (8), for F , there is just one value,
repeated twice. Finally, for Equation (13), for G, there is also just one value, repeated twice, but
that value is the maximum of two values. In both of the latter cases, 2n is simply the sum of the
repeated values (i.e., twice the repeated value, but the point is to do things using only addition
and no multiplication).

The proofs that F, G and H are P-TIME have a common structure, though the cases in the
deﬁnitions of G, H result in technical complications, especially for H. Here, accordingly, it is
only for F (Theorem 2) that we will outline the main ideas of the proof.

In subsections (3.1) and (3.4), we introduce the function SBC (in Deﬁnition 1) and a num-
ber of other auxiliary functions and relations, notably the two functions, IStep and EW. The
function IStep computes “positions” with respect to SBC and is introduced in the comments
following Remark 1, in (3.1). We introduce EW in Deﬁnition 5 of (3.4). It is the enumerating
function for Weight (Deﬁnition 2: the usual Hamming weight of a positive integer). The sequence
http://oeis.org, 2010, Sequence A066884, [9], encodes EW. IStep bears the same relationship to
n} as Weight does to {Sn}.
{S∗
In subsection (3.4), Proposition 4 establishes, among other things, that for all n and all i ≤ n

the computation of SBC(n, i) can be carried out using O(cid:0)n2(cid:1) additions of integers all below 2n,

with all of the intermediate sums being less than 2n. This guarantees that the function IStep is
P-TIME.

The corresponding result for the function EW is given by Corollary 3 which also establishes
that the relation expressed by Equation (7 ) is P-TIME decidable. Corollary 3 is the culmination
of a sequence of results (Proposition 4, Lemmas 2 and 3) where the notion of “tame” relation,
introduced in Deﬁnition 3, is a key ingredient. Lemma 2 establishes that the enumerating function
(viz. Deﬁnition 3) for a tame relation is P-TIME. Lemma 3 establishes the tameness of the
relation whose enumerating function is EW (and thus, with Lemma 2, that EW is P-TIME). It
follows from the proof of Lemma 3 that EW itself can be simply computed in terms of SBC and
that solutions, m, of Equation 7 can be computed in polynomial time as functions of n and k.

The proof of Theorem 2 then proceeds by showing that for n > 0 and k < 2n, F (n, k) =
m < 2n is the unique solution of Equation (7). We are very grateful to S. Buss who provided
invaluable assistance on several occasions. In particular, he conﬁrmed the validity of our approach
to Proposition 4, pointed out the references given there and supplied a very nice argument that
evolved into the proof of Lemma 3. He also suggested combining these ideas with binary search
(a variant of the Bisection Algorithm). In the course of working out the details, we isolated the
notion of tameness and formulated and proved Lemma 2. A bit more detail on the material of
this subsubsection is given in the overview of Section 3.

2. Theorem 1 and Corollary 1

2.1. Preliminaries for Theorem 1. For x ∈ (0, 1), we set:
rn(x) := (ε1(x), . . . , εn(x)) ,

(cid:16)
(−1)1+ε1(x), . . . , (−1)1+εn(x)(cid:17)

.

sn(x) :=

6

On Dn,k, rn(x), sn(x) are constant. Therefore, following the convention in the ﬁnal paragraph
of (1.3), we denote these constant values by Irn(k), Isn(k), respectively.

Note that Irn(k) does NOT denote the kth component of a vector, Irn, rather it denotes the
vector (a length n bitstring) itself. We will denote the ith component of this vector by (Irn(k))i.
Note that this is just εi(x) for any x ∈ Dn,k. Similar observations hold with s in place of r (and
{−1, 1} replacing {0, 1}).

Note, further, that Irn(k) is the reversal of the binary representation of k: k =

and that (Irn(k)| k < 2n) enumerates {0, 1}n in increasing order with respect to the lexicographic
ordering. For r ∈ {0, 1}n, we also let:

i=1

n(cid:88)

2n+1−i (Irn(k))i,

n(cid:88)

n as a sum
S∗
R∗
n,i,
n =

i=1

Dr := {x ∈ (0, 1)|rn(x) = r}.

Letting k be such that r = Irn(k), we note that Dr = Dn,k = {x ∈ (0, 1)|rn(x) = Irn(k)}.
We use νn to denote the order isomorphism (with respect to lexicographic order) between
{0, 1}n and {−1, 1}n, thus for r ∈ {0, 1}n and 1 ≤ i ≤ n, (νn(r))i = (−1)1+(r)i. Note that
It is also worth noting that any permutation, π, of {0, . . . , 2n − 1} is
Isn(k) = νn (Irn(k)).
naturally viewed as a permutation of {0, 1}n, by taking π (Irn(k)) as deﬁned to be Irn(π(k)),
and similarly with {−1, 1} replacing {0, 1} and s replacing r.
2.2. Theorem 1 and Corollary 1.
Theorem 1. For each n, there is a canonical bijection between admissible permutations of
{0, . . . , 2n − 1} and representations of S∗

where (cid:0)R∗

n,i| 1 ≤ i ≤ n(cid:1) is an i.i.d.

family of Rademacher random variables each of which has

n,i. We
First, let π be an admissible permutation of {0, . . . , 2n − 1}. For x ∈ (0, 1), let k be such that

n,i, given π, and then construct π given the R∗

mean 0, variance 1 and depends only on rn.
Proof. Fix n > 0. We ﬁrst construct the R∗
then carry out the necessary veriﬁcations in each direction.
x ∈ Dn,k, and let 1 ≤ i ≤ n. Then:
(2)

let y be any member of Dn,π(k) and deﬁne: R∗

Conversely, given an independent family, (cid:0)R∗
follows. Given k < 2n, let x ∈ Dn,k, let s =(cid:0)R∗

each R∗

n,i(x) := (−1)1+εi(y).
n(cid:88)

n,i|1 ≤ i ≤ n(cid:1), such that S∗
n,i(x)|1 ≤ i ≤ n(cid:1) and deﬁne:

R∗
n,i, where
n,i is Rademacher with mean 0 and variance 1 and depends only on rn(x), we obtain π as

n =

i=1

π(k) = that m < 2n such that s = Isn(m).

(3)
Clearly these constructions yield a bijection, so we turn to the necessary veriﬁcations.
First suppose π is admissible and that the R∗
R∗
n,i depend only on rn(x). In order to see that they sum to S∗

n, note that:

n,i are deﬁned by Equation (2). Clearly these

for all k < 2n and all x ∈ Dn,k, S∗

n(cid:88)
(−1)1+εi(y), for any such y, i.e. S∗
n,i is Rademacher with mean 0 and variance 1, ﬁx i and  ∈ {0, 1} and let

A :=(cid:8)t ∈ {0, 1}n(cid:12)(cid:12)ti = (cid:9); then |A| = 2n−1. Since π is 1-1,(cid:12)(cid:12)π−1 [A](cid:12)(cid:12) = 2n−1. Now, viewing π as

n(x) = Sn(y), for any y ∈ Dn,π(k),

R∗
n,i(x); this suﬃces.

To see that each R∗

a permutation of {0, 1}n, we have that:

π−1 [A] =(cid:8)r ∈ {0, 1}n(cid:12)(cid:12) (π (r))i = (cid:9) and {x| (π (rn(x)))i = } =

n(cid:88)

i.e. S∗

(cid:71)

n(x) =

n(x) =

Dr.

i=1

i=1

r∈π−1[A]

7

It follows that:

λ ({x| (π (rn(x)))i = }) = λ

 (cid:71)

r∈π−1[A]

 = 2n−1 · 2−n = 1/2; this suﬃces.

Dr

In order to see that these R∗

n,i are independent, it suﬃces to show that:

for all s = (s1, . . . , sn) ∈ {−1, 1}n , p (s1, . . . , sn) = p1 (s1) · . . . · pn (sn) ,

n,n = sn

Let π be deﬁned by Equation (3). We ﬁrst show that π is one-to-one. For this, let x ∈ Dn,k, s =

n,i alone. We showed that p1 (s1)· . . . ·
−1 (s) and note

n (s(cid:9)(cid:1) = λ (Dr) = 2−n.

n,i|1 ≤ i ≤ n(cid:1) is given with the stated properties.

P(cid:0)R∗

n,1 = s1, . . . , R∗

n,i and pi is the pmf of R∗

where p is the joint pmf of the R∗
pn (sn) = 2−n, so, again viewing π as a permutation of {0, 1}n, let r := π−1 ◦ (νn)
that:

(cid:1) = λ(cid:0)(cid:8)x|π (rn(x)) = ν−1
For the opposite direction, suppose that(cid:0)R∗
(cid:0)R∗
n,i(x)|1 ≤ i ≤ n(cid:1) and note that if u ∈ {0, 1}n is such that
n,i(y)|1 ≤ i ≤ n(cid:1) = s, then u = Irn(k).
(cid:1) = 2−n+1,
n(cid:88)

for y ∈ Du, (cid:0)R∗
P(cid:0)R∗
If this were to fail we would have that
n,1 = s1, . . . , R∗
n(cid:88)
n(cid:88)

n,n = sn
which contradicts our hypotheses on the R∗
because now, by hypothesis, if x ∈ Dn,k and m = π(k), then:

(cid:1) ≥ λ (Du) + λ(cid:0)DIrn(k)

n,i. Thus, f is one-to-one. Admissibility then follows,

si, but also for any y ∈ Dn,m, Sn(y) =

S∗
n(x) =

R∗
n,i(x) =

i=1

i=1

(cid:3)
as required.
Corollary 1. There is a canonical bijection between sequences, {πn}, of admissible permutations
of {0, . . . , 2n − 1} and trim, strong triangular arrays for {S∗
n}.
(cid:3)

Given n and (cid:0)R∗
representations (Ri|1 ≤ i ≤ n) and(cid:0)R∗
singling out a speciﬁc representation,(cid:0)R∗

n,i|1 ≤ i ≤ n(cid:1), Equation (3) is best seen as as a ﬁner version of Equation
n,i|1 ≤ i ≤ n(cid:1) singles out a speciﬁc admissible permutation,
n,i|1 ≤ i ≤ n(cid:1), of S∗

whereas Equation (1) deﬁnes the set of all of them. Equation (2) reverses this, taking as given
the canonical representation, (Ri|1 ≤ i ≤ n), together with a speciﬁc admissible permuation and

(1) (the deﬁnition of admissible permutation). Incorporating the additional information in the

n.

si,

i=1

3. The Road to Theorem 2

In (3.1) we introduce the notions that will provide the “toolkit” for the rest of the paper, and, in
particular for Theorems 2 and 3. In Deﬁnition 1, we introduce the functions Stepn, Weightn and
SBC. Incorporating Remark 1 then immediately gives us the functions IStepn, IS and IS∗. These
are the “integer versions” of the functions Stepn, Sn and S∗
n, respectively. We also introduce the
function IStep which is the natural encoding (as a function of two variables) of the family of the
IStepn.
In Deﬁnition 2, we introduce the sets An,i and Bn,i and their “integer versions” IAn,i and
IBn,i. Analogues of these are given in (4.1) in the construction of the {Gn} , {Hn} and their
natural encodings (see (3.3)) by the functions G and H.

The IAn,i and IBn,i are the motivating paradigm for Deﬁnition 3, which is particularly impor-
tant. It is given in abstract form to accommodate ﬁve diﬀerent invocations: one in (3.1) itself, in
connection with the IAn,i, IBn,i, and the other four in (4.1), in connection with their analogues.
The invocation of Deﬁnition 3 in (3.1) introduces the three-place relations RIA and RIB, which
encode the families IAn,i and IBn,i respectively, their associated cardinality functions, cdRIA and
cdRIB and enumerating functions, ERIA and ERIB. The notion of “tameness” is also introduced

8

in Deﬁnition 3; it plays an important role in the complexity analyses carried out in subsections
(3.4) and (4.2).

The cardinality functions associated with P-TIME decidable relations form the somewhat
unusual complexity class, #P (see, e.g., [4], (6.3.5)), which, conjecturally, is not included in the
collection of P-TIME functions. In addition to all of the other ways we appeal to tameness, it
also guarantees (Item 6. of Remark 3) that the relation itself is P-TIME decidable and that (by
deﬁnition) its associated cardinality function is P-TIME, allowing us to avoid the issue of #P .
We elaborate a bit on the sketch (in (1.3.3) and (1.3.5)) of what is accomplished in subsections
(3.4) and (3.5), since the material of subsections (3.2) and (3.3) has already been fully presented
in subsection (1.3). In (3.4), Proposition 4 establishes that for all n and all i ≤ n, the binomial

(cid:1) and SBC(n, i) can be computed using O(n2) additions of integers all below 2n

coeﬃcient, (cid:0)n

(cid:8)F −1

(cid:9). We conclude (3.5) by arguing for the (informal and therefore necessarily imprecise)

with all intermediate sums being less than 2n and so, in particular, in time polynomial in n.
Consequently, the function IStep is P-TIME, and the relation RIA is tame. This sets the stage
for Lemmas 2 and 3, Corollary 3 and Theorem 2. In (3.5), Corollary 4 sheds additional light
on the relationship between F and SBC by showing that SBC can be simply computed in terms
of F and the function, which we denote by InvF , which is the natural encoding of the sequence
thesis that {Fn} is, in fact, is the simplest sequence of admissible permutations. The argument
appeals to the view of admissible permutations developed at the end of (3.1).
3.1. Toolkit for Theorems 2 and 3. As usual, FB(n,p) denotes the cumulative binomial dis-
tribution with parameters n, p.
Deﬁnition 1. For n > 0, set SBC(n, 0) := 0 and for 1 ≤ i ≤ n + 1, set

n

i

(cid:18)n

(cid:19)

i−1(cid:88)

j=0

SBC(n, i) :=

.

j

n(cid:88)

i=1

εi(x).

For n > 0, and x ∈ (0, 1), Stepn(x) is the unique i such such that FB(n,1/2)(i) ≤ x < FB(n,1/2)(i+
1). We also set Weightn(x) :=
Remark 1. For x ∈ (0, 1). and n > 0, the following observations are obvious:

n(x) = −n + 2Stepn(x).

(1) Sn(x) = −n + 2Weightn(x),
(2) Weightn(x) is the usual Hamming weight of rn(x),
(3) Stepn(x) is the unique i such that SBC(n, i) ≤ x2n < SBC(n, i + 1) ,
(4) S∗
(cid:3)
(5) Stepn(x), Weightn(x) depend at most on rn(x).
In view of (1.3) and 5. of Remark 1, we have deﬁned IStepn(k), IWeightn(k). We already
knew that Sn and S∗
n(k), ISn(k)
n(r), ISn(r) for r ∈ {0, 1}n.
for k < 2n; by the usual identiﬁcation, we have also deﬁned IS∗
Also, IWeightn(k) is the usual Hamming weight of the binary representation of k and is therefore
independent of n, so henceforth this will simply be denoted by Weight(k). Similarly Weight(r)
denotes the usual Hamming weight of r for ﬁnite bitstrings, r. In what follows, we shall use the
notation IStep(n, k) rather than IStepn(k). The following is then also obvious
Remark 2. For n > 0 and k < 2n:

n also depend at most on rn(x) and thus we have also deﬁned IS∗

k < SBC(n, i + 1),

(1) IStep(n, 0) = 0 and for 0 < k < 2n, IStep(n, k) is the least positive i ≤ n such that
(2) For all i ∈ N, 2i − 1 is the least k such that Weight(k) = i and 2n − 2n−i is the largest
(3) For all 0 ≤ i ≤ n, SBC(n, i) is the least k such that IStep(n, k) = i.
(cid:3)

k < 2n such that Weight(k) = i,

Deﬁnition 2. For i ≤ n, we deﬁne An,i, Bn,i by:

An,i := {x ∈ (0, 1)|Stepn(x) = i},

9

Bn,i := {x ∈ (0, 1)|Weightn(x) = i}.

In view of Remark 2, for ﬁxed n > 0, each of the An,i, Bn,i is the union of level n dyadic
intervals, and therefore, in view of the last paragraph of (1.3), IAn,i, IBn,i will be used to denote
the corresponding subsets of {0, . . . , 2n − 1} (or of {0, 1}n, via the usual identiﬁcation) :
(4)
We also let αn,i := |IAn,i| , βn,i := |IBn,i| and for positive integers, x < 2n, we let α(n, i, x) =
|IAn,i ∩ {1, . . . , x}| , β(n, i, x) = |IBn,i ∩ {1, . . . , x}|.

IAn,i := {k < 2n|Dn,k ⊆ An,i} and IBn,i := {k < 2n|Dn,k ⊆ Bn,i} .

This provides the motivating paradigm for the next deﬁnition, taking d = 1, Un = {0, . . . , n}

and Xn,i = IAn,i or Xn,i = IBn,i.
Deﬁnition 3. Suppose that d ∈ Z+ and that for n > 0, Un ⊆ {0, . . . , n}d. Suppose, further,
that for u ∈ Un, we have non-empty Xn,u ⊆ {0, . . . , 2n − 1}, with the increasing enumeration of
Xn,u denoted by (xn,u,s|1 ≤ s ≤ |Xn,u|). We deﬁne RX(n, u, (cid:96)) to be that d + 2 − place relation
on N such that

RX(n, u, (cid:96)) iﬀ (cid:96) ∈ Xn,u.

The cardinality function associated with RX is the function cdRX which, for n > 0, u ∈ Un and
positive integers, x < 2n, assigns to (n, u, x), cdRX (n, u, x) := |Xn,u ∩ {1, . . . , x}|. We denote by
ERX the enumerating function for RX: ERX(n, u, s) := xn,u,s for 1 ≤ s ≤ |Xn,u|. We will call
RX tame if cdRX is P-TIME.

In our invocations of Deﬁnition 3, we will have d = 1 and Un = {0, . . . , n} (for the ﬁrst two
invocations, and the last one) or d = 2 and Un = {(i, j)|i, j ≤ n, i (cid:54)= j} (for the third and fourth
invocations). In all of our invocations, it will be true that for ﬁxed n, {Xn,u|u ∈ Un} will be a
pairwise disjoint family, but we have not built this into the deﬁnition of tame.
We now invoke Deﬁnition 3 with d = 1 and Un = {0, . . . , n} and with Xn,i = IAn,i or
Xn,i = IBn,i. This deﬁnes RIA, RIB, cdRIA, cdRIB, ERIA, ERIB. The notation for the
increasing enumerations will be an,i,s, bn,i,s.
Remark 3. The following observations are immediate, with the exception of item 6.

(1) For ﬁxed n, i, j we’ll have that RIA(n, i, (cid:96)) holds n > 0, 0 ≤ i ≤ n, 0 ≤ (cid:96) < 2n and
IStep(n, (cid:96)) = i. Similarly, RIB(n, j, (cid:96)) holds iﬀ n > 0, 0 ≤ j ≤ n, 0 ≤ (cid:96) < 2n and
Weight((cid:96)) = j.

If x < SBC(n, i), then α(n, i, x) = 0, and if x ≥ SBC(n, i + 1), then α(n, i, x) =(cid:0)n
(3) For n > 0, αn,i = |IAn,i| =(cid:0)n

(2) cdRIA is the function α of Deﬁnition 2 while cdRIB is the function β of Deﬁnition 2.
SBC(n, i+1)−SBC(n, i). For SBC(n, i) ≤ x < SBC(n, i+1), α(n, i, x) = x+1−SBC(n, i).

(cid:1) = |IBn,i| = βn,i.

(cid:1) =

(4) If a = an,i,s, then s = α(n, i, a) and a = ERIA(n, i, s); the analogous statements hold,
(5) For any system Xn,u as in Deﬁnition 3, if u ∈ Un, a < b < 2n, then cdRX (n, u, b) −
(6) Suppose that {(n, u)|u ∈ Un} is P-TIME decidable. Then, if RX is tame, it is also

replacing A with B, α with β and all occurrences of a with b.
cdRX (n, u, a) = |{x ∈ Xn,u|a < x ≤ b}|.

i

i

P-TIME decidable.

Proof. Items 1. - 5. are obvious. For item 6., note that for n > 0, u ∈ Un and x ∈ Z+ with
x < 2n, RX(n, u, x) holds iﬀ either x = cdRX (n, u, x) = 1 or
(x > 1 and cdRX (n, u, x) = cdRX (n, u, x − 1) + 1).
(cid:3)
Lemma 1. Let n > 0. Then:

(1) If π is a permutation of {0, . . . , 2n − 1}, the admissibility of π is equivalent to each of the

following conditions:
(a) for all k < 2n, Weight(π(k)) = IStep(n, k),
(b) for all i < n, π [IAn,i] = IBn,i,
(c) IS∗

n = ISn ◦ π.

10

(2) There are(cid:81)n

i=0

(cid:0)(cid:0)n

i

(cid:1)!(cid:1) admissible permutations of {0, . . . , 2n − 1} .

Proof. For 1., it is clear that (b) and (c) are each equivalent to (a), so we argue that the admis-
sibility of π is equivalent to (a). Let π be any permutation of {0, . . . , 2n − 1}, let k < 2n and let
x ∈ Dn,k, y ∈ Dn,π(k). Then:

2IStep(n, k) = n + S∗

n(x) and 2Weight(π(k)) = n + Sn(y).

But the condition that the right hand sides of the last two displayed equations are equal (for any
k and any such x, y) deﬁnes the admissibility of π, while (a) is the condition that the left hand
sides are equal (for all k), and so the admissibility of π is equivalent to (a).
For 2., note that an admissible permutation π decomposes into the system of its restrictions
to the IAn,i. Complete information about π (cid:22) IAn,i is encoded by the permutation, πn,i of

(cid:1)(cid:9) deﬁned by:
(cid:1)(cid:9), then for each n there is a (unique) admissible permutation πn of {0, . . . , 2n − 1}

Further, the πn,i are arbitrary in the sense that if, for i < n, σn,i is any permutation of

(cid:8)1, . . . ,(cid:0)n
(cid:8)1, . . . ,(cid:0)n

, then πn,i(s) := β (n, i, π (an,i,s)) .

if 1 ≤ s ≤

such that for each i < n, πn,i = σn,i. Finally, for ﬁxed n, the product in 2. counts the number
of such systems (σn,i|i < n), and so 2. follows.
(cid:3)

(cid:18)n

(cid:19)

(5)

i

i

i

It is worth pointing out, here, that the proof of 2. of Lemma 1 provides us with yet another
view of admissible permutations, since they correspond canonically to such systems of σn,i. We
will return to this view of admissible permutations in (3.5) below.
3.2. Corollary 2 and Propositions 1, 2. The next Corollary is an immediate consequence of
Theorem 1, Corollary 1 and 2. of Lemma 1; it gives the existence of trim, strong triangular array
for {S∗
n}.

Corollary 2. For each n, there are(cid:81)n
where(cid:0)R∗

(cid:0)(cid:0)n

i

(cid:1)!(cid:1) representations
n(cid:88)

R∗
n,i,

i=0

S∗
n =

n,i| 1 ≤ i ≤ n(cid:1) is an independent family of Rademacher random variables each of which

i=1

has mean 0, variance 1 and depends only on rn. Therefore, there exist (continuum many) trim,
n}.
strong triangular array representations of the sequence {S∗
(cid:3)

The next Proposition builds on Corollary 2 to show that there are non-trim, strong triangular
n}, by constructing one, as a modiﬁcation of a trim, strong one. Thus,
n} is not an immediate formal consequence

array representations of {S∗
the existence of trim strong triangular arrays for {S∗
of the existence of strong ones.
Proposition 1. There are non-trim, strong triangular arrays for {S∗
n}.

n}. It is easy to see that for all suﬃ-
ciently large n we can ﬁnd i1, i2, k1, k2 such that i1 (cid:54)= i2, i1, i2 < n, k1 < k2 < 2n and for
j = 1, 2:

Proof. Fix a trim, strong triangular array, (cid:8)R∗
Fixing a suﬃciently large n∗ and then ﬁxing such i1, i2, j1, j2, we deﬁne(cid:8)R∗∗

(cid:9) and then verify

(x) = (−1)j for all x ∈ Dn,kj and R∗

(x) = (−1)j−1 for all x ∈ Dn,kj .

(cid:9), for {S∗

R∗

n,i1

n,i2

n,i

n}. For n (cid:54)= n∗, or n = n∗ and i (cid:54)= i1, i2, we

n,i

that it is a non-trim, strong triangular array for {S∗
let R∗∗

n,i := R∗

n,i. For j = 1, 2, we let:
R∗∗
n∗,i1
R∗∗
n∗,i1
R∗∗
n∗,i2

(x) := (−1)j for all x ∈ Dn∗+1,2k1+j−1 ∪ Dn∗+1,2k2+2−j and
(x) := (−1)j−1 for all x ∈ Dn∗+1,2k1+2−j ∪ Dn∗+1,2k2+j−1,
(x) := (−1)j for all x ∈ Dn∗+1,2k1+2−j ∪ Dn∗+1,2k2+j−1 and

11

(x) := (−1)j−1 for all x ∈ Dn∗+1,2k1+j−1 ∪ Dn∗+1,2k2+2−j.
Clearly R∗∗
are Rademacher, with mean 0 and variance 1 and clearly they depend on
εn∗+1. By construction, we have guaranteed that for all x ∈ Dn∗,k1 ∪ Dn∗,k2 we will have that

R∗∗
n∗,i2
, R∗∗
n∗,i2

n∗,i1

n∗,i1)(x) + R∗
(x) · R∗

(x) = R∗
n}, as required.

(x) = R∗
n∗,i2
This suﬃces to show that the R∗∗
a strong, non-trim triangular array for {S∗

(x) + R∗∗
R∗∗
n∗,i1
R∗∗
n∗,i1

n∗,i2
(x) · R∗∗
n∗,i are independent, and that they sum to S∗

triangular array representation, (cid:8)R∗

n∗. Thus, {R∗∗} is
(cid:3)
The next Proposition is a “non-persistence” result, showing that in any sequence, {πn}, of
admissible permutations, there is no n such that πn+1 extends πn, and that, in any trim, strong
n+1,i (cid:54)=
R∗
n,i. This is in contrast to the situation for the Rn,i, so, as noted at the end of (1.2.2), Proposition
2 begins to answer to Question 4. Item 1. of Proposition 2 appeals to 1. of Lemma 1.
Proposition 2.

n}, for any n, there is some i such that R∗

(cid:9), of {S∗

n∗,i2
n∗,i2

(x) and

(1) If {πn} is any sequence of admissible permutations, then for all n, πn (cid:54)⊆ πn+1 .

(cid:9) is a trim, strong triangular array for {S∗

n}, then for all n, there is 1 ≤ i ≤ n

(2) If (cid:8)R∗

n∗,i1

(x).

n,i

n,i

such that R∗

n+1,i (cid:54)= R∗
n,i.

Proof. For item 1., the most obvious obstacle to having πn ⊆ πn+1 is that there will be k < 2n
such that IStep(n + 1, k) < IStep(n, k). Since Weight (πi(k)) = IStep(i, k), for i = n, n + 1,
clearly Weight (πn+1(k)) < Weight (πn(k)), and therefore πn+1(k) (cid:54)= πn(k), for any such k.

For item 2., note ﬁrst that

Now, let(cid:8)R∗

(cid:9) be a trim, strong triangular array for {S∗

for any k < 2n, Dn,k = Dn+1,2k ∪ Dn+1,2k+1.

n,i

of admissible permutations. Fix n, and, towards a contradiction, assume that R∗
all 1 ≤ i ≤ n. We ﬁrst show that

for all k < 2n and for j = πn+1(2k), πn+1(2k + 1), Dn+1,j ⊆ Dn,πn(k).
We argue this for j = πn+1(2k). The case j = πn+1(2k + 1) is similar. Note that

n}, and {πn} be the associated sequence
n,i for

n+1,i = R∗

for all 1 ≤ i ≤ n, y ∈ Dn+1,j and x ∈ Dn+1,2k, (−1)1+εi(y) = R∗

n+1,i(x).

But any such x is in Dn,k, and, by hypothesis, R∗

n+1,i(x) = R∗

n,i(x), so

n+1,i(x) = R∗
i.e., y ∈ Dn,πn(k). It is then immediate that

(−1)1+εi(y) = R∗

n,i(x) = (−1)1+εi(z) for any z ∈ Dn,πn(k),

Dn,πn(k) = Dn+1,πn+1(2k) ∪ Dn+1,πn+1(2k+1) and so:
{πn+1(2k), πn+1(2k + 1)} = {2πn(k), 2πn(k) + 1} ,

which means that πn+1(2k), πn+1(2k + 1) have opposite parity. Now, however, choose k > 0
so that IStep(n + 1, 2k) = IStep(n + 1, 2k + 1) = 1 and πn+1(2k), πn+1(2k + 1) > 1. Then
(cid:3)
πn+1(2k), πn+1(2k + 1) both have weight 1 and therefore, both are even, contradiction!
3.3. Sequences of Admissible Permutations and their Encodings, Proposition 3. A
sequence, {πn} of permutations of {0, . . . , 2n − 1} (admissible or not) is naturally encoded by the
two-place function Π : N × N → N deﬁned by Π(n, k) = πn(k) for n > 0 and k < 2n, Π(0, 0) = 0
and Π(n, k) = 2n, for k ≥ 2n (including when n = 0 and k > 0). We will approach the question
of the complexity of the sequence in terms of the complexity of its natural encoding.

The next Proposition gives our general lower complexity bound statement for arbitrary se-
quences of admissible permutations. We follow the general approach developed in the ﬁrst para-
graph of (1.3.5).
Proposition 3. The complexity of 2n is a lower bound for the complexity of any sequence of
admissible permutations, and thus for any trim, strong triangular array for {S∗
n}.

12

n(cid:88)

Proof. Let {πn} be any sequence of admissible permutations and let Π be its natural encoding.
A simple, explicit expression for 2n in terms of the n values, Π(n, 1), . . . , Π(n, n), of Π, uniformly
in n is provided by Equation (6), below. Thus, by paragraph 1 of (1.3.5) Equation (6) and its
proof give the statement of the proposition.

i=1

Π(n, i).

For all n > 0, 2n = 1 +

(6)
Equation 6 is immediate, from the following observations. First, IAn,1 = {1, . . . , n}. Second,
IBn,1 is the set of powers of 2 below 2n (since these are the weight 1 positive integers below 2n).
(cid:3)
Finally, πn [IAn,1] = IBn,1.
3.4. The sequence {Fn}, its natural encoding, F , and Theorem 2. For the next Deﬁnition,
recall our invocation of Deﬁnition 3 in (3.1, where the bn,i,s and α(n, i, k) are deﬁned).
Deﬁnition 4. For all n > 0, Fn is the permutation of {0, . . . , 2n − 1} deﬁned as follows.
0 ≤ k < 2n, let i = IStep(n, k). Then

If

Fn(k) := bn,i,s, where s = α(n, i, k).

Then, take F : N × N → N to be the natural encoding of the sequence {Fn}. Also, for use in
(3.5) and referring to the ﬁrst sentence of (3.3), we take InvF : N × N → N to be the natural

encoding of the sequence(cid:8)F −1

(cid:9).

n

In view of 2. of Lemma 1, these Fn are (obviously) very natural admissible permutations of the
{0, . . . , 2n − 1}. Recalling that, ERIB is the enumerating function for RIB, viz. the invocation
of Deﬁnition 3 immediately preceding Remark 3, note that F (n, k) = ERIB(n, i, s), where s is
as in Deﬁnition 4.
Remark 4. Note that our deﬁnition of Fn is equivalent to stipulating that, in terms of the notation
that with i = IStep(n, k) and s = α(n, i, k), then, in fact, s = k − SBC(n, i); further, for these
(cid:3)
i, s, we also have that s = β(n, i, F (n, k)).

used in Equation (5), for all i ≤ n, Fni is the identity permutation of(cid:8)1, . . . ,(cid:0)n
(cid:1)(cid:9). Note, also,
Proposition 4. As functions of (n, i), with i ≤ n, the binomial coeﬃcients (cid:0)n
(cid:1) and SBC are
portion of Pascal’s triangle using the familiar addition identity. This requires O(cid:0)n2(cid:1) additions,

computable in time polynomial in n. The function IStep is P-TIME. Further, the relation RIA
is tame.
Proof. The algorithm for computing the binomial coeﬃcents is simply to generate the needed

and then the computation of SBC(n, i), requires i more additions. All of the summands remain
below 2n, obviously. For additional results on the computation of the binomial coeﬃcients, see
[1], [6]. That IStep is P-TIME then follows immediately from item 1. of Remark 2; note that the
“search” is bounded by n. For the ﬁnal statement, recall (item 2. of Remark 3) that the function
α of Deﬁnition is cdRIA, and let x ∈ Z+. Note that if x < SBC(n, i), then α(n, i, x) = 0, and if
1 + x − SBC(n, i), by Remark 4. Thus, α is P-TIME.
(cid:3)

(cid:1). For SBC(n, i) ≤ x < SBC(n, i + 1) − 1, α(n, i, x) =

x ≥ SBC(n, i + 1) − 1, then α(n, i, x) =(cid:0)n

i

i

i

The next Lemma embodies, in abstract form (to facilitate multiple applications), S. Buss’s
suggestion of combining tameness with a binary search argument to show that if RX is tame
then ERX is P-TIME. Along with Item 6. of Remark 3, Lemma 2 represents the main apport
of the hypothesis of tameness.
Lemma 2. Suppose that Un, the Xn,u, etc., are as in Deﬁnition 3 and suppose that RX is tame.
Then the enumerating function ERX is P-TIME.
Proof. Fix n, u ∈ Un and s with 1 ≤ s ≤ |Xn,u|. Let cd = cdRX be the cardinality function
associated with the Xn,u; by hypothesis, cd is P-TIME. Start from a0 = 0, b0 = 2n − 1, s0 = s.
Having deﬁned ai, bi, si, we let mi := (cid:98)(ai + bi) /2(cid:99) and we consider whether cd (n, u, mi) −
cd (n, u, ai) ≥ si. If so, we take ai+1 = ai, bi+1 = mi, si+1 = si. Otherwise, we take ai+1 =

13

mi, bi+1 = bi, si+1 = si + cdRX (n, u, ai) − cdRX (n, u, mi). Then, clearly, for some k ≤ n we
will have sk = 1, ak = bk − 1 and bk = xn,u,s. Thus, ERX is P-TIME.
(cid:3)

S. Buss also sketched for us an argument that became the proof of the next Lemma.

Lemma 3. (S. Buss) RIB is tame.

Proof. We show that the function β of Deﬁnition 2 is P-TIME. This suﬃces, since by (2) of
Remark 3, β is cdRIB. Let j ≤ n and let b ∈ N with b < 2n. Without loss of generality we may
assume 0 < j, b and j < n. Let (cid:96) = min(j, Weight(b)), so (cid:96) ≥ 1. Let i1 > . . . > i(cid:96) be the (cid:96) largest
i’s such that the ith bit in the binary expansion of b is 1. Clearly (cid:96) and the is are computed in
time polynomial in n.
If j > i1, then β(n, j, b) = 0, so assume that j ≤ i1. If j = 1, then clearly β(n, 1, b) = i1, so
assume that j > 1 and so i1 > 1. If x ∈ N with x ≤ b, then either x = b or there is unique s with
1 ≤ s ≤ (cid:96) such that the s-th bit in the binary expansion of x is 0 but for all 1 ≤ t < s, the t-th
bit in the binary expansion of x is 1.

Note that if 1 ≤ s ≤ (cid:96), then (cid:0) is−1
(cid:1) counts the number of such x < b with Weight(x) = j.
(cid:0) is−1
(cid:1), while otherwise,
Finally, this means that if Weight(b) = j, then β(n, j, b) = 1 +(cid:80)(cid:96)
β(n, j, b) =(cid:80)(cid:96)
(cid:1) is just 1; for is > 1,
of Theorem 2. First, note that, for is = 1, the binomial coeﬃcient(cid:0) is−1

We record a few observations related to the proof of Lemma 3 that will be useful in the proof

(cid:0) is−1

the coeﬃcients that occur in the ﬁnal paragraph of the proof can be expressed in terms of SBC:

(cid:1).

s=1

j+1−s

s=1

j+1−s

j+1−s

j+1−s

(cid:3)

= SBC (is − 1, j + 2 − s) − SBC (is − 1, j + 1 − s) .

(cid:19)

(cid:18) is − 1

j + 1 − s

Thus, the function β has a simple expression in terms of SBC. Next, note that χRIB(n, j, x) = 1
iﬀ (j = x = 1 or (x > 1 and β(n, j, x) = β(n, j, x − 1) + 1)). Thus, χRIB also has a simple
expression in terms of SBC, since β does. This is similar to the argument for item 6. of Remark
3.

Since Weight does not depend on n, we can naturally “put together” the diﬀerent branches,
indexed by n, of the ERIB function into a single enumerating function, EW, for Weight; this is
Deﬁnition 5. The ﬁnal assertion of Corollary 3 is an easy consequence of Lemmas 2, 3: EW is
P-TIME. This result is used in the proof of Theorem 2 and is also of some interest in its own
right, since the sequence http://oeis.org, 2010, Sequence A066884, [9], encodes EW; [9] does not
indicate that this sequence is P-TIME and gives no closed form.
Deﬁnition 5. For j, t ∈ N:

(cid:40)

EW(j, t) :=

0,
the tthm such that Weight(m) = j

if j = 0
if j > 0

Corollary 3. The relations RIA, RIB are P-TIME decidable. The function EW is P-TIME.
The relation between n, k, m expressed by the Equation 7, which follows, is also P-TIME decid-
able. Given n and k < 2n, this equation has a unique solution, m, which, as a function of (n, k),
is also P-TIME.
(7)

β(n, IStep(n, k), m) · χRIB(n, IStep(n, k), m) = α(n, IStep(n, k), k).

Proof. By Proposition 4, RIA is tame, and by Lemma 3, so is RIB. Since the hypothesis of item
6. of Remark 3 clearly holds for RIA, RIB, these relations are P-TIME decidable.

For EW, note that if j > 0, then for any t, taking n = max(j, t) + 1, we will have t ≤(cid:0)n

(cid:1).

Therefore, EW(j, t) < 2n, and so EW(j, t) = ERIB(n, j, t). Since RIB is P-TIME decidable,
χRIB is P-TIME, and so the third sentence of the Corollary is immediate from Lemma 3 and the
ﬁrst sentence.

j

14

Let j = IStep(n, k) and note that α(n, j, k) > 0. This is the point of multiplying by
χRIB(n, j, m): to ensure that m ∈ IBn,j. The unique solution m is computed as EW(j, k +
1 − SBC(n, j)).
(cid:3)

The observations in the last paragraph of the proof of Corollary 3 will be used in the proof
of Theorem 2. Of course the P-TIME decidability of RIA can be established quite simply and
directly from Proposition 4, but the approach taken is more eﬃcient.
Theorem 2. F is P-TIME and simply computed in terms of SBC.
Proof. We ﬁrst argue for the lower complexity bound much as in Proposition 3, but with a slightly
cleaner expression for 2n given by Equation (8), below, rather than by Equation (6). We then
show that F is P-TIME; the upper complexity bound then follows by the general argument given
in (1.3.5). We note:
(8)
For Equation (8), the relevant observations are that n is the largest element of IAn,1, 2n−1 is
the largest element of IBn,1 and that for all n, i, Fn maps IAn,i onto IBn,i in order-preserving
fashion.

2n = F (n, n) + F (n, n).

The rest of the proof follows the strategy laid out in (1.3.5). To see that F is P-TIME we will

For n > 0 and k < 2n, m = F (n, k) < 2n is the unique solution of Equation (7).

argue that
(9)
This is immediate from the last observation given in connection with Equation (8) and clearly
suﬃces to show that F is P-TIME, in view of Lemmas 2, 3 and Corollary 3. That F is simply
computed in terms of SBC follows from Equation (7) since all of the functions that ﬁgure there
are simply computed in terms of SBC. For IStep, this is by item 1. of Remark 2. For α, this is
by item 2. of Remark 3. For β and χRIB this is by the ﬁrst paragraph following the proof of
(cid:3)
Corollary 3.

3.5. Obtaining SBC and related Questions. We begin by showing how to obtain SBC from
F and InvF (the latter was also introduced in Deﬁnition 4).
Corollary 4. SBC is simply computed in terms of F and InvF . InvF is simply computed in
terms of SBC. Thus, the joint complexity of F and InvF is exactly that of SBC.
Proof. For the ﬁrst assertion, recall that SBC(n, 0) = 0 and note that SBC(n, n + 1) = 2n. For

1 ≤ i ≤ n, note that SBC(n, i) = InvF(cid:0)n, 2i − 1(cid:1). But 2i − 1 = 2F (i, i) − 1.

That InvF is simply computable from SBC follows from the material of (3.4), and in particular

from the following “dual version” (interchanging Step and Weight) of Equation 7:
α(n, Weight(m), k) · χRIA(n, Weight(n, m), k) = β(n, Weight(m), m).

As in (3.4), all of the functions in the previous displayed equation are simply computed from
SBC, and, given (n, m), the unique solution, k, is computed as SBC(n, Weight(m), t), where
m = EW(Weight(m), t). We can easily compute t from SBC (and EW) using a binary search
. But this unique solution is just InvF (n, m). The
argument with initial interval
(cid:3)
ﬁnal assertion is immediate from the ﬁrst two.

1,(cid:0)

(cid:1)(cid:105)

Weight(m)

(cid:104)

n

Remark 5. It would be ideal if we could show that SBC is simply computed from F alone, since
then the complexity of F would be exactly that of SBC. The speciﬁc obstacle is being able to
carry out the calculation of t in the last sentence of the proof of the Corollary in terms of F alone,
without the use of the binomial coeﬃcient or the function EW. An indication that this obstacle
may be serious is the general phenomenon that an inverse of a function, f, can be signiﬁcantly
more complex than f itself. Symmetrically, if we could eliminate the use of F to compute 2i − 1,
it would follow that the complexity of InvF is exactly that of SBC. This seems somewhat more
feasible.

15

We conclude this section by tieing up some “odds and ends”. We ﬁrst argue that {Fn} is
the simplest sequence of admissible permutations, and so its corresponding triangular array
representation is the simplest trim, strong triangular array representation for {S∗
n}. Finally, we
make some observations concerning the contrast between Equations (6) and (8) in light of this
status of {Fn}.
Remark 4 and the proof of item 2. of Lemma 1 are the main elements of our argument
that {Fn} is the simplest sequence of admissible permutations. Recall that each Fn (cid:22) IAn,i
is the order-preserving bijection between IAn,i and IBn,i. While the claim that this is the
simplest bijection between these sets may not be entirely clear, it is far clearer that the identity

(cid:1)(cid:9) is the simplest permutation of this set. By Remark 4, each F n,i is
(cid:1)(cid:9) and so from the point of view of the proof of Lemma 1

permutation on(cid:8)1, . . . ,(cid:0)n
the identity permutation on(cid:8)1, . . . ,(cid:0)n

and the subsequent paragraph, {Fn} really is simplest, since it is represented by the system where
each σn,i is the identity permutation. It should, however, be acknowledged that we have “built
in” the role of the increasing enumerations in this way of representing admissible permutations.
Regarding the contrast between Equations (6) and (8), what is really at issue is to be able
−1 (2n) as a function of n, since, trivially, we’ll always have
to easily identify k(n) = (πn+1)
that 2n = πn+1(k(n)). For {Fn}, Equation (8) is based on the easy identiﬁcation of k(n) as
It is then natural to expect that for more complex sequences {πn}, the
simply being n + 1.
corresponding function k(n) will also be more complex, leaving us only Equation (6) rather than
a simple analogue of Equation (8). This has some features in common with the issues discussed
in Remark 5, above.

i

i

4. Construction of the Variants of F and Theorem 3

4.1. The functions G and H. Here we construct the variants, G (Deﬁnition 7) and H (Def-
inition 11), of F . We impose additional requirements on the admissible permutations, Gn and
Hn, respectively, that are to be encoded.

The motivation for introducing these variants is to obtain sequences of permutations whose
natural encodings are still P-TIME, with SBC as an upper complexity bound (this will be the
content of Theorem 3) and where the orbit structures of the individual permutations are simpler
than those of the Fn. We construct the Gn so as to maximize the number of ﬁxed points. The
construction of the Hn goes farther: once all possible ﬁxed points have been identiﬁed (the same
ones as for the Gn), we maximize the number of two-cycles, so that the Hn are as close as possible
to being self-inverse.
We construct the Gn in two stages: we ﬁrst note the ﬁxed points are the elements of the
IAn,i ∩ IBn,i. We then proceed much as for F : for each 1 ≤ i ≤ n, map “what is left of” IAn,i in
order preserving fashion onto “what is left of” IBn,i. Of course, this requires that these two sets
have the same cardinality; this will be obvious for the construction of Gn, as noted in Remark 6.
We construct the Hn in three stages, with the ﬁrst stage being identical to the ﬁrst stage in
the construction of the Gn. We interpolate a new second stage, where we identify a maximal set
of two-cycles. The third and ﬁnal stage is analogous to the second stage in the deﬁnition of the
Gn, in that, for each 1 ≤ i ≤ n, we map “what is left of” IAn,i in order preserving fashion onto
“what is left of” IBn,i. This time, “what is left” means after removing the ﬁxed points and the
points involved in the two-cycles identiﬁed in the second stage. As in the second stage of the
construction of Gn, in order to carry out the third and ﬁnal stage for the Hn, it must again be
true that for each i, “what is left of” IAn,i has the same cardinality as “what is left of” IBn,i.
This is the content of Proposition 5.

The constructions of the Gn and of the Hn will both be uniform in n, so for the remainder
of this subsection, we take n to be ﬁxed. The next deﬁnition is analogous to Deﬁnition 2. It
introduces the IA1
n,i: “what is left of IAn,i, resp. IBn,i”, after removing the ﬁxed points.
n,i := IBn,i \ (IAn,i ∩ IBn,i) . We

n,i := IAn,i \ (IAn,i ∩ IBn,i) , IB1

n,i and IB1

Deﬁnition 6. For i < n, IA1
also let α0

n,i := |IAn,i ∩ IBn,i|, and set α1

n,i = β

0

n,i :=(cid:12)(cid:12)IA1

n,i

(cid:12)(cid:12) , β1
n,i :=(cid:12)(cid:12)IB1

n,i

(cid:12)(cid:12).

16

We now invoke Deﬁnition 3 with d = 1 and Un = {0, . . . , n} and with Xn,i = IA1
or Xn,i = IB1
n,i. This deﬁnes RIA1, RIB1, cdRIA1, cdRIB1, ERIA1, ERIB1. We use α1, β1
to denote cdRIA1, cdRIB1, respectively. The notation for the increasing enumerations will be
n,i,s, b1
a1
Remark 6. For i < n, the following observations are obvious:

n,i,s.

n,i

n,i =(cid:0)n

(cid:1) − α0

n,i =(cid:0)n

(1) α1
(2) for k ∈ IAn,i, k ∈ IA1

i

(cid:1) − β

0
n,i = β1

n,i,

i

n,i iﬀ IStep(n, k) (cid:54)= i. (cid:3)
Deﬁnition 7. Gn is the permutation of {0, . . . , 2n − 1} deﬁned as follows. If 0 ≤ k < 2n, let
i = IStep(n, k), then:

n,i iﬀ Weight(k) (cid:54)= i; for m ∈ IBn,i, m ∈ IB1
(cid:40)

(10)
Take G : N × N → N to be the natural encoding of the sequence {Gn}.

k
n,i,s where s = α1(n, i, k), otherwise.
b1

Gn(k) :=

if Weight(k) = i

n,i

It is clear that Gn is an admissible permutation of {0, . . . , 2n − 1}, with the additional property
that Gn is the identity on k such that IStep(n, k) = Weight(k), i.e., G is maximal, among
admissible permutations of {0, . . . , 2n − 1}, for agreement with the identity permutation. Further,
in analogy with Remark 4 and (3.5), we argue that G is the simplest such admissible permutation.
n,i. Each

This is based on the analogues of the F n,i deﬁned on(cid:8)1, . . . , α1
of these is the identity on(cid:8)1, . . . , α1

(cid:9), starting from Gn (cid:22) A1

(cid:9).

n,i

Deﬁntions 2 - 4. Our ﬁrst task is to identify those k which will be part of a two-cycle.

We turn now to the deﬁnition of the Hn and H. Once again, we will proceed in analogy with
In order to motivate what follows, suppose that π is an admissible permutation of {0, . . . , 2n − 1}
with the property we have built into Gn: that π(s) = s whenever IStep(n, s) = Weight(s). Sup-
pose further that k (cid:54)= m, π(k) = m and π(m) = k. Let i = IStep(n, k), j = Weight(k). Then
i (cid:54)= j, i = Weight(m), j = IStep(n, m). Stated otherwise, we have that k ∈ IA1
n,j and
m ∈ IA1
Deﬁnition 8. For i, j < n with i (cid:54)= j we set: IC 1

We now invoke Deﬁnition 3 with d = 2 and Un = {(i, j)|0 ≤ i, j ≤ n, i (cid:54)= j} and with
n,i,j. This deﬁnes RIC 1, cdRIC1 , ERIC 1. We use γ1 to denote cdRIC1. The notation

n,i,j :=(cid:12)(cid:12)IC 1

n,j ∩ IB1
n,i.

n,i ∩ IB1

n,i ∩ IB1

n,i,j := IA1

n,j, and γ1

(cid:12)(cid:12).

n,i,j

Xn,i,j = IC 1
for the increasing enumerations will be c1
Remark 7. The following observations are obvious:
n,i =

n,i,j, and IB1

For i < n, IA1

(cid:71)

n,i,j,s.

n,i =

IC 1

(cid:71)

0≤j<n, j(cid:54)=i

0≤j<n, j(cid:54)=i

IC 1

n,j,i.

(cid:3)

It would be natural to attempt to match up the elements of the IC 1

n,i,j with those of correspod-
n,j,i to form the two-cycles. However, the following example shows that even for fairly small
n,j,i.

ing IC 1
n, this will not be possible, since it can happen that for certain i (cid:54)= j, i, j < n, γ1
When n = 8, we have:

n,i,j (cid:54)= γ1

IC 1

8,2,4 = {15, 23, 27, 29, 30}, while IC 1

8,4,2 = {96, 129, 130, 132, 136, 144, 160}.

n,j,i there are various reasonable ways of choosing the γ1

n,i,j > γ1

n,i,j which will form 2-cycles with the elements of IC 1

When γ1
IC 1
in what follows is to exclude the “extreme” elements of IC 1
elements of IC 1
n,j,i. This is codiﬁed in the next Deﬁnition.
Deﬁnition 9. For i, j < n with i (cid:54)= j, let γ1

(cid:1) and set:

n,j,i − many elements of
n,j,i. The particular way we have chosen
n,i,j: those that are farthest from the

(11)

IC

1
n,i,j :=

n,i,j

n,i,j,s|1 ≤ s ≤ γ1
n,i,j,t+s|1 ≤ s ≤ γ1

n,j,i

n,j,i

n,j,i and i > j
n,i,j − γ1

n,j,i otherwise.

IC 1
(cid:8)c1
(cid:8)c1

n,i,j := min(cid:0)γ1
(cid:9)
(cid:9) where t = γ1

n,i,j, γ1
n,i,j ≤ γ1
n,i,j > γ1

if γ1
if γ1

n,j,i

n,j,i

17

In the second or third case, let IC 2

n,i,j := IC 1

n,i,j \ IC

1

n,i,j.

We now invoke Deﬁnition 3 with d = 2 and Un = {(i, j)|0 ≤ i, j ≤ n, i (cid:54)= j} and with
1. We use γ1 to denote cdRIC1. The notation

, cdRIC1, ERIC

Xn,i,j = IC
for the increasing enumerations will be c1

n,i,j. This deﬁnes RIC

1

1

n,i,j,s.

Deﬁnition 10. For i < n, we set:

(cid:71)
n,i :=(cid:12)(cid:12)IB2
(cid:12)(cid:12) and β2

0≤i,j<n, i(cid:54)=j

IC 2

(cid:12)(cid:12).

n,i :=

IA2

n,i :=(cid:12)(cid:12)IA2

n,i

n,i,j and IB2

n,i :=

(cid:71)

0≤i,j<n, i(cid:54)=j

IC 2

n,j,i.

We also set α2

n,i

We now invoke Deﬁnition 3 with d = 1 and Un = {0, . . . , n} and with Xn,i = IA2

n,ior
Xn,i = IB2
n,i. This deﬁnes RIA2, RIB2, cdRIA2 , cdRIB2 , ERIA2, ERIB2. We use α2, β2
to denote cdRIA2, cdRIB2, respectively. The notation for the increasing enumerations will be
n,i,s, b1
a1
Proposition 5. For i < n, α2

n,i,s.

n,i = β2

n,i .

This follows from the deﬁnitions of the IA2
since, by construction, γ1

n,i,j = γ1

n,j,i, for all relevant n, i, j, we have that

n,i,j, and Remark 7. But then,

IC

0≤j<n, j(cid:54)=i

IA2

n,i = IA1

Proof. We note ﬁrst that

n,i \ (cid:71)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Finally, by construction,(cid:12)(cid:12)A1

n,i

(cid:71)
(cid:12)(cid:12) =(cid:12)(cid:12)B1

0≤j<n, j(cid:54)=i

n,i

1

n,i, IB2

n,i = IB1

n,i,j and that IB2

n,i \ (cid:71)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) .
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) =
(cid:12)(cid:12). It then clearly follows that α2

n,i and the IC

0≤j<n, j(cid:54)=i

(cid:71)

1
n,i,j

1
n,j,i

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

IC

IC

1

n,i = β2

n,i.

(cid:3)

IC

1
n,j,i.

0≤j<n, j(cid:54)=i

We can now complete the construction of the Hn. Proposition 5 makes it clear that the third
case of Equation (12), below, will provide a coherent deﬁnition and that the Hn we deﬁne there
are admissible permutations of {0, . . . , 2n − 1} with the additional property of Gn.
Deﬁnition 11. Hn is the permutation of {0, . . . , 2n − 1} deﬁned as follows. If 0 ≤ k < 2n, let
i = IStep(n, k), j = Weight(k). Then:

k

(12)

Hn(k) :=

if j = i

n,i,j,s where s = γ1
c1
where s = α2
b2
n,i,s

n(i, j, k) if k ∈ IC
n(i, k), otherwise.

1
n,i,j

Also (as usual), let: H : N×N → N to be the natural encoding of the sequence {Hn} of admissible
permutations.

With reference to the discussion in the ﬁnal paragraph of (3.5), related to the form of the
lower bound expression, we should note here, that even for G, the situation is somewhat more
complicated: it may fail to be true that Gn(n) = 2n−1 (or, in the notation of the ﬁnal paragraph
of (3.5), that k(n) = n): this will happen exactly if n is is a power of 2, since then Weight(n) =
1 = IStep(n, n) and so Gn(n) = n (cid:54)= 2n. In this case, however, we’ll have that Gn(n− 1) = 2n−1.
This is the basis for Equation (13), below, which is the analogue for G of Equation (8). We have
not carried out a similar analysis of the k(n) function for H, and so, in the proof of Theorem
3, in (4.2), we content ourselves with the general lower bound expression given by Equation (6).
Similar issues represent similar (but even worse) obstacles to obtaining an analogue of Corollary
4 for G or H.

18

4.2. Theorem 3. The analogue of Theorem 2 for the functions G and H is provided by Theorem
3. The lower bound statement argument divides, as just discussed, but things rejoin for the
proof that G and H are P-TIME. Proposition 6 is the main technical tool; it incorporates the
contributions of Proposition 4, Lemma 2, Lemma 3 and Corollary 3 in the proof of Theorem 2.
Proposition 6. Each of the following relations is both P-TIME decidable and tame:
RIA1, RIA1, RIC 1, RIC
(12) are P-TIME decidable.
Proof. For each of the listed relations, the hypothesis of item 6. of Remark 3 clearly holds, and
so it will suﬃce to establish tameness. We weave our way through the statements to be proved in
the following order. First, the P-TIME decidability of the case condition of Equation (10), then
the tameness of RIA1, RIB1, RIC 1, then the P-TIME decidability of the second case condition
, RIA2 and RIB2. Throughout the proof we
of Equation (12) and ﬁnally, the tameness of RIC
will have x ∈ Z+ with x < 2n.

, RIA2, RIB2. Also, all of the case conditions of Equations (10) and

1

1

For the tameness of RIC 1, just note that IC 1

For the tameness of RIA1, note that for each (n, i), IA1

For the case condition of Equation (10) (and the ﬁrst case condition of Equation (12)), our
starting point is Proposition 4, itself. The case condition is just whether IStep(n, k) = Weight(k):
if so, then it is the ﬁrst case of Equations (10), (12) of Deﬁnitions 7, 11 that applies: G(n, k) =
It follows from Proposition 4 that the relation expressed by the last displayed
H(n, k) = k.
equation is P-TIME decidable.
n,i = IAn,i \ (IAn,i ∩ IBn,i). Re-
call that β(n, i, x) − β(n, i, SBC(n, i) − 1) computes |{m ∈ IBn,i|SBC(n, i) ≤ m ≤ x}|.
It fol-
lows that α1(n, i, x) = α(n, i, x) + β(n, i, SBC(n, i) − 1) − β(n, i, x). Similarly, IB1
n,i = IBn,i \
[SBC(n, i), SBC(n, i + 1)). Thus, β1(n, i, x) = β(n, i, x) − α(n, i, x) and so α1 and β1 are both
P-TIME. Therefore, RIA1, RIB1 are both tame.
It follows that if x < SBC(n, i) then γ1(n, i, j, x) = 0, and if SBC(n, i + 1) − 1 ≤ x < 2n then
γ1(n, i, j, x) = β1(n, j, SBC(n, i + 1) − 1) − β1(n, j, SBC(n, i) − 1). Finally, if SBC(n, i) ≤ x <
SBC(n, i + 1) − 1, then γ1(n, i, j, x) = β1(n, j, x) − β1(n, j, SBC(n, i) − 1). Thus, γ1 is P-TIME
and so RIC 1 is tame. Note that by Lemmas 2 and 3, we have that ERIC 1 is P-TIME, i.e., for
all relevant (n, i, j) and all s with 1 ≤ s ≤ γ1
1, note that if γ1

n,j|SBC(n, i) ≤ m < SBC(n, i + 1)(cid:9) .

γ1
n,i,j > γ1
n,i,j,s < x < 2n, then γ1(n, i, j, x) = s. Finally, if γ1
c1
x < c1
t. Thus, γ1 is P-TIME, and so RIC
this explicitly only because it is exactly the second case condition of Equation (12).

If
n,i,j,s, then γ1(n, i, j, x) = γ1(n, i, j, x), while if
n,j,i. If
n,i,j,t+1 ≤ x < 2n, then γ1(n, i, j, x) = γ1(n, i, j, x)−
1 is tame, and therefore is P-TIME decidable. We mention

n,i,j =(cid:8)m ∈ IB1

n,i,j,s is a P-TIME function of (n, i, j, s).

n,i,j,t+1, then γ1(n, i, j, x) = 0, while if c1

n,j,i, then γ1(n, i, j, x) = γ1(n, i, j, x).

n,j,i and i > j, let s = γ1

n,i,j, c1
n,i,j ≤ γ1

For the tameness of RIC

n,i,j > γ1

n,j,i and i < j, let t = γ1

n,i,j −γ1

n,j,i. If x ≤ c1

Finally, we show that RIA2 and RIB2 are tame. For RIA2, if 0 < i ≤ n, note:

Then, β2(n, i, x) = β1(n, i, x) −

γ1(n, j, i, x), so RIB2 is tame.

(cid:3)

Theorem 3. Each of G, H is P-TIME and is simply computed in terms of SBC.

19

If x < SBC(n, i), then α2(n, i, x) = 0; otherwise:

γ1(n, i, j, x),

and so RIA2 is tame. For RIB2, we have the analogous observation: for 0 < i ≤ n

1≤j≤n, j(cid:54)=i

IA2

n,i = IA1

n,i \ (cid:71)
α2(n, i, x) = α1(n, i, x) − (cid:88)
n,i \ (cid:71)

n,i = IB1

IB2

1≤j≤n, j(cid:54)=i

1≤j≤n, j(cid:54)=i

(cid:88)

1≤j,IStep(n,x), j(cid:54)=i

IC

1
n,i,j.

IC

1
n,j,i.

Proof. As already indicated, we do not attempt to improve on Equation (6) for the lower bound

statement for H. For G, however, we do note that IStep(cid:0)n, 2n−1(cid:1) = (cid:98)(n + 1)/2(cid:99) > 1. Thus,
−1(cid:0)2n−1(cid:1), then k is the largest element

2n−1 is the largest element of IB1
n,1. As noted at the end of (4.1), possibly k (cid:54)= n (if n is a power of 2), but, if k (cid:54)= n, then
of IA1
k = n − 1 (since (1, 2) is the only pair of consecutive 2-powers). Thus, our analogue of Equation
(8) for G is:

n,1, and so if k = (Gn)

(13)

2n = max(G(n, n), G(n, n − 1)) + max(G(n, n), G(n, n − 1)).

Turning to the proof that G and H are P-TIME, we know, by Proposition 6, that the case
conditions are P-TIME decidable, and that in the ﬁrst case we have G(n, k) = H(n, k) = k. For
each of the remaining cases (case 2, for G and cases 2, 3, for H), we exhibit P-TIME decidable
relations involving n, k, m whose unique solution, m, is less than 2n, is P-TIME and is the value
of G(n, k) (resp. H(n, k)) as determined by the case in question. This is done in Equations (14),
(15), (16).

For readability, we will use i as an abbreviation for IStep(n, k) in each of these equations,
and in Equation (15), we will also use j as an abbreviation for Weight(k), but the relations
expressed by these equations really involve only n, k, m. The P-TIME computability of the
unique solutions depends on Proposition 6, and on Lemma 2 (for the P-TIME computability
of the relevant enumerating function) and will be established by exhibiting an equation that
speciﬁes the computation.

For case 2 of Equation (10), the P-TIME decidable relation is:

(14)

β1(n, i, m)χRIB1(n, i, m) = α1(n, i, k).

The P-TIME computability of the unique solution m = G(n, k) of Equation (14) is established
by:

if RIA1(n, i, k) holds, then G(n, k) = ERIB1(n, i, α1(n, i, k)).

For case 2 of Equation (12), the P-TIME decidable relation is:

(15)

γ1(n, j, i, m)χRIC1 (n, j, i, m) = γ1(n, i, j, k).

The P-TIME computability of the unique solution m = H(n, k) of Equation (15) is established
by:

if RIC

1

(n, i, j, k) holds, then H(n, k) = ERIC

1

(n, j, i, γ1(n, i, j, k)).

Finally, for case 3 of Equation (12), the P-TIME decidable relation is:

(16)

Note also that

β2(n, i, m)χRIB2(n, i, m) = α2(n, IStep(n, k), k).

if RIA2(n, i, k) holds, then H(n, k) = ERIB2(n, i, α2(n, i, k)).

This means that H(n, k) is the unique solution of Equation (16), and thus is P-TIME.

The argument that each of G, H is simply computed in terms of SBC is similar to that in
Theorem 2, and involves the straightforward veriﬁcation that all of the functions involved in
Equations (14), (15), (16) are simply computed in terms of SBC. This traces back to examining
the proof of Proposition 6. Each of α1, β1 is explicitly and simply computed in terms of α, β
and SBC. Next, γ1 is explicitly and simply computed in terms of β1 and SBC. Then, γ1 is
explicitly and simply computed in terms of γ1. Next, α2 is simply and explicitly computed in
terms of α1 and γ1, while β2 is simply and explicitly computed in terms of β1, γ1 and IStep.
Finally, χRIB1, χRIC1 and χRIB2 can then be computed simply in terms of SBC using the second
(cid:3)
observation in the ﬁrst paragraph following the proof of Lemma 3.

20

References

[1] Beame, P. W., Cook, S. A., Hoover, H. J.: Log depth circuits for division and related problems. Siam Journal
on Computing 15, 994-1003 (1986).
[2] Berti, P., Pratelli, L.,Rigo, P.: Skorohod representation theorem via disintegrations. Sankhy¯a: The Indian
Journal of Statistics 72-A, 208-220 (2010).
[3] Berti, P., Pratelli, L., Rigo, P.: A Skorohod representation theorem for uniform distance. Probability Theory
and Related Fields150(1-2), 321-335 (2011).
[4] Clote, P., Kranakis, E.: Boolean Functions and Computation Models. Springer , Berlin-Heidelberg-New York
(2002).
[5] Dudley, R.M.: Real Analysis and Probability. Cambridge U. Press, Cambridge (1989).
[6] Hesse, W., Allender, E., Barrington, D. A. M: Uniform constant-depth threshold circuits for division and
iterated multiplication. Journal of Computer and System Sciences 65, 695-716 (2002).
[7] Khintchine, A.: Über dyadische brüche. Math. Zeit. 18, 109-116 (1923).
[8] Kolmogoroﬀ, A.: Über das gesetz des iterierten logarithmus. Math. Ann.101, 126-135 (1929).
[9] The On-Line Encyclopedia of Integer Sequences, published electronically at http://oeis.org.
[10] Papadimitriou, C. H.: Computational Complexity. Addison-Wesley, Reading (1994).
[11] Skorokhod, A. V.: Limit theorems for stochastic processes.Theory of Probability and its Applications 1,
261-290 (1956).
[12] Skyers, M.: A tale of two sequences: a story of convergence, weak and almost sure. Dissertation, Lehigh
University (2012).

Department of Mathematics, Lehigh University, 14 East Packer Avenue, Bethlehem, PA 18015
E-mail address: vd00@lehigh.edu

Department of Mathematics, Lehigh University, 14 East Packer Avenue, Bethlehem, PA 18015
E-mail address: marinaskyers@gmail.com

Department of Mathematics, Lehigh University, 14 East Packer Avenue, Bethlehem, PA 18015
E-mail address, Corresponding author: ljs4@lehigh.edu

21

