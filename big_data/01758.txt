6
1
0
2

 
r
a

 

M
0
2

 
 
]

O
L
.
s
c
[
 
 

2
v
8
5
7
1
0

.

3
0
6
1
:
v
i
X
r
a

NORMAL-ORDER REDUCTION GRAMMARS

MACIEJ BENDKOWSKI

Abstract. We present an algorithm which, for given n, generates an un-
ambiguous regular tree grammar deﬁning the set of combinatory logic
terms, over the set {S, K} of primitive combinators, requiring exactly
n normal-order reduction steps to normalize. As a consequence of the
famous Curry and Feys’s standardization theorem, our reduction gram-
mars form a complete syntactic characterization of normalizing com-
binatory logic terms. We investigate the size of generated grammars,
giving a primitive recursive upper bound.

1. Introduction

Since the pioneering works of Moses Sch¨onﬁnkel [8] and Haskell Curry [5],
combinatory logic is known as a powerful, yet extremely simple in structure,
formalism expressing the notion of computability. With the dawn of func-
tional programming languages in the early 1970s, combinatory logic, with
its standard normal-order reduction scheme [6], is used as a practical imple-
mentation of lazy semantics in languages such as SASL [9] or its successor
Miranda [10]. Lack of bound variables in the language resolves the intrinsic
problem of substitution in λ-calculus, making the reduction relation a simple
computational step and so, in consequence, the leading workhorse in imple-
menting call-by-need reduction schemes. It has therefore direct impact on
the encoded computation running time, as each terminating computation
requires some ﬁnite number of normal-order reduction steps to normalize.
Although the problem of determining whether a given term x reduces in n
normal-order steps is easy to decide, the naive approach of reducing x using
up to n reduction steps does not reveal the underlying structure of x. In this
paper, we construct an inﬁnite sequence of regular tree grammars {Rn}n∈N
deﬁning the set of terms requiring exactly n normal-order reduction steps
to normalize. Our approach gives therefore a complete syntactic character-
ization of normalizing combinatory logic terms. Finally, we investigate the
size of the reduction grammars giving a primitive recursive upper bound on
the number of productions in Rn.

The paper is organized as follows. In Sections 1.1 and 1.2 we give prelim-
inary deﬁnitions and notational conventions used in the paper. In Section 2
we present a high-level overview on the algorithm, followed with a formal
pseudo-code representation. In Section 3 we analyse the algorithm giving
proofs of soundness 3.2, completeness 3.3 and unambiguity 3.4.
In Sec-
tion 3.5 we study some practical consequences and applications of reduction
grammars. In Section 3.6 we investigate the size of the generated grammars.

This work was partially supported within the grant 2013/11/B/ST6/00975 founded by

the Polish National Science Center.

1

2

MACIEJ BENDKOWSKI

1.1. Combinatory Logic. We consider the set of terms over primitive com-
binators S and K. In other words, the set C of combinatory logic terms is
deﬁned as C := S | K | C C. We follow standard notational conventions
(see e.g. [3]) — we omit outermost parentheses and drop parentheses from
left-associated terms, e.g. instead of ((SK)(KK)) we write SK(KK). We
use →w to denote the normal-order reduction relation (reduce the leftmost
outermost redex) to which we usually refer brieﬂy as the reduction relation.
We use lower case letters x, y, z, . . . to denote combinatory logic terms. For
an introduction to combinatory logic we refer the reader to [3], [6].

1.2. Regular tree grammars. In order to characterize terms normaliz-
ing in n steps we use regular tree grammars (see e.g. [4]), a generalization
of regular word grammars. A regular tree grammar G = (S, N, F , P ) con-
sists of an axiom S, a set N of non-terminal symbols such that S ∈ N , a set
of terminal symbols F with corresponding arities and a ﬁnite set of pro-
duction rules P of the form α → β where α ∈ N is a non-terminal and
β ∈ TF (N ) is a term in the corresponding term algebra TF (N ), i.e. the set
of directed trees built upon terminals F according to their associated ari-
ties. To build terms of grammar G, we start with the axiom S and use the
corresponding derivation relation, denoted by →, as deﬁned through the set
of production rules P .

Example 1. Consider the following regular tree grammar deﬁned as B =
(S, N, F , P ) where S := B, N := {B}, F := {•, ◦(·, ·)}, and P consists of the
two following rules:

B → ◦(B, B)
B → •

Note that B deﬁnes the set of terms isomorphic to plane binary trees where
leafs correspond to the nullary constant • and inner nodes correspond to the
binary terminal ◦(·, ·).

In our endeavour, we are going to recursively construct regular tree gram-
mars generating sets of combinatory logic terms. We set a priori their axioms
and both terminal and non-terminal symbols, leaving the algorithm to deﬁne
the remaining production rules. And so, the nth grammar Rn will have:

(1) an axiom S = Rn,
(2) a set F of terminal symbols consisting of two nullary constants S,

K and a single binary application operator,

(3) a set of non-terminal symbols N = {C} ∪ {R0, . . . , Rn} where C
denotes the axiom of the set of all combinatory logic terms, as deﬁned
in the previous section.

In other words, the grammar Rn deﬁning terms normalizing in n steps, will
reference all previous grammars R0, . . . , Rn−1 and the set of all combinatory
logic terms C.

Throughout the paper, we adopt the following common deﬁnitions and no-
tational conventions regarding trees. We use lower case letters α, β, γ, δ, . . .
to denote trees, i.e. elements of the term algebra TF (N ) where N = {C} ∪
{R0, . . . , Rn} for some n. Whenever we want to use a combinator without
specifying its type, we use capital letters X, Y, . . .. We deﬁne the size of α

NORMAL-ORDER REDUCTION GRAMMARS

3

as the number of applications in α. We say that α is normal if either α
is of size 0, or α = Xα1 . . . αm, for some m ≥ 1, where all α1, . . . , αm are
normal. In the latter case we say moreover that α is complex. Since we are
going to work exclusively with normal trees, we assume that all trees are
henceforth normal. We say that a complex α is of length m if α is in form
of Xα1 . . . αm. Otherwise, if α is not complex, we say that it is of length 0.
The degree of α, denoted as ρ(α), is the minimum natural number n such
that α does not contain references to any Ri for i ≥ n. In particular, if α
does not reference any reduction grammar, its degree is equal to 0. We use
LG(α) to denote the language of α in grammar G. Since Rn does not refer-
ence grammars of greater index, we have LRρ(α)−1(α) = LRn(α) for arbitrary
n ≥ ρ(α). And so, for convenience, we use L(α) to denote the language of α
in grammar Rρ(α)−1 if ρ(α) > 0. Otherwise, if ρ(α) = 0 we assume that
L(α) denotes the language of α in grammar C. Finally, we say that two
normal trees are similar if both start with the same combinator X and are
of equal length.

Example 2. Consider the following trees:

(1) α = S(KR1)C, and
(2) β = K(CS)R0.

Note that both α and β are of size 3 and of equal length 2, although they
are not similar since both start with diﬀerent combinators. Moreover, only
α is normal as β has a subtree CS, which is of positive size, but does not
start with a combinator. Since α contains a reference to R1 and no other
reduction grammar, its degree is equal to 2, whereas the degree of β is equal
to 1.

A crucial observation, which we are going to exploit in our construction,
is the fact that normal trees preserve length of generated terms. In other
words, if α is of length m ≥ 1, then any term x ∈ L(α) is of length m as
well, i.e. x = Xx1 . . . xm.

2. Algorithm

The key idea used in the construction of reduction grammars is to generate
new productions in Rn+1 based on the productions in Rn. Necessarily, any
term normalizing in n + 1 steps reduces directly to a term normalizing in n
steps, hence their syntactic structure should be closely related. As the base
of our inductive construction, we use the set of normal forms R0 given by

R0 := S | K | SR0 | KR0 | SR0R0.

Clearly, primitive combinators S and K are in normal form. If we take
a normal form x, then both S x and K x are again normal since we did not
create any new redex. For the same reason, any term Sx1x2 where x1 and x2
are normal forms, is itself in normal form. And so, with the above grammar
we have captured exactly all redex-free terms.

Let us consider productions of R0. Note that from both the cases of SR0
and KR0 we can abstract a more general rule — if x reduces in n steps,
then Sx and Kx reduce in n steps as well, since after reducing x we have
no additional redexes left to consider. It follows that any Rn should contain

4

MACIEJ BENDKOWSKI

productions SRn and KRn. Similarly, from the case of SR0R0 we can
abstract a more general rule — if Sx1x2 reduces in n steps, then both x1
and x2 must reduce in total of n steps. The normal-order reduction of Sx1x2
proceeds to normalize x1 and x2 sequentially. As there is no head redex,
after n steps we obtain a term in normal form. And so, Rn should also
contain productions SRiRn−i for i ∈ {0, . . . , n}.

As we have noticed, all the above productions do not contain head redexes
and hence do not increase the total amount of required reduction steps to
normalize. Formalizing the above observations, we say that α is short if
either α = Xα1 or α = Sα1α2. Otherwise, α is said to be long. Hence,
we can set a priori the short productions of Rn for n ≥ 1 and continue to
construct the remaining long productions. Naturally, as we consider terms
over two primitive combinators S and K, we distinguish two types of long
productions, i.e. S- and K-Expansions.

2.1. K-Expansions. Let us consider a production α = Xα1 . . . αm where
m ≥ 0. We deﬁne the set K-Expansions(α) as

nK(Xα1 . . . αk)Cαk+1 . . . αm | k ∈ {0, . . . , m − 1}o.

Proposition 3. Let x ∈ L(K(Xα1 . . . αk)Cαk+1 . . . αm). If x →w y, then
y ∈ L(Xα1 . . . αm).

Proof. Let x = K(Xx1 . . . xk)zxk+1 . . . xm. Let us consider its direct reduct
y = Xx1 . . . xkxk+1 . . . xm. Clearly, xi ∈ L(αi) for i ∈ {1, . . . , m} which
ﬁnishes the proof.
(cid:3)

In other words, the set K-Expansions(α) has the crucial property that
any K-Expansion of α generates terms that reduce in one step to terms
generated by α.
If we compute the sets K-Expansions(α) for all pro-
ductions α ∈ Rn, we have almost constructed all the long K-productions
of Rn+1. What remains is to include the production KRnC as any term
x ∈ L(KRnC) reduces directly to y ∈ L(α) for some production α ∈ Rn.
We use the following subroutine computing the set of K-Expansions for
a given α.

Algorithm: K-Expansions

Γ ← ∅
for k ∈ {0, . . . , m − 1} do

1: function K-expansions(Xα1 . . . αm)
2:
3:
4:
5:
6:
7: end function

Γ ← Γ ∪ {K(Xα1 . . . αk)Cαk+1 . . . αm}

end for
return Γ

2.2. S-Expansions. Let us consider a production α = Xα1 . . . αm where
m ≥ 0. We would like to deﬁne the set S-Expansions(α) similarly to
K-Expansions(α), i.e. in such a way that any term generated by an S-
Expansion of α reduces in a single step to some y ∈ L(α). Unfortunately,
deﬁning and computing such a set is signiﬁcantly more complex than the
corresponding K-Expansions(α).

NORMAL-ORDER REDUCTION GRAMMARS

5

Let q = Xx1 . . . xkz(yz). Suppose that q ∈ L(α) for some production α ∈
Rn. Evidently, S(Xx1 . . . xk)yz →w q and so we would like to guarantee that
q ∈ L(β) for some β ∈ S-Expansions(α). Assume that α = Xα1 . . . αkγδ
where z ∈ L(γ) and yz ∈ L(δ). Unfortunately, in order to guarantee that we
capture all terms reducing to α via an S-redex and nothing more, we cannot
use both γ and δ directly. We require an additional ’rewriting’ operation
that would extract the important sublanguages of γ and δ so that we can
operate on them, instead of γ and δ.

Hence, let us consider the following rewriting relation ⊲, extending the

standard derivation relation:

α ⊲ β ⇔ α → β ∨ (α = C ∧ ∃n∈N β = Rn) .

We use D to denote the transitive-reﬂexive closure of ⊲. The important
property of D is the fact that if α D β, then L(β) ⊆ L(α). To denote the
fact that α does not rewrite to β and vice versa, we use the symbol α k β.
In such case we say that α and β are non-rewritable. Otherwise, if one
of them rewrites to the other, meaning that α and β are rewritable, we use
the symbol α ⊲⊳ β.

2.2.1. Mesh Set. In the endeavour of ﬁnding appropriate S-Expansions
rewritings, we need to ﬁnd common meshes of given non-rewritable trees
α k β. In other words, a complete partition of L(α) ∩ L(β) using all possible
trees γ such that α, β D γ. For this purpose, we use the following MeshSet
pseudo-code subroutine.

Algorithm: Mesh Set

if α = Xα1 . . . αm and β = Xβ1 . . . βm then

for i ∈ {1, . . . , m} do

else if βi D αi then

else

end if

if αi D βi then

γi ← {βi}

γi ← {αi}

1: function MeshSet(α, β)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22: end function

return Sδ∈Rk
return Sδ∈Rk

end if

end if

else

return ∅

else

γi ← MeshSet(αi, βi)

end for
return {X} × γ1 × · · · × γm

if α = Rk and β is complex then
MeshSet(δ, β)

else if β = Rk and α is complex then

MeshSet(α, δ)

6

MACIEJ BENDKOWSKI

If α and β are similar, then we consider their arguments pairwise, con-
structing sets γi of applicable rewritings. Using them, we construct the
Cartesian product of meshes and return it as the ﬁnal result. Otherwise,
if α and β are not similar, however one of them is a reduction grammar
symbol, we construct a union of all meshes created from productions of the
appropriate reduction grammar. In any other case, we return ∅.

Example 4. Let α = KCR0S and β = KS(SR0C)S. Let us consider
MeshSet(α, β). Both α and β are similar and complex, hence MeshSet
proceeds directly to construct mesh sets of corresponding arguments of α
and β. Since C D S, we get γ1 = {S}. Then, as both R0 and SR0C are non-
rewritable, γ2 = MeshSet(R0, SR0C). It follows that MeshSet(R0, SR0C)
MeshSet(δ, SR0C). After a quick inspection, we note
that MeshSet(R0, SR0C) = {SR0R0} and thus γ2 = {SR0R0}. Finally,
γ3 = {S} as S rewrites trivially to itself. Since each γi is a singleton, it
follows that

is equal to Sδ∈R0

MeshSet(α, β) = {KS(SR0R0)S}.

We leave the analysis of MeshSet until we fully deﬁne the construction

of reduction grammars {Rn}n∈N.
2.2.2. Rewriting Set. Consider again our example of q = Xx1 . . . xkz(yz) ∈
L(α) where α = Xα1 . . . αkγδ such that both z ∈ L(γ) and yz ∈ L(δ). In
order to capture terms reducing to α via an S-redex, we need to ﬁnd all
pairs of trees η, ζ such that γ D ζ and δ D η ζ. Since such pairs of trees
follow exactly the structure of z(yz) we can use them to deﬁne the set
S-Expansions(α). And so, to ﬁnd such rewriting pairs, we use the following
RewritingSet pseudo-code subroutine.

Algorithm: Rewriting Set

if β ∈ {S, K} then

return {C α}

end if
if β = Rk then

return ∅

end if
if β = C then

return Sγ∈Rk

1: function RewritingSet(α, β)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20: end function

end if
if β = Xβ1 . . . βm then

return {Xβ1 . . . βm}

else

end if

end if

return {Xβ1 . . . βm−1} × MeshSet(α, βm)

RewritingSet(α, γ)

if α D βm then

else if βm D α then

return {Xβ1 . . . βm−1 α}

NORMAL-ORDER REDUCTION GRAMMARS

7

In RewritingSet(α, β) we consider several cases based on the structure
of β. If β is a primitive combinator, then we return ∅. If β is equal to C,
then we return a single tree C α. If β = Rk, then we consider productions
of Rk and take the union of corresponding rewriting sets. Finally, if β is
complex, we look at its ﬁnal argument βn. In the case α ⊲⊳ βn, we return
a single rewriting tree. Otherwise, we have two non-rewritable trees which,
depending on the outcome of MeshSet(α, βn), results in a potentially empty
set of rewriting trees.

know that RewritingSet(S, R0) = Sγ∈R0

Example 5. Let us consider RewritingSet(S, R0). Since β = R0, we
It fol-
lows therefore that in order to compute RewritingSet(S, R0), we have to
consider rewriting sets involving productions of R0. Note that both pro-
ductions S and K do not contribute new trees.
It remains to consider
productions SR0, KR0 and SR0R0. Evidently, each of them is complex and
has R0 as its ﬁnal argument. Hence, their corresponding rewriting sets are
SS, KS and SR0S, respectively. And so, we obtain that

RewritingSet(S, γ).

RewritingSet(S, R0) = {SS, KS, SR0S}.

Similarly to the case of MeshSet, we postpone the analysis until we

deﬁne the construction of {Rn}n∈N.

Equipped with the notion of rewriting sets, we are ready to deﬁne the
set of S-Expansions. And so, let α = Xα1 . . . αm where m ≥ 0. The set
S-Expansions(α) is deﬁned as

nS(Xα1 . . . αk)ϕlϕrαk+3 . . . αm | k ∈ {0, . . . , m − 2}o,

where (ϕlϕr) ∈ RewritingSet(αk+1, αk+2). We use the following subrou-
tine computing the set of S-Expansions for a given α.

Algorithm: S-Expansions

E ← ∅
for k ∈ {0, . . . , m − 2} do

1: function S-expansions(Xα1 . . . αm)
2:
3:
4:
5:
6:
7:
8:
9: end function

for (ϕl ϕr) ∈ RewritingSet(αk+1, αk+2) do
E ← E ∪ {S(Xα1 . . . αk)ϕlϕrαk+3 . . . αm}

end for

end for
return E

Proposition 6. Let x ∈ L(S(Xα1 . . . αk)ϕlϕrαk+3 . . . αm). If x →w y, then
y ∈ L(Xα1 . . . αkϕr(ϕl ϕr)αk+3 . . . αm).

Proof. Let x = S(Xx1 . . . xk)wzxk+3 . . . xm. Let us consider its direct reduct
y = Xx1 . . . xkz(w z)xk+3 . . . xm. Clearly, xi ∈ L(αi) for i in proper range.
Moreover, both w ∈ L(ϕl) and z ∈ L(ϕr), which ﬁnishes the proof.
(cid:3)

As in the case of K-Expansions(α), the set S-Expansions(α) has the
property that each S-Expansion of α generates terms that reduce in one
step to terms generated by α. We prove this fact later in Section 3.2.

8

MACIEJ BENDKOWSKI

2.3. Pseudo-code. With the complete and formal deﬁnitions of both S-
and K-Expansions we are ready to give the main algorithm, which for
given n ∈ N constructs the grammar Rn.

Main algorithm: Reduction Grammar

return R0 := S | K | SR0 | KR0 | SR0R0

else

if n = 0 then

Γ ← Γ ∪ {SRn−iRi}

Γ ← {SRn, KRn}
for i ∈ {0, . . . , n} do

1: function ReductionGrammar(n)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16: end function

end for
return Rn := Γ

end if

end for
Γ ← Γ ∪ {KRn−1C}
for (Xα1 . . . αm) ∈ ReductionGrammar(n − 1) do

Γ ← Γ ∪ K-expansions(Xα1 . . . αm)
Γ ← Γ ∪ S-expansions(Xα1 . . . αm)

Example 7. Let α = SSSR0. Since α ∈ S-Expansions(SR0R0) we get
α ∈ R1. Note that S-Expansions(α) contains β1 = S(SS)SS and β2 =
S(SS)KS. It follows that β1, β2 ∈ R2.

3. Analysis

3.1. Tree potential. Most of our proofs in the following sections are using
inductive reasoning on the underlying tree structure. Unfortunately, in cer-
tain cases most natural candidates for induction such as tree size fail due to
self-referencing productions, i.e. productions of Rn which explicitly use the
non-terminal symbol Rn. In order to remedy such problems, we introduce
the notion of tree potential π(α), deﬁned inductively as

π(S) = π(K) = π(C) = 0,

m

π(Xα1 . . . αm) = m +

π(αi),

Xi=1

π(Rn) = 1 + max

π(γ)

γ∈Φ(Rn)

where Φ(Rn) denotes the set of productions of Rn which do not use the
non-terminal symbol Rn. Note that such a deﬁnition of potential is almost
identical to the notion of tree size. The potential of α is the sum of α’s size
and the weighted sum of all non-terminal grammar symbols occurring in α.
Immediately from the deﬁnition we get π(R0) = 1. Moreover, π(Rn+1) >
π(Rn) for any n ∈ N. Indeed, let α ∈ Rn be the witness of Rn’s potential.
Clearly, (Kα C) ∈ Φ(Rn+1) and so Rn+1 has necessarily greater potential.
Moreover, π(α) > π(β) if β is a subtree of α. It follows that the notion of tree
potential is a good candidate for the intuitive tree complexity measure.

NORMAL-ORDER REDUCTION GRAMMARS

9

3.2. Soundness. In this section we are interested in the soundness of Re-
duction Grammar. In particular, we prove that it is computable, termi-
nates on all legal inputs and, for given n, constructs a reduction grammar
Rn generating only terms that require exactly n steps to normalize.
Let us start with showing that the rewriting relation is decidable.

Proposition 8. It is decidable to check whether α D β.

Proof. Induction over n = π(α) + π(β).
If α = X, then the only tree α
rewrites to is X. On the other hand, if α = C, then α rewrites to any β.
And so, it is decidable to check whether α D β in case n = 0. Now, let us
assume that n > 0. We have two remaining cases to consider.

(1) If α = Xα1 . . . αm, then α D β if and only if β = Xβ1 . . . βm and αi D
βi for all i ∈ {1, . . . , m}. Since the total potential of π(αi) + π(βi) is
less than n, we can use the induction hypothesis to decide whether all
arguments of α rewrite to the respective arguments of β. It follows
that we can decide whether α D β.

(2) If α = Rk, then clearly α D β if and only if β = Rk or there
exists a production γ ∈ Rk such that γ D β. Let us assume that
γ is a production of Rk. Note that if γ D β, then γ and β are
similar. And so, since similarity is decidable, we can rephrase our
previous observation as α D β if and only if β = Rk or there exists
a production γ ∈ Rk such that γ is similar to β and γ D β. Checking
whether β = Rk is trivial, so let us assume the other option and start
with the case when γ is a short production referencing Rk.

If γ = XRk is similar to β = Xβ1, we know that γ D β if and
only if Rk D β1. Since π(Rk) + π(β1) < n, we know that checking
whether Rk D β1 is decidable, hence so is γ D β.

Let us assume w.l.o.g. that γ = SRkR0. Clearly, β = Sβ1β2.
And so, γ D β if and only if Rk D β1 and R0 D β2. Notice that
π(Rk)+ π(β1) < n as well as π(R0)+ π(β2) < n. Using the induction
hypothesis to both, we get that checking Rk D β1 and R0 D β2 is
decidable, hence so is α D β.

Finally, if γ is a long production we can rewrite it as γ = Xγ1 . . . γm,
and so reduce this case to the previous one when both trees are com-
plex, as π(γ) is necessarily smaller than n.

(cid:3)

Proposition 9. Let α, β be two trees. Then, both α D γ and β D γ for
arbitrary γ ∈ MeshSet(α, β).

Proof. Induction over n = π(α) + π(β). Let M = MeshSet(α, β). Clearly,
it suﬃces to consider such α, β that M 6= ∅.

Let us assume that both α = Xα1 . . . αm and β = Xβ1 . . . βm. If αi ⊲⊳ βi
for all i ∈ {1, . . . , m}, then M consists of a single tree γ = Xγ1 . . . γm for
which αi, βi D γi. Evidently, our claim holds. Suppose that there exists
an i ∈ {1, . . . , m} such that αi k βi. Since π(αi)+π(βi) < n, we can apply the
induction hypothesis to MeshSet(αi, βi). The set M ′ = MeshSet(αi, βi)
cannot be empty and so let δi be an arbitrary mesh in M ′. We know that
αi, βi D δi. And so, if we consider an arbitrary γ = Xγi . . . γm ∈ M , we get
αi, βi D γi for all i ∈ {1, . . . , m}, which implies our claim.

10

MACIEJ BENDKOWSKI

What remains is to consider the case when either α = Rk and β is complex
or, symmetrically, β = Rk and α is complex. Let us assume w.l.o.g. the
former case. From the deﬁnition, MeshSet(Rk, β) depends on the union
of MeshSet(γ, β) for γ ∈ Rk. Clearly, Rk rewrites to any of its productions.
Let γ ∈ Rk be a production referencing Rk. We have to consider two cases
based on the structure of γ.

(1) Let γ = XRk. Then, π(γ) = π(Rk) + 1 and so we cannot use the
induction hypothesis to MeshSet(γ, β) directly. Note however, that
we can assume that β = Xβ1, since otherwise MeshSet(γ, β) would
be empty. Therefore, we know that MeshSet(Rk, β1) 6= ∅ to which
we can now use the induction hypothesis, as π(Rk) + π(β1) < n.
Immediately, we get that Rk, β D γ.

(2) W.l.o.g. let γ = SRkR0. Then, π(γ) = 3 + π(Rk). Again, we cannot
directly use the induction hypothesis. Note however, that we can
assume that β = Sβ1β2. And so we get π(Rk) + π(β1) < n and
π(R0) + π(β2) < n. Using the induction hypothesis to both parts we
conclude that Rk, β D γ in this case as well.

To ﬁnish the proof we need to show that our claim holds for all γ ∈ Rk
which do not reference Rk.
Indeed, any such production has necessarily
smaller potential than Rk, and so, we can use the induction hypothesis
directly to the resulting mesh set. Evidently, our claim holds.
(cid:3)

In other words, MeshSet(α, β) is in fact a set of meshes, i.e. trees gener-
ating a joint portion of L(α) and L(β). Note, that along the lines of proving
the above proposition, we have also showed that indeed MeshSet(α, β) ter-
minates on all legal inputs, as the number of recursive calls cannot exceed
2(π(α) + π(β)) – in the worst case, every second recursive call decreases the
total potential sum of its inputs.

Proposition 10. Let α, β be two trees. Then, α D ϕr and β D ϕlϕr for
arbitrary ϕlϕr ∈ RewritingSet(α, β).

Proof. We can assume that RewritingSet(α, β) 6= ∅, as otherwise our
claim trivially holds. Let ϕlϕr ∈ RewritingSet(α, β). We have to consider
three cases based on the structure of β.

(1) If β = C, then ϕlϕr = Cα. Clearly, α D α and C D C α.
(2) If β = Xβ1 . . . βm, then we have again exactly three possibilities.
Both cases when α ⊲⊳ βm are trivial, so let us assume that α k βm.
It follows that there exists such a γ ∈ MeshSet(α, βm) that ϕlϕr =
Xβ1 . . . βm−1γ. Due to Proposition 9, we know that α, βm D γ and
so directly that α D ϕr and β D ϕlϕr.

(3) If β = Rn, then there exists such a production γ ∈ Rn that ϕlϕr ∈
RewritingSet(α, γ). Note however, that in this case γ = Xγ1 . . . γm
and so we can reduce this case to the already considered case above.
(cid:3)

Now we are ready to give the anticipated soundness theorem.

NORMAL-ORDER REDUCTION GRAMMARS

11

Theorem 11 (Soundness). If x ∈ L(Rn), then x reduces in n steps.

Proof. Induction over pairs (n, m) where m denotes the length of a minimal,
in terms of length, derivation Σ of x ∈ L(Rn). Let n = 0 and so x ∈ L(R0).
If m = 1, then x ∈ {S, K} hence x is already in normal form. Suppose
that m > 1. Clearly, x 6∈ {S, K}. Let R0 → α be the ﬁrst production rule
used in derivation Σ. Using the induction hypothesis to the reminder of the
derivation, we know that x does not contain any nested redexes. Moreover,
α avoids any head redexes and so we get that x is in normal form.

Let n > 0. We have to consider several cases based on the choice of the

ﬁrst production rule Rn → α used in the derivation Σ.

(1) α = SRn or α = KRn. Using the induction hypothesis we know

that x = Xy where y reduces in n steps. Clearly, so does x.

(2) α = SRn−iRi for some i ∈ {0, . . . , n}. Then, x = Syz where y ∈
L(Rn−i) and z ∈ L(Ri). Note that both their derivations are in fact
shorter than the derivation of x and thus applying the induction
hypothesis to both y and z we know that they reduce in n − i and
i steps, respectively. Following the normal-order reduction strategy,
we note that y and z and reduce sequentially in x. Since x does not
contain a head redex itself, we reduce it in total of n reductions.

(3) α = KRn−1C. Directly from the induction hypothesis we know that
x = Kyz where y reduces in n − 1 steps. And so x →w y, implying
that x reduces in n steps.

(4) α = K(Xα1 . . . αk)Cαk+1 . . . αm. Let x ∈ L(α). Clearly, x has
a head redex and so let x →w y. Using Proposition 3, we know
that y ∈ L(Xα1 . . . αm). Moreover, by the construction of Rn we
get α ∈ K-Expansions(Xα1 . . . αm) and therefore y ∈ L(Rn−1). It
follows that y reduces in n − 1 steps and so x in n steps.

(5) α = S(Xα1 . . . αk)ϕlϕrαk+3 . . . αm. Let x ∈ L(α). Clearly, x has
a head redex and so let x →w y. Due to Proposition 6 we get
that y ∈ L(Xα1 . . . αkϕr(ϕl ϕr)αk+3 . . . αm). In order to show that
x reduces in n steps it suﬃces to show that y ∈ L(Rn−1). Let us
consider β such that α ∈ S-Expansions(β). From the structure of α
we can rewrite it as β = Xα1 . . . αkαk+1αk+2 . . . αm. Moreover, from
Proposition 10 we know that αk+1 D ϕr and αk+2 D ϕl ϕr. Clearly,
y ∈ L(β), which ﬁnishes the proof.

(cid:3)

Combining the above result with the fact that each normalizing combina-
tory logic term reduces in a determined number of normal-order reduction
steps, gives us the following corollary.

Corollary 12. If L(Rn) ∩ L(Rm) 6= ∅, then n = m.

3.3. Completeness. In this section we are interested in the completeness
of Reduction Grammar. In other words, we show that every term nor-
malizing in exactly n steps is generated by Rn.

W start with some auxiliary lemmas showing the completeness of Mesh-

Set and, in consequence, RewritingSet.

12

MACIEJ BENDKOWSKI

Lemma 13. Let α, β be two non-rewritable trees. Let x be a term. Then,
x ∈ L(α) ∩ L(β) if and only if there exists a mesh γ ∈ MeshSet(α, β) such
that x ∈ L(γ).

Proof. It suﬃces to show the necessary part, the suﬃciency is clear from
Proposition 9. We show this result using induction over the size |x| of x.
Let x ∈ L(α)∩ L(β). Let us start with noticing that |α|+ |β| > 0. Moreover,
there are only two cases where x ∈ L(α) ∩ L(β), i.e. when either α =
Xα1 . . . αm and β = Xβ1 . . . βm or when exactly one of them is equal to
some Rn and the other is complex. And so, let us consider these cases
separately.

(1) Suppose that α = Xα1 . . . αm and β = Xβ1 . . . βm. It follows that
we can rewrite x as Xx1 . . . xm such that xi ∈ L(αi)∩ L(βi). Clearly,
if all αi ⊲⊳ βi, then there exists a mesh γ such that x ∈ L(γ). Let
us assume that some αi and βi are non-rewritable. Then, using
the induction hypothesis we ﬁnd a mesh γi ∈ MeshSet(αi, βi) such
that xi ∈ L(γi).
Immediately, we get that there exists a mesh in
MeshSet(α, β) which generates x.

(2) Let us assume w.l.o.g. that α = Rn and β = Xβ1 . . . βm. Since
x ∈ L(Rn), there must be such a production γ ∈ Rn that x ∈ L(γ).
Although the size of x does not decrease, note that we can reduce
this case to the one considered above since both γ and β are complex.
Clearly, it follows that we can ﬁnd a suiting mesh δ ∈ MeshSet(γ, β)
such that x ∈ L(δ). Immediately, we get δ ∈ MeshSet(α, β) which
ﬁnishes the proof.

(cid:3)

Lemma 14. Let α, β be two trees. Let x, yx be two terms. Then, x ∈ L(α)
and yx ∈ L(β) if and only if there exists such a ϕlϕr ∈ RewritingSet(α, β)
that x ∈ L(ϕr) and yx ∈ L(ϕlϕr).

Proof. Due to Proposition 10 the suﬃciency part is clear. What remains
is to show the necessary part. Let x ∈ L(α) and yx ∈ L(β). Consider
the structure of β.
If β = C, then Cα ∈ RewritingSet(α, β) and so
ϕl = C, ϕr = α. Clearly, our claim holds. Now, consider the case when
β = Xβ1 . . . βm. Based on the rewritability of α and βm we distinguish
three subcases.

(1) If α D βm, then Xβ1 . . . βm ∈ RewritingSet(α, β). Since yx ∈

L(β), we get x ∈ L(βm) and in consequence x ∈ L(ϕr).

(2) If βm D α, then Xβ1 . . . βm−1α ∈ RewritingSet(α, β). Since βm D

α, we know that L(α) ⊆ L(βm) and so yx ∈ L(Xβ1 . . . βm−1α).

(3) If α k βm, then we know that x ∈ L(α) ∩ L(βm). If not, then yx
could not be a term of L(β). And so, using Lemma 13 we ﬁnd
a mesh γ ∈ MeshSet(α, βm) such that x ∈ L(γ). We know that
Xβ1 . . . βm−1γ ∈ RewritingSet(α, β). Clearly, it is the tree we
were looking for.

It remains to consider the case when β = Rk. Note however, that it can
be reduced to the case when β = Xβ1 . . . βm. Indeed, since x ∈ L(Rk), then
there exists a production γ ∈ Rk such that x ∈ L(γ). From the previous
arguments we know that we can ﬁnd a tree satisfying our claim.
(cid:3)

NORMAL-ORDER REDUCTION GRAMMARS

13

Using the above completeness results for MeshSet and RewritingSet,

we are ready to give the anticipated completeness result of {Rn}n∈N.

Theorem 15 (Completeness). If x reduces in n steps, then x ∈ L(Rn).

Proof. Induction over pairs (n, s) where s denotes the size of x. The base
case n = 0 is clear due to the completeness of R0. Let n > 0.

Let us start with considering short terms. Let x = Xy be a term of size
s. Since x has no head redex, y must reduce in n steps as well. Now, we can
apply the induction hypothesis to y and deduce that y ∈ L(Rn). It follows
that x ∈ L(XRn). Clearly, XRn is a production of Rn and so x ∈ L(Rn).
Now, assume that x = Syz. Since x reduces in n steps and does not contain
a head redex, there exists such an i ∈ {0, . . . , n} that y reduces in i steps
and z reduces in n − i steps. Applying the induction hypothesis to both y
and z, we get that y ∈ L(Ri) whereas z ∈ L(Rn−i). Immediately, we get
that x ∈ L(Rn) as SRiRn−i ∈ Rn.

What remains is to consider long terms. Let x = Kx1x2. Note that
x1 must reduce in n − 1 steps, as x →w x1. And so, from the induction
hypothesis we get that x1 ∈ L(Rn−1). Now we have x ∈ L(KRn−1C) and
hence x ∈ L(Rn) as KRn−1C is a production of Rn.

Now, let x = Kx1 . . . xm for m ≥ 3. Since x has a head redex, we know
that x →w y = x1x3 . . . xm, which itself reduces in n−1 steps. Let us rewrite
y as Xy1 . . . ykx3 . . . xm where x1 = Xy1 . . . yk. We know that there exists
a production α ∈ Rn−1 such that y ∈ L(α). Let α = Xα1 . . . αkα3 . . . αm.
Clearly, there exists a β = K(Xα1 . . . αk)Cα3 . . . αm ∈ K-Expansions(α).
Indeed, y ∈ L(α) implies that yi ∈ L(αi) and
We claim that x ∈ L(β).
xj ∈ L(αj) for any i and j in proper ranges. Since x2 ∈ L(C), we conclude
that x ∈ L(β) and hence x ∈ L(Rn).

Let x = Sx1 . . . xm for m ≥ 3. Clearly, x has a head redex and so
x →w y = x1x3(x2x3)x4 . . . xm which reduces in n − 1 steps. Again, let us
rewrite y as Xy1 . . . ykx3(x2x3)x4 . . . xm where x1 = Xy1 . . . yk. Now, since
y ∈ L(Rn−1), there exists a production α = Xα1 . . . αkα3γα4 . . . αm ∈ Rn−1
such that y ∈ L(α). We claim that there must be a production β ∈
S-Expansions(α) such that x ∈ L(Rn). If so, the proof would be complete.
Notice that x3 ∈ L(α3) and x2x3 ∈ L(γ). Using Lemma 14 we know that
there exists a tree ϕlϕr ∈ RewritingSet(α3, γ) such that x3 ∈ L(ϕr) and
(x2x3) ∈ L(ϕlϕr). And so we know that y ∈ L(Xα1 . . . αkϕr(ϕlϕr)α4 . . . αm).
Moreover, due to ϕlϕr ∈ RewritingSet(α3, γ), we know that the tree
β = S(Xα1 . . . αk)ϕlϕrα4 . . . αm ∈ S-Expansions(α) and so also β ∈ Rn.
Since x2 ∈ L(ϕl), we get that x ∈ L(β).
(cid:3)

3.4. Unambiguity. In this section we show that reduction grammars are in
fact unambiguous, i.e. every term x ∈ L(Rn) has exactly one derivation. Due
to the mutual recursive nature of MeshSet, RewritingSet and Reduc-
tionGrammar, we split the proof into two separate parts. In the following
lemma, we show that MeshSet returns unambiguous meshes under the as-
sumption that R0, . . . , Rn up to some n are themselves unambiguous. In
the corresponding theorem we use inductive reasoning which supplies the
aforementioned assumption and thus, as a consequence, allows us to prove
the main result.

14

MACIEJ BENDKOWSKI

Lemma 16. Let α, β be two trees such that γ, γ ∈ MeshSet(α, β) where in
addition ρ(α), ρ(β) ≤ r+1. If R0, . . . , Rr are unambiguous and L(γ)∩L(γ) 6=
∅, then γ = γ.

Proof. Induction over n = π(α)+π(β). Let x ∈ L(γ)∩ L(γ). We can assume
that |MeshSet(α, β)| > 1 as the case for |MeshSet(α, β)| = 1 is trivial. In
consequence, the base case n = 0 is clear as the resulting MeshSet for two
trees of potential 0 has to be necessarily empty. Hence, we have to consider
two cases based on the structure of α and β.

(1) Let α = Xα1 . . . αm and β = Xβ1 . . . βm. Clearly, x is in form
of x = Xx1 . . . xm. Let αi k βi be an arbitrary non-rewritable pair
of arguments in α, β. It follows that xi ∈ L(αi) ∩ L(βi) and so, due
to Lemma 13, there exists a mesh δ ∈ MeshSet(αi, βi) such that
xi ∈ L(δ). Let Mi = MeshSet(αi, βi). Since π(αi) + π(βi) < n we
can use the induction hypothesis to Mi and immediately conclude
that δ is the only mesh in Mi generating xi. And so, we know that
γ and γ are equal on the non-rewritable arguments of α, β. Note
that if αi ⊲⊳ βi, then both contribute a single mesh at position
Immediately, we get that both γ and γ are also equal on the
i.
rewritable arguments of α and β, hence ﬁnally γ = γ.

(2) W.l.o.g. let α = Rk and β = Xβ1 . . . βm. Clearly, as ρ(α) ≤ r + 1,
we know that Rk is unambiguous. From the deﬁnition of MeshSet
there exist productions δ, δ ∈ Rk such that γ ∈ MeshSet(δ, β) and
γ ∈ MeshSet(δ, β). We claim that γ = γ as otherwise δ, δ would
generate a common term. Suppose that γ 6= γ. From Lemma 13 we
know that L(γ) ⊆ L(δ) and L(γ) ⊆ L(δ). Since x ∈ L(γ) ∩ L(γ), we
get that x ∈ L(δ) ∩ L(δ) and therefore a contradiction with the fact
that Rk is unambiguous. It follows that γ = γ, which ﬁnishes the
proof.

(cid:3)

Theorem 17 (Unambiguity). Let α, β ∈ Rn. If L(α) ∩ L(β) 6= ∅, then
α = β.

Proof. Induction over n. Let x ∈ L(α) ∩ L(β). Note that if x ∈ L(α) ∩
L(β), then both α, β must be similar. We can therefore focus on similar
productions of Rn. For that reason, we immediately notice that R0 satisﬁes
our claim.

Let n > 0. Since Rn does not contain combinators as productions, we can
rewrite both α as Xα1 . . . αm and β as Xβ1 . . . βm. Consider several cases
based on their common structure.

(1) Let X = K. If m = 1, then α and β are equal as there is exactly one
short K-production in Rn. If m = 2, then again α = β, since there
is a unique K-production KRn−1C of length two in Rn. If m > 2,
then both are K-Expansions of some productions in Rn−1. And so

α = K(Xα1 . . . αk)Cα3 . . . αm ∈ K-Expansions(γ),

β = K(Xβ1 . . . βk)Cβ3 . . . βm ∈ K-Expansions(δ),

NORMAL-ORDER REDUCTION GRAMMARS

15

where

γ = Xα1 . . . αkα3 . . . αm,

δ = Xβ1 . . . βkβ3 . . . βm.

Since x ∈ L(α) ∩ L(β), we can moreover assume that x is in form
of K(Xy1 . . . yk)x2x3 . . . xm where yi ∈ L(αi) ∩ L(βi) and xj ∈
L(αj) ∩ L(βj).
It follows that we can use the induction hypothe-
sis to γ, δ ∈ Rn−1 obtaining αi = βi and αj = βj. Immediately, we
get α = β.

(2) Let X = S. If m = 1, then α and β are equal due to the fact that
there is exactly one S-production of length one in Rn. If m = 2,
then α, β are in form of α = SRiRn−i and β = SRj Rn−j. Hence,
x = Sx1x2 for some terms x1, x2. Since x1 ∈ L(Ri) ∩ L(Rj) and
x2 ∈ L(Rn−i) ∩ L(Rn−j), we know that i = j due to Corollary 12
and thus α = β. It remains to consider long S-productions. Let

α = S(Xα1 . . . αk)ϕlϕrα4 . . . αm ∈ S-Expansions(γ),

β = S(Xβ1 . . . βk)ϕlϕrβ4 . . . βm ∈ S-Expansions(δ),

where

γ = Xα1 . . . αkα2α3α4 . . . αm,

δ = Xβ1 . . . βkβ2β3β4 . . . βm.

It follows that we can rewrite x as S(Xy1 . . . yk)wzx4 . . . xm. Let us
focus on the reduct x →w y = Xy1 . . . ykz(wz)x4 . . . xm. Evidently,
y ∈ L(γ) ∩ L(δ) and so according to the induction hypothesis we
know that γ = δ, in particular α2 = β2 and α3 = β3. Hence, both
ϕlϕr and ϕlϕr are elements of the same RewritingSet. If we could
guarantee that ϕlϕr = ϕlϕr, then immediately α = β and the proof
is ﬁnished. From the construction of the RewritingSet we have
two cases left to consider.
(a) If α3 = Xγ1 . . . γm, then both ϕlϕr and ϕlϕr are either in form
of Xγ1 . . . γm−1 ϕr or Xγ1 . . . γm−1 ϕr. It follows that ϕl = ϕl.
It remains to show that ϕr = ϕr. Note that ρ(α2), ρ(α3) ≤ n
since both γ, δ ∈ Rn−1. Moreover, from the induction hypothe-
sis we know that R0, . . . , Rn−1 are unambiguous. And so, since
z ∈ L(ϕr) ∩ L(ϕr), we can use Lemma 16 to conclude that
ϕr = ϕr.

(b) If α3 = Rk, then there exist such productions η, η ∈ Rk that
ϕlϕr ∈ RewritingSet(α2, η), whereas ϕlϕr is an element of
RewritingSet(α2, η). Note that from Proposition 10 we know
that L(ϕlϕr) ⊆ L(η) and L(ϕlϕr) ⊆ L(η). It implies that wz ∈
L(η) ∩ L(η), however, since k < n, we know from the induction
hypothesis that Rk is unambiguous. Hence η = η. Finally, it
means that we can reduce this case to one of the previous cases
when α3 is complex, concluding that ϕlϕr = ϕlϕr.

(cid:3)

16

MACIEJ BENDKOWSKI

3.5. Applications. In this section we highlight some interesting conse-
quences of the existence of reduction grammars.
In particular, we prove
that terms reducing in n steps have necessarily bounded length. Moreover,
we show that the problem of deciding whether a given term reduces in n
steps, can be done in memory independent of the size of the term.

Proposition 18. If α ∈ Rn, then α has length at most 2n + 2.

Proof. Induction over n. The base case n = 0 is clear from the shape of R0.
Fix n > 0. Let us consider long productions in Rn. If β is a K-Expansion
of some Xα1 . . . αm ∈ Rn−1, then

β = K(Xα1 . . . αk)Cαk+1 . . . αm

for 0 ≤ k ≤ m − 1.

Since setting k = 0 maximizes the length of β, we note that β is of length
m + 2 and so by the induction hypothesis at most 2n + 2. Now, let us
consider the case when β is a S-Expansion of some Xα1 . . . αm ∈ Rn−1.
Then,

β = S(Xα1 . . . αk)ϕlϕrαk+3 . . . αm

for 0 ≤ k ≤ m − 2.

where in addition (ϕl ϕr) ∈ RewritingSet(αk+1, αk+2). Again, setting
k = 0 maximizes the length of β. It follows that β is of length at most m + 1
and so also at most 2n + 1.
(cid:3)

In other words, terms reducing in n steps cannot be too long as their
length is tightly bounded by 2n + 2. Now, let us consider the following two
problems.

Problem: n-step-reducible
Input: A combinatory logic term x ∈ L(C).
Output: yes if and only if x reduces in n steps.

Problem: reduces-in-n-steps
Input: A combinatory logic term x ∈ L(C) and a number n ∈ N.
Output: yes if and only if x reduces in n steps.

Corollary 19. n-step-reducible is decidable in O(|x|) time and O(1)
space using Reduction Grammars, whereas the Naive algorithm, reduc-
ing x in at most n steps, requires O(|x|) time and O(|x|) space.

Since n in not a part of the input, we can compute Rn in constant time
and memory. Using Rn we build a bottom-up tree automaton recognizing
L(Rn) [4] and use it to check whether x ∈ L(Rn) in time O(|x|), without
using additional memory. On the other hand, the Naive algorithm requires
O(|x|) time and additional memory. At each reduction step, the considered
term doubles at most in size, as Sxyz →w xz(yz). In order to ﬁnd the next
redex we spend up to linear time in the current size of x, therefore both size
and time are bounded by

|x| + 2|x| + 4|x| + · · · + 2n|x| = |x|(cid:16)1 + 2 + 4 + · · · + 2n(cid:17)
= |x|(cid:16)2n+1 − 1(cid:17) = O(|x|).

NORMAL-ORDER REDUCTION GRAMMARS

17

As a natural extension, we get the following corollary.

Corollary 20. The reduces-in-n-steps problem is decidable in space de-
pending exclusively on n, independently of |x|.

3.6. Upper bound. In this section we focus on the upper bound on the
number of productions in Rn. We show that there exists a primitive recursive
function f : N → N such that |Rn| ≤ f (n).

Following the scheme of the soundness proofs in Section 3.2, we construct
suitable upper bounds using the notions of tree potential and degree. In the
end of this section, we show that these values are in fact bounded in each
Rn, thus giving the desired upper bound.

Lemma 21. Let α, β be two trees of degree at most n such that their total
potential π(α) + π(β) is equal to p. Then, the number of distinct meshes in
MeshSet(α, β) is bounded by |Rn|e p!.

Proof. Induction over total potential p. Consider the following primitive
recursive function fn : N → N.

fn(k) =(1

(|Rn| · fn(k − 1))k

if k = 0,
otherwise.

We claim that |MeshSet(α, β)| ≤ fn(p). Note that it suﬃces to consider
such α, β that |MeshSet(α, β)| > 1 since fn is an increasing function attain-
ing positive values for any given input. It follows that the base case p = 0
is clear, as if π(α) + π(β) = 0, then MeshSet(α, β) is necessarily empty.
Now, let us assume that p > 0. From the construction of the common mesh
set M of α and β, we can distinguish two cases left to consider.

(1) Suppose that α = Xα1 . . . αm and β = Xβ1 . . . βm.

In order to
maximize the size of M , we can furthermore assume that none of the
pairs αi, βi are rewritable. And so, the total number of meshes in
M is equal to the product of all meshes in corresponding mesh sets
for αi and βi. The degree of αi and βi is still at most n, however
π(αi) + π(βi) ≤ p − 2. Hence, using the induction hypothesis we get
|MeshSet(αi, βi)| ≤ fn(p − 2). Since both α, β are of length m ≤ p
we can furthermore state that

|M | ≤ (fn(p − 2))m ≤ (fn(p − 2))p

≤ (fn(p − 1))p ≤ (|Rn| · fn(p − 1))p
= fn(p).

(2) Let us assume w.l.o.g. that α = Ri and β is complex. In order to
maximize the total number of meshes in M , we can moreover assume
that all productions γ ∈ Ri are similar to β and generate disjoint
sets of meshes. We claim that MeshSet(γ, β) ≤ fn(p − 1). Clearly,
if γ does not reference Ri, then our claim is trivially true. Suppose
that γ is a self-referencing production. If γ = XRi, then β is in form
of Xβ1. From the construction of M , we get that

|MeshSet(γ, β)| = |MeshSet(Ri, β1)|.

18

MACIEJ BENDKOWSKI

As π(Ri) + π(β1) ≤ p − 1, we can apply the induction hypothe-
sis to MeshSet(Ri, β1) and immediately obtain |MeshSet(γ, β)| ≤
fn(p − 1). Now, suppose w.l.o.g. that γ = SRiR0 and hence β =
Sβ1β2. Again, from the construction of M we know that

|MeshSet(γ, β)| = |MeshSet(Ri, β1)| · |MeshSet(R0, β2)|.

Due to the fact that both π(Ri) + π(β1) ≤ p − 2 and π(R0) + π(β2) ≤
p − 2, we can use the induction hypothesis and immediately get that

|MeshSet(γ, β)| = |MeshSet(Ri, β1)| · |MeshSet(R0, β2)|

≤ fn(p − 2) fn(p − 2).

Note that (fn(p − 2))2 ≤ fn(p − 1) for p ≥ 2 and, in consequence,
|MeshSet(γ, β)| ≤ fn(p − 1). Indeed, if p = 2, then (fn(p − 2))2 =
1 ≤ fn(1) = |Rn|. Otherwise if p > 2, then
fn(p − 1) = (|Rn| · fn(p − 2))p−1

=(cid:16)|Rn|p−1(fn(p − 3))p−2(cid:17)p−1
≥(cid:16)|Rn|p−2(fn(p − 3))p−2(cid:17)p−1

= (|Rn| · fn(p − 3))(p−1)(p−2).

As 2(p − 2) ≤ (p − 1)(p − 2) for p > 2, we ﬁnally obtain

(|Rn| · fn(p − 3))(p−1)(p−2) ≥ (|Rn| · fn(p − 3))2(p−2)

= (fn(p − 2))2.

We know therefore that MeshSet(γ, β) ≤ fn(p − 1) for each γ ∈

Ri. Finally, using the fact that |Ri| ≤ |Rn|, we get

|M | ≤ |Rn| · fn(p − 1)

≤ (|Rn| · fn(p − 1))p
= fn(p).

And so, we know that |MeshSet(α, β)| ≤ fn(p). Solving the recurrence for
fn(p), using e.g. Mathematica R(cid:13) [7], we obtain the following closed form
expression

where

fn(p) = |Rn|e p Γ(p,1),

s−1

Γ(s, x) = (s − 1)! e−x

xk
k!

Xk=0

is the upper incomplete gamma function (see e.g. [2]). Simplifying the above
1
k! ≤ e for

expression in the case x = 1 and using the observation that Ps−1

arbitrary s, we ﬁnally obtain the anticipated upper bound

k=0

fn(p) ≤ |Rn|e p!.

(cid:3)

NORMAL-ORDER REDUCTION GRAMMARS

19

Lemma 22. Let α, β be two trees of degree at most n such that their total
potential π(α) + π(β) is equal to p. Then, the number of distinct trees in
RewritingSet(α, β) is bounded by |Rn|1+e p!.

Proof. If |RewritingSet(α, β)| ≤ 1, then our claim is trivially true. Let
us focus therefore on the remaining cases when either β = Xβ1 . . . βm and
both βm and α are non-rewritable, or β = Ri.

First, consider the former case. The resulting rewriting set is of equal size
as MeshSet(α, βm). Since π(α) + π(βm) ≤ p − 1, we can use Lemma 21 to
deduce that

|RewritingSet(α, β)| = |MeshSet(α, βm)| ≤ |Rn|e (p−1)! < |Rn|1+e p!.
Now, let us consider the latter case. In order to maximize the resulting
rewriting set we assume that each production γ ∈ Ri generates a disjoint set
of trees. We claim that each production γ contributes at most |Rn|e p! new
trees to the resulting rewriting set and therefore |RewritingSet(α, β)| ≤
|Rn|1+e p!, as there are at most |Rn| productions in Ri.
Indeed, consider
an arbitrary γ ∈ Ri. Evidently, if |RewritingSet(α, γ)| ≤ 1, then our
claim is true. Hence, let us assume that |RewritingSet(α, γ)| > 1.
It
follows that γ is complex. Let us rewrite it as Xγ1 . . . γm. Note that as in the
previous case, the resulting rewriting set is of equal size as MeshSet(α, γm).
Since π(α) + π(γm) ≤ p − 1 we use Lemma 21 and get

|RewritingSet(α, γ)| = |MeshSet(α, γm)| ≤ |Rn|e (p−1)! < |Rn|e p!.

(cid:3)

Lemma 23. Let α, β be two trees of total potential π(α) + π(β) equal to
p. Then, each mesh in MeshSet(α, β) has potential bounded by p!(1 + e).

Proof. Induction over total potential p. Clearly, it suﬃces to consider such
α, β that MeshSet(α, β) is not empty. Immediately, the base case p = 0 is
clear. Let us assume that p > 0. Consider the following primitive recursive
function f : N → N.

f (k) =(1

k · (f (k − 1) + 1)

if k = 0,
otherwise.

Let γ ∈ MeshSet(α, β). We claim that π(γ) ≤ f (p). Note that f is
an increasing function attaining positive values for any input. We have two
cases to consider.

(1) Suppose that α = Xα1 . . . αm and β = Xβ1 . . . βm. Note that
π(αi) + π(βi) ≤ p − 2 for each pair of corresponding arguments
αi, βi. Using the induction hypothesis to pairs αi, βi and the fact
that γ ∈ MeshSet(α, β) is similar to both α and β, we bound γ’s
potential by

π(γ) ≤ m · f (p − 2) + m ≤ p · (f (p − 2) + 1) ≤ f (p).

(2) Let us assume w.l.o.g. that α = Ri and β is complex. It follows that
γ ∈ MeshSet(δ, β) for some δ ∈ Ri.
If δ does not reference Ri,
then clearly π(δ) ≤ π(Ri) − 1 and therefore π(γ) ≤ f (p − 1). Now,
suppose that δ is a self-referencing production of Ri.

20

MACIEJ BENDKOWSKI

If δ = XRi, then β is in form of Xβ1 and similarly γ = Xγ1. It
follows that π(δ) = π(Ri) + 1 and therefore π(δ) + π(β) = p + 1.
Note however that π(γ1) ≤ f (p − 1) as π(Ri) + π(β1) ≤ p − 1. Due
to that, π(γ) = 1 + f (p − 1) ≤ f (p).

Let us assume w.l.o.g. that δ = SRiR0. Immediately, β is in form
of Sβ1β2 whereas γ = Sγ1γ2. Moreover, π(δ) = π(Ri) + 3. Note
however that both π(Ri) + π(β1) ≤ p − 2 and π(R0) + π(β2) ≤ p − 2.
We can therefore use the induction hypothesis and conclude that

π(γ) = 2 + π(γ1) + π(γ2) ≤ 2 + 2 · f (p − 2).

Since π(δ) ≥ 4, we know that p ≥ 3 and so we can further bound
π(γ) by

π(γ) = 2 (1 + f (p − 2))

≤ (p − 1) (1 + f (p − 2))

= f (p − 1) ≤ f (p).

Finally, we know that π(γ) ≤ f (p). What remains is to solve the recursion,
using e.g. Mathematica R(cid:13) [7], for f and give its closed form solution. It
follows that

where

f (p) = Γ(1 + p) + e p Γ(p, 1)

≤ p! + e p!

= p!(1 + e)

Γ(n) = (n − 1)!

(cid:3)

Lemma 24. Let α, β be two trees of total potential π(α) + π(β) equal
to p. Then, each tree in RewritingSet(α, β) has potential bounded by
p!(1 + e) + p.

Proof. Let γ be an arbitrary tree in RewritingSet(α, β). Based on the
structure of β we have several cases to consider. If β = C, then γ = Cα and
so π(γ) = π(α) + 1 = p + 1. Note that 1 < p!(1 + e) for any p and thus our
bound holds.

If β = Xβ1 . . . βm, then π(α)+π(βm) ≤ p−1. In both cases when α ⊲⊳ βm
the resulting tree has potential bounded by p and so also by p!(1 + e) + p.
Let us assume that α k βm. We can therefore rewrite γ as Xγ1 . . . γm. Using
Lemma 23, we know that π(γm) ≤ (p − 1)!(1 + e). Moreover, both α and
β are similar to γ. Let us rewrite them as Xα1 . . . αm and Xβ1, . . . , βm,
respectively. Note that for each i < m, γi is equal to αi or βi. It follows that
we can bound the potential of Xγ1 . . . γm−1 by p − 1 and hence γ’s potential
by (p − 1)!(1 + e) + p.

Now, if β = Ri, then γ ∈ RewritingSet(α, δ) for some δ ∈ Ri. Clearly,
if δ does not reference Ri, we know that π(δ) ≤ π(Ri)− 1 ≤ p − 1. Moreover,
δ is complex, as otherwise RewritingSet(α, δ) = ∅. Using our previous
argumentation, we can therefore conclude that π(γ) ≤ (p − 1)!(1 + e) + p.
Suppose that δ is a self-referencing production of Ri. If δ = XRi, then α
If
is in form of Xα1 and γ = Xγ1.

Immediately, π(α) + π(δ) = p + 1.

NORMAL-ORDER REDUCTION GRAMMARS

21

Ri ⊲⊳ α1, then γ has potential bounded by p. Therefore, let us assume
that Ri k α1. Since π(Ri) + π(α1) = p − 1, we know from Lemma 23 that
π(γ1) ≤ (p−1)!(1+e). It follows immediately that π(γ) ≤ (p−1)!(1+e)+1 ≤
p!(1 + e) + p.

Finally, suppose that δ = Sδ1δ2 and so α = Sα1α2. Immediately, γ =
Sγ1γ2. Again, if δ2 ⊲⊳ α2, we can bound γ’s potential by p. Hence, let
us assume that δ2 k α2. Clearly, π(α) + π(δ) = p + 3. Note however that
π(α1) + π(δ1) ≤ p − 2 and π(α2) + π(δ2) ≤ p − 2, as both δ1 and δ2 are non-
terminal reduction grammar symbols of positive potential. Using Lemma 23
to MeshSet(α2, δ2) we conclude that π(γ2) ≤ (p − 2)!(1 + e). It follows that
π(γ) ≤ (p − 2)!(1 + e) + p ≤ p!(1 + e) + p.
(cid:3)

Lemma 25. There exists a primitive recursive function ψ : N → N such
that π(Rn) ≤ ψ(n).

Proof. Consider the following function ψ : N → N:

ψ(k) =(1

4 (ψ(k − 1) + 2)! + 2ψ(k − 1) + 5 otherwise.

if k = 0,

Clearly, ψ is an increasing primitive recursive function. We show that ψ(n)
bounds the potential of Rn using induction over n. Since π(R0) = ψ(0) = 1,
the base case is clear. Let n > 0.
In order to prove our claim, we have
to check that π(α) ≤ ψ(n) − 1 for all productions α ∈ Rn which do not
reference Rn.

(1) Suppose that α = SRn−iRi. Clearly, the potential of α is equal
to 2 + π(Rn−i) + π(Ri). Using the induction hypothesis, we know
moreover that

π(α) ≤ 2 + ψ(n − i) + ψ(i)

≤ 2 + 2ψ(n − 1)

≤ ψ(n) − 1.

(2) Let α = KRn−1C. Due to the fact that π(α) = 2 + π(Rn−1), we use

the induction hypothesis and immediately obtain

π(α) ≤ 2 + ψ(n − 1) ≤ ψ(n) − 1.

(3) Suppose that α ∈ K-Expansions(β) for some β ∈ Rn−1. Note that
π(β) ≤ ψ(n − 1) + 3 as the productions of greatest potential in Rn−1
are exactly SRn−1R0 and SR0Rn−1. Since π(α) = 2 + π(β), we get

π(α) ≤ 5 + ψ(n − 1) ≤ ψ(n) − 1.

(4) Finally,

let α ∈ S-Expansions(β) for some β ∈ Rn−1. Again,
π(β) ≤ π(Rn−1)+3 and hence from the induction hypothesis π(β) ≤
ψ(n − 1) + 3. Let us rewrite α as S(Xβ1 . . . βk)ϕlϕrβk+3 . . . βm
where β = Xβ1 . . . βm. Note that π(α) ≤ π(β) + π(ϕl) + π(ϕr) + 1.
Moreover, as π(ϕlϕr) = 1 + π(ϕl) + π(ϕr), we get π(α) ≤ π(β) +
π(ϕlϕr). Since π(βk+1βk+2) ≤ π(β) − 1 and thus, in consequence,
π(βk+1βk+2) ≤ ψ(n − 1) + 2, we can use Lemma 24 to obtain

π(ϕlϕr) ≤ (ψ(n − 1) + 2)!(1 + e) + ψ(n − 1) + 2.

22

MACIEJ BENDKOWSKI

It follows therefore that

π(α) ≤ π(β) + π(ϕlϕr)

≤ (ψ(n − 1) + 2)!(1 + e) + 2ψ(n − 1) + 5

≤ ψ(n) − 1

where the last inequality follows from the fact that

(3 − e) (ψ(n − 1) + 2)! ≥

1
5

(ψ(n − 1) + 2)! ≥

6
5

≥ 0.

(cid:3)

Theorem 26. There exists a primitive recursive function χ : N → N such
that the number |Rn| of productions in Rn is bounded by χ(n).

Proof. Consider Rn for some n > 0. Note that Rn consists of :

(1) two productions SRn and KRn,
(2) n + 1 short S-productions in form of SRn−iRi,
(3) an additional K-production KRn−1C,
(4) K-Expansions(α) for each α ∈ Rn−1 and
(5) S-Expansions(α) for each α ∈ Rn−1.
It suﬃces therefore to bound the number of K- and S-Expansions, as
the number of other productions in Rn is clear. Let us start with K-
Expansions. Suppose that α is of length m. Clearly, |K-Expansions(α)| =
m. Using Proposition 18, we know that that each production α ∈ Rn−1
is of length at most 2n.
It follows that there are at most 2n · |Rn−1|
K-Expansions in Rn. Now, let us consider S-Expansions.
In order to
bound the number of S-Expansions in Rn, we assume that each produc-
tion α ∈ Rn−1 is of length 2n and moreover each RewritingSet of ap-
propriate portions of α generates a worst-case set of trees. And so, assum-
ing that α is of length 2n we can rewrite it as Xα1 . . . α2n. Let ψ denote
the upper bound function on the potential of Rn−1 from Lemma 25. Ev-
idently, π(α) ≤ ψ(n − 1) + 3. Now, using Lemma 22 we know that each
RewritingSet(αi, αi+1) contributes at most

|Rn−1|1+e(cid:0)ψ(n−1)+3(cid:1)!

new S-Expansions. As there are at most 2n − 1 pairs of indices (i, i + 1)
yielding RewritingSets, we get that the number of S-Expansions in Rn
is bounded by

(2n − 1) · |Rn−1| · |Rn−1|1+e(cid:0)ψ(n−1)+3(cid:1)! ≤ (2n − 1) · |Rn−1|2+3(cid:0)ψ(n−1)+3(cid:1)!.

Finally, since |R0| = 5, we combine the above observations and get the

following primitive recursive upper bound on |Rn|.

χ(k) =


5

4 + k + 2k · χ(k − 1)

if k = 0,

+ (2k − 1) · χ(k − 1)2+3(cid:0)ψ(k−1)+3(cid:1)! otherwise.

(cid:3)

NORMAL-ORDER REDUCTION GRAMMARS

23

4. Conclusion

We gave a complete syntactic characterization of normal-order reduction
for combinatory logic over the set of primitive combinators S and K. Our
characterization uses regular tree grammars and therefore exhibits interest-
ing algorithmic applications. We investigated the complexity of the gener-
ated reduction grammars, giving a primitive recursive upper bound on the
number of their productions. We emphasize the fact that although the size
of Rn is bounded by a primitive recursive function of n, it seems to be enor-
mously overestimated. Our computer implementation of the Reduction
Grammar algorithm [1] suggests that the ﬁrst few numbers in the sequence
{|Rn|}n∈N are in fact

5, 12, 75, 625, 5673, 53164, 508199, . . .

The upper bound χ(1) on the size of R1 is already of order 6 · 1084549,
whereas the actual size of R1 is equal to 12. Naturally, we conjecture that
{Rn}n∈N grows much slower than {χ(n)}n∈N, although the intriguing prob-
lem of giving better approximations on the size of Rn for large n is still
open.

Acknowledgements

We would like to thank Katarzyna Grygiel for many fruitful discussions

and valuable comments.

References

[1] Normal-order

reduction

grammars

–

Haskell

implementation.

https://github.com/maciej-bendkowski/normal-order-reduction-grammars.

[2] M. Abramowitz and I. Stegun. Handbook of Mathematical Functions, with formulas,

graphs, and mathematical tables. Dover Publications, 1972.

[3] H. P. Barendregt. The Lambda Calculus, Its Syntax and Semantics, volume 103. North

Holland, 1984.

[4] H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez, S. Ti-
son, and M. Tommasi. Tree automata techniques and applications. Available on:
http://www.grappa.univ-lille3.fr/tata, 2007. release October, 12th 2007.

[5] H. B. Curry. Grundlagen der kombinatorischen Logik. American Journal of Mathe-

matics, 52(3):509–536, 1930.

[6] H. B. Curry and R. Feys. Combinatory Logic. Vol. I. Amsterdam, North Holland,

1958.

[7] Wolfram Research Inc. Mathematica version 10.3, 2015. Champaign, Illinois.
[8] M. Sch¨onﬁnkel. ¨Uber die Bausteine der mathematischen Logik. Mathematische An-

nalen, 92(3):305–316, 1924.

[9] D. Turner. A new implementation technique for applicative languages. Software:

Practice and Experience, 9(1):31–49, 1979.

[10] D. Turner. An overview of Miranda. SIGPLAN Not., 21(12):158–166, 1986.

Theoretical Computer Science Department, Faculty of Mathematics and
 Lojasiewicza 6, 30-348

Computer Science, Jagiellonian University, ul. Prof.
Krak´ow, Poland

E-mail address: bendkowski@tcs.uj.edu.pl

