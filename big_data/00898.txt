6
1
0
2

 
r
a

M
2

 

 
 
]

M
D
.
s
c
[
 
 

1
v
8
9
8
0
0

.

3
0
6
1
:
v
i
X
r
a

Large Peg-Army Maneuvers

Luciano Gualà

Università di Roma Tor Vergata

Emanuele Natale

Stefano Leucci

Sapienza Università di Roma
Roberto Tauraso

Sapienza Università di Roma

Università di Roma Tor Vergata

Abstract

Despite its long history, the classical game of peg solitaire continues
to attract the attention of the scientiﬁc community.
In this paper, we
consider two problems with an algorithmic ﬂavour which are related with
this game, namely Solitaire-Reachability and Solitaire-Army. In the ﬁrst
one, we show that deciding whether there is a sequence of jumps which
allows a given initial conﬁguration of pegs to reach a target position is
NP-complete. Regarding Solitaire-Army, the aim is to successfully deploy
an army of pegs in a given region of the board in order to reach a target
position. By solving an auxiliary problem with relaxed constraints, we
are able to answer some open questions raised by Csákány and Juhász
(Mathematics Magazine, 2000).

1

Introduction

Not so very long ago there became widespread an excellent kind
of game, called Solitaire, where I play on my own, but as if with a
friend as witness and referee to see that I play correctly. A board
is ﬁlled with stones set in holes, which are to be removed in turn,
but none (except the ﬁrst, which may be chosen for removal at will)
can be removed unless you are able to jump another stone across it
into an adjacent empty place, when it is captured as in Draughts.
He who removes all the stones right to the end according to this
rule, wins; but he who is compelled to leave more than one stone
still on the board, yields the palm. This game can more elegantly be
played backwards, after one stone has been put at will on an empty
board, by placing the rest with it, but the same rule being observed
for the addition of stones as was stated just above for their removal.
Thus we can either ﬁll the board, or, what would be more clever,
shape a predetermined ﬁgure from the stones; perhaps a triangle, a
quadrilateral, an octagon, or some other, if this be possible; but such
a task is by no means always possible: and this itself would be a
valuable art, to foresee what can be achieved; and to have some way,
particularly geometrical, of determining this.

Gottfried W. Leibniz1

1Original Latin text in Miscellanea Berolinensia 1 (1710) 24, the given translation is from

[3].

Figure 1: A peg solitaire move.

In this work we investigate some computational and mathematical aspects
of the classical game known as peg solitaire. In peg solitaire, we have a grid
graph (the board) on each of whose nodes (the holes) there may be at most one
peg. The initial conﬁguration of pegs evolves by performing one of the following
moves (the jumps): for each triple of horizontally or vertically adjacent nodes,
if the ﬁrst and the second nodes are occupied by pegs and there is no peg
on the third one, then we can remove the two pegs and place a new one on
the third node. A puzzle of peg solitaire is deﬁned by an initial and a ﬁnal
conﬁguration, and consists of ﬁnding a sequence of moves that transforms the
initial conﬁguration into the ﬁnal one.

Because of the complexity generated by such simple rules [14, 17, 10, 7], the
game has attracted the attention of many mathematically-inclined minds over
its long history (for which we refer the reader to Beasley’s writings on the topic
[8, 4, 5]). In fact, we started with a quotation from Leibniz, and the origin of the
game may well precede his time. Despite such a respectable age, the problem
of deciding which peg solitaire puzzles can be solved is far from settled [4].

The present paper contributes to such investigation by considering two spe-

ciﬁc problems:

• Peg-Reachability: given an initial conﬁguration of pegs on a ﬁnite
board, we wish to determine whether there exists a sequence of moves
that allows some peg to be placed in a given target position.
• Solitaire-Army: given a target position and a region of an inﬁnite
board, ﬁnd an initial conﬁguration of pegs inside that region, and a se-
quence of moves that allows some peg to be placed in a given target
position.

We study the former problem from a computational point of view and we prove
that Peg-Reachability is NP-complete. This result, which we discuss in
Section 2, is a signiﬁcant step in understanding why peg solitaire puzzles are
intrinsically diﬃcult. They are actually still a good testbed for artiﬁcial intel-
ligence techniques [22, 21]. Indeed, the ﬁrst computational hardness result for
this game was proved in 1990 in [25], but was limited to those peg solitaire
puzzles in which the ﬁnal conﬁguration is required to have only one peg (and
hence the goal was that of cleaning the entire board).

The Solitaire-Army problem has received a lot of attention from the math-
ematical and game-connoisseur community [8, 1, 9]. In this body of works, the
part of the board where no pegs are allowed in the initial conﬁguration is called
desert, and the typical goal is reaching the farthest distance inside the desert.
In the classical example, introduced by J. H. Conway, the desert is a half-
plane. Conway devised an elegant potential function argument which shows

2

that, for any initial conﬁguration, and no matter what sequence of moves one
may attempt, no peg can reach a distance larger than four in the desert [20].

Other shapes for the desert have been considered. For instance, in [13], the
authors focus on square-shaped and rhombus-shaped deserts. Here the natural
target position is the center of the square/rhombus, and the goal is that of
ﬁnding the largest size of the desert for which the puzzle is solvable. Among
other results, in [13] it is shown that the 9 × 9 square-shaped and 13 × 13
rhombus-shaped deserts are solvable, while the 13×13 square-shaped and 17×17
rhombus-shaped are not. Therefore the problems whether the 11 × 11 square-
shaped and 15 × 15 rhombus-shaped deserts are solvable were left open2.
In Section 3 we discuss our contribution to the Solitaire-Army problem.
We develop a general approach that can be used to attack such kind of puzzles,
and as a byproduct, we are able to show that both the 11×11 square-shaped and
15×15 rhombus-shaped deserts are actually solvable. The main idea underlying
our technique is considering an auxiliary problem where the constraint that any
node can have at most one peg is relaxed to allowing pegs to be stacked. We
actually allow each node to have any integer number of pegs, including negative.
This setting has the advantage that the order of the moves is immaterial. The
auxiliary problem admits a natural compact Integer Linear Programming (ILP)
formulation which, when the puzzle is simple enough, can be safely solved by
means of an ILP solver. Once the relaxed problem is solved we provide also an
eﬃcient algorithm which converts the relaxed solution into a solution for the
original problem.

Interestingly enough, an analogous relaxation was considered in [11] for a
similar problem where a diﬀerent set of moves is used (the so-called pebbling
game). The authors claim the equivalence between the relaxed and the original
problem (see Lemma 3 in [11]) but the proof is omitted as an ‘easy induction
argument’. Apparently, E. W. Dijkstra disagrees with such statement: “it would
have been nice if ‘the easy induction argument’ had been shown: a few colleagues
2 hours on not ﬁnding it” [15]. Since our equivalence result holds
and I spent 1 1
for a large class of moves which includes both pegs and pebbles, we also obtain
their result as a corollary.

Other related results. Our hardness reduction contributes to the line of
research investigating the computational complexity of combinatorial games [19,
12, 16, 26, 2, 18]. As for positive results regarding the computational tractability
of peg solitaire, it has been shown that, on a rectangular board of ﬁxed height,
the set of initial conﬁgurations that can be reduced to a single peg form a
regular language [24, 23]. Recently, the game of peg solitaire has been also
generalized to general graphs [6]. Finally, the idea of formulating peg solitaire
puzzles as integer linear programs in order to solve them by computer was
already suggested in [3] and eﬀectively used in [22].

2Note that the square/rhombus should have the side of odd length in order for the center

of the desert to be well-deﬁned.

3

2 Our Hardness Reduction
2.1 Overview of the Reduction
Here we consider the problem Peg-Reachability: given an initial conﬁgura-
tion of pegs on a board, it asks to decide whether there exists a sequence of
moves that cause a peg to be placed in a given target position. We prove that
Peg-Reachability is NP-complete.

Our reduction is from the planar circuit satisﬁability problem (PCSat for
in PCSat we are given a boolean network represented as a planar di-
short):
rected acyclic graph G having a single sink vertex t ∈ V (G) (i.e., a vertex having
out-degree 0). Each other vertex in V (G) is either an input vertex or a NAND
vertex. The vertex t is required to have in-degree 1, input vertices must be
sources in G (i.e. their in-degree must be 0), while NAND vertices must have
in-degree exactly 2 and out-degree at least 1. The problem consists in deter-
mining whether it is possible to assign a truth value π(u) ∈ {True, False} to
each vertex u ∈ G in order to satisfy the following properties:

• the truth value assigned to a NAND vertex u is the NAND of the truth
values of its two in-neighbors, i.e., if v1 and v2 are the in-neighbors of u,
we have π(u) = ¬(π(v1) ∧ π(v2));
• the value assigned to the sink vertex t coincides with the truth value of
its only in-neighbor;
• π(t) = True.
Notice that the assignment π(·) is completely determined by the truth values
of the input vertices. It is well known that this problem is NP-hard.3 Clearly,
the graph can be thought as a boolean circuit consisting of links and gates which
computes a boolean output as a function of the circuit’s inputs x1, x2, . . . .

Given any instance of PCSat, we will build an instance of Peg-Reachability

which simulates the behavior of such a circuit. We encode the circuit’s mechan-
ics using dual-rail logic: each edge of the network will be transformed into a
dual-rail wire consisting of two single wires which will always “carry” opposite
boolean values. In order to perform such a transformation we will make use
of some gadgets: the choice gadget will be used to encode input vertices, the
NAND gadget will represent a NAND vertex, and the fan-out gadget will al-
low to split a single double-wire into multiple double-wires to be fed as input
into other gadgets. For technical reasons, the fan-out gadget will output and
additional boolean control signal on a dedicated single wire, which we will call
control wire. Intuitively, if we require this control signal to be True, then the
correct operation of the fan-out gadget is guaranteed. All these control wires
can be safely brought outside of the area of the board that contains the gadgets
and all the other wires. Once this has been done, we can ﬁnally AND together
the boolean signals carried by all these control lines along with the signal car-
ried by the double wire corresponding to the unique edge entering the output
vertex t. Since G is planar we will have no intersections between double-wires.
However, the same does not hold for control wires. Whenever a control wire
3See, for example, the notes of lecture 6 of the course “Algorithmic Lower Bounds: Fun with
Hardness Proofs” by Prof. Erik Demaine (http://courses.csail.mit.edu/6.890/fall14/
lectures/).

4

Figure 2: An instance of PCSat corresponding to the formula (¬x1 ∨ ¬x2) ∧
(x2 ∨ ¬x3 ∨ ¬x4). Gadgets that we need to implement are highlighted.

intersects a double wire we will use a suitable additional gadget which we call
control-crossover that ensure that, whenever the control signal is True, the
signal carried by the double wire will not be aﬀected.

Figure 2 shows a possible instance of PCSat and highlights the gadgets
we need to implement, while Figure 3 is a high-level picture of the associated
instance of Peg-Reachability. Clearly, the circuit shown in Figure 3 will be
implemented as a certain conﬁguration of pegs on a board. The output of the
last AND gate will correspond to the target position of Peg-Reachability: a
peg can be brought to the target position iﬀ there is a truth assignment of the
inputs that causes the circuit to output True.

2.2 Description of the Gadgets
In this section we describe the gadgets used by our reduction. We will need to
design gates for both binary and dual-rail logic. We will use the following color
convention: the former will be colored white, while the latter will be in gray.

2.2.1 Binary Logic Gadgets
We start by describing the gadgets of our construction that deal with binary
logic. We have single wires and binary logic gates.
Intuitively a single wire
“carries” a boolean signal from its ﬁrst endpoint to the other. The truth value
of the signal is encoded as follows: if there is a peg on the ﬁrst endpoint then
the signal is True, and the wire will allow the peg to be moved to the other
endpoint via a sequence of moves. On the converse, if there is no peg on the
ﬁrst endpoint then no move can be made and therefore no peg can be placed on
the second endpoint, which encodes a False signal. The implementation of a
single wire is straightforward and it is shown in Figure 4. In order to deal with
parity issues we can use the Shift gadget (also shown in Figure 4) that allows

5

x1x2x4x3t?y¬yFigure 3: A high-level picture of the instance of Peg-Reachability corre-
sponding to the instance of PCSat shown in Figure 2. Double wires are bold
while single wires are thin. Control wires (in green) are ANDed together with
the single wire carrying the positive signal z of the circuit output. The negated
signal ¬z is ignored.

to shift a wire by one row/column of the board. This gadget can also be used
to force the signal to ﬂow in one direction.

As far as gates are concerned, each gate takes one or more boolean inputs
(which are again encoded by the presence or absence of pegs in certain input
positions), and has one or more boolean outputs which are a function of the
inputs. If an output is True, this means that there exists a sequence of moves
which places a peg on the output position of the gate. Otherwise, if an output
is False, no sequence of moves can place a peg on the output position of the
gate.

Intuitively, this gadget allows for two single
Binary Logic Half-Crossover
wires to safely cross each other if at least one of them is False. When both
signals are True they cannot both cross, and one of them will become False.
More formally, the half-crossover has two inputs x and y and two outputs x(cid:48)
and y(cid:48). If x and y are not both true, then x(cid:48) is true iﬀ x is true, and y(cid:48) is true
iﬀ y is true. Otherwise, if both x and y are true, then only one of x(cid:48) and y(cid:48) can
be set to true. The gadget is shown in Figure 4.

Binary Logic AND and Binary Logic OR The binary logic AND and OR
gadgets have two inputs and one output and their implementations are shown
in Figure 5.
In the AND gadget it is possible to place a peg on the output
position only when both pegs are present on the input positions while, in the
OR gadget, it is possible to output a peg iﬀ at least one input peg is present.
Clearly, multiple copies of both the AND and the OR gadgets can be chained
together in order to simulate AND and OR gates with multiple inputs.

6

????x1x2x3x4Target¬zzFigure 4: Symbols and implementations of the wire (left), shift (center), and
half-crossover (right). In the half-crossover, if the inputs x and y are not both
true, then x(cid:48) = x and y(cid:48) = y. Otherwise either x(cid:48) or y(cid:48) will be true (but not
both).

Figure 5: Implementation of the AND and OR binary logic gates.

Binary Logic Fan-Out This gadget allows to duplicate an input signal x.
For technical reasons it also has an additional output signal c that we call control
signal. Whenever c is True, this gate acts as a classical fan-out: the values of
the two outputs x(cid:48) and x(cid:48)(cid:48) (see Figure 6) will coincide to the value of x. We
will always require all the control lines to be True. In order to implement this
gate we need an additional gadget that we call AND-OR-AND gate.

The AND-OR-AND gate takes three inputs a, x, b (in order) and computes
a single output whose value is True iﬀ x is True or both a and b are True.
The implementation is given in Figure 6. Notice that if x is True, then a True
signal can traverse the half-crossover and trigger the OR-gate, which outputs
True. If x is False, then the only way for the gate to output True is to have
both a and b set to True. Indeed, in this case, a can traverse the half-crossover
and reach the AND gate together with b. Both this signals are need to cause
the AND and the OR gates to output True.

Now we argue on the correctness of the fan-out gadget. Assume that the
output control signal c is True. This means that either x is True and hence
two pegs can be placed on the output positions of x(cid:48) and x(cid:48)(cid:48), or x is False
which means that the other two inputs of the AND-OR-AND gate must both
be true, which implies that no peg can reach x(cid:48) or x(cid:48)(cid:48).

Binary Logic Control-Crossover This gadget allows a control signal c to
safely cross a the signal x carried by single wire. The gadget has two outputs
c(cid:48) and x(cid:48) and its implementation is shown in Figure 7. If c(cid:48) is required to be
True, then c must be also true and x(cid:48) will be True iﬀ x is True. Notice that

7

SingleWirexx0y0yxx0Half-Crossovery0yShiftxyx∧yANDxyx∧yxyx∨yxyx∨yORFigure 6: Implementation of the AND-OR-AND and fan-out binary logic gates.

Figure 7: Implementation of the control-crossover gadget. If c(cid:48) = True, then
c = True and x(cid:48) = x. If c(cid:48) = True then x(cid:48) is unrelated to x and can be either
True or False.

if c(cid:48) = False then x(cid:48) can be freely set to True or False. However, we will
always require c(cid:48) to be set to True.

We now argue on the correctness of the gadget. We only need to consider
the case c(cid:48) = True. It is easy to see that, in order for c(cid:48) to be True, c must
be True as well. Indeed if c = False, then at least one of the two inputs of
the AND gate must be false. Let us assume c = True. Either x = True or
x = False. In the ﬁrst case, the gate can output x(cid:48) = True and c(cid:48) = True: we
can use the peg from c to allow the peg from x to reach the fan-out gate which
can now output three True signals. Notice that this requires the peg from x to
jump over the peg from c. In the other case, i.e. x = False, we have that the
gate can output x(cid:48) = False and c(cid:48) = True by using the peg from c to activate
the OR gate, and the control signal from the fan-out gate to activate the end
gate. Now, we only need to show that the gate cannot output x(cid:48) = True and
c(cid:48) = True. Indeed, as c(cid:48) = True, the control signal from the fan-out gate must
be true as well. The claim follows since, in this case, there is no way for a True
signal to reach the input of the fan-out gate.

2.2.2 Dual-Rail Logic Gadgets
Double Wire and Dual-Rail Logic Choice These two gadgets are straight-
forward and their implementation are shown in Figure 8. Double wires will be
drawn in bold to distinguish them from single wires. Moreover we will refer to
pair of signals x and ¬x as ˆx. In the choice gadget, the central peg must jump

8

Fan-Outx0xcx00x∨(a∧b)AND-OR-ANDaxbxx0cx00x∨(a∧b)abxc0x0cxcxc0x0Control-CrossoverFigure 8: Implementation of a double wire and of the dual-rail logic choice
gadget.

over either the peg on its top (that corresponds to x) or the peg on its bottom
(that corresponds to ¬x).
Dual-Rail Logic NAND We implement this gate by separately building a
dual-rail NOT gate and a a dual-rail AND gate, see Figure 9. To compute ¬ˆx
from ˆx, we just need to exchange the roles of the single wires corresponding
to x and ¬x, hence the NOT gate is actually just a half-crossover. The AND
gate computes the logic AND of ˆx and ˆy by separately computing x ∧ y and
¬(x ∧ y) = ¬x ∨ ¬y. Notice that, every time we use a half-crossover, at least
one of its inputs is False.

Dual-Rail Logic Fan-Out This gate is shown in Figure 10 and it is similar
to the binary logic fan-out except that it works on double wires. The gadget
makes use of two binary logic fan-outs whose control lines are crossed with the
single wires using binary logic control crossovers. The additional control output
c will be True iﬀ all the inner control lines are True as well, hence ensuring
the correct operation of the gadget. Notice that we also need to cross a single
wire carrying the signal ¬x with another single wire carrying ¬x but this can
be safely done by using an half-crossover.

Dual-Rail Logic Control-Crossover This gadget allows for a control wire
to safely cross a double wire: if the control output c(cid:48) is True, then the control
input c is true as well and the output x(cid:48) is equal to the input x (see Fig-
ure 11). Its implementation is straightforward as it suﬃces to use two binary
logic control-crossovers to cross c with the single wires corresponding to x and
¬x, respectively.
3 The Solitaire-Army problem
In this section we focus on the Solitaire-Army problem which, given a target
position g and a region R of an inﬁnite board, requires ﬁnding an initial con-
ﬁguration of pegs inside R, and a sequence of moves such that a peg is ﬁnally
placed in g. We will call desert the part of the board where no pegs are allowed
in the initial conﬁguration. Moreover, when we consider a conﬁguration of the
board, for any position p, we denote by n(p) the number of pegs placed at p
in the conﬁguration. When trying to solve an instance of Solitaire-Army,

9

DoubleWire?x¬xˆxChoiceFigure 9: Implementation of the dual-rail logic NOT, AND, and NAND gates.

Figure 10: Implementation of the dual-rail logic fan-out. Whenever c(cid:48) = True,
the gadget duplicates ˆx into ˆx(cid:48) and ˆx(cid:48)(cid:48).

10

Dual-RailLogicNOT¬ˆxˆxx¬xx¬xˆxx¬xˆyy¬yˆx∧ˆyx∧y¬x∨¬yˆyˆxˆx∧ˆyDual-RailLogicANDDual-RailLogicNAND¬(ˆx∧ˆy)ˆyˆx¬(ˆx∧ˆy)ˆyˆxˆx¬ˆxˆx0ˆx00ˆxˆxˆx0ˆx00ccDual-RailLogicFan-outFigure 11: Implementation of the dual-rail logic control-crossover.

Desert

Square 7 × 7
Square 9 × 9
Square 11 × 11

Square 12 × 12

Square 11 × 11 at the border of
the board, when the board is a

half-plane

Square 11 × 11, when the board
is the union of three half-planes

tangent to the desert

of length 15)

Rhombus 15 × 15 (i.e. with axes
Rhombus 15 × 15 at the border
of the board, when the board is

a diagonal half-plane

Rhombus 15 × 15, when the
board is the union of three
half-planes tangent to the desert

Goal
vertex
Center of
the desert
Center of
the desert
Center of
the desert
One of the
four centers
of the desert

Center of
the desert

Center of
the desert

Center of
the desert

Center of
the desert

Center of
the desert

Number of

moves

15

39

212

301

246

241

176

202

183

Table 1: Solutions to Solitaire-Army of particular interest.

11

ˆxˆx0cc0Dual-RailLogicControlCrossoverˆxx¬xx00x0ˆx0cc0Figure 12: The initial deployment of the Solitaire-Army which sends a peg
to the center of a square 11 × 11 desert (this problem was left open in [13]).
The army is divided into seven platoons each denoted by a letter. The letters
inside the square represent the positions reached by the corresponding platoons.
When those positions are taken, it is easy to conquer the center denoted by a
star. The complete sequence of moves is given in Appendix A.

it is convenient to consider the reversed version of the game, as if we were
rewinding a video of someone trying to solve the puzzle. More formally, in the
reverse Solitaire-Army, a move is deﬁned as follows. Let p = (p1, p2, p3) be
a generic triple of vertically or horizontally adjacent positions p1, p2 and p3. A
move consists of decreasing by one n(p3) and increasing by one both n(p1) and
n(p2), provided that n(p1) = n(p2) = 0 and n(p3) = 1. Clearly, an instance of
Solitaire-Army is solvable if and only if, in the reversed version of the game,
it is possible to reach a conﬁguration with no peg in the desert, starting from
an initial conﬁguration with a single peg placed in g. In the rest of this section,
we will consider always the reversed version of Solitaire-Army and we will
refer to it as simply Solitaire-Army.

We are now ready to describe a general approach that can be conveniently
used to attack an instance of Solitaire-Army. One of the most annoying
issue when trying to solve the problem is the fact that the order of the moves
does matter. To circumvent this diﬃculty, we simplify the game by deﬁning a
relaxed version of Solitaire-Army that we call SRP . In this variant, given a
triple p = (p1, p2, p3) on the board, a move consists of decreasing n(p3) by one

12

ABCDEFG⋆ABCDEFGGG131211109876543210-1-2-3-4-5-6-7-8-9-10-11-12-13543210-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17and increasing both n(p1) and n(p2) by one, with no constraints on the values
of n(p1), n(p2) and n(p3). Therefore we allow each position to have any integer
number of pegs, including negative. Here the goal is to reach a conﬁguration
in which there is no peg in the desert and every position in the region R is
occupied by at most one peg.

Our main contribution of this section is the following theorem, which shows

the equivalence among the two versions of the game.
Theorem 1. SRP is solvable if and only if Solitaire-Army is solvable.
Moreover, any solution for SRP can be transformed in polynomial time into
a solution for Solitaire-Army (with at most the same number of moves).
Proof. Recall that we are considering the reversed version of Solitaire-Army.
For any ﬁnite board, let n be the number of positions. Let b be a n × 1 integer
vector with 0 ≤ b ≤ 1 which represents the initial conﬁguration of pegs. Let c
be a n × 1 integer vector with 0 ≤ c ≤ 1 which represents the constraints on
the ﬁnal conﬁguration. In particular the zero entries of c specify the region that
at the end should be cleared of pegs (the desert). A n × m matrix A = (aij)
deﬁnes the set of moves on the board:
for j = 1, . . . , m, the jth move adds
aij ∈ {0, 1,−1} pegs to the ith position. The fundamental assumption on this
matrix is that each column of A, a move, has at most a −1 entry.
According of this notation, we state the relaxed problem (SRP ): ﬁnd a m×1
integer vector x ≥ 0 such that

0 ≤ Ax + b ≤ c.

Note that the component (Ax + b)i gives the number of pegs at the ith po-
sition after we applied (x)j times the jth move for j = 1, . . . , m to the initial
conﬁguration b.

On the other hand, the original problem Solitaire-Army can be rephrased
as follows. Find m×1 unit vectors u1, u2, . . . , uN (a unit vector is a vector which
has an entry 1 and 0s elsewhere) such that

where xk := (cid:80)k

0 ≤ Axk + b ≤ 1 for 1 ≤ k ≤ N − 1 and 0 ≤ AxN + b ≤ c.

t=1 ut. Hence if a solution x of SRP is available, we need to
ﬁnd a decomposition of x into an ordered sum of unit vectors which represents
a speciﬁc sequence of feasible moves for Solitaire-Army.

For a generic vector x, we denote by |x| the sum of the entries of x. The
following preliminary lemma describes a crucial property we will need later.
Lemma 1. Let x be a solution of SRP and let y be a m× 1 integer vector such
that

0 ≤ y ≤ x and Ay ≥ 0.

If y is maximal, i. e. there is no unit vector u ≤ x − y such that y(cid:48) := y + u
satisﬁes the above inequalities, then x(cid:48) := x − y is another solution of SRP .
Proof. We have to show that 0 ≤ Ax(cid:48) + b ≤ c. The inequality on the right
is trivial:

Ax(cid:48) + b ≤ (Ax(cid:48) + b) + Ay = Ax + b ≤ c.

13

If the remaining inequality Ax(cid:48) + b ≥ 0 does not hold then there is some
i ∈ {1, . . . , n} such that (Ax(cid:48) + b)i ≤ −1 which implies

(Ax(cid:48))i ≤ −1 − (b)i ≤ −1.

Hence there exists a unit vector u ≤ x(cid:48) such that (Au)i = −1. We claim
that A(y + u) ≥ 0, which contradicts the maximality of y. As regards the
ith entry,

(A(y + u))i = (Ax + b)i − (Ax(cid:48) + b)i + (Au)i ≥ 0 + 1 − 1 = 0.

We divide the proof of this fact into two claims.

For l (cid:54)= i, due to the fundamental assumption on the matrix A, we have
(Au)l ≥ 0 and the proof is complete.
In order to prove Theorem 1, it suﬃces to show that if SRP is solvable
then Solitaire-Army is solvable as well. The proof is by induction on the the
number of moves |x| of the solution of SRP x. If |x| = 1 then we set u1 := x and
we are done. Assume that |x| > 1 and any x(cid:48) solution of SRP with |x(cid:48)| < |x|
can be transformed into a solution of Solitaire-Army.
Let x0 = 0. We need to show that if we are at the step k with 0 ≤ k < |x|
and 0 ≤ Axk +b ≤ 1 then we are able to move forward to step k+1: there exists
a unit vector u ≤ x − xk such that 0 ≤ Axk+1 + b ≤ 1 where xk+1 := xk + u.
Claim 1. There is a unit vector u such that u ≤ x− xk and A(xk + u) + b ≥ 0.
Proof. Let z := x − xk, then z ≥ 0 and z (cid:54)= 0.
If Az ≥ 0 then we extend z to a maximal vector y such that z ≤ y ≤ x
and Ay ≥ 0. By Lemma 1, x(cid:48) := x − y is another solution for SRP with
|x(cid:48)| < |x| and, by the induction hypothesis, it can be transformed into a
solution of Solitaire-Army.
On the other hand, if Az ≥ 0 does not hold, then there is some i ∈
{1, . . . , n} such that (Az)i ≤ −1 and there is a unit vector u ≤ z such that
(Au)i = −1. If l (cid:54)= i it follows that

(A(xk + u) + b)l = (Axk + b)l + (Au)l ≥ (Axk + b)l ≥ 0.

As regards the ith entry, Ax + b ≥ 0 implies

(Axk + b)i = (Ax + b)i − (Az)i ≥ 0 + 1 = 1.

and therefore

(A(xk + u) + b)i = (Axk + b)i + (Au)i = (Axk + b)i − 1 ≥ 1 − 1 = 0.
Hence A(xk + u) + b ≥ 0.
Claim 2. There is a unit vector u such that u ≤ x−xk and 0 ≤ A(xk +u)+b ≤
1.
Proof. Let U be the set of unit vectors u ≤ x−xk such that A(xk +u)+b ≥
0. The set U is not empty by Claim 1. If Claim 2 holds then the proof is
complete. Otherwise given any u ∈ U there is some i ∈ {1, . . . , n} such that

(Axk + b)i = 1 and (Au)i = 1.

14

On the other hand, 0 ≤ Ax + b ≤ c implies
(A(x − xk − u))i = (Ax + b)i − (Axk + b)i − (Au)i ≤ 1 − 1 − 1 = −1,
and there is a unit vector v ≤ x − xk − u such that (Av)i = −1. Hence

(A(xk + v) + b)i = (Axk + b)i + (Av)i = 1 − 1 = 0

z := (cid:80)r

which means that v ∈ U.
By iterating this process, we generate a sequence of elements of U. Since
U is ﬁnite, this sequence has a minimal cycle, u1, . . . , ur−1, ur = u1 and, by
construction, for 2 ≤ t ≤ r, (Aut)i = −1 implies that (Aut−1)i = 1. Setting
t=2 ut, we have 0 ≤ z ≤ x, Az ≥ 0 and z (cid:54)= 0. Now, as in Claim
1, we extend z to a maximal vector y. Then, by Lemma 1, x(cid:48) := x − y is
another solution for SRP with |x(cid:48)| < |x| and ﬁnally we apply the induction
hypothesis.
Finally, observe that the proof is constructive and can be easily turned into

a polynomial-time algorithm that performs the transformation.

1 , . . . , p(i)

(cid:96)i−1) = 0.

(cid:96)i ) of vertices of the board.

We emphasize that Theorem 1 actually holds for a wider class of games
(including the pebbling game [11]). More precisely, we can deﬁne a generalized
(reversed) Solitaire-Army problem in which the set of moves is speciﬁed by
a collection of tuples p(i) = (p(i)
In this
game a move consists of removing a peg from the vertex p(i)
and of adding
(cid:96)i
a peg in the remaining vertices of the tuple, provided that n(p(i)
(cid:96)i ) = 1 and
n(p(i)

1 ) = ··· = n(p(i)
Since it turns out that SRP admits a compact integer linear programming
formulation (ILP), then several Solitaire-Army puzzles can be solved by using
a good ILP solver4. Table 1 summarizes some of the results that we obtained by
using our general approach. As an example, in Figure 12, we illustrate a ﬁnal
conﬁguration for the Solitaire-Army in which the initial target position is the
center of a 11×11 square-shaped desert. To appreciate the combinatorial beauty
of our solutions, we recommend to visit the gallery of animations provided at
http://solitairearmy.isnphard.com.

References
[1] M. Aigner. Moving into the Desert with Fibonacci. Math. Magazine,

70(1):11–21, 1997.

[2] G. Aloupis, E. D. Demaine, A. Guo, and G. Viglietta. Classic Nintendo
games are (computationally) hard. Theoretical Computer Science, 586:135–
160, 2015.

[3] J. D. Beasley. The Ins and Outs of Peg Solitaire. Oxford University Press,

1985.

[4] J. D. Beasley. Solitaire: Recent Developments. arXiv:0811.0851, 2008.

4We used Gurobi Optimizer, that Gurobi Optimization Inc. has gently made freely avail-

able to academic users for research purposes.

15

[5] J. D. Beasley. John and Sue Beasley’s Webpage on Peg Solitaire, 2015.

[6] R. A. Beeler and D. Paul Hoilman. Peg solitaire on graphs. Discrete

Mathematics, 311(20):2198–2202, 2011.

[7] G. I. Bell. A Fresh Look at Peg Solitaire. Mathe.Magazine, 80(1):16–28,

2007.

[8] G. I. Bell, D. S. Hirschberg, and P. Guerrero-Garcia. The minimum size

required of a solitaire army. arXiv/0612612, 2006.

[9] E. R. Berlekamp, J. H. Conway, and R. K. Guy. Winning Ways for Your

Mathematical Plays, Volume 2. AK Peters, 2002.

[10] A. Bialostocki. An application of elementary group theory to central soli-

taire. The College Mathematics Journal, 29(3):208, 1998.

[11] F. Chung, R. Graham, J. Morrison, and A. Odlyzko. Pebbling a Chess-

board. The American Mathematical Monthly, 102(2):113–123, 1995.

[12] G. Cormode. The hardness of the Lemmings game, or Oh no, more NP-

completeness proofs. In FUN 2004, pages 65–76.

[13] B. Csákány and R. Juhász. The Solitaire Army Reinspected. Math. Mag-

azine, 73(5):354–362, 2000.

[14] E. W. Dijkstra. The checkers problem told to me by M.O. Rabin. http:

//www.cs.utexas.edu/users/EWD/ewd11xx/EWD1134.PDF, 1992.

[15] E. W. Dijkstra. Only a matter of style? http://www.cs.utexas.edu/

users/EWD/ewd12xx/EWD1200.PDF, 1995.

[16] M. Forivsek. Computational Complexity of Two-Dimensional Platform

Games. In FUN 2010, pages 214–227.

[17] M. Gardner. The Unexpected Hanging and Other Mathematical Diversions.

University of Chicago Press, 1991.

[18] L. Guala, S. Leucci, and E. Natale. Bejeweled, Candy Crush and other

match-three games are (NP-)hard. In CIG 2014, pages 1–8.

[19] R. A. Hearn and E. D. Demaine. Games, puzzles, and computation. AK

Peters, 2009.

[20] R. Honsberger. A problem in checker jumping. Mathematical Gems II,

pages 23–28, 1976.

[21] C. Jeﬀerson, A. Miguel, I. Miguel, and S. A. Tarim. Modelling and solving
English Peg Solitaire. Computers & Operations Research, 33(10):2935–
2959, 2006.

[22] M. Kiyomi and T. Matsui.

Integer Programming Based Algorithms for
Peg Solitaire Problems. In Computers and Games, number 2063 in LNCS,
pages 229–240. Springer, 2000.

16

[23] C. Moore and D. Eppstein. One-Dimensional Peg Solitaire, and Duotaire.

arXiv/0008172, 2000.

[24] B. Ravikvmar. Peg-solitaire, string rewriting systems and ﬁnite automata.
In Algorithms and Computation, volume 1350, pages 233–242. Springer,
1997.

[25] R. Uehara and S. Iwata. Generalized Hi-Q is NP-Complete.

TRANSACTIONS, E73-E(2):270–273, 1990.

IEICE

[26] G. Viglietta. Gaming Is a Hard Job, but Someone Has to Do It! Theory

of Computing Systems, 54(4):595–621, 2014.

A Moves of the Solution in Figure 12
Given a conﬁguration of pegs on a board, we denote a jump with (x,y,d), where
d ∈ {↑,↓,←,→} indicates the direction of the jump that has to be made by
the peg in position (x, y) of the board. The moves that allows the peg army in
Figure 12 to reach the center are listed below.
Platoon A: (-7,-2,→), (-9,-2,→), (-11,-2,→), (-13,-2,→), (-10,-4,↑), (-10,-2,→),
(-10,0,↓), (-12,0,→), (-11,2,↓), (-12,-1,→), (-11,-2,→), (-8,-2,→), (-8,-4,↑), (-9,-
2,→), (-6,-2,→), (-6,0,↓), (-6,2,↓), (-6,4,↓), (-8,1,→), (-10,1,→), (-7,3,↓), (-7,5,↓),
(-9,2,→), (-8,4,↓), (-8,-1,→), (-10,-1,→), (-7,1,↓), (-7,3,↓), (-9,0,→), (-11,0,→),
(-8,2,↓), (-7,-2,→), (-5,-2,→), (-7,-1,→), (-7,1,↓), (-9,0,→), (-8,-1,→), (-6,-1,→),
(-7,0,→), (-6,2,↓), (-6,0,→), (-4,0,↓), (-4,-2,→).
Platoon B: symmetric moves of Platoon A.
Platoon C:(-8,-6,↑), (-10,-5,→), (-12,-3,→), (-10,-3,→), (-9,-7,↑), (-9,-5,↑), (-
7,-3,→), (-6,-5,↑), (-7,-5,↑), (-6,-3,→), (-8,-3,→), (-8,-5,↑), (-9,-3,→), (-7,-3,→),
(-5,-3,→).
Platoon D: symmetric moves of Platoon C.
Platoon E: (-2,-7,↑), (-3,-7,↑), (-4,-7,↑), (-6,-6,→), (-5,-8,↑), (-5,-6,→), (-6,-8,↑),
(-7,-6,→), (-7,-8,↑), (-8,-8,↑), (-8,-6,→), (-6,-6,→), (-3,-6,↑), (-4,-6,↑), (-4,-4,→),
(-2,-5,↑).
Platoon F: symmetric moves of Platoon E.
Platoon G: (-3,-9,↑), (-5,-9,→), (-7,-9,→), (-6,-11,↑), (-6,-9,→), (-3,-10,↑), (-5,-
10,→), (-5,-12,↑), (-4,-12,↑), (-3,-11,↑), (-5,-10,→), (-4,-9,↑), (-4,-7,→), (-3,-9,↑),
(1,-7,↑), (1,-9,↑), (3,-9,←), (5,-9,←), (7,-9,←), (6,-11,↑), (6,-9,←), (4,-9,←), (3,-
11,↑), (5,-10,←), (5,-12,↑), (4,-12,↑), (4,-14,↑), (3,-8,←), (3,-10,↑), (5,-10,←),
(4,-8,←), (1,-8,↑), (1,-10,↑), (3,-10,←), (2,-12,↑), (4,-12,←), (3,-14,↑), (1,-11,↑),
(1,-13,↑), (1,-15,↑), (3,-15,←), (1,-16,↑), (3,-12,←), (1,-12,↑), (0,-7,↑), (0,-9,↑),
(-2,-9,→), (-1,-11,↑), (-1,-13,↑), (-1,-15,↑), (-3,-12,→), (-2,-14,↑), (-4,-13,→), (-
3,-10,→), (2,-8,←), (2,-10,↑), (1,-10,↑), (0,-8,↑), (2,-8,←), (0,-9,↑), (0,-11,↑), (-
2,-11,→), (0,-12,↑), (-2,-12,→), (0,-13,↑), (2,-13,←), (0,-14,↑), (2,-14,←), (-2,-
13,→), (-2,-8,→), (-1,-10,↑), (-1,-7,↑), (-3,-7,→), (-1,-8,↑), (1,-6,↑), (0,-6,↑), (0,-
8,↑), (0,-10,↑), (0,-12,↑), (0,-14,↑), (0,-16,↑), (-2,-16,→), (0,-17,↑), (0,-15,↑), (0,-
13,↑), (0,-11,↑), (0,-9,↑), (0,-7,↑), (-1,-6,↑), (0,-5,↑).
Finale: (-3,-3,→), (3,-3,←), (-1,-4,↑), (1,-4,↑), (-2,-2,→), (0,-3,↑), (2,-2,←), (0,-
2,↑).

17

