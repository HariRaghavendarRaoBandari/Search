6
1
0
2

 
r
a

 

M
6
1

 
 
]
h
p
-
t
n
a
u
q
[
 
 

1
v
5
0
0
5
0

.

3
0
6
1
:
v
i
X
r
a

Engineering autonomous error correction in stabilizer codes at ﬁnite temperature

C. Daniel Freeman,1, 2, ∗ C. M. Herdman,3, 4, 5 and K. B. Whaley1, 6

1Berkeley Quantum Information & Computation Center,

University of California, Berkeley, CA 94720, USA

2Department of Physics, University of California, Berkeley, CA 94720, USA

3Institute for Quantum Computing, University of Waterloo, Waterloo, ON N2L 3G1, Canada

4Department of Chemistry, University of Waterloo, Waterloo, ON N2L 3G1, Canada

5Department of Physics & Astronomy, University of Waterloo, Waterloo, ON N2L 3G1, Canada

6Department of Chemistry, University of California, Berkeley, CA 94720, USA

(Dated: March 17, 2016)

We present an error correcting protocol that enhances the lifetime of stabilizer code based qubits
which are susceptible to the creation of pairs of localized defects (due to string-like error operators)
at ﬁnite temperature, such as the toric code. The primary tool employed is dynamic application
of a local, unitary operator which exchanges defects and thereby translates localized excitations.
Crucially, the protocol does not require any measurements of stabilizer operators, and therefore can
be used to enhance the lifetime of a qubit in the absence of such experimental resources.

I.

INTRODUCTION

For the past two decades, signiﬁcant eﬀort has gone
into devising schemes for encoding quantum informa-
tion in reliable and retrievable forms. Stabilizer error
correcting codes are thought to be an eﬀective strategy
for performing this encoding, because they allow an ef-
ﬁcient means of detecting and correcting errors. Among
these, topological stabilizer codes (or topological quan-
tum memories), are particularly promising strategies for
storing quantum information due to their intrinsic ro-
bustness to errors at zero temperature, their ability to be
eﬃciently implemented via a local Hamiltonian1, as well
as the existence of eﬃcient strategies for performing error
detection and correction2,3. Several exhaustive studies
have been performed on calculating error thresholds for
these topological codes, like Kitaev’s toric code, both in
the presence and absence of error correcting protocols2–6.
However, these topological codes are well known to be
poor passive quantum memories at ﬁnite temperature7–14
(for a thorough review, see Ref. 15). For physically re-
alistic coupling to an environment, local noise processes
drive the creation of localized defects. In the absence of
an error correcting protocol, the propagation of these de-
fects can then lead to decoherence of the memory. For
the case of the toric code, these error strings are particu-
larly pathological, and cause the maximum lifetime of an
encoded qubit to decay exponentially with temperature
with a timescale independent of system size8.

On the other hand, a variety of active error correction
protocols exist for eﬃcient detection and correction of er-
rors. As long as error rates and the temperature are low
or, alternatively, as long as detection and correction are
fast enough, the lifetime of these codes can in principle
be extended indeﬁnitely. But these decoding strategies
implicitly rely on resources that may not always be avail-
able or eﬃciently physically implementable.

An error correcting strategy for topological codes with-
out the need for stabilizer measurement is desirable. At
face, ignoring the power of the stabilizer group will as-

suredly provide a suboptimal strategy. But given limited
resources and rates of measurement it is worthwhile to
understand the limits of strategies which do not require
syndrome measurements, and to determine if such strate-
gies can augment known decoding schemes.

We provide here a new protocol for error correction
of pairs of localized defects which modiﬁes an existing
dissipative protocol. We achieve this by applying a spe-
cially designed sequence of unitary operators to a code
of choice. This pattern of operators is designed to en-
courage defects in the system to dissipate more quickly.
In this work, we explicitly treat the theory for the 1D
Ising model at ﬁnite temperature, and describe how this
approach may be extended to other stabilizer codes, such
as the toric code. While dissipative protocols have pre-
viously been employed to generate hamiltonians16,17, to
prepare encoded ground states18, to mediate long range
interactions19–21, and to “trap” defects22, a dissipative
protocol that explicitly targets string-like error processes
has not been proposed to date. While it does not com-
pletely eliminate errors, the protocol presented here pro-
vides a signiﬁcant enhancement of the lifetime of a ﬁnite-
size system.

It is known that stabilizer Hamiltonians at ﬁnite tem-
perature in dimension less than three have a system-size
independent upper bound to their lifetime8,10,11,23–27.
These “no-go” theorems necessarily limit the extent to
which the method proposed here can be carried out. In
fact, a size-independent constant enhancement of a sys-
tem’s lifetime may be the best one can get with a purely
local unitary protocol like the one presented here. Thus,
this scheme, by itself, will not generate a topologically
protected quantum memory at ﬁnite temperature for one
or two dimensions. It is nonetheless worthwhile to under-
stand how far purely local protocols can be pushed, be-
cause a large constant increase in the lifetime of a quan-
tum architecture could mean the diﬀerence between a
physically realistic architecture that can be fault toler-
antly operated versus one that cannot, as discussed in
Sec. V C.

The rest of the paper is structured as follows: in Sec.
II, we review stabilizer codes and how they can be mod-
eled at ﬁnite temperature. In Sec. III, we describe how
the 1D Ising model can be treated as a stabilizer code
and discuss the low temperature dynamics of the model.
In Sec. IV, we construct our autonomous protocol, built
out of local unitary operators, and discuss the scaling be-
havior of the protocol. We also demonstrate evidence for
the enhancement of the lifetime of the 1D Ising model. In
Sec. V, we sketch how our protocol generalizes to higher
dimensions and to other stabilizer codes, including the
toric code.

II. STABILIZER CODES

A. Deﬁnitions

In this section, we brieﬂy review the theory of stabilizer
error correcting codes28. Given n qubits, a collection of
operators Si, and k states |ψ(cid:105)i, i = 1, .., k which span
some subspace of the n qubits, let,

Si|ψ(cid:105)i = +1|ψ(cid:105)i

[Si, Sj] = 0

(1)

(2)

for all i, j. Furthermore, suppose there are m error
operators Ej, j = 1, .., m, and that for each of them, there
exists some operator Sj such that

[Ei, Sj] = −1

(3)

Stabilizer codes are those collections of states |ψ(cid:105)i and
operators {Sj} which satisfy the above conditions for
error operators belonging to some subset of the Pauli
group—tensor products of Pauli operators with the iden-
tity.

For example, given three qubits,

let |ψ(cid:105)1 = | ↑↑↑
(cid:105) and |ψ(cid:105)2 = | ↓↓↓(cid:105).
Then the set of opera-
tors satisfying (1) and (2) is {σzσzI, Iσzσz}. One
can easily determine that the set of error opera-
tors corresponding to these two stabilizer operators is:
{III, σxII, IσxI, IIσx, σxσxI, σxIσx, Iσxσx}.
More transparently, this 3-qubit stabilizer code en-
codes two protected states.
If some noise source were
to apply any single qubit σx operator, or any two-qubit
σi
xσj
x operator, measurement of the set of stabilizer oper-
ators would indicate the presence of the error. Further-
more, the code can actually detect and correct single σx
errors. For example, a meaurement result of −1, +1 of
the stabilizers σzσzI and Iσzσz, respectively, indicates
either an error on the ﬁrst qubit or two errors error on
the latter two qubits. For many noise models, the single
error situation is much more likely, thus a single σx op-
erator applied to the ﬁrst qubit will more often than not
return the qubit back into the protected subspace.

2

B. Active State Preparation versus Dissipative

Hamiltonian Engineering

Here we will reﬁne our discussion by broadly classify-
ing error correcting approaches into (1) state preparation
strategies and (2) Hamiltonian engineering strategies.

The target of both strategies is the same: the genera-
tion of an encoded stabilizer state. In state preparation, a
stabilizer encoded state is prepared by the application of
a sequence of unitaries. However, ignoring noise sources,
the natural Hamiltonian which describes the system is
H = 0. The target of such a strategy is generation of the
stabilizer state itself. Implicitly, some sort of active error
measurement and correction needs to be performed once
the target state is reached.

In contrast, in Hamiltonian engineering approaches,
the encoded state is reached by implementing a Hamil-
tonian on a set of qubits which has a stabilizer encoded
state as its ground state. The stabilizer state is then pre-
served by keeping a quantum system at a suﬃciently low
temperature to suppress errors.

Mixtures of these strategies exist. For example, one
could use a Hamiltonian engineering approach to gener-
ate a stabilizer encoded state, and then immediately turn
oﬀ the Hamiltonian once the desired state was reached,
preserving the state at further times with active error
correction. Alternatively, one could use Hamiltonian en-
gineering to prepare the state, and then use a combina-
tion of dissipation with an additional protocol to detect
or correct errors. We will focus here on this latter strat-
egy. Speciﬁcally, we will be concerned with systems being
dissipatively driven towards the ground state of a Hamil-
tonian which encodes a stabilizer state, and we will build
an autonomous error correction protocol to mitigate the
ways in which dissipation alone fails to protect the en-
coded state.

C. Error Correcting Master Equation

To dissipatively generate a stabilizer code, one forms
the system Hamiltonian as the sum of the stabilizer op-
erators for the code of interest, i.e., H = −
i Si. This
guarantees that the ground state of that hamiltonian will
be the encoded subspace. Furthermore, this ensures that
conﬁgurations of the system with errors present are ex-
cited states.

(cid:80)

To model dissipation in such a code, we employ here
a Lindblad master equation. Without loss of generality,
but to simplify analysis, we assume that the bath only
operates on the system with purely local errors, and that
these local errors correspond to the errors of the stabilizer
code of interest. Given this assumption, the dynamics
may be described by the Lindblad equation:

(cid:88)

ω

˙ρ =

2cωρc†ω − c†ωcωρ − ρc†ωcω,

(4)

where ρ is the system density matrix for some candi-

date system and {cω} = {√γωLω} are Lindblad op-

erators arising from interactions with a bath, where the
Lω act on the system with characteristic rates γω. Er-
ror processes can then be represented by products of the
Lindblad operators: {c1
A necessary condition for error correction to occur to
nth order in the error processes is to apply the inverses
of the error processes suﬃciently rapidly. If we restrict
ourselves to stabilizer codes on lattices, then the recipe
for error correction is straightforward: measure the sta-
bilizers of the code and apply correction operations con-
ditioned on the results of the stabilizer measurements.

ωc2

ω ··· cn
ω}.

While it is in principle possible to measure all of the
stabilizers of a given system simultaneously because they
all commute, it will be convenient to decompose a given
correction protocol into groups of terms involving oper-
ators only acting within a characteristic length scale λ.
This is useful because it provides a natural scale for treat-
ing stabilizer codes with ﬁxed resources, and it allows the
interpretation of diﬀerent protocols as the implementa-
tion of a certain kind of eﬀective long-range interaction.

D. Error Correction Thresholds and Scaling

Much of the power of stabilizer codes arises from the
existence of error thresholds. Speciﬁcally, as the sta-
bilizer code is made suﬃciently large, the probability
of remaining in an encoded subspace goes to 1 as long
as measurement/correction cycles occur faster than the
threshold rate. This gives rise to a competition between
the resources necessary to perform error correction/de-
tection for stabilizer codes involving many qubits, versus
the scaling of the error rate of the code with system size.
For concreteness, consider a linear stabilizer code, with
correction/detection steps idealized by operators O act-
ing over a length scale λ as in Fig. 1. In reality, these
operators O can often themselves be decomposed into
purely local operators, but detecting and correcting er-
rors occurring over a length scale λ requires measuring
and applying many such local operators over that length
scale suﬃciently quickly. For suﬃciently large λ and fast
application of gates, the distinction in terms of resource
requirements between a nonlocal operator O acting in
a region λ versus a sequence of local operators acting
within a region λ becomes a matter of philosophy.

Thus, ensuring the code remains in a protected sub-
space as system size is made large can, in practice, re-
quire applying sequences of operators over successively
larger length scales. Generically, having a larger stabi-
lizer code provides better protection to errors, but this
must be weighed against the growth rate of the number
of gates necessary to implement the corrective operators
O as system size and λ are varied. Note that if an er-
ror correction threshold exists for the code, the number
of gates could, in principle, stop growing. But, in the
absence of a threshold, if gates can only be applied with

3

FIG. 1. A linear stabilizer code with detection/correction
operators O. When the code is made larger, correction of
errors in the code will require measurement and correction of
errors occurring over larger lengthscales.

rate χ, the maximum system lifetime is set by the scaling
properties of O. We explicitly construct this operator for
a special case in Sec. III D.

III. 1D ISING MODEL

A. 1D Ising Model as a Stabilizer Code

The choice of 3-qubit stabilizer code introduced in II A
was deliberate, because it can naturally be extended and
interpreted as the ground state of a 1-dimensional Ising
model.

L(cid:88)

i=1

H1DIsing = −∆

σi
zσi+1

z

(5)

The ground state subspace of this model is two-fold
degenerate and is comprised of the states | ↑ ··· ↑(cid:105) and
| ↓ ··· ↓(cid:105). These ground states are exactly the L-qubit
analogues of the 3-qubit code treated previously. These
states are stabilized by the set of all adjacent pairwise
σz operators {II ··· Iσi
I ··· I}, where i runs from 1
to L. These are precisely the operators appearing in the
Hamiltonian of the 1D Ising model.

zσi+1

z

Furthermore, σx errors are equivalent to excited states.
In the simplest case, errors can be corrected by resort-
ing to a simple majority rule—if most spins point in a
particular direction, the correction protocol returns the
state to the encoded ground state corresponding to that
direction.

B. 1D Ising Model at Finite Temperature

By coupling the Ising model to an external reservoir,
one might hope to dissipatively drive the 1D Ising model

|q1iO...|qλi|qλ+1iO...|q2λi=⇒|q1i˜O...|q2λi|q2λ+1i˜O...|q4λiinto one of these encoded states. However, the 1D Ising
model has no ﬁnite temperature ordered phase, so at
all ﬁnite temperatures, the system evolves towards the
thermal state. Furthermore, this timescale over which
the system relaxes to a thermal state is known to be
independent of the size of the chain, given modest bath
assumptions29. Thus, dissipation by itself cannot protect
the 1D Ising model, and an additional protocol needs to
be implemented in order to correct thermal errors. While
dissipation cannot protect the 1D Ising Model at ﬁnite
temperature, it is instructive to understand the details of
how thermal ﬂuctuations lead to instability in this sim-
ple case, because very similar processes are responsible
for the instability of many other stabilizer codes at ﬁnite
temperature. In previous work, we examined the dynam-
ics of this model, as well as of the toric code, at ﬁnite
temperature14.
In particular, we identiﬁed a low tem-
perature regime where the dynamics are well described
by a simple random walk model. We brieﬂy summarize
the analysis below.

z

zσi+1

When studying the error dynamics, it is convenient to
consider the dual lattice of the Ising model: we imagine
a new 1D lattice with sites interleaved between the sites
of (5) and associate auxiliary spin values bi with them.
The auxiliary site’s spin values are uniquely determined
by the products bi = σi
, where site bi deﬁned by this
equation sits between site i and i + 1. We can identify
these extra variables with domain walls. If adjacent spin
variables disagree, then the auxiliary site sitting between
them will have bi = −1. If all but a contiguous block of
spins disagree, then all auxiliary sites will have bi = 1 ex-
cept for those two sites which sit at the two boundaries of
the contiguous blocks of spins. Describing the dynamics
of these domain walls is equivalent to describing the spin
dynamics, because if one knows all the auxiliary variables
plus any single spin value, σi
z, one can reconstruct all of
the remaining spin variables σj
z.

For simplicity, we assume a bath that operates on the
system only by creating, destroying, or translating do-
main walls. Then, for suﬃciently low temperatures, oc-
casionally the bath will cause an adjacent domain wall
pair to appear in the system. Bath ﬂuctuations will cause
this pair of domain walls to ﬂuctuate across the system,
eﬀectively causing the domain walls to undergo a 1D ran-
dom walk. When domain walls are adjacent, it is ener-
getically favorable for them to be dissipated. If domain
walls fuse before traversing the length of the system, the
encoded state will be preserved. But if domain walls un-
dergo a random walk such that one winds entirely around
the system, this eﬀectively performs an uncorrectable er-
ror on the encoded qubit because the system will have
transitioned from one encoded ground state to the other
encoded ground state14.

C. Microscopic Master Equation

4

When the bath operates on the system with purely
local errors which only create, destroy, and translate do-
main walls, the Lindblad operators for are of the form:

(cid:110)√γ0Tb,√γ+D†b,√γ−Db

(cid:111)

{cω} =

(6)

When resolved in the Pauli basis, these operators take

a simple form:

D†b =

Db =

1
4
1
4
1
2

(IσxI + σzσxσz + i (Iσyσz + σzσyI)) ,

(IσxI + σzσxσz − i (Iσyσz + σzσyI)) ,
(IσxI − σzσxσz)

(7)

Tb =

A short calculation veriﬁes (cid:80)

i cic†i = I. Physically,
these operators represent the creation of a domain wall
pair at dual lattice sites b and b+1 (D†b), annihilation of a
pair of domain walls at dual lattice sites b and b + 1 (Db),
and the translation of a domain wall from b to b + 1 or
b+1 to b (Tb). Additionally, these operators only connect
diagonal elements of the density matrix to other diagonal
elements. This reduces the time evolution of the diagonal
matrix elements to a classical master equation:

(cid:88)

n0

dPn
dt

= γ0

(cid:88)
(cid:88)

n+

n−

(cid:0)γ−Pn+ − γ+Pn
(cid:0)γ+Pn− − γ−Pn

(cid:1)
(cid:1)

(Pn0 − Pn) +

+

The rates which which these operators are applied, i.e.
γ0, γ+, and γ−, are set by the speciﬁc choice of bath
model. For simplicity, we consider here a Markovian
bath. The rates of such a bath are determined by:

(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)

γ (ω) = ξ

ωn

1 − e−βω

(8)

(9)

The relevant rates for our study are γ−, γ+, and γ0,
corresponding to domain wall pair annihilation, pair cre-
ation, and translation, respectively. Diﬀerent n corre-
spond to diﬀerent types of baths–for n = 1 the bath is
Ohmic, and for n ≥ 2, the bath is Superohmic. For our
purposes, it will be more convenient to treat γ0 as a tun-
able parameter to study the scaling behavior of our pro-
tocol. Qualitatively, γ0 scales linearly with T for Ohmic
baths and equals zero for Superohmic baths.

For more details of the master equation approach used

to study this model, see Ref. 14.

5

where there is a pair of these operators for each
triple of lattice sites.
In Fig. 2, the details of the 4-
qubit operator O are abstracted away (see Appendix A),
but it can be decomposed into applications of CSWAPs
and DWALLs, conditioned on syndrome measurements.
A simple calculation shows [HIsing, CSWAP] = 0 and
[HIsing, DWALL] = +1.

Intuitively, DWALL destroys (creates) a domain wall
pair at the dual lattice site in-between the three qubits
being operated on if and only if a domain wall pair is
present (or, all of the spins are aligned), respectively.
CSWAP translates a domain wall, either left or right if
and only if a single domain wall exists between the 3
spins being operated on.

Because we seek a protocol without measurements, the
natural operators for such a procedure are DWALL and
CSWAP. DWALL is inconvenient, both because the bath
already acts to dissipate excitations and because it can
lead to the generation of extra, uncontrolled domain walls
more easily than the CSWAP operator. Consequently, we
only use CSWAPs in our protocols.

If we restrict our attention to the low temperature
regime, then the lifetime of the Ising chain is governed
by the dynamics of single pairs of defects. For error cor-
recting purposes, it is convenient to classify the common
geometries of pairs of domain walls. First, correctable er-
rors are those errors for which the pair of domain walls
is not yet separated by L/2 or more. Non-correctable
errors are those domain wall conﬁgurations in the com-
plement of this set. In the language of error correction,
the distance for this code is (cid:98)L/2(cid:99)–more transparently,
correctable errors are those errors which will be correctly
matched by a perfect decoder. Furthermore, we need to
distinguish between trivial and nontrivial defect pairs.
A domain wall pair is trivial if two domain walls sit on
neighboring dual lattice sites. Again, assuming we op-
erate in the low temperature regime, these trivial de-
fect pairs annihilate with rate γ−—that is, much faster
than other time scales of the problem. Nontrivial pairs
are those pairs which are not on neighboring dual lattice
sites.

Designing a successful protocol for the Ising model
amounts to designing a sequence of CSWAPs that eﬃ-
ciently dissipates nontrivial, correctable defect pairs. If
we let χ be the rate at which CSWAPs can be applied,
then we expect an enhanced lifetime given the following
rate assumptions:

γ− >> χ/O(poly(L)) ∼ γ0 > γ+.

(12)

To wit, CSWAPs are applied at a rate much slower
than the inherent annihilation rate of the system–this is
so CSWAPs do not turn trivial defect pairs into nontriv-
ial defect pairs. Furthermore, χ is chosen to be close to
the inherent translation rate so that correctable, nontriv-
ial defect pairs can be brought adjacent to one another
and then be dissipated by the bath before they have time

FIG. 2. Circuit for performing error suppression for a subre-
gion of the 1D Ising model. Qubits q1 through q4 are lattice
sites on an Ising chain. s1 through s3 are ancillas used to
read out the syndrome measurements of ZZ on the nearest-
neighbor Ising lattice sites. Based on the results of the syn-
drome measurements, the conditional unitary operator CU
corrects the errors present. A table which deﬁnes CU is pro-
vided in Appendix A. This entire circuit represents a possible
realization of one such operator O from Fig. 1.

D. Error Correcting Operator

In the absence of resource constraints, it is straightfor-
ward to construct the operators which correct errors in
the 1D Ising model. According to the schematic shown in
Fig. 1, the λ = 2 analogue of O is simply the domain-wall
annihilation operator, Db from (7). In more generality,
for larger λ the corresponding O is the operator which,
given an even number of domain walls, annihilates all do-
main wall pairs in the region being operated upon. For
example, the circuit for the λ = 3 version of this opera-
tor is depicted in Fig. 2. Note that for an odd number
of domain walls, there is not an unambiguous choice for
how to annihilate domain walls because a free, unpaired
domain wall is always left over.

IV. THE PROTOCOL

A. Protocol Considerations for the 1D Ising Model

The most straightforward error correcting protocol is
simply to measure the system’s stabilizers often enough
that one can unambiguously locate pairs of domain walls
and then perform correction operations, as indicated in
Fig. 2. This can be represented by a sequence of mea-
surement operators, the stabilizer for the 1D Ising model,
Si, interleaved by conditional application of corrective
unitaries: CSWAP and DWALL. These operators opera-
tors have the following representation in the Pauli basis:

DWALL =

CSWAP =

1
2
1
2

(III + IσxI − σzIσz + σzσxσz)
(III + IσxI + σzIσz − σzσxσz)

(10)

(11)

|q1iZZCU|q2iZZ|q3iZZ|q4i|s1i=|0iH•HLL✙✙✙✙✙✙❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤SyndromeDecoding•|s2i=|0iH•HLL✙✙✙✙✙✙❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤•|s3i=|0iH•HLL✙✙✙✙✙✙❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤❴❴❴❴❴❴❴❴✤✤✤✤✤✤✤•to translate out of the correctable range of the proto-
col. The O(poly(L)) factor multiplying χ accounts for
the fact that diﬀerent protocol require some polynomial
in L number of swaps to sweep across the entire lattice.
For a proof of the polynomial scaling in L, see Appendix
B.

In the absence of a corrective protocol, this intrinsic
hopping rate of the Ising model gives rise to a simple,
background error rate14,29,

Γ0 =

γ0

1 + e∆/T

(13)

B. Protocol Construction

In this section we construct an autonomous error cor-
rection protocol for the 1D Ising model with a variable
length-scale λ. The design of the protocol reduces to
attempting to perform a sequence of CSWAPs that will
necessarily cause any arbitrarily placed pair of domain
walls within a region of length 2λ to become neighbors.
We refer the reader to Appendix B for a more complete
discussion of this strategy.

First,

the dual

lattice is

There are a variety of ways to construct protocols
which achieve this in a number of CSWAPs that scales
polynomially in the length of the system. Here we focus
on protocols which we call λ-mixing. By deﬁnition, these
are protocols which, in the absence of errors, never trans-
late domain walls a distance λ or greater. For an Ising
model of length L, λ runs from 1 to (cid:98)L/2(cid:99). In the lan-
guage of error correction, the protocol can be designed
to correct errors of distance 1 to distance (cid:98)L/2(cid:99).
subdivided into non-
intersecting subregions of length λ. Then, two adjacent
regions are chosen, and a λ-mixing protocol is applied
over that subregion of total length 2λ. CSWAPs are cho-
sen to move defects towards the shared boundary of the
two regions, but not to mix defects between the bound-
aries. The non-intersection of the two regions is crucial:
if the protocol did not have this feature, it would actually
increase the error rate, eﬀectively increasing the inherent
translation rate, and thus diﬀusion rate of defects in the
system. Fig. 3 depicts a circuit for this protocol for λ = 3
and Fig. 4 depicts the same circuit acting on the domain
wall variables. Fig. 5 illustrates a snapshot of this entire
procedure for a representative error process involving two
domain walls sitting in neighboring λ-domains.

This circuit should be reminiscent of the cartoon
sketched in Fig. 1. For our purposes, the operator O
from Fig. 1 is the full sequence of CSWAPs in Fig. 3
dressed by the probabilistic action of creation/annihila-
tion/translation operators by the bath on the system.

We provide code for this algorithm in the Appendix C,
including how the λ-mixing subprotocols are constructed.

6

FIG. 3. Sequence of CSWAPs, denoted C, for a λ = 3 λ-
mixing protocol.
If a pair of domain walls exist anywhere
between sites q1 through q7, then they will necessarily be
brought adjacent to each other by this sequence of swaps.
Gates are applied sequentially with waiting time 1/χ between
each gate.

FIG. 4. The same sequence from Fig. 3 but shown acting
on domain-wall variables. Here, it is clear that the sequence
of CSWAPs is designed not to mix domain walls between the
two regions of size λ = 3. Site b1 sits between q1 and q2, b2
between q2 and q3, etc.

C. Error Modes and Scaling

In this section, we examine how uncontrollable thermal
errors lead to loss of the qubit in the presence of the
protocol.

In the presence of a corrective protocol, and assuming
the correction rate χ is close to the translation rate of
the system but still much less than the annihilation rate,
the lowest order error process is,

ΓCyc = Lγ+

γ0
χ

γ0
γ−

1

L − 2 − 2λ

f (λ)

L

(14)

This rate is the product of (i) the baseline production
rate of defect pairs, Lγ+, (ii) the probability of a defect
pair not immediately annihilating, γ0
γ− , (iii) the proba-
bility of a defect exiting a corrective region, γ0
χ , (iv) the
probability of a nontrivial random walk across the chain
L−2−2λ , divided by a factor proportional to the num-
ber of correcting regions on the lattice. Thus, f (λ) ∝ λ.

1

|q1iCCC|q2iCCCCCC|q3i|q4iCC|q5iC|q6i|q7i|b1iCCC|b2iCCCCCC|b3i|b4iCC|b5iC|b6i7

erwise fused. At the same time, for a ﬁxed number of
domains, i.e. ﬁxed L
λ , any given pair of lattice sites is
only ever operated on by a CSWAP for a fraction of the
corrective cycle. So, for ﬁxed χ and ﬁxed L
λ , as λ is in-
creased, domain walls may spend a longer amount of time
sitting on a boundary before being caught by the proto-
col. For the protocol used in this paper, this is cubic in
λ. Thus,

g(λ, L, γ0, γ−, γ+) ∝ g(γ0, γ−, γ+)λ3 L

= g(γ0, γ−, γ+)λ2L
(16)
This scaling behavior suggests a critical cycling rate,
χc, at which the lifetime is maximally improved by the
protocol. Diﬀerentiating (15) with respect to λ yields the
critical rate, up to the rate function g,

λ

FIG. 5. One possible snapshot of the error correction process.
a) depicts a system with two domain walls present, each sit-
ting in adjacent λ-domains. b) depicts the state of the system
after the protocol has been applied–domain walls have been
shuttled to the shared boundary. In c), the bath dissipates
the domain walls, and the system returns to the ground state.

χc =

1

2λ2Lg(γ0, γ−, γ+)

,

(17)

where any residual prefactors and terms involving γ0,

γ+, and γ− have been absorbed into g.

1

γ0

Without the protocol, the probability that a pair of do-
main walls undergoes a random walk that winds around
L−2 , but when the proto-
the entire system scales like
col is implemented, the eﬀective lattice size is slightly re-
duced: the particle need only come within approximately
a distance 2λ of its partner for the protocol to fuse them.
This eﬀective rate is valid as long as χ is fast enough
to compete with γ0, but not so fast as to compete with
pair annihilation, γ−, and other higher order processes in
γ− and γ0
χ . It might be tempting to examine the form of
(14) and expect that errors vanish in the limit of γ0 → 0,
but a new eﬀective translation rate appears once γ0 <<
γ+. In this regime, two pairs of domain walls can appear
next to one another, and a consecutive annihilation event
produces a lone of pair of domain walls separated by two
dual-lattice sites. In this way, an eﬀective translation rate
is set by the rate at which these doubled-pair creation
events occur. We do not consider this limit further, but
it is the natural error process for superohmic baths at
low temperature.

To model the breakdown of (14) as χ is varied, we
, as being eﬀectively

can approximate the lifetime,
reduced by some factor proportional to χ:

ΓCyc

1

)2+(

χ
γ0

)2),

χ
γ−

1
ΓCyc →

1

ΓCyc

(1−χg(λ, L, γ0, γ−, γ+)+O((

(15)
with g(λ, L) a protocol-dependent scaling function.
Heuristically, for ﬁxed λ, one expects that g should scale
linearly with the number of parallel domains of size λ
because, for twice as many domains, twice as many pairs
will be pulled apart by the protocol that would have oth-

D. Memory Enhancement and Scaling

We now present numerical results demonstrating the
enhanced lifetime of the Ising Model when subjected to
λ-mixing protocols in serial and in parallel. For serial
application, only a single corrective operation was ap-
plied every 1/χ units of time. For parallel application,
L/(2λ) simultaneous corrective operations were applied
every 1/χ, where each operation acted on a nonintersect-
ing region of length (2λ).

For the following analysis, we deﬁne the lifetime as the
average time it takes a 1D Ising model initialized to the
spin up state to transition to the spin down state. In the
absence of the protocol, that is, in the low-χ limit, this
lifetime asymptotes to approximately the lifetime given
by (13).

For the details of the Monte Carlo algorithm, see
Ref. 14. The only nontrivial choice required at the level
of simulation is how to treat the competition between
the application CSWAPs and bath operators. For sim-
plicity, we assume if a bath operator takes longer than
1/χ to occur, that the CSWAP occurs unhindered. Like-
wise, if a bath operator takes less than 1/χ to occur,
the transformation associated with that bath operator
occurs unhindered, be that a pair creation, pair annihi-
lation, or single translation. More complicated choices
could be made, like choosing a probabilistic failure rate
of a CSWAP as a function of the ratio of the competing
timescales, but we do not expect the result of a such a
treatment to greatly aﬀect our analysis.

Fig. 6 depicts the scaling of the 1D Ising model’s life-
time with λ at ﬁxed L, where a smaller λ results in more
domains being operated on in parallel. Speciﬁcally, for

a)b)c)8

FIG. 6. Lifetime of the Ising model, expressed in terms of
inverse units of ΓIsing for a range of χ and for diﬀerent values
of λ for L = 96, T = .07, γ(0) = .0007. Protocols were
implemented in parallel on 48/λ blocks (see text).
In the
absence of the protocol, the lifetime of the Ising model for
these parameters corresponds to approximately Γ−1
0 , i.e. (13).
This is the value which all three protocols converge towards
in the limit of χ << γ0. Note the decrease in lifetime for

χ ≈ γ− = 1.

parallel simulations, the protocol was performed simul-
taneously on L/(2λ) domains. These domains were cho-
sen such that CSWAPs were only being applied on non-
overlapping regions of characteristic size λ. Here, in-
creasing parallelization manifestly increases the lifetime
of the model. For small χ, the protocol does nothing,
and the memory converges to the value of the memory
in the absence of any corrective protocol, i.e. (13). For
χ approaching γ−, the protocol begins to compete with
the process of pair annihilation, and begins turning triv-
ial defect pairs into nontrivial pairs. This actually re-
duces the lifetime below that of the protocol-free value.
In the intermediate regime, the optimal lifetime grows
linearly with the number of parallel blocks employed in
the algorithm. For this particular protocol, the number
of parallel blocks was 48/λ.

Fig. 7 depicts the scaling of lifetime with λ, as in Fig.
6, but for a serial application of the protocol. For serial
application, only a single CSWAP operator ever oper-
ates on the system over a timescale χ−1. Decreasing λ
also manifestly increases the maximum enhanced lifetime
of the protocol. Thus, for ﬁxed-resource architectures,
smaller λ necessarily outperforms larger λ implementa-
tions.

Fig. 8 and Fig. 9 depict the scaling of the lifetime with
L at ﬁxed λ for parallel application. Remarkably, the L
dependence of the models can be completely removed by
rescaling the data by (14), and rescaling χ to χL as de-
picted in Fig. 9. This rescaling reveals the turnaround
in the scaling of the lifetime for χL = .038± .002, where-
after it transitions from linear scaling in χ to a power law
decay.

FIG. 7. Lifetime of the Ising model for a range of χ and
for diﬀerent values of λ for L = 96, T = .07, γ(0) = .0007.
Protocols were implemented serially (see text). The scaling of
lifetime with χ is characteristically similar to the parallel case;
however, the maximal lifetime is correspondingly smaller for
the serial implementation. Note that smaller λ still yields a
larger enhanced lifetime.

FIG. 8. Lifetime of the Ising model for a range of χ and
for diﬀerent values of L for λ = 3, T = .07, γ(0) = .0007.
Protocols were implemented in parallel on L/2λ blocks (see
text). Note the linear scaling in χ for small values, as well as
the shift in the maximum of the lifetime as a function of L.

V. HIGHER DIMENSIONS AND

GENERALIZATION

A. The Toric Code

The argument and construction from the previous sec-
tion immediately generalizes to any higher dimensional
stabilizer codes with stringlike error operators. The im-
mediate analogue is Kitaev’s Toric Code, whose Hamil-
tonian is deﬁned as a sum over vertex and plaquette op-
erators acting on the edges of a square lattice,

10−510−410−3χ10−1100101(Γ/Γ0)−1λ=16λ=12λ=8λ=6λ=4λ=310−410−3χ10−1100(Γ/Γ0)−1λ=6λ=4λ=30.00050.00100.00150.0020χ12345678(Γ/Γ0)−1L=48L=96L=1929

ists in the protocol where defects of diﬀerent type are
uncontrollably wound around one another. This can be
suppressed by operating at low temperature. Secondly,
both of these defects undergo two-dimensional random
walks rather than one-dimensional random walks. This
diﬀerence in dimension gives rise to a modiﬁed form of
the toric code’s ﬁnite temperature error rate, due to the
diﬀering nontrivial topological random walk probability
for two dimensions versus one.

Operationally, these diﬀerences only require small
modiﬁcations of the autonomous protocol. Namely, there
need be two CSWAP operators:

CSWAPe

vv(cid:48) =

CSWAPm

pp(cid:48) =

1
4
1
4

σx
vv(cid:48) (1 − Av) (1 + Av(cid:48))
σz
pp(cid:48) (1 − Bp) (1 + Bp(cid:48))

(20)

(21)

These translate an A-type (B-type) excitation from a
vertex v (plaquette p) to an adjacent vertex v(cid:48) (plaque-
tte p(cid:48)). Second, the λ-mixing protocol shuttles defects
towards a shared boundary of length λ between subdo-
mains of charactersitic area λ2.

Because subregions share a boundary of length λ rather
than a single site, as in the one-dimensional case, the cy-
cling protocols require at most a factor of λ more swaps
to complete a cycle. The protocol then takes the follow-
ing simple form:

1. Choose a species of quasiparticle
2. Divide the lattice into domains of characteristic area

λ2

3. Pick two λ-domains which share a boundary
4. Pick two defect locations within these two λ-

domains.

5.

If these defect locations are within the same λ-
domain, apply CSWAPs until they would be nearest
neighbors.
If they are in diﬀerent λ-domains, apply
CSWAPs until they meet at the shared boundary.

6. Repeat (5) until all pairs of defect locations are

exhausted.

7. Repeat (3) through (6) until all pairs of λ domains

which share a boundary are exhausted.

8. Repeat (1) through (7) until all species of quasipar-

ticle are exhausted.

(18)

(19)

This protocol is also highly parallelizable, both by op-
erating on multiple pairs of λ-domains, and by acting
on simultaneous pairs of defect sites within pairs of λ-
domains.

The low temperature dynamics of the toric code are
governed by the proliferation of localized excitations that
are created by string-like error operators, with dynam-
ics similar to to those of the 1D Ising model. However,
toric code dynamics diﬀer in two ways: ﬁrst, there are
now two types of defects in the toric code–deﬁned as
−1 eigenstates of the Av and Bp operators, located on
the vertices and plaquettes of the square lattice, respec-
tively. Because of this, an additional error pathway ex-

B. The General Problem

We can always divide a d-dimensional

lattice into
N ≡ Ld/λd domains and try to devise an algorithm that
fuses defects between adjacent domains. For our proto-
col, defects are shuttled towards d−1-dimensional bound-
aries between adjacent domains of volume λd. Theorem
(B.1) guarantees that an algorithm exists which does this

FIG. 9. This ﬁgure contains the same data as Fig. 8, but
with the χ axis rescaled to χL, and the 1/ΓCyc axis rescaled
by (14). Hence, the linear scaling in χ, and the slight residual
system size dependence have been removed. Note the steep,
sudden dropoﬀ in lifetime after χL ∼ .03.

FIG. 10. The critical cycling rate, χc as a function of 1
L for
λ = 3, T = .07, γ(0) = .0007. Protocols were implemented in
parallel on L/2λ blocks. This scaling is consistent with the
error model ansatz in (17). Fit to 1/L in red.

(cid:88)

(cid:89)

j∈v

(cid:88)
(cid:89)

p
σx
j ,

j∈p

HTC = −Je

Av − Jm

Bp,

v
σz
j , Bp ≡

Av ≡

0.000.020.040.060.080.100.120.140.16χL0.00.10.20.30.40.50.6(Γ/ΓCycling)−1L=48L=96L=1920.0100.0150.0200.0250.0300.0350.0401/L0.00020.00040.00060.00080.00100.00120.0014χc10

FIG. 11. A single random application of the bath hopping
operator causes a defect to move between adjacent regions of
size λ. Once a pair of defects are separated by this distance,
the protocol will not be able to correct them with certainty.

in a number of steps polynomial in the dimension of the
lattice. However, this Theorem does not guarantee that
a λ-mixing protocol exists which solves the problem. In
general, for higher dimensions, there are always defect
patterns of distance O(λ) which are uncorrectable by our
λ-mixing protocol. The design strategy is then to try and
maximize this minimum uncorrectable distance by care-
ful tiling of the graph of interest.

To be more explicit, if a single pair of defects appears
on the graph, uncorrectable errors are generated only
when one of the defects escapes to an adjoining region
which does not share a boundary with its pair. A car-
toon of this process is depicted in ﬁgure Fig. 11. For
one dimension, this cannot happen in one step after an
adjacent pair of defects appears. More speciﬁcally, if a
single pair of adjacent defects appears on the lattice, no
single CSWAP will cause such an error to occur, by de-
sign, and no single bath operation will cause an adjacent
pair of defects to be in nonadjacent regions of size λ. In
one dimension, at worst a pair will be created, shuttled
around by the protocol, and then translate by a bath op-
erator across a boundary, resulting in an uncorrectable
error.

This distinction is important because poor choice of
tiling in higher dimension can result in uncorrectable er-
rors that occur in a single step after pair creation. For
example, compare the single hop in the upper half of
Fig. 12 to the lower half. A defect pair appearing at a
corner can transition to an uncorrectable conﬁguration
in a single step, whereas in the lower tiling, this is not
possible for any initial conﬁguration of adjacent defect
pairs. This can be checked by simple enumeration of the
possible defect locations and single-hop geometries.

This shifted square lattice tiling depicted in the lower

half of Figure 12 generalizes to three dimensions.

FIG. 12. A single random application of the bath hopping
operator causes a defect to move between nonintersecting re-
gions of size λ, depicted in (a) and (b). (c) depicts a new
lattice tiling where no single swap can move defects into two
λ regions which do not share a boundary.

C. Hybrid CSWAP-Stabilizer Codes

While we have demonstrated that our protocol gives
rise to an enhanced lifetime for a topological code with
string-like error operators, it is also possible and desir-
able, to use our CSWAP cycling protocol with a more
traditional stabilizer detection-correction scheme simul-
taneously. We postpone numerical analysis of such a
scheme for future work, but we sketch such a protocol
in this section.

For concreteness, we specialize here to the case of the
toric code. Error detection and correction in the toric
code requires (1) measurement of all stabilizer syndrome
operators and (2) application of a perfect-matching al-
gorithm to determine which pairs of defects to fuse.
Whether or not such an algorithm will be successful de-
pends on the density of defects at the time of measure-
ment. Given a stabilizer measurement rate γ, in the “in-
ﬁnite temperature” limit, each site is found to have a
defect with probability p, independently, except for the
ensemble requirement that the total number of defects
be even. It is well known that if p is below some critical
value, pc, it is possible to correct the errors in the toric
code with certainty. Equivalently, pc sets the minimum
rate at which measurement must occur so that detection
is possible in principle. Call this rate γc.

For the protocol to have an eﬀect, we must operate
in a regime where pair annihilation is favored over pair
creation. For simplicity, we work in the low tempera-
ture regime where single defect pairs dominate. In this
regime, an uncorrectable error has occurred when a single
pair of defects becomes separated by more than half the

..(a)(b)(c)linear lattice dimension. In the presence of the CSWAP
cycling protocol, the rate associated with such an event
occuring is modiﬁed by some constant factor:

1

ΓToric Code Cycling

= g

1

ΓToric Code

(22)

where ΓToric Code Cycling is the error rate of the toric
code in the presence of a cycling protocol, and ΓToric Code
is the error rate in the absence of the protocol.

For g > 1, i.e., when our protocol actually enhances
the lifetime of the code, this eﬀectively reduces the criti-
cal detection rate γc by the same factor. This is because
the protocol eﬀectively reduces the rate at which unde-
tectable pairs are created.

Thus, if a physical realization of a stabilizer error de-
tection/correction cycle is rate limited due to hardware
or fundamental noise constraints, the CSWAP cycling
protocol provides one avenue towards reducing the criti-
cal measurement/detection rate purely by application of
local unitaries.

VI. DISCUSSION

We have provided a dissipative error correction pro-
tocol that enhances the lifetime for models with string-
like defects. In particular, we have derived an enhanced
lifetime for the one-dimensional Ising model in the pres-
ence of our protocol, i.e. equation (14), and provided
numerical evidence for this enhancement given certain
rate assumptions. Furthermore, we have sketched how
this protocol can be generalized to higher dimensional
models like the toric code, and used in conjunction with
traditional stabilizer error detection/correction schemes.
The eﬃcacy of these sorts of protocols is intimately re-
lated to the scaling of the protocol with system size and
protocol parameters, as we have demonstrated. Notably,
the best performing versions of our protocol have small λ,
and, in a sense, only correct the shortest distance errors.
This may seem counterintuitive from the perspective of
designing protocols which correct as many errors as pos-
sible. For example, suppose we wish to compare a λ = 3
protocol with total cycle time τ to a λ = 4 protocol with
the same cycle time τ . Note that by ﬁxing total cycle
time, we are implicitly requiring that the λ = 4 protocol
be performed more quickly at the level of individual ap-
plication of CSWAPs (because there are more CSWAPs
in a complete cycle), but we require that the complete
error correcting cycle of each protocol is completed in
the same amount of time. Naively, we would expect the
λ = 4 protocol to do better, because it is dissipating er-
rors over a longer length scale, but in the same amount
of time. Fig. 7 indicates a narrow region where this is
the case, but, generically, this is not the case.

This can be traced to the poor scaling of the maximal
lifetime with λ, as represented by equation (17). Essen-
tially, the protocols which correct larger distance errors—

11

i.e., large λ-ﬁxing protocols—employ so many gates that
all of the gains of correcting longer distance errors are
erased by the time it takes to actually perform the pro-
tocol, even when implementing the protocol in parallel.
This shortfall could be circumvented by allowing for
longer range unitaries. For example, the CSWAP opera-
tor could be replaced by a generalized operator CSWAPλ
which transports domain walls over longer distances. Our
insistence on building the protocol entirely out of local
CSWAP gates was to perform as honest an analysis as
possible with respect to the power of this type of pro-
tocol. But if a particular architecture could exchange
defects over long distances just as easily as short ones,
this would immediately allow for algorithms with better
scaling. We hope to examine the optimality of these sorts
of protocols in future work.

In the long term, this program is meant to identify the
simplest possible set of ingredients necessary to provide
protection for a stabilizer code based quantum memory.
Many partial ingredients are known, like the No-Go the-
orems mentioned in Sec. I. Practically, the goal is a pro-
tocol designed around the dynamics of the excitations of
the stabilizer codes of interest with miminimal usage of
resources, but which still results in an error threshold
so that a state can be preserved indeﬁnitely. With this
work, we have demonstrated a constant factor improve-
ment with only local unitaries dressing the system.

VII. ACKNOWLEDGMENTS

This material

is based upon work supported by
DARPA under Grant No. 3854-UCB-AFOSR-0041 and
by NSF under Grant PIF-0803429. CDF was supported
by the NSF Graduate Research Fellowship under Grant
DGE-1106400.

Appendix A: Syndrome Decoding for 1D Ising

Model

The corrective operator O in Fig. 2 can be written
as a collection of conditional applications of CSWAP
and DWALL, where the applications of the operators are
conditioned on the measurements of the stabilizers. We
adopt the notation O123 to indicate the application of the
operator O on qubits 1, 2 and 3. Then, in table form, the
operator O is:

Appendix B: MATCHSEQ and Error Correction

1. Polynomial Scaling

Deﬁne the game M AT CHSEQ as follows: two non-
adjacent vertices on a simply connected graph G are col-
ored black, called defects, the rest white. The player
is allowed to perform a conditional swap, or CSWAP, on

s1 s2 s3
1
1
1
1 −1
1
1 −1 1
1 −1 −1
−1 1
1
−1 1 −1 CSWAP123DWALL234
−1 −1 1
−1 −1 −1

DWALL123

DWALL234

O
I
I
I

I

I

TABLE I. Corrective operations given certain measurements
of the stabilizers s1 through s3 in Fig. 2. If an odd number
of domain walls are detected, the identity is applied.

|M (3)| 1
|M (4)| 3
|M (5)| 6
|M (6)| 10
|M (7)| 18

TABLE II. Minimum number of CSWAPs required to neces-
sarily fuse any two defects on a linear chain with open bound-
ary conditions. Computed via breadth ﬁrst search.

any two adjacent vertices, which exchanges black vertices
and white vertices, and does nothing to pairs of white
vertices. If black vertices become adjacent, they immedi-
ate fuse and become white vertices. Crucially, the player
does not know which vertices are colored black.

“Winning” M AT CHSEQ amounts to performing a
sequence of moves which guarantees that a pair of arbi-
trarily placed vertices fuses.

Deﬁne the pairing sequence M (Gv) to be the sequence
of conditional swaps necessary to bring any conﬁgura-
tions of two defects adjacent to one another at least once
on a graph G with v vertices. Deﬁne the pairing number
|M (Gv)| to be the pairing sequence with minimal length.
Table 1 tabulates the ﬁrst few nontrivial pairing numbers
for the special case of G equal to a linear chain of length
L.

Theorem B.1. The number of CSWAPs necessary to
win M AT CHSEQ for an arbitrary ﬁnite, connected
graph G is polynomial in the number of vertices in the
graph G.

Proof: Let M∗(G) be a winning strategy on an
arbitrary graph G. Suppose an arbitrary vertex is added
to G, called v∗, with up to |G| edges. Call this modiﬁed
graph G(cid:48). Then, performing M∗(G) on G(cid:48) either fuses
two arbitrarily placed defects, or there’s a single defect
on the new vertex, and the remaining vertex has just
been permuted around in G. A candidate M (G(cid:48)) is
then:
1. Perform M∗ on G.
2. Pick a vertex, v(cid:48), on G. Supposing a defect is on v(cid:48),
perform a sequence of CSWAPs that brings that defect
adjacent to the new vertex, v∗.

12

3. Perform the reverse of the sequence of CSWAPs in
(2), and repeat (2) with a new v(cid:48).
4. Repeat (2) and (3) until all vertices in G are ex-
hausted.

The number of CSWAPs needed for step (2) is at most
|v|, i.e., the number of vertices in G. Thus, the total
complexity of steps 2 through 4 is O(|v|2). This admits
a recurrence relation:

|M (Gv+1)| ≤ |M (Gv)| + b ∗ |v|2,

(B1)

Where b is a constant ≤ 1. b = 1 corresponds to the
case that the new vertex is only connected to one vertex
in the original graph G. Solving this recurrence rela-
tion in the limit that the inequality is always saturated
yields |M (Gv)| ≤ O(|v|3). It is worth emphasizing that
this is not the minimal such solution to MATCHSEQ,
just one that is easily provably polynomial in |G|. The
likely graph structures of interest to an experimentalist,
i.e., linear chains, square lattices, admit more favorable
algorithms with softer polynomial scaling.

2. Strategies

For a given winning strategy, M∗(G), it will be con-
venient to classify the strategy based on the maximum
distance that any given defect is moved. In the sequel, we
will construct M∗(G) out of a concatenation of M∗(Gi),
where Gi are subgraphs of G. Thus, if only a single de-
fect happens to be in the subgraph Gi, we would like to
bound the maximum displacement of that defect by the
strategy.

Let d(M) be the maximum distance any given defect is
moved by a given strategy. For winning strategies, d(M)
is at least half of the maximum distance between defects
and at most permutes defects around the entire graph,
so |v| ≥ d(M) ≥ |v|/2. Deﬁne a strategy M∗(G) to be
k-mixing if d(M) = k.
We introduce this terminology because most physical
realizations of MATCHSEQ will have a background rate
of uncontrollable CSWAPs, driven by coupling to a bath.
k-mixing strategies are necessary in such cases to be par-
tially resilient to these random “error” CSWAPs.

3. Mapping onto 1D Ising Model

Vertices in the problem setup for MATCHSEQ corre-
spond to the dual lattice of the Ising chain, and the pro-
cess of fusion is simply dissipation of adjacent domain
wall pairs by the bath.

However, we caution that the mapping onto MATCH-
SEQ is only partial: defects on the Ising chain hop in the
absence of any experimental intervention, so the Ising
chain is more akin to a game of MATCHSEQ with a

13

a sequence of locations. Our convention is such that
location i indicates a CSWAP should be applied that
exchanges defects between sites i and i + 1. Heuristi-
cally, the algorithm attempts to shuﬄe defects towards
the shared boundary of the disjoint sites 0,1,2,...,λ-1 and
λ,λ+1,...,2λ-1. That is, it attempts to translate defects
so that they are adjacent to each other at sites λ−1 and λ.
After completing this cycle, the algorithm repeats for the
next two adjacent domains, λ, ..., 2λ−1 and 2λ, ..., 3λ−1.
This continues until the lattice has been exhausted.
The following python code generates a complete se-

quence of CSWAPs given a lattice size and λ length.

def SwapProtocol(L, lamb):

prot = []
if L%lamb!=0 or (L/lamb)%2!=0:

print "L,lambda mismatch. Lambda must

divide L, and quotient must be even."

FIG. 13. An example of the result of applying a winning
sequence M (G) to a graph with defect pairs present. No
matter where the defects are, the sequence of CSWAPs brings
pairs adjacent, whereupon they immediately fuse.

else:

numofdomains = L / lamb
for d in xrange(numofdomains):

for k in xrange(lamb):
for m in xrange(k):

random, background CSWAP rate. Further, there can
be more than two pair of excitations on the Ising chain,
but for low temperature, the regime where the proto-
col works best, this is exceedingly rare. Lastly, defect
pairs don’t necessarily fuse immediately–fusion happens
at the timescale set by the system-bath coupling, the type
of bath model, and the temperature, so rate at which
CSWAPs are applied must be chosen carefully for opti-
mal lifetime enhancement.

Appendix C: Algorithm for 1-D Ising Model

Here we provide python code for a λ-mixing algorithm
for the Ising chain. The output of the algorithm is

prot.append((lamb-1-k+m+d*lamb)%L)

for i in xrange(lamb):

for j in xrange(i):

prot.append((lamb+i-j-1+d*lamb)%L)

return prot

The protocol is parallelized by operating simultane-
ously on speciﬁc pairs of domains. To be more ex-
plicit: denote the ﬁrst λ sites as λ1, the next λ sites λ2
and so on. The algorithm can be naturally partitioned
into a sequence of CSWAPs that translates defects to
the shared boundary of λ1 and λ2 (call this sequence
(λ1, λ2)), followed by a sequence that translates defects
to the shared boundary between λ2 and λ3, (call this se-
quence (λ2, λ3)), etc. To parallelize, apply the sequence
(λ1, λ2) simultaneously with (λ3, λ4), (λ5, λ6), etc. When
complete, apply the sequence (λ2, λ3) with (λ4, λ5) etc.
This exhausts the protocol.

∗ daniel.freeman@berkeley.edu
1 A. G. Fowler, Physical Review Letters 109, 180502 (2012).
2 D. S. Wang, H. Centre, and Q. C. Technology,
, 1 (2009),

arXiv:arXiv:0905.0531v1.

(2009).

9 S. Chesi, B. R¨othlisberger, and D. Loss, Physical Review

A 82, 022305 (2010).

10 S. Chesi, D. Loss, S. Bravyi, and B. M. Terhal, New Jour-

3 G. Duclos-Cianci and D. Poulin, Physical Review Letters

nal of Physics 12, 025013 (2010).

104, 050504 (2010).

4 S. B. Bravyi and A. Y. Kitaev,

(1998), arXiv:9811052

[quant-ph].

11 B. Yoshida, Annals of Physics 326, 2566 (2011).
12 O. Viyuela, a. Rivas,

and M. a. Martin-Delgado, New

Journal of Physics 14, 033044 (2012).

5 A. G. Fowler, A. M. Stephens, and P. Groszkowski, Phys-

13 F. H. E. Watson and S. D. Barrett, New Journal of Physics

ical Review A 80, 052312 (2009).

16, 093045 (2014).

6 J. R. Wootton and D. Loss, Physical Review Letters 109,

14 C. D. Freeman, C. M. Herdman, D. J. Gorman, and K. B.

160503 (2012).

Whaley, Physical Review B 90, 134302 (2014).

7 C. Castelnovo and C. Chamon, Physical Review B 76,

15 B. J. Brown, D. Loss, J. K. Pachos, C. N. Self, and J. R.

184442 (2007).

Wootton,

, 1 (2014), arXiv:arXiv:1411.6643v1.

8 R. Alicki, M. Fannes,

and M. Horodecki, Journal of
Physics A: Mathematical and Theoretical 42, 065303

16 C. M. Herdman, K. C. Young, V. W. Scarola, M. Sarovar,
and K. B. Whaley, Physical Review Letters 104, 230501

(cid:1839)∗(cid:4666)(cid:1833)(cid:4667)14

(2010).

arXiv:1512.04528.

17 H. Weimer, M. M¨uller, I. Lesanovsky, P. Zoller, and H. P.

23 S. Bravyi and B. Terhal, New Journal of Physics 11,

B¨uchler, Nature Physics 6, 382 (2010).

18 J. Dengis, R. K¨onig, and F. Pastawski, New Journal of

Physics 16, 013023 (2014).

043029 (2009).

24 M. Hastings, Physical Review Letters 107, 1 (2011).
25 O. Landon-Cardinal and D. Poulin, Physical Review Let-

19 A. Hutter, J. R. Wootton, B. R¨othlisberger, and D. Loss,

ters 110, 090502 (2013).

Physical Review A 86, 052340 (2012).

20 F. L. Pedrocchi, A. Hutter, J. R. Wootton, and D. Loss,

Physical Review A 88, 062313 (2013).

21 E. Kapit, J. T. Chalker, and S. H. Simon, Phys. Rev. A

91, 62324 (2015).

26 K. Temme, (2014), arXiv:arXiv:1412.2858v1.
27 K. Temme and M. J. Kastoryano, arXiv preprint

arXiv:1505.07811 (2015).

28 D. Gottesman,
[arXiv:quant-ph].

2008

(2008),

arXiv:9705052v1

22 C.-E. Bardyn

and T. Karzig,

,

18

(2015),

29 R. J. Glauber, Journal of Mathematical Physics 4, 294

(1963).

