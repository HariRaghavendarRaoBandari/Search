Vertex Cover Structural Parameterization

Revisited(cid:63)

Fedor V. Fomin and Torstein J. F. Strømme

Department of Informatics, University of Bergen, Norway,

{fedor.fomin,torstein.stromme}@ii.uib.no

Abstract. A pseudoforest is a graph whose connected components have
at most one cycle. Let X be a pseudoforest modulator of graph G, i. e.
a vertex subset of G such that G − X is a pseudoforest. We show that
Vertex Cover admits a polynomial kernel being parameterized by
the size of the pseudoforest modulator. In other words, we provide a
polynomial time algorithm that for an input graph G and integer k,
outputs a graph G(cid:48) and integer k(cid:48), such that G(cid:48) has O(|X|12) vertices and
G has a vertex cover of size k if and only if G(cid:48) has vertex cover of size k(cid:48).
We complement our ﬁndings by proving that there is no polynomial kernel
for Vertex Cover parameterized by the size of a modulator to a mock
forest (a graph where no cycles share a vertex) unless NP ⊆ coNP/poly.
In particular, this also rules out polynomial kernels when parameterized
by the size of a modulator to outerplanar and cactus graphs.

1

Introduction

Kernelization is a fundamental algorithmic methodology rooted in parameterized
complexity. It also serves as a rigorous mathematical tool for analyzing certain
polynomial-time preprocessing or data-reductions algorithms. In this paper we
provide new kernelization algorithm for “structural” parameterization of Vertex
Cover.

In the Vertex Cover problem, we are given as input a graph G and a
positive integer k, and are asked if there exists a set S of at most k vertices in G
such that every edge in G is adjacent to at least one of the vertices in S; such an
S is called a vertex cover of G. As a part of a general program on kernelization
with structural parameterization, Jansen and Bodlaender [9] initiated the study
of kernelization for Vertex Cover with “reﬁned” parameterization by showing
that it admits a polynomial kernel when parameterized by the size of a feedback
vertex set, i.e. a forest-modulator. Since a feedback vertex set can be signiﬁcantly
smaller than a vertex cover, in various situations such a kernel can be preferable.
It is a very natural question if the kernelization result of Jansen and Bodlaender
can be extended to parameters which are “stronger” than the size of a feedback
vertex set. Forests are exactly the graphs of treewidth one and a natural direction

(cid:63) Supported by Rigorous Theory of Preprocessing, ERC Advanced Investigator Grant

267959.

6
1
0
2

 
r
a

M
2

 

 
 
]
S
D
.
s
c
[
 
 

1
v
0
7
7
0
0

.

3
0
6
1
:
v
i
X
r
a

of such an extension would be to explore the parameterization by a constant
treewidth modulator. However, as it was shown by Cygan et al. [2], for each t ≥ 2,
Vertex Cover does not admit a polynomial kernel being parameterized by
the size of the treewidth t modulator unless NP ⊆ coNP /poly. Since the result
of Cygan et al. [2] rules out polynomial kernels for Vertex Cover even when
parameterized by treewidth-2 modulators, the next natural step in the study
of polynomial kernelization for Vertex Cover is to see if the problem admits
a polynomial kernel when parameterized by a modulator to some subclasses of
graphs of treewidth 2. Towards this end, Majumdar, Raman and Saurabh [10]
obtain a polynomial kernel for Vertex Cover parameterized by the size of a
degree-2 modulator.

In this work we show that Vertex Cover admits a polynomial kernel
when the parameter is the size of a pseudoforest modulator. More precisely, a
pseudoforest is an undirected graph in which every connected component has at
most one cycle. In a graph G, a vertex set X is a pseudoforest modulator if the
graph G − X obtained from G by deleting X is a pseudoforest. We deﬁne the
following problem

Vertex Cover/Pseudoforest modulator (VC/PFM)
Input: A simple undirected graph G, a pseudoforest-modulator set X ⊆ V (G)
such that G − X is a pseudoforest, integer k.
Parameter: Size of a pseudoforest modulator |X|.
Question: Does G contain a vertex cover of size at most k?
Our results. We show that VC/PFM admits a polynomial kernel with O(|X|12)
vertices. Since every feedback vertex set is a pseudoforest-modulator and every
degree-2-modulator is also a pseudoforest-modulator, our result extends the
borders of polynomial kernelization for Vertex Cover established by Jansen
and Bodlaender [9] and by Majumdar et. al. [10].

We complement our kernelization algorithm with the lower bound. Let us
observe that the work of Cygan et al. [2] does not rule out the existence of
polynomial kernels when the problem is parameterized by the size of a modu-
lator to some proper subclass of treewidth-2 graphs, like outerplanar graphs or
cactus graphs, i. e. graphs where every 2-connected component is a cycle. We
reﬁne the known lower bounds by proving that a polynomial kernel for Ver-
tex Cover parameterized by the size of mock forest modulator would imply
NP ⊆ coNP /poly. (Mock forest is a graph with no two cycles sharing a vertex
and thus of treewidth at most 2.) Since a mock forest is also outerplanar and
cactus graph, this rules out polynomial kernels parameterized by the size of a
modulator to these classes as well.

While we state our kernelization result assuming that a pseudoforest modulator
is given as a part of the input, this condition can be omitted. There are several
approximation algorithms for pseudoforest modulator. For example, computing
a modulator to a pseudoforest is a special case of the F-Deletion problem
considered in [4], and there is a randomized constant factor approximation
algorithm of running time O(nm). Also since pseudoforests of a graph form

2

independent sets of a bicircular matroid, it follows from the generic framework of
Fujito [6] that there is a deterministic polynomial time 2-approximation algorithm
for pseudoforest modulator.

The proof of our main result is constructive and consists of several reduction
rules. While some of our steps follow Jansen and Bodlaender [9], the essential
part of the proof is diﬀerent. Our algorithm is based on a novel combinatorial
result about maximum independent sets in pseudotrees (Lemma 4), which is also
interesting in its own.

The remaining part of the paper is organized as follows. In Section 2 we give
preliminaries on notation and deﬁnitions. In Section 3 we develop the kernelization
algorithm for Vertex Cover/Pseudoforest modulator, which is the main
content of this paper. The section containing the proof of Lemma 4 is quite
technical and is found in Section 4. We obtain lower bounds for Vertex Cover
parameterized by the vertex deletion distances to mock forests.

2 Preliminaries

Graph theoretic notions.

a set S ⊆ V (G) we denote its neighborhood N (S) = ((cid:83)

In this paper we are concerned only with ﬁnite, simple, loopless, undirected
graphs. A graph G consists of a set of vertices V (G) and a set of edges E(G).
For a vertex v ∈ V (G), its neighborhood N (v) is the set of all vertices adjacent
to v. The closed neighborhood of v is denoted N [v] = N (v) ∪ {v}. Similarly, for
v∈S N (v)) \ S, and its
closed neighborhood N [S] = N (S) ∪ S. The degree of a vertex is the number
of vertices adjacent to v in the graph, deg(v) = |N (v)|. A vertex of degree 1 is
called a leaf. In cases where it may be unclear which graph is being referred to, a
subscript is added, e.g. NG(cid:48)(S) denotes the neighborhood of S in the graph G(cid:48).
A subgraph G(cid:48) ⊆ G is a graph such that V (G(cid:48)) ⊆ V (G) and E(G(cid:48)) ⊆ E(G).
For a set S ⊆ V (G), the subgraph induced by the vertices of S is denoted
G[S]. The graph where S and its incident edges are removed, is denoted as
G − S = G[V (G) \ S]. Similarly, the graph G[V (G) \ {v}] obtained by removing
a single vertex v and its incident edges is denoted G − v, and the graph obtained
by removing a subgraph G(cid:48) ⊆ G and its incident edges is denoted G − G(cid:48) =
G[V (G) \ V (G(cid:48))].
A tree T is a connected graph which contains no cycles. A tree is rooted if one
vertex r ∈ V (T ) has been designated as the root. In rooted trees, all vertices have
a natural orientation with respect to the root. For a non-leaf vertex a ∈ V (T ) we
denote the set of its children by C(a). For two vertices a, b ∈ V (T ), we say that
a is an ancestor of b if a is on the path from r to b (by this deﬁnition, a vertex is
always an ancestor of itself). We let the subtree rooted at the vertex a be denoted
by Ta = T [{b | a is an ancestor of b}]. A subtree Ta is a strict subtree if T (cid:54)= Ta,
in other words if a (cid:54)= r. A graph F is a forest if every connected component of F
is a tree.
An independent set of G is a set I ⊆ V (G) such that every edge of G has
at most one endpoint in I. We let α(G) denote the independence number of G,

3

i. e. the largest number of distinct vertices which can constitute an independent
set of G. An independent set I of G with size |I| = α(G) is called a maximum
independent set, abbreviated MIS.
A feedback vertex set (FVS) of G is a set X ⊆ V (G) such that G − X is a

forest. A graph G is a mock forest if no cycles of G share a vertex.

Kernels and reductions.

Deﬁnition 1 (Kernelization, kernel). A kernelization algorithm, or simply
a kernel, for a parameterized problem Q is an algorithm A that, given an instance
(I, k) of Q, works in polynomial time and returns an equivalent instance (I(cid:48), k(cid:48))
of Q. Moreover, we require that k(cid:48) + |I(cid:48)| ≤ g(k) for some computable function
g : N → N.
If the upper bound g(·) is a polynomial function of the parameter, then we say
that Q admits a polynomial kernel .

3 Kernelization

This section contains the kernelization of Vertex Cover/Pseudoforest
modulator and is the main section of the paper. We will ﬁrst develop a kernel
for Independent Set/Pseudoforest modulator, and then by the immediate
correspondence between the Vertex Cover and Independent Set problems
the kernel for VC/PFM will follow. For the remainder of this section, we will
thus focus on the Independent Set/Pseudoforest modulator problem:

Independent Set/Pseudoforest modulator (IS/PFM)
Input: A simple undirected graph G, a pseudoforest-modulator set X ⊆ V (G)
such that G − X is a pseudoforest, integer k.
Parameter: Size of a pseudoforest modulator |X|.
Question: Does G contain an independent set of size at least k?
Throughout the section, let F := G − X be the induced subgraph remaining
after the modulator X has been removed from G. Note that F is a pseudoforest.
We say that (G, X, k) is a yes-instance of IS/PFM if there exists an inde-
pendent set I of G such that |I| ≥ k. We say it is a no-instance if there is no
such set.
Deﬁnition 2. (Conﬂicts) Let (G, X, k) be an instance of IS/PFM where F (cid:48) ⊆
F is a subgraph of the pseudoforest F and X(cid:48) ⊆ X is a subset of the modulator X.
Then the number of conﬂicts induced by X(cid:48) on F (cid:48) is deﬁned as ConfF (cid:48)(X(cid:48)) :=
α(F (cid:48)) − α(F (cid:48) − NG(X(cid:48))).

Choosing X(cid:48) to be in the independent set I of G may prevent some vertices in
F (cid:48) from being included in same set I. In particular, no vertex v ∈ V (F (cid:48))∩NG(X(cid:48))
can be chosen to be in I. In light of this, the term ConfF (cid:48)(X(cid:48)) can be understood
as the price one has to pay in F (cid:48) by choosing to include X(cid:48) in the independent
set.
Observe that ConfF (cid:48)(X(cid:48)) is polynomial time computable when the indepen-
dence number α(F (cid:48)) is.

4

Fig. 1: Conﬂicts: In the ﬁgure, we observe that α(F (cid:48)) = 3, and α(F (cid:48)−NG(X(cid:48))) = 1.
Hence, we get that ConfF (cid:48)(X(cid:48)) = 2. In other words, the number of conﬂicts
induced by X(cid:48) on F (cid:48) is 2.

Deﬁnition 3. (Chunks) Let (G, X, k) be an instance of IS/PFM. A set X(cid:48) ⊆ X
is a chunk if the following hold:
– X(cid:48) is independent in G,
– The size of X is between 1 and 3, i. e. 1 ≤ |X| ≤ 3, and
– The number of conﬂicts induced by X(cid:48) on the pseudoforest F is less than

|X|, i. e. ConfF (X(cid:48)) < |X|.

We let X be the collection of all chunks of X.

The collection of chunks X can be seen as all suitable candidate subsets of
size at most 3 from X to be included in a maximum independent set I for G.
The idea is that I may contain a chunk as a subset, but need not include a subset
X(cid:48) ⊆ X of size at most 3 which is not a chunk. This will allow us to discard
potential solutions containing non-chunk subsets of X with size at most 3. In
order for this intuition to hold, we provide the following lemma, originally by
Jansen and Bodlaender [9, Lemma 2] though slightly altered to ﬁt our purposes.

Lemma 1. If there exists an independent set of size k in G, then there exists
an independent set I of G such that |I| ≥ k and for all subsets X(cid:48) ⊆ X ∩ I,
ConfF (X(cid:48)) < |X|.
Proof. Assume that I(cid:48) ⊆ V (G) is an independent set for which there exists some
X(cid:48) ⊆ I(cid:48) ∩ X such that CON FF (X(cid:48)) ≥ |X|. We will show that then there is also
another independent set I such that |I| ≥ |I(cid:48)| and for all subsets X(cid:48)(cid:48) ⊆ X with
CON FF (X(cid:48)(cid:48)) ≥ |X|, X(cid:48)(cid:48) is not a subset of I.
Because CON FF (X(cid:48)) ≥ |X|, we have that α(F ) ≥ |X| + α(F − NG(X(cid:48))).
Now consider the independent set I(cid:48). Some of its vertices are in X, however no
more than |X|. The remainder of vertices of I(cid:48) are in V (F ), however no more
than α(F − NG(X(cid:48))). Thus |X| + α(F − NG(X(cid:48))) ≥ |I(cid:48)|. But then α(F ) ≥ |I(cid:48)|,
and we see that a MIS of the pseudoforest F satisﬁes the requirements of the
lemma.

Deﬁnition 4. (Anchor triangle) Let (G, X, k) be an instance of IS/PFM. Let
P be a connected component in F with V (P ) = {p1, p2, p3}. Then P is an anchor
triangle if there exists a set {x1, x2, x3} ⊆ X such that:
– NG(p1) = {p2, p3, x1}

5

FXX(cid:48)F(cid:48)– NG(p2) = {p1, p3, x2}
– NG(p3) = {p1, p2, x3}

An anchor triangle is non-redundant if there is no other anchor triangle with the
same open neighborhood in G.

Fig. 2: The connected component P ⊆ F with vertices V (P ) = {p1, p2, p3} is an
anchor triangle for the triple {x1, x2, x3} ⊆ X.
Deﬁnition 5. (Unnecessary triple) A triple 3X ⊆ X is said to be unnecessary
if there exists an anchor triangle P such that NG(P ) = 3X.

The fact that a triple 3X ⊆ X is unnecessary as deﬁned above should
intuitively be understood with respect to constructing an independent set. If a
triple 3X is unnecessary then there exists a MIS which does not contain all of
3X. This intuition is supported by the next lemma.

Lemma 2. Let (G, X, k) be an instance of IS/PFM. If there exists an indepen-
dent set of size at least k in G, then there exists an independent set I of G with
|I| ≥ k containing no unnecessary triple 3X ⊆ X.

Proof. We will prove the lemma by constructing the required independent set I
satisfying the properties, assuming we have an arbitrary independent set I(cid:48) of
size at least k. By deﬁnition, for each unnecessary triple 3X ⊆ X ∩ I(cid:48), there is
at least one anchor triangle P ⊆ F such that NG(P ) = 3X. Since 3X ⊆ I(cid:48), we
have that no vertex of P is in I(cid:48). Let pu ∈ V (P ) be an arbitrary vertex of P ,
and let u ∈ 3X be the neighbor of pu in 3X. Observe that we can here replace u
by pu in I(cid:48), and still have I(cid:48) be an independent set of the same size. We do this
for every unnecessary triple 3X ⊆ X ∩ I(cid:48) to obtain I, which then satisﬁes the
requirement of the lemma.

3.1 Reduction Rules

We introduce here the reduction rules. Each reduction receives as input an
instance (G, X, k) of Independent Set/Pseudoforest modulator, and
outputs an equivalent instance (G(cid:48), X(cid:48), k(cid:48)). A reduction is safe if the input and
output instances are equivalent, that is, (G, X, k) is a yes-instance if and only

6

p1p2p3x1x2x3FXif (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance. Reductions 1, 2 and 4 originates in [9], though
Reduction 4 is altered to ﬁt the context of a pseudoforest, which also required
some changes to the proof.

Reduction rules will be applied exhaustively starting with lower number rules,
until Reduction 4 is no longer applicable. During this process, a lower number
rule is always applied before a higher number rule if at any point they are both
applicable. Then Reductions 5 and 6 will be applied once each to obtain the ﬁnal
reduced instance. Note that each reduction is computable in polynomial time.
Reduction 1. If there is a vertex v ∈ X such that ConfF ({v}) ≥ |X|, then
delete v from the graph G and from the set X. We let G(cid:48) := G − v, X(cid:48) := X − v
and k(cid:48) := k.
Reduction 2. If there are distinct vertices u, v ∈ X with uv /∈ E(G) for which
ConfF ({u, v}) ≥ |X|, then add edge uv to G. We let G(cid:48) := (V (G), E(G)∪{uv}),
X(cid:48) := X and k(cid:48) := k.

Reductions 1 and 2 are safe due to Lemma 1.

Reduction 3. If there are distinct u, v, w ∈ X such that ConfF ({u, v, w}) ≥
|X|, the set {u, v, w} is independent in G, and for which there is no anchor
triangle P with N (P ) = {u, v, w}, then add an anchor triangle P (cid:48) = {pu, pv, pw}
to the graph such that N (P (cid:48)) = {u, v, w}, and increase k by one. Let V (G(cid:48)) :=
V (G) ∪ {pu, pv, pw} and let E(G(cid:48)) := E(G) ∪ {pupv, pupw, pvpw, puu, pvv, pww}).
Further, let X(cid:48) := X and let k(cid:48) := k + 1.

Fig. 3: Reduction 3: Adding an anchor triangle to the independent triple {u, v, w}
(k(cid:48) = k + 1). This makes {u, v, w} an unnecessary triple in the output instance.
Note that Reduction 3 makes the triple {u, v, w} ⊆ X unnecessary in the reduced
instance as deﬁned in Deﬁnition 5.

Lemma 3. Reduction 3 is safe. Let (G, X, k) be an instance of IS/PFM to
which Reduction 3 is applicable, and let (G(cid:48), X(cid:48), k(cid:48)) be the reduced instance. Then
(G, X, k) is a yes-instance if and only if (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance.

Proof. For the forward direction of the proof, assume (G, X, k) is a yes-instance,
let u, v, w ∈ X be the elements which triggers the reduction, and let P (cid:48) =
{pu, pv, pw} be the vertices of the added anchor triangle in the reduced instance.
Let I be an independent set of G with |I| ≥ k. By Lemma 1, we assume that

7

uvwFXpupwpvuvwF(cid:48)X(cid:48)at least one of u, v, w is not in I. Without loss of generality, let u /∈ I. For the
reduced instance, observe that I(cid:48) := I ∪ {pu} is an independent set of G(cid:48) with
size |I(cid:48)| = |I| + 1 ≥ k + 1 = k(cid:48), which makes (G(cid:48), X(cid:48), k(cid:48)) a yes-instance.
For the backward direction, assume that (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance, and
let P (cid:48) be the added anchor triangle in the reduced instance. Let I(cid:48) be an
independent set of G(cid:48) with |I(cid:48)| ≥ k(cid:48). Because P (cid:48) induces a triangle in G(cid:48), at
most one vertex of P (cid:48) is in I(cid:48). Thus, I := I(cid:48) \ P (cid:48) is an independent set of G with
|I| ≥ |I(cid:48)| − 1 ≥ k(cid:48) − 1 = k, which makes (G, X, k) a yes-instance.

Reduction 4. If there exists a connected component P in F which is not a
non-redundant anchor triangle, and for every chunk X(cid:48) ∈ X there is no conﬂicts
induced by X(cid:48) on P , i.e. ConfP (X(cid:48)) = 0, then remove P from G and reduce k
by α(P ). We let G(cid:48) := G − P , X(cid:48) := X and k(cid:48) := k − α(P ).

To prove that Reduction 4 is safe, we will rely on the following lemma, which
states that any pseudotree has a small (at most size three) obstruction in terms
of obtaining a maximum independent set.

Lemma 4. Let P be a pseudotree and let Z be a set of vertices such that α(P ) >
α(P −Z). Then there exist three (possibly non-distinct) vertices u, v, w ∈ Z∩V (P )
such that α(P ) > α(P − {u, v, w}).

The proof of the above lemma is quite technical, and is postponed till Section 4
in order to preserve the ﬂow of the kernelization algorithm. Taking Lemma 4 as
a black box, we are able to make the following observation:
Observation 1. Let P ⊆ F be a connected component in the pseudoforest F
and let X(cid:48) ⊆ X be an independent set such that ConfP (X(cid:48)) > 0. Then there
exists some X(cid:48)(cid:48) ⊆ X(cid:48) with 1 ≤ |X(cid:48)(cid:48)| ≤ 3 such that ConfP (X(cid:48)(cid:48)) > 0.

We see that the observation is true, since by Lemma 4 there exist u, v, w ∈
NG(X(cid:48))∩ V (P ) such that α(P ) > α(P −{u, v, w}). Then for each element u, v, w,
pick an arbitrary neighbor xu, xv, xw ∈ X(cid:48) (they need not be distinct) to form
the set X(cid:48)(cid:48) := {xu, xv, xw}. See that then ConfP (X(cid:48)(cid:48)) > 0. We are now equipped
to prove safeness of Reduction 4.

Lemma 5. Reduction 4 is safe. Let (G, X, k) be an instance of IS/PFM to
which Reduction 4 is applicable, and let (G(cid:48), X(cid:48), k(cid:48)) be the reduced instance. Then
(G, X, k) is a yes-instance if and only if (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance.
Proof. Let P ⊆ F be the connected component which triggered the reduction.
For the forward direction of the proof, assume (G, X, k) is a yes-instance and
let I be an independent set of G with size at least k. Let I(cid:48) := I \ V (P ). Clearly
I(cid:48) is an independent set of G(cid:48). Now observe that |I ∩ V (P )| ≤ α(P ), and thus
|I(cid:48)| = |I| − |I ∩ V (P )| ≥ k − α(P ) = k(cid:48). Hence (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance.
For the backward direction, we assume that (G(cid:48), X(cid:48), k(cid:48)) is a yes-instance,
and has an independent set I(cid:48) of size at least k(cid:48). Because of Lemma 2 we can
assume that I(cid:48) contains no unnecessary triples 3X ⊆ X(cid:48) ∩ I(cid:48). We want to show

8

that we can always pick some independent set IP ⊆ V (P ) with |IP| = α(P )
such that I := I(cid:48) ∪ IP is an independent set with size at least k(cid:48) + α(P ) = k.
Since I(cid:48) and V (P ) are disjoint in G by construction, it will suﬃce to show that
α(P − NG(I(cid:48))) ≥ α(P ).
Assume for the sake of contradiction that α(P − NG(I(cid:48))) < α(P ). Since P
was a connected component in F , all its neighbors NG(P ) are in X. Thus we
have that ConfP (X(cid:48) ∩ I(cid:48)) > 0. By Observation 1, we further have that there
exists some X(cid:48)(cid:48) ⊆ X(cid:48) ∩ I(cid:48) such that 1 ≤ |X(cid:48)(cid:48)| ≤ 3 and ConfP (X(cid:48)(cid:48)) > 0.
For any such X(cid:48)(cid:48), there are two cases. In the ﬁrst case, ConfF (X(cid:48)(cid:48)) < |X|.
Because X(cid:48)(cid:48) is also independent and has size at most 3, it is a chunk of X in the
input instance. This contradicts the preconditions for Reduction 4, so this case
can not happen.
In the second case, ConfF (X(cid:48)(cid:48)) ≥ |X|. But then one of Reductions 1, 2 or 3
would have previously been applied to X(cid:48)(cid:48), yielding it either unfeasible for an
independent set or making it an unnecessary triple in the input instance. Because
non-redundant anchor triangles are not chosen for removal by Reduction 4, X(cid:48)(cid:48)
is also an unnecessary triple in the output instance, which contradicts that I(cid:48)
(cid:117)(cid:116)
contains no unnecessary triples. This concludes the proof.
Notice that Reduction 4 will remove connected components from F . When
the reduction is not applicable, we should then be able to give some bound on
the number of connected components in F . The next lemma gives such a bound:
Lemma 6. Let (G, X, k) be an instance of IS/PFM which is irreducible with
respect to Reductions 1, 2, 3 and 4. Let CF denote the set of all connected
components P ⊆ F . Then |CF| ≤ |X|4 + |X|3, i.e. the number of connected
components in F is at most |X|4 + |X|3.
Proof. Let AF denote the set of all non-redundant anchor triangles in F . Consider
the bipartite graph B between the chunks X and connected components CF where
there is an edge between X(cid:48) ∈ X and P ∈ CF if and only if CON FP (X(cid:48)) > 0.
Because Reduction 4 is not applicable, every connected component P ∈ CF will
have at least one edge incident to it in B, unless the component is a non-redundant
anchor triangle. Thus any bound on the number of edges in B will also be a
bound for |CF| − |AF|.
By the deﬁnition of chunks, we know that for every X(cid:48) ∈ X , CON FF (X(cid:48)) <
|X|. Since conﬂicts induced by X(cid:48) on F in diﬀerent connected components of
F are distinct, each X(cid:48) ∈ X is incident to less than |X| connected components
in B. Since |X| ≤ |X|3, we get that |CF| − |AF| ≤ |X|4. It remains to show
that |AF| ≤ |X|3 to conclude the proof. This can be veriﬁed by observing that
every anchor triangle has a neighborhood in X of size exactly 3. If two anchor
triangles had the same neighborhood in G (and hence in X), they would not be
non-redundant, so there is at most one non-redundant anchor triangle for each
distinct triple of X. Observe that the number of such distinct triples is less than
|X|3.

When the above reduction rules have been exhaustively applied, the next two

reductions will be executed exactly once each.

9

Reduction 5. Let ˆX ⊆ V (F ) be a set such that ˆX contains exactly one vertex
of each cycle in F . In the reduced graph, let G(cid:48) := G, X(cid:48) := X ∪ ˆX, and k(cid:48) := k.

The reduction is safe because neither G nor k was changed. Observe that X
is now a feedback vertex set (which is ﬁne, since every feedback vertex set is
also a modulator to pseudoforest). This reduction may increase the size of X
dramatically. This is why the Reduction is applied only once, such that we can
give guarantees for the size of the reduced instance.
Observation 2. Let (G(cid:48), X(cid:48), k(cid:48)) be an instance of IS/PFM after Reduction 5
have been applied to (G, X, k). Then X(cid:48) ≤ |X|4 + |X|3 + |X|.

After Reduction 5 has been applied once, the returned instance (G, X, k) is
ready for the ﬁnal reduction step. Note that since X is now a feedback vertex
set, (G, X, k) is now an instance of Independent Set/Feedback Vertex
Set as well, and we can for the ﬁnal reduction apply the kernel of Jansen and
Bodlaender.

Independent Set/Feedback Vertex Set (IS/FVS)
Input: A simple undirected graph G, a feedback vertex set X ⊆ V (G), integer
k.
Parameter: Size of the feedback vertex set |X|.
Question: Does G contain an independence set of size at least k?

Proposition 1 ([9, Theorem 2]). Independent Set/Feedback Vertex
Set has a kernel with a cubic number of vertices: There is a polynomial-time
algorithm that transforms an instance (G, X, k) into an equivalent instance
(G(cid:48), X(cid:48), k(cid:48)) such that |X(cid:48)| ≤ 2|X|, and |V (G(cid:48))| ≤ 56|X|3 + 28|X|2 + 2|X|.
Reduction 6. Let the output instance (G(cid:48), X(cid:48), k(cid:48)) be the reduced instance after
applying Proposition 1. This reduction is applied once only.

3.2 Bound on size of reduced instances

When no reduction rules can be applied to an instance, we call it reduced. In this
section we will prove that the number of vertices in a reduced instance (G(cid:48), X(cid:48), k(cid:48))
is at most O(|X|12) where |X| is the size of the modulator in the original problem
(G, X, k).

Theorem 1. Independent Set/Pseudoforest modulator admits a kernel
with O(|X|12) vertices.

Proof. In order to prove the theorem, we show that where is a polynomial
time algorithm that transforms an instance (G, X, k) to an equivalent instance
(G(cid:48), X(cid:48), k(cid:48)) such that
– |V (G(cid:48))| ≤ 56(|X|4+|X|3+|X|)3+28(|X|4+|X|3+|X|)2+2(|X|4+|X|3+|X|),
– |X(cid:48)| ≤ 2|X|4 + 2|X|3 + 2|X|, and

10

– k(cid:48) ≤ k + |X|3.
We will begin with the proof that k(cid:48) ≤ k + |X|3. The only transformation which
increase k is Reduction 3, which rise k by 1 each time it is applied. However, this
transformation will be done less than |X|3 times, since the rule will be applied
at most once for each distinct triple of X.
Next, we focus on the bound |X(cid:48)| ≤ 2|X|4 + 2|X|3 + 2|X|. The only trans-
formations which increase |X| are Reductions 5 and 6, which are applied only
once each. By Observation 2 we then have that |X(cid:48)| ≤ |X|4 + |X|3 + |X| after
applying Reduction 5, and by Proposition 1 we have that the size is at most
doubled after applying Reduction 6. Thus the bound holds.
For the bound on V (G), let us consider the instance of IS/FVS (G(cid:48)(cid:48), X(cid:48)(cid:48), k(cid:48)(cid:48))
to which Reduction 6 was applied in order to obtain the ﬁnal reduced instance
(G(cid:48), X(cid:48), k(cid:48)). We have already established that |X(cid:48)(cid:48)| ≤ |X|4 +|X|3 +|X|. It follows
from Proposition 1 that in the reduced instance, |V (G(cid:48))| ≤ 2|X(cid:48)(cid:48)| + 28|X(cid:48)(cid:48)|2 +
56|X(cid:48)(cid:48)|3, which in terms of |X| yields |V (G(cid:48))| ≤ 56(|X|4 +|X|3 +|X|)3 +28(|X|4 +
|X|3 + |X|)2 + 2(|X|4 + |X|3 + |X|).
(cid:117)(cid:116)

Finally, observe that each reduction can be done in polynomial time.

Corollary 1. Vertex Cover/Pseudoforest modulator admits a kernel
with O(|X|12) vertices.

4 Proof of Lemma 4

In this section we prove Lemma 4. Our starting point will be the following result
by Jansen and Bodlaender [8, Lemma 4], rephrased here in terms of a vertex set
Z:
Proposition 2. Let T be a tree, and let Z be a set of vertices. If α(T ) > α(T−Z),
then there exist two (possibly non-distinct) vertices u, v ∈ Z ∩ V (T ) such that
α(T ) > α(T − {u, v}).

We also need to establish a framework for reasoning about independent sets in
trees which rely on whether a vertex is α-critical or not. We will use the following
deﬁnition:

Deﬁnition 6 (α-critical). Let G be a graph, and let v be a vertex. If v is in
every maximum independent set of G, i. e. α(G) = 1 + α(G − v), then v is
α-critical in G.

Observation 3. Let G be a graph and let v be a vertex in G. Then v is an
α-critical vertex of G if and only if α(G − v) = α(G − N [v]).

Lemma 7. Let T be a tree rooted at r. Then r is α-critical in T if and only if a
is not α-critical in Ta for all children a of r.

11

a∈C(r) α(Ta) ≥ 1 +(cid:80)

is a tree rooted at r, we have that α(T − r) =(cid:80)
(cid:80)
Proof. For the forward direction of the proof, assume r is α-critical in T . Since T
a∈C(r) α(Ta) and α(T − N [r]) =
a∈C(r) α(Ta − a).
Assume for the sake of contradiction that there is some a(cid:48) ∈ C(r) such that
conclude that(cid:80)
a(cid:48) is α-critical in Ta(cid:48). Then we have α(Ta(cid:48)) = 1 + α(Ta(cid:48) − a(cid:48)), which lead us to
a∈C(r) α(Ta − a). This contradicts that r
(cid:80)

is α-critical in T by Observation 3.
For the backward direction of the proof, assume that for all children a of
r, a is not α-critical for Ta. Seeing that T is a tree, we recall that α(T − r) =
a∈N (r) α(Ta). Adding the single vertex r back will increase the independence
number by at most one. It remains to show that it also increase by at least one
to conclude the proof. But this can be done by picking a maximum independent
set in T − r which avoids all of C(r), and then include r. Note that such a set
exists by the initial assumption that no child a of r is α-critical for Ta.

Fig. 4: Lemma 7: Let T be a tree rooted at r. A vertex a ∈ V (T ) is marked with
orange stripes if a it is α-critical in the subtree Ta. Then a is α-critical if and
only if, for all its children b ∈ C(a), b is not α-critical in Tb.

Observation 4. Let G be a graph and let a be an α-critical vertex of G. If there
is a set of vertices Z such that a is not α-critical in G− Z, then α(G) > α(G− Z).

Observation 5. Let T be a tree rooted at r, and let Z be a set of vertices. Then
the following holds:

– If r is α-critical in T − Z, then α(T − Z) = 1 +(cid:80)
particular, if r is α-critical in T then α(T ) = 1 +(cid:80)
– If r is not α-critical in T − Z, then α(T − Z) = (cid:80)
particular, if r is not α-critical in T then α(T ) =(cid:80)

a∈C(r) α(Ta − Z). In
a∈C(r) α(Ta − Z). In

a∈C(r) α(Ta).

a∈C(r) α(Ta).

Armed with Proposition 2 and the framework for reasoning about independent

sets in trees presented above, we are now prepared to show the next lemma:

Lemma 8. Let T be a tree rooted at r, and let Z be a set of vertices. Then the
following holds:

12

r(a) If α(T ) > α(T − Z) and r is α-critical in T , then either

(i) There exist two (possibly non-distinct) vertices u, v ∈ Z ∩ V (T ) such that
(ii) There exists a vertex u ∈ Z ∩ V (T ) such that α(T ) > α(T − u) and r is
(b) If α(T ) = α(T − Z) and r is α-critical in T − Z but not in T , then there

α(T ) > α(T − {u, v}) and r is still α-critical in T − {u, v}.
not α-critical in T − u.

exists a vertex u ∈ Z ∩ V (T ) such that r is α-critical in T − u.

Proof. The proof is done by strong induction on the height of the tree, where we
will go two levels deep. For the base case we consider trees of height 0 and 1, i. e.
the single vertex and stars rooted at the center vertex. In both cases, it is easy to
verify that the lemma holds. For the inductive step, we let T be a tree rooted in
r. By the induction hypothesis we assume the lemma holds for all strict subtrees
of T , as these have all strictly smaller height than T . We will now show each
part of the lemma separately.
Part (a). We assume that α(T ) > α(T − Z), and that r is α-critical in T .
First consider the case when r ∈ Z. Then just pick u := r to meet the requirement
for (ii). Thus, for the remainder of the case we can assume r /∈ Z. By Lemma 7,
we can also assume that there is no child a of r such that a is α-critical in Ta.
We will now consider two cases.
Case 1. This case applies if there is no child a of r such that α(Ta) > α(Ta−Z).
Then there must exist at least one child a(cid:48) of r such that a(cid:48) is α-critical in Ta(cid:48) − Z,
or else there is a contradiction with the assumption that α(T ) > α(T − Z). Hence
we can apply the induction hypothesis (b) to Ta(cid:48) and ﬁnd that there exists a
vertex u ∈ Z ∩ V (Ta(cid:48)) such that a(cid:48) is α-critical in Ta(cid:48) − u. Observe that by
Lemma 7, r is not α-critical in T − u. Further applying Observation 5 to ﬁnd
that α(T ) > α(T − u), we see that we have met the requirement of (ii).
Case 2. This case applies if there exists a child a of r such that α(Ta) >
α(Ta − Z). Before we proceed further, we want to establish that there must exist
some child b(cid:48) of a such that α(Tb(cid:48)) > α(Tb(cid:48) − Z). For the sake of contradiction,
b∈C(a) α(Tb − Z). Because a is not α-
b∈C(a) α(Tb) by Observation 5.
b∈C(a) α(Tb − Z) ≤ α(Ta − Z). Combining the above, we obtain
α(Ta) ≤ α(Ta − Z), which contradicts the initial assumption of this case. Thus
for the remainder of the case we can assume there is at least one child b(cid:48) of a
such that α(Tb(cid:48)) > α(Tb(cid:48) − Z). By Lemma 7, we also have that there exists at
least one child b(cid:48)(cid:48) of a which is α-critical in Tb(cid:48)(cid:48) . Now we will again distinguish
between two diﬀerent cases:
Subcase 2.1. This subcase applies if there exist two distinct children b and
b(cid:48) of a such that α(Tb) > α(Tb − Z) and b(cid:48) is α-critical in Tb(cid:48). By Lemma 2,
there exist u, v ∈ Z ∩ V (Tb) such that α(Tb) > α(Tb − {u, v}). Note that a is not
α-critical in Ta − {u, v} by Lemma 7 because b(cid:48) is α-critical in Tb(cid:48) − {u, v} (Tb(cid:48)
is untouched by u, v). In order to meet the requirements of (i), we will proceed
to show that α(Ta) > α(Ta − {u, v}).

assume there is not, i. e.(cid:80)
critical in Ta by Lemma 7, we have that α(Ta) =(cid:80)
Now note that(cid:80)

To show this, we use Observation 5 to ﬁnd that α(Ta) =(cid:80)
α(Ta−{u, v}) =(cid:80)

b(cid:48)(cid:48)∈C(a) α(Tb(cid:48)(cid:48) ) and
b(cid:48)(cid:48)∈C(a) α(Tb(cid:48)(cid:48) −{u, v}). Because there exists a child b of a such

b∈C(a) α(Tb) =(cid:80)

13

that α(Tb) > α(Tb −{u, v}), it then follows that α(Ta) > α(Ta −{u, v}). Because
a is not α-critical in Ta − {u, v} and the siblings of a are untouched by u, v, it
follows that r is α-critical by Lemma 7. By symmetric reasoning as above but
using T and r rather than Ta and a, we conclude that also α(T ) > α(T − {u, v}),
thus obtaining the requirements for (i).
Subcase 2.2. This subcase applies if there is exactly one child b of a which
is α-critical in Tb, and this is the only child of a for which α(Tb) > α(Tb − Z).
The vertex a may have other children besides b, but for all of these children
b(cid:48) ∈ C(a) \ {b}, we have that b(cid:48) is not α-critical in Tb(cid:48) and α(Tb(cid:48)) = α(Tb(cid:48) − Z).
By the induction hypothesis (a) there are two cases:
– There exist two (possibly non-distinct) vertices u, v ∈ Z ∩ V (Tb) such that
α(Tb) > α(Tb−{u, v}) and b is α-critical in Tb−{u, v}. This case leaves a not
α-critical in Ta − {u, v}, and yields α(Ta) > α(Ta − {u, v}). By an analogous
argument to that of the previous subcase, we obtain the requirements for (i).
– There exists u ∈ Z ∩ V (Tb) such that α(Tb) > α(Tb − u), and such that b is
not α-critical in Tb − u. In this case, a is α-critical in Ta − u. This, however,
in turn yields r not α-critical in T − u, which must reduce the independence
number of T by Observation 4. Thus, we have obtained the requirement for
(ii).

We have now exhausted all possibilities, and in each case obtained the
requirements for either (i) or (ii). This concludes the proof for part (a).
Part (b). We assume that α(T ) = α(T − Z) and that r is α-critical in
T − Z, but not in T . By Lemma 7, we know that r is α-critical in T − Z if and
only if no child a of r is α-critical in Ta − Z. If there are two or more children
which are α-critical in their respective subtrees before forbidding Z, we note that
α(T ) > α(T − Z) by Observations 4 and 5, contradicting the premise of part (b)
in the lemma. Thus there is exactly one child a of r which is α-critical in Ta,
and for all other children a(cid:48) of r it holds that a(cid:48) is not α-critical in neither Ta(cid:48)
nor Ta(cid:48) − Z, as this would contradict either that α(T ) = α(T − Z) or that r is
α-critical in T − Z.

Subcase 2.1

Subcase 2.2

Fig. 5: Proof of Lemma 8 (a), Case 2: Orange stripes indicates that the vertex is
α-critical in the subtree rooted at that vertex. Subtrees where α(Ta) > α(Ta − Z)
are drawn with a red color.

14

rab(cid:48)TbbraTbbBy Observation 4, we know that α(Ta) > α(Ta − Z). By the induction
hypothesis (a), there are two possibilities; either (i) is true for Ta, and there exist
vertices u, v ∈ Z such that α(Ta) > α(Ta − {u, v}) and so that a is α-critical in
Ta − {u, v}. That, however, would contradict the premise that α(T ) = α(T − Z).
We may then assume that only (ii) is true, and that there exists a vertex
u ∈ Z ∩ V (Ta) such that α(Ta) > α(Ta − u) and which leave a not α-critical in
Ta − u. See that this choice of u will also leave r α-critical in T − u, concluding
the proof for part (b).

We will now move on to pseudotrees, i. e. graphs which contains at most one
cycle, and study how maximum independent sets behave in them when a set Z
of vertices forbidden to be included in any independent set is introduced. We can
view a pseudotree P as a cycle C with rooted trees being attached to vertices of
C (if there is no cycle, P is a tree and behaves accordingly). A vertex in C may
have zero, one or several trees being attached to it. Every non-cycle vertex with
a neighbor in C is the root r of a tree T attached to the cycle. Formally, we use
this deﬁnition:

Deﬁnition 7 (Attached tree). Let P be a pseudotree which contains a cycle
C ⊆ P . Each connected component T of P − C is then an attached tree of C.
Further, let c ∈ V (C) and r ∈ V (T ) be the two vertices such that cr ∈ E(P )
(there is a unique pair with this property since P is a pseudotree). Then r is
designated as the root of T , and c is the attachment point vertex for T . We say
that c has an attached tree T , and that T is attached to C at c.

Fig. 6: Attached tree: A pseudotree consists of a cycle C and attached subtrees.
We say that the attached tree T1 is rooted at r1, and is attached to C at its
attachment point vertex ci. The cycle vertex cj has two attached trees, T2 and
T3.

In building a maximum independent set I for a pseudotree P , each attached
tree is faced with two possibilities; either their attachment point vertex c ∈ C is
in I, or it is not. In some cases, c being in I may reduce the number of vertices

15

cicjT1r1T2r2T3r3Cavailable to pick in a tree T attached to c, since the root r of T is forbidden in I
due to it being a neighbor of c. In cases like this, we observe that it is always at
least as good to let c be left outside I and rather pick the larger independent set
from T . This motivates distinguishing between trees where the root is α-critical
in the tree from those where it is not.

With this in mind, we observe that the following greedy strategy for ﬁnding
a MIS in a pseudotree P is correct: First, pick a MIS in every tree T attached
to C which avoids the root r of T unless r is α-critical in T . Next, ﬁnd a MIS
for the cycle C which avoids any c ∈ C which has an attached tree T where the
root r is α-critical in T . The union of found independent sets will be a MIS for
P . We can easily extend this algorithm to also avoid a set Z of vertices:

Algorithm 1 (Greedy MIS for pseudotree avoiding Z). Input: A pseu-
dotree P and a set of vertices Z. Output: A maximum independent set I of
P − Z.

1. If P contain no cycle C, then return the MIS of P avoiding Z.
2. Let Z(cid:48) := ∅. This set is for cycle vertices which will be marked as forbidden
due to α-criticalness of roots in attached subtrees.
3. For every tree T0, T1,··· , Tt attached to the cycle C, let ri be the root of Ti
and let ci ∈ C be the attachment point vertex for Ti. Then for i ∈ {1, 2,··· , t},
do the following:
(a) Let ITi be a MIS for Ti − Z which avoids ri unless ri is α-critical in
(b) If ri is α-critical in Ti − Z, mark ci as forbidden: Let Z(cid:48) := Z(cid:48) ∪ {ci}.

Ti − Z.

5. Let the ﬁnal solution be the union of the found sets: Return ((cid:83)t

4. Let IC be a MIS for the cycle vertices C − (Z ∪ Z(cid:48)).

i=1 ITi) ∪ IC.
When Algorithm 1 is called on input (P, Z), we refer to sets of this solution
with a superscript (P,Z), e. g. the set I (P,Z)
refers to the set ITi when the algorithm
is called on input (P, Z). However, note that we will never actually call this
algorithm during the kernelization of IS/PFM, it is used only for analysis. Seeing
that the above algorithm is correct, we are now ready to prove the ﬁnal lemma
of this section:

Ti

Lemma 4. Let P be a pseudotree and let Z be a set of vertices such that α(P ) >
α(P−Z). Then there exist three (possibly non-distinct) vertices u, v, w ∈ Z∩V (P )
such that α(P ) > α(P − {u, v, w}).

Proof. Assume the condition of the lemma holds. If P has no cycle, then by
Lemma 2 there exist u, v ∈ Z ∩ V (P ) such that α(P ) > α(P − {u, v}), and we
have obtained the requirement of the lemma (we simply let one of the elements
repeat, e.g. let w := v). For the remainder of the proof, we may therefore assume
that P has a cycle C.
If there is a vertex w of the cycle C in P which is also in Z, then pick it as
one of the three elements. Unless α(P ) > α(P − w), we have by Lemma 2 that
there are two vertices u, v ∈ Z ∩ V (P ) such that α(P − w) > α(P − {u, v, w}).

16

T

T

| and |I (P,∅)

C

| > |I (P,{u,v})

| ≥ |I (P,{u,v})

In either case we have obtained the requirement of the lemma. For the remainder
of the proof we may therefore assume that there is no vertex of the cycle C ⊆ P
which is also in Z.
Let us next consider the trees attached to C. If there exists a tree T rooted
at r which is of one of the following types, then we can ﬁnd u, v, w ∈ Z which
satisfy the requirement of the lemma:
– r is not α-critical in T and α(T ) > α(T − Z). Then by Lemma 2, there exist
u, v ∈ Z ∩ V (T ) such that α(T ) > α(T − {u, v}). Observe that Algorithm 1
will produce sets |I (P,∅)
|, so by the
correctness of the algorithm we conclude that α(P ) > α(P − {u, v}). The
requirement of the lemma is thus satisﬁed.
– r is α-critical in T , α(T ) > α(T − Z), and case (i) of Lemma 8 (a) holds
for T, r, Z. Then there exist u, v ∈ Z ∩ V (T ) such that α(T ) > α(T − {u, v})
and r is α-critical in T − {u, v}. In order to show that α(P ) > α(P − {u, v}),
consider what Algorithm 1 will do: Whether called on (P,∅) or (P,{u, v}),
the attachment point vertex c ∈ C for T will still be marked as forbidden.
Thus the only diﬀerence occurs in IT , which is strictly smaller in the latter
case. Hence, the requirement of the lemma is satisﬁed.
– r is α-critical in T , and α(T ) = α(T−Z). Let c be the attachment point vertex
for T . Observe that α((P − T )− c) > α((P − T )− ({c}∪ Z)), or else there is a
contradiction with the preconditions of the lemma. Since (P − T )− c is a tree,
we then have by Lemma 2 that there exist u, v ∈ Z ∩ V ((P − T )− c) such that
α((P−T )−c) > α((P−T )−{c, u, v}). Observe that also α(P ) > α(P−{u, v}),
and the lemma is satisﬁed.

C

From now on, we can assume that there are no trees attached to C of the
above types. We observe that every tree T which is attached to C with root r
must then be one of these three types instead:
(a) r is α-critical in T , and α(T ) > α(T − Z). Case (i) of Lemma 8 (a) does
not apply, so by case (ii), there exists a singleton u ∈ Z ∩ V (T ) such that
α(T ) > α(T − u) and r is not α-critical in T − u.
(b) r is α-critical in T − Z, but not in T . We know that α(T ) = α(T − Z), and
by Lemma 8 (b) that there exists a singleton u ∈ Z ∩ V (T ) such that r is
α-critical in T − u.

(c) r is α-critical in neither T nor T − Z. We know that α(T ) = α(T − Z).
If there is a vertex of the cycle c ∈ C such that two trees Ta and T (cid:48)

a both
of type (a) are attached to c with respective roots r and r(cid:48), then we have that
there exists u ∈ Z ∩ V (Ta) such that α(Ta) > α(Ta − u). Note that u is suﬃcient
to yield α(P ) > α(P − u). To see this, consider what happens in Algorithm 1:
Regardless of whether it was called with parameters (P,∅) or (P,{u}), c will be
marked as forbidden since r(cid:48) is still α-critical in T (cid:48)
a). The
only diﬀerence between the two runs of the algorithm is that ITa will be strictly
smaller in the latter case. Hence the requirement of the lemma holds, and going
forward we can assume no such cycle vertex exists.

a − u (u is not in T (cid:48)

17

If there is a cycle vertex c with two attached trees Ta and Tb of types (a)
and (b) respectively, then there are elements u ∈ Z ∩ V (Ta) and v ∈ Z ∩ V (Tb)
such that α(Ta) > α(Ta − u) and rb is α-critical in Tb − v. Note that then
α(P ) > α(P − {u, v}). To see this, consider what happens in Algorithm 1:
Regardless of whether it was called with input (P,∅) or (P,{u, v}), c will be
marked as forbidden because ra is α-critical in T , and rb is α-critical in Tb − v.
Since I (P,{u,v})
, we have reached the requirement
of the lemma. From now on we assume there are no such cycle vertices.
We can now partition all the cycle vertices c ∈ C into the following three

is strictly smaller than I (P,∅)

Ta

Ta

categories:
Redeemable A cycle vertex c ∈ C is redeemable if it has exactly one attached
tree T of type (a), and all other attached trees are of type (c). We know
there exists a singleton u ∈ Z ∩ V (T ) such that c is redeemed, i. e. such that
T will have its root r not α-critical in T − u. Informally we may note that
the price payed in T for redeeming c is at least one by Observation 4, i. e.
Algorithm 1 yields |I (P,∅)
Blockable A cycle vertex c ∈ C is blockable if it has at least one attached tree
T of type (b). It may also have any number of attached trees of type (c). We
know there exists a singleton u ∈ Z ∩ V (T ) such that c is blocked, i. e. such
that the root r of T will be α-critical in T − u.

Free A cycle vertex c ∈ C is free if all attached trees are of type (c).

| > I (P,{u})

.

T

T

If there are no redeemable cycle vertices in C, then consider some blockable
cycle vertex cu. It exists, or else we have that α(P ) = α(P − Z). Because there
are no trees where Z cause a drop in the independence number of the tree,
the diﬀerence must occur in |IC| when using Algorithm 1 on the inputs (P,∅)
and (P, Z). By Lemma 2, we can extrapolate that there exist two (possibly
non-distinct) blockable cycle vertices cv, cw ∈ C − cu such that α(C − cu) >
α(C − {cu, cv, cw}). If we now let u, v, w be elements that block their respective
cycle vertex cu, cv, cw, then we have that α(P ) > α(P −{u, v, w}), and the lemma
is satisﬁed. Going forth, we will assume there is at least one redeemable cycle
vertex.
If there is exactly one redeemable cycle vertex c, observe that Algorithm 1
will pick α(C) vertices of C when ﬁnding the MIS for input (P,∅). Let T be the
tree of type (a) attached to c. See that there is no way to compensate the cost
occurring in IT when u redeems c. Thus, α(P ) > α(P − u), and the lemma holds.
Assume then, there are at least two redeemable cycle vertices.
If there are exactly two redeemable cycle vertices c1 and c2, then similarly
to the previous case, Algorithm 1 will pick at least α(C) − 1 vertices of C on
input (P,∅). If we pick u, v such that they redeem c1 and c2 respectively, then
the price payed is at least two, out of which at most one can be compensated in
C. Thus, α(P ) > α(P − {u, v}), and the lemma holds. Assume then, there are at
least three redeemable cycle vertices.
Pick two redeemable vertices ci and cj and a maximal length path along the
cycle Q = {c1, c2,··· , ci−1, ci, ci+1,··· , cj−1, cj, cj+1,··· , cq} such that ci and cj

18

are the only redeemable vertices in Q. Since there are at least three redeemable
vertices in C, such a path exists, and c1 is not a neighbor of cq. Let α(Q) be
the maximum independent set of Q after ci and cj have been both redeemed. It
remains to observe that α(Q) ≤ 1 + α(Q − {ci, cj}) to conclude that redeeming
ci by u and cj by v will cause α(P ) > α(P − {u, v}). This concludes the proof of
the lemma.

5 No polynomial kernel for VC/MFM

In this section we show that Vertex Cover/Mock forest modulator
admits no polynomial kernel unless NP ⊆ coNP/poly. Our strategy is to make a
reduction from CNF-SAT parameterized by the number of variables to IS/MFM.
By the immidiate correspondance between Vertex Cover and Independent
Set, the result for Vertex Cover/Mock forest modulator will follow. We
deﬁne the following problem.

Independent Set/Mock forest modulator (IS/MFM)
Input: A simple undirected graph G, a mock forest modulator X ⊆ V (G)
such that no two cycles of G − X share a vertex, and an integer k.
Parameter: Size of a mock forest modulator |X|.
Question: Does G contain an independent set of size at least k?

Our reduction also shows that there is no polynomial kernel for Vertex
Cover when parameterized by the size of modulators to cactus graphs and
outerplanar graphs as well, under the same condition. This strategy is an adaption
of the strategy used by Jansen, Raman and Vatshelle [7] to show that Feedback
Vertex Set does not admit a polynomial kernel parameterized by a modulator
to mock forests unless NP ⊆ coNP/poly.
Deﬁnition 8 (Polynomial-parameter transformation [1]). Let Q,Q(cid:48) ⊆
Σ∗ × N be parameterized problems. A polynomial-parameter transformation from
Q to Q(cid:48) is an algorithm that, on input (x, k) ∈ Σ∗ × N, takes time polynomial
in |x| + k, and outputs an instance (x, k) ∈ Σ∗ × N such that k(cid:48) is polynomially
bounded in k, and (x, k) ∈ Q if and only if (x(cid:48), k(cid:48)) ∈ Q(cid:48). For a parameterized
problem Q ⊆ Σ∗ × N, the unparameterized version of Q is the set ˆQ = {x1k |
(x, k) ∈ Q} where 1 is a new symbol that is added to the alphabet.
Proposition 3 ([1]). Let Q and Q(cid:48) be parameterized problems and let ˆQ and ˆQ(cid:48)
be the unparameterized versions of Q and Q(cid:48) respectively. Suppose ˆQ is NP-hard
and ˆQ(cid:48) is in NP. If there is a polynomial-parameter transformation form Q to
Q(cid:48), and Q(cid:48) has a polynomial kernel, then Q also has a polynomial kernel.
Proposition 4 ([3,5]). CNF-SAT parameterized by the number of variables
does not admit a polynomial kernel unless NP ⊆ coNP/poly.
Deﬁnition 9 (Clause gadget). Let k ≥ 1 be an integer. The clause gadget
of size k is the graph Gk consisting of k triangles T1, T2, . . . , Tk and two extra
vertices r0 and lk+1 connected as follows: For each triangle Ti, label the three

19

vertices li,ri, and si ( left vertex, right vertex and spike vertex, respectively).
Then for each i ∈ {0} ∪ [k], let there be an edge rili+1 connecting the right vertex
of Ti to the left vertex of Ti+1. In this way, Gk is a “path” of k connected triangles,
with two extra degree-1 vertices attached at the ends.

Fig. 7: A clause gadget Gk

Observation 6. For a clause gadget Gk, the independence number α(Gk) is
exactly k + 2. This can be obtained by the independent set containing all the
spike vertices as well as r0 and lk+1. We verify that this is also optimal since
at most one vertex can be chosen from each triangle Ti, and there are only two
non-triangle vertices.
Observation 7. For a clause gadget Gk, every maximum independent set I must
contain at least one spike vertex. Removing the spike vertices, what remains of
Gk is an even path with 2k + 2 vertices, yielding a maximum independent set of
size k + 1, which is strictly smaller than α(Gk).
Observation 8. For a clause gadget Gk, let S denote the set of spike vertices.
Observe that for each spike vertex si ∈ S, there exists a maximum independent
set Ii such that si is the only spike in Ii, i. e. Ii ∩ S = {si}.
Theorem 2. Independent Set/Mock forest modulator does not admit
a polynomial kernel unless NP ⊆ coNP/poly.

Proof. Since Vertex Cover is in NP and CNF-SAT is NP-hard, we have
by Propositions 3 and 4, that it is suﬃcient to show a polynomial-parameter
transformation from CNF-SAT parameterized by the number of variables to
IS/MFM.

Consider an instance F of CNF-SAT consisting of clauses C1, C2, . . . , Cm
over the variables x1, x2, . . . , xn. For a clause Cj, let h(j) denote the number
of literals in Cj. We will in polynomial time construct an instance (G, X, k) of
IS/MFM such that F is satisﬁed if and only if (G, X, k) is a yes-instance. We
construct graph G as follows.
For each variable xi, we let there be two vertices ti and fi in V (G). Let
them be connected by an edge tifi ∈ E(G). Which of ti and fi is included in a
maximum independent set for G will represent whether the variable xi is set to
true or false.
For each clause Cj, let (cid:96)1, (cid:96)2, . . . , (cid:96)h(j) denote the literals of Cj. Let Cj be a
copy of the clause gadget Gh(j), and add it to the graph G. Let the spikes of Cj be

20

r0r1r2rklk+1l1l2lks1s2skparameter. Finally, we let k = n +(cid:80)m

j=1(h(j) + 2).

denoted s1, s2, . . . , sh(j). We will connect Cj to the rest of G as follows: For each
literal (cid:96)r ∈ Cj, let there be an edge from sr to fi if and only if (cid:96)r = xi. Similarly,
let there be an edge from sr to ti if and only if (cid:96)r = ¬xi. By this process, every
spike of Cj is connected to exactly one vertex outside of Cj, which is either ti or
fi for some i ∈ [n]. This concludes the construction of G.
Let the set X consist of the variable gadget vertices, i. e., let X = {ti | i ∈
[n]} ∪ {fi | i ∈ [n]}. Observe that X is indeed a mock forest modulator for G,
since every connected component of G − X is exactly a clause gadget, and thus
also a mock forest. Also note that |X| = 2n, which is polynomial in the input
j=1(h(j) + 2). It remains to show that F is
satisﬁable if and only if (G, X, k) is a yes-instance.
(⇒) Assume the formula is satisﬁable by the assignment ϕ. We will now build
an independent set I in G which has size at least k. Initially, let IX = ∅. For each
variable xi, let ti be in IX if ϕ(xi) is True, and let fi be in IX otherwise. In this
way, n vertices are added to IX . Observe that this process preserves independence
of IX .
For each clause Cj, we know that there exists some satisﬁed literal (cid:96)r. In the
corresponding clause gadget Cj, observe that sr /∈ NG[IX ] by the construction
of the graph and the choice of IX . Then by Observation 8, we can choose an
independent set Ij for Cj which is disjoint from NG[IX ].
j=1 Ij. Observe that independence
is maintained, since there are no edges between IX and Ij for all j ∈ [m], and
there are no edges between Ij and Ij(cid:48) for all choices of j, j(cid:48) ∈ [m], j (cid:54)= j(cid:48), since
there were no edges between Cj and Cj(cid:48). Further, we note that |IX| = n, and
|Ij| = h(j) + 2 for every j ∈ [m], and that all the sets are vertex disjoint. Thus
(⇐) Assume that there exists an independent set I for G with size |I| ≥
j=1(h(j) + 2). We construct an assignment ϕ which satisﬁes the SAT
j=1(h(j) + 2). Since
G[X] consists exactly of n pairwise joined vertices, we also know that |I ∩ X| ≤ n.
j=1(h(j) + 2), and equality holds for all the relations. For each
variable xi it must thus be the case that either ti ∈ I and fi /∈ I, or vice versa.
We let ϕ(xi) evaluate to True if ti ∈ I, and to False otherwise.
It remains to show that ϕ is in fact a satisfying assignment. Consider some
clause Cj and its corresponding gadget Cj. Because |I ∩ Cj| = h(j) + 2, we have
by Observation 7 that there exists a spike vertex sr ∈ Cj ∩ I. Assume for the
sake of contradiction that (cid:96)r ∈ Cj is not satisﬁed by ϕ. This implies that xi
was assigned a value that would not satisfy (cid:96)r. Without loss of generality, (by
symmetry) assume (cid:96)r = xi and ϕ(xi) = False. Then fi ∈ I; however, by the
construction of the graph, there is an edge between sr and fi. This contradicts
that I is independent. Thus (cid:96)r ∈ Cj is satisﬁed by ϕ and we have concluded the
(cid:117)(cid:116)
proof.

Finally, let I be the union of IX and (cid:83)m
we obtain that |I| = n +(cid:80)m
n +(cid:80)m
formula F . By Observation 6, we know that |I \ X| ≤(cid:80)m
Thus, |I| ≤ n +(cid:80)m

Corollary 2. Vertex Cover/Mock forest modulator does not admit a
polynomial kernel unless NP ⊆ coNP/poly.

21

Finally, let us observe that in the proof of Theorem 2, the graph G − X is
outerplanar. Also every 2-connected component of this graph is either an edge
or a cycle of length 3. Thus the proof of Theorem 2 can be used to show that
Independent Set parameterized by the size of a modulator to an outerplanar
graph, a cactus graph or to a block graph, does does not admit a polynomial
kernel.

References

1. H. L. Bodlaender, S. Thomass´e, and A. Yeo, Kernel bounds for disjoint cycles

and disjoint paths, Theoretical Computer Science, 412 (2011), pp. 4570–4578.

2. M. Cygan, D. Lokshtanov, M. Pilipczuk, M. Pilipczuk, and S. Saurabh,

On the hardness of losing width, Theory Comput. Syst., 54 (2014), pp. 73–82.

3. H. Dell and D. van Melkebeek, Satisﬁability allows no nontrivial sparsiﬁcation

unless the polynomial-time hierarchy collapses, J. ACM, 61 (2014), p. 23.

4. F. V. Fomin, D. Lokshtanov, N. Misra, and S. Saurabh, Planar F-deletion:
Approximation, kernelization and optimal FPT algorithms, in Proceedings of the
53rd Annual Symposium on Foundations of Computer Science (FOCS), IEEE, 2012,
pp. 470–479.

5. L. Fortnow and R. Santhanam, Infeasibility of instance compression and succinct

PCPs for NP, J. Computer and System Sciences, 77 (2011), pp. 91–106.

6. T. Fujito, A uniﬁed approximation algorithm for node-deletion problems, Discrete

Applied Mathematics, 86 (1998), pp. 213–231.

7. B. M. Jansen, V. Raman, and M. Vatshelle, Parameter ecology for feedback

vertex set, Tsinghua Science and Technology, 19 (2014), pp. 387–409.

8. B. M. P. Jansen and H. L. Bodlaender, Vertex cover kernelization revisited:
Upper and lower bounds for a reﬁned parameter, in Proceedings of the 28th Inter-
national Symposium on Theoretical Aspects of Computer Science (STACS), vol. 9
of Leibniz International Proceedings in Informatics (LIPIcs), Schloss Dagstuhl -
Leibniz-Zentrum fuer Informatik, 2011, pp. 177–188.

9.

, Vertex cover kernelization revisited - upper and lower bounds for a reﬁned

parameter, Theory Comput. Syst., 53 (2013), pp. 263–299.

10. D. Majumdar, V. Raman, and S. Saurabh, Kernels for Structural Parameteri-
zations of Vertex Cover - Case of Small Degree Modulators, in 10th International
Symposium on Parameterized and Exact Computation (IPEC 2015), vol. 43 of
LIPIcs, Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2015, pp. 331–342.

22

