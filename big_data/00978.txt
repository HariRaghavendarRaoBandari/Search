Finiteness and Computation in Toposes

Edward Hermann Haeusler

PUC-Rio

Rio de Janeiro, Brasil

∗

hermann@inf.puc-rio.br

Some notions in mathematics can be considered relative. Relative is a term used to denote when the
variation in the position of an observer implies variation in properties or measures on the observed
object. We know, from Skolem theorem, that there are ﬁrst-order models where R is countable and
some where it is not. This fact depends on the position of the observer and on the instrument/language
the obserevr uses as well, i.e., it depends on whether he/she is inside the model or not and in this
particular case the use of ﬁrst-order logic. In this article, we assume that computation is based on
ﬁniteness rather than natural numbers and discuss Turing machines computable morphisms deﬁned
on top of the sole notion ﬁniteness. We explore the relativity of ﬁniteness in models provided by
toposes where the Axiom of Choice (AC) does not hold, since Tarski proved that if AC holds then
all ﬁniteness notions are equivalent. Our toposes do not have natural numbers object (NNO) either,
since in a topos with a NNO these ﬁniteness notions are equivalent to Peano ﬁniteness going back
to computation on top of Natural Numbers. The main contribution of this article is to show that
although from inside every topos, with the properties previously stated, the computation model is
standard, from outside some of these toposes, unexpected properties on the computation arise, e.g.,
inﬁnitely long programs, ﬁnite computations containing inﬁnitely long ones, inﬁnitely branching
computations. We mainly consider Dedekind and Kuratowski notions of ﬁniteness in this article.

1 Introduction

Investigations on eﬀectiveness usually follows two non-exclusive approaches, the model-theoretical and
the proof-theoretical one. The model-theoretical approach provides a “model” X, such that, any (partial)
function F from A into A is X-eﬀective if and only if there is an instance XF of X that represents F1.
The meaning of the “instance XF that represents F” is provided informally by stating that for all input
iX submitted to XF produces an output oX, if and only if, F(i) = o, for some ﬁxed representation for the
input and output data, e.g. numerals or strings simply. The meaning of “submitting” and of “producing”
is also at least informally deﬁned when introducing the “model” X main concepts. X-eﬀectiveness has
to be as close to our intuition on eﬀectiveness as possible. The proof-theoretical approach provides a
logical theory T, such that, for any (partial) function F from A to A, F is said to be T-eﬀective if and
only if there is a term tF, the codiﬁcation of F, and a proof that tF ∈ Terms(T), such that for every a ∈ A,
F(a) = b, if and only if, tF(aF) = bF ∈ T. T is presented by a set of axioms and inference rules for
deriving propositions on membership of T and identity between elements of T. The main judgments in
T are either of the form tF ∈ Terms(T) or [F ≡ G] ∈ T.

Typical of a model-theoretic approach are Turing machines, while G¨odel’s (partial) recursive func-
tions follows the proof-theoretical. Of course, the approaches are not purely model-theoretical or proof-
theoretical. One can consider lambda-calculus as a purely proof-theoretical example, by ignoring the
∗The author thanks CAPES and the Petrobras project led by prof. Eduardo Sani Laber at PUC-Rio, for the academic and

ﬁnancial support

1In classical theory of recursive functions A is the set N of natural numbers.

C.A. Mu˜noz and J. A. P´erez (Eds.) :
Developments in Computational Models
EPTCS 204, 2016, pp. 61–77, doi:10.4204/EPTCS.204.6

c(cid:13) E.H.Haeusler
This work is licensed under the
Creative Commons Attribution License.

62

Finiteness and Computation

underlying evaluation model that provides the intentional identity relationship. On the other hand, we
can consider the lambda-calculus as a model-theoretical approach if we focus on the lambda-terms eval-
uation model. Roger’s theorem stating an abstract axiomatization for the proof-theoretical approach on
eﬀectiveness provides stronger2 evidence (read [17], page 28, or [15], isomorphism theorem, chap 4)
for Turing-Church thesis: “A (partial) function from N to N is eﬀective, if and only if, it is Turing com-
putable” [4]. Thus, Roger’s theorem can be seen as a meta-theoretical proof-theory based approach for
eﬀectiveness.

This work is based on the observation that ﬁniteness is basic for eﬀectiveness deﬁnition. The Turing
machine, for example, relies on the ﬁniteness restriction to its tape content, set of symbols and set of
states. They have to be ﬁnite sets. “Programs”, or whatever is used to represent the eﬀective functions,
are ﬁnite too, they “run” in ﬁnite time, they use a ﬁnite amount of “data”, if they are non-deterministic
the corresponding non-deterministic range is always ﬁnite, etc. Although natural numbers may appear
as central in eﬀectiveness studies, some computational models, do not explicitly mention them, namely
Turing machines. This article also investigates what are the consequences of taking ﬁniteness more basic
than natural numbers in this subject.

In ZFC3, Peano’s deﬁnition of ﬁnite sets uses the set N of the natural numbers. Nevertheless, deﬁ-
nitions of ﬁnite in ZFC, such as those due to Dedekind or Kuratowski, do not depend on the existence
of any inﬁnite set, such as N. To the best of our knowledge, we can say that almost all model-theoretical
approaches for eﬀectiveness are carried out in ZFC. In 1924, Tarski proved that the many existing
and well-known deﬁnitions of ﬁnite set are equivalent. Tarski mentioned Peano-ﬁniteness, Dedekind-
ﬁniteness and some inductive deﬁnitions due to M.M. Russell, Sierpinski and Kuratowski, see [21]. A
ﬁrst fact to be noted is that he had to use the Axiom of Choice in his equivalence proof. Another fact
is that, due to the duality between ﬁnite and inﬁnite, when deﬁning one of these concepts the respective
dual is obtained by means of negation. The use of negation adds a logical dimension to this discussion.
Thus, besides the Axiom of Choice, the fact that we are inside intuitionistic or classical framework has
interesting consequences on the relationship among these mathematical deﬁnitions of ﬁniteness.

Outside the realm of ZFC, ﬁniteness is a relative notion. Relative means that the variation in the
position of the observer implies variation in properties or measures on the observed object. This variation
may include the instrument used to measure. For example, if we use the language of ﬁrst-order logic as
an analog of a measuring instrument, Skolem’s theorem provides this relativity eﬀect. We have some
models where R is countable, some where it is not. This fact depends on the position of the observer. In
this speciﬁc case of ﬁniteness it may depend on whether he/she is inside the model or not. Outside ZFC,
for example, a Dedekind-ﬁnite object O can be intuitively inﬁnite, that is, it can be expressed as O1∪ O2
with both, O1 and O2 not Dedekind-ﬁnite objects, i.e., Dedekind-inﬁnite ones. This is example is shown
in this article. One can also argue that ﬁrst-order logic is not adequate to express Real numbers, this is
another point of view. However this kind of discussion may end up into philosophical points that are out
of the scope of our approach, as it can be taken in the sequel.

Based on the relativity of ﬁniteness, we want to start a discussion on what is its real role in Theory
of Computation. The methodology is to use a ﬁniteness property as a parameter in Turing-machines
deﬁnition. For example, by choosing the Dedekind deﬁnition of ﬁnite we have Turing-Dedekind ma-
chines and hence, Turing-Dedekind computable functions. By Tarski’s analysis, these Turing-Dedekind
machines cannot be formalized inside ZFC, without collapsing into the usual/classical Turing-machines.
We will use Category Theory, speciﬁcally toposes to obtain these Turing machines deﬁnition on top

2Stronger than evidences provided by some concrete models, as those raised since Turing’s work.
3Zermelo Fraenkel set theory with the axiom of Choice.

E.H.Haeusler

63

of well-known ﬁniteness deﬁnitions, such as Dedekind and Kuratowski. Category Theory (CT) is not
completely dissociated from set theory as an alternative theory for the foundation of mathematics4. It
provides, nevertheless, an alternative ontology5 for mathematics. In CT, classes of objects and mor-
phisms form a category. Morphisms are typed by domain and co-domain. For example, A and B are
objects in a category C and f : A → B is a morphism in C having domain A and co-domain B. There is
a typed composition “◦” operation between morphisms that has a monoidal ﬂavor. However, the meta-
theory CT, apart from the parcel of ZFC that it uses, does not provide meaning to propositions of the
form A = B in C. The meta-theory CT only provides meaning to assertions of the type f = g, whenever
f and g are morphisms. The whole class of all sets and all functions between these sets is the archetypal
category. Inside this category (known by SETS) only identity of functions have semantics. About the
objects of SETS, i.e., the sets themselves, it cannot be stated that any two sets are equal or not equal. The
most that can be said is that they are isomorphic or not6. This changing of perspective is quite interesting
since it provides more ways to compare models of certain concepts formalized on top of ZFC with those
formalized on top of CT.

We will ﬁnd out that, at least hypothetically, some Turing-Dedekind machines when observed outside
the model, i.e., from the ZFC perspective, have inﬁnite set of states and/or inﬁnitely long transition-
tables. However, they are ﬁnite when observed from inside the model. We could show many other
non-standard ﬁnite computational models. Because of Tarski’s result and the fact that Zermelo-Fraenkel
set theory is usually classical, our discussion will be carried in the language CT. The use of Local Set
Theory and toposes is justiﬁed by the fact that the internal logic of a topos is able to easily express
set-theoretically based concepts as membership, sub-objects, functions, power-objects. This helps to
translate the set-theoretically inspired notions of Dedekind-ﬁniteness and Kuratowksi-ﬁniteness to the
Local language. Other categorical approaches to ﬁniteness, as lfp-categories (presented in [7] and in
[1] in an English comprehensive presentation) lacks internal logic able to deﬁne Turing-computable
morphisms in the usual set-theoretical analog way. The main contribution of this article is to provide
deﬁnition of Turing-computable morphism inside any topos, in a way that ﬁniteness is a parametric
notion and does not depend on NNO. From this deﬁnition we show some examples of toposes, without
NNO and not satisfying the Axiom of Choice, where from outside them, many unexpected computational
properties may hold: 1- Inﬁnitely long Turing machine codes, 2- Inﬁnitely long computations contained
in ﬁnitely long ones and 3- Inﬁnitely branching computations. In Section 2 we brieﬂy explain Local
Set Theory and toposes, in Section 3 we show a Dedekind-ﬁnite automaton having an inﬁnite sub-
automaton, and how this can be extended to an example of a Dedekind-ﬁnite automaton with arbitrarily
many diﬀerent, and non-isomorphic, inﬁnite sub-automata. We also show, in this topos of automata
that there exists an object A, an automaton, having only one element e : 1 → A, but three non-empty
proper sub-objects. In Section 4 we state, using the language of Local Set Theory, the ﬁniteness notions
of Dedekind-ﬁnite, Kuratowski-ﬁnite and Peano-ﬁnite, as they are quite well-known. In Section 6 we
deﬁne Turing machines, their computations and the Turing-computable morphisms induced by them, by
means of Local Set Theory formulas in an arbitrary topos. In Section 7 we point out the fact that does
not seem to exist a natural deﬁnition of ﬁniteness, Deﬁnition 11, by showing inﬁnitely many deﬁnitions
of ﬁnite, due to R. Squire. In Section 8 we remark the existence of some topos where from the outside
the above mentioned non-standard computational properties of Turing-machine computations hold. Our
assumption on ﬁniteness rather than arithmetic in formalizing the eﬀective is brieﬂy discussed on the

4The deﬁnition of category mention a set/class of objects and a set/class of functions.
5Terminology, in philosophical sense.
6Let A and B be sets, A is isomorphic to B, if and only if, there are f : A → B and g : B → A, such that, f ◦ g = IdB and

g◦ f = IdA.

64

Finiteness and Computation

light of very relevant articles that discuss the nature of Turing-Church thesis. In Section 5 we remind the
reader about the relative inconsistency of a stronger form of Church-Turing thesis with classical logic
and the existence of Natural Numbers in the universe of discourse, namely, a topos. Because of this
inconsistency we have to either drop out classical logic or the existence of Natural Numbers object, in
order to have such topos. If we deﬁne it with a non-classical internal logic we end up revisiting the well
studied eﬀective topos, see [11]. On the other hand, if we drop out Strong Church-Turing thesis, that
is, every morphism in the topos is computable, we obtain the well studied classical theory of recursive
functions. The last alternatives is to drop out the existence of a Natural Numbers object and in a naive
setting to have ﬁnite sets and ﬁrst-order ﬁnite domain logic. From these alternatives, the former, namely,
the adoption of a deﬁnition of Turing machines by means of only ﬁniteness notions can shed some light
on computations expressed inside a topos without Natural numbers existence. Section 6 shows how to
follow this approach, a contribution of this article.

2 Local Set Theory and toposes

One of the useful aspects of topos theory [8, 13] from a logical point of view concerns investigating
the internal logic of toposes, namely categories with some special properties, by means of localized
language, called local set theory (LST) [2]. This has been accomplished by taking any topos as a model
of a theory in the language of LST, which is basically a higher-order typed language. The interpretation
of such a theory in the particular topos provide us with a convenient way of treating the objects of the
topos as set-like entities and the morphisms between them as function-like relations between them.

With the purpose of ﬁxing terminology and provide some (useful) intuition, we write down some

deﬁnitions. We remind the reader that the deﬁnitions in category theory work up to isomorphism.
Deﬁnition 1 (Topos) A topos is a category T having: (1) Terminal Object; (2) Pull-Backs; (3) Expo-
nential Objects; (4) Sub-object Classiﬁer.
Deﬁnition 2 (Sub-object Classiﬁer) A sub-object classiﬁer, in a category T , is an object Ω, together
with a morphism (cid:62) : 1 → Ω, such that, for every monomorphism f : B → A, there is a unique morphism
χ f : A → Ω, such that, the following diagram is a Pull-Back:

A /

!
1 /

f

(cid:62)

B

χ f
/ Ω

The morphism (cid:62) plays the rule of the truth-value “true”. Monomorphisms provide a way of deﬁning
sub-objects inside a category. Inside a topos, many set-theoretical notions can be categoriﬁed, that is,
translated to the CT language in a way that preserves its original meaning in SETS, the category of sets
and functions between them. For example, the notion of element of set is in a one-to-one correspondence
with functions from a singleton to this set. Each a ∈ A is associated with the function f : {(cid:63)} → A, such
that, f ((cid:63)) = a. The fact that this correspondence can be seen as a bijection between functions from a
singleton to A and elements of A allow us to categorify the set-theoretical notion of elements in any
category with a terminal object. Terminal objects are the categorical counterpart of singletons. As a
matter of notation, we use (up to isomorphim) (cid:112)a(cid:113) ∈ A to denote that (cid:112)a(cid:113) : 1 → A is a morphism in a
particular category. The categoriﬁcation of the empty set is the initial object, since there is one and only
one function (in SETS) from ∅ to any other set. As we could expect, categoriﬁed notions do not preserve
all properties they have in SETS, as the two following examples illustrates.

/
/
/




/
/
E.H.Haeusler

65

Example 1 Initial objects in any category not having a zero object7 cannot have elements8. Initial ob-
jects and empty objects in a category might be the same class. However, in the functor category SETS·→·,
there are objects that are empty and are not initial. An initial object in this category is isomorphic to
the only function from ∅ into ∅. On the other hand, functions from ∅ into A, for any set A, cannot have
elements either. The formula ¬∃x(x ∈ X) is true if X is assigned to ∅ → A in SETS·→·.
Example 2 Let f,g : A → B, two functions in SETS, such that f (cid:44) g. Consider now the objects ! : ∅ → A
and IdB : B → B in SETS·→· and the commutative diagram below, showing that the (!, f ) and (!,g) are
morphisms from ! : ∅ → A in IdB : B → B in SETS·→·.

A

!

∅

f

g

!

/ B

IdB

/ B

Because there is no element in ! : ∅ → A, inside SETS·→· it is not possible to falsify the formula (∀x ∈
X(F(x) = G(x)) → F = G), if F,G are assigned to (!, f ) and (!,g), respectively, and X to ! : ∅ → A.
Internally F and G are equal, but they are not externally equal.

Using sub-object classiﬁers it is possible to locally deﬁne equality, the membership relation, exis-
tential and the universal quantiﬁer. For any topos they form the semantics of Local Set Theory. The
reader can check that Deﬁnition 3 corresponds to the identity in SETS. The other deﬁnitions are omitted
because of lack of space. Being a morphism from A× A into Ω, =A is a predicate. Thus, LST has a
propositional meaning for ∈A, =A, ∀A and ∃A. They are typed (localized) counterparts of ∈, =, ∀ and ∃.
This is brieﬂy explained in the following subsection.

2.1 The internal language of a topos
Deﬁnition 3 (Local Identity) Consider an object A in a topos T . Let δ : A → A× A be the diagonal
morphism, deﬁned as (cid:104)IdA, IdA(cid:105) from the usual categorical cartesian product deﬁnition. The sub-object
classiﬁer pullback below deﬁnes local equality =A, in A. =A is the characteristic morphism of δ.

A

!

1

δA /

A× A

=A

/ Ω

(cid:62)

Using the internal logic of the topos, provided by the sub-object classiﬁer, it is possible to deﬁne the
membership relationship ∈A, localized in any object A of the topos. This deﬁnition strongly relies on
the fact that Hom(A, Ω) represents the collection of sub-objects of A9. In fact Hom(A, Ω) is a Heyting
algebra.

7A zero object is an object that is initial and terminal.
8Any morphism from 1 to 0 would make them isomorphic.
9By the sub-object classiﬁer axiom stated in Deﬁnition 2 each monomorphism from A to Ω corresponds to a sub-object of

A in a bijective way.

/
/
/
O
O
/
O
O
/




/
66

Finiteness and Computation

Deﬁnition 4 (Local Membership) Consider a topos T and an object A in it. Let evA : A× ΩA → Ω be
the evaluation morphism provided by the exponential object ΩA. The following instance of the sub-object
classiﬁer diagram deﬁnes ∈A.

inc /

A× ΩA
evA

∈A

!

1

/ Ω

(cid:62)

So, the local membership to A is the characteristic morphism of evA.
There is a very useful and strong way of building toposes. This is provided by one the fundamental
theorem of topos. Its proof can be found in [8, 13, 2]. A category is locally small whenever Hom(A, B)
is a set, for any A and B in the category.
Theorem 1 Let C be a locally small category. SETSC is a topos.

The category SETSC, when C is a pre-order, is naturally interpreted as sets varying according C.
The pre-order works as a temporal structure over each set evolves. When C is more than a pre-order
category, sometimes it is possible to see a kind of topology on any object A induced by the morphism
with co-domain A. In this case, we have a temporal structure induced by this topology. Anyway, in
some cases, SETSC is naturally equivalent to a category of dynamic systems. Since discrete dynamical
systems can be seen as a semantics for computing process, the use of the above functorial category in
providing examples for non-standard model of computing is justiﬁed.

2.2 The logical language related to toposes
Any topos is (naturally isomorphic to) a model of some local set theory (LST). In LST, the notion of
type replaces “set”. In the language of LST each term (including those representing sets) has an asso-
ciated type. The terminology “local” in LST provide us with a scope (locality) to any “set-theoretical”
operations, such as union, intersection, identity (see Deﬁnition 3), membership (see Deﬁnition 4), etc.
These “set-theoretical” operations are only deﬁned for terms of the same type (i.e., locally). Apart from
that, the language is very similar to set-theory language, based on the primitive symbols =, ∈ and the
operation { | }10. The language of LST is deﬁned in the sequel. This presentation follows [2] (see pp.
91ﬀ), where the details on how to interpret a local language in an arbitrary topos are provided.

Deﬁnition 5 (Local Language) A local language L is deﬁned by:
Symbols the unit symbol 1, the truth-value type symbol Ω, a collection of ground type symbols A, B,C, . . . ,

and a collection of function symbols f,g,h, ...;

Types the set of types of L is the least set T containing 1, Ω, all ground type symbols A, B,C, . . . and

closed under the following operations:

• For A ∈ T, the type of power object PA is also in T11;
• For A1, . . . , An ∈ T , the product type A1 × . . .× An is also in T (for n = 0, the product type is
• For A, B ∈ T, the exponential type A → B is also in T.

1);

10The operation { | } when applied to a predicate φ(x) of type ΩX provides a sub-object {x | φ(x)} of X.
11A power object PA internalizes the notion of the “collection” of all sub-objects of A.

/




/
E.H.Haeusler

67

Signatures Each function symbol f is associated to a signature A → B, where A and B are types. We

use f : A → B to denote this;

Variables For each type A there is a countable set of variables VA;
Terms For each type A, there is a set TA of terms of type A, deﬁned as follows:

• (cid:63) ∈ T1;
• VA ⊆ TA;
• For f : A → B and τ ∈ TA, we have that f (τ) ∈ TB;
• For τi ∈ TAi (i = 1, . . . ,n) ,we have that (τ1, . . . , τn) ∈ TA1×...×An. In the case n = 0, this term is
(cid:63) ∈ T1;
• For τ ∈ TA1×...×An, we have that πi(τ) ∈ TAi (i = 1, . . . ,n);
• For ϕ ∈ TΩ and x ∈ VA, we have that {x | ϕ} ∈ TPA;
• For terms σ and τ of type A, we have that σ = τ is a term in TΩ;
• For terms σ and τ of types A and PA, respectively, we have that σ ∈ τ is a term in TΩ.

Terms of type Ω are called formulae. We use superscripts to indicate the type of a variable, and,
in order to not have overloaded superscripts we allow the omission of some of these superscripts in
some terms, since this omission does not interfere in their unique typing. Free and bound occurrences
of variables are deﬁned in the usual way. Logical operators can be deﬁne as abbreviations, (see [2],
p. 70). For example, (cid:62) is deﬁned as (cid:63) = (cid:63); given formulae ϕ, ψ we have that ϕ ∧ ψ is deﬁned as
(ϕ, ψ) = ((cid:62),(cid:62)), and ϕ ⇒ ψ is deﬁned as ϕ∧ ψ = ϕ. Quantiﬁers are also (locally) deﬁned: given a variable
x of the appropriate type A, ∀xA : ϕ is an abbreviation of {x | ϕ} = {x | (cid:62)}. The falsum (⊥) is deﬁned as
∀ωΩ : ω. Consider a formula ϕ, with no occurrence of the variable ω of type Ω, ∃xA : ϕ is deﬁned as
∀ωΩ : (∀xA : (ϕ ⇒ ω) ⇒ ω). Some terms in a local language represent set-like objects in the Topos.
Deﬁnition 6 (Set-terms) A set-term is any term of power type PA for some type A.

1 . . .∃xA

Set-theoretical-like deﬁnitions are listed in [2] (see pp. 83ﬀ). For example: X ⊆ Y is deﬁned as
∀Ax : (x ∈ X ⇒ x ∈ Y); X∩ Y is deﬁned as {x | x ∈ X∧ x ∈ Y}; X∪ Y is deﬁned as {x | x ∈ X∨ x ∈ Y}, where
X and Y are of type PA; A is deﬁned as {x | (cid:62)}, of type PA, with x a variable of type A. Thus, for every
type symbol A, there is a corresponding set-term A. The term ∅A is deﬁned as {x | ⊥}, of type PA, with
x a variable of type A; PA is deﬁned as {x | x ⊆ A}, of type PPA, with x a variable of type PA. A more
general version of deﬁning set-like objects from set-like objects is provided by the term {τ | ϕ}, which is
deﬁned as {x | ∃xA
n : (x = τ∧ ϕ)}. A× B is deﬁned by {(x,y) | xA ∈ A∧ yB ∈ B}. BA is deﬁned by
{ f P(A×B) | ∀xA : ∃!yB : (x,y) ∈ f}12. The type of BA is PP(A× B). Besides that, to each function symbol
f : A → B in L corresponds the set-term {(xA, f (x)) | x ∈ A} of type BA. When the topos determines the
local language, each morphism f : A→ B is associated to a set-term f of type BA, allowing us to represent
morphisms as functions-like entities, in terms of “sets” of ordered pairs. Finally, inﬁnite versions of these
operations, for indexed families, are such that, ⊕i∈IXi is deﬁned as {(iI, xXi) | i ∈ I ∧ x ∈ Xi}. In [2] it is
shown a deductive system, in sequent-style, to derive (draw conclusion) formulas from set of formulas.
It is shown how any consistent13 set of formulas in LST gives raise to a syntactical topos (in the style
of a Herbrand term model), and how from syntactical models one can derive a completeness theorem for
LST logical consequence.

12∃!yA : ϕ is an abbreviation to (∃yA : ϕ)∧ (∀xA∀yA : (ϕ∧ ϕ(y/x) ⇒ x = y)), where ϕ(y/x) denotes the replacing of x by y in
13A set of formulas is consistent, if and only if, it does not derive ⊥.

ϕ, usual conditions on replacing free variables applies.

68

Finiteness and Computation

A notion of validity of a formula in a topos is deﬁned in the expected way. Consider a mapping M
from a Local Language L into a topos T , such that, the types T are mapped into the objects of T , Ω
is mapped into a sub-object classiﬁer of T (ΩT ), 1 is mapped into a terminal object of T , products are
mapped into products, function symbols are adequately mapped into morphisms, and variables of type
X into morphisms from M(1) into M(X). This mapping is recursively extended to a mapping ˆM from
terms into objects and morphisms of T . Thus, for each set-like term t, of type PA, ˆM(t) is mapped to a
corresponding sub-object of ˆM(A). Terms of type Ω are mapped to morphisms from M(1) to M(Ω), that
are truth-values inside the topos. M can be seen as denotational interpretation of L into T . Thus, having
denotations for t1 and t2 of type A, M(t1) and M(t2) sub-objects of M(A), the denotation of the formula
t1 = t2 can be considered as true, if and only if, the monomorphism related to M(t1) is equal to the one
related to M(t2), since Category Theory provides equality between morphism, this is unproblematic at
ﬁrst sight. However, the (local) equality can be deﬁned inside a topos. As it was shown in Deﬁnition 3,
the denotation of t1 = t2 is itself a general element of (a morphism from M(1) to M(Ω)), and hence a
morphism from 1T into ΩT , a truth value itself. Since the equality deﬁned in Deﬁnition 3 is a local
notion, it is hardly the case that the truth value M(t1 = t2) is the same of M(t1) = M(t2). Example 2
conﬁrm this and Example 1 provide a typical case of a categoriﬁcation of a set-theoretical concept that
does not have the same truth value on every topos. The concept of monomorphism, used here and not
deﬁned yet, is of a diﬀerent kind. Monomorphisms are categoriﬁcations of injective functions: f : A → B
is a monomorphism (mono), if and only if, for every pair of morphisms h,g : C → A, such that f ◦h = f ◦g,
then h = g. In a topos monomorphisms and injections coincide. In a general category this is not the case.
In a topos every morphism that is injective and surjective is an isomorphism. Of course, this is the case
in SETS, since SETS is a topos. It is clear that there are properties expressed in LST that hold in some
topos and does not in SETS.

3 Motivating Examples

M-Sets form an universe that can be identiﬁed with the class of automata and morphisms between them.
Let M be a monoid and A be a set. A : A× M → A is a M-Set, if and only if, A(a,m (cid:63)n) = A(A(a,m),n),
where (cid:63) is the monoid operation. Let A : A × M → A and B : B× M → B be M-Sets. A function
F : A → B, such that, F(A(x,m)) = B(F(x),m) is a morphism in S etsM. We denote it by F : A → B.
An M-Set (monoid actions) can be seen as a family (Aσ)σ∈M of functions from A into A. Note that
we use A for both, the family of functions and their domain and co-domain sets. The functions must
satisfy: Am(cid:63)n(x) = Am(An(x)). F : A → B is morphism, if and only if, F(Am(x)) = Bm(F(x)). M-Sets
and M-Sets morphisms form a category that is a topos. Let A be the ﬁnite automaton at the right side
of Figure 1(a). It can be uniquely deﬁned by the actions ma, mb and mc on the set {q1,q2,q3,q4}, such
that: Aa(q1) = q2,Aa(q2) = q4,Aa(q3) = q4,Aa(q4) = q4,Ab(q1) = q2,Ab(q2) = q3,Ab(q3) = q3,Ab(q4) =
q4,Ac(q1) = q3,Ac(q2) = q2,Ac(q3) = q2,Ac(q4) = q4. It can be proved that every Σ(cid:63)-Set is an automaton
on Σ(cid:63), not necessarily ﬁnite.

What are the automata B that can be related to A by monomorphisms. Consider B with only one
state X. A mono F : B → A is a function f : {X} → {q1,q2,q3,q4} that is equivariant.
f (X) = q4 is the
only possibility, for f (Bσ(X)) = Aσ( f (X)), see Figure 1(a). In Figure 1(b), B has two states X and Y. A
mono F : B → A is a function f : {X,Y} → {q1,q2,q3,q4} equivariant and injective. With f (X) = q4, there
is no way to have f (Bσ(Y)) = Aσ( f (Y)), for any choice, such that f (Y) = {q3,q1,q2}.

E.H.Haeusler

69

c

Y

f

a,b

a,b,c

X

a,b,c

X

f

q1

a,b

c

c

c

q2

q3

b

c,b,a

q4

a

b

a

f

a,b

q1

c

c

c

q2

q3

b

c,b,a

q4

b

a

a

Figure 1: Monomorphisms: Left (a) from one-state automaton B into A. Right, (b) two-state B into A

c

c

Y

Z

b

a,b,c

X

a

a

b

f2

f2

f2

a,b

q1

c

c

c

q2

q3

b

c,b,a

q4

b

a

a

Figure 2: Monomorphism from a three-state automaton B into A

There are only two monomorphisms F1, F2 : B → A that are equivariant from an automaton with 3 states.
They correspond to the functions f1 and f2: f1(X) = q4 and f2(X) = q4 and f1(Y) = q3 with f2(Y) = q2,
and, f1(Z) = q2 with f2(Z) = q3 . See Figure 2.
The {a,b,c}(cid:63)−S et A has only one element 1 :→ A, but three non-empty proper sub-objects. In ZFC
this statement cannot be true. Any set with only one element cannot have a power-set with three elements.
This is yet another manifestation of the relativity of the concept of ﬁniteness. Let us show an example on
Dedekind notion of ﬁniteness. In LST, we express that f is an isomorphism by Iso( f BA) ⇔ ∃h(( f ◦h =BB
IdB ∧ (h ◦ f =AA IdA. We express that f is a monomorphism by Mono( f BA) ⇔ ∀hAC∀gAC(( f ◦ h =BC
f ◦ g) → h =AC g). In a topos T , A is D-ﬁnite in T , if and only if, ∀ f ∈ AA(Mono( f ) ⇒ Iso( f )) holds in
T .
Example 3 Let M be the free monoid generated by {mi/i ∈ N}, A={an/n ∈ N}, B={bn/n ∈ N}, and C =
A∪ B. The automaton C : M×C → C is the following.
{mk}k(cid:44)n

{mk}k(cid:44)1

{mi}i∈N

{mi}i∈N

a1

m1

b1

an

mn

bn

We show that any injective morphism F : C → C is the identity IdC (see Example 1). Thus, C is
Dedekind-ﬁnite, no matter the set-theoretical cardinality of A and B. If B is an inﬁnite set then there

70

Finiteness and Computation

is G : B (cid:55)→ B, an injective function that is not bijective. Thus, B(mn,bk) = G(bk) is not Dedekind-ﬁnite14.
That is, there is a Dedekind-ﬁnite (C) object that has a D-inﬁnite sub-object (B). This can be extended for
any n ∈ N, such that, C = A∪A1∪A2∪ . . .∪An, C is Dedekind-ﬁnite and Bi, i = 1, . . . ,n, are D-inﬁnite,
see Example 4.

4 Finiteness in Local Set Theories

The main discussion in this article, is the role played by ﬁniteness in computability. We are sure that this
notion is essential when deﬁning any computation model, even it is used implicitly. From the literature
on topos theory, we are aware of the fact that the well-known notions of ﬁnite, namely, Dedekind-ﬁnite,
Kuratowski-ﬁnite and Peano-ﬁnite, for example are not equivalent, see [14]. This in fact means that some
of these notions correspond to non-ﬁnite (inﬁnite) extensions, externally, in some toposes. Besides that,
such notions have counter-intuitive properties as we will mention in the sequel.

As a starting point, we write down, in LST, sometimes with the help of diagrams these ﬁniteness

notions.

The ﬁrst item of the above list, Dedekind ﬁniteness or D-ﬁniteness as deﬁned in Section 3, is quite
interesting. There we show D-ﬁnite objects that are externally inﬁnite. Besides that, a result due to
Johnstone [12] shows that any sub-object classiﬁer is D-ﬁnite. However, there are many toposes that
have inﬁnitely many truth-values. Sheaves over a topological space S have Opens(S) as the “set” of
truth-values, for example. One can argue that D-ﬁniteness is obtained by negating D-inﬁnity, and hence,
it is strongly dependent on whether the topos is classical or not. Kuratowski-ﬁniteness, in contrast, is
based on a positive aspect of ﬁniteness. Intuitively, an object is Kuratowski-ﬁnite, if and only if, we can
provide an inductive proof that it is ﬁnite. This induction is based on the facts that the empty object and
the singletons are ﬁnite and any binary union of ﬁnite objects is ﬁnite too.
Deﬁnition 7 (Kuratowski-ﬁnite) In a topos T , A is Kuratowksi-ﬁnite (K-ﬁnite), if and only if, the fol-
lowing holds:

∀z ∈ ΩΩA([0 → A] ∈ z∧∀a ∈ A({a} ∈ z)∧∀y ∈ ΩA∀y(cid:48) ∈ ΩA((y ∈ z∧ y(cid:48) ∈ z) ⇒ (y∪ y(cid:48)) ∈ z) ⇒ [idA] ∈ z)

Considering K(A) as the sub-object of ΩA formed by the K-ﬁnite subobjects of A, we have (cf. [13]):
a) 0 e 1 are K-ﬁnite; b) If f : A → B is an epimorphism and A is K-ﬁnite then B is K-ﬁnite too; c)
B,C ∈ K(A), if and only if, B∪C ∈ K(A); d) If B and C are K-ﬁnite then B +C and B×C are K-ﬁnite; e)
If A is K-ﬁnite and B ∈ ΩA and B is complemented then B is K-ﬁnite too; f) X is K-ﬁnite, if and only if,
K(X) is K-ﬁnite.

In both ﬁniteness notions above it is possible to have a non-ﬁnite sub-object of a ﬁnite object. It
happens in any topos that does not have always complemented sub-objects. This is the case in all non-
classical toposes. Example of these toposes are used in the computational deﬁnitions in the sequel and in
the examples in Section 3. The third notion of ﬁniteness is reported here only as matter of completeness.
It involves the existence of a NNO in the topos. We are not considering that NNO is an essential starting
point for deﬁning a computational model. In a topos having NNO, any Peano-ﬁnite object is a K-ﬁnite
and a D-ﬁnite object. A natural number object is a rather categorical deﬁnition of natural numbers in a
category. It states that there is an object N with two morphisms 0 : 1 → N and s : N → N, such that, for
any other object A and morphisms g : 1→ A and h : A→ A, there is one and only one morphism f : N → A,
such that the primitive recursive equations f (0) = g(0) and f (s(n)) = h( f (n)) hold categorically. NNO

14Remember that a M-Set is an action M× B (cid:55)→ B.

E.H.Haeusler

71

allows us to deﬁne any primitive recursive function inside its category. Thus, in a topos having a NNO,
the relation less-than is deﬁned, by primitive recursion, stating that (cid:104) is a sub-object of N × N. We deﬁne
[p] ≈ {0, . . . , p− 1}, as a sub-object of N using Ω axiom:

[p]

(cid:104)

!

1

p

/ N × N π2

/ N suc /

/ N

Deﬁnition 8 (Cardinal-ﬁnite) In a topos T with NNO, A is c-ﬁnite, or Peano-ﬁnite, if and only if, A is
isomorphic to [p] for some p : 1 → N.

5 Strong Church-Turing thesis inside toposes

In this section we discuss the relationship among NNO existence, classical logic reasoning and the
(strong) Church-Turing thesis inside an arbitrary topos. The intention of this discussion is to reinforce
conceptual and philosophical aspects on the Church-Turing thesis drawn in [19] that point out to the
direction we follow in this article, when we consider ﬁniteness more basic than Natural Numbers in the
study of eﬀectiveness.

The following argument is found in [18] and speciﬁcally in [16] using the language of CT. Consider
the Strong Church Thesis (SCT) “Every function from N in N is computable.” A function is computable
if and only if there is a program that computes it. Any program can be expressed by its code that, in its
turn can be viewed as a natural number. Thus, STC is expressed by the following number-theoretical
formula:

∀ f ∃p∀n∃y· (T(p,n,y)∧ Out(y) = f (n)),

where T(p,n,y) is Kleene’s T predicate and Out(y) is Kleene’s output function. The meaning of T(p,n,y)
is that p when running over n produces the Turing machine conﬁguration y. Using the Peano Arithmetic
we can obtain T and Out as primitive recursive predicate and function respectively. Thus, in any topos
with a Natural Number object, T and Out are primitive recursive too. In Local Set Theory, SCT is of
form:

∀ f NN∃pN∀nN∃yN(T(p,n,y)∧ Out(y) =N f (n)).

Considering an arbitrary topos having a Natural Numbers object, and having classical logic as inter-
nal logic, it can be shown that SCT is inconsistent with the statements above, namely, in this topos SCT
cannot hold. Using the fact that classical logic satisﬁes the law of excluded middle, the deﬁnition for g
as follows:

(cid:40) m + 1 if ∃ jN(T(n,n, j)∧ Out( j) = m)

g(n) =

0

otherwise

is provable to be deﬁned for every n. Thus g is a total function, and hence by SCT has a program p.
However, any program p ∈ N that implements g is such that g(p) = (g(p)) + 1, since there is j, such that,
T(p, p, j) and Out( j) = m and (g(p)) = m + 1. This is not possible, so SCT is inconsistent with the law of
the excluded middle in a topos having a Natural Numbers object.

Let us analyze the alternatives when deﬁning a topos of computable morphisms. It may have the

following properties:

1. The internal logic of the topos is classical;

/
/




/
/
72

Finiteness and Computation

2. Every morphism in the topos is eﬀective, i.e., SCT holds in the topos;
3. The topos has a Natural Numbers object.

We have just shown that 2 is inconsistent with 1 and 3, so either we drop out classical logic or the
existence of Natural Numbers object. If we deﬁne a topos with a non-classical internal logic we end up
revisiting the well studied eﬀective topos, see [11]. On the other hand, if we drop out item 2, we obtain
with 1 and 3 the also well studied classical theory of recursive functions. The last alternative is to drop
out the existence of a Natural Numbers object. In a naive setting, 1 and 2 together entail ﬁnite sets and
ﬁrst-order ﬁnite domain logic. The deﬁnition of Turing machines by means of only ﬁniteness notions
can shed some light on computations expressed inside a topos without NNO. This is what the following
section does. Finally, the deﬁnition of Turing machines by means of only ﬁniteness notions can shed
some light on computations expressed inside a topos without Natural numbers.

6 Turing Machines in Local Language

In this section we detail our ﬁniteness-parametric Turing-computable functions inside toposes that may
not have natural numbers objects. The potential cases of internal standard Turing machines representing
the external non-standard are: (1) Inﬁnitely long programs; (2) Inﬁnitely many branching, and; (3)
Inﬁnitely long traces inside ﬁnitely long ones; as remarked in Section 8. In the sequel we sometimes use
T.M. for denoting a Turing machine.

In this subsection we express Turing Machines by means of a local language. We consider that
ﬁniteness is essential for the deﬁnition of any computational model. Instead of ﬁxing a speciﬁc ﬁnite-
ness notion, we use it as a parameter. So, consider f in(X) a predicate that deﬁnes a ﬁniteness notion.
In the usual (set-theoretical) deﬁnition of a Turing Machine, as found in [10]15 for example, we have
(cid:104)Q, Σ,{qo},{q f}, δ(cid:105), and, δ ⊆ 2Σ×Q×{←,→}×Σ×Q. Q and Σ have to be ﬁnite and non-empty sets of states and
symbols, and δ, the transition function, is ﬁnite as a consequence of the ﬁniteness of Q and Σ, and the fact
that the power set of a ﬁnite set is ﬁnite. Besides that, the elapsed time of any meaningful computation
has to be ﬁnite. The behavior of the Turing Machine is described by the deﬁnition of ˆδ16. We proceed in
deﬁning the semantics of a Turing Machine, in a topos without NNO. It is important to remember that in
a topos with NNO, the ﬁniteness notions collapse to Peano-ﬁniteness.
Deﬁnition 9 (Turing Machine in LST) Let Σ and Q be types and XΣ, Y Q, qQ
f variables, then T,
a variable of type Q× Σ× Q× Q× [Q× Σ → P(Q× Σ× 2)] is a Turing Machine, if and only if, π1(T) =
X ∧ π2(T) = Y ∧ (π3(T) ∈ X)∧ (π4(T) ∈ X)∧ f in(X)∧ f in(Y). We denote this predicate as T M(T).

o and qQ

The type 2, in the above deﬁnition, is used to denote Right and Le f t, the directions of a possible
moving in a one-step transition of the Turing Machine. The deﬁnition above regards to non-deterministic
Turing machines. As we will see in the sequel, there are non-standard external behavior in case we con-
sider deterministic (only) Turing machines too. The possibility of hypercomputational external behavior
happen in both cases, deterministic and non-deterministic, but the sort of hypercomputational behavior
caused by non-determinism does not seem to be emulated by the deterministic version.

Note that we do not have the type of the Turing Machines in this formalization. We have chosen this
way, in order to not have to ﬁx a type for states and alphabets. Whenever we refer to a Turing Machine

15In [10] the alphabet distinguishes input and working symbols, here this distinction is not relevant
16 ˆδ is the function from T.M. conﬁgurations into the power set of T.M. conﬁgurations that represents the transitive/reﬂexive
closure of the transition δ. It is usually deﬁned in Theory of Computation textbooks by means of (cid:96)(cid:63) the relation between T.M.
conﬁgurations entailing the transitive closure of the one-step transition table, see [10] for example

E.H.Haeusler

73

T, it is a variable x of the type Q× Σ× Q× Q× [Q× Σ → P(Q× Σ× 2)], for some types Q and Σ, such that
T M(x). In the sequel, we show, in an informal way, the deﬁnition of the behavior of a Turing Machine
T = (cid:104)X,Y,qo,q f ,Z(cid:105), with adequate typing corresponding to Q× Σ× Q× Q× [Q× Σ → P(Q× Σ× 2)].
Consider a type Pos, a variable ZPos and a variable XΣ. HΣPos is a tape, if it satisﬁes Tape(HΣPos) ⇔
f in({pPos | H(p) (cid:44) “ ”}) ∧ ¬ f in(Pos)17.
In a Turing machine tape, the non-blank cells must be only
ﬁnitely many. Besides that, there is no limit in the tape for storing symbols.
Deﬁnition 10 (Closure) The behavior of T is ˆδ (a variable of type deﬁned in the sequel). It is speciﬁed
by means of the following variables (implicitly locally quantiﬁed) and predicates. At the end we have the
morphism computed by T.

• H : Pos −→ Σ, such that Tape(H)
• fδ

: P(Q × Pos × T f in) −→ P(Q × Pos f in × Q),

fδ(S 1) = S 2 ⇔
S 2 = {s | ∃s1 ∈ S 1(π4(T)(π1(s1), π2(s1), π3(s1)) = s ∧ Tape(π3(s1))}, where π4(T)(X,Z, H) is an
usual translation for the local typed language of the one-step of a Turing Machine, possibly non-
deterministic, T, in state X, on position Z, and tape H.

• Con f ig(X) = {S ⊆ X : fδ(S ) ⊆ S}

• i : S t(X) (cid:44)→ P(X) has left adjoint O : P(X) → S t(X), O(Z) =(cid:84){S ∈ S t(X) : Z ⊆ S}

such

that

• O◦ i is a closure operator, thus we have ˆδ = O◦ i
• f ={(cid:104)xΣ(cid:63)

,yΣ(cid:63)(cid:105)/(cid:104)q,zPos,yT(cid:105) ∈ ˆδ◦(cid:104)qQ

a similar closure deﬁnition and application has to be done.

0 ,oPos, xT(cid:105) and f inal(q)}. Here, to obtain Σ(cid:63), the type of strings,

This deﬁnition uses a technique from [3] to denote orbits in arbitrary toposes, without NNO. It is impor-
tant to note that if the topos has a NNO, then the closure deﬁned above is just Kleene closure.
Having deﬁned the concept of a morphism being Turing computable in a topos, we have that: In
S etsG, G a particular free group, with f in(A) = Dedekind(A), then S etsG |= ∃W( f in(W)∧¬ f in(P(W)).
Hence in S etsG, a T.M. with states in W is a non-standard computational model possibly with a D-
inﬁnitely long program, or a D-inﬁnitely branching non-deterministic behavior.
In S ets0→1 with f in(A) = Kuratowski(A), then S ets0→1 |= ∃W( f in(W) ∧ ∃V(V ⊆ W ∧ ¬ f in(V))).
Thus, a T.M. with states in W can be a non-standard computational model able to K-ﬁnitely compute on
K-inﬁnitely long transitions.

We provided here arguments in favor of a kind of non-standard ﬁniteness phenomena inside M-Sets.

They justify in details what is observed in the conclusion of our work (Section 8).
Fact 1 Let M be the free monoid generated by {mi/i ∈ N} A={an/n ∈ N}, B={bn/n ∈ N}, and C = A∪ B
Let C : M×C → C be the action of M on C, such that,

 ak

bk
bk

C(mn, x) =

if x = ak and k (cid:44) n
if x = ak and k = n
if x = bk

Any injective morphism F : C → C is the identity IdC. This is justiﬁed by observing that, if F was not
the identity, then there would exists n, such that, f (an) (cid:44) an. Thus, f (an) = x (cid:44) an ⇒ C(mn, x) = x, for
an is the only element of A∪ B changed by the action C18 then, f (bn) = f (C(mn,an)) = C(mn, f (an)) =
C(mn, x) = x = f (an). This cannot be possible.

17The symbol “ ” denotes blank in the cell.
18Note that we confuse the set with the action.

74

Finiteness and Computation

Let G : B (cid:55)→ B be an injective function that is not bijective. The action B(mn,bk) = G(bk) is not

Dedekind-ﬁnite. Thus, B is a Dedekind-inﬁnite object inside a Dedekind-ﬁnite object in M-Sets.
Example 4 It is also possible to have arbitrarily many disjoint inﬁnite sub-objects of C Let C : M× (A∪
B∪ D) → (A∪ B∪ D) be the action of M on C, such that,



C(mn, x) =

ak
bn
bk
cn
ck

if x = ak and k (cid:44) n
if x = ak and k = n
if x = bk and k (cid:44) n
if x = bk and k = n
if x = ck

Any injective morphism F : C → C is the identity IdC. The same argument used in fact 1 is used to prove
that if f (an) = x (cid:44) an ⇒ C(mn, x) = x, then, f (bn) = f (C(mn,an)) = C(mn, f (an)) = C(mn, x) = x = f (an).
That is not possible. On the other hand if each of B and D and A are inﬁnite sets then there are G : B (cid:55)→ B
and H : D (cid:55)→ D injective functions that are not bijective. The actions B(mn,bk) = G(bk) and D(mn,ck) =
H(ck) prove that both, B and D are not Dedekind-ﬁnite.

In [6], a categorical presentation of recursiveness is provided using CT. It axiomatizes categories
able to deﬁne primitive recursive morphisms in a completely abstract way. Using the internal language
of the category it is possible to precisely deﬁne any primitive recursive function. This work is very inter-
esting, since, it joins in a quite harmonious way a model-theoretic deﬁnition with a proof-theoretic one.
The identity present in the meta-theory provides meaning for a theory of equality between intention-
ally distinct ways of deﬁning the primitive recursive functions. Besides that no mention on a concrete
numerical system of even richer deﬁnition of natural number is needed, but primitive recursiveness.

7 There are inﬁnitely many ﬁniteness deﬁnitions

As a matter of curiosity, we show that there are inﬁnitely many deﬁnitions of ﬁnite. The following
deﬁnition is from [20].
Deﬁnition 11 (Squire-ﬁnite) Let p ∈ N, p (cid:44) 0. Let φp be any formula expressing that there is at most p
i< j≤p+1(xi = x j). Thus,

things, for example, φp = ∃x1∃x2 . . .∃xp∀y(y = x1 ∨ y = x2 . . .∨ y = xp), or, φp =(cid:87)

A is Lp-ﬁnite, if and only if:

• Lp(A) is the upper-semi-lattice generated by {S : S ∈ 2A and S |= φp}
• ˆidA : 1 → ΩA factors as:

1

ˆidA

/ ΩA

Lp(A)

Note that the formula(cid:87)

since each xi and y has to be assigned to an “element” e : 1 → A of A, anyway.

i=1,p(y = xi) can be also taken as φp. The quantiﬁers are not essential to this end,

The ﬁrst thing that we have to observe is that in Sets every set that is Lp ﬁnite is ﬁnite. L1-ﬁniteness
is basically Kuratowski-ﬁniteness. Thus, any ﬁnite set is L1-ﬁnite and hence it is also Lp-ﬁnite, for any
1 ≤ p. On the other hand, if a set A is Lp-ﬁnite, this means that A ∈ Lp(A), since the arrow ˆidA factors

!
!
!
!
/
<
<
<
<
E.H.Haeusler

75

through Lp(A) says this. Besides this, as we already said, Tarski proved that Dedekind, Kuratowski and
Peano-ﬁniteness are equivalent. Thus, as A ∈ Lp(A) means that the cardinality, card(A) is less than or
equal to 22p in sets, then A is Peano-ﬁnite and hence ﬁnite in a very intuitive sense.
Fact 2 Let A be a set that it is Lp-ﬁnite, for some p (cid:44) 0. So A is Peano-ﬁnite, Dedekind-ﬁnite and
Kuratowski-ﬁnite.

Besides that, we have the following facts.

Fact 3 Let q ≤ p. If A is Lq ﬁnite then it is Lp ﬁnite.
Fact 4 In M-Sets, there are objects Lp ﬁnite that are not Lq ﬁnite, q ≤ p.

The ﬁrst fact is obvious from the deﬁnition of φp and the observation that Lp(A) includes Lq(A), thus
every A that factors through Lq(A) factors through Lq(A) too. The second fact is a bit involving. Consider
the monoid M =(cid:104){1≤ . . .≤ p},∨,1(cid:105). Thus, i∨ j = max(i, j) = j∨i. In the category of the M−S ets, M itself
is an M− S et. The sub-objects of M as an M− S et, are in one-to-one correspondence with the subsets of
{1, . . . , p}, closed by the operation ∨. This sub-objects are the ﬁnal segments of the form {k, . . . , p}, k ≤ p.
The lattice is a linear order, thus, the upper-semi lattice generated by the sub-objects are themselves. In
this sense, a Lq-ﬁnite sub-object of M is formed by the unions of the generators {k, . . . p}, k ≤ p. Then,
this Lq-ﬁnite set is not Lq−1 − f inite, for the generators this turn are {2, . . . ,q},{3, . . . ,q}, . . . ,{q}. They do
not include 1, so {1, . . . ,q− 1} does not factor through Lq−1. Hence, this M is not Lq−1-ﬁnite.

8 Conclusion

In some mathematical universes, e.g. M-Sets, ﬁnite objects may not share essential properties with their
Sets counterparts. Finiteness is relative. The ﬁrst example in Section 3 was carried out using a rather
intuitive notion of ﬁniteness. Given a property F(S ) that provides a ﬁniteness deﬁnition for S , in LST,
and a topos T , we can express Turing machines (TM) and their semantics in T itself. In Deﬁnition 10
some eﬀort is need to deﬁne TM-semantics without natural numbers. f : A → B in T is TM-computable,
if and only if, there is a TM that has f as semantics. What is interesting in this general deﬁnition of
TM computability is that, without appealing to inﬁnitely long computations and programs, as well non-
deterministic branching, for the TMs are internally ﬁnite, programs and branching can be externally
inﬁnite. We intend to see how this is related to computation on inﬁnite-time Turing machines ([9]), but
at the present stage of the research and the lack of space we can not provide any deﬁnite result.

Finally, we would like to comment on some recent analysis on the status of Turing-Church thesis, by

Sieg, Dershowitz and Gurevich, in [19] and [5], for example.

Wilfried Sieg, in [19], observes that Turing-machines and λ-calculus are not explicitly number-
theoretic based models of computation, instead, they take seriously boundedness and locality as basic
concepts in computation. Boundedness and locality are ﬁniteness aspects of the computational under-
lying model. This is justiﬁed in [19], where Church’s citations on the adequateness of the restrictions
of ﬁniteness on the machines regarded the ordinary notion of computing (see pg. 6 of [19]). This is
precisely the main restrictions Turing states in his seminal article. The argument that Church follows,
according [19], is to reserve Turing’s analytic steps: “a human calculator, provided with pencil and paper
and explicit instructions, can be regarded as a kind of Turing machine”. It seems to be clear, at least
for Sieg, Dershowitz and Gurevih, that the unique aspect of Turing’s work on analytically exploiting
the limitations of the essential abilities of the human computing agent, in order to take basic principles
for his machine deﬁnition, point out to ﬁniteness restrictions (boundedness and locality) on computors

76

Finiteness and Computation

(human computing agent) and computing machines. The work of Sieg is important when it points out
that ﬁniteness is a quite relevant aspect of computing. We cannot forget, however, that the approaches
by G¨odel and Kleene have taken the study of eﬀectiveness to the number-theoretic level. At this level,
ﬁniteness was granted for free. Under this number-theoretic approach, our work is meaningless, since
a category with NNO and eﬀectiveness deﬁned on top of Natural Numbers, is not diﬀerent from the
classical recursion theory. A topos with NNO, as seen in Section 5, does not provide much alternative
model-theoretic properties when compared to classical recursion theory. We can say that we followed
the foundational/historical arguments that are in [19] and [5] to an extent that they do not consider. Both
works turn back to the number-theoretic aspect of computing in order to either follow an empirically
based discussion ([19]) or to provide a kind of proof of Church-Turing thesis ([5]). We can observe that
taking Natural Numbers as the basic elements when deﬁning computational models, was an historical
moving that led to many interesting and important equivalences. However, what does it remain when we
drop Natural Numbers ? This is the kind of question that we started to answer by modeling computation
inside toposes as we shown here.

9 Acknowledgements

We would like to thank prof. Luiz Carlos Pereira and the project Logic in Ilha Grande that motivates
the initial ideas on the research reported here. We are thankful to Peter Arndt, whose seminars pointed
out to me the many facets of ﬁniteness provided by topos-theoretic models. We are also grateful to prof
Gilles Dowek for the discussions on the Turing-Dedekind machines and the viability of their use on
standard computational models. The statement of what is relative concept in mathematics was ﬁrstly
provided by him in an informal meeting. Bruno Lopes, Hugo Macedo, Ranieri Batista and Jeﬀerson
Santos have read previous versions of this article. We thank them very much. Finally we would like to
thank the referees of the DCM2015 ﬁrst submitted version, particularly the referee that pointed out other
works that consider seriously the concept of ﬁniteness as being more basic than the Natural Numbers in
eﬀectiveness deﬁnition.

References

[1] J. Ad´amek & J Rosick´y (1994): Locally presentable and accessible categories. Cambridge University Press,

doi:10.1017/CBO9780511600579.

[2] J. L. Bell (1988): Toposes and Local Set Theories. Oxford Logic Guides 14, Oxford Univ. Press.
[3] J. B´enabou & B. Loiseau (1994): Orbits and monoids in a topos.

J. of Pure and Applied Algebra
92(1), doi:10.1016/0022-4049(94)90045-0. Available at http://www.sciencedirect.com/science/
article/pii/0022404994900450.

[4] B. Jack Copeland (2015): The Church-Turing Thesis. In Edward N. Zalta, editor: The Stanford Encyclopedia

of Philosophy, summer 2015 edition.

[5] Nachum Dershowitz & Yuri Gurevich (2008): A natural axiomatization of computability and proof of

Church’s Thesis. Bulletin of Symbolic Logic 14(03), pp. 299–350, doi:10.2178/bsl/1231081370.

[6] S. Eilenberg & C.C. Elgot (1970): Recursiveness. ACM monograph series, Academic Press. Available at

https://books.google.com.br/books?id=hvruAAAAMAAJ.

[7] P. Gabriel & F. Ulmer (1971): Lokal pr¨asentierbare Kategorien. Lecture Notes in Mathematics 221, Springer-

Verlag.

[8] Robert. Goldblatt (1979): Topoi, the categorial analysis of logic. North-Holland.

E.H.Haeusler

77

[9] Joel David Hamkins & Andy Lewis (2000): Inﬁnite time Turing machines. J. Symbolic Logic 65(2), pp.

567–604, doi:10.2307/2586556.

[10] J.E. Hopcroft, R. Motwani & J.D. Ullman (2001): Introduction to Automata Theory, Languages, and Com-
putation. Addison-Wesley series in computer science, Addison-Wesley. Available at https://books.
google.com.br/books?id=omIPAQAAMAAJ.

[11] J.M.E. Hyland (1982): The Eﬀective Topos. In A.S. Troelstra & D. van Dalen, editors: The L. E. J. Brouwer
Centenary SymposiumProceedings of the Conference held in Noordwijkerhout, Studies in Logic and the
Foundations of Mathematics 110, Elsevier, pp. 165 – 216, doi:10.1016/S0049-237X(09)70129-6. Available
at http://www.sciencedirect.com/science/article/pii/S0049237X09701296.

[12] Peter Johnstone (1979): Automorphisms of Ω. Algebra Universalis 9(1).
[13] P. T. Johnstone (1977): Topos Theory. Academic Press.
[14] A. Kock, P. Lecouturier & C. J. Mikkelsen (1975): Model Theory and Topoi: A Collection of Lectures by
Various Authors. chapter Some topos theoretic concepts of ﬁniteness, Springer Berlin Heidelberg, Berlin,
Heidelberg, pp. 209–283, doi:10.1007/BFb0061297.

[15] Michael. Machtey & Paul Young (1978): An introduction to the general theory of algorithms. North-Holland.
[16] Colin McLarty (1992): Elementary categories, elementary toposes. Oxford University Press.
[17] H. Rogers (1987): Theory of Recursive Functions and Eﬀective Computability. MIT Press.
[18] Stewart Shapiro (2011): Varieties of pluralism and relativism for logic. A companion to relativism, pp.

526–552, doi:10.1002/9781444392494.ch27.

[19] Wilfried Sieg (2008): Church Without Dogma: Axioms for Computability. In S.Barry Cooper, Benedikt Lwe
& Andrea Sorbi, editors: New Computational Paradigms, Springer New York, pp. 139–152, doi:10.1007/978-
0-387-68546-5 7.

[20] R. Squire: Appears as private communication in many references in many articles. We used as reference the

Master dissertation of Peter Arndt, Universidade de Campinas, Departamento de Filosoﬁa, 2005.

[21] Alfred Tarski (1924): Sur les ensembles ﬁnis. Fundamenta Mathematicae 6, pp. 45–95.

