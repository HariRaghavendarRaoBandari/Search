Learning Shared Representations for Value Functions in Multi-task

Reinforcement Learning

Diana Borsa
Thore Graepel
John Shawe-Taylor
University College London, Dept. of Computer Science, CSML, London WC1E 6EA, UK

DIANA.BORSA@GMAIL.COM
THORE@GOOGLE.COM
J.SHAWE-TAYLOR@CS.UCL.AC.UK

6
1
0
2

 
r
a

M
7

 

 
 
]
I

A
.
s
c
[
 
 

1
v
1
4
0
2
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

We investigate a paradigm in multi-task rein-
forcement learning (MT-RL) in which an agent
is placed in an environment and needs to learn
to perform a series of tasks, within this space.
Since the environment does not change, there
is potentially a lot of common ground amongst
tasks and learning to solve them individually
seems extremely wasteful.
In this paper, we
explicitly model and learn this shared structure
as it arises in the state-action value space. We
will show how one can jointly learn optimal
value-functions by modifying the popular value-
iteration and policy-iteration procedures to ac-
commodate this shared representation assump-
tion and leverage the power of multi-task super-
vised learning. Finally, we demonstrate that the
proposed model and training procedures, are able
to infer good value functions, even under low
samples regimes. In addition to data efﬁciency,
we will show in our analysis, that learning ab-
stractions of the state space jointly across tasks
leads to more robust, transferable representations
with the potential for better generalization.

1. Introduction
Reinforcement learning (RL) has gained a lot of popular-
ity and has seen remarkable successes in the last years,
exploiting and beneﬁting greatly from the recent develop-
ments in general functional approximators, such as neural
networks (Mnih et al., 2015). At least part of this suc-
cess seems to be linked to the ability of these universal
functional approximators to distill meaningfully represen-
tations (Bengio, 2009), from high-dimensional input states.

These enabled RL to scale up to more complex environ-
ments and scenarios that were previously prohibited or re-
quired a great amount of feature engineering as shown in
(Mnih et al., 2015), (Silver et al., 2016). Thus, learning
a good abstraction of a given environment and the agent’s
role in it, seems to be a key component in developing com-
plex and optimal control mechanisms.
While a lot of progress has been made in improving learn-
ing on individual single tasks, there seems to have been a
lot less work in trying to re-use or efﬁciently transfer in-
formation from one task to the another (Taylor & Stone,
2009b). Nevertheless, it is natural to assume that the differ-
ent tasks an agent needs to learn during its life, share a lot
of structure and in-build redundancy. And potentially this
could be leverage to speed-up learning. In this work we
will propose a way to address this aspect, by learning ro-
bust, transferable abstractions of the environment that gen-
eralize over a set of tasks.
Value functions are a central ideas in reinforcement learn-
ing (Sutton & Barto, 1998) and have been successfully used
in conjunction with functional approximators to generalize
over large state-action spaces. They are a concise way to
readily assess the ”goodness” of a state and can be learnt
efﬁciently even in an off-policy fashion. This enables us
to decouple the data gathering and the learning process,
but most importantly this allows us to re-use past experi-
ences collected under arbitrary or exploratory policies (Sut-
ton & Barto, 1998). More recently, value functions have
been shown to exhibit a very nice compositional structure
with respect to the state space and goal states (Schaul et al.,
2015). This is consistent with earlier studies in (Sutton
et al., 2011) that suggest value functions can capture and
represent knowledge beyond their current goal that can be
leveraged or re-used. Similar structures have been iden-
tiﬁed in the hierarchical reinforcement learning literature
(Dietterich, 2000) or (Sutton et al., 1999). These all mo-
tivated our choice of explicitly modelling the presence of
this shared structure in the state-action value space.

Learning share representations for value functions in Multi-Task RL

Using a multi-task RL formulation and following the re-
cent work done in (Calandriello et al., 2014), we ﬁrstly
outline two general ways of learning RL tasks jointly and
sharing knowledge across them by extending two of the
most popular procedures for learning value function, Fitted
Q-Iteration (Ernst et al., 2005) and Fitted Policy Iteration
(Antos et al., 2007), to accommodate this shared structure
assumption. Furthermore, taking advantage of the multi-
task methods developed in supervised settings, we extend
the work in (Calandriello et al., 2014) to account for task-
speciﬁc components.
We will also show empirically that these lead to an over-
all improvement on the policies inferred, as well as a de-
crease in the number of samples per task needed to achieve
good performance. We explore the nature of the repre-
sentation learnt and its potential transferability to new, but
related tasks. We show this learning is able infer a com-
pressed structure that nevertheless captures a lot of trans-
ferable knowledge, similar to option-like transition models
(Sutton et al., 1999) – without us ever specifying a parti-
tion of desirable states or subgoals. Finally we will argue
that this way of learning, leads to more robust and reﬁned
representations which are deemed crucial for learning and
planning in complex environments.

2. Proposed Model
2.1. Background and Notation

We deﬁne a Markov Decision Process (MDP) as a tuple
M = (S,A,P,R, γ), where S is the set of states, A is the
set of actions1, P : S × (S × A) → [0, 1] is the transition
dynamics P(s(cid:48)|s, a) which provides a probability over next
state s(cid:48), R : S × A → R is a reward signal, which is as-
sumed to be bounded (∃Rmax, s.t. R(s, a) ≤ Rmax,∀s ∈
S, a ∈ A) and γ ∈ [0, 1] is a discount factor.
Given an MDP and any policy π : S × A → [0, 1], we de-
ﬁne the (state-action) value function, Qπ(s, a) as the dis-
counted cumulative reward an agent is expected to collect
when starting from state s ∈ S, taking action a ∈ A and
then act accordingly to policy π:

(cid:35)

(cid:34) ∞(cid:88)

t=0

Qπ(s, a) = Eπ,P

γtrt|s = s0, a = a0

(1)

The expectation is over all trajectories starting in (s, a) and
obtained by interacting with the environment (P) while fol-
lowing behaviour policy π.
Our goal is to learn an optimal behaviour with respect to
this expected cumulative reward. Thus we are looking for
π∗ s.t.

π∗(s, a) = arg max πQπ(s, a)

(2)

1in this work this will be a ﬁnite set

We will denote this optimal value function as Q∗ = Qπ∗
.
And note that ﬁnding Q∗, automatically gives us an optimal
policy π∗ by acting greedily with respect to these values.
In the following, we denote this greedy operation by π∗ =
GQ∗.

2.2. Problem formulation

We will consider the scenario in which an agent resides (or
is placed) into an environment in which it needs to perform
a series of tasks. The overall goal is to learn how to suc-
ceed at all these tasks. The environment is described by a
state-action space S × A and a transition kernel P(s(cid:48)|s, a)
and the tasks can be speciﬁed by different rewards signals
Rt(s, a), one for each task t = 1, T . This formally gives
rise to T MDPs Mt = (S,A,P,Rt, γ) which share a lot
of structure. Thus, if we can ﬁnd a way to leverage this
structure, we expect this to aid the learning process and
lead to better generalization. (Taylor & Stone, 2009a)

2.3. A shared (value function) representation

We propose to model the shared structured found in above
deﬁned MDP-s as a shared embedding of the state-action
space φ : S × A → Rd on which we can build the individ-
t}t=1,T for all considered
ual optimal value functions {Q∗
tasks and potentially new ones. Thus in this paper we are
interested in learning this shared embedding as well as ulti-
mately the optimal behaviour for each of the tasks consid-
ered. In the following, we will present how one can extend
two of the most popular paradigms of learning value func-
tions, Fitted Q-Iteration and Fitted Policy Iteration, to in-
corporate this shared structure assumption. This will come
down to employing a multi-task learning procedure in the
target-ﬁtting step of Q-Iteration and in the policy evaluation
step of Policy-Iteration.

3. Multi-task (Fitted) Value Iteration
In this section we outline a general framework of using
approximate value iteration to infer the optimal Q-values
(and optimal policies) for a set of tasks, in a given en-
vironment following the MT-RL setup previously intro-
duced. The proposed algorithm is an extension of Fitted
Q-Iteration (FQI) that allows for joint learning and transfer
across tasks. Following the recipe of FQI, at each step in
the iteration loop and for each sample in our experience set
D = {(s, a, r, s(cid:48))|s(cid:48) ∼ P(.|s, a)}, we compute the one-
step TD target based on our current estimate of the value
function. Then, treating these estimates as ground truth,
we obtain a regression problem from the state-action space
onto the TD targets (which are really place-holders for the
true value function). In the case of MT-RL, we will ob-
tain such a regression problem for each task t. Now we
could, in principle, solve all these regression problems in-

Learning share representations for value functions in Multi-Task RL

Figure 1. Proposed Model: Enforcing a shared representation of the state-action space, to be used in modelling all value functions, {Qj}
across a set of tasks j = 1, T .

dependently for each task, which would amount to apply-
ing FQI individually to each task. But our assumption is
that there is shared structure between tasks and we would
like to make use of this common ground to aid the learning
process and arrive at more robust abstractions of the input
space. Thus we propose solving the regression problems
jointly, accounting for and building upon a common repre-
sentation. A detailed description of the proposed procedure
is outlined in Algorithm 1.

Algorithm 1 Multi-task Fitted Q-Iteration
Require: D = ∪T

t=1Dt ∼ µ,P - set of experi-

ences/episodes for each task t

Initialize Θ = Θ0, k = 0 (parameters)
while not converged (dΘ < ||k < MaxIter) do

=

{y(k+1)

Compute Targets:
Y (k+1)
γ maxa(cid:48) Q(k)(s(cid:48), a(cid:48))|(s, a, s(cid:48)) ∈ Dt},∀t = 1, T
Multi-task Learning:
t=1Y (k)
Θ(k+1) = MTL(D = ∪T
dΘ = (cid:107)Θ(k+1) − Θ(k)(cid:107), k = k + 1

t=1Dt,Y (k) = ∪T

(s, a)

)

t

t

t

=

Rt(s, a) +

end while

Return:
Θ = {θt}T

t=1 (⇒ Qt(s, a) = fθt(s, a),∀s, a ∈ S × A)

Note that, in the spirit of generalization, we do not specify
a particular algorithm for the multi-task learning step(MTL

in Algorithm 1). There is extensive literature of how to
deal with multi-task inference and exploit shared structure
between tasks in purely supervised settings, and we will
take a look at some instantiations of this step throughout
this work.

4. Multi-task (Fitted) Policy Iteration
By a similar argument as the one presented in the last sec-
tion for MT-FQI, we can extend the framework of general
policy iteration to the MT-RL scenario. Policy Iteration al-
gorithms rely on an alternating procedure between a policy
evaluation step and a policy improvement step. We can ex-
tend this framework to the multi-task case, by deﬁning a
(current) set of policies Π = {πt}T
t=1, one for each task,
and then we evolve this set of policies jointly at each itera-
tion, k. Please ﬁnd an outline of the proposed procedure in
Algorithm 2. For now, we implement the policy improve-
ment step by acting greedily with respect to our current es-
timates of the value function. This step is done individually
for each task.
On the other hand, we allow joint learning and sharing of
knowledge in the policy evaluation step. This gives rise to
a general procedure we will call Multi-task Policy Evalua-
tion (MT-PE)- see Algorithm 3. In MT-PE, we are given a
set of policies Π = {πt}T
t=1, one for each task, and a col-
lection of experiences D = ∪T
t=1Dt. Then the aim of the
algorithm is to approximate the corresponding value func-
tions Qπt
associated with acting out policy πt for task t.
t

(original) State𝑆𝑡𝐴𝑡Action𝑆𝑡+1𝐴𝑡+1𝑆𝑡+2𝐴𝑡+2𝜙(𝑆𝑡,𝐴𝑡)𝑆𝑡+3𝜙(𝑆𝑡+1,𝐴𝑡+1)𝜙(𝑆𝑡+2,𝐴𝑡+2)𝑄𝑗(𝑠𝑡,𝑎𝑡)𝑡𝑎𝑠𝑘𝑠𝑗=1,𝑇𝑄𝑗(𝑠𝑡+1,𝑎𝑡+1)𝑄𝑗(𝑠𝑡+2,𝑎𝑡+2)Learning share representations for value functions in Multi-Task RL

Algorithm 2 Multi-Task Policy Iteration (MT-PI)
Require: D = ∪T

t=1Dt, set of experiences for each task t

Initialize Θ = Θ0, k = 0

Algorithm 3 Multi-Task Policy Evaluation (MT-PE)
Require: D = ∪T

t=1Dt, set of experiences for each task t
t=1, for each task t that need

A set of policies Π = {πt}T
to be evaluated

while convergence not reached (dΘ < ) do

Policy Evaluation:
Compute Θ(k) = MT-PE(D, Π(k)) via Algorithm 3
where Π(k) = [π1,··· , πt,··· , πT ] and Θ(k) =
1 ,··· , θπt
t ,··· , θπT
[θπ1
T ]
Policy Improvement
(a|s)
π(k+1)
j
arg maxa fθπt

arg maxa Qπ(k)

=
(s, a)

(s, a)

=

t

t

t

end while
Return: Θ = {θt}T

t=1 and policies Π = {πt}T

t=1 ≈ Π∗

Note that, in general, this step (policy evaluation) requires
on-policy data, for each policy πt and for each task t. This
could be quite demanding and inefﬁcient data-wise, as the
numbers of tasks grow, not to mention that this is just the
inner loop of another iterative algorithm (MT-PI). In this
work, we opt for an implementation of the policy evalua-
tion step that circumvents this problem. Making use of the
Bellman Expectation Equation, we can compute regression
targets for approximating {Qπt
t } by only using experience
of the form (s, a, rt, s(cid:48)) previously collected, as we did in
the case of Fitted-Q Iteration.
∀(s, a, rt, s(cid:48)) ∈ Dt → y(i)

t (s(cid:48), πt(s(cid:48)))
(3)
Therefore, we have now reduced the original problem to a
set of regression problems that can be solved jointly, under
a shared input space representation. This is very similar
to the multi-task learning step employed in MT-FQI, but
now the shared structure is learnt to model the input set of
policies Π = {πt}T
t=1, rather than the optimal ones. Nev-
ertheless, by constantly improving the set of policies that
are presented to the MT-PE step, we should eventually be
able to convergence to the optimal policies and thus at this
point, the policy evaluation step should be able to recover
the shared structure amongst optimal value functions.

t = rt(s, a) + γQ(i)

5. Multi-task and Representation Learning
In this section will we look at a couple of methods we can
plug into the above algorithms in the M T L step. For this
we will assume a linear parametrization of the state-action
value space -i.e. we assume ∃Φ = {φk : S × A → R} s.t.
all value function of interest Qt can be well approximated
by this linear combination of this set of features.
In the
case of ﬁtted value iteration we want this set of features to
ﬁt well the intermediate targets Y (i), but ultimately we are

Initialize Θ = Θ0, i = 0

while convergence not reached (dΘ < ) do

t (s(cid:48), πt(s(cid:48)))|(s, a, s(cid:48)) ∈ Dt},∀t = 1, T

t

t

=

(s, a)

{y(i+1)

Compute Targets:
Y (i+1)
γQ(i)
Multi-task Learning:
Θ(i+1) = MTL(D = ∪T
dΘ = (cid:107)Θ(i+1) − Θ(i)(cid:107), i = i + 1

t=1Dt,Y (i) = ∪T

t=1Y (i)
t )

=

Rt(s, a) +

end while
Return: Θ = {θt}T

(cid:16)⇒ ˆQπt

t=1

t (s, a) = fθt(s, a) ≈ Qπt

t (s, a),∀s, a ∈ S × A(cid:17)

interested in a set of features that ﬁt well the optimal value
functions Q∗
t and we will see that this turns out to be very
small subspace of the original feature space.

t (s, a) = (cid:104)Φ∗(s, a), wt(cid:105),∀t = 1, T
Q∗

(4)

t

t

t

t

In the case of policy iteration, at each evaluation step we
are interested in having a feature space that well approxi-
mates the value function corresponding to our current poli-
≈
cies Π(k). Thus we are looking for ΦP E s.t. Qπ(k)
(cid:105),∀t = 1, T . As policies improve, we
(cid:104)ΦP E(s, a), wπ(k)
will end up ﬁtting optimal or near-optimal value functions.
Certainly if the regression step can be done perfectly (no
approximation error), policy iteration will continue to im-
prove the policies and in the limit will converge to the op-
timal value functions. Thus, the representation that will
come out of this learning procedure should be similar to
the ones learned by value-iteration procedures. Conse-
quently, ultimately what we want in terms of representation
is a (low-dimensional) features space that spans the optimal
value functions of interest.

5.1. Multi-task feature learning

(cid:105)

(cid:17)

(cid:104)(cid:80)

t L(cid:16)

t Φ, ˆQt
wT

+ H(W )

the joint problem we are try-
In terms of planning,
ing to solve can be formalized as inferring {wt}T
t=1 =
where H(W ) is
arg minW
a regularizer on the weight vectors, that encourages fea-
ture sharing. At the same time, we wish to learn a more
compact abstraction of the state-action space, that will be
shared among tasks. To make this a bit more formal, let
Qt,w : S × A → R, Qt,w(s, a) := (cid:104)Φ(s, a), wt(cid:105), then our

Learning share representations for value functions in Multi-Task RL

{ψi}i=1,Nψ such that ∀t, Qt(s, a) = (cid:80)

assumption can be expressed as: ∃ a small set of features
i αtiψi(s, a) =
(cid:104)αt, U T Φ(s, a)(cid:105) where ψi-s form a basis for the relevant
low-dim subspace.
Thus for each task t, we are trying to solve jointly the fol-
lowing optimization problem:

arg min

f =(cid:104)αt,U T Φ(cid:105)

LDt

ft(s, a), y(k)

t

+ (cid:107)αt(cid:107)2

1

(5)

(cid:34)(cid:88)

t

(cid:16)

(cid:17)

(cid:35)

In (Argyriou et al., 2008) this was shown to be equivalent
to Eq. 6 and can be solved efﬁciently by an alternating
minimization procedure:

(cid:16)(cid:104)αt, U T Φ(s, a)(cid:105), y(k)

t

(cid:17)

LDt

+ H(A)

(cid:35)

(cid:34)(cid:88)

t

arg min
A,U

(6)
where A = [α1,··· , αt,··· , αT ] and this is assumed to be
sparse, take H(A) = γ||A||2

2,1.

5.2. Allowing for task speciﬁcity

The above procedure can be used to construct very infor-
mative shared features – as shown in (Calandriello et al.,
2014) and in our experimental section. However, in a lot of
scenarios tasks can beneﬁt from having a small and sparse
set of features that represent the particularities of each in-
dividual task on top of a low-dimensional shared subspace.
This is deﬁnitely the case in many practical applications
and had been observed in purely supervised settings as well
– it is simply too restricted to constrain all tasks to be us-
ing a single shared structure. Thus researchers have come
up with various ways of incorporating task-speciﬁc com-
ponents — see (Zhou et al., 2011), (Jalali et al., 2010),
(Chen et al., 2012) and reference therein – and showed that
modelling these explicitly can improve both the learning
(accuracy and speed) and interpretability of the resulting
representations. In this work, we choose just one of these
formulations, introduced in (Ando & Zhang, 2005), where
we learn a low-dimensional shared representation U Φ(s, a)
as before, as well as a task speciﬁc vector wt, on which
we place a strong sparsity constraint to encourage common
features to still be identiﬁed and shared.

Qt,θ(s, a) = (wT

t + vT

t U )Φ(s, a)

(7)

Note that if U is a zero matrix, then we will be treating the
task as completely independent and on the other hand if wt
is zero for all tasks, we recover the previous formulation.
Furthermore, we can place an orthogonality condition on
the set of shared features inferred, by enforcing U U T = I.

The resulting optimization problem has the form:

(cid:34)(cid:88)

L(cid:16)

t

(cid:17)

(cid:35)

(wT

t + vT

t U )Φ, ˆQt

+ H(W )

arg

min

U,{vt,wt}T

t=1

(8)
and can be solved by Alternating Structure Optimization
(ASO) – see (Ando & Zhang, 2005).

6. Experiments
We assess the performance and behaviour of our proposed
model and learning procedures in the 4-room navigation
task (Sutton et al., 1999). The state space S is described
by all valid positions an agent might take – any position
in the grid, but the wall and the agent has access to four
actions A = {→,←,↑,↓}. We consider a deterministic
dynamics in those directions and all walls are considered
elastic – bumping into walls has no effect on your state.
Tasks are speciﬁed as target locations in the environment
the agent need to navigate to. These will be sampled at
random from the valid states in the environment. We do not
specify a starting state – agents need to learn to navigate to
the selected goal position from any part of the environment.
When the agent transitions to the goal states, it collects a
positive reward. No other reward signal is provided.
Since all of the proposed methods can be run off-policy,
thus decoupling the experience gathering and the learning,
we sample a modest amount of experience up front for each
of the considered tasks Dt. This can be done, in principle,
by any behaviour policy, but in all our data-gathering we
employ uniformly random exploration.
Once data is gathered or provided, we can proceed with
the learning. All experiments were conducted under a re-
strictive sample budget |Dt| ∈ {500, 750, 1000}. Firstly,
we would like to compare the proposed joint-representation
learning with its single tasks counterparts of FQI and FPI
to see what effects, if any, enforcing and learning a shared
representation would have. We assess the quality of the
inferred greedy policies by the amount of reward they are
able to produce under random starts – this is a proxy for the
real value function V πt, where πt = G ˆQt.

(cid:34) ∞(cid:88)

(cid:35)

emp ≈ Es0∼µ
V πt

γkrk|s0, πt

≈ V πt

k=0

Depending on the selection of starting states, the difﬁ-
culty of the tasks and thus amount of reward achievable
may vary. To ease interpretation, we report the normalized
value of the above estimate, with respect to the optimal
value function at the starting states. Example results for
the ﬁrst 10 training tasks are displayed in Figure 2. These
were obtained by training on 30 randomly sampled tasks
on 500 samples of experience per task. We can see that

Learning share representations for value functions in Multi-Task RL

Figure 2. Quality of the inferred greedy policies, when trained individually and jointly on 30 tasks, with a sample budget of 500 sam-
ples/task. We show the average cumulative reward achieved by the agent from random initial positions – the values are normalized with
emp. We can see that in most cases, the
respect to the optimal cumulative reward achievable from the same starting positions V πt
single-task learning struggles under this sample regime, whereas the joint-learning methods are able to discover much better policies and
even recover the optimal ones.

emp/V ∗

the joint-learning procedures manage to learn good poli-
cies, quite close to optimal ones that substantially outper-
form the single-task learning. Please note that our proposed
extension to allow task-speciﬁc features, in most cases, im-
proves performance, even when considering a very small
set of common features (dshared = 5) - which also gives
us a much faster convergence in the shared subspace. In-
deed, this behaviour seems to be consistent to lower sam-
ples sizes, although it is worth mentioning that divergence
does occur more often in these extrem conditions (very few
samples) and regularization parameters that might ensure
convergence (Calandriello et al., 2014) provide a solution
that is often worse than even the single task. Outside, those
extreme cases, policy and value iteration methods perform
very similarly and as we can see from Figure 3 - 4, that they
tend to converge to the same solution.
To get a better idea of the average task performance we
obtain and how that changes during training, we can look
at the average distance between our estimate of the value
functions at iteration k and the optimal ones Q∗
t . For this
small environment, these can be computed analytically.
Results for 500 and 1000 samples budgets are displayed
in Figure 3. We observe quite a big difference between
the single-task and multi-task procedures in terms of re-
covering the true optimal value functions. Convergence to
a better MSE happens much faster and we get even asymp-
totic superior solution. Nevertheless, closeness to the opti-
mal value functions in Euclidean space may not necessar-
ily imply the same relation in policy space. A plot of the
quality of policies as a function of value/policy iterations

(cid:80)
t ||V ∗

t − V πt

emp,t||/||V ∗

is available in Figure 4. Here, we report the normalized
t ||. We can see
average regret 1
T
that the policies in general will converge much faster than
the value functions, when comparing with the Q-value con-
vergence in Figure 3. Please also note that the multi-task
Fitted Policy-Iteration procedures inherit the same speedy
convergence present in the single-task counterpart.

6.1. Learnt shared representations

Probably the most interesting phenomenon encountered in
learning these shared representations is the nature of the
low dimensional representations inferred. We visualize the
inferred set of shared features (Figure 5) and their respec-
tive weights in the value-function (Figure 6).
These were produced via MT-FQI with ASO, with the con-
straint that the shared subspace has at most 5-dimensions.
And even this seem to be too permissive, as we actually ob-
tain strong activations only for the top 3 features inferred
ψ1:3 – presented in Figure 5. Thus the learnt representation
is very low dimensional, but at the same time expressive
enough to effectively approximate optimal value functions.

6.2. Transferring knowledge to new tasks

The learnt representations resemble option-like features
(Sutton et al., 1999) that essentially inform the agent,
across tasks, how to navigate efﬁciently between rooms
and negotiate the narrow hallways. These are indeed eas-
ily transferable ’skills’ that can be use in learning a new
task. We test this hypothesis by augmenting the represen-

Task ID12345678910Normalized cummulative reward achieved ≈ Qπt/Q*00.10.20.30.40.50.60.70.80.91joint AFPIjoint AFPI - ASOsingle task AFPIjoint AFQIjoint AFQI - ASOsingle task AFQILearning share representations for value functions in Multi-Task RL

Figure 3. Convergence to optimal value function Q∗, as assessed
by the Euclidean norm ||Q∗ − Q(k)|| for the different sample
complexities: 500 samples/task (top), 750 samples/task (middle),
1000 samples/task (bottom) for the different methods proposed.
We report an average over T = 30 tasks and shaded area corre-
sponds to variances below and above the mean. Note that at 1000
sample/task, all joint-representation learning algorithms obtain
convergence to the true optimal value functions for all tasks. Also
note that between the join-learning methods, the second method,
allowing for task-speciﬁcity(red lines – AFPI-ASO, AFQI-ASO)
yields the better approximations Q(k).

||/||V ∗

t

(cid:80)
t ||V ∗

t − V πt

Figure 4. To evaluate the quality of the policy learnt, we produce
t || for different
an empirical estimate of 1
T
sample complexities: 500 samples/task (top), 750 samples/task
(middle), 1000 samples/task (bottom) for the different methods
proposed. As seen from the convergence plot above, for 1000
samples the multi-task methods will reliably recover the optimal
value functions and implicitly the optimal policies, but so will the
single-task methods in a lot of these tasks. At the same time for
half that budget (500 samples), the multi-task learning is already
able to recover the optimal policies, while the single-task methods
converge to a suboptimal value function (blue lines on the plot).

Learning share representations for value functions in Multi-Task RL

Figure 5. [To be read row-wise] The ﬁrst three most relevant
shared features ψ1:3(s, a) – corresponding to the top three eigen-
values – learnt via AFPI-MTFL under 30 tasks randomly sampled
in the four rooms. Please note that these already enable the navi-
gation between any pair of rooms.

Figure 6. Weighting Coefﬁcients α1:3,t and α2:3,t for the above
three most prominent shared features. We can see from these val-
ues that the ﬁrst feature clearly dominated in all tasks. Bottom:
Rescaled version of α2:3,t such that we can see the activation of
the other two prominent features. Blue corresponds to negative
activation and red to positive ones. Given the nature of the fea-
tures one can readily read out, just by looking at the sign of the
weight, which room that task’s goal state is. For instance, if we
look at second task: negative activation for both ψ2 ⇒ north-side
of the environment and ψ3 ⇒ west-side of the environment. The
goal G2 is indeed located at position (2, 1) in the top-left room.

Figure 7. Average performance on a set of 10 new tasks with and
without transfer of shared features, as assessed by the normal-
ized average cumulative reward collected over 50 random starts
in the environment. The value functions for the new tasks were
produced by (single-task) FQI on original feature φ (no transfer),
and respectively the augmented features space [ψM T F L
, φ] and
[ψASO

, φ] (transfer).

s

s

tation for the new task, with this shared subspace. We in-
vestigate the beneﬁts of having learnt a shared subspace
over a set of training tasks in terms of transferring that
knowledge when optimizing for a new task. We augment
the feature space for the new task, with the learnt features
ψs and then we assess the effect this modiﬁcation has on
learning the new task. In Figure 7, we present an empir-
ical evaluation of the cumulative regret the agent will in-
cur on the inferred (greedy) policy, when trained on the
original representation φ, versus the augmented represen-
tation {ψs, φ}, after seeing a varying amount of samples
N = 50, 200, 300, 500, 700, 1000, 2000. We can see that
the augmented representation is able to produce a good per-
formance under smaller sample sizes. In general, the learn-
ing based on the transferred representation is able to pro-
duce a policy that is equivalent to the ones we could learn
without transfer under twice as much data. This behaviour
is consistent until convergence.

6.3. Connection to Options

As previously, the learnt shared representation seems ac-
count for the general topology and dynamics of the envi-
ronment in the value functions. They nicely partition the
environment into relevant regions to facilitate the global
navigation to a local neighbourhood of the goal. Some of
those features are characteristic of options (Sutton et al.,
1999), skills (Konidaris & Barto, 2007), macro-actions lit-
erature (Dietterich, 2000) and are hve the potential to dras-
tically improve the efﬁciency and scalability of RL meth-
ods (Barto & Mahadevan, 2003), (Hengst, 2002). In the

ψ1(s,↓)246810246810ψ1(s,→)246810246810ψ1(s,↑)246810246810ψ1(s,←)246810246810ψ2(s,↓)246810246810ψ2(s,→)246810246810ψ2(s,↑)246810246810ψ2(s,←)246810246810ψ3(s,↓)246810246810ψ3(s,→)246810246810ψ3(s,↑)246810246810ψ3(s,←)246810246810Coefficients αt (read columns)Task ID (t) 51015202530Weights for (NEW) features ID (Ψi)0.511.522.533.5-300-250-200-150-100-500Coefficients αt (read columns)Task ID (t) 51015202530Weights for (NEW) features ID (Ψ2:3)0.511.522.5-40-30-20-10010203040following we would like to investigate this connection fur-
ther.
Following the formulation in (Sutton et al., 1999), an op-
tion o = (cid:104)I, µ, β(cid:105), is a generalization of primitive actions
a ∈ A to a temporally extended course of action. I is the
initiation set I ⊆ S from which the option is available, µ is
the policy we are going to follow once the options is trig-
gered and β : S → [0, 1] is the probability of termination.
In this case, the value function take the form:

t (s, o) = E
Qπt

P (s(cid:48)|s, o)V π

t (s(cid:48))

 K(cid:88)

k=0

(cid:124)

γkrt,k

(cid:123)(cid:122)

(cid:125)

rt(s,o)

+γK+1(cid:88)

s(cid:48)

ss(cid:48) =(cid:80)∞

where s(cid:48) is in the termination state of options o. We denote
k po(s(cid:48), k)γk, where po(s(cid:48), k) is the probability
P o
that options o will terminate in state s(cid:48) after exactly k steps.
Note that this term accounts for the transition dynamics,
the policy of the option and its termination criteria, all of
which, for us, are task-invariant. Moreover note that for us,
rt(s, o) is generally 0 unless the option happens to hit the
goal. Thus the above equation, simpliﬁes to:

Qπt

t (s, o) =

(cid:124)(cid:123)(cid:122)(cid:125)

P o
ss(cid:48)

task independent(t,πt)

·

V πt(s(cid:48))

(cid:124) (cid:123)(cid:122) (cid:125)

task dependent(t,πt)



(cid:88)

s(cid:48)

Learning share representations for value functions in Multi-Task RL

ton et al., 1999) is given by: Qπ(s, o) = (cid:80)

tion corresponding to this newly deﬁned semi-MDP (Sut-
ss(cid:48), as
V π(s(cid:48)) = const 2.
In this semi-MDP we run FQI and
indeed see that we are able to construct a value function,
based solely on the learnt 5-dim feature space ψs, that suc-
cessfully completes the speciﬁed task. Results for all such
navigation options are available in Figure 8.

s(cid:48) P o





This is a linear combination between the option transition
ss(cid:48) = φµo(s, s(cid:48)) in the termination set (subgoals
models P o
of the option) – which is independent of task t and πt, it
only depends on µo – weighted by the value function of the
termination states for each of the tasks – which incorpo-
rates the dependency on task and the individual policy em-
ployed after the option has terminated. This is very similar
to the parametrization we assumed in Eq. 4. This suggest
that the learnt representation is able to capture and repre-
sent efﬁciently some option-like transition models without
specifying any subgoals, policies nor initial states. We hy-
pothesize that the learnt shared space is actually a com-
pressed basis for these option-transition models. In order
to test this hypothesis, we consider an intuitive set of op-
tions O (like navigation to a particular room) and test if
ss(cid:48) for some option o ∈ O and
this learnt basis can span P o
can successfully represent an option-policy.
We deﬁne an option o1 to be navigating to a speciﬁc room,
say room 1 (NW). The initialization set Io1 is the set of
states outside the room and termination set is any state in
the desired room. We also can deﬁne an MDP that main-
tains the same transition dynamics, state and action space,
but now the reward signal is zero outside the target room
and a constant positive reward in any of the desired ter-
mination states s(cid:48) ∈ room 1. Note that the value func-

Figure 8. Learned greedy policies (as indicated by the arrows) and
value functions (V (s) = maxa(Q(s, a)) ) enabling navigation to
any of the four rooms, based only on the share feature subspace
discovered in the multi-task value function learning of 30 goals
randomly sampled in the environment. The value functions were
learnt using (single-task) FQI on top of features ψASO
and re-
quired 200 samples to recover option-like policies that enable the
agent to reach the desired room.

s

Please note that the above deﬁned options are quite ex-
tended ones. Simpler ones would include making your way
outside a particular room – these are along the lines of the
options deﬁned in (Sutton et al., 1999) and (Stolle & Pre-
cup, 2002) – and these can be easily recovered as well. Ac-
tually for these simpler options we require very few sam-
ples to obtain the desired behaviour (10-30 samples), al-
though they might not be optimal – please consult Supple-
mentary material for details. The fact that we are able to
express a whole variety of such intuitively deﬁned options
– much more than the dimensionality of the common sub-
space on which we are building on – is a clear indication of
the expressiveness of this shared representation and its po-
tential transferability in aiding learning of new tasks within

2This is actually true, only under a mild assumption that the
agent under π(s(cid:48)) will not leave the room, which is where all the
reward is.

↓→→→↑↑↓→→↑↑↑↑↑↑↑↑↑↓←↑←←↑↓↓←↓↓↓←↓↓↓↓↓←↑↓→←↑↑↑↓←←↑↑↑←↑↑↑←↓←↑↓←←↑↑←↓↓←↑↓←↑↑↑↑←↓←←↓←←←↑←Policy: Task 11234567891012345678910→→→→↓→→→→→→→→→↓→→→→→→→→↑↑↑↑↑↑↑↓↓→↑↓←→↑↑↑↓↓→↓↓↓→↓↓↓↓→↑→→↑↑↑↑↑↑↑↓←↑←↑↑↓←↑↑↑↑↓←←←↑↑Policy: Task 21234567891012345678910→→→→↓→→→→↓↓↓↓↓↓↓↓←←↓↓↓←↓↓↓←↓↓↓↓↓←→↓↓←↑↑↑↓↓↓↓↓←←↑↑↑←←←←↓←←←←↑←←←←↓←←←←↑←←←←↓←←←←↑Policy: Task 31234567891012345678910→→→→↓→→→→→→→→→↓→→→→→↓↓→↓↓↓→↑↑↑↓↓→↑↓↓→↑↑↑↓↓→↓↓↓→↓↓↓↓↓→→↓↓↓↓↓↓←←←←↓←←←←↓←←←←↓Policy: Task 41234567891012345678910Learning share representations for value functions in Multi-Task RL

the same environment.

7. Related work
There is a good collection of methods that tackle various
aspect of multi-task reinforcement learning (Lazaric, 2012)
and (Taylor & Stone, 2009a). As with our approach, these
methods try to learn jointly either value functions or poli-
cies over a set of tasks (Lazaric & Ghavamzadeh, 2010),
(Dimitrakakis & Rothkopf, 2011) but under different struc-
ture and environment assumptions. A more recent study in
(Konidaris et al., 2012), also employs the idea of a shared
feature space, but both the learning procedure and the pro-
posed way of transferring this tuned knowledge is very dif-
ferent from ours. The main novel idea this work intro-
duces is modelling explicitly a shared abstraction of the
state-action space that can be reﬁned throughout the learn-
ing process while optimizing for the value functions. The
ability to change the representation throughout the learning
process to model the improving set of policies is crucial.
This is the only way option-like features could emerges
– these already incorporate both the transition model and
good policies that generalize over tasks, as shown in the
previous section. One of the methods investigated in (Ca-
landriello et al., 2014) in a study on sparsity in multi-task,
is very closely related to our learning procedure and this
work can be seen as a generalization of that method, al-
though the focus and model assumptions are quite differ-
ent. Perhaps the most relevant prior work that shares our
vision and some of the modelling assumption is the ap-
proach in (Schaul et al., 2015) which model a shared state-
representation between goals and assume a linear factor-
ization between this state embbeding and task/goal embbe-
ding.

8. Conclusion and Future work
In this work, we investigated the problem of representation
learning in multi-task/multi-goal reinforcement learning.
We introduced the multi-task RL paradigm and showed
how two of the most popular classes of planning algo-
rithms, ﬁtted Q-Iteration and approximate Policy Iteration,
can be extended to learn from multiple tasks jointly. Focus-
ing on linear parametrization of the Q-function, we showed
at least two ways in which one can harness the power
of well-established multi-task learning and transfer algo-
rithms developed in supervised settings and apply them to
inferring a joint structure over optimal value functions, and
implicitly over policies. As argued before and shown in
these preliminary experiments, RL can beneﬁt a lot from
integrating joint treatment of goals and exploiting com-
monality between tasks. This ought to lead to more ef-
ﬁcient learning and better generalization. Although these
are very encouraging results, this paradigm does need more

investigation to assess convergence behaviour, scalability
to more complex tasks, employing other multi-task learn-
ing or representation learning procedures and we hope this
work will serve as staring point.

References
Ando, Rie Kubota and Zhang, Tong. A framework for
learning predictive structures from multiple tasks and
unlabeled data. The Journal of Machine Learning Re-
search, 6:1817–1853, 2005.

Antos, Andr´as, Szepesv´ari, Csaba, and Munos, R´emi.
learning
Value-iteration based ﬁtted policy iteration:
with a single trajectory. In Approximate Dynamic Pro-
gramming and Reinforcement Learning, 2007. ADPRL
2007. IEEE International Symposium on, pp. 330–337.
IEEE, 2007.

Argyriou, Andreas, Evgeniou, Theodoros, and Pontil, Mas-
similiano. Convex multi-task feature learning. Machine
Learning, 73(3):243–272, 2008.

Barto, Andrew G and Mahadevan, Sridhar. Recent ad-
vances in hierarchical reinforcement learning. Discrete
Event Dynamic Systems, 13(4):341–379, 2003.

Bengio, Yoshua. Learning deep architectures for ai. Foun-
dations and trends R(cid:13) in Machine Learning, 2(1):1–127,
2009.

Calandriello, Daniele, Lazaric, Alessandro, and Restelli,
Marcello. Sparse multi-task reinforcement learning. In
Advances in Neural Information Processing Systems, pp.
819–827, 2014.

Chen, Jianhui, Liu, Ji, and Ye, Jieping. Learning inco-
herent sparse and low-rank patterns from multiple tasks.
ACM Transactions on Knowledge Discovery from Data
(TKDD), 5(4):22, 2012.

Dietterich, Thomas G. Hierarchical reinforcement learning
with the maxq value function decomposition. J. Artif.
Intell. Res.(JAIR), 13:227–303, 2000.

Dimitrakakis, Christos and Rothkopf, Constantin A.
Bayesian multitask inverse reinforcement learning.
In
Recent Advances in Reinforcement Learning, pp. 273–
284. Springer, 2011.

Ernst, Damien, Geurts, Pierre, and Wehenkel, Louis. Tree-
based batch mode reinforcement learning. In Journal of
Machine Learning Research, pp. 503–556, 2005.

Hengst, Bernhard. Discovering hierarchy in reinforcement
learning with hexq. In ICML, volume 2, pp. 243–250,
2002.

Learning share representations for value functions in Multi-Task RL

for learning knowledge from unsupervised sensorimotor
In The 10th International Conference on
interaction.
Autonomous Agents and Multiagent Systems-Volume 2,
pp. 761–768. International Foundation for Autonomous
Agents and Multiagent Systems, 2011.

Taylor, Matthew E and Stone, Peter. Transfer learning for
reinforcement learning domains: A survey. The Journal
of Machine Learning Research, 10:1633–1685, 2009a.

Taylor, Matthew E and Stone, Peter. Transfer learning for
reinforcement learning domains: A survey. The Journal
of Machine Learning Research, 10:1633–1685, 2009b.

Zhou, Jiayu, Chen, Jianhui, and Ye, Jieping. Clustered
multi-task learning via alternating structure optimiza-
tion. In Advances in neural information processing sys-
tems, pp. 702–710, 2011.

Jalali, Ali, Sanghavi, Sujay, Ruan, Chao, and Ravikumar,
Pradeep K. A dirty model for multi-task learning.
In
Advances in Neural Information Processing Systems, pp.
964–972, 2010.

Konidaris, George and Barto, Andrew G. Building portable
options: Skill transfer in reinforcement learning. In IJ-
CAI, volume 7, pp. 895–900, 2007.

Konidaris, George, Scheidwasser, Ilya, and Barto, An-
drew G. Transfer in reinforcement learning via shared
features. The Journal of Machine Learning Research, 13
(1):1333–1371, 2012.

Lazaric, Alessandro. Transfer in reinforcement learning: a
framework and a survey. In Reinforcement Learning, pp.
143–173. Springer, 2012.

Lazaric, Alessandro and Ghavamzadeh, Mohammad.
In ICML-
Bayesian multi-task reinforcement learning.
27th International Conference on Machine Learning, pp.
599–606. Omnipress, 2010.

Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David,
Rusu, Andrei A, Veness, Joel, Bellemare, Marc G,
Graves, Alex, Riedmiller, Martin, Fidjeland, Andreas K,
Ostrovski, Georg, et al. Human-level control through
deep reinforcement learning. Nature, 518(7540):529–
533, 2015.

Schaul, Tom, Horgan, Daniel, Gregor, Karol, and Silver,
David. Universal value function approximators. In Pro-
ceedings of the 32nd International Conference on Ma-
chine Learning (ICML-15), pp. 1312–1320, 2015.

Silver, David, Huang, Aja, Maddison, Chris J, Guez,
Arthur, Sifre, Laurent, van den Driessche, George,
Schrittwieser, Julian, Antonoglou, Ioannis, Panneershel-
vam, Veda, Lanctot, Marc, et al. Mastering the game of
go with deep neural networks and tree search. Nature,
529(7587):484–489, 2016.

Stolle, Martin and Precup, Doina. Learning options in re-
inforcement learning. In SARA, pp. 212–223. Springer,
2002.

Sutton, Richard S and Barto, Andrew G. Reinforcement
learning: An introduction, volume 1. MIT press Cam-
bridge, 1998.

Sutton, Richard S, Precup, Doina, and Singh, Satinder. Be-
tween MDPs and semi-MDPs: A framework for tempo-
ral abstraction in reinforcement learning. Artiﬁcial intel-
ligence, 112(1):181–211, 1999.

Sutton, Richard S, Modayil, Joseph, Delp, Michael, De-
gris, Thomas, Pilarski, Patrick M, White, Adam, and
Precup, Doina. Horde: A scalable real-time architecture

Learning share representations for value functions in Multi-Task RL

Figure 9. Learned greedy policies (as indicated by the arrows) and value functions (coloring indicates the value V (s) = maxa(Q(s, a))
) enabling navigation to any of the four rooms, based only on the share feature subspace discovered in the multi-task value function
learning of 30 goals randomly sampled in the environment. The value functions were learnt using (single-task) FQI on top of features
ψASO

and we show the results when using 30, 50, 100 and respectively 300 samples from the option-deﬁned MDP.

s

→→→→↓↓↓→→↓↓↓↓↓↓↓↓←↑↓↓↓←↓↓↓↓↓↓↓↓←↑↓↓↓←↓↓←←←←↓←←←←↓←↓←←↓1234567891012345678910↓↓→→↓→↓→→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓←→↓↓↓↓↓↓←↓←←↓←↓←←↓←←←←↓1234567891012345678910↓↓→→↓→↓→→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓←→↓↓↓↓↓↓←↓←←↓←↓←←↓←←←←↓1234567891012345678910→↓→→↓→↓→→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓←→↓↓↓↓↓↓↓↓↓←↓↓↓↓←↓↓←←←↓1234567891012345678910↓↓↓↓↓←↓↓↓←↓↓↓↓↓←↑↓↓←↑↑↑↓↓←↓↓↓←←←←←↓←←↓←←←←←←↓←←↓←←←←←←↓←←↓←←←←←1234567891012345678910↓↓↓↓↓←↓↓↓←↓↓↓↓↓←→↓↓←↑↑↑↓↓↓↓↓↓←←↑↑↓↓←←↓↓←←↑↑↓↓←←↓↓←←↑↑↓↓←←↓←←←↑↑1234567891012345678910↓↓↓↓↓←↓↓↓←↓↓↓↓↓←↑↓↓←↑↑↑↓↓←↓↓↓←↑↑↑←←←←↓←←←↑←←↓←←↓←←←←↑←←←←↓←←←←←1234567891012345678910↓↓↓↓↓←↓↓↓←↓↓↓↓↓←↑↓↓←↑↑↑↓↓←↑↓↓←↑↑↑←←←←↓←←←←←←←←←↓←←←←←←←←←↓←←←↑←1234567891012345678910↓↓↓↓↓←↓↓↓↓↓↓↓↓←↑↓↓↓←↓↓←↓←←↓↓↓←←↓←↓←←↓1234567891012345678910↓↓↓↓↓←↓↓↓↓↓↓↓↓←↑↓↓↓←↓↓↓↓←←↓↓↓←←↓↓↓←←↓1234567891012345678910↓↓↓↓↓←↓↓↓↓↓↓↓↓←→↓↓↓↓↓↓↓↓←←↓↓↓←←↓↓↓←←↓1234567891012345678910↓↓↓↓↓←↓↓↓↓↓↓↓↓←→↓↓↓↓↓↓↓↓←←↓←↓←←↓↓↓←←↓1234567891012345678910↓↓↓↓↓↓↓↓→↓↓↓↓→→→↑↑↑↑↑↑↑↑↓←←←←←↓←←←←←↓←←←←←1234567891012345678910↓↓↓↓↓↓↓↓→↓↓↓↓→→↑↑↑↑↑↑↑↑↑↓←↑↑↑↑↓←↑↑↑↑↓←↑↑↑↑1234567891012345678910↓↓↓↓↓↓↓↓←↓↓↓↓→←↑↑↑↑↑↑↑↑↑↓←←↑↑↑↓←←↑↑↑↓←←←↑↑1234567891012345678910↓↓↓↓↓↓↓↓←↓↓↓↓↓←↑↑↑↓←←↑↑↑↓←←↑↑↑↓←←↑↑↑↓←←↑↑↑1234567891012345678910↓→→→→→↓→→→→→↑↑↑↑↑↑↓←→↑↑↑↓↓↓↓↓→↓↓↓↓↓↓↓1234567891012345678910↓→→→↑↑↓→→→↑↑↑↑↑↑↑↑↓←→↑↑↑↓↓↓↓↓→↓↓↓↓↓↓↓1234567891012345678910↓→→→→→↓→→→→→↑↑→↑↑↑↓↓→↑↑↑↓↓↓↓↓→↓↓↓↓↓↓↓1234567891012345678910↓→→→↑→↓→→→→→↑↑↑↑↑↑↓←→↑↑↑↓↓↓↓↓→↓↓↓↓↓↓↓1234567891012345678910→↓↓→↓→↓↓→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓↓↓1234567891012345678910→→→→↓→↓↓→↓↓↓↓↓↓↓↓←←↓↓↓←↓↓↓↓↓↓↓↓↓↓1234567891012345678910↓↓→→↓→↓→→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓↓↓1234567891012345678910↓↓→→↓→↓→→↓↓↓↓↓↓↓↓↓←↓↓↓←↓↓↓↓↓↓↓↓↓↓1234567891012345678910