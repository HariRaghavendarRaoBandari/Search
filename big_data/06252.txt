Grouping Time-varying Data
for Interactive Exploration

Arthur van Goethem∗ Marc van Kreveld† Maarten L¨oﬄer†
Bettina Speckmann∗

Frank Staals‡

6
1
0
2

 
r
a

 

M
0
2

 
 
]

G
C
.
s
c
[
 
 

1
v
2
5
2
6
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

We present algorithms and data structures that support the interactive analysis of the grouping structure
of one-, two-, or higher-dimensional time-varying data while varying all deﬁning parameters. Grouping
structures characterise important patterns in the temporal evaluation of sets of time-varying data. We
follow Buchin et al. [9] who deﬁne groups using three parameters: group-size, group-duration, and inter-
entity distance. We give upper and lower bounds on the number of maximal groups over all parameter
values, and show how to compute them eﬃciently. Furthermore, we describe data structures that can
report changes in the set of maximal groups in an output-sensitive manner. Our results hold in Rd for
ﬁxed d.

1 Introduction

Time-varying phenomena are ubiquitous and hence the rapid increase in available tracking,
recording, and storing technologies has led to an explosive growth in time-varying data. Such
data comes in various forms: time-series (tracking a one-dimensional variable such as stock
prices), two- or higher-dimensional trajectories (tracking moving objects such as animals, cars,
or sport players), or ensembles (sets of model runs under varying initial conditions for one-
dimensional variables such as temperature or rain fall), to name a few. Eﬃcient tools to extract
information from time-varying data are needed in a variety of applications, such as predicting
traﬃc ﬂow [22], understanding animal movement [7], coaching sports teams [17], or forecasting
the weather [25]. Consequently, recent years have seen a ﬂurry of algorithmic methods to analyse
time-varying data which can, for example, identify important geographical locations from a
set of trajectories [6, 19], determine good average representations [8], or ﬁnd patterns, such as
groups traveling together [9, 18, 21].

Most, if not all, of these algorithms use several parameters to model the applied problem at
hand. The assumption is that the domain scientists, who are the users of the algorithm, know
from years of experience which parameter values to use in their analysis. However, in many
cases this assumption is not valid. Domain scientists do not always know the correct parameter
settings and in fact need algorithmic support to interactively explore their data in, for example,
a visual analytics system [3, 20].

We present algorithms and data structures that support the interactive analysis of the
grouping structure of one-, two-, or higher-dimensional time-varying data while varying all

∗Department

of Mathematics

{a.i.v.goethem,b.speckmann}@tue.nl
m.loffler}@uu.nl

†Department

and Computer

Science, Eindhoven University

of

Information and Computing Sciences, Utrecht University,

of Technology
{m.j.vankreveld,

‡MADALGO, Aarhus University, f.staals@cs.au.dk

1

deﬁning parameters. Grouping structures (which track the formation and dissolution of groups)
characterise important patterns in the temporal evaluation of sets of time-varying data. Classic
examples are herds of animals or groups of people. But also for one-dimensional ensembles
grouping is meaningful, for example, when detecting trends in weather models [24].

Buchin et al. [9] proposed a grouping structure for sets of moving entities. Their deﬁnition
was later extended by Kostitsyna et al. [21] to geodesic distances. In this paper we use the same
trajectory grouping structure. Our contributions are data structures and query algorithms that
allow the parameters of the grouping structure to vary interactively and hence make it suitable
for explorative analysis of sets of time-varying data. Below we ﬁrst brieﬂy review the deﬁnitions
of Buchin et al. [9] and then state our contributions in detail.

Trajectory grouping structure [9]. Let X be a set of n entities moving in Rd and let T denote
time. The entities trace trajectories in T × Rd. We assume that each individual trajectory
is piecewise linear and consists of at most τ vertices. Two entities a and b are ε-connected if
there is a chain of entities a = c1,.., ck = b such that for any pair of consecutive entities ci and
ci+1 the distance is at most ε. A set G is ε-connected, if for any pair a, b ∈ G, the entities
are ε-connected (possibly using entities not in G). Given parameters m, ε, and δ, a set of
entities G is an (m, ε, δ)-group during time interval I if (and only if) (i) G has size at least m,
(ii) duration(I) ≥ δ, and (iii) G is ε-connected at any time t ∈ I. An (m, ε, δ)-group (G, I) is
maximal if G is maximal in size or I is maximal in duration, that is, if there is no group H ⊃ G
that is also ε-connected during I, and no interval J ⊃ I such that G is ε-connected during J.

Results and Organization. We want to create a data structure D that represents the grouping
structure, that is, its maximal groups, while allowing us to eﬃciently change the parameters.
As we show below, the complexity of the problem is already fully apparent for one-dimensional
time-varying data. Hence we restrict our description to R1 in Sections 2–4 and then explain in
Section 5 how to extend our results to higher dimensions.

If all three parameters m, ε, and δ can vary independently the question arises what constitutes
a meaningful maximal group. Consider a maximal (m, ε, δ)-group (G, I). If we slightly increase
ε to ε(cid:48), and consider a slightly longer time interval I(cid:48)
⊇ I then (G, I(cid:48)) is a maximal (m, ε(cid:48), δ)-
group. Intuitively, these groups (G, I) and (G, I(cid:48)) are the same. Thus, we are interested only in
(maximal) groups that are “combinatorially diﬀerent”. Note that the set of entities G may also
be a maximal (m, ε, δ)-group during a time interval J completely diﬀerent from I, we also wish
to consider (G, I) and (G, J) to be combinatorially diﬀerent groups. In Section 2 we formally
deﬁne when two (maximal) (m, ε, δ)-groups are (combinatorially) diﬀerent. We prove that there
are at most O(|A|n2) such groups, where A is the arrangement of the trajectories in T × R1,
and |A| is its complexity. We also argue that the number of maximal groups may be as large
as Ω(τ n3), even for ﬁxed parameters m, ε, and δ and in R1. This signiﬁcantly strengthens the
lower bound of Buchin et al. [9].

In Section 3 we present an O(|A|n2 log2 n) time algorithm to compute all combinatorially
diﬀerent maximal groups. In Section 4 we describe a data structure that allows us to eﬃciently
obtain all groups for a given set of parameter values. Furthermore we also describe data structures
for the interactive exploration of the data. Speciﬁcally, given the set of maximal (m, ε, δ)-groups
we want to change one or more of the parameters and eﬃciently report only those maximal
groups which either ceased to be a maximal group or became a maximal group. That is, our data
structures can answer so-called symmetric-diﬀerence queries which are gaining in importance as
part of interactive analysis systems [16]. As mentioned above, in Section 5 we extend our data
structures and algorithms to Rd, for ﬁxed d.

2

Fig. 1: (a) A set of trajectories for a set of entities moving in R1 (b) The region A{r,v} during
which {r, v} is alive, and its decomposition into polygons, each corresponding to a distinct
instance. In all such regions, except the top one {r, v} is a maximal group: in the top
region {r, v} is dominated by {r, v, o} (darker region).

2 Combinatorially Diﬀerent Maximal Groups

We consider entities moving in R1, hence the trajectories form an arrangement A in T × R1.
We assume that no three pairs of entities have equal distance at the same time. Consider the
four-dimensional parameter space P with axes time, size, distance, and duration. A set of entities
G deﬁnes a region AG in this space in which it is alive: a point p = (pt, pm, pε, pδ) = (t, m, ε, δ)
lies in AG if and only if G is a (m, ε, δ)-group at time t. We use these regions to deﬁne when
groups are combinatorially diﬀerent. First (Section 2.1) we ﬁx m = 1 and δ = 0 and deﬁne
and count the number of combinatorially diﬀerent maximal (1, ε, 0)-groups, over all choices of
parameter ε. We then extend our results to include other values of δ and m in Section 2.2.

2.1 The Number of Distinct Maximal (1, ε, 0)-Groups, over all ε

Consider the (t, ε)-plane in P through δ = 0 and m = 1. The intersection of all regions AG with
this plane give us the points (t, ε) for which G is a (1, ε, 0)-group. Note that G is a (1, ε, 0)-group
at time t if and only if the set G is ε-connected at time t. Hence the region AG, restricted to
this plane, corresponds to the set of points (t, ε) for which G is ε-connected. AG, restricted
to this plane, is simply connected. Furthermore, as the distance between any pair of entities
moving in R1 varies linearly, AG is bounded from below by a t-monotone polyline fG. The
region is unbounded from above: if G is ε-connected (at time t) for some value ε, then it is
also ε(cid:48)-connected for any ε(cid:48)
≥ ε (see Fig. 1). Every maximal length segment in the intersection
between (the restricted) AG and the horizontal line (cid:96)ε at height ε corresponds to a (maximal)
time interval I during which (G, I) is a (1, ε, 0)-group, or an ε-group for short. Every such a
segment corresponds to an instance of ε-group G.

Observation 1. Set G is a maximal ε-group on I, iﬀ the line segment sε,I = {(t, ε) | t ∈ I} is
a maximal length segment in AG, and is not contained in AH , for a supergroup H ⊃ G.

Two instances of ε-group G may merge. Let v be a local maximum of fG and I1 = [t1, vt]
and I2 = [vt, t2] be two instances of group G meeting at v. At vε, the two instances G that
are alive during [t1, vt] and [vt, t2] merge and we now have a single time interval I = [t1, t2] on
which G is a group. We say that I is a new instance of G, diﬀerent from I1 and I2. We can
thus decompose AG into maximally-connected regions, each corresponding to a distinct instance
of group G, using horizontal segments through the local maxima of fG. We further split each
region at the values ε where G changes between being maximal and being dominated. Let PG
denote the obtained set of regions in which G is maximal. Each such a region P corresponds to
a combinatorially distinct instance on which G is a maximal group (with at least one member

3

R(a)(b)orpvtimetimeεFig. 2: The arrangement H and the regions A{r,v} (purple) and A{p,o} (orange) for the trajectories
shown in Fig. 1(a). The arrangement H corresponds to the arrangement of functions
ha(t) that represent the distance from a to the entity directly above a at time t.

and duration at least zero). The region P is bounded by at most two horizontal line segments
and two ε-monotone chains (see Fig. 1(b)).

Counting maximal ε-groups. To bound the number of distinct maximal ε-groups, over all values
of ε, we have to count the number of polygons in PG over all sets G. While there are possibly
exponentially many sets, there is structure in the regions AG which we can exploit.
Consider a set of entities G and a region P ∈ PG corresponding to a distinct instance of the
maximal ε-group G. We observe that all vertices of P lie on the polyline fG: they are either
directly vertices of fG, or they are points (t, ε) on the edges of fG where G starts or stops being
maximal. For the latter case there must be a polyline fH , for some subgroup or supergroup of
G, that intersects fG at such a point. Furthermore, observe that any vertex (of either type) is
used by at most a constant number of regions from PG.
Below we show that the complexity of the arrangement H, of all polylines fG over all G, is
bounded by O(|A|n). Furthermore, we show that each vertex of H can be incident to at most
O(n) regions. It follows that the complexity of all polygons P ∈ PG, over all groups (sets) G,
and thus also the number of such sets, is at most O(|A|n2).
The complexity of H. The span SG(t) = {a | a ∈ X ∧ a(t) ∈ [minb∈G b(t), maxb∈G b(t))} of a
set of entities G at time t is the set of entities between the lowest and highest entity of G at
time t (for technical reasons, we include the lowest entity of G in the span, but not the highest).
Let ha(t) denote the distance from entity a to the entity directly above a at time t, that is, ha(t)
is the height of the face in A that has a on its lower boundary at time t.
Observation 2. A set G is ε-connected at time t, if and only if the largest distance among
consecutive entities in SG(t) is at most ε. That is,
fG(t) = max
a∈SG(t)

ha(t)

It follows that H is a subset of the arrangement of the n functions ha, for a ∈ X (see Fig. 2).

We use this fact to show that H has complexity at most O(|A|n):
Lemma 3. Let A be an arrangement of n line segments, and let k be the maximum number of
line segments intersected by a vertical line. The number of triplets (F, F (cid:48), x) such that the faces
F ∈ A and F (cid:48)
∈ A have equal height h at x-coordinate x is at most O(|A|k) ⊆ O(|A|n) ⊆ O(n3).
Proof. Let (cid:96)x be the vertical line through point (x, 0). Now consider a triplet (F, F (cid:48), x), and let
eF and fF (eF (cid:48) and fF (cid:48)) be the two edges of F (F (cid:48)) intersected by (cid:96)x. We charge (F, F (cid:48), x) to
edge e ∈ {eF , fF , eF (cid:48), fF (cid:48)} if (and only if) its left endpoint, say u, is the rightmost endpoint that
lies to the left of (cid:96)x (i.e. u is the rightmost among the left endpoints). We now show that each
edge can be charged at most 2k times.

Consider an edge e = uv of A, with ux ≤ vx. Edge e is charged by a triplet (F, F (cid:48), x), only if

one of the faces, say F , is incident to e, and the left-endpoints of the three other edges that are

4

timedistanceintersected by (cid:96)x and bounding F or F (cid:48) lie to the left of u. It now follows that there are only k
choices for face F (cid:48), as both the edges bounding F (cid:48) are intersected (consecutively) by the vertical
line through ux, and any vertical line intersects at most k edges. Clearly, e is incident to at most
two faces, and thus there are also only two choices for F . Finally, observe that for each such
pair of faces F and F (cid:48) there is at most one value x ∈ [ux, r], where r is the x-coordinate of the
leftmost right endpoint among eF , fF , eF (cid:48) and fF (cid:48), at which F and F (cid:48) have equal height (as the
height of faces F and F (cid:48) varies linearly in such an interval). It follows that every edge e ∈ A is

charged at most 2k times.

Remark 1. Interestingly, this bound is tight in the worst case. In Appendix A we give a
construction where there are Ω(n3) triplets (F, F (cid:48), x) such that F and F (cid:48) have equal height at x,
even if we use lines instead of line segments.

Lemma 4. The arrangement H has complexity O(|A|n).
Proof. Vertices in H are either (i) vertices of individual functions ha, or (ii) intersections between
two such functions, say ha and hc. The total complexity of the individual functions is O(|A|),
hence there are also only O(|A|) vertices of the type (i). Vertices of the type (ii) correspond to a
triplet (F, F (cid:48), x) in which F and F (cid:48) are faces of A that have equal height at x-coordinate x. By
Lemma 3 there are at most O(|A|n) such triplets. Thus, the number of vertices of type (ii) is
also at most O(|A|n).

What remains to show is that each vertex v of H can be incident to at most O(n) polygons

from diﬀerent sets. We use Lemma 5, which follows from Buchin et al. [9]:

Lemma 5. Let R be the Reeb graph for a ﬁxed value ε capturing the movement of a set of n
entities moving along piecewise-linear trajectories in Rd (for some constant d), and let v be a
vertex of R. There are at most O(n) maximal groups that start or end at v.
Lemma 6. Let v be a vertex of H. Vertex v is incident to at most O(n) polygons from

P =(cid:83)

G⊆X PG.

Proof. Let P ∈ PG be a region that uses v. Thus, G either starts or ends as a maximal vε-group
at time vt. This means, v correspond to a single vertex u in the Reeb graph, built with parameter
vε. By Lemma 5, there are at most O(n) maximal vε-groups that start or end at u. Hence, v
can occur in regions of at most O(n) diﬀerent sets G. For a ﬁxed set G, the regions in PG are
disjoint, so there are only O(1) regions from PG, that contain v.
Lemma 7. The number of distinct ε-groups, over all values ε, and the total complexity of all

G⊆X PG, are both at most O(|H|n) = O(|A|n2).

regions P =(cid:83)

2.2 The Number of Distinct Maximal Groups, over all Parameters

For the complexity of the regions in(cid:83)

Maximal groups are monotonic in m and δ (see Buchin et al. [9]); hence a maximal (m, ε, δ)-group
is also a maximal (m(cid:48), ε, δ(cid:48))-group for any parameters m(cid:48)
≤ δ. It follows that the
number of combinatorially diﬀerent maximal groups is still at most O(|A|n2).
PG: ﬁx m = 0, and consider the remaining subspace
of P with axes time, distance, and duration, and the restriction of AG, for any set G, into this
space. In the δ = 0 plane we simply have the regions AG, that are bounded from below by a
t-monotone polyline fG, as described in Section 2.1. As we increase δ we observe that the local
minima in the boundary fG get replaced by a horizontal line segment of width δ (see Fig. 3).
For arbitrarily small values of δ > 0, the total complexity of this boundary is still O(|A|n2).

≤ m and δ(cid:48)

5

Fig. 3: A cross section of the region A{r,v} with the plane through δ = δ(cid:48). The boundary of the

original region (i.e. the cross section with the plane through δ = 0) is dashed.

Further increasing δ, monotonically decreases the number of vertices on the functions fG. It
follows that the regions AG, restricted to the time, distance, duration space also have total
complexity O(|A|n2). Finally, consider the regions AG in the full four dimensional space. Clearly,
AG ∩ {p | p ∈ P ∧ pm < |G|} = ∅. For values m ≥ |G|, the boundary of AG is constant in m. We
conclude:

Theorem 8. Let X be a set of n entities, in which each entity travels along a piecewise-linear
trajectory of τ edges in R1, and let A be the resulting trajectory arrangement. The number of
distinct maximal groups is at most O(|A|n2) = O(τ n4), and the total complexity of all regions
in the parameter space corresponding to these groups is also O(|A|n2) = O(τ n4).

In Section B in the appendix we prove Lemma 9: even for ﬁxed parameters ε, m, and δ, the
number of maximal (m, ε, δ)-groups, for entities moving in R1, may be as large as Ω(τ n3). This
strengthens the result of Buchin et al. [9], who established this bound for entities in R2.
Lemma 9. For a set X of n entities, in which each entity travels along a piecewise-linear
trajectory of τ edges in R1, there can be Ω(τ n3) maximal ε-groups.

3 Algorithm

In the following we refer to combinatorially diﬀerent maximal groups simply as groups. Our
algorithm computes a representation (of size O(|A|n2)) of all groups, which we can use to list
all groups and, given a pointer to a group G, list all its members and the polygon QG ∈ PG. We
assume δ = 0 and m = 1, since the sets of maximal groups for δ > 0 and m > 1 are a subset of
the set for δ = 0 and m = 1.

3.1 Overview

Our algorithm uses the arrangement H located in the (t, ε)-plane. Line segments in H correspond
to the height function of the faces in A. Let a, b ∈ SG(t) be the pair of consecutive entities in the
span of a group G with maximum vertical distance at time t. We refer to (a, b) as the critical
pair of G at time t. The pair (a, b) determines the minimal value of ε that is required for the
group G to be ε-connected at time t. The distance between a critical pair (a, b) deﬁnes an edge
of the polygon bounding G in H.
Our representation will consist of the arrangement H in which each edge e is annotated with
a data structure Te, a list L (or array) with the top edge in each group polygon QG ∈ PG, and
an additional data structure S to support reconstructing the grouping polygons. We start by
computing the arrangement H. This takes O(|H|) = O(τ n3) time [2]. The arrangement is built
from the set of height-functions of the faces of A. With each edge we store the pair of edges in
A responsible for it.

6

δ0timedistanceδ0Given arrangement H we use a sweep line algorithm to construct the rest of the representation.
A horizontal line (cid:96)(ε) is swept at height ε upwards, and all groups G whose group polygon QG
currently intersects (cid:96) are maintained. To achieve this we maintain a two-part status structure.
First, a set S with for each group G the time interval I(G, ε) = QG ∩ (cid:96)(ε). Second, for each edge
e ∈ H intersected by (cid:96)(ε) a data structure Te with the sets of entities whose time interval starts
or ends at e, that is, G ∈ Te if and only if I(G, ε) = [s, t] with s = e ∩ (cid:96)(ε) or t = e ∩ (cid:96)(ε). We
postpone the implementation of T to Section 3.3. The data structures support the following
operations:

Operation
Filter(Te, X)
Insert(Te, G)
Delete(Te, G)
Merge(Te,Tf )

Contains(Te, G)

Input
A data structure Te
A set of entities X
A data structure Te
A pointer to a representation of G
A data structure Te
A pointer to a representation of G
Two data structures Te, Tf , be-
longing to two edges e, f having
the same starting or ending vertex
A data structure Te
A pointer to a representation of G
ending or starting on edge e

Action
Create a data structure T
X | G ∈ Te}
Create a data structure T
{G}.
Create a data structure T
{G}.
Create a data structure T
Tf .
Test if Te contains set G.

(cid:48) = {G∩
(cid:48) = Te ∪
(cid:48) = Te \
(cid:48) = Te ∪

HasSuperSet(Te, G) A data structure Te

A pointer to a representation of G
ending or starting on edge e

Test if Te contains a set H ⊇ G,
and return the smallest such set
if so.

The end points of the time interval I(G, ε) = [start(G, ε), end (G, ε)] vary non-stop along the
sweep. For each group G, the set S instead stores the edges e and f of H that contain the starting
time start(G, ε) and ending time end (G, ε), respectively, and pointers to the representation of G
in Te and Tf . We refer to e and f as the starting edge and ending edge of G. In addition, we
store with each interval I(G, ε) a pointer to the previous version of the interval I(G, ε(cid:48)) if (and
only if) the starting time (ending time) of G changed to edge e (edge f ) at ε(cid:48). Note that updates
for both S and T occur only when a vertex is hit by the sweep line (cid:96)(ε). For all unbounded
groups we add I(G,∞) to L after the sweep line algorithm.
3.2 Sweepline Events

The sweep line algorithm results in four diﬀerent vertex events (see Fig. 4). The Extend-event
has a symmetrical version in which uu(cid:48) and ww(cid:48) both have a negative incline. We describe how
to update our hypothetical data structures in all cases.
Case I - Birth. Vertex v is a local minimum of one of the functions ha, with a ∈ X (see Fig. 4(a)).
When the sweep line intersects v a new maximal group G is born. We can ﬁnd the maximal
group spawned in O(|G|) time by checking which trajectories are ε-connected for this value of t
and ε. To this end we traverse the (vertical decomposition of) A starting at the entities deﬁning
v.
Case II - Extend. Vertex v is the intersection of two line segments sab = uu(cid:48) and scd = ww(cid:48),
both with a positive incline (see Fig. 4(b)). The case in which sab and scd have negative incline
can be handled symmetrically. Assume without loss of generality that scd is steeper than sab.
We start with the following observation:

7

Fig. 4: The diﬀerent types of vertex events shown both in the arrangement A and in H. The

Extend event has a horizontally symmetric case.

Observation 10. None of the groups arriving on edge (w, v) continue on edge (v, u(cid:48)).

Proof. Let G be a group that arrives at v using edge (w, v). As G uses (w, v), it must contain
entities both above and below the face F deﬁned by critical pair (c, d). We know that uε and wε
are strictly smaller than vε and ε is never smaller than zero. Thus, vε is strictly positive and F
has a strictly positive height at t. Therefore, G still contains entities above and below F after
time t. But then the critical pair (c, d) is still part of G and scd is a lower bound for the group.
It follows that G must use edge (v, w(cid:48)).

We ﬁrst compute the groups on outgoing edge (v, u(cid:48)). By Observation 10 all these groups
arrive on edge (u, v). In particular, they are the maximal size subsets from T(u,v) for which
all entities lie below entity d at time t, that is, T(v,u(cid:48)) = Filter(T(u,v), below (d, t)), where
below (y, t) = {x | x ∈ X ∧ x(t) < y(t)}. For each group G in T(v,u(cid:48)) we update the time-interval
in S. If G was dominated by a maximal group H ⊃ G on incoming edge (u, v), we insert a new
time interval with starting edge f = start(H, ε) and ending edge (v, u(cid:48)) into S, and insert G into
Tf . Note that G and H indeed have the same starting time: G is a subset of H, and is thus
ε-connected at any time where H is ε-connected. Since G was not maximal before, it did not
start earlier than H either.

(cid:48) by setting the ending edge to (v, w(cid:48)).

The groups from T(u,v) that contain entities on both sides of critical pair (c, d), continue
(cid:48) denote these groups. We update the interval I(G) in S for each group
onto edge (v, w(cid:48)). Let T
G ∈ T
Next, we determine which groups from T(w,v) die at v. A maximal group G ∈ T(w,v) dies at v
if there is a group H on (v, w(cid:48)) that dominates G. Any such group H must arrive at v by edge
(cid:48) with H ⊃ G and
(u, v). Hence, for each group G ∈ T(w,v) we check if there is a group H ∈ T
I(H) ⊇ I(G). For each of these groups we remove the interval I(G, ε) from S, add I(G, ε) to L,
and delete the set G from the data structure Tf , where f is the starting edge of G (at height ε).
(cid:48)(cid:48) denote
(cid:48)(cid:48)). Since
this set. We obtain T(v,w(cid:48)) by merging T
we now have the data structures T(v,u(cid:48)) and T(v,w(cid:48)), and we updated S accordingly, our status
structure again reﬂects the maximal groups currently intersected by the sweep line.
Case III - Join. Vertex v is a local maximum of one of the functions ha, with a ∈ X (see
Fig. 4(c)). Two combinatorially diﬀerent maximal groups Gu and Gw with the same set of entities

The remaining (not dominated) groups from T(w,v) continue onto edge (v, w(cid:48)). Let T
(cid:48),T

(cid:48) and T

(cid:48)(cid:48), that is, T(v,w(cid:48)) = Merge(T

8

(b)Extend(c)Join(a)Birth(d)UnionabcdtAabcdtεεAtεabAtabAHu0uvHuu0vHuu0ww0vHuu0ww0vεεεdie at v (and get replaced by a new maximal group G∗) if and only if Gu is a maximal group in
T(u,v) and Gw is a maximal group in T(w,v). We test this with a call to Contains(T(w,v), Gu) for
each group Gu ∈ T(u,v). Let G be a group in T(u,v), and let H ∈ T(w,v) be the smallest supergroup
of G, if such a group exists. At v the group G will immediately extend to the ending edge of H.
We can ﬁnd H by using a HasSuperSet(T(w,v), G) call. If H exists we insert G into Te, and
update I(G, ε) in S accordingly. We process the groups G in T(w,v) that have a group H ∈ T(u,v)
whose starting time jumps at v analogously.
Case IV - Union. Vertex v is the intersection of a line segment sab = uu(cid:48) with positive incline
and a line segment scd = ww(cid:48), with negative incline (see Fig. 4(d)). The Union event is a special
case of the Birth event. Incoming groups on edge (u, v) are below the line segment scd and,
hence, can not contain any elements that are above c. As a consequence the line segment scd
does not limit these groups and for a group G ∈ T(u,v) we can safely add it to T(v,u(cid:48)). We also
update the interval I(G) in S by setting the ending edge to (v, u(cid:48)). An analogous argument can
be made for groups arriving on edge (w, v).

Furthermore a new maximal group is formed. Let H be the set of all entities ε-connected to
entity a at time t. We insert H into T(v,u(cid:48)) and T(v,w(cid:48)) and we insert a time interval I(H) into S
with starting edge (v, w(cid:48)) and ending edge (v, u(cid:48)).

3.3 Data Structure

We can implement S using any standard balanced binary search tree, the only requirement
is that, given a (representation of) set G in a data structure Te, we can eﬃciently ﬁnd its
corresponding interval in S.

The data structure Te. We need a data structure T = Te that supports Filter, Insert,
Delete, Merge, Contains, and HasSuperSet eﬃciently. We describe a structure of size
O(n), that supports Contains and HasSuperSet in O(log n) time, Filter in O(n) time,
and Insert and Delete in amortized O(log2 n) time. In general, answering Contains and
HasSuperSet queries in a dynamic setting is hard and may require O(n2) space [27].

Lemma 11. Let G and H be two non-empty ε-groups that both end at time t. We have:

(G ∩ H (cid:54)= ∅ ∧ |G| ≤ |H|) ⇐⇒ G ⊆ H ∧ G (cid:54)= ∅.

Proof. The if-direction is easy: G ⊆ H immediately implies that |G| ≤ |H|, and since G is
non-empty we then also have G ∩ H = G (cid:54)= ∅.
We prove the only-if direction by contradiction: assume by contradiction that G (cid:54)⊆ H, and
thus there is an element b ∈ G \ H. Furthermore, let a ∈ G ∩ H, and let sG and sH denote the
starting times of group G and H, respectively. We distinguish two cases: sG ≤ sH and sH < sG.
Case sG ≤ sH . Since a ∈ G and sG ≤ sH , we have that at any time in [sH , z], the entities in
G are ε-connected to a. So, in particular, entity b is ε-connected to a. However, during [sH , z],
the entities in H are also ε-connected to a. Thus, it follows that during [sH , z], entity b is also
ε-connected to H, and thus b ∈ H. Contradiction.
Case sH < sG. Analogous to the previous case we get that both H and G are ε-connected
to entity a during [sG, z]. It then follows that H ⊆ G. However, as b ∈ G \ H, this relation is
strict, that is, H ⊂ G. This contradicts that |G| ≤ |H|.

We implement T with a tree similar to the grouping-tree used by Buchin et al. [9]. Let
i∈[1,..,k] Gi denote the entities in these
(cid:48). Each group Gi is represented by an internal

{G1,.., Gk} denote the groups stored in T , and let X
groups. Our tree T has a leaf for every entity in X

(cid:48) =(cid:83)

9

node vi. For each internal node vi the set of leaves in the subtree rooted at vi corresponds
exactly to the entities in Gi. By Lemma 11 these sets indeed form a tree. With each node vi,
we store the size of the group Gi, and (a pointer to) an arbitrary entity in Gi. Next to the tree
we store an array containing for each entity a pointer to the leaf in the tree that represents it
(or Nil if the entity does not occur in any group). We preprocess T in O(n) time to support
level-ancestor (LA) queries as well as lowest common ancestor (LCA) queries, using the methods
of Bender and Farach-Colton [4, 5]. Both methods work only for static trees, whereas we need
to allow updates to T as well. However, as we need to query Te only when processing the upper
end vertex of e, we can be lazy in updating Te. More speciﬁcally, we delay all updates, and
simply rebuild Te when we handle its upper end vertex.
HasSuperSet and Contains queries. Using LA queries we can do a binary search on the
ancestors of a given node. This allows us to implement both HasSuperSet(Te, G) queries and
Contains(Te, G) in O(log n) time for a group G ending or starting on edge e. Let a be an
arbitrary element from group G. If the datastructure Te contains a node matching the elements
in G then it must be an ancestor of the leaf containing a in T . That is, it is the ancestor that
has exactly |G| elements. By Lemma 11 there is at most one such node. As ancestors only get
more elements as we move up the tree, we ﬁnd this node in O(log n) time by binary search.
Similarly, we can implement the HasSuperSet function in O(log n) time.
Insert, Delete, and Merge queries. The Insert, Delete, and Merge operations on Te are
performed lazily; We execute them only when we get to the upper vertex of edge e. At such a
time we may have to process a batch of O(n) such operations. We now show that we can handle
such a batch in O(n log2 n) time.

Lemma 12. Let G1,.., Gm be maximal ε-groups, ordered by decreasing size, such that: (i) all
groups end at time t, (ii) G1 ⊇ Gi, for all i, (iii) the largest group G1 has size s, and (iv) the
smallest group has size |Gm| > s/2. We then have that Gi ⊇ Gi+1 for all i ∈ [1,.., m − 1].
Proof. All groups Gi are subsets of G1 and have size at least s/2. Thus, any two subsets Gi and
Gi+j have a non-empty intersection, i.e. Gi ∩ Gi+j (cid:54)= ∅. The result then follows directly from
Lemma 11.

(cid:48), representing the set G respectively H, both

Lemma 13. Given two nodes vG ∈ T and vH ∈ T
ending at time t, we can test if G ⊆ H in O(1) time.
(cid:48) to ﬁnd the leaf (cid:96) in T
(cid:48)
Proof. Let a be the entity from G stored with vG. We use the array of T
(cid:48). If the result is vH then a ∈ H
that represents a, and perform a LCA query on (cid:96) and vH in T
and Lemma 11 states that G ⊆ H if and only if |G| < |H|. If the result is not vH then a (cid:54)∈ H,
and trivially G (cid:54)⊆ H. Finding (cid:96), and performing the LCA query takes O(1) time. As we store
the group size with each node, we can also test if |G| < |H| in constant time.
Lemma 14. Given m = O(n) nodes representing maximal ε-groups G1,.., Gm, possibly in
diﬀerent data structures T1,..,Tm, that all share ending time t, we can construct a new data
structure T representing G1,.., Gm in O(n log2 n) time.
Proof. Sort the groups G1,.., Gm on decreasing group size. Let G1 ∈ T1 denote the largest
group and let it have size s. We assume for now that G1 is a superset of all other groups. If this
is not the case we add a dummy group G0 containing all elements. We process the groups in
order of decreasing size. By Lemma 12 it follows that all groups G1,.., Gk that are larger than
s/2 form a path P in T , rooted at G.

10

For all remaining (small) groups Gi we then ﬁnd
the smallest group in P that is a super set of Gi. By
Lemma 13, we can test in O(1) time if a group H ∈ P
is a supergroup of Gi by performing a LCA query
in the tree H originated from. We can then ﬁnd
the smallest super set of Gi in O(log n) time using a
binary search. Once all groups are partitioned into
clusters with the same ancestor Gi, we process the
clusters recursively. When the largest group in a
cluster has size one we are done (see Fig. 5).

Fig. 5: T is built top-down in several
rounds. Edges and nodes are col-
ored by round.

The algorithm goes through a series of rounds.
In each round the remaining clusters are handled
recursively. Because all (unhandled) clusters jointly contain no more than O(n) groups, each
round takes only O(n log n) time in total. As in each round the size of the largest group left
is reduced by half, it follows that after O(log n) rounds the algorithm must has constructed
the complete tree. Updating the array with pointers to the leaves takes O(n) time, as does
rebuilding the tree for future LA and LCA queries.
The ﬁnal function Filter can easily be implemented in linear time by pruning the tree from the
bottom up. We thus conclude:
Lemma 15. We can handle each event in O(n log2 n) time.

3.4 Maximal Groups

Reconstructing the grouping polygons. Given a group G, represented by a pointer to the top
edge of QG in L, we can construct the complete group polygon QG in O(|QG|) time, and list all
group members of G in O(|G|) time. We have access to the top edge of QG. This is an interval
I(G, ˆε) in S, speciﬁcally, the version corresponding to ˆε, where ˆε is the value at which G dies as
a maximal group. We then follow the pointers to the previous versions of I(G,·) to construct
the left and right chains of QG. When we encounter the value ˇε at which G is born, these chains
either meet at the same vertex, or we add the ﬁnal bottom edge of QG connecting them. To
report the group members of G, we follow the pointer to I(G, ˆε) in S. This interval stores a
pointer to its starting edge e, and to a subtree in Te of which the leaves represent the entities in
G.
Analysis. The list L contains O(g) = O(|A|n2) entries (Theorem 8), each of constant size. The
total size of all S’s is O(|H|n): at each vertex of H, there are only a linear number of changes in
the intervals in S. Each edge e of H stores a data structure Te of size O(n). It follows that our
representation uses a total of O(|H|n) = O(|A|n2) space. Handling each of the O(|H|) nodes
requires O(n log2 n) time, so the total running time is O(|A|n2 log2 n).
Theorem 16. Given a set X of n entities, in which each entity travels along a trajectory of τ
edges, we can compute a representation of all g = O(|A|n2) combinatorial maximal groups G such
that for each group in G we can report its grouping polygon and its members in time linear in its
complexity and size, respectively. The representation has size O(|A|n2) and takes O(|A|n2 log2 n)
time to compute, where |A| = O(τ n2) is the complexity of the trajectory arrangement.
4 Data Structures for Maximal Group Queries

In this section we present data structures that allow us to eﬃciently obtain all groups for a given
set of parameter values (Section 4.1), and for the interactive exploration of the data (Section 4.2).

11

CiGThroughout this section, n denotes the number of entities considered, τ the number of vertices
in any trajectory, k the output complexity, i.e. the number of groups reported, g the number of
maximal groups, g(cid:48) the maximum number of maximal groups for a given (ﬁxed) value of ε, and
Π the total complexity of the regions corresponding to the g combinatorially diﬀerent maximal
groups. So we have g(cid:48) = O(τ n3) and g ≤ Π = O(τ n4). When g(cid:48), g, or Π appear as the argument

of a logarithm, we write O(log nτ ).

4.1 Quering the maximal groups

We show that we can store all groups in a data structure of size O(Π log nτ log n) that can be
built in O(Π log2 nτ log n) time, and allows reporting all (m, ε, δ)-groups in O(log2 nτ log n + k)
time. We use the following three-level tree to achieve this.

On the ﬁrst level we have a balanced binary tree
with in the leaves the group sizes 1...n. Each internal
node v corresponds to a range Rv of group sizes and
stores all groups whose size lies in the range Rv. Let
Gv denote this set of groups, and for each such group
let DG denote the duration of group G as a function of
ε. The functions DG are piecewise-linear, δ-monotone,
and may intersect (see Fig. 6). By Theorem 8 the
total complexity of these functions is O(Π). We store
all functions DG, with G ∈ Gv, in a data structure
that can answer the following polyline stabbing queries
in O(log2 nτ + k) time: Given a query point q = (ε, δ),
report all polylines that pass above point q, that is, for
which DG(ε) ≥ δ. Thus, given parameters m, ε, and δ,
ﬁnding all (m, ε, δ)-groups takes O(log2 nτ log n + k)
time.

We build a segment tree storing the (ε-extent of

Fig. 6: The functions DG expressing the
duration of group G as a func-
tion of ε. Assuming all groups
have size at least m, all (m, ε, δ)-
groups intersect the upward ver-
tical half-ray starting in point
(ε, δ).

the) individual edges of all polylines stored at v. An internal node u of the segment tree
corresponds to an interval I(u), and stores the set of edges Ints(u) that completely span I(u).
Hence, with respect to u, we can consider these segments as lines. For a query with a point
q, we have to be able to report all (possibly intersecting) lines from Ints(u) that pass above
q. We use a duality transform to map each line (cid:96) to a point (cid:96)∗ and query point q to a line q∗.
The problem is then to report all points (cid:96)∗ in the half-plane below q∗. Such queries can be
answered in O(log h + k) time, using O(h) space and O(h log h) preprocessing time, where h is
the number of points stored [13]. It follows that we can ﬁnd all k polylines that pass above q in
O(log2 nτ + k) time, using O(Π log nτ ) space, and O(Π log2 nτ ) preprocessing time. We thus
obtain the following result:

Theorem 17. Given parameters m, ε, and δ, we can build a data structure of size O(Π log nτ log n),
using O(Π log2 nτ log n) preprocessing time, which can report all (m, ε, δ)-groups in O(log2 nτ log n+
k) time, where k is the output complexity.

4.2 Symmetric Diﬀerence Queries

Here we describe data structures for the interactive exploration of the data. We often have
all (m, ε, δ)-groups, for some parameters m, ε, and δ, and we want to change (some of the)
parameters, say to m(cid:48), ε(cid:48), and δ(cid:48), respectively. Thus, we need a way to eﬃciently report all
changes in the maximal groups. This requires us to solve symmetric diﬀerence queries, in

12

distancedurationεδwhich we want to eﬃciently report all maximal (m, ε, δ)-groups that are no longer maximal
for parameters m(cid:48), ε(cid:48), and δ(cid:48), and all maximal (m(cid:48), ε(cid:48), δ(cid:48))-groups that were not maximal for
parameters m, ε, and δ. That is, we wish to report G(m, ε, δ) ∆G(m(cid:48), ε(cid:48), δ(cid:48)).
Changing only δ. Consider the case in which we vary only δ, and keep m and ε ﬁxed, that
is, m(cid:48) = m and ε(cid:48) = ε. With ﬁxed ε, it suﬃces to use the algorithm from Buchin et al. [9] to
compute all maximal ε-groups with size at least m. There are at most g(cid:48) such groups. Each
group G corresponds to an interval IG = (−∞, duration(G)] such that G is maximal for a choice
δ of the duration parameter if and only if δ ∈ (−∞, duration(G)]. We now have two values δ
and δ(cid:48), and we should report all intervals in S(δ) ∆ S(δ(cid:48)), where S(x) denotes the intervals that
contain x.
Note that we can assume without loss of generality that δ ≤ δ(cid:48). Then we observe that we
should report group G if and only if duration(G) ∈ [δ, δ(cid:48)]. Hence, our data structure is simply a
balanced binary search tree on at most g(cid:48) values duration(G) and a symmetric diﬀerence query
is a 1-dimensional range query.

Changing only m. The case in which we vary only m can be solved analogously to the previous
case. A maximal group G has a size |G|, and G should be reported if and only if |G| ∈ [m, m(cid:48)),
assuming that the group size changes from m to m(cid:48) or vice versa, with m < m(cid:48).
Changing only ε. The minimum duration δ is ﬁxed,
so consider the δ-truncated grouping polygons (i.e. the
regions AG where each local minimum has been re-
placed by a horizontal line segment of width δ). Com-
pute all combinatorially distinct maximal groups for
this parameter δ and remove all groups that have size
less than m. A group G is now maximal during some
interval IG = [ˇεG, ˆεG], and we have to report G if
(and only if) IG occurs in the set S(ε) ∆ S(ε(cid:48)). We
now observe that this is the case exactly when IG
contains ε or ε(cid:48), but not both (see Fig. 7). Using an
interval tree we can thus report the symmetric diﬀer-
ence for ε in O(log nτ + k) time, using O(Π) space
and O(Π log nτ ) preprocessing time.1

Fig. 7: The symmetric diﬀerence for pa-
rameters ε and ε(cid:48) (red and blue
intervals) is exactly the set of in-
tervals that contains either ε or ε(cid:48),
but not both. Hence, the green
intervals should not be reported.

Changing δ and m simultaneously. Consider the
space δ × m. A group G is maximal in the quadrant (−∞, duration(G)] × (−∞,|G|] with
top-right corner pG = (duration(G),|G|). So, for parameters δ and m, the set of maximal
(m, ε, δ)-groups corresponds to the set of corner points that lie to the top-right of (δ, m). It now
follows that when we change the parameters to (δ(cid:48), m(cid:48)), the maximal groups that we have to
report lie in Q(δ,m) ∆ Q(δ(cid:48),m(cid:48)) (see Fig. 8). We can report those points (groups) by two three-sided
(orthogonal) range queries. Therefore, we store the corner points in a priority search tree [15],
and thus solve symmetric diﬀerence queries in O(log nτ + k) time, and O(g(cid:48)) space. Building a
priority search tree takes O(g(cid:48) log nτ ) time.
Changing ε and m simultaneously. Consider the space ε × m. A group G is now a maximal
group in a bottomless rectangle RG = [ˇεG, ˆεG] × (−∞,|G|]. See Fig. 9. Thus, for parameters
ε and m the maximal groups all contain the point (ε, m). We ﬁnd the groups that we have
to report by combining the approaches for varying only ε and varying only m. Observe that
G should be reported if (and only if) (ε, m) is in the rectangle RG and (ε(cid:48), m(cid:48)) is not, or vice
versa. Assume we test for the former. We can solve this query problem with three very similar

1 Note that we now have O(Π) groups (intervals) rather than O(g(cid:48)).

13

εε0Fig. 8: Symmetric diﬀerence queries when we allow varying δ and m. Each combinatorial
maximal group G corresponds to a lower-left quadrant in the space δ × m (a). For
given parameters m, ε, and m, all (δ, ε, m)-groups lie to the top-right of the point (δ, m).
Therefore, the groups that have to be reported in a symmetric-diﬀerence query (shown
in red and blue) can be reported by two three-sided range queries.

two-level data structures. The ﬁrst is a binary search tree on all groups G sorted on ˇεG. An
internal node v is associated to a subset Gv of groups that appear in the subtree rooted at v. We
store Gv by storing the horizontal line segments [ˇεG, ˆεG] × |G| in a hive graph [11], preprocessed
for planar point location queries. If h = |Gv|, then this structure uses O(h) storage and and
allows us to report all line segments of Gv that lie vertically above a query point in O(log h + k)
time. We query the main tree with ε(cid:48) and select a subset of O(log nτ ) nodes whose associated
subsets contains exactly the groups G with ε(cid:48) < ˇεG. This implies that (ε(cid:48), m(cid:48)) is not inside RG.
The second-level structure allows us to ﬁnd those groups whose rectangle RG contains (ε, m).
The second data structure is diﬀerent only in its main tree, which is sorted on ˆεG, and we will
select the nodes whose associated subsets contains exactly the groups with ε(cid:48) > ˆεG. The third
data structure is again diﬀerent in the main tree only, and is sorted on |G|. Here we select nodes
whose associated subsets have m(cid:48) > |G|. Together, the three main trees capture that (ε(cid:48), m(cid:48)) is
not in RG and the associated structures capture that (ε, m) is in RG. We report any group in
the symmetric diﬀerence at most twice. The data structure uses O(Π log nτ ) space and takes
O(Π log2 nτ ) time to build. The query time is O(log2 nτ + k).

Changing ε and δ, one by one. Consider
the space ε × δ. A group G is maximal
in the region below the partial, piecewise-
linear, and monotonically increasing func-
tion DG that expresses the duration of
G as a function of ε. Each such partial
function is deﬁned for a single interval of ε-
values. See Fig. 6. Note that the polylines
representing DG and DH , for two groups
G and H, may intersect. The combination
of non-orthogonal boundaries and intersec-
tions makes changing ε and δ much harder
than changing ε and m.
Consider changing parameter δ to δ(cid:48),
while keeping ε unchanged. For such a
query we thus have to report all groups G

Fig. 9: Symmetric diﬀerence queries when we allow
varying ε and m. Each combinatorial maxi-
mal group G now corresponds to a bottomless
rectangle. We ﬁnd the groups that are maxi-
mal for only one pair of parameters (i.e. the
red and blue groups) by a query in a two-level
tree for symmetric-diﬀerence queries.

14

durationdurationsizeδδ0mm0(a)(b)sizeεε0mm0sizedistancewhose polyline DG intersects the vertical query segment Q = (ε, δ)(ε, δ(cid:48)). We use the following
data structure to answer such queries. We build a segment tree storing the individual edges of
the polylines. Like in Section 4, each node v in this tree now corresponds to a set Ints(v) of
polyline edges (one per polyline) that completely cross the interval Iv associated with v. We
again treat these edges as lines. We store the h = |Ints(v)| lines in a data structure by Cheng
and Janardan [14] that has size O(h log h), can be built in O(h log2 h) time, and allows reporting
all (possibly intersecting) lines that intersect Q in O(√h2log∗ h log h + k) time. Since for any
value ε there are at most O(g(cid:48)) groups, we also have that for any node v, |Ints(v)| = O(g(cid:48)). It
follows that we can answer symmetric diﬀerence queries in δ in O(√g(cid:48)2log∗ nτ log2 nτ + k) time,
after O(Π log3 nτ ) preprocessing time, and using O(Π log2 nτ ) space.
Consider changing parameter ε to ε(cid:48), while keeping δ unchanged. For such a query we have
to report all groups G whose polyline DG is above exactly one end point of the horizontal query
segment Q = (ε, δ)(ε(cid:48), δ). Since all polylines DG are ε and δ-monotone we could use the same
approach as before, reversing the roles of ε and δ. However, a horizontal line may intersect O(g)
polylines rather than O(g(cid:48)), causing √g to appear in the query time rather than √g(cid:48). This may
be signiﬁcantly worse. Instead, observe that there are three ways in which Q can have exactly
one end point below DG. The two cases where one end point of Q is outside the ε-range of DG
are easily handled with a two-level tree. The ﬁrst level is a binary search tree on the ε-range
of DG, and allows us to ﬁnd the groups for which DG is either deﬁned completely before, or
completely after ε. All these groups are not maximal for parameter ε, so among them we have
to select the ones that are maximal for parameters ε(cid:48) and δ(cid:48). Our second level is thus the data
structure from Section 4. This leads to a data structure of size O(Π log2 nτ ) and query time
O(log3 nτ + k). The third case concerns the situation where the ε-range of Q is contained in
the ε-range of DG. In that case we need to test whether Q intersects DG. We use a hereditary
segment tree [12] on the ε-ranges of all segments S of all DG, and at each node v, we use
associated structures for the cases where segments of S are “long” and Q is “short”, and vice
versa. For the segments Sv of S that are long at v, we observe that there are only O(g(cid:48)) of them,
because they have a common ε-value. Furthermore, there can be at most one long segment in
Sv for each group G. Hence, we can use the data structure by Cheng and Janardan [14] to
report the ones intersecting Q. For the segments of S that are short at v, we know that the
query segment is long and horizontal, so we can just consider the δ-span of each short segment.
However, we must still ensure that the polyline DG that a short segment is part of, extends to
the right beyond Q. Both conditions together lead again to a hive graph, preprocessed for planar
point location. The data structure has size O(Π log2 nτ ), query time O(√g(cid:48)2log∗ nτ log2 nτ + k),
and can be built in O(Π log3 nτ ) time.

Changing all three parameters, one by one. To support changing all three parameters, we
combine some of the previous approaches. We build two separate data structures; one to change
m, the other to change ε or δ. The data structure to change m is simply the data structure
from Section 4. The ﬁrst level of this tree allows us to ﬁnd O(log n) subtrees containing the
groups whose size is in the range (min{m, m(cid:48)
}]. We then use the associated data
structures to report the groups that are long enough (with respect to parameters ε and δ). Thus,
we can answer such queries in O(log n log2 nτ + k) time. To support changing ε or δ we extend
the solution from the previous case: we simply add an other level to the structure, that allows
us to ﬁlter the groups that intersect a query segment Q in the (ε, δ)-plane by size. This yields a
query time of O(√g(cid:48)2log∗ nτ log2 nτ log n + k). The size and preprocessing time remain unaﬀected,
when compared to the previous situation.

}, max{m, m(cid:48)

Changing ε and δ simultaneously. We build a data structure that allows us to report the
maximal groups for parameters ε and m as a small number of canonical subsets. For each of

15

these canonical subsets we store a data structure that allows us to eﬃciently report the groups
that are not maximal for parameters ε(cid:48) and δ(cid:48). Symmetrically, we ﬁnd the groups that are not
maximal for parameters ε and δ and maximal for ε(cid:48) and δ(cid:48). So, basically, we need two layers of
the data structure from Section 4.2

Recall that the data structure from Section 4 is a segment tree with associated data structures
that allow half-plane range reporting. Unfortunately, the data structure that we use for the
half-space range reporting does not report the result as a small number of canonical subsets.
So, for the ﬁrst layer of our data structure we replace these half-plane range reporting data
structures by a partition tree [23]. For the second layer we can use the data structure from
Section 4 as is. It follows that we can now ﬁnd all groups that are maximal for ε and δ but not
maximal for ε(cid:48) and δ(cid:48) in O(√g(cid:48)2log∗ nτ log3 nτ + k) time. The data structure uses O(Π log2 nτ )
space, and can be built in O(Π log3 nτ ) time. We can thus solve symmetric diﬀerence queries in
the same time (and with the same amount of space).

Changing all three parameters simultaneously. We use the same approach as above, expressing
the groups alive for parameters m, ε, and δ as a small number of canonical subsets, for each
of which we store the data structure from Section 4. It follows that we can report symmetric
diﬀerence queries in O(√g(cid:48)2log∗ nτ log3 nτ log2 n + k) time, using O(Π log2 nτ log2 n) space and
O(Π log3 nτ log2 n) preprocessing time.

The following theorem summarizes our results:

Theorem 18. Let (m, ε, δ) and (m(cid:48), ε(cid:48), δ(cid:48)) be two conﬁgurations of parameters. In O(P (Π, g(cid:48), n))
time we can build a data structure of size O(S(Π, g(cid:48), n)) for symmetric diﬀerence queries, that is,
we can report all groups in G(ε, m, δ) ∆G(ε(cid:48), m(cid:48), δ(cid:48)), in O(Q(Π, g(cid:48), n, k)) time. In these results
Π denotes the total complexity of all combinatorially diﬀerent maximal groups (over all values
ε), g(cid:48) the number of maximal groups for a ﬁxed value ε, n the number of entities, τ the number
of vertices in a trajectory, and k the output complexity. The functions P , S, and Q depend on
which of the parameters are allowed to change (other parameters are assumed to be ﬁxed and
known at preprocessing time). We have

Variable Param.

Query time Q(Π, g(cid:48), n, k)

Space S(Π, g(cid:48), n)

Preproc. P (Π, g(cid:48), n)

Changing one parameter at a time

δ
m
ε

δ, m
ε, m
ε, δ

ε, δ, m

log nτ + k
log nτ + k
log nτ + k
log nτ + k
log2 nτ + k

g(cid:48) log nτ
g(cid:48) log nτ
Π log nτ
g(cid:48) log nτ
Π log2 nτ
Π log2 nτ
√g(cid:48)2log∗ nτ log2 nτ log n + k Π log2 nτ

√g(cid:48)2log∗ nτ log2 nτ + k

Changing multiple parameters at the same time

δ, m
ε, m
ε, δ

ε, δ, m

log nτ + k
log2 nτ + k

√g(cid:48)2log∗ nτ log3 nτ + k

g(cid:48) log nτ
Π log2 nτ
Π log2 nτ

√g(cid:48)2log∗ nτ log3 nτ log2 n + k Π log2 nτ log2 n

g(cid:48) log nτ
g(cid:48) log nτ
Π log nτ
g(cid:48) log nτ
Π log2 nτ
Π log3 nτ
Π log3 nτ

g(cid:48) log nτ
Π log2 nτ
Π log3 nτ
Π log3 nτ log2 n

2 We described this data structure for reporting all maximal groups for ε and δ. But it is easy to see that we
can also use it to report all groups that are not maximal for ε and δ: we simply have to report all polylines below,
rather than above, point (ε, δ).

16

5 Entities Moving in Rd

We now describe how our results can be extended to entities moving in Rd, for any constant
dimension d.

5.1 Bounding the Complexity

Let H

Recall that X (t) denotes the locations of the entities at time t. We still consider the (t, ε)-plane
in P, and the regions AG, for subsets G ⊆ X , in which set G is alive. Such a region is still
bounded from below by a function fG that expresses the minimum epsilon value for which G is
ε-connected. We again consider the arrangement H of these functions fG, over all sets G.
(cid:48)(cid:48) be the arrangement of all pairwise distance functions hab(t) = (cid:107)a(t)b(t)(cid:107). For any
subset of entities G and any time t, fG(t) = (cid:107)a(t)b(t)(cid:107) for some pair of entities a and b. Thus,
(cid:48)(cid:48). This immediately gives an O(τ n4) bound on the complexity of
H is a sub-arrangement of H
H. We instead show that H has complexity at most O(τ n3β4(n)), where βs(n) = λs(n)/n, and
λs(n) is the maximum length of a Davenport-Schinzel sequence of order s on n symbols. Using
exactly the same argument as in Lemma 6 we then get a bound of O(τ n4β4(n)) on the number
of combinatorially diﬀerent groups.

Let E(t) be the Euclidean minimum spanning tree (EMST) of the points in X (t). We then

observe:

Observation 19. A subset of entities G ⊆ X is ε-connected at time t if and only if for any
two entities p, q ∈ G the longest edge in the Euclidean minimum spanning tree E(t) on the path
between p and q has length at most ε.
Speciﬁcally, let E G(t) be the minimum (connected) subtree
of E(t) containing all points in G(t), and let ˇεG(t) be the
length of the longest edge e in E G(t) (see Fig. 10). We
have that G is an ε-group for all ε ≥ ˇεG(t), and that
fG(t) = max(a,b)∈E G(t) (cid:107)a(t)b(t)(cid:107).
It follows from Observation 19 that we are interested
in the distance function hab on the time intervals during
which (a, b) is part of the EMST. Hence, we need to con-
sider only the arrangement of such partial functions. It is,
however, diﬃcult to bound the complexity of the resulting
arrangement directly. Instead, we consider hab only during
those time intervals in which (a, b) is an edge in the Yao-
(cid:48) be the resulting arrangement. Since the
graph [26]. Let H
EMST is a subgraph of the Yao-graph it follows that H is
a sub-arrangement of H
Lemma 20. H
Proof. Fix an entity a, and consider the movement of the other entities with respect to a. This
gives us a set of (piecewise linear) trajectories. Entity a is ﬁxed at the origin. Partition this
space into k = O(1) equal size polyhedral cones C1,.., Ck that have their common apex at the
origin3. For each such cone Ci, let ηi
a(t) denote the distance from a to the nearest entity in the
cone. It is easy to show that ηi
a is piecewise hyperbolic, and consists of O(τ λ4(n)) pieces [21].
a, over all entities a ∈ X and all cones Ci. The
total number of pieces (hyperbolic arcs), over all entities and all cones, is O(τ nλ4(n)). Partition

Fig. 10: E(t) and its minimum sub-
tree EG(t) (red edges) for a
subset of entities G (red ver-
tices). Edge e determines
the minimum ε for which G
is ε-connected at t.

(cid:48) has complexity O(τ n3β4(n)).

(cid:48) [26].

∗ be the arrangement of all functions ηi

Let H

3 Note that k is exponential in the dimension d.

17

eEG(t)time into O(τ λ4(n)) time intervals, with O(n) pieces each. This may require splitting some of
the pieces, but the total number of pieces remains O(τ nλ4(n)). In each time interval we now
∗
have O(n) hyperbolic arc pieces, that intersect at most O(n2) times in total. It follows that H
has complexity O(τ λ4(n)n2) = O(τ n3β4(n)).
Fix a time t, and consider the graph Y (t) that has an edge (a, b) if and only if b is the nearest
a(t). Indeed, Y (t) is the

neighbor of a in one of the cones Ci at time t, that is, (cid:107)a(t)b(t)(cid:107) = ηi
Yao-graph of the entities at time t [26]. It follows that H

∗ = H

(cid:48).

Since H is a sub arrangement of H

(cid:48), it follows that H also has complexity O(τ n3β4(n)).

Using exactly the same argument as in Lemma 6 we then get that the number of combinatorially
diﬀerent maximal groups is O(τ n4β4(n)). We conclude:
Theorem 21. Let X be a set of n entities, in which each entity travels along a piecewise-linear
trajectory of τ edges in Rd, for any constant d. The number of maximal combinatorial groups as
well as the total complexity of all their group polygons is at most O(τ n4β4(n)).

5.2 Algorithm

We can almost directly apply our algorithm from Section 3 in higher dimensions as well. Instead
(cid:48). The only diﬀerences involve discovering the set entities
of the arrangement H, we now use H
involved in a Birth-event, and splitting the set of entities in case of an Extend-event. Let v
(cid:48) encodes the Yao-graph
denote the vertex of H
Y . Using a breadth ﬁrst search in Y we can ﬁnd the entities connected to v. If an edge has
length larger than ε we stop the exploration along it. Since Y is planar, and has O(n) vertices
this takes O(n) time. This does not aﬀect the running time, hence we get the same result as in
Theorem 16 for entities moving in Rd, for any constant d.

(cid:48) we are processing. We use that at time vt, H

5.3 Data Structures

Finding all maximal (m, ε, δ)-groups. We use the same approach as in Section 4. However, the
functions duration G are no longer (piecewise) linear functions in ε. Let start G(ε) = f−1(ε) and
end G(ε) = h−1(ε) be some hyperbolic functions f and h corresponding to curves in H. We have
that duration G(ε) = end G(ε) − start G(ε). The function duration G corresponds to a piecewise
curve with pieces deﬁned by polynomials of degree at most four. Hence, we have to solve the
following sub-problem: given a set of g(cid:48) algebraic curves of degree at most four, and query point
q, report all curves that pass above q.

We can solve such queries as follows. We transform the curves into hyperplanes in R(cid:96), where
(cid:96) is the linearization dimension. We then apply a duality transform, after which the problem
can be solved using a half-space range query. Since we have curves of degree at most four
in R2, the linearization dimension is seven: the set of points above a curve can be described
using a seven-variate polynomial (the ﬁve coeﬃcients of the degree four curve, and the two
coordinates of the point) [1]. It follows that we can ﬁnd all curves above query point q in
O(g(cid:48)1−1/(cid:98)7/2(cid:99) polylog nτ + k) = O(g(cid:48)2/3 polylog nτ + k) time, using linear space [23]. Reporting
all maximal (m, ε, δ)-groups thus takes O(g(cid:48)2/3 polylog nτ + k) time, using O(Π log nτ log n)
space and O(Π log2 nτ log n) preprocessing time.

Alternatively, we can maintain the upper envelope of the curves in a dynamic data structure.
To solve a query, we repeatedly delete the curve realizing the upper envelope at qε. This allows
us to ﬁnd all (m, ε, δ)-groups in O(kβ4(g(cid:48))2 polylog nτ ) time [10].
Symmetric Diﬀerence Queries. Only the versions of the problem that involve changing both ε
and δ are aﬀected. Instead of piecewise linear functions duration G we again have piecewise curves

18

of degree at most four. We use a similar approach as above to ﬁnd the curves that intersect a
vertical or horizontal query segment in O(g(cid:48)2/3 polylog nτ + k) time. Thus, we essentially replace
the √g(cid:48) terms in Theorem 18 by a g(cid:48)2/3 term.

Acknowledgments

F.S. is supported by the Danish National Research Foundation under grant nr. DNRF84. F.S. is supported
by the Danish National Research Foundation under grant nr. DNRF84. A.v.G. and B.S. are supported
by the Netherlands Organisation for Scientiﬁc Research (NWO) under project nr. 612.001.102 and
639.023.208, respectively.

References

[1] P. Agarwal and J. Matouek. On Range Searching with Semialgebraic Sets. Disc. & Comput. Geom.,

11(4):393–418, 1994.

[2] N. Amato, M. Goodrich, and E. Ramos. Computing the arrangement of curve segments: Divide-
and-conquer algorithms via sampling. In Proc. 11th ACM-SIAM Symp. on Disc. Algorithms, pages
705–706, 2000.

[3] G. Andrienko, N. Andrienko, and S. Wrobel. Visual analytics tools for analysis of movement data.

ACM SIGKDD Explorations Newsletter, 9(2):38–46, 2007.

[4] M. Bender and M. Farach-Colton. The LCA problem revisited. In LATIN 2000: Theoret. Informatics,

volume 1776 of LNCS, pages 88–94. Springer, 2000.

[5] M. Bender and M. Farach-Colton. The level ancestor problem simpliﬁed. Theoret. Computer Science,

321(1):5–12, 2004.

[6] M. Benkert, B. Djordjevic, J. Gudmundsson, and T. Wolle. Finding popular places. Int. J. of

Comput. Geom. & Appl., 20(1):19–42, 2010.

[7] P. Bovet and S. Benhamou. Spatial analysis of animals’ movements using a correlated random walk

model. J. of Theoret. Biology, 131(4):419–433, 1988.

[8] K. Buchin, M. Buchin, M. van Kreveld, M. L¨oﬄer, R. Silveira, C. Wenk, and L. Wiratma. Median

trajectories. Algorithmica, 66(3):595–614, 2013.

[9] K. Buchin, M. Buchin, M. van Kreveld, B. Speckmann, and F. Staals. Trajectory grouping structure.

J. of Comput. Geom., 6(1):75–98, 2015.

[10] T. Chan. A dynamic data structure for 3-d convex hulls and 2-d nearest neighbor queries. J. of the

ACM, 57(3):16:1–16:15, 2010.

[11] B. Chazelle. A functional approach to data structures and its use in multidimensional searching.

SIAM J. Comput., 17(3):427–462, 1988.

[12] B. Chazelle, H. Edelsbrunner, L. Guibas, and M. Sharir. Algorithms for bichromatic line-segment

problems and polyhedral terrains. Algorithmica, 11(2):116–132, 1994.

[13] B. Chazelle, L. Guibas, and D. Lee. The power of geometric duality. BIT Numerical Mathematics,

25(1):76–90, 1985.

[14] S. Cheng and R. Janardan. Algorithms for ray-shooting and intersection searching. Journal of

Algorithms, 13(4):670–692, 1992.

[15] M. de Berg, O. Cheong, M. van Kreveld, and M. Overmars. Computational Geometry: Algorithms

and Applications. Springer, Berlin, 3rd edition, 2008.

[16] D. Eppstein, M. Goodrich, and J. Simons. Set-diﬀerence range queries. In Proc. 2013 Canadian

Conf. on Comput. Geom., 2013.

[17] A. Fujimura and K. Sugihara. Geometric analysis and quantitative evaluation of sport teamwork.

Systems and Computers in Japan, 36(6):49–58, 2005.

19

[18] J. Gudmundsson, M. van Kreveld, and B. Speckmann. Eﬃcient detection of patterns in 2D trajectories

of moving points. GeoInformatica, 11:195–215, 2007.

[19] J. Gudmundsson, M. van Kreveld, and F. Staals. Algorithms for hotspot computation on trajectory

data. In Proc. 21st ACM SIGSPATIAL GIS, pages 134–143, 2013.

[20] D. Keim, G. Andrienko, J.-D. Fekete, C. Grg, J. Kohlhammer, and G. Melanon. Visual analytics:
Deﬁnition, process, and challenges. In A. Kerren, J. Stasko, J.-D. Fekete, and C. North, editors,
Information Visualization, volume 4950 of LNCS, pages 154–175. Springer, 2008.

[21] I. Kostitsyna, M. van Kreveld, M. L¨oﬄer, B. Speckmann, and F. Staals. Trajectory grouping

structure under geodesic distance. In Proc. 31th Symp. Computat. Geom. Lipics, 2015.

[22] X. Li, X. Li, D. Tang, and X. Xu. Deriving features of traﬃc ﬂow around an intersection from

trajectories of vehicles. In Proc. IEEE 18th Int. Conf. Geoinformatics, pages 1–5, 2010.

[23] J. Matouek. Eﬃcient partition trees. Disc. & Comput. Geom., 8(3):315–334, 1992.

[24] M. Mirzargar, R. Whitaker, and R. Kirby. Curve Boxplot: generalization of Boxplot for ensembles

of curves. IEEE Trans. on Vis. and Comp. Graphics, 20(12):2654–2663, 2014.

[25] A. Stohl. Computation, accuracy and applications of trajectories – a review and bibliography.

Atmospheric Environment, 32(6):947–966, 1998.

[26] A. Yao. On constructing minimum spanning trees in k-dimensional spaces and related problems.

SIAM J. Comput., 11(4):721–736, 1982.

[27] D. Yellin. Representing sets with constant time equality testing. J. of Algorithms, 13(3):353–373,

1992.

20

A The Number of Equal Height Faces in an Arrangement of Lines

Recall that A was an arrangement of n line segments, and that S(A) denotes the set of all triples (F, F (cid:48), x)
such that (i ) the faces F ∈ A and F (cid:48) ∈ A have equal height h at x-coordinate x, and (ii ) all faces in
between F and F (cid:48) at x-coordinate x have height less than h. We now show that S(A) may contain Ω(n3)
triples, even if our segments are lines.

Lemma 22. The number of triples in S(A) for a line arrangement A with n lines may be Ω(n3).

Proof. We construct a set of n lines L = R ∪ G ∪ B ∪ E whose arrangement A has |S(A)| = Ω(n3). The
(sub)sets R, G, and B have size k each. We use them to build the subset of faces such that there are
Ω(k3) triples (F, F (cid:48), x) such that F and F (cid:48) have equal height at x. The remaining O(k) lines are used
only to make sure that the faces in between any such pair (F, F (cid:48)) have smaller height. It follows that we
can choose k = Θ(n) and get |S(A)| = Ω(n3) as desired.
Our construction is shown in Fig. 11. The set of red lines R together with the set of blue lines B
form a unit grid that has been rotated by 45 + δ degrees, for some arbitrarily small δ > 0. The lines in R
(B) are all parallel to each other4. Let Ci,j denote the face (grid cell) in which the intersection point of ri
and bj is the point with the minimum y-coordinate, and let Cj = {C1,j, C2,j+1, C3,j+2.., C1+kj ,j+kj} be
the jth “column” of such faces.
The green lines in the set G = {g1,.., gk}, ordered from top to bottom, are (almost) horizontally,
and such that the distance between any consecutive lines gi and gi+1 increases slightly (i.e. the distance
between gi and gi+1 is h + iδ(cid:48), for some h ∈ (1/c, 1), some constant c, and some arbitrarily small δ(cid:48)). We
place these green lines suﬃciently far below the grid formed by the red and blue lines such that each face
Fi, bounded by r1, b1, and the green lines gi and gi+1, is wide enough such that its x-extent contains
[x1, x2], the x-extent of the grid.

Consider the (maximal) interval Jj such that all heights of the faces (grid cells) in column j are
simple increasing linear functions. See Fig. 12. It now follows that for each face C1+(cid:96),j+(cid:96) in column j
there is a small interval Ij,(cid:96) ⊂ Jj in which the height of the face varies between h and h + kδ(cid:48). Hence, in
this interval, the height of face C1+(cid:96),j+(cid:96) subsequently becomes equal to the height of the faces F1,.., Fk.
We can choose δ(cid:48) small enough such that the intervals I1+(cid:96),j+(cid:96) for all faces in column j are disjoint (and
so that I1+(cid:96),j+(cid:96) lies to the left of I2+(cid:96),j+(cid:96)+1). So, since we have Ω(k) columns, each of Ω(k) faces, it
follows that the number of x-coordinates at which two faces have equal height is Ω(k3).

4 Note that we can perturb all lines slightly to avoid parallel lines if desired.

Fig. 11: A construction of n lines, such that their arrangement A has |S(A)| = Ω(n3).

21

x1x2r1rkb1bkg1gkFig. 12: The heights of the faces in a column Cj = {C1,j, C2,j+1.., C1+kj ,j+kj} in interval Jj.

Finally, observe that any column j, and any x-coordinate in Jj, the faces in column j, ordered from
top to bottom, have decreasing height. Similarly, the faces F1,.., Fk, ordered from top to bottom, have
increasing height. It follows that when faces C1+(cid:96),j+(cid:96) and Fi have equal height h(cid:48), all other faces from C(cid:96)
and F1,.., Fi−1 have height smaller than h(cid:48). To make sure the remaining faces (such as the triangular
face bounded by r1, b1, and g1, have height at most h, we add a set of grey lines E. Since the slope of
the blue lines is close to one, the distance between b1 and g1, at x2 is at most O(k). The same holds for
the distance between r1 and g1 at x1. It follows that we have to add at most O(k) in between the grid
and g1 to make sure all intermediate faces have height at most h. Hence, all equal-height events involving
faces C1+(cid:96),j+(cid:96) and Fi produce a triplet in S(A).

B A Lower Bound on the Number of Maximal groups

In this section we show that, even for ﬁxed parameters ε, m, and δ, the number of maximal (m, ε, δ)-groups
may be as large as Ω(τ n3) even in R. This strengthens the result of Buchin et al. [9], who establish this
bound for entities moving in R2.

Lemma 9. For a set X of n entities, in which each entity travels along a piecewise-linear trajectory of τ
edges in R1, there can be Ω(τ n3) maximal ε-groups.

Proof. We build a construction in which all entities move along lines that yields Ω(n3) groups. Repeating
this construction Ω(τ ) times produces the claimed bound.

Partition X into three sets R, B, and H, with |R| = |B| = k = Ω(n) and |H| = k/2. The lines
(forming the trajectories of the entities) in R and B form a grid, that we rotate by 45 + δ degrees, for some
small δ > 0. Let R = {r1,.., rk}, B = {b1,.., bk}, denote the lines in increasing order. See Fig. 13. We
partition vertices of the rotated grid (i.e. the intersection points of R and B) into “columns” C1,.., CΩ(n),
where Ci is of the form {(rj, bk), (rj+1, bk−1),..,}, for some j and k. For a given column Ci, and a given
line rj ∈ R, let bij ∈ B be the line that intersects rj in Ci, and let tij be the time of the intersection.
Finally, for each entity rj, j odd, we place a line h ∈ H through the points rj ∩ b1 and rj+1 ∩ b2.
5. We scale the entire construction such that the
So, in every column Ci, h intersects some r(cid:96) in r(cid:96) ∩ bi(cid:96)
distance between two consecutive lines in h is larger than ε, and the distance between an intersection
point ri ∩ bij in column i and the lines h−ij and h+
Consider a column Ci, with i even. Entity rj is directly connected to bij during some time interval
Iij = [tij − ∆, tij + ∆], for some ∆. Since we rotated the grid by 45 + δ degrees, we have tij < ti(j+1)

ij in H directly above and below it is at most ε.

5 Note that we can easily perturb the lines to avoid parallel lines and points in which three lines intersect.

22

faceheightfaceheightF1Fk−1C1,jC1+kj,j+kjC1+‘,j+‘Ij,‘xJjFig. 13: (a) The construction in which the entities move along lines that yields Ω(n3) maximal
ε-groups (for a ﬁxed ε). The background color indicates that entities are connected. (b)
The intervals Iij during which rj is directly connected to bij (black), and the intervals
during which the sets Gijz are maximal (orange).

any consecutive range [j..z], the set of entities Xijz = (cid:83)

for every j. Hence, every interval Ii(j+1) starts and ends slightly later than Iij. Note that at any time
during Iij, either rj or bij is directly connected to h−ij. The same holds for h+
ij. This means that for
(cid:96)∈[j..z]{r(cid:96), bi(cid:96), h−i(cid:96), h+
i(cid:96)} is ε-connected during
Iijz = Iij ∩ Iiz = [tiz − ∆, tij + ∆]. It is easy to see that Iijz is maximal in duration.
It now follows that a column Ci with Ω(n) intersection points “generates” Ω(n2) maximal ε-groups.
Let rj,.., rz be entities from R involved in column Ci. At time ti(cid:96) − ∆, for (cid:96) ∈ [j..z], the group Gij(cid:96)
starts as a new maximal group. When rj and bij disconnect, all these groups end, and the groups
Gi(j+1)(j+1),.., Gi(j+1)z are discovered as new maximal ε-groups. Since we have Ω(n) columns (that have
Ω(n) intersection points) we get Ω(n3) maximal ε-groups as desired.

Note that we can choose the speed of the entities such that this construction holds for any choice of δ.

Furthermore, the construction holds even for minimal group sizes of Ω(n).

23

r2r1r3IijIi(j+1)Iizb1bijh+ijh−ijIijrjCiGijzGij(j+1)GijzGi(j+1)(j+1)Gi(j+1)zGi(j+1)(j+2)(a)(b)ε