Piecewise Testable Languages and
Nondeterministic Automata∗
Tomáš Masopust

Fakultät Informatik, Technische Universität Dresden, Germany and
Institute of Mathematics CAS, Czech Republic
tomas.masopust@tu-dresden.de

Abstract

A regular language is k-piecewise testable if it is a ﬁnite boolean combination of languages of the
form Σ∗a1Σ∗ ··· Σ∗anΣ∗, where ai ∈ Σ and 0 ≤ n ≤ k. Given a DFA A and k ≥ 0, it is an NL-
complete problem to decide whether the language L(A) is piecewise testable and, for k ≥ 4, it is
coNP-complete to decide whether the language L(A) is k-piecewise testable. It is known that the
depth of the minimal DFA serves as an upper bound on k. Namely, if L(A) is piecewise testable,
then it is k-piecewise testable for k equal to the depth of A. In this paper, we show that some
form of nondeterminism does not violate this upper bound result. Speciﬁcally, we deﬁne a class
of NFAs, called ptNFAs, that recognize piecewise testable languages and show that the depth of
a ptNFA provides an (up to exponentially better) upper bound on k than the minimal DFA. We
provide an application of our result, discuss the relationship between k-piecewise testability and
the depth of NFAs, and study the complexity of k-piecewise testability for ptNFAs.

1998 ACM Subject Classiﬁcation F.1.1 Models of Computation, F.4.3 Formal Languages

Keywords and phrases Automata, Logics, Languages, k-piecewise testability, Nondeterminism

Introduction

1
A regular language L over an alphabet Σ is piecewise testable if it is a ﬁnite boolean
combination of languages of the form

La1a2...an = Σ∗a1Σ∗a2Σ∗ ··· Σ∗anΣ∗

where ai ∈ Σ and n ≥ 0. If L is piecewise testable, then there exists a nonnegative integer k
such that L is a ﬁnite boolean combination of languages Lu, where the length of u ∈ Σ∗ is at
most k. In this case, the language L is called k-piecewise testable.

Piecewise testable languages are studied in semigroup theory [2, 3, 25] and in logic over
words [9, 26] because of their close relation to ﬁrst-order logic FO(<). They actually form
the ﬁrst level of the Straubing-Thérien hierarchy [24, 32]. This hierarchy is closely related to
the dot-depth hierarchy [6], see more in [21]. They are indeed studied in formal languages
and automata theory [19], recently mainly in the context of separation [26, 34]. Although
the separability of context-free languages by regular languages is undecidable, separability
by piecewise testable languages is decidable [8] (even for some non-context-free families).
Piecewise testable languages form a strict subclass of star-free languages, that is, of the
limit of the above-mentioned hierarchies or, in other words, of the languages deﬁnable by
LTL logic. They are investigated in natural language processing [10, 27], in cognitive and
sub-regular complexity [28], in learning theory [11, 20], and in databases in the context of
XML schema languages [7, 13, 14]. They have been extended from words to trees [4, 12].

∗ This work was supported by the DFG in project DIAMOND (Emmy Noether grant KR 4381/1-1).

6
1
0
2

 
r
a

 

M
0
1

 
 
]
L
F
.
s
c
[
 
 

2
v
1
6
3
0
0

.

3
0
6
1
:
v
i
X
r
a

© Tomáš Masopust;
licensed under Creative Commons License CC-BY

Conference title on which this volume is based on.
Editors: Billy Editor and Bill Editors; pp. 1–20

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

2

Piecewise Testable Languages and Nondeterministic Automata

Recently, the complexity of computing the minimal k and/or bounds on k for which a
piecewise testable language is k-piecewise testable was studied in [13, 18, 19], motivated by
applications in databases and algebra and logic. However, the knowledge of such a k that is
either minimal or of reasonable size is of interest in many other applications as well. The
complexity to test whether a piecewise testable language is k-piecewise testable was shown
to be coNP-complete for k ≥ 4 if the language is given as a DFA [18] and PSPACE-complete
if the language is given as an NFA [22]. The complexity for DFAs and k < 4 is discussed in
detail in [22]. The best upper bound on k known so far is given by the depth of the minimal
DFA [19].

In this paper, we deﬁne a class of NFAs, called ptNFAs, that characterizes piecewise
testable languages. This characterization is based on purely structural properties, therefore it
is NL-complete to check whether an NFA is a ptNFA (Theorem 5). We show that the depth
of ptNFAs also provides an upper bound on k-piecewise testability (Theorem 8) and that
this new bound is up to exponentially lower than the one given by minimal DFAs (Section 3
and Theorem 14). We further show that this property does not hold for general NFAs, and
that the gap between k-piecewise testability and the depth of NFAs can be arbitrarily large
(Theorem 12). The opposite implication of Theorem 8 does not hold. We give a non-trivial
application of our result in Section 5, where we also provide more discussion. Finally, in
Section 6, we discuss the complexity of k-piecewise testability for ptNFAs.

The paper is organized as follows. Section 2 presents basic notions and deﬁnitions, ﬁxes
the notation, and deﬁnes the ptNFAs. Section 3 motivates and demonstrates Theorem 8 on a
simple example. Section 4 then proves Theorem 8 and the related results. Section 5 provides
a non-trivial application and further discussion. Section 6 recalls the known complexity
results and discusses the complexity of the related problems for ptNFAs. Section 7 concludes
the paper.

2

Preliminaries and Deﬁnitions

We assume that the reader is familiar with automata theory, see, e.g., [1]. The cardinality of
a set A is denoted by |A| and the power set of A by 2A. An alphabet, Σ, is a ﬁnite nonempty
set; the elements of an alphabet are called symbols or letters. The free monoid generated
by Σ is denoted by Σ∗. A word over Σ is any element of Σ∗; the empty word is denoted by
ε. For a word w ∈ Σ∗, alph(w) ⊆ Σ denotes the set of all letters occurring in w, and |w|a
denotes the number of occurrences of letter a in w. A language over Σ is a subset of Σ∗. For
a language L over Σ, let L = Σ∗ \ L denote the complement of L.

A nondeterministic ﬁnite automaton (NFA) is a quintuple A = (Q, Σ,·, I, F), where Q
is a ﬁnite nonempty set of states, Σ is an input alphabet, I ⊆ Q is a set of initial states,
F ⊆ Q is a set of accepting states, and · : Q × Σ → 2Q is the transition function that can
be extended to the domain 2Q × Σ∗ by induction. The language accepted by A is the set
L(A) = {w ∈ Σ∗ | I · w ∩ F 6= ∅}. In what follows, we usually omit · and write simply Iw
instead of I · w.

A path π from a state q0 to a state qn under a word a1a2 ··· an, for some n ≥ 0, is a
sequence of states and input symbols q0a1q1a2 . . . qn−1anqn such that qi+1 ∈ qi · ai+1, for
all i = 0, 1, . . . , n − 1. The path π is accepting if q0 ∈ I and qn ∈ F. We use the notation
a1a2···an
−−−−−−→ qn to denote that there exists a path from q0 to qn under the word a1a2 ··· an.
q0
A path is simple if all states of the path are pairwise distinct. The number of states on the
longest simple path of A, starting in an initial state, decreased by one (i.e., the number of
transitions on that path) is called the depth of the automaton A, denoted by depth(A).

T. Masopust

3

The NFA A is complete if for every state q of A and every letter a in Σ, the set q · a is

nonempty, that is, in every state, a transition under every letter is deﬁned.
Let A = (Q, Σ,·, I, F) be an NFA, and let p be a state of A. The sub-automaton of A
induced by state p is the automaton Ap = (reach(p), Σ,·p, p, F ∩ reach(p)) with state p being
the sole initial state and with only those states of A that are reachable from p; formally,
reach(p) denotes the set of all states reachable from state p in A and ·p is a restriction of ·
to reach(p) × Σ.
The NFA A is deterministic (DFA) if |I| = 1 and |q · a| = 1 for every state q in Q and
every letter a in Σ. Then the transition function · is a map from Q × Σ to Q that can be
extended to the domain Q × Σ∗ by induction. Two states of a DFA are distinguishable if
there exists a word w that is accepted from one of them and rejected from the other. A DFA
is minimal if all its states are reachable and pairwise distinguishable.

Let A = (Q, Σ,·, I, F) be an NFA. The reachability relation ≤ on the set of states is
deﬁned by p ≤ q if there exists a word w in Σ∗ such that q ∈ p · w. The NFA A is partially
ordered if the reachability relation ≤ is a partial order. For two states p and q of A, we
write p < q if p ≤ q and p 6= q. A state p is maximal if there is no state q such that p < q.
Partially ordered automata are sometimes also called acyclic automata.

An NFA A = (Q, Σ,·, I, F) can be turned into a directed graph G(A) with the set of
vertices Q, where a pair (p, q) in Q × Q is an edge in G(A) if there is a transition from
p to q in A. For Γ ⊆ Σ, we deﬁne the directed graph G(A, Γ) with the set of vertices
Q by considering all those transitions that correspond to letters in Γ. For a state p, let
Σ(p) = {a ∈ Σ | p ∈ p · a} denote the set of all letters under which the NFA A has a self-loop
in state p. Let A be a partially ordered NFA. If for every state p of A, state p is the unique
maximal state of the connected component of G(A, Σ(p)) containing p, then we say that the
NFA satisﬁes the unique maximal state (UMS) property.

An equivalent notion to the UMS property for minimal DFAs has been introduced in the
literature. A DFA A over Σ is conﬂuent if, for every state q of A and every pair of letters
a, b in Σ, there exists a word w in {a, b}∗ such that (qa)w = (qb)w.
We adopt the notation La1a2···an = Σ∗a1Σ∗a2Σ∗ ··· Σ∗anΣ∗ from [19]. For two words
v = a1a2 ··· an and w ∈ Lv, we say that v is a subsequence of w or that v can be embedded
into w, denoted by v (cid:52) w. For k ≥ 0, let subk(v) = {u ∈ Σ∗ | u (cid:52) v, |u| ≤ k}. For two words
w1, w2, deﬁne w1 ∼k w2 if and only if subk(w1) = subk(w2). Note that ∼k is a congruence
with ﬁnite index.

The following is well known.

(cid:73) Fact 1 ([29]). Let L be a regular language, and let ∼L denote the Myhill congruence [23].
A language L is k-piecewise testable if and only if ∼k⊆∼L. Moreover, L is a ﬁnite union of
∼k classes.

We will use this fact in several proofs in the form that if L is not k-piecewise testable,

then there exist two words u and v such that u ∼k v and |L ∩ {u, v}| = 1.
(cid:73) Fact 2. Let L be a language recognized by the minimal DFA A. The following is equivalent.
1. The language L is piecewise testable.
2. The minimal DFA A is partially ordered and conﬂuent [19].
3. The minimal DFA A is partially ordered and satisﬁes the UMS property [33].

We now deﬁne a special class of nondeterministic automata called ptNFAs. The name
comes from piecewise testable, since, as we show below, they characterize piecewise testable
languages. And indeed include all minimal DFAs recognizing piecewise testable languages.

ArXiv

4

Piecewise Testable Languages and Nondeterministic Automata

a, b

0

a

a

1

a, b

2

b

Figure 1 Conﬂuent automaton accepting a non-piecewise testable language

(cid:73) Deﬁnition 3. An NFA A is called a ptNFA if it is partially ordered, complete and satisﬁes
the UMS property.

The reason why we use the UMS property in the deﬁnition of ptNFAs rather than the
notion of conﬂuence is simply because conﬂuence does not naturally generalize to NFAs, as
shown in Example 4 below.
(cid:73) Example 4. Consider the automaton depicted in Figure 1. The notion of conﬂuence is not
clear for NFAs. If we consider the point of view that whenever the computation is split, a
common state can be reached under a word over the splitting alphabet, then this automaton
is conﬂuent. However, it does not satisfy the UMS property and its language is not piecewise
testable; there is an inﬁnite sequence a, ab, aba, abab, . . . that alternates between accepted
and non-accepted words, which implies that there is a non-trivial cycle in the corresponding
minimal DFA and, thus, it proves non-piecewise testability by Fact 2.

Note that to check whether an NFA is a ptNFA requires to check whether the automaton is
partially ordered, complete and satisﬁes the UMS property. The violation of these properties
can be tested by several reachability tests, hence its complexity belongs to coNL=NL. On
the other hand, to check the properties is NL-hard even for minimal DFAs [5]. Thus, we
have the following.
(cid:73) Theorem 5. It is NL-complete to check whether an NFA is a ptNFA.

3 Motivation and an Example
Considering applications, such as XML, where the alphabet can hardly be considered as ﬁxed,
the results of [18] (cf. Theorem 17 below) say that it is intractable to compute the minimal k
for which a piecewise testable language is k-piecewise testable, unless coNP=P. This leads to
the investigation of reasonably small upper bounds. Recall that the result of [19] says that k
is bounded by the depth of the minimal DFA. However, applications usually require to work
with NFAs, which motivates the research of this paper. Another motivation comes from a
simple observation that, given several DFAs, a result of an operation can lead to an NFA
that in some sense still have the DFA-like properties, see more discussion below. Moreover, it
seems to be a human nature to use a kind of nondeterminism, for instance, to reuse already
deﬁned parts as demonstrated here on a very simple example.
Let L0 = {ε} be a language over the alphabet Σ0 = {a0}. Assume that the language Li
over Σi is deﬁned, and let Li+1 = Li ∪ Σ∗
i ai+1Li over Σi+1 = Σi ∪ {ai+1}, where ai+1 is a
new symbol not in Σi. We now construct the NFAs for the languages Li,

Ai = ({0, 1, . . . , i},{a0, a1, . . . , ai},·,{0, 1, . . . , i},{0})

where ‘ · aj = ‘ if i ≥ ‘ > j ≥ 0 and ‘ · a‘ = {0, 1, . . . , ‘ − 1} if i ≥ ‘ ≥ 1. The automaton A3
is depicted in Figure 2. The dotted transitions are to “complete” the NFA in the meaning
that ‘ · a 6= ∅ for any state ‘ and letter a.

T. Masopust

5

a3

a2, a3

a1

0

a0, a1, a2, a3

Σ3

s

a0, a1, a2

a0, a1

3

a3

2

a3

a2

a3

a0

1

a2

Figure 2 Automaton A3; the dotted transitions depict the completion of A3

Although the example is very simple, the reader can see the point of the construction in

nondeterministically reusing the existing parts.

Now, to decide whether the language is piecewise testable and, if so, to obtain an upper
bound on its k-piecewise testability, the known results for DFAs say that we need to compute
the minimal DFA. Doing so shows that Li is piecewise testable. However, the minimal DFA
for the language Li is of exponential size and its depth is 2i+1 − 1, cf. [22], which implies
that Li is (2i+1 − 1)-piecewise testable. Another way is to use the PSPACE algorithm of [22]
to compute the minimal k. Both approaches are basically of the same complexity.

This is the place, where our result comes into the picture. According to Theorem 8
proved in the next section, the easily testable structural properties say that the language Li
is (i + 1)-piecewise testable. This provides an exponentially better upper bound for every
language Li than the technique based on minimal DFAs. Finally, we note that it can be
shown that Li is not i-piecewise testable, so the bound is tight.

4

Piecewise Testability and Nondeterminism

In this section, we establish a relation between piecewise testable languages and nondetermin-
istic automata and generalize the bound given by the depth of DFAs to ptNFAs. We ﬁrst
recall the know result for DFAs.
(cid:73) Theorem 6 ([19]). Let A be a partially ordered and conﬂuent DFA. If the depth of A is k,
then the language L(A) is k-piecewise testable.

This result is currently the best known structural upper bound on k-piecewise testability.
The opposite implication of the theorem does not hold and we have shown in [22] (see also
Section 3) that this bound can be exponentially far from the minimal value of k. This
observation has motivated our investigation of the relationship between piecewise testability
and the depth of NFAs. We have already generalized a structural automata characterization
for piecewise testability from DFAs to NFAs as follows.
(cid:73) Theorem 7 ([22]). A regular language is piecewise testable if and only if it is recognized
by a ptNFA.

We now generalize Theorem 6 to ptNFAs and discuss the relation between the depth of
NFAs and k-piecewise testability in more detail. An informal idea behind the proof is that
every ptNFA can be “decomposed” into a ﬁnite number of partially ordered and conﬂuent

ArXiv

6

Piecewise Testable Languages and Nondeterministic Automata

DFAs. We now formally prove the theorem by generalizing the proof of Theorem 6 given
in [19].
(cid:73) Theorem 8. If the depth of a ptNFA A is k, then the language L(A) is k-piecewise testable.

The proof of Theorem 8 follows directly from Lemmas 9 and 11 proved below.

(cid:73) Lemma 9. Let A be a ptNFA with I denoting the set of initial states. Then the language

i∈I L(Ai), where every sub-automaton Ai is a ptNFA.

L(A) =S

Based on the previous lemma, it is suﬃcient to show the theorem for ptNFAs with a

single initial state. We make use of the following lemma.
(cid:73) Lemma 10 ([19]). Let ‘ ≥ 1, and let u, v ∈ Σ∗ be such that u ∼‘ v. Let u = u0au00 and
v = v0av00 such that a /∈ alph(u0v0). Then u00 ∼‘−1 v00.
(cid:73) Lemma 11. Let A be a ptNFA with a single initial state and depth k. Then the language
L(A) is k-piecewise testable.
Proof. Let A = (Q, Σ,·, i, F). If the depth of A is 0, then L(A) is either ∅ or Σ∗, which are
both 0-piecewise testable by deﬁnition. Thus, assume that the depth of A is ‘ ≥ 1 and that
the claim holds for ptNFAs of depth less than ‘. Let u, v ∈ Σ∗ be such that u ∼‘ v. We
prove that u is accepted by A if and only if v is accepted by A.
Assume that u is accepted by A and ﬁx an accepting path of u in A. If alph(u) ⊆ Σ(i), then
the UMS property of A implies that i ∈ F. Therefore, v is also accepted in i. If alph(u) 6⊆ Σ(i),
then u = u0au00 and v = v0bv00, where u0, v0 ∈ Σ(i)∗, a, b ∈ Σ \ Σ(i), and u00, v00 ∈ Σ∗. Let
p ∈ i· a be a state on the ﬁxed accepting path of u. Let Ap = (reach(p), Σ,·p, p, F ∩ reach(p))
be a sub-automaton of A induced by state p. Note that Ap is a ptNFA. By assumption, Ap
accepts u00 and the depth of Ap is at most ‘ − 1.
If a = b, Lemma 10 implies that u00 ∼‘−1 v00. By the induction hypothesis, u00 is accepted
by Ap if and only if v00 is accepted by Ap. Hence, v = v0av00 is accepted by A.
0) and a /∈ alph(v0bv00
If a 6= b, then u = u0au00
0 ).

1 , where b /∈ alph(u0au00

1 and v = v0bv00

0 av00

0 bu00

Then

0 bu00

u00 = u00

1 ∼‘−1 v00
because, by Lemma 10,

0 av00

1 = v00

0 bu00

0 av00

0 bu00
1) .

1 ) ⊆ sub‘−1(v00

1) ⊆ sub‘−1(u00

accepted by A.

1) = sub‘−1(v00

1 ) = sub‘−1(u00

sub‘−1(u00
(*)
If p ∈ i · b, the induction hypothesis implies that v00 is accepted by Ap, hence v = v0bv00 is
If p /∈ i · b, let q ∈ i · b. By the properties of A, there exists a word w ∈ {a, b}∗ such that
pw = qw = r, for some state r. Indeed, there exists w1 and a unique maximal state r with
respect to {a, b} such that pw1 = {r} and a, b ∈ Σ(r). By the UMS property, there exists
w2 such that qw1w2 = {r}. Let w = w1w2. We now show that wu00 ∼‘−1 u00 by induction
on the length of w. There is nothing to show for w = ε. Thus, assume that w = xw0, for
1 ∼‘−1 v00 ∼‘−1 u00
x ∈ {a, b}, and that w0u00 ∼‘−1 u00. Notice that (*) shows that u00 ∼‘−1 v00
1.
1 ) = sub‘−1(v00) = sub‘−1(v00
This implies that sub‘−1(v00
1 ),
1 ∼‘−1 v00
1 ∼‘−1 u00
which shows that av00
1. If x = a, then
1 ∼‘−1 u00. Similarly, if x = b,
w0u00 ∼‘−1 u00 ∼‘−1 v00
1 implies that aw0u00 ∼‘−1 av00
1 ∼‘−1 u00. Therefore,
then w0u00 ∼‘−1 u00 ∼‘−1 u00
1 ∼‘−1 u00
wu00 ∼‘−1 u00. Analogously, wv00 ∼‘−1 v00.

0 av00
1 . Similarly we can show that bu00
1 ∼‘−1 v00
1 implies that bw0u00 ∼‘−1 bu00

1 ) ⊆ sub‘−1(av00

1 ) ⊆ sub‘−1(v00

T. Masopust

7

a

i0

a

. . .

a

a

10

20

a

a

a

0

1

a

2

a

a

. . .

a

i

Figure 3 The NFA of depth i recognizing Li

Finally, using the induction hypothesis (of the main statement) on Ap, we get that u00 is
accepted by Ap if and only if wu00 is accepted by Ap, which is if and only if u00 is accepted
by Ar. Since u00 ∼‘−1 v00, the induction hypothesis applied on Ar gives that u00 is accepted
by Ar if and only if v00 is accepted by Ar. However, this is if and only if wv00 is accepted by
Aq. Using the induction hypothesis on Aq, we obtain that wv00 is accepted by Aq if and only
if v00 is accepted by Aq. Together, the assumption that u00 is accepted by Ap implies that v00
is accepted by Aq. Hence v = v0bv00 is accepted by A, which completes the proof.
(cid:74)

In other words, the previous theorem says that if k is the minimum number for which a
piecewise testable language L is k-piecewise testable, then the depth of any ptNFA recognizing
L is at least k.

It is natural to ask whether this property holds for any NFA recognizing the language
L. The following result shows that it is not the case. Actually, for any natural number ‘,
there exists a piecewise testable language such that the diﬀerence between its k-piecewise
testability and the depth of an NFA is at least ‘.
(cid:73) Theorem 12. For every k ≥ 3, there exists a k-piecewise testable language that is recognized

by an NFA of depth at most(cid:4) k

(cid:5).

2

Proof. For every i ≥ 1, let Li = ai + a2i+1 · a∗. We show that the language Li is (2i + 1)-
piecewise testable and that there exists an NFA of depth at most i recognizing it.
The minimal DFA for Li consists of 2i + 1 states {0, 1, . . . , 2i + 1}, where 0 is the initial
state, i and 2i + 1 are accepting, p · a = p + 1 for p < 2i + 1, and (2i + 1) · a = 2i + 1. The
depth is 2i + 1, which shows that Li is (2i + 1)-piecewise testable. Notice that a2i ∼2i a2i+1,
but a2i does not belong to Li, hence Li is not 2i-piecewise testable.

The NFA for Li consists of two cycles of length i + 1, the structure is depicted in Figure 3.
The initial state is state 0 and the solely accepting state is state i. The automaton accepts Li.
Indeed, it accepts ai and no shorter word. After reading ai, the automaton is in state i or i0.
In both cases, the shortest nonempty path to the single accepting state i is of length i + 1.
Thus, the automaton accepts a2i+1, but nothing between ai and a2i+1. Finally, using the
self-loop in state i0, the automaton accepts aia∗ai+1 = a2i+1a∗. The depth of the automaton
(cid:74)
is i.

4.1 Piecewise Testability and the Depth of NFAs
Theorem 8 gives rise to a question, whether the opposite implication holds true.

For instance, for an alphabet Σ, the language L =T

Notice that although the depth of ptNFAs is more suitable to provide bounds on k-
piecewise testability, the depth is signiﬁcantly inﬂuenced by the size of the input alphabet.
a∈Σ La of all words containing all letters
of Σ is a 1-piecewise testable language such that any NFA recognizing it requires at least
2|Σ| states and is of depth |Σ|, cf. [22].

ArXiv

8

Piecewise Testable Languages and Nondeterministic Automata

on the depth of the minimal DFA recognizing it is(cid:0)k+n

Considering the opposite direction of Theorem 8, it was independently shown in [18, 22]
that, given a k-piecewise testable language over an n-letter alphabet, the tight upper bound
gives the tight upper bound on the depth of the ∼k-canonical DFA [22] over an n element
alphabet. A related question on the size of this DFA is still open, see [17] for more details.

(cid:1) − 1. In other words, this formula

k

We recall the result for DFAs.

(cid:73) Theorem 13 ([18, 22]). For any natural numbers k and n, the depth of the minimal DFA

recognizing a k-piecewise testable language over an n-letter alphabet is at most (cid:0)k+n

(cid:1) − 1.

k

The bound is tight for any k and n.

It remains open whether this is also a lower bound for NFAs or ptNFAs.

Application and Discussion

5
The reader might have noticed that the reverse of the automaton Ai constructed in Section 3
is deterministic and, when made complete, it satisﬁes the conditions of Fact 2. Since, by
deﬁnition, a language is k-piecewise testable if and only if its reverse is k-piecewise testable,
this observation provides the same upper bound i+1 on k-piecewise testability of the language
L(Ai). However, this is just a coincidence and it is not diﬃcult to ﬁnd an example of a
ptNFA whose reverse is not deterministic.

Since both the minimal DFA for L and the minimal DFA for LR provide an upper bound
on k, it could seem reasonable to compute both DFAs in parallel with the hope that (at
least) one of them will be computed in a reasonable (polynomial) time. Although this may
work for many cases (including the case of Section 3), we now show that there are cases
where both the DFAs are of exponential size.
(cid:73) Theorem 14. For every n ≥ 0, there exists a (2n + 1)-state ptNFA B such that the depth
of both the minimal DFA for L(B) and the minimal DFA for L(B)R are exponential with
respect to n.
Proof sketch. The idea of the proof is to make use of the automaton Ai constructed in
Section 3 to build a ptNFA Bi such that L(Bi) = L(Ai) · L(Ai)R. Then L(Bi) = L(Bi)R
and it can be shown that the minimal DFA recognizing the language L(Bi) requires an
exponential number of states compared to Bi. Namely, the depth of both the minimal DFA
for L(Bi) and the minimal DFA for L(Bi)R are of length at least 2i+1 − 1.
(cid:74)

The previous proof provides another motivation to investigate nondeterministic automata
for piecewise testable languages. Given several DFAs, the result of a sequence of operations
may result in an NFA that preserves some good properties. Namely, the language L(Bi)
from the previous proof is a result of the operation concatenation of a language LR with L,
where L is a piecewise testable language given as a DFA.

It immediately follows from Theorem 8 that the language L(Bi) is (2i + 1)-piecewise
testable. This result is not easily derivable from known results, which are either in PSPACE
or require to compute an exponentially larger minimal DFA, which anyway provides only the
information that the language L(Bi) is k-piecewise testable for some k ≥ 2i+1 − 1.

Even the information that the language L(Bi) = LR · L, for a piecewise testable language
L, does not seem very helpful, since, as we show in the example below, piecewise testable
languages are not closed under the concatenation even with its own reverse.

T. Masopust

9

(cid:73) Example 15. Let L be the language over the alphabet {a, b, c} deﬁned by the regular
expression ab∗ + c(a + b)∗. The reader can construct the minimal DFA for L and check that
the properties of Fact 2 are satisﬁed. In addition, the depth of the minimal DFA is two,
hence the language is 2-piecewise testable. Since the properties of Theorem 18 (see below)
are not satisﬁed, the language L is not 1-piecewise testable.

On the other hand, the reader can notice that the sequence ca, cab, caba, cabab, cababa, . . .
is an inﬁnite sequence where every word on the odd position belongs to L· LR, whereas every
word on the even position does not. This means that there exists a cycle in the minimal DFA
recognizing L · LR, which shows that L · LR is not a piecewise testable language according
to Fact 2. The reader can also directly compute the minimal DFA for L · LR and notice a
non-trivial cycle in it.

To complete this part, we show that the language L(Bi) is not (2i)-piecewise testable.

Thus, there are no ptNFAs recognizing the language L(Bi) with depth less then 2i + 1.
(cid:73) Lemma 16. For every i ≥ 0, the language L(Bi) is not 2i-piecewise testable.

Complexity

6
In this section, we ﬁrst give an overview of known complexity results and characterization
theorems for DFAs and then discuss the related complexity for ptNFAs.

Simon [29] proved that piecewise testable languages are exactly those regular languages
whose syntactic monoid is J -trivial, which shows decidability of the problem whether a
regular language is piecewise testable. Later, Stern proved that the problem is decidable in
polynomial time for languages represented as minimal DFAs [30], and Cho and Huynh [5]
showed that it is NL-complete for DFAs. Trahtman [33] improved Stern’s result by giving an
algorithm quadratic in the number of states of the minimal DFA, and Klíma and Polák [19]
presented an algorithm quadratic in the size of the alphabet of the minimal DFA. If the
language is represented as an NFA, the problem is PSPACE-complete [15] (see more details
below).

By deﬁnition, a regular language is piecewise testable if there exists k such that it is
k-piecewise testable. It gives rise to a question to ﬁnd such a minimal k. The k-piecewise
testability problem asks, given an automaton, whether it recognizes a k-piecewise testable
language. The problem is trivially decidable because there are only ﬁnitely many k-piecewise
testable languages over a ﬁxed alphabet. The coNP upper bound on k-piecewise testability
for DFAs was independently shown in [13, 22].1 The coNP-completeness for k ≥ 4 was
recently shown in [18]. The complexity holds even if k is given as part of the input. The
complexity analysis of the problem for k < 4 is provided in [22]. We recall the results we
need later.
(cid:73) Theorem 17 ([18]). For k ≥ 4, to decide whether a DFA represents a k-piecewise testable
language is coNP-complete. It remains coNP-complete even if the parameter k ≥ 4 is given
as part of the input. For a ﬁxed alphabet, the problem is decidable in polynomial time.

It is not diﬃcult to see that, given a minimal DFA, it is decidable in constant time

whether its language is 0-piecewise testable, since it is either empty or Σ∗.

1 Actually, [13] gives the bound NEXPTIME for the problem for NFAs where k is part of the input. The
coNP bound for DFAs can be derived from the proof omitted in the conference version. The problem is
formulated in terms of separability, hence it requires the NFA for the language and for its complement.

ArXiv

10

Piecewise Testable Languages and Nondeterministic Automata

(cid:73) Theorem 18 (1-piecewise testability DFAs, [22]). Let A = (Q, Σ,·, i, F) be a minimal DFA.
Then L(A) is 1-piecewise testable if and only if (i) for every p ∈ Q and a ∈ Σ, paa = pa and
(ii) for every p ∈ Q and a, b ∈ Σ, pab = pba. The problem is in AC0.

It is not hard to see that this result does not hold for ptNFAs. Indeed, one can simply
consider a minimal DFA satisfying the properties and add a nondeterministic transition that
violates them, but not the properties of ptNFAs. On the other hand, the conditions are still
suﬃcient.
(cid:73) Lemma 19 (1-piecewise testability ptNFAs). Let A = (Q, Σ,·, i, F) be a complete NFA. If
(i) for every p ∈ Q and a ∈ Σ, paa = pa and (ii) for every p ∈ Q and a, b ∈ Σ, pab = pba,
then the language L(A) is 1-piecewise testable.

Note that any ptNFA A satisfying (i) must have |pa| = 1 for every state p and letter a. If
pa = {r1, r2, . . . , rm} with r1 < r2 < . . . < rm, then paa = pa implies that {r1, . . . , rm}a =
{r1, . . . , rm}. Then r1 ∈ r1a and the UMS property says that r1a = {r1}. By induction,
we can show hat ria = {ri}. Consider the component of G(A, Σ(r1)) containing r1. Then
r1, . . . , rm all belong to this component. Since r1 is maximal, r1 is reachable from every ri
under Σ(r1) ⊇ {a}. However, the partial order r1 < . . . < rm implies that r1 is reachable
from ri only if ri = r1. Thus, |pa| = 1. However, A can still have many initial states, which
can be seen as a ﬁnite union of piecewise testable languages rather then a nondeterminism.

The 2-piecewise testability characterization for DFAs is as follows.

(cid:73) Theorem 20 (2-piecewise testability DFAs, [22]). Let A = (Q, Σ,·, i, F) be a minimal
partially ordered and conﬂuent DFA. The language L(A) is 2-piecewise testable if and only
if for every a ∈ Σ and every state s such that iw = s for some w ∈ Σ∗ with |w|a ≥ 1,
sba = saba for every b ∈ Σ ∪ {ε}. The problem is NL-complete.

It is again suﬃcient for ptNFAs.

(cid:73) Lemma 21 (2-piecewise testability ptNFAs). Let A = (Q, Σ,·, i, F) be a ptNFA. If for every
a ∈ Σ and every state s such that iw = s for some w ∈ Σ∗ with |w|a ≥ 1, sba = saba for
every b ∈ Σ ∪ {ε}, then the language L(A) is 2-piecewise testable.

Considering Theorem 17, the lower bound for DFAs is indeed a lower bound for ptNFAs.
Thus, we immediately have that the k-piecewise testability problem for ptNFAs is coNP-hard
for k ≥ 4. We now show that it is actually coNP-hard for every k ≥ 0. The proof is split
into two lemmas.

The proof of the following lemma is based on the proof that the non-equivalence problem
for regular expressions with operations union and concatenation is NP-complete, even if one
of them is of the form Σn for some ﬁxed n [16, 31].
(cid:73) Lemma 22. The 0-piecewise testability problem for ptNFAs is coNP-hard (even if the
alphabet is binary).

It seems natural that the (k + 1)-piecewise testability problem is not easier then the
k-piecewise testability problem. We now formalize this intuition. We also point out that our
reduction introduces a new symbol to the alphabet.
(cid:73) Lemma 23. For k ≥ 0, k-piecewise testability is polynomially reducible to (k +1)-piecewise
testability.

Together, since the k-piecewise testability problem for NFAs is in PSPACE [22], we have

the following result.
(cid:73) Theorem 24. For k ≥ 0, the k-piecewise testability problem for ptNFAs is coNP-hard and
in PSPACE.

T. Masopust

11

The case of a ﬁxed alphabet. The previous discussion is for the general case where the
alphabet is arbitrary and considered as part of the input. In this subsection, we assume that
the alphabet is ﬁxed. In this case, it is shown in the arxiv versions v1–v4 of [17] that the

length of the shortest representatives of the ∼k-classes is bounded by the number(cid:0) k+2c−1

where c is the cardinality of the alphabet. This gives us the following result for 0-piecewise
testability for ptNFAs.
(cid:73) Lemma 25. For a ﬁxed alphabet Σ with c = |Σ| ≥ 2, the 0-piecewise testability problem
for ptNFAs is coNP-complete.

(cid:1)c,

c

Proof. The hardness follows from Lemma 22, since it is suﬃcient to use a binary alphabet.
We now prove completeness. Let A be a ptNFA over Σ of depth d recognizing a nonempty
language (this can be checked in NL). Then the language L(A) is d-piecewise testable by
Theorem 8. This means that if v ∼d u, then either both u and v are accepted or both are
rejected by A. Now, the language L(A) 6= ∅ is not 0-piecewise testable if and only if L(A)
is non-universal. Since Σ is ﬁxed, the shortest representative of any of the ∼d-classes is of
language L(A) is not universal, then the nondeterministic algorithm can guess a shortest
representative of a non-accepted ∼d-class and verify the guess in polynomial time.
(cid:74)

(cid:1)c = O(dc), which is polynomial in the depth of A. Thus, if the

length less than(cid:0) d+2c−1

c

We can now generalize this result to k-piecewise testability.

(cid:73) Theorem 26. Let Σ be a ﬁxed alphabet with c = |Σ| ≥ 2, and let k ≥ 0. Then the problem
to decide whether the language of a ptNFA A over Σ is k-piecewise testable is coNP-complete.
Note that this is in contrast with the analogous result for DFAs, cf. Theorem 17, where
the problem is in P for DFAs over a ﬁxed alphabet. In addition, the hardness part of the
previous proof gives us the following corollary, which does not follow from the hardness proof
of [18], since the proof there requires a growing alphabet.
(cid:73) Corollary 27. The k-piecewise testability problem for ptNFAs over an alphabet Σ is coNP-
hard for k ≥ 0 even if |Σ| = 3.

The case of a unary alphabet. Since Lemma 25 (resp. Lemma 22) requires at least two
letters in the alphabet to prove coNP-hardness, it remains to consider the case of a unary
alphabet. We now show that the problem is simpler, unless P=coNP. Namely, a similar
argument as in the proof of Lemma 25, improved by the fact that the length of the shortest
representatives of ∼k-classes is bounded by the depth of the ptNFA, gives the following
result.
(cid:73) Theorem 28. The k-piecewise testability problem for ptNFAs over a unary alphabet is
decidable in polynomial time. The result holds even if k is given as part of the input.

In contrast to this, we now show that the problem is coNP-complete for general NFAs.
(cid:73) Theorem 29. Both piecewise testability and k-piecewise testability problems for NFAs over
a unary alphabet are coNP-complete.

The complexity of k-piecewise testability for considered automata is summarized in
Table 1. Note that the precise complexity of k-piecewise testability for ptNFAs is not yet
known in the case the alphabet is consider as part of the input even for k = 0.

ArXiv

12

Piecewise Testable Languages and Nondeterministic Automata

Unary alphabet

Fixed alphabet

Arbitrary alphabet

k ≤ 3

k ≥ 4

DFA
ptNFA

P
P

P [18]

coNP-complete

NFA coNP-complete

PSPACE-complete [22]

NL-complete [22]

coNP-complete [18]

PSPACE & coNP-hard
PSPACE-complete [22]

Table 1 Complexity of k-piecewise testability – an overview

Conclusion

7
In this paper, we have deﬁned a class of nondeterministic ﬁnite automata (ptNFAs) that
characterize piecewise testable languages. We have shown that their depth (exponentially)
improves the known upper bound on k-piecewise testability shown in [19] for DFAs. We have
discussed several related questions, mainly in comparison with DFAs and NFAs, including the
complexity of k-piecewise testability for ptNFAs. It can be noticed that the results for ptNFAs
generalize the results for DFAs in the sense that the results for DFAs are consequences of
the results presented here. This, however, does not hold for the complexity results.

The length of a shortest proof over an arbitrarily alphabet.
It is an open question what is
the complexity of k-piecewise testability if the alphabet is consider as part of the input. Notice
that the results of [17] give a lower bound on the maximal length of the shortest representative
of a class. Namely, let Lk(n) denote the maximal length of the shortest representatives of
the ∼k-classes over an n-element alphabet. Then (Ln(k) + 1) log n > ( k
n). Setting
k = n2 then gives that Ln(n2) > nn−1. Thus, the representative can be of exponential length
with respect to the size of the alphabet. However, how many states does a ptNFA require to
exclude such a representative while accepting every shorter word?

n)n−1 log( k

Acknowledgements. We thank the authors of [13] and [18] for providing us with full
versions of their papers.

References

1 A. V. Aho, J. E. Hopcroft, and J. D. Ullman. The Design and Analysis of Computer

Algorithms. Addison-Wesley, 1974.
J. Almeida, J. C. Costa, and M. Zeitoun. Pointlike sets with respect to R and J. Journal
of Pure and Applied Algebra, 212(3):486–499, 2008.
J. Almeida and M. Zeitoun. The pseudovariety J is hyperdecidable. RAIRO – Theoretical
Informatics and Applications, 31(5):457–482, 1997.

4 M. Bojanczyk, L. Segouﬁn, and H. Straubing. Piecewise testable tree languages. Logical

Methods in Computer Science, 8(3), 2012.
S. Cho and D. T. Huynh. Finite-automaton aperiodicity is PSPACE-complete. Theoretical
Computer Science, 88(1):99–116, 1991.

6 R. S. Cohen and J. A. Brzozowski. Dot-depth of star-free events. Journal of Computer and

2

3

5

System Sciences, 5(1):1–16, 1971.

7 W. Czerwiński, W. Martens, and T. Masopust. Eﬃcient separability of regular languages

by subsequences and suﬃxes. In ICALP, volume 7966 of LNCS, pages 150–161, 2013.

8 W. Czerwiński, W. Martens, L. van Rooijen, and M. Zeitoun. A note on decidable separ-
In FCT, volume 9210 of LNCS, pages 173–185,

ability by piecewise testable languages.
2015.

T. Masopust

13

10

11

12

9 V. Diekert, P. Gastin, and M. Kuﬂeitner. A survey on small fragments of ﬁrst-order logic
over ﬁnite words. Int. Journal of Foundations of Computer Science, 19(3):513–548, 2008.
J. Fu, J. Heinz, and H. G. Tanner. An algebraic characterization of strictly piecewise
languages. In TAMC, volume 6648 of LNCS, pages 252–263. 2011.
P. García and J. Ruiz. Learning k-testable and k-piecewise testable languages from positive
data. Grammars, 7:125–140, 2004.
P. García and E. Vidal. Inference of k-testable languages in the strict sense and application
to syntactic pattern recognition.
IEEE Transactions on Pattern Analysis and Machine
Intelligence, 12(9):920–925, 1990.
P. Hofman and W. Martens. Separability by short subsequences and subwords. In ICDT,
volume 31 of LIPIcs, pages 230–246, 2015.
Š. Holub, G. Jirásková, and T. Masopust. On upper and lower bounds on the length of
alternating towers. In MFCS, volume 8634 of LNCS, pages 315–326, 2014.
Š. Holub, T. Masopust, and M. Thomazo. Alternating towers and piecewise testable sep-
arators. CoRR, abs/1409.3943, 2014.

13

14

15

17

16 H. B. Hunt III. On the Time and Tape Complexity of Languages. PhD thesis, Department

of Computer Science, Cornell University, Ithaca, NY, 1973.
P. Karandikar, M. Kuﬂeitner, and Ph. Schnoebelen. On the index of Simon’s congruence
for piecewise testability. Information Processing Letters, 115(4):515–519, 2015.
18 O. Klíma, M. Kunc, and L. Polák. Deciding k-piecewise testability. Submitted.
19 O. Klíma and L. Polák. Alternative automata characterization of piecewise testable lan-

guages. In DLT, volume 7907 of LNCS, pages 289–300, 2013.
L. Kontorovich, C. Cortes, and M. Mohri. Kernel methods for learning languages. Theor-
etical Computer Science, 405(3):223–236, 2008.

20

21 M. Kuﬂeitner and A. Lauser. Around dot-depth one. International Journal of Foundations

of Computer Science, 23(6):1323–1340, 2012.

22 T. Masopust and M. Thomazo. On the complexity of k-piecewise testability and the depth

of automata. In DLT, volume 9168 of LNCS, pages 364–376, 2015.
J. Myhill. Finite automata and representation of events. Technical report, Wright Air
Development Center, 1957.

24 D. Perrin and J.-E. Pin. First-order logic and star-free sets. Journal of Computer and

23

System Sciences, 32(3):393–406, 1986.

25 D. Perrin and J.-E. Pin. Inﬁnite words: Automata, semigroups, logic and games, volume

141 of Pure and Applied Mathematics. 2004.

26 T. Place, L. van Rooijen, and M. Zeitoun. Separating regular languages by piecewise
In MFCS, volume 8087 of LNCS, pages 729–740,

testable and unambiguous languages.
2013.
J. Rogers, J. Heinz, G. Bailey, M. Edlefsen, M. Visscher, D. Wellcome, and S. Wibel. On
languages piecewise testable in the strict sense.
In MOL, volume 6149 of LNAI, pages
255–265, 2010.
J. Rogers, J. Heinz, M. Fero, J. Hurst, D. Lambert, and S. Wibel. Cognitive and sub-regular
complexity. In FG, volume 8036 of LNCS, pages 90–108, 2013.
I. Simon. Hierarchies of Events with Dot-Depth One. PhD thesis, Department of Applied
Analysis and Computer Science, University of Waterloo, Canada, 1972.
J. Stern. Complexity of some problems from the theory of automata. Information and
Control, 66(3):163–176, 1985.
L. J. Stockmeyer and A. R. Meyer. Word problems requiring exponential time: Preliminary
report. In STOC, pages 1–9. ACM, 1973.

27

28

29

30

31

32 W. Thomas. Classifying regular events in symbolic logic. Journal of Computer and System

Sciences, 25(3):360–376, 1982.

ArXiv

14

Piecewise Testable Languages and Nondeterministic Automata

a0, a1

2

a2

a0

1

a2

a1

0

a1

a2

a0

−1

a2

a0

a0, a1

Σ2

a2

−2

a2

s

a1

Figure 4 Automaton B2 (without dotted transitions) and its completion (with dotted transitions)

33 A. N. Trahtman. Piecewise and local threshold testability of DFA. In FCT, volume 2138

of LNCS, pages 347–358, 2001.
L. van Rooijen. A combinatorial approach to the separation problem for regular languages.
PhD thesis, LaBRI, University of Bordeaux, France, 2014.

34

Proofs of Section 4

8
(cid:73) Lemma 9. Let A be a ptNFA with I denoting the set of initial states. Then the language

i∈I L(Ai), where every sub-automaton Ai is a ptNFA.

L(A) =S
Proof. Indeed, L(A) =S

i∈I L(Ai) holds. It remains to show that every Ai is partially order,
complete, and satisﬁes the UMS property. However, Ai is obtained from A by removing
the states not reachable from i and the corresponding transitions. Since A is complete and
partially ordered, so is Ai. If the UMS property was not satisﬁed in Ai, it would not be
satisﬁed in A either, hence Ai satisﬁes the UMS property.
(cid:74)

Proofs of Section 5

9
(cid:73) Theorem 14. For every n ≥ 0, there exists a (2n + 1)-state ptNFA B such that the depth
of both the minimal DFA for L(B) and the minimal DFA for L(B)R are exponential with
respect to n.
Proof. The idea of the proof is to make use of the automaton Ai constructed in Section 3 to
build a ptNFA Bi such that L(Bi) = L(Ai) · L(Ai)R. Then L(Bi) = L(Bi)R and we show
that the minimal DFA recognizing the language L(Bi) requires an exponential number of
states compared to Bi. Thus, for every i ≥ 0, we deﬁne the NFA

Bi = ({−i, . . . ,−1, 0, 1, . . . , i},{a0, a1, . . . , ai},·, Ii,−Ii)

with Ii = {0, 1, . . . , i} and the transition function · deﬁned so that j · a‘ = j if i ≥ |j| > ‘ ≥ 0,
‘ · a‘ = {0, 1, . . . , ‘ − 1}, and −j · a‘ = −‘ if 0 ≤ j < ‘ ≤ i. Automaton B2 is depicted in
Figure 4.
Notice that L(Bi−1) ⊆ L(Bi) and that Bi has 2i + 1 states. The reader can see that
L(Bi) = L(Bi)R. Moreover, making the NFA Bi complete (the dotted lines in Figure 4),
results in a ptNFA. Therefore, the language L(Bi) is piecewise testable by Theorem 7.
We now deﬁne a word wi inductively by w0 = a0 and w‘ = w‘−1a‘w‘−1, for 0 < ‘ ≤ i.
Then |wi| = 2i+1 − 1 and we show that every preﬁx of wi of even length belongs to L(Bi)
and every preﬁx of odd length does not.

T. Masopust

15

Indeed, ε belongs to L(B0) ⊆ L(Bi). Let v be a preﬁx of wi of even length. If |v| < 2i − 1,
then v is a preﬁx of wi−1 and v ∈ L(Bi−1) ⊆ L(Bi) by the induction hypothesis. If |v| > 2i−1,
then v = wi−1aiv0, where v0 is a preﬁx of wi−1 of even length. The deﬁnition of Bi and the
wi−1−−−→ i ai−→ (i − 1) v0−→ 0. Thus, v
induction hypothesis then imply that there is a path i
belongs to L(Bi).
We now show that any preﬁx w of wi of odd length does not belong to L(Bi). Since
w begins and ends with a0 and there is neither an a0-transition to nor from state 0, it
cannot be accepted either by or from state 0. Therefore, if w is accepted by Bi, there
must be an accepting computation starting from an initial state q0 ∈ {1, . . . , i} and ending
in an accepting state qf ∈ {−1, . . . ,−i}. It means that w can be written as w = ua‘ajv,
ua‘−−→ 0 aj v−−→ qf. By the construction, both ‘ and j are diﬀerent from 0, which is a
where q0
contradiction with the structure of wi, since a0 is on every odd position.
These properties imply that the preﬁxes of wi alternate between accepting and non-
accepting states of the minimal DFA for L(Bi). Since the language L(Bi) is piecewise testable,
the minimal DFA does not have any non-trivial cycles. Thus, the word wi forms a simple
path in the minimal DFA recognizing the language L(Bi), which shows that the depth of the
minimal DFA is of length at least 2i+1 − 1.
(cid:74)
(cid:73) Lemma 16. For every i ≥ 0, the language L(Bi) is not 2i-piecewise testable.
Proof. Let wi = wi−1aiwi−1 be the word as deﬁned in the proof of Theorem 8, and let w0
i)R ∼2i
denote its preﬁx without the last letter, that is, wi = w0
ia0. We show that w0
i)R does not belong to L(Bi) and
i(w0
i)R. Combining this with the observation that w0
w0
ia0(w0
i)R belongs to L(Bi) then implies that L(Bi) is not 2i-piecewise testable.
w0
i(w0
i(w0
Indeed, w0
i)R),
then w ∈ sub2i(w0
i)R without mapping a0 of w to
the a0 between w0
i)R, then the claim holds. Thus, assume that w = ua0v is such that
the a0 must be mapped to the a0 between w0
i)R. Thus, u must be embedded into
w0
i. We show by induction on i that the length of u must be at least i. It obviously holds for
i = 0. Assume that the claim holds for i − 1 and consider w0
i−1a0. Since the
ia0 and alph(wi−1ai) = {a0, a1, . . . , ai}, there
a0 of w must be mapped to the last letter of w0
must be a nonempty preﬁx u1 of u, i.e., u = u1u0, such that u1 is embedded into wi−1ai and
ia0. We now have that u0a0 is
it forces the ﬁrst letter of u0 to be embedded to w0
embedded into w0
i−1a0. By the
induction hypothesis, the length of u0 is at least i − 1. Since u1 is nonempty, we obtain that
the length of u = u1u0 is at least i.
ia0 is a palindrome, the same argument applies to v. Together, we
have that |w| = |u| + 1 + |v| ≥ 2i + 1, which is a contradiction with the assumption that
|w| ≤ 2i.
(cid:74)

i)R). If w can be embedded into w0
i and (w0

i−1a0 such that a0 must be mapped to the last letter of w0

i)R (cid:52) w0
i(w0
i and (w0

ia0(w0

i)R, therefore we need to show that if w ∈ sub2i(w0

ia0(w0

Since the word w0

ia0(w0

i

ia0(w0

i−1a0 in w0

ia0 = wi−1aiw0

Proofs of Section 6

10
(cid:73) Lemma 19 (1-piecewise testability ptNFAs). Let A = (Q, Σ,·, i, F) be a complete NFA. If
(i) for every p ∈ Q and a ∈ Σ, paa = pa and (ii) for every p ∈ Q and a, b ∈ Σ, pab = pba,
then the language L(A) is 1-piecewise testable.
Proof. Consider the minimal DFA D constructed from A by the standard subset construction
and minimization. We show that D satisﬁes the properties of Theorem 18, which then implies
the claim. Because every state of D is represented by a nonempty subset of states of A,

ArXiv

16

Piecewise Testable Languages and Nondeterministic Automata

let X ⊆ Q be a state of D. Then, we have that Xaa = S
and, similarly, that Xab =S

p∈X pab =S

p∈X paa = S

p∈X pa = Xa
p∈X pba = Xba. Theorem 18 then completes the
(cid:74)

proof.
(cid:73) Lemma 21 (2-piecewise testability ptNFAs). Let A = (Q, Σ,·, i, F) be a ptNFA. If for every
a ∈ Σ and every state s such that iw = s for some w ∈ Σ∗ with |w|a ≥ 1, sba = saba for
every b ∈ Σ ∪ {ε}, then the language L(A) is 2-piecewise testable.
Proof. Consider the minimal DFA D obtain from A by the standard subset construction and
minimization. Since any ptNFA recognizes a piecewise testable language, see Theorem 7, D is
conﬂuent and partially ordered. We now show that it satisﬁes the properties of Theorem 20.
Again, the states of D are represented by nonempty subsets of A. Let I ⊆ Q denote
the initial state of D. Let a ∈ Σ, and let w ∈ Σ∗ be such that |w|a ≥ 1. Denote Iw = S
s∈S saba =
(cid:74)

and consider any b ∈ Σ ∪ {ε}. Then, since sba = saba in A, Sba =S

Saba.
(cid:73) Lemma 22. The 0-piecewise testability problem for ptNFAs is coNP-hard.
Proof. We reduce the complement of CNF satisﬁability. Let U = {x1, x2, . . . , xn} be a
set of variables and ϕ = ϕ1 ∧ ϕ2 ∧ . . . ∧ ϕm be a formula in CNF, where every ϕi is a
disjunction of literals. Without loss of generality, we may assume that no clause ϕi contains
both x and ¬x. Let ¬ϕ be the negation of ϕ obtained by the de Morgan’s laws. Then
¬ϕ = ¬ϕ1 ∨ ¬ϕ2 ∨ . . . ∨ ¬ϕm is in DNF. For every i = 1, . . . , m, deﬁne βi = βi,1βi,2 . . . βi,n,
where

s∈S sba =S

 0 + 1

0
1

βi,j =

for j = 1, 2, . . . , n. Let β =Sm

if xj and ¬xj do not appear in ¬ϕi
if ¬xj appears in ¬ϕi
if xj appears in ¬ϕi

i=1 βi. Then w ∈ L(β) if and only if w satisﬁes some ¬ϕi. That
is, L(β) = {0, 1}n if and only if ¬ϕ is a tautology, which is if and only if ϕ is not satisﬁable.
Note that by the assumption, the length of every βi is exactly n.
We construct a ptNFA M as follows (the transitions are the minimal sets satisfying the
deﬁnitions). The initial state of M is state 0. For every βi, we construct a deterministic path
consisting of n + 1 states {qi,0, qi,1, . . . , qi,n} with transitions qi,‘+1 ∈ qi,‘ · βi,‘ and qi,0 = 0.
In addition, we add n+1 states {α1, α2, . . . , αn+1} and transitions α‘+1 ∈ α‘ · a, for ‘ < n+1
and α0 = 0, and αn+1 ∈ αn+1 · a, where a ∈ {0, 1}. This path is used to accept all words of
length diﬀerent from n. Finally, we add n states {r1, . . . , rn} and transitions ri+1 ∈ ri · a, for
i < n, and αn+1 ∈ rn · a, where a ∈ {0, 1}. These states are used to complete M by adding a
transition from every state q to r1 under a if a is not deﬁned in q. They ensure that any word
of length n that does not belong to L(β) is not accepted by M. The accepting states of M
are the states {0, q1,n, . . . , qm,n} ∪ {α1, . . . αn+1} \ {αn}. Notice that M is partially ordered,
complete and satisﬁes the UMS property. Indeed, the UMS property is satisﬁed since the
only state with self-loops is the unique maximal state αn+1. The automaton accepts the
language L(M) = L(β) ∪ {w ∈ {0, 1}∗ | |w| 6= n}.

By Theorem 7, the language is piecewise testable. It is 0-piecewise testable if and only if
(cid:74)

L(M) = {0, 1}∗, which is if and only if L(β) = {0, 1}n.
(cid:73) Lemma 23. For k ≥ 0, k-piecewise testability is polynomially reducible to (k +1)-piecewise
testability.

T. Masopust

17

Figure 5 The ptNFA Mk+1 constructed from the ptNFA Mk with two initial states Ik = {i1, i2}

k+1 → Σ∗

Assume that Lk is k-piecewise testable. Let x, y ∈ Σ∗

Proof. Let Lk over Σk be a piecewise testable language recognized by a ptNFA Mk with
the set of initial states Ik = {i1, . . . , i‘}. We construct the language Lk+1 over the alphabet
Σk+1 = Σk ∪ {ak+1}, where ak+1 /∈ Σk, as depicted in Figure 5. Namely, Mk+1 recognizing
the language Lk+1 is constructed from Mk by adding self-loops under ak+1 to every state of
Mk and adding, for every initial state i of Mk, a new state i0 that contains self-loops under
all letters from Σk and goes to the initial states i of Mk under ak+1. The initial states of
Mk+1 are the new states i0, the accepting states are the accepting states of Mk. Notice that
the automaton Mk+1 is a ptNFA. We now prove that Lk is k-piecewise testable if and only
if Lk+1 is (k + 1)-piecewise testable.
k+1 be two words such that x ∼k+1 y.
Since k + 1 ≥ 1, we have that alph(x) = alph(y). If ak+1 /∈ alph(x), then neither x nor
y belongs to Lk+1. Thus, assume that ak+1 appears in x and y. Then x = x0ak+1x00 and
y = y0ak+1y00, where ak+1 /∈ alph(x0y0). By Lemma 10, x00 ∼k y00. By construction, the words
x00 and y00 are read in Mk extended with the self-loops under ak+1. Let p : Σ∗
k denote
a morphism such that p(ak+1) = ε and p(a) = a for every a ∈ Σk. Since no ak+1-transition
changes the state in any computation of Mk, the sets of states reachable by x and y in Mk+1
are exactly those reachable by p(x00) and p(y00) in Mk. Since Lk is k-piecewise testable,
either both contain an accepting state or neither does. Hence x is accepted if and only if y is
accepted, which shows that Lk+1 is (k + 1)-piecewise testable.
On the other hand, assume that Lk is not k-piecewise testable. Then there exist words x
and y such that x ∼k y and |Lk ∩ {x, y}| = 1. Let w ∈ Σ∗
k be such that subk+1(w) = {u ∈
k | |u| ≤ k + 1}. Then, wak+1x ∼k+1 wak+1y and |Lk+1 ∩ {wak+1x, wak+1y}| = 1. This
Σ∗
(cid:74)
shows that Lk+1 is not (k + 1)-piecewise testable.
(cid:73) Remark (Parallel composition). A morphism p : Σ∗ → Σ∗
o, for Σo ⊆ Σ, deﬁned as p(a) = a,
for a ∈ Σo, and p(a) = ε, otherwise, is called a (natural) projection. Arguments similar to
those used in the proof of Lemma 23 show that piecewise testable languages are closed under
inverse projection. A parallel composition of languages (Li)n
i=1 is
deﬁned as kn
i is a natural projection. As
a consequence, piecewise testable languages are closed under parallel composition. On the
other hand, note that piecewise testable languages are not closed under natural projection.
(cid:73) Theorem 26. Let Σ be a ﬁxed alphabet with c = |Σ| ≥ 2, and let k ≥ 0. Then the problem
to decide whether the language of a ptNFA A over Σ is k-piecewise testable is coNP-complete.
Proof. Let d denote the depth of A. Then the language L(A) is d-piecewise testable. If
k ≥ d, then the answer is Yes. Thus, assume that k < d. Notice that if u ∼d v, then u ∼k v,

i=1 p−1(Li), where p : (Sn

i=1 Li =Tn

i=1 over the alphabets (Σi)n

i=1 Σi)∗ → Σ∗

ArXiv

MkIki1i2i01i02ak+1Σkak+1Σkak+118

Piecewise Testable Languages and Nondeterministic Automata

Figure 6 The ptNFA Mk constructed from a ptNFA M0 with two initial states

but the opposite does not hold. If L(A) is not k-piecewise testable, then there exist two
words x ∈ L(A) and y /∈ L(A) such that x ∼k y. This means that x 6∼d y, hence we can
guess the minimal representatives of the x/∼d and y/∼d classes that are of length O(dc),
see the discussion above, which is polynomial in the depth of A, and check that x ∈ L(A)
and y /∈ L(A), and that x ∼k y. The last step requires to test all words up to length k for
embedding in both words. However, it is at most kck words, which is a constant.

To prove hardness, we reduce 0-piecewise testability to k-piecewise testability, k ≥ 1.
First, notice that the proof of Lemma 23 cannot be used, since the alphabet there grows
proportionally to k. However, the proof here is a simple modiﬁcation of that proof. Let
M0 over Σ0 be a ptNFA. Construct the ptNFA Mk over the alphabet Σ = Σ0 ∪ {a}, where
a /∈ Σ0, as depicted in Figure 6. Namely, Mk is constructed from M0 by adding self-loops
under a to every state of M0, and by adding k new states ij,1, . . . , ij,k for every initial state
ij of Mk. Every ij,‘ contains self-loops under all letters from Σ0 and ij,‘ goes to ij,‘+1 under
a, for 1 ≤ ‘ < k − 1, and ij,k goes to the initial states ij of M0 under a. The initial states
of Mk are the states ij,1, the accepting states are the accepting states of M0. Note that
Mk is a ptNFA. We now prove that L(Mk) is k-piecewise testable if and only if L(M0) is
0-piecewise testable.

Assume that L(M0) is 0-piecewise testable. Let x, y ∈ Σ∗ be two words such that x ∼k y.
If ak 6(cid:52) x, then x /∈ L(Mk), and x ∼k y implies that ak 6(cid:52) y, hence y /∈ L(Mk) either.
Thus, assume that ak (cid:52) x and ak (cid:52) y. Then x = x1ax2a . . . xkax00 and y = y1ay2a . . . ykay00,
where a /∈ alph(x1 ··· xky1 ··· yk). By Lemma 10 applied k-times, x00 ∼0 y00. Notice that, by
construction, the words x00 and y00 are read in M0 extended with the self-loops under a and
the sets of states reachable by x and y in Mk are exactly those reachable by x00 and y00 in
M0. Let p : Σ∗ → Σ∗
0 denote a morphism such that p(a) = ε and p(b) = b for b ∈ Σ0. Since
no a-transition changes the state in any computation of M0, the sets of states reachable by
x00 and y00 in M0 are exactly those reachable by p(x00) and p(y00), respectively. Since L(M0)
is 0-piecewise testable, either both contain an accepting state or neither does. Together, x is
accepted by Mk if and only if y is accepted by Mk, which shows that L(Mk) is k-piecewise
testable.

On the other hand, assume that L(M0) is not 0-piecewise testable. Then there are two
words x ∈ L(M0) and y /∈ L(M0). Let w ∈ Σ∗
0 | |u| ≤ k}.
Then, we have that (wa)kx ∼k (wa)ky and |L(Mk) ∩ {(wa)kx, (wa)ky}| = 1. This shows
that L(Mk) is not k-piecewise testable.
(cid:74)

0 be such that subk(w) = {u ∈ Σ∗

M0I0i1i2i1,k···i1,2i1,1i2,k···i2,2i2,1aΣ0aΣ0aaaaΣ0Σ0aaaΣ0Σ0T. Masopust

19

(cid:73) Corollary 27. The k-piecewise testability problem for ptNFAs over an alphabet Σ is coNP-
hard for k ≥ 0 even if |Σ| = 3.
Proof. It is shown in Lemma 22 that 0-piecewise testability for ptNFAs is coNP-hard for a
binary alphabet. The hardness proof of the previous theorem then shows that, for any k ≥ 1,
(cid:74)
k-piecewise testability is coNP-hard for a ternary alphabet.
(cid:73) Theorem 28. The k-piecewise testability problem for ptNFAs over a unary alphabet is
decidable in polynomial time. The result holds even if k is part of the input.
Proof. Let A be a ptNFA of depth d. Then the language L(A) is d-piecewise testable by
Theorem 8 and the minimal representatives of ∼d-classes are of length at most d; there are
at most d + 1 equivalence classes. If k ≥ d, then the language L(A) is k-piecewise testable,
since every d-piecewise testable language is also (d + 1)-piecewise testable. If k < d, then
the language L(A) is not k-piecewise testable if and only if there are two words of length at
most d that are ∼k-equivalent and only one of them is accepted. Since all words of length
less than k are ∼k-equivalent only with itself and all unary words of length at least k are
∼k-equivalent, it can be checked in polynomial time whether there is a word of length at
(cid:74)
least k + 1 and at most d with a diﬀerent acceptance status than ak.
(cid:73) Theorem 29. Both piecewise testability and k-piecewise testability problems for NFAs over
a unary alphabet are coNP-complete.
Proof. We ﬁrst show that to check piecewise testability for NFAs over a unary alphabet is in
coNP. To do this, we show how to check non-piecewise testability in NP. By Fact 2, we need
to check that the corresponding DFA is partially ordered and conﬂuent. However, conﬂuence
is trivially satisﬁed because there is no branching in a DFA over a single letter. Partial order
is violated if and only if there exist three words a‘1, a‘2 and a‘3 with ‘1 < ‘2 < ‘3 such that
I · a‘1 = I · a‘3 6= I · a‘2 and one of these sets is accepting and the other is not (otherwise
they are equivalent). The lengths are bounded by 2n, where n denotes the number of states
of the NFA, and can be guessed in binary. The fast matrix multiplication can then be used
to compute resulting sets of those transitions in polynomial time.

Thus, we can check in coNP whether the language of an NFA is piecewise testable. If
so, then it is 2n-piecewise testable, since the depth of the minimal DFA is bounded by 2n,
where n is the number of states of the NFA. Let M be the transition matrix of the NFA. To
show that it is not k-piecewise testable, we need to ﬁnd two ∼k-equivalent words such that
exactly one of them belongs to the language of the NFA. Since every class deﬁned by a‘, for
‘ < k, is a singleton, we need to ﬁnd k < ‘ ≤ 2n such that ak ∼k a‘ and only one of them
belongs to the language. This can be done in nondeterministic polynomial time by guessing
‘ in binary and using the matrix multiplication to obtain the reachable sets in M k and M ‘
and verifying that one is accepting and the other is not.

We now show that both problems are coNP-hard. To do this, we use the proof given

in [31] showing that universality is coNP-hard. We recall it here for convenience.
Let ϕ be a formula in 3CNF with n distinct variables, and let Ck be the set of literals
in the kth conjunct, 1 ≤ k ≤ m. The assignment to the variables can be represented as a
binary vector of length n. Let p1, p2, . . . , pn be the ﬁrst n prime numbers. For a natural
number z congruent with 0 or 1 modulo pi, for every 1 ≤ i ≤ n, we say that z satisﬁes ϕ if
the assignment (z mod p1, z mod p2, . . . , z mod pn) satisﬁes ϕ. Let

n[

pk−1[

E0 =

0j · (0pk)∗

k=1

j=2

ArXiv

20

Piecewise Testable Languages and Nondeterministic Automata

that is, L(E0) = {0z | ∃k ≤ n, z 6≡ 0 mod pk and z 6≡ 1 mod pk} is the set of natural numbers
that do not encode an assignment to the variables. For each conjunct Ck, we construct
an expression Ek such that if 0z ∈ L(Ek) and z is an assignment, then z does not assign
the value 1 to any literal in Ck. For example, if Ck = {x1,r,¬x1,s, x1,t}, for 1 ≤ r, s, t ≤ n
and r, s, t distinct, let zk be the unique integer such that 0 ≤ zk < prpspt, zk ≡ 0 mod pr,
zk ≡ 1 mod ps, and zk ≡ 0 mod pt. Then

Now, ϕ is satisﬁable if and only if there exists z such that z encodes an assignment to ϕ and

k=1 Ek) 6= 0∗.

Ek = 0zk · (0prpspt)∗ .

0z /∈ L(Ek) for all 1 ≤ k ≤ m, which is if and only if L(E0 ∪Sm
1 ≤ i ≤ n. This shows that if 0z /∈ L(Ek) for all k, then 0z(0pn#)∗ ∩ L(E0 ∪Sm
Since both languages are inﬁnite, the minimal DFA recognizing the language L(E0∪Sm

The proof shows that universality is coNP-hard for NFAs over a unary alphabet. Let
i=1pi. If z encodes an assignment of ϕ, then, for any natural number c, z+c·pn# also
pn# = Πn
encodes an assignment of ϕ. Indeed, if z ≡ xi mod pi, then z + c· pn# ≡ xi mod pi, for every
k=1 Ek) = ∅.
k=1 Ek)
must have a non-trivial cycle. Therefore, if the language is universal, then it is k-piecewise
testable, for any k ≥ 0, and if it is non-universal, then it is not piecewise testable. This
proves coNP-hardness of k-piecewise testability for every k ≥ 0.
(cid:74)

