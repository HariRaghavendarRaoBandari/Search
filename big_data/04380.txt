6
1
0
2

 
r
a

 

M
3
2

 
 
]
S
D
.
s
c
[
 
 

3
v
0
8
3
4
0

.

3
0
6
1
:
v
i
X
r
a

Linear Sum Assignment with Edition

S´ebastien Bougleux and Luc Brun

Normandie Universit´e
GREYC UMR 6072

CNRS - Universit´e de Caen Normandie - ENSICAEN

Caen, France

March 24, 2016

Abstract

We consider the problem of transforming a set of elements into another by a sequence of
elementary edit operations, namely substitutions, removals and insertions of elements. Each
possible edit operation is penalized by a non-negative cost and the cost of a transformation
is measured by summing the costs of its operations. A solution to this problem consists
in deﬁning a transformation having a minimal cost, among all possible transformations.
To compute such a solution, the classical approach consists in representing removal and
insertion operations by augmenting the two sets so that they get the same size. This
allows to express the problem as a linear sum assignment problem (LSAP), which thus
ﬁnds an optimal bijection (or permutation, perfect matching) between the two augmented
sets. While the LSAP is known to be eﬃciently solvable in polynomial time complexity,
for instance with the Hungarian algorithm, useless time and memory are spent to treat the
elements which have been added to the initial sets. In this report, we show that the problem
can be formalized as an extension of the LSAP which considers only one additional element
in each set to represent removal and insertion operations. A solution to the problem is
no longer represented as a bijection between the two augmented sets. We show that the
considered problem is a binary linear program (BLP) very close to the LSAP. While it can
be solved by any BLP solver, we propose an adaptation of the Hungarian algorithm which
improves the time and memory complexities previously obtained by the approach based on
the LSAP. The importance of the improvement increases as the size of the two sets and
their absolute diﬀerence increase. Based on the analysis of the problem presented in this
report, other classical algorithms can be adapted.

1

Introduction

Assigning the elements of some set to the elements of another, such that the resulting assignment
satisfy some optimality conditions, is a fundamental combinatorial problem encountered in a
wide variety of scientiﬁc ﬁelds [10, 4]. This report focusses on linear sum assignment problems,
also known as weighted bipartite graph matching problems. The simplest example assumes that
the two sets have the same cardinality.
Problem 1 (LSAP). Provided two ﬁnite sets U and V having the same cardinality n, assigning
the n elements of U to the n elements of V can be described by a bijective mapping U →V. The
task of assigning an element of U to an element of V is penalized by a real non-negative cost
function c :U ×V → [0, +∞). The Linear Sum Assignment Problem (LSAP) consists in ﬁnding
an optimal bijection

(cid:41)

(cid:88)

u∈U

c(u, ϕ(u))

,

(1)

(cid:40)

ˆϕ ∈ argmin
ϕ ∈ B(U ,V)

A(ϕ, c)

def.
=

where B(U,V) is the set of bijections from U to V.

1

(a)

(b)

(c)

Figure 1: (a) A squared assignment with edition (Problem 2), i.e. a bijection ϕ :U ∪EU →
V ∪EV . (b) The equivalent assignment with edition (Problem 3), i.e. a mapping ϕ :U →P(V)
edition ϕ deﬁned in (b). The sets U (cid:93) and V (cid:93) in (b) are surrounded by dashed boxes.

satisfying constraints given by Eq. 8. (c) The bijective restriction (cid:101)ϕ of the assignment with

Note that several optimal assignments may exist, which depends on the cost function. Recall
that any bijection is in one-to-one correspondence with a permutation of {1, . . . , n}, and that
any permutation ϕ can be represented by a matrix X∈{0, 1}n×n satisfying xi,j = 1 if ϕ(i) = j
and xi,j = 0 else. Such a n× n matrix, called permutation matrix, satisﬁes

X∈{0, 1}n×n, X1n = 1n, XT 1n = 1n.

Let Pn be the set of all n× n permutation matrices. Then the LSAP can be reformulated as

ˆX ∈ argmin
X∈Pn

xi,jci,j

n(cid:88)

n(cid:88)

A(X, C) def.=
 ,
(cid:110)
cT x | Lx = 1n2 , x∈{0, 1}n2(cid:111)

i=1

j=1

ˆx ∈ argmin

,

(2)

(3)

(4)

where C = (ci,j)i,j=1,...,n is the cost matrix representing the cost function, that is ci,j = c(ui, vj)
with ui ∈U and vj ∈V. From Eq. 3, the LSAP can be easily reformulated as a binary linear
program [18]

where x = vec(X) and c = vec(C) are the vectorization of the permutation matrix X and the
cost matrix C, respectively. The right-hand side of Eq. 4 is the matrix version of the constraints
deﬁned by Eq. 2. The matrix L∈{0, 1}2n×n2
corresponds to the node-edge incidence matrix of
the complete bipartite graph Kn,n with node sets U and V, i.e. (L)k,(i,j) = 1 if (k = i)∨ (k = j)
and 0 else. A solution to the LSAP corresponds to a perfect bipartite matching, i.e. a subgraph
of Kn,n such that each element of U ∪V has degree one.

The LSAP is eﬃciently solvable. While there is n! possible assignments, it can be solved in
polynomial time complexity (worst-case), for instance in O(n3) with the well-known Hungarian
algorithm [8, 9, 11] or its improvements, see [10, 4] for more details.
When the two sets U and V have diﬀerent cardinalities, |U| = n and |V| = m with n≤ m, an
assignment becomes an injection ϕ :U →V, or equivalently an arrangement of n elements among
m = m!/(m− n)! such assignments. Under this context, a solution to the LSAP
m. There is n! C n
is an injection minimizing the objective functional deﬁned in Eq. 1. The Hungarian algorithm
has been modiﬁed to solve this LSAP in O(n2m) time complexity [1].
In this paper, we study an extension of this problem which allows to model the transformation
of the ﬁrst set U into the second one V by means of edit operations. Three simple operations
are considered. In addition to the traditional mapping of elements, i.e. each element of U can
be substituted by an element of V, the elements of U can be removed and the elements of V

2

ε1ε2ε3ε4ε1ε2ε3ε4ϕ−1εUεV21345671234ε5εε67ϕϕ−1εUεV21345671234ϕεεϕ−121345671234ϕεεVU~~##can be inserted into U. This extension is motivated by the deﬁnition of error-tolerant distance
or similarity measures, which play an important role in pattern recognition. In particular, the
graph edit distance [19, 3, 16, 2] is one of the most ﬂexible graph dissimilarity measure, but
computing it exactly is a NP-complete problem. The main strategy developed in the last decade
consists in approximating the graph edit distance by solving a special weighted bipartite graph
matching of the nodes such that insertion and removal operations are represented [7, 15, 12,
20, 14, 5, 6, 13, 17]. An edit path containing node and edge operations is then deduced from
an initial node mapping provided by the LSAP. The approximate edit distance is then deﬁned
as the cost of this edit path. Initially designed as an upper bound of the graph edit distance
by deﬁning the cost of mapping two nodes as the cost of mapping their labels [7], it has been
improved by also penalizing the mapping of their direct neighborhoods (incident edges and
adjacent nodes) within this cost [15, 12]. More global and representative patterns than direct
node neighborhoods, such as bags of walks [6], have also been explored.

The main diﬃculty within this bipartite framework consists in deﬁning properly the removal
and insertion operations. Moreover, the cost of mapping two direct neighborhoods or two bags
is usually deﬁned as the cost of an optimal weighted bipartite graph matching of the edges or
patterns within the bags, which also consider removal and insertion operations. Such weighted
bipartite graph matchings may be formulated as the following error-tolerant assignment problem
between two sets [15, 12].
Problem 2 (sLSAPE). Let U and V be two ﬁnite sets (|U| = n and |V| = m). Any element
of U can be substituted to any element of V. The removal of the elements of U is represented
by augmenting V by n distinct null elements EV ={i}i=1,...,n such that each element i ∈EV
corresponds to a unique element ui ∈U and reciprocally. The insertion of the elements of V in U
is represented similarly by augmenting U by m elements EU ={j}j=1,...,m. The two augmented
sets have the same cardinality n + m (Fig. 1(a)). Each possible edit operation (substitution,
removal and insertion) is penalized by a cost function c : (U ∪EU ) × (V ∪EV )→ [0, ω] such that:

• the cost c(ui, vj) penalizes the substitution of any ui ∈U by any vj ∈V,
• the cost c(ui, i) penalizes the removal of any ui,
• the cost c(j, vj) penalizes the insertion of any vj into U.

Assigning any ui to any k (k (cid:54)= i) or any l to any vj (l (cid:54)= j) is forbidden, so the associated costs
are set to a large value ω > max{c(ui, vj), ∀i∈U, j ∈V}, i.e. c(ui, k) = c(l, vj) = ω. Finally,
we have c(j, i) = 0 for all ui ∈U and all vj ∈V, since assigning two null elements should not
inﬂuence the overall assignment.
bijection ϕ :U ∪EU →V ∪EV that minimizes the objective functional:

The squared linear sum assignment problem with edition (sLSAPE) consists in ﬁnding a

A(ϕ, c) =

c(u, ϕ(u)) =

c(ui, ϕ(ui)) +

c(j, ϕ(j))

(cid:88)
(cid:88)

ui∈U

(cid:88)
(cid:88)

j∈EU

(cid:88)
(cid:88)

u∈U∪EU

ui∈U

vj =ϕ(ui)

(cid:123)(cid:122)

(cid:124)

=

c(ui, vj)

+

c(ui, i)

+

c(j, vj)

(5)

(cid:125)

ui∈U

i=ϕ(ui)

(cid:123)(cid:122)

(cid:124)

(cid:125)

(cid:124)

j∈EU
vj =ϕ(j )

(cid:123)(cid:122)

(cid:125)

substitutions

removals

insertions

The set of bijective mappings between U ∪EU and V ∪EV is denoted SE (U,V).
Since the sLSAPE is a LSAP (Problem 1) with a speciﬁc cost function, it can be solved by
any algorithm solving the LSAP, for instance in O((n + m)3) time complexity by the Hungarian
algorithm [12]. This algorithm is based on the formulation of the LSAP given by Eq. 3. For
the sLSAPE, it consists in ﬁnding an optimal (n + m)× (n + m) permutation matrix, provided

3



a (n + m)× (n + m) edit cost matrix of the following form
···
. . .
. . .
ω

(c(ui, vj))i,j

. . .
···

c(1, 1)

ω

c(2, 2)

ω
...
ω

c(1, 1)

ω

ω
...
ω

c(2, 2)

. . .
···

···
. . .
. . .
ω

ω
...

ω

c(m, m)

(c(j, i))i,j = 0m,n

ω
...

ω

c(n, n)



∈ [0, ω](n+m)×(m+n). (6)

As we can observe, many coeﬃcients of such a cost matrix are not relevant (equal to ω or to
0) in the blocks representing the cost of removal/insertion operations. These values have been
added in order to model the problem of transforming one set into another, by means of edit
operations, as a LSAP. To improve the time and memory complexity, the computation of an
optimal transformation should not depend on these useless values. To this, a variant of the
sLSAPE has been proposed in [17], but it restricts insertion (or removal) operations to occur in
only one set.

In this report, rather than modelling the initial transformation problem such that it can be
solved with known algorithms, we formalize it as an extension of the LSAP which considers only
one additional element in each set to represent removal and insertion operations (Fig. 1(b)). A
solution to the problem is not any more represented as a bijection between the two augmented
sets (Section 2). We call this extension the linear sum assignment problem with edit operations
(LSAPE). Intuitively, it consists in reducing the square edit cost matrix (Eq. 6) by removing its
useless elements, in order to obtain a (n + 1)× (m + 1) edit cost matrix



(c(ui, vj))i,j

c(, 1)

c(, 2)

···

c(1, )
c(2, )

...

c(n, )

c(, m)

0

 ∈ [0, +∞)(n+1)×(m+1).

(7)

We show that the LSAPE is a speciﬁc binary linear program where the set of constraints deﬁnes a
mixed bipartite graph (Section 3). According to this analysis, we propose a modiﬁed Hungarian
algorithm which solves the problem in O(min{n, m}2 max{n, m}) time complexity and in O(nm)
memory complexity (Section 4). This is faster than the similar Hungarian algorithm used to
solve the sLSAPE, as observed experimentally with comparable implementations.

2 Assignments with Edition

In this section we deﬁne the notion of assignment with edition (or -assignment), and we analyze
some associated algebraic and numerical properties.

2.1 Deﬁnition and combinatorial properties
Consider two ﬁnite sets U and V. Let n =|U| and m =|V| be their respective cardinalities.
Transforming U into V, by means of edit operations, can be realized:

• by substituting each element of U by a unique element of V, or by removing it from U,

and then

• by inserting into U each element of V which has not been used for a substitution.

Let  be an element introduced to represent removal and insertion operations. The removal of
an element u∈U is denoted by u→ , and the insertion of an element v ∈V into U is denoted
by → v. Consider the two augmented sets U =U ∪{} and V =V ∪{}. We propose to deﬁne
a transformation from U into V as follows (Fig.1(b)).

4

Deﬁnition 1 (-assignment). An assignment with edition (or -assignment) from U to V is a
mapping ϕ :U →P(V) satisfying the following constraints:



∀u∈U,
∀v ∈V,
 ∈ ϕ()

|ϕ(u)| = 1

(cid:12)(cid:12)ϕ−1[v](cid:12)(cid:12) = 1

where P(·) is the powerset, and ϕ−1[v]⊂U denotes the preimage of any singleton {v}∈P(V)
by ϕ. Note that braces are omitted for singletons (ϕ−1[{v}] is written ϕ−1[v]). Let A(U,V) be
the set of all -assignments from U to V.
Note that the edit operation →  is always selected, but we could equivalently consider this
operation as being never selected. Compared to the deﬁnition of bijections involved in the
sLSPAE (Problem 2), an -assignment does not constrain the -elements directly. Indeed, by
deﬁnition of ϕ above, we have

1 ≤ |ϕ()| ≤ m + 1

and 1 ≤ |ϕ−1[]|≤ n + 1.

For example the -assignment in Fig. 1(b) is given by

1→{4}, 2→{6}, 3→{5}, 4→{}, →{1, 2, 3, 7, }.

Deﬁnition 1 also implies the existence of the sets:

(8)

(9)

(10)

(11)

U (cid:93) = {u∈U | ϕ(u)⊂V} = ϕ−1[V] ∩ U

V (cid:93) =(cid:8)v ∈V | ϕ−1[v]⊂U(cid:9) = ϕ[U] ∩ V
(cid:19)
(cid:18) U (cid:93) → V (cid:93)

(cid:55)→ v with {v} = ϕ(u)

(cid:101)ϕ :

where ϕ−1[V] denotes the preimage of the set composed of all singletons of P(V) by ϕ. Similarly
ϕ[U] denotes the image of U by ϕ. Then the function (Fig. 1(c))

u
Indeed, given u∈U (cid:93), by Eq. 8 we have |ϕ(u)| = 1. Since u∈U (cid:93), there is v ∈V
is bijective.
such that ϕ(u) ={v}. Moreover, by Eq. 8 we still have |ϕ−1[v]| = 1, and since ϕ(u) ={v}, then
ϕ−1[v] ={u}⊂U. Hence v ∈V (cid:93). Moreover, by Eq. 8, for any v ∈V (cid:93) there is a single u∈U such
that {v} = ϕ(u). We have u∈U and ϕ(u) ={v}⊂V, thus u∈U (cid:93). Hence, for any v ∈V (cid:93) there is

of elements of U which are not mapped onto . An -assignment may thus be understood as a
bijection on which the bijectivity constraint is relaxed for .
Let I(U,V) be the set of all injections from a subset of U onto V. Let ϕ∈A(U,V) be an

a single u∈U (cid:93) such that (cid:101)ϕ(u) = v.
The function (cid:101)ϕ is thus bijective. It may be understood as the restriction of ϕ to the set
-assignment. Note that the bijective restriction (cid:101)ϕ of ϕ is by deﬁnition injective from U (cid:93) onto V,
and hence belongs to I(U,V). Consider a mapping (cid:101)ϕ :Us ⊆U →V of I(U,V). Then the mapping

belongs to A(U,V) by construction. More generally ϕ and (cid:101)ϕ are linked as follows.

ϕ :U →P(V) deﬁned by:

(12)

∀u∈U \Us, ϕ(u) = {}

∀u∈Us, ϕ(u) = {(cid:101)ϕ(u)}
ϕ() = V \(cid:101)ϕ[Us]
(cid:19)
(cid:18) A(U,V) → I(U,V)
(cid:101)ϕ

(cid:55)→

ψ :

ϕ

Proof. Consider a mapping (cid:101)ϕ :Us ⊆U →V of I(U,V). The associated mapping ϕ∈A(U,V) can

be reconstructed according to Eq. 12, and one can easily show that ϕ belongs to A(U,V) by con-
struction. The mapping ψ is thus surjective. We show that it is bijective. Consider two elements
ϕ1, ϕ2 ∈ A(U,V) such that ϕ1 (cid:54)= ϕ2. There is necessarily u∈U such that ϕ1(u)(cid:54)= ϕ2(u):

(13)

Proposition 1. The following mapping is bijective:

5

• If u∈U, then:

– If ϕ1(u) ={v} and ϕ2(u) ={v(cid:48)} with (cid:54)∈{v, v(cid:48)} then u∈U (cid:93)
– Else, suppose w.l.o.g. that ϕ1(u) ={} and ϕ2(u)(cid:54)={}, then u(cid:54)∈U (cid:93)

have (cid:101)ϕ1(u) = v (cid:54)=(cid:101)ϕ2(u) = v(cid:48), which implies that (cid:101)ϕ1 (cid:54)=(cid:101)ϕ2.
implies that (cid:101)ϕ1 (cid:54)=(cid:101)ϕ2 (the (cid:101)ϕi are not deﬁned on the same subset of U).

1 ∩ U (cid:93)

2, but in this case we

1 and u∈U (cid:93)

2 which

• If u = , consider w.l.o.g.

that v ∈ ϕ1()\ ϕ2(). By Eq. 9, we have ∈ ϕ1()∩ ϕ2(),
consequently  (cid:54)= v ∈V. Since v (cid:54)∈ ϕ2() it exists u(cid:48) ∈U such that ϕ2(u(cid:48)) ={v}. Then we
have u(cid:48) ∈U (cid:93)
2.
– If u(cid:48) (cid:54)∈U (cid:93)
not equal.
– If u(cid:48) ∈U (cid:93)

1, (cid:101)ϕ1 and (cid:101)ϕ2 are not deﬁned on the same subset of U and are consequently
1, since v ∈ ϕ1() then ϕ1(u(cid:48))(cid:54)={v} = ϕ2(u(cid:48)) from Eq. 8, and so (cid:101)ϕ1 (cid:54)=(cid:101)ϕ2.

In all cases we get (cid:101)ϕ1 (cid:54)=(cid:101)ϕ2. The mapping ψ is thus injective and hence bijective.

A simple consequence is given by the following equality.
Corollary 1. |A(U,V)| =|I(U,V)|.
This allows to easily enumerate the number of -assignments.

Theorem 1. There is

|A(U,V)| =

C p

nC p

mp!

min{n,m}(cid:88)

p=0

m the number of partial permutations (injections).

possible -assignments between two sets U and V with n =|U|, m =|V|. C p
permutations (bijections), and p! C p
Proof. Consider the set I(U,V) and the notations of Eq. 12. We have C p
|Us| = p≤ min{n, m}. For each subset there exists p! C p
for each p = 0, . . . , min{n, m}, the number of injective mappings is p! C p
corresponds to the case where all elements of U and V are assigned to .
Remark that there exists much more -assignments than injections. Indeed, suppose that n ≤ m,
we have

n is the number of
n subsets Us of U with
m injective mappings from Us to V. So
m. Note that p = 0

nC p

n−1(cid:88)

|A(U,V)| = n! C n

m +

p! C p

mC p

n > n! C n
m

p=0

However, there is much less -assignments than bijections enumerated over n + m elements, as
considered by the sLSAPE.
Corollary 2. If w.l.o.g we suppose that n ≤ m we have:

Proof. We have by a classical result on binomial coeﬃcient:

n+m ≤ |A(U,V)| ≤ (n + m)!
C n
n(cid:88)

(n + m)!

m!

C p

nC p

m = C n

n+m =

n!m!

< (n + m)!

Hence from Theorem 1 we have:

p=0

|A(U,V)| ≤ n!

n(cid:88)
|A(U,V)| ≥ n(cid:88)

p=0

C p

nC p

m = C n

n+m

C p

nC p

m =

(n + m)!

m!

< (n + m)!

p=0

As for bijections, -assignments can be equivalently represented by matrices, which are useful
for analyzing the associated linear sum assignment problem and for deriving a solution.

6

2.2 Matrix form
Given two sets U ={ui}i=1,...,n and V ={vj}j=1,...,m, any -assignment ϕ∈A(U,V) is in one-
to-one correspondence with a matrix X∈{0, 1}(n+1)×(m+1) such that its n ﬁrst rows represent
U (row i corresponds to ui), its m ﬁrst columns represent V (column j corresponds to vj), its
row (n + 1) and its column (m + 1) represent the null element , and

∀i = 1, . . . , n, ∀j = 1, . . . , m (substitutions)
xi,j = δϕ(ui)={vj},
∀i = 1, . . . , n
xi,m+1 = δϕ(ui)={},
xn+1,j = δϕ−1[vj ]={}, ∀j = 1, . . . , m
xn+1,m+1 = 1

(insertions)

(removals)

where δr = 1 if the relation r is true, or δr = 0 else.

The matrix X has the general form:

∈ {0, 1}(n+1)×(m+1)

(14)

where Xsub ∈{0, 1}n×m represents substitutions, xrem ∈{0, 1}n×1 removals, and xins ∈{0, 1}1×m
insertions. For example, the matrix which represents the -assignment shown in Fig. 1(b) is given
by:





u1
...
un




v1
0
0
0
0
1

u1
u2
u3
u4


v1 ··· vm



Xsub

xrem

xins

1



v2
0
0
0
0
1

v3
0
0
0
0
1

v4
1
0
0
0
0

v5
0
0
1
0
0

v6
0
1
0
0
0

v7
0
0
0
0
1




0
0
0
1
1

Due to the constraints on ϕ (Deﬁnition 1), such a matrix has a 1 on each of its n ﬁrst rows, and
a 1 on each of its m ﬁrst columns:

∀i = 1, . . . , n

∀j = 1, . . . , m

(i.e. |ϕ(ui)| = 1)

(i.e. |ϕ−1[vj]| = 1)

(15)

Reciprocally, any matrix X∈{0, 1}(n+1)×(m+1) satisfying Eq. 15 represents an -assignment

j=1

xi,j = 1,

xi,j = 1,

m+1(cid:88)
n+1(cid:88)


ϕ such that:∀ui ∈U, ϕ(ui) =

i=1
xn+1,m+1 = 1

(cid:40){vj}

{}

if ∃j ∈{1, . . . , m} | xi,j = 1
else (i.e. xi,m+1 = 1)

ϕ() = {vj ∈V | xn+1,j = 1}

(16)

Let Sn,m, be the set of all matrices in {0, 1}(n+1)×(m+1) satisfying Eq. 15. It is the matrix form
of A(U,V). Compared to a permutation matrix, where each row and each column sum to 1,
the last row and the last column of a matrix satisfying Eq. 15 satisﬁes the following relaxed
constraints (Eq. 9):

1 ≤ n+1(cid:88)

and 1 ≤ m+1(cid:88)

xi,m+1 ≤ n + 1

xn+1,j ≤ m + 1.

i=1

j=1

7

Remark that any -assignment ϕ∈A(U,V) can be equivalently represented by a bipartite
graph G = ((U,V),E) such that each edit operation performed according to ϕ corresponds to
an edge of E. This graph is a subgraph of the complete bipartite graph Kn+1,m+1 generated
from the two sets U and V. Note that the matrix X associated with ϕ corresponds to the
node adjacency matrix of G. Reciprocally, any subgraph of Kn+1,m+1 represented by a node
adjacency matrix X satisfying Eq. 15 deﬁnes an -assignment.

2.3 Partial assignments with edition
A partial assignment from U onto V is an assignment wherein all elements are not assigned, i.e.
a bijection from a subset of U to a subset of V, or equivalently a partial permutation matrix.
This can be deﬁned similarly in the context of -assignments.
Deﬁnition 2 (partial -assignment). A partial -assignment from U to V is a mapping ϕ : U →
P(V) satisfying the following set of constraints:

(17)

which relaxes the one deﬁning -assignments (Eq. 8)
A partial -assignment from U to V is an -assignment from a subset U(cid:48) ⊆U onto a subset V(cid:48) ⊆V,
i.e. an -assignment in A(U(cid:48),V (cid:48)).
A partial -assignment can be equivalently represented by a matrix X∈{0, 1}(n+1)×(m+1),

having the structure of matrices of Sn,m, (Eq. 14), and satisfying the set of constraints





|ϕ(u)| ∈ {0, 1}

(cid:12)(cid:12)ϕ−1[v](cid:12)(cid:12) ∈ {0, 1}

∀u∈U,
∀v ∈V,
 ∈ ϕ()

xi,j ≤ 1, ∀i = 1, . . . , n

m+1(cid:88)
n+1(cid:88)

j=1

xi,j ≤ 1,

i=1
xn+1,m+1 = 1

∀j = 1, . . . , m

(18)

This relaxes the ones deﬁned by Eq. 15.

For example, the following matrix represents a partial -assignment with two unassigned

elements: u2 and v2.



v1
0
0
0
0
1

u1
u2
u3
u4


v2
0
0
0
0
0

v3
0
0
0
0
1

v4
1
0
0
0
0

v5
0
0
1
0
0

v6
0
0
0
0
0

v7
0
0
0
0
1




0
0
0
1
1

Note that the matrix X deﬁnes the node adjacency matrix of a bipartite graph having some
isolated nodes.

3 Minimal Linear Sum Assignment with Edition

that U ={1, . . . , n},
In order to simplify the forthcoming expressions, we assume w.l.o.g.
V ={1, . . . , m}, U =U ∪{n + 1} and V =V ∪{m + 1}, i.e. the element  corresponds to n + 1
in U and to m + 1 in V.

8

3.1 Edit cost and problem formulation
The deﬁnition of an -assignment from U to V does not rely on the nature of the sets, i.e. on the
nature of the underlying data. In order to select a relevant -assignment, among all assignments
from U to V, each possible edit operation i→ j is penalized by a non-negative cost ci,j. All
possible costs can be represented by an edit cost matrix C∈ [0, +∞)(n+1)×(m+1) having the
same structure as the one of matrices in Sn,m, (Eq. 14):



1··· m



Csub

crem

cins

0

 1

...
n


C =

(19)

(20)

i,j penalizes the substitution i→ j for all pair (i, j)∈U ×V, ci,m+1 penalizes the removal
where csub
i→  for all i∈U, cn+1,j penalizes the insertion → j for all j ∈V, and cn+1,m+1 = 0 associates
a zero cost to the mapping → . Note that the edit cost matrix associates a cost to each edge
of the complete bipartite graph Kn+1,m+1.

Let ϕ∈A(U,V) be an -assignment. Its cost is deﬁned as

A(ϕ, C) =

=

=

i∈U

ci,j

i∈U

j∈ϕ(i)

(cid:88)

(cid:88)
(cid:88)
(cid:123)(cid:122)
(cid:125)
ci,(cid:101)ϕ(i)
(cid:125)
(cid:123)(cid:122)

(cid:124)
(cid:88)
(cid:124)

ϕ(i)={j}

i∈U (cid:93)

substitutions

substitutions

ci,j

+

+

(cid:88)

i∈U

ϕ(i)={}

(cid:123)(cid:122)

removals

(cid:125)

(cid:124)

(cid:124)

(cid:88)

i∈U\U (cid:93)

(cid:123)(cid:122)

ci,m+1

+

cn+1,j

(cid:88)
(cid:123)(cid:122)

j∈V

ϕ−1[j]={}

insertions

(cid:124)
(cid:88)

(cid:125)

ci,m+1

+

cn+1,j

.

(cid:125)

j∈V\V (cid:93)

(cid:123)(cid:122)

(cid:124)

(cid:125)

removals

insertions

Problem 3 (LSAPE). Given to sets U and V, the linear sum assignment problem with edition
(LSAPE) consists in ﬁnding an -assignment having a minimal cost among all -assignments
transforming U into V, i.e. satisfying

argmin
ϕ∈A(U ,V)

A(ϕ, C).

(21)

This problem is equivalent to the sLSAPE, as demonstrated in the following section.

3.2 Link to the sLSAPE
Recall that the sLAPE ﬁnds a squared -assignment from U to V, i.e. a bijection from U ∪EU
to V ∪EV , with EU ={j, j ∈V} and EV ={i, i∈U}, and such that i∈U (resp. j ∈EU ) cannot
be assigned to k ∈EV (resp. l ∈V) with k (cid:54)= i (resp. l (cid:54)= j). This is penalized through the cost
values by setting a large value to such forbidden couplings. Also, the cost of assigning any
element of EU to any element of EV is null (equivalent to → , which has also a zero cost). We
assume that any squared -assignment has a non-inﬁnite cost A.
Lemma 1. Each -assignment ϕ∈A(U,V) is associated to a bijection ψ ∈SE (U,V) (Problem 2)

such that: ∀i∈U (cid:93),
(cid:18) E (cid:93)U = {j ∈ EU | j ∈ V (cid:93)} → E (cid:93)V = {i ∈ EV | i ∈ U (cid:93)}

ψ(i) = ϕ(i)
∀i∈U \U (cid:93), ψ(i) = i
∀j ∈V \V (cid:93), ψ(j) = j

and the restriction of ψ to

(cid:55)→ i

j

9

(cid:19)

(22)

(23)

Initial set Arrival set

Mapping

ψsub =(cid:101)ϕ U (cid:93)
U \ U (cid:93)
EU \ E (cid:93)U
E (cid:93)U

ψrem
ψins
ψcomp

V (cid:93)
EV \ E (cid:93)V
V \ V (cid:93)
E (cid:93)V

Table 1: Arrival and terminal sets involved in the construction of a squared -assignment from
an -assignment.

is bijective. Moreover, mappings ϕ and ψ have the same cost (Eq. 5 and Eq. 20).

the mapping ψ deﬁned by Eq. 22 and Eq. 23. We show that ψ ∈SE (U,V). The mapping
ψ :U ∪EU →V ∪EV is built as described in Table 1:

Proof. Let ϕ∈A(U,V) be an -assignment, and let (cid:101)ϕ be its associated injection. Consider
• Substitutions. When i∈U (cid:93), we have ψ(i) =(cid:101)ϕ(i). Since (cid:101)ϕ is a bijection from U (cid:93) onto
V (cid:93) = (cid:101)ϕ[U (cid:93)], the restriction ψsub :U (cid:93) → ψ[U (cid:93)] =V (cid:93) of ψ is also a bijection.

• Removals/insertions. When i∈U \U (cid:93) (reps. j ∈V \V (cid:93)), we have ψ(i) = i (resp. ψ(j) = j).
By deﬁnition, there is a natural bijective mapping from any i∈U (resp.
j ∈EU ) to
i ∈EV (reps. j ∈V). So the restriction ψrem :U \U (cid:93) →EV \E (cid:93)V of ψ, and the restriction
ψins :EU \E (cid:93)U →V \V (cid:93), are bijective.

• Completion. Meanwhile all edit operations have been deﬁned through the two last items,
the mapping ψ is not yet complete. Indeed, it is not yet deﬁned from E (cid:93)U to E (cid:93)V . Since
ψsub is a bijection, we have |U (cid:93)| =|V (cid:93)| and by consequence |E (cid:93)U| =|E (cid:93)U|. So the restriction
ψcomp :E (cid:93)U →E (cid:93)V of ψ can be any bijection from E (cid:93)U to E (cid:93)V .

All initial sets and arrival sets are disjoints and the mapping deﬁned between each couple of
sets is bijective. The mapping ψ is thus bijective. Moreover, considering that any mapping of
j ∈ E (cid:93)U onto ψcomp(j) ∈ E (cid:93)V is associated to a 0 cost, both mappings have the same cost.
Note that one -assignment corresponds to several bijections of SE (U,V) due to the bijective
mapping ψcomp. The proof also show that all these bijections have the same cost.
Lemma 2. Any bijection ψ ∈SE (U,V) is associated to an -assignment ϕ∈A(U,V) such that:

ϕ(i) = {}
ϕ() = ψ[E (cid:93)U ] ∪ {} with E (cid:93)U ={j ∈EU | ψ(j)∈V}

 ϕ(i) = {ψ(i)}
to V ∪ EV , its restriction (cid:101)ϕ to U (cid:93) = {u ∈ U | ψ(u) ∈ V} is injective from U (cid:93) to V. Such an
is provided by Eq. 20 (with V (cid:93) = (cid:101)ϕ[U (cid:93)]). By construction (Eq. 24), ϕ has the same cost as ψ

Mappings ψ and ϕ have the same cost.
Proof. Let ψ ∈SE (U,V) be a squared -assignment. Since it deﬁnes a bijection from U ∪ EU
injective mapping corresponds to a unique -assignment from U to V (Proposition 1) whose cost

if ψ(i)∈V
if ψ(i)∈EV

(24)

(Eq. 5).

A simple consequence of Lemma 1 and Lemma 2 is given by the following property.

Proposition 2. The LSAPE and the sLSAPE are equivalent, their respective solutions provide
the same minimal cost A.

Note that even if the minimal cost is the same for the LSAPE and the sLSAPE, the proof of
this proposition shows that solving a sLSAPE requires to deﬁne additionally a bijective mapping
between two sets of -values. This mapping being useless in terms of edit costs, computing an
optimal -assignment should be more eﬃcient than its squared version.

10



1
2

n
1

m

(1,1)
1

. . .
···

(1,m)

(1,)

(2,1)

1

1

1

1

1

. . .

(2,m)

(2,)

1

1

. . .

···

. . .

···

···

···

1

0

1

0

(n,1)

. . .

(n,m)

(n,)

(,1)

. . .

(,m)

1
1

···

. . .

1

1

1

0

1

. . .

1



Figure 2: Constraint matrix L. Its n ﬁrst rows represent U and its m last rows represent V.
Missing values are equal to 0.

n+1(cid:88)

m+1(cid:88)

3.3 Matrix form and linear programming
Let C∈ [0, +∞)(n+1)×(m+1) be an edit cost matrix. From Eq. 20, the cost associated to an
-assignment given by a matrix X∈Sn,m, (Eq. 15 and Eq. 14), is measured by

A(X, C) =

ci,jxi,j.

(25)

i=1

j=1

The LSAPE (Problem 3) can then be rewritten as ﬁnding a matrix of Sn,m, having a minimal
cost, i.e. satisfying

argmin
X∈Sn,m,

A(X, C)

(26)

The LSAPE can be rewritten as a linear programming problem, as described in the following.
Let x = vec(X)∈{0, 1}(n+1)(m+1)−1 be the vectorization of X obtained by concatenating its
rows and by removing its last element (since xn+1,m+1cn+1,m+1 = 0). Then the constraints can be
rewritten as the linear system of equations Lx = 1, where the matrix L∈{0, 1}(n+m)×[(n+1)(m+1)−1]
is given by Fig. 2, i.e.

∀(i, j),

∀k = 1, . . . , n
lk,(i,j) = δk=i,
ln+k,(i,j) = δk=j, ∀k = 1, . . . , m

(27)

(cid:40)

where δa=b = 1 if a = b and 0 else. The n ﬁrst rows of L represent the constraints on the rows
of X (|ϕ(i)| = 1,∀i∈U) and its m last rows represent the constraints on the columns of X
(|ϕ−1[j]| = 1,∀j ∈V). Each element lk,(i,j) = 1 corresponds to a possible edit operation:

• a substitution i → j, when k = i∈U or n + j with j ∈V,
• a removal i →  when k = i∈U and j = m + 1, or
• an insertion  → j when k = n + j with j ∈V, and i = n + 1.

Note that  is not represented as a row of L since it is unconstrained. The matrix L represents
the discrete domain whereon solutions to the LSAPE are deﬁned.
Contrary to the constraint matrix involved in the LASP, which corresponds to the node-edge
incidence matrix of the complete bipartite graph Kn,m with node sets U and V, the constraint
matrix L can be viewed as a node-edge incidence matrix of the mixed bipartite graph Kn,m,
composed of Kn,m and the two bipartite digraphs ((V,{}),V ×{}) and ((U,{}),U ×{})
It is important to remark that
representing insertion and removal operations, respectively.
Kn,m, does not have any arc from  to U ∪V. Due to the deﬁnition of x, Lx selects exactly one
edge or arc in the neighborhood of each node in U ∪V. An -assignment can thus be assimilated
to a subgraph of Kn,m, having each node in U ∪V connected to only one other node. Solving
the LSAPE consists in computing such a subgraph that minimizes the objective functional A.

11

Similarly, let c = vec(C)∈ [0, +∞)(n+1)(m+1)−1 be the vectorization of the edit cost matrix
C. With these notations, the LSAPE given by Eq. 26 consists in selecting a vector satisfying

cT x | Lx = 1, x ∈ {0, 1}(n+1)(m+1)−1(cid:111)
(cid:110)

argmin

(28)

which is a binary linear program.
By deﬁnition, each column of L sums to no more than 2, and its rows can be partitioned into
two sets, U and V, such that a 1 appears in each column at most once in each set (Fig. 2). Then
the matrix L is totally unimodular. By standard tools in linear programming, a binary linear
programming problem with totally unimodular constraint matrix has always a binary optimal
solution, see [18] for more details on linear programming problems. So the LSAPE has a binary
optimal solution. As for the LSAP (and the sLSAPE), this shows that the LSAPE can be solved
with linear programming tools.

3.4 Primal-dual problem and admissible transformations

Consider the LSAPE expressed as a binary linear program (Eq. 28). By standard tools in duality
theory and linear programming [18], the problem dual to the LSAPE consists in ﬁnding two
vectors u∈ [0, +∞)n and v ∈ [0, +∞)m, which associate a real value to each element of the sets
U and V respectively, and satisfying

argmax

1T
n u + 1T

mv | LT

≤ c,

∈ [0, +∞)n+m

(cid:27)

(cid:18)u
(cid:19)

v

(cid:18)u
(cid:19)

v

(cid:111)

(cid:26)
(cid:110)

or equivalently

argmax

(u,v)

E(u, v) def.= 1T

n u + 1T

mv

s.t. u∈ [0, +∞)n, v ∈ [0, +∞)m

ui + vj ≤ ci,j, ∀i = 1, . . . , n, ∀j = 1, . . . , m
ui ≤ ci,m+1, ∀i = 1, . . . , n
vj ≤ cn+1,j, ∀j = 1, . . . , m

(29)

One can remark that the objective functional E(u, v) is the same as the one involved in the
problem dual to the LSAP, see [4], but the two last constraints are diﬀerent.

By the strong duality theorem, if X is a solution to the LSAPE (primal problem), then its

dual problem has an optimal solution (u, v) and the solutions (X, (u, v)) satisfy

A(X, C) = E(u, v).

(30)

Such a primal-dual problem can be solved by ﬁnding transformations of the edit cost matrix,
called admissible. We adapt the notion of admissible transformations of cost matrices (or equiv-
alent cost matrices), developed in the context of the classical assignment problem to edit cost
matrices, see for instance [4].
Note that the dual variables can be expressed as a pair (u, v) such that u∈ [0, +∞)n+1 with
un+1 = 0, and v ∈ [0, +∞)m+1 with vm+1 = 0, without altering objective functional E(u, v) and
leading to a rewriting of the three last constraints in Eq. 29 as

ui + vj ≤ ci,j, ∀i = 1, . . . , n + 1, j = 1, . . . , m + 1.

(31)

We use this trick to simplify the forthcoming expressions.

Deﬁnition 3 (-admissible transformation). Let T (C, C) be the transformation of an edit cost
matrix C into a matrix C, with C, C∈ [0, +∞)(n+1)×(m+1). T is called -admissible with index
A(T )∈ R if C is an edit cost matrix and

A(X, C) = A(X, C) + A(T )

for any -assignment X.

12

By consequence, an -assignment X which minimizes A(X, C) also minimizes A(X, C) + A(T ),
and so the edit cost matrices C and C are said to be equivalent (w.r.t. the LSAPE). Remark
that transformations are assumed to produce edit cost matrices.
In particular, transformed
matrices must satisfy C≥ 0.
Lemma 3. Let T (C, C) be an -admissible transformation. Let ˆX be an -assignment satisfying
A( ˆX, C) = 0. Then ˆX represents an optimal -assignment, with total cost A( ˆX, C) = A(T ).
Proof. Let X be an arbitrary -assignment. Under the conditions of the lemma, we have C ≥ 0
and then A(X, C) ≥ 0. So A(X, C) = A(X, C) + A(T ) ≥ A(T ) = A( ˆX, C) + A(T ) =
A( ˆX, C), and A(X, C) reaches its minimum value for X = ˆX.

Admissible transformations of edit cost matrices are linked to the primal-dual equation 30 as
follows.
Proposition 3. Let C be an edit cost matrix. Let a ∈ Rn+1 and b ∈ Rm+1 be two vectors
m+1 + 1n+1bT ≤ C. The transformation T (C, C) such that
such that an+1 = bm+1 = 0 and a1T
C = C− a1T

Proof. Let X be any -assignment. We have:

m+1(cid:88)
(ci,j − ai − bj)xi,j = A(X, C) − n(cid:88)

m+1 − 1n+1bT is -admissible with index A(T ) = E(a, b).
m+1(cid:88)
(cid:124) (cid:123)(cid:122) (cid:125)
m+1b(cid:1) = A(X, C) − E(a, b).

n+1(cid:88)
= A(X, C) −(cid:0)1T

n+1a + 1T

xi,j

i=1

j=1

=1

ai

i=1

j=1

A(X, C) =

− m(cid:88)

j=1

bj

n+1(cid:88)
(cid:124) (cid:123)(cid:122) (cid:125)

xi,j

i=1

=1

So A(X, C) = A(X, C) + E(a, b). Remark that C ≥ 0 with cn+1,m+1 = 0, so C is an edit cost
matrix and the transformation is -admissible.

Consider a dual solution (u, v). Recall that un+1 = vm+1 = 0. By deﬁnition the dual solution
fulﬁls the conditions of Proposition 3. This implies the following complementary slackness
condition.

Proposition 4. (X, (u, v)) solves the LSAPE and its dual problem (primal-dual equation Eq. 30)
iﬀ A(X, C) = 0 with

C = C− u1T
i.e. for all (i, j)∈{1, . . . , n + 1}×{1, . . . , m + 1}

m+1 − 1n+1vT

xi,jci,j = 0 ⇔ ((xi,j = 1) ∧ (ci,j = 0)) ∨ ((xi,j = 0) ∧ (ci,j ≥ 0))
⇔ ((xi,j = 1) ∧ (ci,j = ui + vj)) ∨ ((xi,j = 0) ∧ (ci,j ≥ ui + vj))

(32)

The optimal cost is A(X, C) = E(u, v).

Proof. Suppose that (X, (u, v)) is a solution to the primal-dual equation 30. By Eq. 31 we have
u1T + 1vT ≤ C. Then by Proposition 3, C = C−(u1T + 1vT ) is an -admissible transformation:
A(X, C) = A(X, C) + E(u, v). Since A(X, C) = E(u, v) by Eq. 30, so A(X, C) = 0, which
demonstrates the ﬁrst part (⇒). Now suppose that X is an -assignment, and C is an edit cost
matrix such that C = C − (u1T + 1vT ) and A(X, C) = 0. By Lemma 3 X is optimal with cost
A(X, C) = E(u, v).

This condition is the same for the LSAP, but X and C do not satisfy the same constraints.
Solving the LSAP is equivalent to ﬁnd a transformed cost matrix having k independent zero
elements (k = min{n, m}). Elements of a matrix are independent if none of them occupies the
same row or column. According to K¨onig’s theorem and Eq. 32, this independent set of zero
elements exactly corresponds to an optimal assignment [8, 11, 1]. Hungarian-type algorithms
are based on this property. In order to derive similar algorithms for solving the LSAPE, the
notion of independent elements needs to be adapted.

13

Deﬁnition 4 (-independent). Let S be a set of elements of a (n + 1)× (m + 1) edit cost matrix
C. Elements of S are -independent if there is at most one element of S on each row i = 1, . . . , n
of C, and at most one element of S on each column j = 1, . . . , m of C. The set S is maximal
when there is exactly one element of S on each row i = 1, . . . , n, and exactly one element of S
on each column i = 1, . . . , n.

Obviously, by deﬁnition, any -assignment contains a maximal set of -independent elements
equals to 1. This implies the following property.
Corollary 3. Let S be a maximal set of -independent elements of an edit cost matrix C. Let
u and v be two vectors such that
ci,j = ui + vj, ∀(i, j)∈S,
ci,j ≥ ui + vj, ∀(i, j)(cid:54)∈S.

(cid:40)

(33)

Then the matrix X constructed such that xi,j = δ(i,j)∈S is an optimal -assignment for the
LSAPE, and (u, v) solves its dual problem.

Proof. By construction and from Deﬁnition 4, X deﬁnes an -assignment. Also, X and C satisfy
the complementary slackness condition given by Eq. 32. So by Proposition 4 (X, (u, v)) solves
the LSAPE and its dual problem.

The Hungarian-type algorithm proposed in the following section ﬁnds such a maximal set of
-independent elements.

4 A Hungarian algorithm for solving the LSAPE

We consider an edit cost matrix C∈ [0, +∞)(n+1)×(m+1) (Eq. 19) between two sets U ={1, . . . , n}

We propose to compute a solution to the LSAPE (Eq. 3 or Eq. 26), and its dual problem
(Eq. 29), by adapting the Hungarian algorithm that initially solves the LSAP and it dual
problem [8, 11, 1, 10, 4]. There is several versions of the Hungarian algorithm. We adapt the
one presented in [10, 4], which is known to be more eﬃcient both in time and space.
and V ={1, . . . , m}. Recall that row n + 1 of C encodes the cost of inserting each element of
V into U. Similarly, column m + 1 encodes the cost of removing each element of U. Consider
the sets U =U ∪{n + 1} and V =V ∪{m + 1}. The proposed adaptation of the Hungarian al-
gorithm takes into account the relaxation of the constraints associated to removal and insertion
operations.

Intuitively, the algorithm proceeds like the classical Hungarian algorithm. First, it computes
an initial partial -assignment (Section 2.3), together with a pair of dual variables, such that the
complementary slackness condition is satisﬁed (Eq. 32). Then, while maintaining this condition,
the set of assigned elements of V (substituted or removed) is iteratively augmented by solving a
restricted primal-dual problem. When all elements of V are assigned, some elements of U may
not be assigned. So the algorithm proceeds until they are, as before. Since the complementary
slackness condition is preserved through the iterations, the algorithm ends with an optimal
solution (Prop. 4). This is detailed in the following sections.

4.1 Encoding and pre-processing

In the following algorithms, a partial -assignment is not encoded by its associated binary matrix
X∈{0, 1}(n+1)×(m+1) (Section 2.3) but by a pair of vectors (ρ, ) with ρ∈{0, 1, . . . , m + 1}n,
∈{0, 1, . . . , n + 1}m, and such that

(cid:26) j
(cid:26) i

0

if ∃j ∈{1, . . . , m + 1} | xi,j = 1
else (unassigned)
if ∃i∈{1, . . . , n + 1} | xi,j = 1

(34)

ρi =

j =

0 else (unassigned)

Note that unassigned elements of the partial -assignment are assigned to 0. The matrix X can
be easily reconstructed from ρ and .

14

1 begin PreProcessing(C)
2

un+1, vm+1 ← 0, ρ ← 0n,  ← 0m
for i = 1, . . . , n do ui ← min{ci,j | j = 1, . . . , m + 1}
for j = 1, . . . , m do vj ← min{ci,j − ui | i = 1, . . . , n + 1}
for i = 1, . . . , n do

if (j = 0) ∧ (ci,j = ui + vj) then

for j = 1, . . . , m do
ρi ← j, j ← i
break

// i assigned to j

if (ρi = 0) ∧ (ci,m+1 = ui) then ρi ← m + 1

// i→ 

for j = 1, . . . , m do

if (j = 0) ∧ (cn+1,j = vj) then j ← n + 1

// → j

return ((ρ, ), (u, v))

Algorithm 1: Basic pre-processing

3

4

5

6

7

8

9

10

11

12

13

We want to compute an initial partial -assignment X, and a pair of dual variables (u, v),
such that Eq. 32 is satisﬁed. To this we adapt the basic pre-processing step involved in the
Hungarian algorithm [4]. Algorithm 1 details this step. The minimum cost on each row i∈U of
C allows to construct u. Then, the minimum cost on each column j ∈V of C− u1T
m+1 allows to
construct v. By construction we have C ≥ u1T
m+1 − 1n+1vT be
the transformed edit cost matrix (Proposition 3). This transformation guaranties the existence
of at least one element j ∈V satisfying ci,j = ui + vj, or equivalently ci,j = 0, for each i∈U. In
other terms, each row i∈U of C contains at least one 0. Similarly, each column j ∈V of C
contains at least one 0. So it is possible to deduce a partial -assignment, eventually reduced to
one pair of assigned elements only, satisfying Eq. 32. Algorithm 1 ﬁnds such a set by a scanline
approach. Note that the whole algorithm has a O(nm) time complexity.

m+1 + 1n+1vT . Let C = C− u1T

Algorithm 1 has a O(nm) time complexity. More sophisticated pre-processing methods can

be adapted to ﬁnd an initial partial -assignment, see [4] for more details on these methods.

Example 1. Consider the edit cost matrix

(35)



0
0
0
1
4

2
4
4
3
0

0
4
3
2
0

1
3
5
0
7

2
5
8
0
8

3
1
4
1
0

 .

First part of Algorithm 1 computes

7
2
1
3
4

11
8
7
7
2

9
8
6
6
2

8
5
6
2
7

9
7
9
2
8

10
3
5
3
0

 and v =

7
2
1
2
0



0
2
2
0
0
0

C =

u =







 , so C = C − u1T − 1vT =
 ,

Due to the distribution of the zeros in C, which correspond to the elements of C satisfying
ci,j = ui + vj, only partial assignments with edition can be constructed. Second part of Algorithm
1 leads to ρ = (1, 0, 0, 4) and  = (1, 5, 5, 4, 0), equivalently represented by

C =

0∗
0
0
1
4

2
4
4
3
0∗

0
4
3
2
0∗

1
3
5
0∗
7

2
5
8
0
8

3
1
4
1
0

where ci,j = 0∗ corresponds to i→ j in the partial -assignment.

15

(a) last edge is unassigned

(b) last edge is unassigned

only substitutions

ending with a removal

(c) last edge is assigned
ending with an insertion

Figure 3: Three cases of augmenting paths starting with an unassigned edge (i1, j1). Unassigned
edges are dotted.

4.2 Augmenting paths

Consider a partial -assignment (ρ, ) (or equivalently X) and a pair of dual variables (u, v)
satisfying Eq. 32. The partial -assignment may be empty (no pre-processing), i.e. ρ = 0n,
 = 0m, u = 0n+1 and v = 0m+1. Assume that at least one element k ∈V is not assigned to an
element of U, for instance k = 5∈V in Example 1. We want to ﬁnd a new partial -assignment
such that:

1. k becomes assigned to an element of U,
2. all previously assigned elements are still assigned, and

3. there is a pair of dual variables such that Eq. 32 is satisﬁed.

Let Sn,m,,k be the set of all matrices representing a partial -assignment which satisﬁes con-
straints 1 and 2 above.

To solve this sub-problem of the LSAPE, we consider a subgraph of the mixed bipartite
graph Kn,m, (Section 3.3) whose edges and arcs satisfy ci,j = ui + vj, i.e. ci,j = 0. Let G0 be this
subgraph. By deﬁnition, the bipartite graph which represents the current partial -assignment
X is a subgraph of G0 (its node adjacency matrix is X). It deﬁnes a set of assigned nodes and
edges on G0, an edge (i, j) being assigned iﬀ xi,j = 1 in the current partial -assignment.

The new partial -assignment is constructed by computing minimal paths in Kn,m,, i.e.
paths in G0. By deﬁnition, a path P in Kn,m, alternate an element of a set and an element of
the other. Also, since there is no arc from  to any other element of U ∪V in Kn,m, (Section 3.3),
 can only be a terminal node of a path. The length of a path, penalized by the edit costs, is
deﬁned by

γC(P ) =

ci,j.

(36)

(cid:88)

(i,j)⊂P

Deﬁnition 5 (alternating and augmenting paths). A path in Kn,m, is alternating if its edges/arcs
are alternatively unassigned and assigned. An alternating path, which starts with an unassigned
element k of V (resp. U) and ends with

1. an unassigned element of U (resp. V), or
2. the null element  of U or V,

is an augmenting path if its length deﬁned by Eq. 36 is minimal among all the alternating paths
connecting k to an element satisfying one of the two cases above.

Contrary to the classical deﬁnition of augmenting paths, see [4], an augmenting path as deﬁned
above may end with an assigned arc. Assume that the starting node of the path is k ∈V. Then,
these two conﬁgurations can be encountered:

• If il ∈U is the last node, the path can be represented as a sequence (k = j1, i1, j2, i2, . . . , jl, il)
with js ∈V and ir ∈U for r = 1, . . . , l − 1. Since the ﬁrst edge (j1, i1) is unassigned and
since the path is alternating, the last edge (jl, il) is also unassigned (Fig. 3(a,b)), as in the
classical case.

16

21341234ij2134123ijε213123ijε• If ∈V is the last node, the path can be represented as a sequence (k = j1, i1, j2, i2, . . . , jl, il, )

with js ∈V and ir ∈U. In this case the last arc (il, ) is assigned, i.e. il is assigned to 
(Fig. 3(c)).

Once an augmenting path has been found, a new partial -assignment is constructed by assigning
unassigned edges/arcs of the path, and reciprocally, as follows.

Proposition 5. Let X be the matrix representation of a partial -assignment, and (u, v) be
a pair of dual variables (un+1 = vm+1 = 0), such that the complementary slackness condition
(Eq. 32) is satisﬁed. Let P be an augmenting path starting with an unassigned element k ∈V
(resp. U). The matrix X(cid:48), deﬁned by

(cid:40)

x(cid:48)
i,j =

1 − xi,j
xi,j

if (i, j)⊂ P
else

,

n+1(cid:88)

i=1

represents an optimal partial -assignment, i.e. satisfying

X(cid:48) ∈ argmin{A(Y, C)| Y ∈Sn,m,,k} ,

(37)

Its total cost is equal to A(X(cid:48), C) = γC(P ) + E(u, v), with C = C− u1T
Proof. Let P be an augmenting path starting with an element k ∈V. We have X(cid:48) ∈{0, 1}(n+1)×(m+1)
by deﬁnition. We show that any column j ∈V of X(cid:48) sums to no more than 1. First remark that
for any j included in P we have:

m+1 − 1n+1vT .

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

x(cid:48)
i,j =

x(cid:48)
i,j +

x(cid:48)
i,j =

(i,j)⊂P

(i,j)(cid:54)⊂P

(i,j)⊂P

(1 − xi,j) +

xi,j =

(i,j)(cid:54)⊂P

(i,j)⊂P

(1 − xi,j)

since there is at most one i∈U such that xi,j = 1, and this element is included in P . Moreover
we have:

• For j = k, there is no i∈U such that xi,k = 1, then the neighbor i1 of k in P satisﬁes

xi1,k = 0. So x(cid:48)

i1,k = 1 and x(cid:48)

i,k = 0 for all i∈U \{i1}.

So(cid:80)n+1
(cid:80)n+1
Similarly, we have (cid:80)m+1
i=1 xi,j ∈ {0, 1} by deﬁnition.
j=1 x(cid:48)

• For any j ∈V \{k} included in P , j has two neighbors ia and ib of U in P satisfying
i,j = 0 for all

for instance xia,j = 1 and xib,j = 0. So we have x(cid:48)
i∈U \{ia, ib}.
i=1 x(cid:48)

i,j ∈ {0, 1} for any j included in P . When j is not a node of P , we have(cid:80)n+1

i,j =
i,j ∈ {0, 1} and so X(cid:48) is a partial -assignment. This shows
that any augmenting path starting with an unassigned element k ∈V leads to a new partial
-assignment that assigns this element. Now we show that this partial -assignment is optimal
among all partial -assignments in Sn,m,,k.

ia,j = 0, x(cid:48)

ib,j = 1, and x(cid:48)

i=1 x(cid:48)

Since X and C satisfy the complementary slackness condition, the total cost A(X, C) can

be decomposed into 4 terms:

A(X, C) =

ci,jxi,j

+

(cid:88)

(cid:88)

(cid:125)

ci,jxi,j

+

ci,jxi,j

+

(cid:124)

(cid:123)(cid:122)

(i,j)⊂P
xi,j =0
=0 (ci,j≥0)

(cid:125)

(cid:124)

(i,j)(cid:54)⊂P
xi,j =1

(cid:123)(cid:122)

=0 (ci,j =0)

ci,jxi,j

(cid:123)(cid:122)

(i,j)(cid:54)⊂P
xi,j =0
=0 (ci,j≥0)

(cid:125)

Similarly we have for X(cid:48):

=0 (ci,j =0)

A(X(cid:48), C) =

ci,j(1 − xi,j)

+

ci,j(1 − xi,j)

+

(cid:88)

(cid:125)

(i,j)(cid:54)⊂P
xi,j =1

(cid:124)

(cid:123)(cid:122)

ci,jxi,j

+

(cid:125)

ci,jxi,j

(cid:124)

(cid:123)(cid:122)

(i,j)(cid:54)⊂P
xi,j =0
=0 (ci,j≥0)

(cid:125)

≥0 (ci,j≥0)

=0 (ci,j =0)

(cid:123)(cid:122)

(cid:88)

(cid:125)

(cid:124)
(cid:88)

(cid:88)

(cid:124)

(i,j)⊂P
xi,j =1

(cid:123)(cid:122)
(cid:88)

(i,j)⊂P
xi,j =1

(cid:124)

= 0 +

=0 (ci,j =0)

(cid:123)(cid:122)
(cid:88)
(cid:123)(cid:122)

(cid:124)

ci,j

(cid:125)

(i,j)⊂P
xi,j =0
≥0 (ci,j≥0)

(cid:88)

(i,j)⊂P
xi,j =0

(cid:124)

(cid:125)

+ 0 + 0 = γC(P )

17

Since P is a minimal path among all augmenting paths connecting k to an unassigned element
of U or to , X(cid:48) is a partial -assignment with a minimal cost.

If each edge/arc of P satisﬁes ci,j = 0 (P is thus contained in G0), then γC(P ) = 0 and by
consequence A(X(cid:48), C) = E(u, v). The sub-problem (Eq. 37) of the LSAPE can thus be solved
by computing an augmenting path P , together with a transformed edit cost matrix C, such that
γC(P ) = 0. This is detailed in Section 4.3. The new partial -assignment is then obtained by
assigning unassigned edges and by deassigning assigned edges along the path (Proposition 5),
as detailed in Section 4.4.

Example 2. Consider the partial -assignment deﬁned by ρ = (1, 0, 0, 4) and  = (1, 5, 5, 4, 0) for
the edit cost matrix



0∗
0
0
2
4

2
0
4
4
4
3
4
3
0∗ 0∗

0
2
4
0∗
6

1
4
7
0
7

3
1
4
2
0

 ,

G0 =

We want to assign k = 5∈V. In the corresponding bipartite graph G0 above (gray and black
edges), k = 5 can be linked to an unassigned element of U (2 or 3), by a path which alternates
unassigned (gray) and assigned (black) edges, i.e. an augmenting path. Consider the one ending
with 2∈U:

swap

=⇒

By swapping assigned and unassigned edges along the path:





0
0∗
0
2
4

2
4
4
4
0∗

0
4
3
3
0∗

0∗
2
4
0
6

1
4
7
0∗
7

3
1
4
2
0

G0 =

we obtain the partial -assignment ρ = (4, 1, 0, 5) and  = (2, 5, 5, 1, 4).
The augmenting path can also ends with an element , either (n + 1)∈U or (m + 1)∈V. In one
of these cases and contrary to the classical deﬁnition of augmenting paths [4], an augmenting
path can end with an assigned arc, as illustrated in the following example.

Example 3. Consider the partial -assignment deﬁned by ρ = (4, 1, 2) and  = (2, 3, 0, 1) for the
edit cost matrix:

 0

0∗
0
4

 , G0 =

0
2
0∗
6

3 0∗
2
0
2
3
0
8

4
7
6
0

The path starting with 3∈V and ending with (n + 1)∈U leads to ρ = (1, 2, 3) and  = (1, 2, 3, 4):

 0∗

0
0
4



0
2
0∗
6

3
0∗
2
8

0
2
3
0∗

4
7
6
0

swap⇒

⇒

18

εVεU1234ε12345εεVεU1234ε12345εεVεU1234ε12345εεVεU1234ε12345εεVεU1231234εεεVεU1231234εεεVεU1231234εεεVεU1231234εεFor the last case, consider the partial -assignment deﬁned by ρ = (3, 4, 2) and  = (0, 3, 1). We
want to assign 1∈V:

 2

3
7
0
0 0∗
6
4

0∗
5
4
0

4
0∗
6
0

 , G0 =

This leads to ρ = (3, 2, 1) and  = (3, 2, 1):

path:

swap⇒

⇒

 2

7
0∗
4



3
0∗
0
6

0∗
5
4
0

4
0
6
0

Remark that the last edge of the path switches from assigned to unassigned.

4.3 Construction of an augmenting path
Algorithm 2 details the construction of an augmenting path from an unassigned element k ∈V.
It consists in growing a tree T 0 of minimal alternating paths in G0, rooted in k, until an
augmenting path has been found. This is similar to Dijkstra’s algorithm to compute minimal
paths in bipartite graphs. The tree is constructed by growing two sets, SV (initialized to k)
and SU, representing the current nodes of the tree. Candidate nodes of U to the extension are
represented by the set LU\ SU , where the set LU deﬁnes the nodes of U within the tree, as
well as all candidate nodes. For computational purposes, the more general tree T of minimal
alternating paths rooted in k (not necessary in G0) is constructed. This tree is encoded by a
predecessor vector pred∈V n (for unassigned edges) and the pair (ρ, ) encoding the partial
-assignment (for assigned edges). The vector π ∈ [0, +∞)n encodes, for each i, the minimal
transformed cost ci,j among all nodes j ∈ SV. The tree T 0 ⊂ G0 is obviously included in the tree
T . Note that π and pred do not consider the element . Indeed, since it can only be a sink of
an augmenting path, the algorithm stops when it is encountered (see below).
At each iteration, the last node j ∈ SV inserted to the tree T 0 is considered (line 5). Each
node i∈U \ LU (line 9) is added to LU as a candidate node to the extension of T 0 (line 15) if
it is connected to j in G0 (line 13), i.e. ci,j = 0. Remark that T is constructed simultaneously
(lines 10–12). When there is at least one candidate node (LU\ SU(cid:54)=∅), one is selected and
added to the set SU of nodes of T 0 (lines 30 and 31), i.e. the unassigned edge (i, predi) is
candidate for an augmenting path, together with the assigned node ρi and edge (i, ρi). Then ρi
is considered for the next iteration (lines 32 and 5). The tree stops to grow when an unassigned
node of U is reached (line 14), when  is reached (line 14 or 6), or when there is no candidate
node in LU , i.e. LU \ SU =∅ (line 16). In this case, dual variables u and v are updated such
that at least one new unassigned edge is inserted in G0 (lines 18–22), i.e. ci,j = 0 is satisﬁed for
at least one pair (i, j)∈ ((U \ LU )∪{n + 1})× SV . Such nodes i∈U \ LU become candidates
(lines 26 and 28), as before. By construction, ((U \ LU)∪{n + 1}) × SV does not contain any
edge of G0 (including assigned edges).

Proposition 6. Let (X, (u, v)) and C be a partial -assignment, a pair of dual variables and
an edit cost matrix such that Eq. 32 is satisﬁed. Consider the minimum transformed cost

δ = min{ci,j | i(cid:54)∈ LU, j ∈ SV}

m+1 − 1n+1vT and un+1 = vm+1 = 0. Eq. 32 is still satisﬁed if the dual variables

with C = C− u1T
(u, v) are updated by

(cid:26) ui ← ui − δ, ∀i∈ LU

vj ← vj + δ, ∀j ∈ SV

(38)

19

εVεU123123εεεVεU123123εεεVεU123123εεεVεU123123εε1 begin Augment(k, C, ρ, , u, v, U )
2

n←|U|, π ∈ [0, +∞]n, SV , SU , LU ← ∅, j ← k
foreach i∈ U do πi ← +∞
while true do

SV ← SV ∪{j}
if (j ≤ n) ∧ (cn+1,j − vj = 0) then

return (n + 1, j, u, v, pred)

// ﬁnd candidate nodes and update the tree
foreach i∈ U \ LU do

if ci,j − ui − vj < πi then

predi ← j
πi ← ci,j − ui − vj
if πi = 0 then

if ρi ∈{0, m + 1} return (i, 0, u, v, pred)
LU ← LU ∪{i}

// update dual variables and ﬁnd candidate nodes
if LU \ SU =∅ then

δs ← min{πi | i∈ U \ LU}
(l, δ) ← (argmin, min){cn+1,j − vj | j ∈ SV }
δ ← min{δs, δ}
foreach j ∈ SV do vj ← vj + δ
foreach i∈ LU do ui ← ui − δ
if δ ≤ δs return (n + 1, l, u, v, pred)
foreach i∈ U \ LU do

πi ← πi − δ
if πi = 0 then

if ρi ∈{0, m + 1} return (i, 0, u, v, pred)
LU ← LU ∪{i}

// extend the tree
i ← any element in LU \ SU
SU ← SU ∪{i}
j ← ρi

Algorithm 2: Construct an augmenting path starting at k ∈V.

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

 ci,j − δ

ci,j + δ
ci,j

ci,j ←

or equivalently if the transformed edit cost matrix C is updated by

if i (cid:54)∈ LU, j ∈ SV
if i ∈ LU, j (cid:54)∈ SV
else

(39)

This updating augments the graph G0 with at least one new edge in ((U \ LU)∪{n + 1}) × SV.
Proof. The updating of the dual variables given by Eq. 38 leads to the following cases:

1. When i(cid:54)∈ LU and j (cid:54)∈ SV, no updating occurs, and so the complementary slackness condi-

tion(CSC) is maintained in this case.

2. When i∈ LU and j ∈ SV, we have ci,j − (ui − δ) − (vj + δ) = ci,j − ui − vj = ci,j. So no

updating occurs and as before the CSC is preserved in this case.

3. When i∈ LU and j (cid:54)∈ SV, ci,j is updated by ci,j−(ui−δ)−vj = ci,j +δ. So the transformed
cost does not become negative. Since elements i∈ LU can only be assigned to elements
j ∈ SV (xi,j = 1), we have xi,j = 0 for all j (cid:54)∈ SV, and by consequence the CSC is preserved.
4. When i(cid:54)∈ LU and j ∈ SV, ci,j is updated by ci,j − ui − (vj + δ) = ci,j − δ which is non-
negative by deﬁnition. Since δ is the minimum of ((U \ LU)∪{n + 1})× SV, the updating

20

produces at least one pair (i, j) such that ci,j = 0 (a new edge added to G0). Also, δ > 0
induces that ci,j (cid:54)= 0 and xi,j = 0 before the updating (by complementary slackness). By
consequence the CSC is also preserved in this case.

So transformed costs do not become negative and the CSC is preserved on U ×V. Moreover,
this shows that the graph G0 is augmented by at least one new edge, ensuring the dual updating
to produce an enlarged tree.

This shows that the dual update adds at least one edge to G0, guaranteeing to complete the tree
at each iteration (lines 30, 31 and 5). This also implies that Eq. 32 is satisﬁed at each iteration.
Since each node of U can be reached, and since each node of the tree T 0 is inserted only once, an
augmenting path is found if there is an unassigned node of U. Since nodes  are unconstrained,
an augmenting path is also found whenever they are encountered. Even when all elements of
U are already assigned, it is possible to ﬁnd an augmenting path, ending by a node . Since
the length γC = 0, by Proposition 5 the corresponding matrix X(cid:48) solves the sub-problem of the
LSAPE.
The growing of the tree depends on the encoding of the set LU\ SU and the selection of the
next node of U (line 30). We propose to use a FIFO strategy, leading to a breadth-ﬁrst like
growth of the tree. It can be eﬃciently encoded, together with the sets LU, U \ LU and SU, by
a permutation of U (Fig. 6 and Appendix A), since U = SU∪ (LU\ SU)∪ (U \ LU).
Example 4. Consider the partial -assignment given by ρ = (3, 0, 1, 4, 0) and  = (3, 6, 1, 4, 0, 0),
and the following cost matrix with u = 05 and v = 06. We want to assign k = 5∈V, which is the
root of the tree T . So in the ﬁrst iteration of Algorithm 2, the element j = 5∈V is added to SV
and all its neighbors in U are added to the tree as a child of j (π and pred). Then, since there
is one element i = 4∈U having a zero transformed cost ci,j = 0, we have LU \ SU = LU ={4}.
Since there is one element j(cid:48) = 4∈V such that j(cid:48) = i, it is selected as the next j for the next
iteration and i = 4 is then added to SU. The resulting tree T is given below, circles represent
elements of V and squares represent elements of U. Black edges are used to represent T 0.



8
2
0∗
S/L 1
2
4

2
4
4
3
0
0∗

0∗
4
3
2
1
1

1
6
1
0∗
3
7

S
2
5
8
0
4
8

1
7
5
0
5
4

3
1
4
1
3
0







2
5
8
0
4

, π =

, pred =





5
5
5
5
5

In the second iteration, while there is no neighbor of j = 4 in U \ LU with a zero reduced cost,
the tree is updated if elements of U \ LU are connected to j by a strictly lower cost.



8
2
0∗
S/L 1
2
4

2
4
4
3
0
0∗

0∗
4
3
2
1
1

S
1
6
1
0∗
3
7

S
2
5
8
0
4
8

1
7
5
0
5
4

3
1
4
1
3
0







1
5
1
0
3

, π =

, pred =



,



4
5
4
5
4

So a dual updating is performed since LU \ SU =∅. The minimum cost is 1 and so the dual
variables become u = (0, 0, 0,−1, 0) and v = (0, 0, 0, 1, 1, 0).



8
2
0∗
S/L 1
2
4

2
4
4
3
0
0∗

0∗
4
3
2
1
1

S
1
6
1
0∗
3
7

S
2
5
8
0
4
8

1
7
5
0
5
4

3
1
4
1
3
0





0
4
0
0
2



 δs = 1

δ = 7
δ = min{δs, δ} = 1

,

, π =

21





4
5
4
5
4

, pred =

5ε528084215434ε54ε058113741352At the end of the iteration, we have the following edit cost matrix and tree, with LU \ SU ={1, 3}.
By considering a FIFO strategy, the element i = 1 is added to SU and its corresponding assigned
element j = 3∈V is selected for the next iteration.

2
4
4
4
0
0∗

0∗
4
3
3
1
1

S
0
5
0
0∗
2
6

S
1
4
7
0
3
7

1
7
5
1
5
4

3
1
4
2
3
0

i = 1, j = 3

In the third iteration, j = 3∈V is added to SV, and the tree is updated. Since LU \ SU ={3},
i = 3 is added to SU and its corresponding element j = 1 is selected for the next iteration.

S
0∗
4
3
3
1
1

S
0
5
0
0∗
2
6

S
1
4
7
0
3
7

2
4
4
4
0
0∗

1
7
5
1
5
4

3
1
4
2
3
0





, π =

, pred =



L 8
2
L 0∗
S/L 2
2
4



S/L 8
2
L 0∗
S/L 2
2
4

In the fourth iteration, j = 1∈V is added to SV.



S
S/L 8
2
S/L 0∗
S/L 2
2
4

S
0∗
4
3
3
1
1

S
0
5
0
0∗
2
6

S
1
4
7
0
3
7

2
4
4
4
0
0∗

1
7
5
1
5
4

3
1
4
2
3
0

, π =



, pred =



Since LU \ SU =∅, dual variables are updated. The minimum is δ = 1 and the dual variables are
updated as before: u = (−1, 0,−1,−2, 0) and v = (1, 0, 1, 2, 2, 0). According to



S
S/L 8
2
S/L 0∗
S/L 2
2
4

S
0∗
4
3
3
1
1

S
0
5
0
0∗
2
6

S
1
4
7
0
3
7

2
4
4
4
0
0∗

1
7
5
1
5
4

3
1
4
2
3
0





0
2
0
0
1





4
1
4
5
3

, π =

, pred =





4
5
4
5
3

4
1
4
5
3





0
4
0
0
1

0
2
0
0
1



,







22

ε54ε31706200441352ε5431εε7000611441352ε5431εεε70006112441352the updating of the transformed costs is given by



S
S/L 8
1
S/L 0∗
S/L 2
1
3

S
0∗
3
3
3
0
0

S
0
4
0
0∗
1
5

S
1
3
7
0
2
6

2
4
4
4
0
0∗

1
7
5
1
5
4

3
1
4
2
3
0





0
1
0
0
0



, pred =





4
1
4
5
3

, π =

Remark that there is two minimal paths. But, according to Algorithm 2, ∈U is selected as a
sink, and an augmenting path can then be extracted as described in the following section.



S
S/L 8
1
S/L 0∗
S/L 2
1
3

S
0
3
3
3
0
0∗

S
0∗
4
0
0
1
5

S
1
3
7
0∗
2
6

3
4
5
5
0
0∗

2
7
6
2
5
4

4
1
5
3
3
0



Proposition 7. Algorithm 2 computes an augmenting path in O((2n + min{n, m}) min{n, m})
time complexity.
Proof. At each iteration of the main loop, one element of V is added to SV (initially empty).
For the ﬁrst iteration this element is provided (j = k with k being the root of the tree), but
for all other iterations it is computed from the last element i∈U added to SU (also initially
empty). By assuming that a sink is always found by the algorithm, we have |SU| = |SV |− 1
since the main loop ends before augmenting SU . Moreover, since elements are added only once
to SU and SV, we have |SU| ≤ |U|− 1 and |SV | ≤ |V|. Then we have |SV | = |SU| + 1 ≤ |U|,
and by consequence |SV | ≤ min{|U|,|V|} and |SU| ≤ min{|U|,|V|} − 1. So the main loop has
O(min{n, m}) iterations. For each iteration:

• U \ LU is traversed 3 times (lines 9, 17 and 24) and has at most n elements,
• LU is traversed 1 time (line 22) and has at most n elements,
• SV is traversed 2 times (lines 19 and 21) and has at most min{n, m} elements.

So each iteration of the main loop runs in O(2n + min{n, m}) time complexity. Indeed, the
encoding of the sets LU , LU \ SU and U \ LU with a permutation allows to traverse these sets
in O(n) time complexity.
Observe that the time complexity depends on min{n, m}. If n≤ m then Algorithm 2 runs in
O(n2), else in O((2n + m)m).
Algorithm 2 assigns an unassigned node k ∈V. An unassigned node k ∈U can also be assigned

by simply swapping the role for ρ and , u and v, and by considering CT .

4.4 Main algorithm

Let (ρ, ) and (u, v) be a partial -assignment and its associated dual variables satisfying Eq. 32,
obtained for instance with Algorithm 1.
The partial -assignment is completed by Algorithm 3. To this, each unassigned element
of V is assigned to an element of U by computing an augmenting path (Algorithm 2) and
then by swapping unassigned and assigned edges along the path (2nd step of assignCols and
Proposition 5), which is realized by a backtrack from the sink to the root of the tree according
to the predecessor vector and the previous partial -assignment in O(min{n, m}) time com-
plexity. Since m elements of V can be unassigned, the ﬁrst call to assigCols is executed in
O(m min{n, m}(2n + min{n, m}) = O(min{n, m}2(m + 2 max{n, m})) time complexity.

23

ε5431εεε600050013413521 begin HungarianLSAPE(C, ρ, , u, v)
U ← {1, . . . , n}, V ← {1, . . . , m}
2
// assign unassigned elements of V
(ρ, , u, v) ←assignCols(C, ρ, , u, v, U, V )
// assign unassigned elements of U
(, ρ, v, u) ←assignCols(CT , , ρ, v, u, V, U )
return ((ρ, ), (u, v))

5

6

3

4

7

8 begin assignCols(C, ρ, , u, v, U, V )
9

foreach k ∈ V | k = 0 do

10

11

12

13

14

15

16

17

18

// ﬁnd an augmenting path rooted in k
(i, j, u, v, pred) ← Augment(k, C, ρ, , u, v, U )
// update partial primal solution
if i = n + 1 then r ← j, j ← i, i ← r
else j ← 0
while j (cid:54)= k do

j ← predi, ρi ← j
r ← j, j ← i, i ← r

return (ρ, , u, v)

Algorithm 3: Compute an -assignment.

The second step of Algorithm 3 consists in augmenting similarly the remaining unassigned
elements of U (line 6). This case occurs when m < n, or when more than max{n, m}− min{n, m}
elements are assigned to  in the ﬁrst step. In the worst-case, all elements of V have been assigned
to  in the ﬁrst step and no element of U have yet been assigned. So the second step executes
in O(min{n, m}2(n + 2 max{n, m})) time complexity.
Proposition 8. Algorithm 3 solves the LSAPE and its dual problem in O(min{n, m}2 max{n, m})
time complexity and in O(nm) space complexity.

Proof. At each iteration of Algorithm 2, the complementary slackness condition is satisﬁed.
So Algorithm 3 computes a maximal set S ={(i, ρi)| i∈V}∪{(j, j)| j ∈V, j = n + 1} of -
independent elements satisfying ci,j = ui + vj for all (i, j)∈ S and ci,j ≥ ui + vj for all (i, j)(cid:54)∈ S.
Then by Corollary 3 the -assignment is optimal. From the above discussion on complexities,
we have

min{n, m}2(m + 2 max{n, m}) + min{n, m}2(n + 2 max{n, m})
= min{n, m}2(n + m + 4 max{n, m})
= min{n, m}2(min{n, m} + 5 max{n, m})
≤ 6 min{n, m}2 max{n, m}

which completes the proof.
Assume that n≤ m, the LSAPE is thus solved in O(n2m) time complexity by Algorithm 3.
Recall that the LSAPE is equivalent the sLSAPE (Problem 2). The complexities of the proposed
algorithm (Proposition 8) are lower than the ones obtained for solving the sLSAPE with the
Hungarian algorithm, i.e. O((n + m)3) in time and O((n + m)2) in space. Observe that more
n, m, and |m− n| are important, more the improvement is.

This is conﬁrmed in practice. We have compared the execution time of the LSAPE and the

sLSAPE with three types of synthetic edit cost matrices:

1. random matrices (Fig. 18),
2. matrices of general term ci,j = i ∗ j (Fig. 18, 1st row),
3. matrices of general term cn−i+1,m−j+1 = i ∗ j for i∈{1, . . . , n} et j ∈{1, . . . , m}. Last line
and column are respectively deﬁned as copies of the n − th line and the m − th column
(Fig. 18, 2nd row).

24

Figure 4: Execution time (in seconds) of the LSAPE (red) vs. squared-LSAPE (blue dotted)
for (uniform) random edit cost matrix. For each size n + m (x-abscissa), a new edit cost matrix
is generated and the time is averaged over several executions on this matrix. First row: both n
and m are varying. Second row: n is ﬁxed and m is varying.

The sLSAPE is solved by an algorithm similar to Algorithm 3 (see [4]) wherein only one set
needs to be augmented and all instructions related to  are not considered. While the LSAPE
and the sLSAPE provide the same optimal value A, as expected the proposed algorithm runs
faster. The diﬀerence in execution time between both algorithms increases according to the
diﬀerence |m− n|. This is easily explained by the growth of the number of assignments between
-elements in the sLSAPE.

Conclusion

We have presented a general framework to transform a set into another by means of edit opera-
tions (substitutions, removals and insertions). The problem of ﬁnding a minimal transformation
is formalized as a linear sum assignment problem where elements can be removed and inserted.
This problem was previously solved by augmenting the given sets such that it can be formalized
as a classical linear sum assignment problem, and thus solved by well-known methods such as
the Hungarian algorithm. Based on the proposed model, the problem is solved by an adaptation
of the Hungarian algorithm that has lower time and memory complexities. Based on the same
model, other algorithms can be adapted similarly.

A Managing the sets in Algorithm 2
Recall that the sets U \ LU, LU, SU and LU\ SU are represented by a permutation PU of U
(Fig. 6). A link to the beginning of each set in the permutation is also saved.

25

0500100015002000250030003500400000.10.20.30.40.5LSAPE vs squared−LSAPE (n=m)number n+m of elements (n=m)execution time (seconds)  LSAPEsquared−LSAPE050010001500200025003000350040004500500000.20.40.60.81LSAPE vs squared−LSAPE (m=4n)number n+m of elements (m=4n)execution time (seconds)  LSAPEsquared−LSAPE500100015002000250030003500400000.10.20.30.40.5LSAPE vs squared−LSAPE (n fixed, m varying)number n+m of elements (n=100 and m=100:10:4100)execution time (seconds)  LSAPEsquared−LSAPEFigure 5: Left column: execution time (in seconds) of the LSAPE (red) vs. squared-LSAPE
(blue dotted). Right column: associated log plot. First row: worst-case obtained for ci,j = ij.
Second row: a variant showing an important improvement (see text).

Figure 6: Encoding of the sets involved in Algorithm 2 as a permutation PU of U.

Example 5. Consider a set U ={1, . . . , 8}. At the beginning of Algorithm 2, we have PU =U
(Fig. 6 left), LU = SU =∅, and so LU \ SU =∅. Assume that π4 = π6 = 0 in the ﬁrst step, and
so i = 4, 6 are iteratively added to LU by swapping each of them with the top of U \ LU (initially
equal to the top of PU), and by incrementing the link to the top. Then we have LU ={4, 6}, the
link to the top of U \ LU is the third element of the array, and the link to the top of LU \ SU is
the ﬁrst element of the array (Fig. 6 middle). There is no dual update since LU \ SU (cid:54)=∅, so the
ﬁrst iteration of the main loop of Algorithm 2 ends by selecting the top of LU \ SU , i.e. i = 6.
Then we have SU ={6}, LU \ SU ={4}, and the link to the top of LU \ SU is incremented in
consequence to become the second element of the array (Fig. 6 right).
Now assume that in the second iteration of the main loop, in the ﬁrst step, we have π1 = 0.
The element i = 1 is added to LU by swapping it with the top of U \ LU , and the process is going
on as before until a sink is found.

References

[1] F. Bourgeois and J.C. Lassalle. An extension of the Munkres algorithm for the assignment problem to

rectangular matrices. Commun. ACM, 14:802–804, 1971.

[2] H Bunke. Error correcting graph matching: on the inﬂuence of the underlying cost function. IEEE Trans-

actions on Pattern Analysis and Machine Intelligence, 21(9):917–922, 1999.

26

050010001500200025003000350040000510152025303540455055LSAPE vs squared−LSAPE (m=2n)number n+m of elements (m=2n)execution time (seconds)  LSAPEsquared−LSAPE020040060080010001200140016001800200010−510−410−310−210−1100101LSAPE vs squared−LSAPEnumber n+m of elementslog(execution time)  LSAPEsquared LSAPE050010001500200025003000350040000246810LSAPE vs squared−LSAPE (m=2n)number n+m of elements (m=2n)execution time (seconds)  LSAPEsquared−LSAPE025050075010001250150010−510−410−310−210−1100LSAPE (red) vs squared−LSAPE (blue dash)number n+m of elementslog(execution time)35178U\LU6LU2451742LUU\LUSULU\SU61235U6784swap38swap[3] H Bunke and G Allermann. Inexact graph matching for structural pattern recognition. Pattern Recognition

Letters, 1(4):245–253, 1983.

[4] R. Burkard, M. Dell’Amico, and S. Martello. Assignment Problems. SIAM, 2009.

[5] S. Fankhauser, K. Riesen, and H. Bunke. Speeding up graph edit distance computation through fast bipartite
matching. In Graph-Based Representations in Pattern Recognition, volume 6658 of LNCS, pages 102–111.
Springer Berlin Heidelberg, 2011.

[6] B. Ga¨uz`ere, S. Bougleux, K. Riesen, and L. Brun. Approximate graph edit distance guided by bipartite
matching of bags of walks. In Structural, Syntactic, and Statistical Pattern Recognition, volume 8621 of
LNCS, pages 73–82, 2014.

[7] D. Justice and A. Hero. A binary linear programming formulation of the graph edit distance. IEEE Trans.

Pattern Anal. Mach. Intell., 28(8):1200–1214, 2006.

[8] H.W. Kuhn. The hungarian method for the assignment problem. Naval Research Logistics Quaterly, 2:83–97,

1955.

[9] H.W. Kuhn. Variants of the hungarian method for the assignment problem. Naval Research Logistics

Quaterly, 3:253–258, 1956.

[10] E.L. Lawler. Combinatorial Optimization: Networks and Matroids. Holt, Rinehart and Winston, New York,

1976.

[11] J. Munkres. Algorithms for the assignment and transportation problems. Journal of the Society for Indus-

trial and Applied Mathematics, 5(1):32–38, 1957.

[12] K. Riesen and H. Bunke. Approximate graph edit distance computation by means of bipartite graph

matching. Image and Vision Computing, 27:950–959, 2009.

[13] K. Riesen and H. Bunke.

Improving bipartite graph edit distance approximation using various search

strategies. Pattern Recognition, 28(4):1349–1363, 2015.

[14] K. Riesen, X. Jiang, and H. Bunke. Exact and inexact graph matching: Methodology and applications.
In C.C. Aggarwal and H. Wang, editors, Managing and Mining Graph Data, volume 40 of Advances in
Database Systems, pages 217–247. Springer US, 2010.

[15] K. Riesen, M. Neuhaus, and H. Bunke. Bipartite graph matching for computing the edit distance of graphs.
In Graph-Based Representations in Pattern Recognition, volume 4538 of LNCS, pages 1–12. Springer Berlin
Heidelberg, 2007.

[16] A. Sanfeliu and K.-S. Fu. A distance measure between attributed relational graphs for pattern recognition.

IEEE Transactions on Systems, Man. and Cybernetics, 13(3):353–362, 1983.

[17] S. Serratosa. Speeding up fast bipartite graph matching through a new cost matrix. Int. Journal of Pattern

Recognition, 29(2), 2015.

[18] G. Sierksma and Y. Zwols. Linear and Integer Optimization: Theory and Practice. Advances in Applied

Mathematics. Chapman and Hall/CRC, 3rd edition, 2015.

[19] W.-H. Tsai and K.-S. Fu. Error-correcting isomorphisms of attributed relational graphs for pattern analysis.

IEEE Trans. on Systems, Man and Cybernetics, 9(12):757–768, 1979.

[20] Z. Zeng, A. K. H. Tung, J. Wang, J. Feng, and L. Zhou. Comparing stars: On approximating graph edit

distance. Proceedings of the VLDB Endowment, 2(1):25–36, 2009.

27

