6
1
0
2

 
r
a

 

M
1
1

 
 
]
I

N
.
s
c
[
 
 

1
v
1
0
5
3
0

.

3
0
6
1
:
v
i
X
r
a

AccConF: An Access Control Framework for Leveraging

In-Network Cached Data in ICNs

Satyajayant Misra†, Reza Tourani†, Frank Natividad†, Travis Mick†, Nahid Ebrahimi Majd‡ and Hong Huang(cid:63)

† Computer Science Department, New Mexico State University, Las Cruces, New Mexico

Email:{misra, rtourani, fnativid,tmick}@cs.nmsu.edu

‡ Computer Science Department, California State University, San Marcos, California

(cid:63) Electrical and Computer Engineering Department, New Mexico State University, Las Cruces, New Mexico

Email:{nmajd}@csusm.edu
Email:{hhuang}@nmsu.edu

Abstract—The fast-growing Internet trafﬁc is increasingly
becoming content-based and driven by mobile users, with
users more interested in data rather than its source. This has
precipitated the need for an information-centric Internet archi-
tecture. Research in information-centric networks (ICNs) have
resulted in novel architectures, e.g., CCN/NDN, DONA, and
PSIRP/PURSUIT; all agree on named data based addressing
and pervasive caching as integral design components. With
network-wide content caching, enforcement of content access
control policies become non-trivial. Each caching node in the
network needs to enforce access control policies with the help
of the content provider. This becomes inefﬁcient and prone to
unbounded latencies especially during provider outages.

In this paper, we propose an efﬁcient access control frame-
work for ICN, which allows legitimate users to access and
use the cached content directly, and does not require veriﬁca-
tion/authentication by an online provider authentication server
or the content serving router. This framework would help reduce
the impact of system down-time from server outages and re-
duce delivery latency by leveraging caching while guaranteeing
access only to legitimate users. Experimental/simulation results
demonstrate the suitability of this scheme for all users, but
particularly for mobile users, especially in terms of the security
and latency overheads.

Keywords: Information-centric networks,

sharing, authentication, caching, access control.

threshold secret

1. INTRODUCTION

The nature of the trafﬁc and the service requirements from
the Internet have changed tremendously. As per the Cisco
Visual Networking Index Forecast (2019) [6]: high bandwidth
video trafﬁc would account for 77% of the Internet trafﬁc by
2019 and mobile wireless devices will account for 77% of
the world Internet trafﬁc. This implies that the majority of the
trafﬁc on the Internet will be multimedia and emanate from
wireless mobile users. This rapid growth has also been fueled
by the use of P2P software (Ares, BitTorrent, etc.), which

This work has been submitted to IEEE Transactions on Information
Forensics and Security journal and is supported in part by the U.S. NSF
grants:1345232 and 1248109 and the U.S. DoD/ARO grant: W911NF-07-
2-0027.

Fig. 1. Multi-level network architecture for Internet-based content distri-
bution.

allows each user on the Internet to become a data server.
This phenomenon has led to the Internet users becoming
indifferent about the data source (video, music, movies) as
long as they are reasonably sure about the content. These are
alarming signs—the Internet was not engineered to scale for
such trends.

To address these concerns there has been a strong push
to redesign the Internet architecture. This push is aimed at
a shift from the host-centric Internet to the information-
centric network [15] where each data item is named and
routing is performed using the name. The ICN Internet
leverages pervasive in-network data caching and has built-
in intelligence to satisfy requests by obtaining the data from
network caches or the content provider, and transferring it to
the requester(s). Several newly proposed Information-Centric
Network (ICN) architectures, such as the CCN/NDN [15],
DONA [16], PSIRP [30], PURSUIT [11], and NetInf [7],
aim to attain the above objectives. We refer the interested
readers to a survey on Information-Centric Networks [1] for
more information.

In today’s Internet most Content Providers (CPs) use
content distribution networks (CDNs) to cache (store) content
geographically closer to the users for faster content delivery.

ISP11CDNNetflix server12CDNISP3ISP2Netflix server25CDN4CDN3CDNNetflix RepositoryTop LevelUpper LevelBottom LevelLower LevelBase StationAs shown in Fig. 1, the Internet hierarchy consists of CPs at
the top, followed by the CDNs (e.g. Akamai and Limelight),
and then the ISPs (e.g. Comcast, AT&T, and Verizon),
culminating in the static/mobile end-users. This architecture
places most of the CDN nodes at the edge of ISPs (refer
Fig. 1) to reduce the network trafﬁc; yet the ISPs keep
deploying more network resources to handle the explosive
data growth. The ICN paradigm, with its decoupling of data
from the source, will enable in-network caching by the ISPs,
reducing their network trafﬁc load and improving scalability
and data availability [33]. But, the important concern is how
to ensure that the available cached content are only usable
by authentic/legitimate users?

Let’s illustrate this concern using Netﬂix as the CP and
the CCN/NDN Internet architecture [15]. To ensure user
authenticity, in the current architecture, a legitimate user’s
Netﬂix player authenticates itself to a server hosted on a
Cloud service (e.g., Amazon EC2). Once the server authen-
ticates the user, the player/client connects to a CDN node
(selected based on network load, proximity, etc.) to access
the content. The access control (AC) is enforced by the server
and subsequently, streaming happens from the designated
CDN node.

With ICN, ubiquitous caching would require each node
that caches any portion of a content
to enforce the AC
policies; an impractical exercise. To cope with this problem,
the user still has to authenticate himself to Netﬂix. The
decryption key, for the encrypted cached content, is granted
to the user upon successful authentication. However, there is
an obvious concern; in our illustration, if the cloud service,
Amazon EC2, is down, then the Netﬂix service is down. The
user cannot authenticate himself to use the cached content.
This has occurred several times in the past. One may argue
that this service-loss can be addressed through better service-
level agreements (SLAs) with the cloud provider, but even the
best SLA cannot guarantee zero downtime. A better approach
is one that can leverage the data available in routers close to
the users, to satisfy requests from legitimate users.

This research is motivated by these observations. We
address the question: Can we design an efﬁcient AC frame-
work to utilize the cached content in ICNs that only serves
legitimate users/subscribers? In this paper, we extend our
preliminary framework to answer this question [23] (ACM
ICN Workshop, 2013) and show that our framework also
increases content availability (even when the provider’s au-
thentication service is ofﬂine) and improves clients’ quality
of experience.

In a nutshell, our contributions include: (i) Design of
AccConF a novel ICN AC framework to guarantee trusted
content in nearby caches can be efﬁciently used by only
legitimate users/subscribers. AccConF leverages broadcast
encryption and speciﬁcally targets mobile users that are at
the low-end of the devices capability/power spectrum. Our
framework also obviates the need for an “always online”

authenticator/veriﬁer. (ii) Discussions on design and imple-
mentation issues of AccConF in the popular CCN/NDN
architecture. (iii) Proof that AccConF can handle user revo-
cations limited by a large threshold t and can be augmented
to handle more than t revoked users. (iv) Implementation of
AccConF in a CCN/NDN testbed and the ndn-SIM simulator
on ns-3 and accompanying analysis validating its usability in
mobile devices.

In Section 2, we present the related work. In Section 3, we
present the basic deﬁnitions and notations, and in Section 4,
we present the system model, security assumptions, and the
threat model. We present our framework in Section 5, its ICN
speciﬁc details in Section 6, and discuss its security provi-
sions in Section 7. In Section 8, we present our experimental
results and analysis. In Section 9, we present our conclusions.

2. RELATED WORK

In CCN/NDN [15], the user’s data interest (request) is
either served by an intermediate router that receives the
interest and has the data cached or the Content Provider (CP).
Data is routed back using information stored in a router’s
pending interests table and the forwarding information base,
and is cached at each forwarding router. In DONA [16], CPs
advertise their named content, in form of P:L where P is the
hash of their public key and L is the content’s unique label,
to resolution handlers (RHs), which form an inter-domain
RH-hierarchy. A user transmits a data request with the help
of the RH-hierarchy to a data source, which then transmits
the data back along the same path. The data can be cached
in the buffer of the involved RHs along the return path. The
design paradigms of both PURSUIT and PSIRP [11] involve
three separate elements – publishers, subscribers, and the
REndezvous NEtwork (RENE) with similar naming scheme
as DONA. Rendezvous Points (RPs) in RENE perform
rendezvous action between publishers and subscribers and
select a path for a publisher/subscriber pair. Network of In-
formation (NetInf) [7] provides a service conceptually similar
to the rendezvous service in PSIRP/PURSUIT. Caching and
named data based addressing are integral facets of all these
architectures, which are also the only two pre-requisites of
our framework.

AC in the ICN has recently received more attention from
the community [2], [5], [10], [12], [14], [19], [20]. In [2],
the authors proposed a per-user privacy design in which
content chunks are mixed with chunks of cover and the
results are published into the network. The user gets the
necessary decoding information via a secure back channel
from the CP, which requires the CP to be always online.
Fotiou et al. proposed an AC enforcement delegation tech-
nique [10]. This scheme introduces the Relaying Party (RP)
and the Access Control Provider (ACP) entities, which are
responsible for storing the content and enforcing the AC
policies, respectively. The RP (a caching node) receives the
user’s request and sends a secret and the corresponding AC

policy to both the ACP and the user. The user authenticates
himself to the ACP by forwarding the received secret, the
policy, and his credentials. The ACP authenticates the user
and notiﬁes the RP to transfer data. This technique requires
interaction between each router and an ACP, which is not
scalable.

Chen [5] proposed a probabilistic encryption-based AC
which leverages symmetric/asymmetric cryptographic opera-
tions. The proposed mechanism was augmented with a Bloom
ﬁlter representing the authorized clients’ public keys; that is
used by the intermediate routers to verify a user before for-
warding the encrypted content. In [12], the authors proposed
a mechanism built upon name obfuscation and authorized
disclosure; the former prevents the unauthorized clients to
obtain the content name. The latter requires any entity, with
a copy of the content, to perform client authentication and
authorization. In this scheme, the content name is encrypted
(hashed) to prevent unauthorized access; the content is in
plaintext.

Li et al. [20] designed a light-weight signature and AC
enforcement mechanism that uses per-content tokens. Tokens
are generated and assigned by the content provider to the
network entities according to their capabilities. Legitimate
users authorize themselves to a network router by obtaining
the content’s private token(s) from the content provider and
verifying to the router that
they have the token(s). This
scheme suffers from the storage overhead of the token (three
per content) at the routers and the overhead of token synchro-
nization which undermine scalability. Also, the mechanism
does not scale in the face of user-revocation as it requires
complete re-keying at all routers.

Attribute-based AC has

also been investigated for
ICN [14], [19]. In [14] the authors proposed a sketch of the
key-policy and the ciphertext-policy based AC. In the key-
policy, the content is encrypted with a key that is derived
from the content attributes and the access policy is embedded
in the decryption key. For the ciphertext policy, the access
policy includes the authorized clients’ attributes which is used
to generate the decryption key. Li et al. [19] proposed a
ciphertext-policy scheme in which the provider encrypts the
content with a symmetric key. It then encrypts the symmetric
key with the access policy, which results in the content name.
The user ﬁrst acquires the content name from the name
publishing system. Only an authorized user can decrypt the
content’s name using his attributes to get the symmetric key.
The problem with the attribute-based systems is again lack
of support for client revocation and computation complexity.
Broadcast encryption (BE) was ﬁrst proposed by Fiat and
Naor [9] to enable a source to send encrypted data to a
set of legitimate users in the network who can decrypt the
data. The protocol was t-resilient (resilient to collusion of
up to t malicious users) with O = (t2 log2 t log n) message
transmission overhead and O = (t log t log n) key storage at
the user, where t is the revocation threshold and n is the

total number of users. In 2001, Naor et al. [25] decreased
the key storage requirement to log n. Broadcast encryption
has found use in the real-world applications. For instance,
subset difference based BE is used for AACS, HD DVD,
Pay Television, and Blu-ray disc encryption. However, these
techniques are not readily usable for secure content delivery
on power and computation constrained mobile devices.

In this paper, we extend our preliminary work [23], which
uses the public-key based traitor tracing t-resilient algorithm
proposed by Tzeng and Tzeng in [32] as a building block
to create a secure content delivery framework especially
applicable for mobile devices. Our enhanced framework
(AccConF) ensures that mobile devices need less than 4 ad-
ditional seconds at start-up on account of the BE procedures.
This guarantees that user experience is not affected adversely.
We also, propose a detailed protocol for handling |R| > t,
and address the real-world implementation challenges and
present more analysis and experimental results.

Majority of the proposed AC mechanisms in ICN either
need an entity (or a network of entities) for client authentica-
tion and/or require the intermediate routers to perform client
authentication. These assumptions, on one hand, undermine
the scalability of the system due to the additional workload of
the routers. On the other hand, they undermine the security;
in case a router decides to maliciously authenticates an unau-
thorized client. Different from prior work, in AccConF, there
is no entity for AC enforcement; the intermediate routers
only forward an extra content (enabling block), which is
much smaller than the original content. In the event of client
revocation, our framework only incurs a minor updating cost
as opposed to the proposed mechanisms, which invariably
require system re-keying.

3. BASIC DEFINITIONS AND NOTATIONS

From here on, we denote the content provider as CP , the
content distribution network as CDN, a CDN node i as CNi,
the Internet Service Provider as ISP . In our framework, the
CP and its servers are essentially the same as they perform the
same tasks, so we use the terms server and CP interchange-
ably. A user ui’s public/private key pair for asymmetric
encryption/decryption is denoted as < Pi, P ri > and the
CP’s corresponding key pair is denoted as < PS , P rS >.
Now we deﬁne some key concepts used in the paper (please
refer to [22] for details).

Deﬁnition 3.1: [Broadcast Encryption] Broadcast en-
cryption is deﬁned as a mechanism where a CP can se-
curely broadcast content to a set of legitimate users U =
{u1, u2, . . . , un}, such that each ui ∈ U can decrypt the
content using his private key (or share).

2
Deﬁnition 3.2: [Shamir’s (t + 1, n)-threshold Secret
Sharing Scheme] In this secret sharing, a secret is shared
between n users in a way that at least (t + 1) ≤ n users have
to combine their shares to obtain the secret. No combination
of users less than t + 1 (t + 1 is termed the threshold),

[26]

can decipher the secret. This scheme is implemented with
the help of a one-dimensional t-degree polynomial pt(x) =
a0 + a1x + a2x2 + . . . + atxt, which can be uniquely
determined using any t + 1 points on the polynomial. A user
ui’s share is given by (xi, f (xi)), where xi is a point on
the X-axis and f (xi) = pt(xi). In Shamir’s secret sharing
scheme, generally the secret is the term a0 in the polynomial.
2

Deﬁnition 3.3: [Lagrangian Interpolation Polynomial]
A Lagrange’s polynomial of degree n taking on the values
f (x0), . . . , f (xn) for the points x0, . . . , xn is given by,

Ln(x) = f (x0)

(x − x1)(x − x2) . . . (x − xn)
(x0 − x1)(x0 − x2) . . . (x0 − xn)

+

f (x1)

(x − x0)(x − x2) . . . (x − xn)
(x1 − x0)(x1 − x2) . . . (x1 − xn)

+ . . . +

f (xn)

(x − x0)(x − x1) . . . (x − xn−1)
(xn − x0)(xn − x1) . . . (xn − xn−1)

.

xj

Note that the secret a0 in Shamir’s secret sharing scheme
can be obtained as a0 = Ln(0). In this paper, we denote the
ith fractional term (also called the Lagrangian coefﬁcient) in
resulting in a0 = Ln(0) =
Ln(0) as, λi = Π0≤j((cid:54)=i)≤n
f (x0)λ0 + f (x1)λ1 + . . . + f (xn)λn.
2
With Shamir’s secret sharing, when t + 1 users combine their
shares, they can obtain a unique interpolating polynomial us-
ing well-known techniques, such as Lagrangian interpolation.
The Lagrangian interpolation method uses the Lagrangian
Interpolation Polynomial to interpolate pt(x).

xj−xi

Difﬁe-Hellman

Deﬁnition 3.4: [Decisional

(DDH)
Problem] Let G denote a multiplicative ﬁnite cyclic
group of order Q (a large prime number), and g be a
generator of G, then given two distributions (gx, gy, gxy)
and (gx, gy, gz), where x, y, z ∈ ZQ (Z \ QZ), the set of
non-negative integers truncated by Q, and are chosen at
random, can the two distributions be distinguished? This
DDH problem is widely assumed to be intractable [22]. 2
Deﬁnition 3.5: [Schnorr Group] Given two large primes
Q and P , where P = rQ + 1, r ∈ Z∗
Q is the
multiplicative group of integers mod Q, choose 1 < h < P ,
such that hr (cid:54)≡ 1 mod P , then g = hr generates a Schnorr
group, which is a subgroup of Z∗
P , the multiplicative group
of integers mod P of order Q. [29]
2
We use the Schnorr group for our framework. In cryptogra-
phy, such prime-order subgroups are desirable as the modulus
is as small as possible relative to Q.

Q, where Z∗

4. SYSTEM AND THREAT MODELS AND ASSUMPTIONS
In this section, we present the system model, our security
assumptions, and possible security threats to our framework.
A. System Model

As the next generation Internet architecture is a notion that
is constantly in ﬂux, we model AccConF to be adaptable.
The setup is hierarchical as shown in Fig. 1, where the CPs

(or their servers) form the top level of the network. The
servers may be synchronized to have the same global image
of the user base or be distributed, serving non-overlapping
user groups, while still having access to the central content
repository. The content is pushed onto the CDN nodes–the
next (upper) level of the system hierarchy–to transmit the
data to the users connected to the ISPs. The next (lower)
level consists of ISPs, which cache the packets and forward
the data to the users (bottom level).

For illustrating our framework and experimentation, we
use the CCN/NDN architecture [15], and its code-base [17].
However, with all ICN architectures sharing the same premise
of caching and name based routing our framework will apply
to all. In our framework, Q and P = 2Q + 1 are large prime
numbers, n is the number of users in the system, t is the
number of users that can be revoked without affecting system
performance; and given that all polynomial operations happen
Q, n has to satisfy the condition n ≤ Q − t − 1. A ﬁrst-
in Z∗
time user registers with the CP to get his credentials and can
obtain data from proximal nodes or the CP.

B. Set-up and Security Assumptions

We assume that the content is encrypted by the content
provider using a secure symmetric key encryption algorithm,
such as AES [22]. A content or a group of contents (set
of movies) may be encrypted using the same secret key–a
legitimate user can decrypt the set of contents after suc-
cessfully extracting the key. Different secret keys can be
used by the provider to encrypt different contents or groups
of contents; this allows the provider to deﬁne diverse AC
policies. Our framework’s objective is to ensure that the
content is encrypted and cannot be used by an entity that
is not a legitimate user/client (not even CDN/ISP nodes).

We also assume that a legitimate user’s front-end player
does not store the symmetric key after decrypting the content,
and that a user cannot tamper the player, which performs
the decryption. Most content providers (Netﬂix, DirectTV,
Comcast) have a player (set-top box, a standalone or em-
bedded player), which performs the task of decryption of
the content and these players are not easily tamperable.
Without this assumption, no known encryption scheme can
be used for security. We assume that
the user does not
use VPN tunneling or other location-cloaking mechanisms,
such as the Tor network [31], to hide their location. In the
rest of the paper, we use the term user and client to refer
interchangeably to the user’s mobile device.

C. Threat Model

In a set-up for content delivery, data security is of ut-
most importance. The use of symmetric key infrastructure,
public key infrastructure, and our framework guarantees data
security. However, there are several other attack scenarios.
For instance, an attacker could ﬂood the network with fake
interests (new or replayed interests), thus orchestrating a

denial of service (DoS) attack. An adversary can pollute
the routers’ caches by sending out unpopular requests [34].
Trafﬁc analysis attack can be performed on a speciﬁc user
to identify his content access pattern. A compromised or
colluding user’s keying materials can be extracted and used
by an adversary, not part of the system, to gain access to the
content by impersonation. The extracted keying materials can
be used by an adversary to mount a Sybil attack [8]. Also,
few revoked users (popularly termed as traitors) can collude
to generate a key for a malicious user (pirate), not part of
the system, to decode the content. Additionally, there are
standard attacks by an adversary, such as chosen plaintext
attack (CPA), chosen ciphertext attack (CCA), and adaptive
chosen ciphertext attack (A-CCA) [22], [32].

By virtue of the information-centric paradigm, our frame-
work, can address most of the threats mentioned. For in-
stance,
the use of the sequence numbers in the interest
and data packets, and caching at the edge routers can help
neutralize replay attacks. Aggregation of interest packets and
controlling interest rates will mitigate DoS attacks. Note that
neither the NDN architecture nor our framework require the
users to identify themselves to the communicating hosts nor
in the interest packets. This ensures identity privacy, unless
of course, the routers in the user’s neighborhood collude
to identify him. Cache pollution attacks has already been
addressed satisfactorily [34]. After proposing our framework,
we will discuss its security against Sybil, collusion, and the
CPA, CCA, and A-CCA attacks.

5. ACCCONF: FRAMEWORK FOR HIGH AVAILABILITY

AND EFFICIENCY IN SECURE CONTENT DELIVERY

Now, we present our framework, which helps perform the
following for AC in an ICN: (i) Allows ISPs to cache the
content packets at their edge-routers enabling requests for
same data to be served from the cache. (ii) Increases the
availability of the content to users by not requiring an initial
authentication by an online server. (iii) Ensures that only
legitimate users can use the content, according to the content
access policy, and no revoked user can use the contents. The
protocols in our framework are either implemented at the top
or the bottom levels of the system hierarchy (Fig. 1). There
are several BE schemes in the literature [9], [25], [32] and
our framework is generic enough to use any BE scheme,
which can account for user revocation. However, for ease of
illustration in this paper, we use a BE scheme proposed by
Tzeng and Tzeng [32], which is a variant of Shamir’s secret
sharing scheme (Deﬁnition 3.2).

In [32], the threshold t+1 of Shamir’s scheme helps deﬁne
a revocation threshold of t–the threshold for the number
of user revocations permitted without affecting data secrecy.
Congruently, we assume n legitimate users in the system and
the number of revoked users (|R|) to be at most t (<< n);
we also propose an enhancement to handle |R| > t. The
BE scheme proposed by Tzeng and Tzeng was proved by

TABLE I

NOTATIONS USED

Q

Description
Big prime numbers such that P = 2Q + 1
Multiplicative groups of integers of order Q
and P respectively
Cyclic groups of order Q and P respectively
Generator of a sub-group of GP of order Q
Random number generator in Z∗
Constant of pt(x)
Degree of polynomial pt(x) and the revoca-
tion threshold
Set of revoked users, |R| ≤ t
Total number of legitimate users
Secret (Symmetric) key for data encryption
Tuple of user ui
Tuple of revoked user ur
Concatenation operator
One-dimensional t-degree polynomial
Evaluation of coordinate xi on pt(x) ∈ Z∗
Server’s share (Protocol 1)
Transformed server’s share (Protocol 2)
Enabling block
Encrypted symmetric key τ
Set of partial Lagrangian coefﬁcients
Secret (Symmetric) key composed of smaller
keys concatenation
kth Lagrangian coefﬁcient
kth partial Lagrangian coefﬁcient

Q

Notation
P , Q
Z∗
Q, Z∗
GQ, GP

P

g

ZQrand()

a0
t
R
n
τ

Ti = (xi, f (xi))
Tr = (xr, f (xr))

||

pt(x)
f (xi)

E
Ee
SC
γ
Λ
Υ

λk
ˆλk

them to be as hard as the DDH problem [32]. We augment
the proposed BE scheme to allow accurate and efﬁcient
encryption of the content, and to ensure that contents can
only be used by legitimate users, but not by the revoked
users. Table I presents the notations used to describe our
framework.

A. Overview of AccConF

Our framework consists of three major steps: The ﬁrst two
steps are performed at the server and are related to encrypting
τ, the symmetric key for data encryption; only the last step is
formed at the client. In the ﬁrst step, the server generates a
polynomial of degree t and evaluates n+t (>> t) number of
points on it. The server distributes n of the evaluated points
among the n clients, one to each legitimate client, while it
keeps t of the remaining as its own shares. In the second
step, the server generates the enabling block – an essential
metadata block, which contains the encrypted τ, and is used
by a client in the last step to extract τ. The enabling block
is forwarded to the routers similarly as content chunks and
forms an integral part of the content. In the third step, a
legitimate client extracts the encrypted τ from the enabling
block by using his share.

B. Basic Protocols

We use a server S to illustrate the computations at the
server(s) or the CP. The server S generates the polynomial
pt(x) and calculates the tuple Ti = (xi, f (xi)) for each
legitimate user ui. Where it does not create confusion, in the
context of the users, we use share and tuple interchangeably.

In what follows, we use index i to represent the users’ shares
and index j to represent the server shares.

1) Polynomial and Shares Generation: Protocol 1
presents the procedure for generation of the polynomial pt(x)
of degree t. In Line 1, the server generates the t + 1 coefﬁ-
cients of pt(x). It then generates its shares by identifying t

Protocol 1 Generation of Polynomial/User Shares at the
Server
Input: Values of n < Q and t, a prime number Q,

ZQrand().

Output: Generates a polynomial pt(x) with random coefﬁ-

cients a0, . . . , at and the tuple Tj for each user uj.

1: Calculates ai = ZQrand(), i = 0 to t.
2: Generates pt(x) using the ais.
3: Calculates xj = ZQrand(), j = 0 to t − 1 and
(cid:54)= xk, 0 ≤ j, k ≤ t − 1. {Ensures xjs are positive,

xj
unique, and not reused for clients}

4: Calculates f (xj) = pt(xj) ∈ Z∗
5: Obtains E = E∪(xj, f (xj)), j = 0 to t−1. {Calculation

Q, j = 0 to t − 1.

of each legitimate client’s share follows.}

xi

(cid:54)= xk, 0 ≤ i, k < n + t.

6: Calculates xi = ZQrand(), i = t to n + t, and
7: Calculates f (xi) = pt(xi) ∈ Z∗
8: Stores values Ti = (xi, f (xi)). {Tuple of user ui}

Q, i = t to n + t.

random points (Lines 3-5) on pt(x) and the n clients’ shares
using n other points (Lines 6-7). The dissemination of the
users’ share happens through the User Registration Protocol
(Protocol 3). The CP encrypts the content using a shared
symmetric key τ ∈ Z∗
Q. A bigger key (say 128-bit AES key)
can also be handled; we will discuss this in Protocol 2.

Protocol 2 Generation and Encryption of Enabling Block

Q and τ gra0 ∈ Z∗

secret key τ ∈ Z∗
Q.

Server’s share E, ZQrand(), g ∈ GQ, a0, data

Input:
Output: Enabling Block SC
1: Calculates r = ZQrand().
2: Obtains γ = τ gra0. {ra0 ∈ Z∗
3: Calculates gr ∈ Z∗
P .
4: Calculates partial Lagrangian coefﬁcients Λ = {ˆλk |
5: Calculates Ee = {(cid:104)xj, grf (xj )(cid:105)|(xj, f (xj)) ∈ E} for the
6: SC = (cid:104)γ, gr, Λ, Ee(cid:105)
7: Generates a timeout value (T O) for SC.
8: Sign SC using the private key (P rS) of the server.

Q }.
ts server shares and rf (xj) ∈ Z∗

Q and grf (xj ) ∈ Z∗
P .

ˆλk =(cid:81)

0≤j(cid:54)=k<t

∈ Z∗

xj−xk

P .}

xj

2) Generation and Encryption of Enabling Block:

Protocol 2 deals with the generation of the enabling block,
which enables the legitimate user to extract the secret key τ,
and is delivered to the user as one of the ﬁrst content packets.

By generating a random number (Line 1), the server obtains
the encrypted secret key (γ) using the ﬁeld generator (g),
polynomial constant (a0), and the secret encryption key (τ)
in Line 2. Line 3 shows the transformation of the group gen-
erator, g, by an exponentiation operation with the generated
random number r. In Line 4, the server calculates Λ (partial
Lagrangian coefﬁcients), this precomputed Λ is used at the
client for calculating the complete Lagrangian coefﬁcients
needed for decryption. As we will show in Section 8 by com-
paring our framework (Global) with the standard approach in
literature (GlobalNP), this partial precomputation step helps
reduce the decryption time at the client tremendously. Thus,
our framework is computation-heavy at the server side, which
result in lightweight computations at the clients.
In Line 5, the server calculates the transformed enabling
block, obtained by raising g to the power of rf (xj) ∀f (xj) ∈
E. In Line 6, the server puts together the enabling block
SC. We will discuss the need for timeout (Line 7) and
how to decide a value for T O in the next subsection.
The enabling block SC is signed by the server (Line 8)
to guarantee provenance. A bigger key (say 128-bit key
for AES) can be used by splitting the bigger key Υ into
smaller sub-keys Υ = {τ1|| . . .||τb|| . . .||τm}, where each
τb ∈ Z∗
Q and instead of sending γ, the server can send
{γ1 = τ1gra0, . . . , γm = τmgra0}. The user will combine
the split keys to regenerate Υ. This protocol’s O(t) modular
exponentiations dominate its running time.

Protocol 3 User ui’s Registration
Input: User’s registration credentials.
1: User ui creates a veriﬁable proﬁle and successfully enters

the system.

2: Server securely transmits the user its public key, PS, its
digital certiﬁcate, the user’s share (xi, f (xi)), and the
expiration time (TO) of the share.

3) New User Registration: Protocol 3 deals with registra-
tion of a new user in our framework. For registration, a user
ui sends a registration interest to the CP. The format for the
user’s name is: /N etf lix/Registration/U nique
U ser ID. This interest contains ui’s other credentials,
encrypted with PS and signed by P ri (ui’s private key).
The CP then replies to ui with a data packet containing
ui’s unique valid share encrypted with Pi. The reply is
unicast from the CP to ui and is not cached at intermediate
routers. Even if the data is cached by a malicious router
communication secrecy cannot be undermined.

4) Secret Extraction at the User: Protocol 4 presents the
procedure used by ui to extract the secret key (τ) needs
to decrypt the content. User ui veriﬁes the signature of SC
(Line 1) that he has obtained along with the content. As per
Deﬁnition 3.3, the kth Lagrangian coefﬁcient λk is deﬁned
, where 0 ≤ j, k ≤ t − 1 represent the
indices of the server shares and are in SC; the tth fraction is

as (cid:81)

0≤j(cid:54)=k≤t

xj−xk

xj

xi obtained from user ui. The server precomputed Λ (part of
SC) is used to obtain complete Lagrangian coefﬁcients, thus
reducing the computation time at the client signiﬁcantly. User
), to obtain the kth
ui simply calculates the last term ( xi
Lagrangian coefﬁcient by performing only one multiplication
(λk = ˆλk ·( xi
)), instead of t multiplications (in Line 2).
xi−xk
This precomputation enables the framework’s use in mobile
devices.

xi−xk

The following steps obtain the parameters used for the
decryption. Line 3 calculates δ1–the multiplication of the
shares (grf (xk),∀f (xk) ∈ Ee) in SC raised to their corre-
sponding Lagrangian coefﬁcients (λk). The client calculates
the Lagrangian coefﬁcient of his share in Line 4 and derives
δ2 through the same procedure as Line 3 (in Line 5). With δ1,
δ2 and the encrypted symmetric key γ, in Line 6 the client
calculates the secret τ. If the secret is Υ (a bigger key),
then it can be obtained by a minor extension to Protocol 4:
in Line 6, instead of calculating just τ, the user calculates
{τ1, . . . , τb, . . . , τm}, using the same operations, but using
{γ1, . . . , γb, . . . , γm}, to recreate Υ = {τ1|| . . .||τm}. Once
the user ui extracts τ, then she can decrypt the content. This
protocol requires O(t) modular exponentiations–again, the
bulk of the running time. We detail the effects of different
values of t in the next section.
Theorem 5.1: A legitimate user ui can use the enabling
block SC and his own tuple (xi, f (xi)) and correctly decrypt
(cid:3)
the secret key τ using Protocol 4.
Proof: Note that the constant term of the polynomial
pt(x) can be calculated using Ln(0), a0 = Ln(0) =
f (x0)λ0 + f (x1)λ1 + . . . + f (xt)λt, where the Lagrangian
as per Deﬁnition 3.3.
k=0(f (xk)· λk), where r is a large
random number. By virtue of the fact that g is the generator
of the Schnorr group (subgroup of Z∗
P ) of order Q, the next
few steps follow.

coefﬁcient λk = (cid:81)
Consequently, ra0 = r(cid:80)t

t−1(cid:89)
= gr(cid:80)t−1
= gr[(f (x0)λ0)+(f (x1)λ1)+···+f (xt−1)λt−1+(f (xi)λi)]
Hence, τ · gra0/{(cid:81)t−1
= gra0

k=0(grf (xk))λk · (gr)f (xi)λi} = τ and the

(grf (xk))λk · (gr)f (xi)λi (Lines 3&5 Protocol 4.)

k=0(f (xk)·λk) · grf (xi)λi

δ1 ∗ δ2 =

0≤j(cid:54)=k≤t

xj−xk

k=0

xj

user can obtain the secret key.

6. ICN-SPECIFIC DETAILS OF ACCCONF

We now discuss the compatibility of

the framework
with popular ICN architectures. In publish-subscribe based
schemes, such as PURSUIT [11], [30] and NetInf [7], the
content’s meta-information (number of packets, encoding,
etc.) are published by the CP, whereas, in CCN/NDN or
DONA, this information can be elicited by an interest packet
sent to the network or the resolution handlers respectively.

SC and Ti, the share of ui

Protocol 4 Secret Extraction by User ui
Input:
Output: Secret key τ for data decryption
1: Veriﬁes the signature of SC using PS.
2: Calculates Lagrangian coefﬁcient

λk = ˆλk ·( xi
xi−xk
and grf (xk) ∈ Ee contained in SC.

3: Calculates δ1 =(cid:81)
(cid:81)

4: Calculates

Lagrangian

its

xj

∈ Z∗

Q, where xi

0≤j<t

xj−xi

Ti.
P , and gr ∈ SC.
Z∗

6: Extracts secret key τ = γ

δ1∗δ2

.

) ∈ Z∗
Q,
0≤k≤t−1(grf (xk))λk, where δ1 ∈ Z∗

(∀ˆλk ∈ Λ)

P

5: Calculates δ2 = (gr)f (xi)λi, where f (xi)λi ∈ Z∗

coefﬁcient

λi

=
is obtained from
Q, δ2 ∈

Our framework requires no extra messages or complexity
in the network to leverage data-naming and caching. It can
be implemented at every node in the network, including the
rendezvous nodes in PURSUIT and the resolution handlers in
DONA. Below we discuss the speciﬁc design details of our
framework from the perspective of the popular CCN/NDN
architecture.

Fig. 2. Our naming scheme for the enabling block and content chunks.

A. Data Chunking and Packet Naming

Naming:

1) Chunk Creation: Large contents are broken down into
smaller data packets (chunks); each chunk is named uniquely
and requested by its corresponding interest. Fig. 2 illustrates
the splitting of the content and the enabling block. Both are
split into equal sized chunks and given appropriate names for
distinction.
2) Packet

the
hier-
follow
CCN/NDN
archical
of
name
is
(ref. Fig.
chunk
/Netﬂix.com/movie/category/movieName/V3/x.avi.
The
ﬁrst segment is the CP’s name, next (“movie”) is the content
type, followed by the category, e.g, Sci-Fi or Comedy, the
fourth is the content name (Star Wars),
the ﬁfth is the
version (V3), and the last part (x.avi) represents the chunk
number. Versioning enables coexistence of different content
qualities and expiry of content.

naming
2). A typical

convention

content

We

NameSignaturePayloadExpiry timeSignaturePayloadNameExpiry time. . .. . .110 [last]003002001 [first]002.avi003.aviContent ObjectEnabling Block1000.avi [last]Name of chunk x :Name of chunk x :/Netflix.com/service/group/EnablingBlock/V1/001.avi [first]x.avi/Netflix.com/video/category/moviename/V3/xThe enabling block naming follows the same convention
but with the replacement of data type with the service type
(premium, standard, plus). The category segment is replaced
by the group with same intention–help group different users
under the same service. Two types of numbering scheme can
be used: sequential and random.
Sequential Numbering: In this scheme, each content chunk
has a sequence number x ∈ {001, 002, . . .}, with increas-
ing value of x. This scheme is easy to implement, but
enables cache probing and trafﬁc analysis attack at
the
router/proxy [18].
the value of
Random Numbering: In random numbering,
is known to the client; however,
x for the ﬁrst packet
each subsequent packet has a random x value. Each chunk
carries the sequence number of the next interest to be used.
This helps negate trafﬁc analysis attack but, may undermine
aggregation of chunks.

B. Protocols to Handle System Dynamics

Our framework has to address several system dynamics.
For instance, (i) what to do when a registered user discontin-
ues the service and needs to be revoked? (ii) What happens
when the number of revoked users reaches the threshold t?
(iii) What happens when a new user arrives and the system
is at its capacity? We detail how these events are handled.
1) Revocation of a User ur: When a user ur has to be
revoked, the server replaces one of its t tuples in SC with
Tr = (xr, f (xr)), ur’s tuple. Hence in Line 5 of Protocol 2,
one of the (cid:104)xj, grf (xj )(cid:105) has to be replaced with (cid:104)xr, grf (xr)(cid:105),
thus changing SC to S(cid:48)
C. Several concerns that need to be
addressed on this front are: (a) A high rate of revocation
would require a new S(cid:48)
C to be disseminated in the network
with every revocation. Hence, the enabling block should be
a small overhead and should be named in a way that allows
differentiation between multiple versions in the network. (b)
The new S(cid:48)
C has to be refreshed everywhere data exists, so
that the revoked user cannot access the content.
In Section 8, using implementation results we show that
the size of SC is much smaller than the content size (< 1%).
Also if one key is used to encrypt several contents (e.g.,
movies), the amortized cost over all related contents can be
made negligible. Thus (a) can be addressed. We believe (b) is
more difﬁcult to address and attempt some possible solutions.
Lazy Update – Refreshing Enabling Block through
Timeout: One way to address (b) is to have a small timeout
value (T O) for SC, which is inversely proportional to the
turnover rate (ζ(n)) of users in the system, i.e., T O ∝
1/ζ(n). The turnover rate is the ratio of the revoked users
to all users, per unit of time. This will enforce a small time
window in which a revoked user can access the data, after
which the routers caching the enabling block will expunge
it. Any subsequent request for contents would require a fetch
of the latest/updated enabling block.

Proactive Update – Enabling Block refreshed by the
CP: Another approach is the CP pushing the enabling block
network-wide. Given that the number of users could be as
several million spread across the globe, and that the data is
cached at several hundred ISPs, this may not be very easy to
accomplish. The challenges notwithstanding, such a proactive
approach may be feasible with close interactions between the
CP, the CDNs, and the ISPs.

Proactive Update – Refreshing Enabling Block through
Clustering: An improved approach is to partition the network
into independent clusters with number of users n(cid:48) < n, where
the clustering is motivated by access policies, geographical
distribution, or cluster size. Each cluster Ci has a cluster head
(CH), which may be a CDN node or an ISP node, designated
by the CP. Each Ci, uses a different polynomial pi
t(cid:48)(x), and
given that n(cid:48) could be smaller than n, the threshold t(cid:48) can
also be smaller than t. The enabling block may be generated
at the CH or at the CP. In the event of a user revocation,
now there is need for only a local update of the local S i
C
corresponding to the cluster Ci. Updating the routers within
the cluster during user revocation becomes much easier. The
use of the smaller t(cid:48) instead of t will also speed-up the user’s
extraction procedure. A combination of the timeout and the
clustering mechanisms may work better than either.

2) Number of Revoked Users Close to or Greater than t:

There are two approaches to address this concern:
Proactive Approach: The CP can re-key the whole system
with a new polynomial, and treat the already revoked users
as non-existent; in essence re-initializing the system. This
procedure can be performed when the number of revoked
users gets close to t.
Reactive Approach: Let’s consider the case where the number
of revoked users |R| = at + p << n, where a > 0 and
p < t. Let’s assume that the key Υ is 128-bits. As we
mentioned in Section 5.B.2, the server splits Υ into m pieces,
{τ1, . . . , τm}. To ensure that revoked users cannot obtain Υ,
we can update Protocols 2 and 4 by choosing t revoked users
for each τi ∈ Υ from at + p revoked users, such that each
revoked user ur’s share is in the server share for at least
one τi. Then ur cannot decrypt one or more τis and hence
Υ correctly. This can extend the scheme beyond t revoked
users.

C. System Reaches User Capacity

The system reaches user capacity when n + t = Z∗

Q. At
that point, no new users can be added. All xs are allocated to
users, no new unique user share can be created. There is some
scope for reuse of the tuples, with the initial revoked users’
tuples replaced in the server’s share. However, eventually the
whole system has to be reinitialized with new prime numbers
Q(cid:48)(>> Q) and P (cid:48) = 2Q(cid:48) + 1, polynomial, and user tuples
and distribution of the new user tuples and enabling blocks.
However, we note that this would happen rarely.

7. A DISCUSSION ON SECURITY PROVISIONS IN

ACCCONF

The security concerns in our framework include Sybil
attacks, collusion attacks, and the other well-known attacks,
such as CPA, CCA, and A-CCA. We will discuss how the
framework can address these concerns. Unfortunately, in an
ICN architecture, where routing is based on named data
rather than hosts identiﬁers,
there is no way to stop an
impersonation attack or a Sybil attack. This is because, if
a legitimate user is colluding with an impersonating user
(sharing keys, passwords, etc.), then the impersonator has
the keying materials of the legitimate node and can decrypt
received content. The Sybil attack also follows similar rea-
soning. As pointed out by Douceur [8], it is difﬁcult to handle
such attacks without a central veriﬁcation entity.

A possible way to identify an impersonating/Sybil node is
by the server/CP requiring the user’s player to periodically
verify its credentials to the server. The veriﬁcation procedure
can involve the CDN node and/or the ISP. Approximate
location information obtained during these veriﬁcations (from
CDN/ISP) can help estimate the user’s geographic location
(lower the entity in the hierarchy, the ﬁner the localization).
A user appearing at multiple locations simultaneously or over
a short time span may be part of a Sybil or impersonation
attack, and can be revoked. The clustering approach can
further limit the impact of the attack. If each cluster uses a
different polynomial, then a Sybil attacker using credentials
of a user in a different cluster cannot decrypt the data.

A set of colluding nodes can create a new share for a
new malicious (illegitimate) node, however this requires at
least t + 1 malicious/revoked nodes to collude, armed with
the knowledge of Q or P , so that they can re-generate the
polynomial using their shares. With t + 1 being of the order
of thousands (or millions), this is unlikely. Note that the
enabling block sent by the server cannot be used to obtain
the legitimate shares as it is as hard as the DDH problem.
For addressing the other attacks, such as CPA, CCA, and A-
CCA, we refer the readers to [32] – the proofs are similar
and we omit them here for brevity.

Privacy of the users in an ICN is an important issue,
with several privacy threats identiﬁed in the literature [4],
[18]. The most likely privacy threat is that of cache access
monitoring, where an attacker connected to the same router
as ui monitors the cache accesses of ui to track his behavior.
Even though in ICN, especially NDN, user’s identity is
not present in the packet, an attacker can leverage partial
knowledge about the user (e.g., ui is interested in Sci-Fi
movies) and the interest name to conjecture ui’s identity.
This problem is being studied by researchers [24] and is not
in scope for this paper. We note that if the secret key (τ)
is compromised, by means of some attack (a probable event
in any secure system), it would require the content to be
encrypted with a new key (τ(cid:48)). Then the enabling block will
also need to be updated according to the new key.

(a) Polynomial and Users Share Gen-
eration time (global)

(b) Polynomial and Users Share Gen-
eration time

(c) Enabling Block Size

(d) Symmetric Key Extraction

Fig. 3. Results from Protocols Implementation: (a) Time taken to generate
pt(x), 5K ≤ t ≤ 40K (global) and the user shares; (b) Comparison of
time taken to generate pt(x), 5K ≤ t ≤ 40K and user shares in the global
and two clustered scenarios (5K ≤ t(cid:48)(= t) ≤ 40K and 0.5K ≤ t(cid:48)(=
t/10) ≤ 4.0K respectively); (c) Size of the enabling block for the global
and the clustered scenarios (t(cid:48) = t; t(cid:48) = t/10); (d) Time required for secret
key extraction in the global and the clustered scenarios (t(cid:48) = t; t(cid:48) = t/10).

8. IMPLEMENTATION RESULTS AND ANALYSES

Our implementation results are categorized into three
segments: (a) experiments for performance analysis of our
protocols with different settings; (b) experiments to assess
the cost incurred for providing security (in terms of time)
using AccConF over NDN; and (c) results from simulation
using ndn-SIM on ns-3. Our experiments were implemented
on servers, laptops, and Nexus 5 smartphones. All these
nodes were a part of a CCNx-0.7 [17] testbed. For the ﬁrst
segment, on the laptop, we implemented our protocols in
C (gcc version 4.5.2) and used the GNU Multi-Precision
Arithmetic (GMP) library [13] for cryptographic operations.
On the smartphones we used Android OS version 5.0.0 (Lol-
lipop) and implemented the application using the Java based
Android SDK API-19 (rev. 22.3) Kit Kat and NDK (rev.
9c). Our mobile version was multithreaded and it decrypted
the downloaded secret key τ concurrently while receiving
content-chunks.

We implemented the Polynomial Generation protocol (Pro-
tocol 1),
the Enabling Block Generation and Encryption
protocol (Protocol 2), and the Extraction protocol (Proto-
col 4). The straightforward user registration protocol was
not
implemented. In our implementation, for the global
scenario, the total number of users ranged from 1M to 20M
in increments of 5M, and the value of t ranged from 5K
to 40K in increments of 5K, where M and K stand for
million and thousand respectively. We chose n ≤ 20M to
represent the dynamic user base of a CP such as Netﬂix
(by current estimates Netﬂix has ≈ 45M users) [27]. For
the clustered scenario, there were 10 clusters, each having

510152025303540024681012Polynomial Degree (in thousand)Time (thousands of seconds)1 Million5 Million10 Million15 Million20 Million0.5/51/101.5/152/202.5/253/303.5/354/40024681012Polynomial Degree (in thousand)Time (thousands of seconds)Clustered (t’=t/10)Clustered (t’=t)Global (t)0.5/51/101.5/152/202.5/253/303.5/354/400100200300400500Polynomial Degree (in thousand)Size (kB)Clustered (t’=t/10)Global−NPGlobal0.5/5K1/10K1.5/15K2/20K2.5/25K3/30K3.5/35K4/40K020406080100120140160180Polynomial DegreeTime (in second)Global LaptopGlobal SmartphoneClusteredGlobal−NP2M users; we assumed two sets of revocation thresholds (t(cid:48)):
t(cid:48) = t (as in global) and t(cid:48) = t/10, which ranged from
0.5K to 4K in increments of 0.5K. Protocols 1 and 2, were
run on a server class machine with 24 Intel Xeon 2.40 GHz
processors and 50 GB RAM. Only one processor was used
in our experimental result. Results were averaged over 100
runs.

Fig. 3 displays the results for polynomial and enabling
block generations and key extraction. Fig. 3(a) shows the time
taken to generate polynomials of different degrees, consisting
of generating random coefﬁcients ({a0, . . . , at}) for the poly-
nomial (pt(x)), and then evaluating pt(x) at n+t points. The
X-axis represents different polynomial degrees (equivalent
to t) and the Y -axis represents the time in thousands of
seconds. The polynomial generation procedure is the most
time consuming component of our framework, however, it is
executed by the server only and can be performed ofﬂine and
in parallel by several processors. We note that the increase
in running time with increasing t (for different values of n)
is attributable not only to the polynomial degree but also
the number of users. The running time scales linearly—the
generation time for 20M users is 20 times more than that for
1M users (t being the same).
Fig. 3(b) shows a comparison between the two clustered
scenarios (t(cid:48) = t and t(cid:48) = t/10) and the global scenario on
the basis of the polynomial generation time. When t(cid:48) = t, as
expected, the time taken is the same. For the t(cid:48) = t/10 case,
running time for one polynomial generation is obviously go-
ing to be small. Interestingly, the running time for generating
the ten polynomials of degree t(cid:48) is much less than generating
a polynomial of degree t.
Fig. 3(c) shows the size of the enabling block SC in
the clustered scenario t(cid:48) = t/10 and two different global
scenarios: one in which AccConF is used, thus the par-
tial Lagrangian coefﬁcients are precomputed at the server
(Protocol 2), denoted as Global, and the other in which
no precomputation is performed at the server, denoted as
GlobalNP. The X-axis represents the polynomial degree (t)
and the Y-axis represents size in KiloBytes. The size of
SC is independent of the number of members; it increases
proportionally with t. The worst case size is in Global
≈ 470kB, for t = 40K. Even then, given that a standard
two-hour Netﬂix movie on a mobile device has a size of
around 300 MB [21], the enabling block makes-up less than
0.16% of the movie! For the reactive approach, to handle the
case where the number of revoked user |R| > t, the size of
the enabling block will increase. Even if we create a share for
every byte of a 128-bit secret key (allows 16· t revocations),
the enabling block size is 7.52MB–only a 2.5% overhead.

The extra precomputed information at the server results in
the enabling block in Global to be signiﬁcantly more than that
of GlobalNP (around 50% for t = 40K). However, as shown
in Fig. 3(d), the corresponding reduction in extraction time at
the client due to the precomputation (Global) is signiﬁcant–

STATISTICS FOR LARGE VALUES OF t RELATED TO EXTRACTION OF τ

TABLE II

1

1.34
10.65

0.5
0.71
5.92

6
70

0.7
1.03
7.44
8.4
96

0.1
0.14
1.16
1.2
12

0.3
0.46
3.68
3.6
40

t (in million)
Laptop Extraction Time (secs)
Smartphone Ext. Time (secs)
Enabling Block Size (MB)
12
Smartphone RAM Usage (MB)
143
less than 1 second for both the laptop and smartphone
versions. The key extraction time in GlobalNP grows super-
linearly with increasing t. The laptop client was running on
an Apple Macbook Pro running VMware, allocated 1 GB
RAM and one 2.5 GHz, Intel Core i5 processor. The smart-
phone was a Nexus 5, 2.3 GHz quad core, 2 GB smartphone.
As a demonstration of the framework’s scalability, es-
pecially from the perspective of the expensive extraction
protocol, we obtained statistics for higher values of t as
shown in Table II. Even when t is 1 million, the enabling
block is only 12 MB (1.2% of a standard Netﬂix movie [27])
and the corresponding extraction of τ takes 1.34 seconds
on the laptop and 10.65 seconds on the smartphone. The
difference between the laptop and smartphone results are due
to the difference in their processors (smartphone’s low-power
processors are slower). Also, in the laptop the algorithms are
implemented in C, while on the smartphones they run on the
Java based Android SDK.

Revocation threshold of 1 million is large, as can be
seen from recent Netﬂix statistics [27], [28], reached on an
average in three months for Netﬂix. This makes system re-
initialization events rare and scalable. Eventually, a success-
ful/scalable implementation should combine our clustering
approach and smaller values of t (say 100, 000), which
will allow a smartphone to extract τ in close to 1 second.
Such implementations can handle values of n close to 1
million in a cluster. Also, our approach has a modest memory
footprint, the high RAM usage numbers (e.g., 143 MB for
t = 1 million) are only during the extraction process.

For the second results segment, we implemented one client
on the Macbook, the smartphone version on the Nexus 5
and the CP (a server with 2.5 GHz Intel Core 2 Quad,
3.8 GB) was ﬁve hops away from the clients over a four-
tiered network (created using switches and IPv4 routers). We
compared the baseline NDN’s and AccConF’s performance
in content retrieval. Our framework took almost the same
time for content download, the additional delay being in
downloading the enabling block and extracting the secret
key—an overhead to enforce the AC. Hence, we deﬁne
the security cost as the total extra time that it takes for a
client to download the enabling block from a nearby cache
and extract the secret. Fig. 4 illustrates AccConF’s security
cost, for different polynomial degrees, for the laptop and the
smartphone clients. The cost for the smartphone application
increases faster than the laptop’s; this can be attributed to the
better resources at the laptop’s disposal. The biggest cost for
the laptop is downloading the enabling block, whereas in the

smartphone the costs of communication and extraction are
almost comparable. It is interesting that the download time
for the smartphone is higher than the laptop despite both
connecting to the same access point using IEEE 802.11n.
This difference is attributable to the laptop antenna being
more powerful than the smartphone antenna.

Our last segment details our simulation results using ndn-
SIM on ns-3. We simulated the AccConF, NDN, and the UDP
clients on ten different network topologies; we illustrate the
results of four representative ones. The four representative
network topologies were: {3755 nodes, 7449 edges}; {3709
nodes, 7193 edges}; {3707 nodes, 7353 edges}; and {3696
nodes, 7331 edges}. The topologies were created using
the two-layer Top-Down hierarchical model in BRITE [3].
The autonomous systems (AS) layer was created using the
Waxman model and the router layer for each AS was created
using the Barab`asi-Albert model. Each topology had two
edge routers, each serving ﬁve clients through 20Mbps links.
One content provider was placed across the network, 6 to 8
hops from the two edge routers. Links in the network core
had bandwidth selected randomly between 1 to 4 Gbps.

The server contained 100 content objects. Each object was
300 MB for NDN and UDP and 312 MB for AccConF
(12 MB for the enabling block) respectively. The content
popularity followed a Zipf-Mandelbrot distribution with q =
1 and s = 2, which is reﬂected in the requests made by
the clients. The clients constantly requested content–if one
content request was satisﬁed they requested another. For fair
comparison, the chunk size was 1436 bytes in NDN and
AccConF, comparable to a standard Ethernet frame size. In
NDN and AccConF, the routers were equipped with 1.5 GB
cache (i.e., 5% of the entire content) and used the LRU
cache-eviction algorithm. We ran the simulation for 30000
seconds. The simulations were run on a server-class machine
having 2 AMD Opteron G276 processors, each core clocking
2.3 GHz, with 128 GB RAM.

Fig. 5 shows the average number of contents downloaded
by each client. In NDN and AccConF, the clients’ requests
are satisﬁed faster by virtue of nearby caches, hence the
clients request more contents. NDN performs a little better

Fig. 4. Security Cost for the Laptop (L) User and the Smartphone (S) User.

(a) Topology 1

(b) Topology 2

(c) Topology 3

(d) Topology 4

Fig. 5. Average Number of Content Downloaded per client in AccConF
(A), NDN (N), and UDP (U).
than AccConF because it does not have the enabling block.
In the last topology, the margin is relatively wider. From our
analysis, we identiﬁed that this topology’s structure is such
that more requests are completed, which leads to more cache-
evictions and hence more requests being served from farther
caches. Consequently AccConF is punished more on account
of its enabling block overhead.

Fig. 6 presents the empirical cumulative distribution func-
tion (eCDF) for per-interest latencies in the three approaches.
NDN and AccConF have a signiﬁcant number of interests
that are served in less than 0.01 seconds, which markedly
improves the number of contents downloaded. Fig. 6(d) fur-
ther illustrates why AccConF has lesser per-client downloads.
Whereas in the ﬁrst three topologies the cumulative proba-
bilities of AccConF and NDN track closely, here AccConF
is served by a farther cache (reﬂected in the eCDF increasing
after latency value of 0.042s).

9. CONCLUSIONS AND FUTURE WORK

In this paper, we present a novel access control framework
(AccConF) for secure content delivery to legitimate users
in ICNs. Leveraging broadcast encryption, AccConF targets
the users with power-constrained devices to enable efﬁcient
content access without
involving an online authenticator.
We detailed the protocols and the design decisions for the
framework in the CCN/NDN architecture and demonstrated
it’s feasibility and scalability with practical experiments. Our
experimental/simulation results demonstrate that AccConF
is practical and deployable with minimal network changes.
It can be used by content providers to reduce latency and
guarantee high availability of content.

In future, we will optimize our smartphone application
and the protocols, testing them in a large network. We will

LSLSLSLSLSLSLS0510152010K50K100K300K500K700K1MPolynomial degreeSecurity Cost (seconds)EB Download TimeExtraction TimeANU05101520Avg. Transmitted ContentANU024681012Avg. Transmitted ContentANU05101520Avg. Transmitted ContentANU0510152025Avg. Transmitted Content[8] J. Douceur. The sybil attack. Peer-to-peer Systems, pages 251–260,

[9] A. Fiat and M. Naor. Broadcast encryption. In CRYPTO, pages 480–

2002.

491, 1994.

(a) Topology 1

(b) Topology 2

(c) Topology 3

[10] N. Fotiou, G.F. Marias, and G.C. Polyzos. Access control enforcement
delegation for information-centric networking architectures. In ACM
Information-centric Networking Workshop, pages 85–90, 2012.

[11] N. Fotiou, P. Nikander, D. Trossen, and G.C. Polyzos. Developing
information networking further: From PSIRP to PURSUIT. In ICST
Conference on Broadband Communications, Networks, and Systems,
pages 1–13, 2010.

[12] C. Ghali, M. Schlosberg, G. Tsudik, and C. Wood.

Interest-based
access control for content centric networks (extended version). arXiv
preprint arXiv:1505.06258, 2015.

[13] The GNU Multiple
http://www.gmplib.org.

Precision Arithmetic

Library,

2012.

[14] M. Ion, J. Zhang, and E. M. Schooler. Toward content-centric privacy
ACM SIGCOMM

in icn: attribute-based encryption and routing.
Computer Comm. Review, 43(4):513–514, 2013.

[15] V. Jacobson, D.K. Smetters, J.D. Thornton, M.F. Plass, N.H. Briggs,
In Intl. conference
and R.L. Braynard. Networking named content.
on Emerging networking experiments and technologies, pages 1–12.
ACM, 2009.

[16] T. Koponen, M. Chawla, B. Chun, A. Ermolinskiy, K. Kim, S. Shenker,
and I. Stoica. A data-oriented (and beyond) network architecture. ACM
SIGCOMM Computer Communication Review, 37(4):181–192, 2007.

[17] Palo Alto Research Lab. Ccnx. http://www.ccnx.org/.
[18] T. Lauinger, N. Laoutaris, P. Rodriguez, and et al. Privacy implications
of ubiquitous caching in named data networking architectures. Tech-
nical report, Technical Report TR-iSecLab-0812-001, iSecLab, 2012.
[19] B. Li, A.P. Verleker, D. Huang, Z. Wang, and Y. Zhu. Attribute-
based access control for icn naming scheme. In IEE Conference on
Communications and Network Security. IEEE, 2014.

[20] Q. Li, X. Zhang, Q. Zheng, R. Sandhu, and X. Fu. Live: Lightweight
integrity veriﬁcation and content access control for named data net-
working. IEEE Transactions on Information Forensics and Security,
10(2):308–320, 2015.

(d) Topology 4

Fig. 6.
eCDF for the Latency in AccConF (A), NDN (N), and UDP (U).
investigate more efﬁcient system re-initialization when the
system reaches its capacity.

REFERENCES

[1] B. Ahlgren, C. Dannewitz, C. Imbrenda, D. Kutscher, and B. Ohlman.
IEEE Communications

A survey of information-centric networking.
Magazine, 50(7):26–36, 2012.

[2] S. Arianfar, T. Koponen, B. Raghavan, and S. Shenker. On preserving
privacy in content-oriented networks. In ACM SIGCOMM Information-
centric networking (ICN) workshop, pages 19–24. ACM, 2011.

[3] Brite: Boston university representative internet

topology generator,

2014. http://www.cs.bu.edu/brite.

[4] A Chaabane, E De Cristofaro, M. Kaafar, and E. Uzun. Privacy
in content-oriented networking: Threats and countermeasures. arXiv
preprint arXiv:1211.5183, 2012.

[5] T. Chen, K. Lei, and K. Xu. An encryption and probability based
In IEEE IPCCC,

access control model for named data networking.
pages 1–8. IEEE, 2014.

[6] Cisco.

Cisco visual networking index forecast

(2019), 2016.

http://www.cisco.com/c/en/us/solutions/service-provider/visual-
networking-index-vni/vni-forecast.html.

[7] C. Dannewitz. NetInf: An information-centric design for the future
Internet. In 3rd GI/ITG KuVS Workshop on The Future Internet, 2009.

[21] App Makers Worry as Data Plans Are Capped, June 6, 2010.

http://www.nytimes.com/2010/06/07/technology/07data.html? r=0.

[22] A.J. Menezes, P.C. Van Oorschot, and S.A. Vanstone. Handbook of

applied cryptography. CRC, 1997.

[23] S. Misra, R. Tourani, and N. Majd.

Secure content delivery in
information-centric networks: design, implementation, and analyses. In
Proceedings of the ACM SIGCOMM workshop on Information-centric
networking, pages 73–78. ACM, 2013.

[24] A. Mohaisen, X. Zhang, M. Schuchard, H. Xie, and Y. Kim. Protecting
access privacy of cached contents in information centric networks. In
ACM SIGSAC Symposium, pages 173–178. ACM, 2013.

[25] D. Naor, M. Naor, and J. Lotspiech. Revocation and tracing schemes

for stateless receivers. In CRYPTO, pages 41–62, 2001.

[26] M. Naor and B. Pinkas. Efﬁcient trace and revoke schemes.

Financial cryptography, pages 1–20, 2001.

In

[27] Netﬂix has over 69 million members in over 60 countries., October

25, 2011. http://ir.netﬂix.com/.

[28] OTT

Subscriber Annual Churn Rates.,

July

30,

2015.

https://www.parksassociates.com/blog/article/pr-july2015-ott-
tracker.

[29] C.-P. Schnorr. Efﬁcient signature generation by smart cards. Journal

of Cryptology, 4(3):161–174, 1991.

[30] S. Tarkoma, M. Ain, and K. Visala. The publish/subscribe internet
routing paradigm (psirp): Designing the future internet architecture.
Towards the Future Internet, page 102, 2009.

[31] Tor Project: Anonymity Online. http://www.torproject.org/.
[32] W. Tzeng and Z. Tzeng. A public-key traitor tracing scheme with
revocation using dynamic shares. In Public Key Cryptography, pages
207–224, 2001.

[33] S. Wang, J. Bi, J. Wu, Z. Li, W. Zhang, and X. Yang. Could in-network
caching beneﬁt information-centric networking? In 7th Asian Internet
Engineering Conference, pages 112–115, 2011.

[34] M. Xie, I. Widjaja, and H. Wang. Enhancing cache robustness for

0.010.020.030.040.050.00.20.40.60.81.0Cumulative ProbabilityLatency (s)AccConFNDNUDP0.020.040.060.080.00.20.40.60.81.0Cumulative ProbabilityLatency (s)AccConFNDNUDP0.010.020.030.040.050.00.20.40.60.81.0Cumulative ProbabilityLatency (s)AccConFNDNUDP0.010.020.030.040.050.00.20.40.60.81.0Cumulative ProbabilityLatency (s)AccConFNDNUDPcontent-centric networking.
2012.

In IEEE INFOCOM, pages 2426–2434,

Satyajayant Misra (SM’05, M’09) is an associate
professor in computer science at New Mexico State
University. He completed his M.Sc. in Physics and
Information Systems from BITS, Pilani, India in
2003 and his Ph.D. in Computer Science from
Arizona State University, Tempe, AZ, USA,
in
2009. His research interests include wireless net-
works and the Internet, supercomputing, and smart
grid architectures and protocols. He has served on
several IEEE journal editorial boards and confer-
ence executive committees (Communications on
Surveys and Tutorials, Wireless Communications Magazine, SECON 2010,
INFOCOM 2012). He has authored more than 45 peer-reviewed IEEE/ACM
journal articles and conference proceedings. More information can be
obtained at www.cs.nmsu.edu/ misra.

received his B.S.

Reza Tourani
in computer
engineering from IAUT, Tehran, Iran,
in 2008,
and M.S. in computer science from New Mex-
ico State University, Las Cruces, NM, USA, in
2012. From 2013, he started his Ph. D. at New
Mexico State University. His research interests
include smart grid communication architecture and
protocol, wireless protocols design and optimiza-
tion, future Internet architecture, and privacy and
security in wireless networks.

Frank Natividad is currently pursuing his Master
degree in the computer science department at the
New Mexico State University, Las Cruces, NM,
USA. Frank’s current interests in research are in
power trading agent competitions and machine
learning in smart grid.

Travis Mick completed his B.S. at New Mexico
State University, Las Cruces, NM, USA in 2014,
and is now pursuing an M.S. in computer science
at New Mexico State University. His research is in
smart grid communication and information-centric
networking.

Nahid Ebrahimi Majd received her PhD degree
from the department of Computer Science, New
Mexico State University, Las Cruces, NM, USA, in
2014. She is currently an assistant professor with
the computer science department at the Califor-
nia State University at San Marcos. Her research
interest is in energy harvesting wireless ad hoc
networks, including relay node placement problem
and cooperative caching problem in such networks.

Hong Huang received his B.E. degree from Ts-
inghua University, Beijing, China, and M.S. and
Ph.D. degrees from Georgia Institute of Technol-
ogy in 2000 and 2002, respectively, all in elec-
trical engineering. He is currently an associate
professor with the Klipsch School of Electrical and
Computer Engineering at the New Mexico State
University. His current research interests include
wireless sensor networks, mobile ad hoc networks,
network security, and optical networks. He is a
member of the IEEE.

