6
1
0
2

 
r
a

M
7

 

 
 
]
S
D
.
s
c
[
 
 

1
v
1
2
3
2
0

.

3
0
6
1
:
v
i
X
r
a

Terminal Embeddings∗

Michael Elkin†, Arnold Filtser‡, Ofer Neiman §

Department of Computer Science, Ben-Gurion University of the Negev, Beer-Sheva, Israel.

Email: {elkinm,arnoldf,neimano}@cs.bgu.ac.il

Abstract

In this paper we study terminal embeddings, in which one is given a ﬁnite metric (X, dX ) (or
a graph G = (V, E)) and a subset K ⊆ X of its points are designated as terminals. The objective
is to embed the metric into a normed space, while approximately preserving all distances among
pairs that contain a terminal. We devise such embeddings in various settings, and conclude that
even though we have to preserve ≈ |K| · |X| pairs, the distortion depends only on |K|, rather
than on |X|.
We also strengthen this notion, and consider embeddings that approximately preserve the
distances between all pairs, but provide improved distortion for pairs containing a terminal.
Surprisingly, we show that such embeddings exist in many settings, and have optimal distortion
bounds both with respect to X × X and with respect to K × X.
Moreover, our embeddings have implications to the areas of Approximation and Online
Algorithms. In particular, [ALN08] devised an ˜O(√log r)-approximation algorithm for sparsest-
cut instances with r demands. Building on their framework, we provide an ˜O(
log |K|)-
approximation for sparsest-cut instances in which each demand is incident on one of the vertices
of K (aka, terminals). Since |K| ≤ r, our bound generalizes that of [ALN08].

(cid:112)

1

Introduction

Embedding of ﬁnite metric spaces is a very successful area of research, due to both its algorithmic
applications and its natural geometric appeal. Given two metric space (X, dX ), (Y, dY ), we say
that X embeds into Y with distortion α if there is a map f : X → Y and a constant c > 0, such
that for all u, v ∈ X,

dX (u, v) ≤ c · dY (f (u), f (v)) ≤ α · dX (u, v) .

Some of the basic results in the ﬁeld of metric embedding are: a theorem of [Bou85], asserting
that any metric space on n points embeds with distortion O(log n) into Euclidean space (which
was shown to be tight by [LLR95]), and probabilistic embedding into a distribution of trees, or

∗A preliminary version of this paper appeared in APPROX’15.
†Supported in part by ISF grant No. (724/15).
‡Supported in part by ISF grant No.

(523/12) and by the European Union Seventh Framework Programme

(FP7/2007-2013) under grant agreement n◦303809.

§Supported in part by ISF grant No.

(523/12) and by the European Union Seventh Framework Programme

(FP7/2007-2013) under grant agreement n◦303809.

1

ultrametrics,1 with expected distortion O(log n) [FRT04], or expected congestion O(log n) [R¨ac08]
(which are also tight [Bar96]).

In this paper we study a natural variant of embedding, in which the input consists of a ﬁnite
metric space or a graph, and in addition, a subset of the points are designated as terminals. The
objective is to embed the metric into a simpler metric (e.g., Euclidean metric), or into a simpler
graph (e.g., a tree), while approximately preserving the distances between the terminals to all other
points. We show that such embeddings, which we call terminal embeddings, can have improved
parameters compared to embeddings that must preserve all pairwise distances. In particular, the
distortion (and the dimension in embedding to normed spaces) depends only on the number of
terminals, regardless of the cardinality of the metric space.

We also consider a strengthening of this notion, which we call strong terminal embedding. Here
we want a distortion bound on all pairs, and in addition an improved distortion bound on pairs
that contain a terminal. Such strong terminal embeddings enhance the classical embedding results,
essentially saying that one can obtain the same distortion for all pairs, with the option to select
some of the points, and obtain improved approximation of the distances between any selected point
to any other point.

As a possible motivation for studying such embeddings, consider a scenario in which a certain
network of clients and servers is given as a weighted graph (where edges correspond to links, weights
to communication/travel time). It is conceivable that one only cares about distances between clients
and servers, and that there are few servers. We would like to have a simple structure, such as a tree
spanning the network, so that the client-server distances in the tree are approximately preserved.
We show that there exists a general phenomenon; essentially any known metric embedding into
an (cid:96)p space or a graph family can be transformed via a general transformation into a terminal
embedding, while paying only a constant blow-up in the distortion.
In particular, we obtain a
terminal embedding of any ﬁnite metric into any (cid:96)p space with terminal distortion O(log k), using
only O(log k) dimensions. We show that a similar general phenomenon2 holds also for strong
terminal embeddings, i.e., that many embeddings can be transformed into strong terminal ones via
a general transformation. Many other embeddings into normed spaces, probabilistic embedding
into ultrametrics (including capacity preserving ones), and into spanning trees, have their strong
terminal embedding counterparts, which are constructed directly, that is, not through our general
transformation. Our results are tight in most settings.3

It is well known that embedding a graph into a single tree may cause (worst-case) distortion
Ω(n) [RR98]. However, if one only cares about client-server distances, we show that it is possible
to obtain distortion 2k − 1, where k is the number of servers, and that this is tight. Furthermore,
we study possible tradeoﬀs between the distortion and the total weight of the obtained tree. This
generalizes the notion of shallow light trees [KRY95, ABP92, ES11], which provides a tradeoﬀ
between the distortion with respect to a single designated server and the weight of the tree.

We then address probabilistic approximation of metric spaces and graphs by ultrametrics and
spanning trees. This line of work started with the results of [AKPW95, Bar96], and culminated
in the O(log n) expected distortion for ultrametrics by [FRT04], and ˜O(log n) for spanning trees
by [AN12]. These embeddings found numerous algorithmic applications, in various settings, see

1An ultrametric (U, ρ) is a metric space satisfying ρ(x, z) ≤ max{ρ(x, y), ρ(y, z)} for all x, y, z ∈ U .
2Though this transformation is somewhat less general than for the case of ordinary, i.e., not strong, terminal

embeddings.

3All our terminal embeddings are tight, except for the probabilistic spanning trees, where they match the state-

of-the-art [AN12], and except for our terminal spanners.

2

[FRT04, EEST08, AN12] and the references therein for details. In their work on Ramsey parti-
tions, [MN06] implicitly showed that there exists a probabilistic embedding into ultrametrics with
expected terminal distortion O(log k) (see Section 2 for the formal deﬁnitions). We generalize this
result by showing a strong terminal embedding with the same expected O(log k) distortion guar-
antee for all pairs containing a terminal, and O(log n) for all other pairs. We also show a similar
result that extends the embedding of [AN12] into spanning trees, with ˜O(log k) expected distortion
for pairs containing a terminal, and ˜O(log n) for all pairs. A slightly diﬀerent notion, introduced by
[R¨02], is that of trees which approximate the congestion (rather than the distortion), and [R¨ac08]
showed a distribution over trees with expected congestion O(log n). We provide a strong terminal
version of this result, and show expected congestion of O(log k) for all edges incident on a terminal,
and O(log n) for the rest.

We also consider spanners, with a stretch requirement only for pairs containing a terminal. Our
general transformation produces for any t ≥ 1 a (4t−1)-terminal stretch spanner with O(k1+1/t +n)
edges. The drawback is that this is a metric spanner, not a subgraph of the input graph. We
alleviate this issue by constructing a graph spanner with the same stretch and O(√n · k1+1/t + n)
edges.4 A result of [RTZ05] implicitly provides a terminal graph spanner with (2t − 1) stretch
and O(t · n · k1/t) edges. Our graph terminal spanner is sparser than that of [RTZ05] as long as
k ≤ t · n1/2(1+1/t).
1.1 Algorithmic Applications

We overview a few of the applications of our results to approximation and online algorithms. Some
of the most striking applications of metric embeddings are to various cut problems, such as the
sparsest-cut, min-bisection, and also to several online problems. Our method provides improved
guarantees when the input graph has a small set of ”important” vertices. Speciﬁcally, these vertices
can be considered as terminals, and we obtain approximation factors that depend on the cardinality
of the terminal set, rather than on the input size. The exact meaning of importance is problem
speciﬁc; e.g.
in the cut problems, we require that the set of important vertices touches every
demand pair, or every edge (that is, forms a vertex cover).

For instance, consider the (general) sparsest-cut problem [LR99, AR98, LLR95]. We are given a

graph G = (V, E) with capacities on the edges c : E → R+, and a collection of pairs (s1, t1), . . . , (sr, tr)
along with their demands D1, . . . , Dr. The goal is to ﬁnd a cut S ⊆ V that minimizes the ratio
between capacity and demand across the cut:

(cid:80){u,v}∈E c(u, v)|1S(u) − 1S(v)|
(cid:80)r

i=1 Di|1S(si) − 1S(ti)|

φ(S) =

,

where 1S(·) is the indicator for membership in S. Following the breakthrough result of [ARV09],
which showed O(√log n) approximation for the uniform demand case, [ALN08] devised an ˜O(√log r)
approximation for the general case. If there is a set of k important vertices, such that every de-
mand pair contains an important vertex, we obtain an ˜O(√log k) approximation using the terminal
embedding of negative-type metrics to (cid:96)1. Observe that k ≤ r, and so our result subsumes the
result of [ALN08]. Our bound is particularly useful for instances with many demand pairs but few
distinct sources si (or few targets ti).

4Note that the number of edges is linear whenever k ≤ n1/(2(1+1/t)).

3

We also consider other cut problems, and show a similar phenomenon: the O(log n) approxima-
tion for the min-bisection problem [R¨ac08], can be improved to an approximation of only O(log k),
where k is the size of the minimum vertex cover of the input graph. For this result we employ
our terminal variant of R¨acke’s result [R¨ac08] on capacity-preserving probabilistic embedding into
trees.

We then focus on one application of probabilistic embedding into ultrametrics [Bar96, FRT04],
and illustrate the usefulness of our terminal embedding result by the (online) constrained ﬁle mi-
gration problem [BFR95]. Given a graph G = (V, E) representing a network, each node v ∈ V has
a memory capacity mv, and there is a set of ﬁles that reside at the nodes, at most mv ﬁles may
be stored at node v at any given time. The cost of accessing a ﬁle is the distance in the graph to
the node storing it (no copies are allowed). Files can also be migrated from one node to another.
This costs D times the distance, for a given parameter D ≥ 1. When a sequence of ﬁle requests
from nodes arrives online, the goal is to minimize the cost of serving all requests. [Bar96] showed
v∈V mv
is the total memory available.5 A setting which seems particularly natural is one where there is
a small set of nodes who can store ﬁles (servers), and the rest of the nodes can only access ﬁles
but not store them (clients). We employ our probabilistic terminal embedding into ultrametrics to
provide a O(log m · log k) competitive ratio, for the case where there are k servers. (Note that this
ratio is independent of n.)

a algorithm with O(log m · log n) competitive ratio for graphs on n nodes, where m = (cid:80)

1.2 Overview of Techniques

The weak variant of our terminal embedding into (cid:96)2 maps every terminal x into its image f (x)
under an original black-box (e.g., Bourgain’s) embedding of K into (cid:96)2. This embedding is then
appended with one additional coordinate. Terminals are assigned 0 value in this coordinate, while
each non-terminal point y is mapped to (f (x), d(x, y)), where x is the closest terminal to y. It is not
hard to see that this embedding guarantees terminal distortion O(γ(k)), where γ(k) is the distortion
of the original black-box embedding, i.e., O(log k) in the case of Bourgain’s embedding. On the
other hand, the new embedding employs only β(k) + 1 dimensions, where β(k) is the dimension
of the original blackbox embedding (i.e., O(log2 k) in the case of Bourgain’s embedding).6 This
idea easily generalizes to a number of quite general scenarios, and under mild assumptions (see
Theorem 2) it can be modiﬁed to produce strong terminal embeddings.

This framework, however, does not apply in many important settings, such as embedding into
subgraphs, and does not provide strong terminal guarantees in others. Therefore we devise embed-
dings tailored to each particular setting in a non-black-box manner. For instance, our probabilistic
embedding into trees with strong terminal congestion requires an adaptation of a theorem of [AF09],
about the equivalence of distance-preserving and capacity-preserving random tree embeddings, to
the terminal setting. Perhaps the most technically involved is our probabilistic embedding into
spanning trees with strong terminal distortion. This result requires a set of modiﬁcations to the
recent algorithm of [AN12], which is based on a certain hierarchical decomposition of graphs. We
adapt this algorithm by giving preference to the terminals in the decomposition (they are the ﬁrst
to be chosen as cluster centers), and the crux is assuring that the distortion of any pair containing
5The original paper shows O(log m · log2 n), the improved factor is obtained by using the embedding of [FRT04].
6We can also get dimension O(log k) for terminal embeddings into (cid:96)2 by replacing Bourgain’s embedding with

that of [ABN11].

4

a terminal is essentially not aﬀected by choices made for non-terminals. Furthermore, one has to
guarantee that each such pair can be separated in at most O(log k) levels of the hierarchy.
The basic technical idea that we use for constructing (4t − 1)-terminal subgraph spanners with
O(√nk1+1/t + n) edges is the following one. As was mentioned above, our general transformation
constructs metric (i.e., non-subgraph) (4t − 1)-terminal spanners with O(n + k1+1/t) edges. The
latter spanners employ some edges which do not belong to the original graph. We provide these
edges as an input to a pairwise preserver. A pairwise preserver [CE05] is a sparse subgraph that
preserves exactly all distances between a designated set of vertex pairs. We use these preservers to
ﬁll in the gaps in the non-subgraph terminal spanner constructed via our general transformation.
As a result we obtain a subgraph terminal spanner which outperforms previously existing terminal
spanners of [RTZ05] in a wide range of parameters.

1.3 Related Work

Already in the pioneering work of [LLR95], an embedding that has to provide a distortion guarantee
for a subset of the pairs is presented. Speciﬁcally, in the context of the sparsest-cut problem,
[LLR95] devised a non-expansive embedding of an arbitrary metric into (cid:96)1, with distortion at most
O(log r) for a set of r speciﬁed demand pairs.

Terminal distance oracles were studied by [RTZ05], who called them source restricted distance
oracles. In their paper, [RTZ05] show (2t− 1)-terminal stretch using O(t· n· k1/t) space. Implicit in
our companion paper [EFN15] is a distance oracle with (4t−1)-terminal stretch, O(t·k1/t +n) space
and O(1) query time. Terminal spanners with additive stretch for unweighted graphs were recently
constructed in [KV13]. Speciﬁcally, they showed a spanner with ˜O(n5/4 · k1/4) edges and additive
stretch 2 for pairs containing a terminal. Another line of work introduced distance preservers
[CE05]; these are spanners which preserve exactly distances for a given collection of pairs.

In the context of preserving distances just between the terminals, [Gup01a, CXKR06, EGK+14,
KKN14] studied embeddings of a graph into a minor over the terminals, while approximately
preserving distances. In their work on the requirement cut problem, among other results, [GNR10]
obtain for any metric with k speciﬁed terminals, a distribution over trees with expected expansion
O(log k) for all pairs, and which is non-contractive for terminal pairs. (Note that this is diﬀerent
from our setting, as the extra guarantee holds for terminals only, not for pairs containing a terminal.)
Another line of research [Moi09, CLLM10, MM10, EGK+14] studied cut and vertex sparsiﬁers.
A cut sparisiﬁer of a graph G = (V, E) with respect to a subset K of terminals is a graph H =
(K, EH ) on just the set of terminals, so that for any subset A ⊂ K, the minimum value of a cut
in G that separates A from K \ A is approximately equal to the value of the cut (A, K \ A) in H.
Note that this notion is substantially diﬀerent from the notion of terminal congestion-preserving
embedding, which we study in the current paper.

1.4 Subsequent Work

In a companion paper [EFN15], we study prioritized metric structures and embeddings. In that
setting, along with the input metric (X, d), a priority ranking of the points of X is given, and
the goal is to obtain a data structure (distance oracle, routing scheme) or an embedding with
stretch/distortion that depends on the ranking of the points. This has some implications to the
terminal setting, since the k terminals can be given as the ﬁrst k points in the priority ranking.
More concretely, implicit in [EFN15] is an embedding into a single (non-subgraph) tree with strong

5

terminal distortion O(k), a probabilistic embedding into ultrametrics with expected strong terminal
distortion O(log k), and embedding into (cid:96)p space with strong terminal distortion ˜O(log k). In the
current paper we provide stronger and more general results: our single tree embedding has tight
2k − 1 stretch, the tree is a subgraph, and it can have low weight as well (at the expense of
slightly increased stretch); we obtain probabilistic embedding into spanning trees, and in congestion-
preserving trees; and our terminal embedding to (cid:96)p space has a tight strong terminal distortion
(O(log k), O(log n)) and low dimension. Furthermore, the results of this paper apply to numerous
other settings (e.g., embeddings tailored for graphs excluding a ﬁxed minor, negative-type metrics,
spanners, etc.).

Following our work, [BFN16] discovered a connection between terminal distortion and coarse
partial distortion. First recall the notion of coarse partial distortion, introduced in [KSW09,
ABC+05]. Let (X, dX ) be a metric space of size |X| = n. For x ∈ X and  ∈ (0, 1),
let
R(x, ) = min{r : |B(x, r)| ≥ n}. A point y is called -far from x if dX (x, y) ≥ R(x, ). We
say that an embedding f : X → Y has coarse (1 − )-partial distortion λ, if every pair x, y ∈ X
such that both x, y are /2-far from each other, has distortion at most λ. The connection between
this notion and terminal distortion is roughly as follows.

certain set of k terminals, then this very embedding has coarse (1− 8

• If a metric admits an embedding (into some target space) with terminal distortion γ for a
k )-partial distortion 5· γ.
k )-partial distortion γ, then every

• If every metric admits an embedding with coarse (1 − 1

metric has embedding with terminal distortion γ (for any set of k terminals).

The terminal embedding results presented here are strictly stronger than those obtainable
by using the state-of-the-art coarse partial embeddings with the above transformation. E.g., by
[ABC+05] it follows that if every n-point metric embeds into (cid:96)p with distortion α(n) and dimension
β(n) (where the embedding needs to fulﬁll a certain condition), then it embeds into (cid:96)p with terminal
distortion α(O(k)) and dimension β(O(k))·O(log n). Our generic terminal embedding of Theorem 1
provides dimension independent of n, does not restrict the original embedding, and has improved
constants in the distortion. Also our embedding into spanning trees with ( ˜O(log k), ˜O(log n))-
strong terminal distortion improves the embedding obtainable by going through the coarse partial
embedding of [ABN15], which would give only ( ˜O(log2 k), ˜O(log2 n))-strong terminal distortion.

1.5 Organization

The general transformations are presented in Section 3. The results on graph spanners appear
in Section 4. The tradeoﬀ between terminal distortion and lightness in a single tree embedding
is shown in Section 5. Corresponding lower bounds in several settings appear in Section 6 and in
Appendix A. The probabilistic embedding into ultrametrics with strong terminal distortion appears
in Section 7, the congestion preserving variant is in Section 8, and the probabilistic embedding into
spanning trees is shown in Section 9. Algorithmic applications are described in Section 10.

2 Preliminaries

Here we provide formal deﬁnitions for the notions of terminal distortion. Let (X, dX ) be a ﬁnite
metric space, with K ⊆ X a set of terminals. Throughout the paper we assume |K| ≤ |X|/2.

6

Deﬁnition 1. Let (X, dX ) be a metric space, and let K ⊆ X be a subset of terminals. For a target
metric (Y, dY ), an embedding f : X → Y has terminal distortion α if there exists c > 0, such that
for all v ∈ K and u ∈ X,7

dX (v, u) ≤ c · dY (f (v), f (u)) ≤ α · dX (v, u) .

We say that the embedding has strong terminal distortion (α, β) if it has terminal distortion α,

and in addition there exists c(cid:48) > 0, such that for all u, w ∈ X,

(cid:48)
dX (u, w) ≤ c

· dY (f (u), f (w)) ≤ β · dX (u, w) .

For a graph G = (V, E) with a terminal set K ⊆ V , an α-terminal (metric) spanner is a graph

H on V such that for all v ∈ K and u ∈ V ,

dG(u, v) ≤ dH (u, v) ≤ α · dG(u, v) .

(1)

H is a graph spanner if it is a subgraph of G.

Denote by diam(X) = maxy,z∈X{dX (y, z)}. For any x ∈ X and r ≥ 0 let BX (x, r) = {y ∈ X |
dX (x, y) ≤ r} (we often omit the subscript when the metric is clear from context). For a point
x ∈ X and a subset A ⊆ X, dX (x, A) = mina∈A{dX (x, a)}. For K ⊆ X we denote by (K, dK) the
(cid:80)
metric space where dK is the induced metric.
For a weighted graph G = (V, E, w) where w : E → R+, given a subgraph H of G, let w(H) =
e∈E(H) w (e), and deﬁne the lightness of H to be Ψ (H) =
w(M ST (G)) , where w(M ST ) is the

w(H)

weight of a minimum spanning tree of G.

By ˜O(f (n)) we mean O(f (n) · polylog(f (n))).

3 A General Transformation

In this section we present general transformation theorems that create terminal embeddings into
normed spaces and graph families from standard ones. We say that a family of graphs G is leaf-
closed, if it is closed under adding leaves. That is, for any G ∈ G and v ∈ V (G), the graph
G(cid:48) obtained by adding a new vertex u and connecting u to v by an edge, belongs to G. Note
that many natural families of graphs are leaf-closed, e.g. trees, planar graphs, minor-free graphs,
bounded tree-width graphs, bipartite graphs, general graphs, and many others.
Theorem 1. Let X be a family of metric spaces. Fix some (X, dX ) ∈ X , and let K ⊆ X be a set
of terminals of size |K| = k, such that (K, dK) ∈ X . Then the following assertions hold:
• If there are functions α, γ : N → R, such that every (Z, dZ) ∈ X of size |Z| = m embeds
distortion 2(p−1)/p · ((2α(k))p + 1)1/p.8
• If G is a leaf-closed family of graphs, and any (Z, dZ) ∈ X of size |Z| = m embeds into G with
distortion α(m) such that the target graph has at most γ(m) edges, then there is an embedding
of X into G with terminal distortion 2α(k) + 1 and the target graph has at most γ(k) + n − k
edges.

γ(k)+1
with distortion α(m), then there is an embedding of X into (cid:96)
p

with terminal

γ(m)
into (cid:96)
p

all pairs.

7In most of our results the embedding has a one-sided guarantee (that is, non-contractive or non-expansive) for
8Note that for any p, α ≥ 1 we have that 2(p−1)/p · ((2α)p + 1)1/p ≤ 4α.

7

Remark: The second assertion holds under probabilistic embeddings as well.

Proof. We start by proving the ﬁrst assertion. By the assumption there exists an embedding

f : K → Rγ(k) with distortion α(k) under the (cid:96)p norm. We assume w.l.o.g that f is non-contractive.
For each x ∈ X, let kx ∈ K be the nearest point to x in K (that is, d(x, K) = d(x, kx)). Deﬁne the
embedding ˆf : X → Rγ(k)+1 by letting for x ∈ X, ˆf (x) = (f (kx), d(x, kx)). Observe that for t ∈ K,
ˆf (t) = (f (t), 0). Fix any t ∈ K and x ∈ X. Note that by deﬁnition of kx, d(x, kx) ≤ d(x, t), and
by the triangle inequality, d(t, kx) ≤ d(t, x) + d(x, kx) ≤ 2d(t, x), so that,
p + d(x, kx)p
≤ (α(k) · d(t, kx))p + d(x, kx)p
≤ (2α(k) · d(t, x))p + d(t, x)p
= d(t, x)p · ((2α(k))p + 1) .

p = (cid:107)f (t) − f (kx)(cid:107)p

(cid:107) ˆf (t) − ˆf (x)(cid:107)p

On the other hand, since f does not contract distances,

(cid:107) ˆf (t) − ˆf (x)(cid:107)p

p = (cid:107)f (t) − f (kx)(cid:107)p

p + d(x, kx)p
≥ d(t, kx)p + d(x, kx)p
≥ (d(t, kx) + d(x, kx))p/2p−1
≥ d(x, t)p/2p−1 ,

where the second inequality is by the power mean inequality. We conclude that the terminal

distortion is at most 2(p−1)/p · ((2α(k))p + 1)1/p.
For the second assertion, there is a non-contractive embedding f of K into G ∈ G with distortion
at most α(k). As above, for each x ∈ X \ K deﬁne kx as the nearest point in K to x. And for each
x ∈ X, add to G a new vertex f (x) that is connected by an edge of length dG(x, kx) to f (kx). The
resulting graph G(cid:48)
∈ G, because it is a leaf-closed family. Fix any x ∈ X and t ∈ K, then as above
d(t, kx) ≤ 2d(t, x), and so

dG(cid:48)(f (t), f (x)) = dG(f (t), f (kx)) + dG(cid:48)(f (x), f (kx))

≤ α(k) · d(t, kx) + d(x, kx)
≤ d(t, x) · (2α(k) + 1) .

Also note that

dG(cid:48)(f (t), f (x)) = dG(f (t), f (kx)) + d(x, kx) ≥ d(t, kx) + d(x, kx) ≥ d(t, x) ,

so the terminal distortion is indeed 2α(k) + 1. Since f embeds into a graph with γ(k) edges, and
we added n − k new edges, the total number of edges is bounded accordingly, which concludes the
proof.

Next, we study strong terminal embeddings into normed spaces. Fix any metric (X, d), a set of
terminals K ⊆ X and 1 ≤ p ≤ ∞. Let f : K → (cid:96)p be a non-expansive embedding. We say that f
is Lipschitz extendable, if there exists a non-expansive ˆf : X → (cid:96)p which is an extension of f (that
is, the restriction of ˆf to K is exactly f ). It is not hard to verify that any Fr´echet embedding9 is
Lipschitz extendable. For example, the embeddings of [Bou85, KLMN05, ALN08] are Fr´echet.

9In our context, it will be convenient to call an embedding f : K → (cid:96)t

such that for all i ∈ [t], and for every x ∈ K, we have fi(x) = d(x,Ai)
t1/p .

p Fr´echet, if there are sets A1, . . . , At ⊆ X

8

γ(m)
p

γ(n)+γ(k)+1
p

with strong terminal distortion O(α(k), α(n)).

Theorem 2. Let X be a family of metric spaces. Fix some (X, dX ) ∈ X , and let K ⊆ X be a set
of terminals of size |K| = k, such that (K, dK) ∈ X . If any (Z, dZ) ∈ X of size |Z| = m embeds
into (cid:96)
with distortion α(m) by a Lipschitz extendable map, then there is a (non-expansive)
embedding of X into (cid:96)
Proof. Let (X, d) ∈ X be a metric on n points, K ⊆ X of size |K| = k. There is a non-expansive
embedding g : X → (cid:96)
with distortion at most α(n), and there exists a Lipschitz extendable
, which is non-expansive and has distortion α(k). Let ˆf be the extension
embedding f : K → (cid:96)
of f to X, note that by deﬁnition of Lipschitz extendability, ˆf is also non-expansive. Finally, let
h : X → R be deﬁned by h(x) = d(x, K). The embedding F : X → (cid:96)
is deﬁned by the
concatenation of these maps F = g ⊕ ˆf ⊕ h.

Since all the three maps g, ˆf , h are non-expansive, it follows that for any x, y ∈ X,

γ(n)+γ(k)+1
p

γ(n)
p

γ(k)
p

(cid:107)F (x) − F (y)(cid:107)p

p ≤ (cid:107)g(x) − g(y)(cid:107)p

p + (cid:107) ˆf (x) − ˆf (y)(cid:107)p

p + |h(x) − h(y)|p ≤ 3d(x, y)p ,

so F has expansion at most 31/p for all pairs (which can easily be made 1 without aﬀecting the
distortion by more than a constant factor). Also note that

(cid:107)F (x) − F (y)(cid:107)p ≥ (cid:107)g(x) − g(y)(cid:107)p ≥

d(x, y)
α(n)

,

which implies the distortion bound for all pairs is satisﬁed. It remains to bound the contraction for
all pairs containing a terminal. Let t ∈ K and x ∈ X, and let kx ∈ K be such that d(x, K) = d(x, kx)
(it could be that kx = x). If it is the case that d(x, t) ≤ 3α(k)·d(x, kx) then by the single coordinate
of h we get suﬃcient contribution for this pair:

(cid:107)F (t) − F (x)(cid:107)p ≥ |h(t) − h(x)| = h(x) = d(x, kx) ≥

d(x, t)
3α(k)

.

The other case is that d(x, t) > 3α(k) · d(x, kx), here we will get the contribution from ˆf . First,
observe that by the triangle inequality,

d(t, kx) ≥ d(t, x) − d(x, kx) > d(t, x)(1 − 1/(3α(k))) ≥ 2d(t, x)/3 .

(2)

By another application of the triangle inequality, using ˆf is non-expansive, and that f has distortion
α(k) on the terminals, we get the required bound on the contraction:

(cid:107)F (t) − F (x)(cid:107)p ≥ (cid:107) ˆf (t) − ˆf (x)(cid:107)p

≥ (cid:107) ˆf (t) − ˆf (kx)(cid:107)p − (cid:107) ˆf (kx) − ˆf (x)(cid:107)p
≥ (cid:107)f (t) − f (kx)(cid:107)p − d(x, kx)
≥

d(t, x)
3α(k)

d(t, kx)
α(k) −
2d(t, x)
3α(k) −
d(t, x)
3α(k)

.

(2)

≥

=

d(t, x)
3α(k)

9

Remark: The results of Theorem 1 and Theorem 2 hold also if X is a family of graphs, rather
than of metrics, provided that the embedding for this family has the promised guarantees even for
graphs with Steiner nodes. (E.g., if ˆZ ∈ X is a graph and Z is a set of vertices of size m, then
γ(m)
there exists a (Lipschitz extendable) embedding of (Z, dZ) to (cid:96)
with distortion α(m), where dZ
p
is the shortest path metric on ˆZ induced on Z.) We note that many embeddings of graph families
satisfy this condition, e.g. the embedding of [KLMN05] to planar and minor-free graphs.10

Corollary 1. Let (X, d) be a metric space on n points, and K ⊆ X a set of terminals of size
|K| = k. Then for any 1 ≤ p ≤ ∞,
1. (X, d) can be embedded to (cid:96)

with terminal distortion O(log k).

O(log k)
p

O(log k)
2. If (X, d) is an (cid:96)2 metric, it can be embedded to (cid:96)
2
3. For any t ≥ 1 there exists a (4t−1)-terminal (metric) spanner of X with at most O(k1+1/t)+n

with terminal distortion O(1).

edges.

4. If (X, d) is an (cid:96)2 metric, for any t ≥ 1 there exists a O(t)-terminal spanner of X with at most

O(k1+1/t2

) + n edges.

5. (X, d) can be embedded to (cid:96)

O(log n+log2 k)
p

with strong terminal distortion (O(log k), O(log n)).

6. If (X, d) is a decomposable metric, 11 it can be embedded to (cid:96)p with strong terminal distortion

(O((log k)min{ 1

2

, 1
p

}

), O((log n)min{ 1

2

}

, 1
p

)).

7. If (X, d) is a negative type metric it can be embedded to (cid:96)2 with strong terminal distortion

( ˜O(√log k), ˜O(√log n)). (We note that any (cid:96)1 metric is of negative type.)

O(t·k1/t·log k)
∞

8. For any t ≥ 1, (X, d) can be embedded to (cid:96)
The ﬁrst two items and the last one use the ﬁrst assertion of Theorem 1, the next two use its
second assertion, and the next three apply Theorem 2. The corollary follows from known embedding
results: (1) and (5) are from [Bou85], with improved dimension due to [ABN11], (2) is from [JL84],
(3) is from [ADD+93] and (4) from [HPIS13], (6) from [KLMN05], (7) from [ALN07, ALN08], and
(8) from [Mat96, ABN11].

with terminal distortion O(t).

4 Graph Terminal Spanners

While Theorem 1 provides a general approach to obtain terminal spanners, it cannot provide
spanners which are subgraphs of the input graph. We devise a construction of such terminal
spanners in this section, while somewhat increasing the number of edges. Speciﬁcally, we show the
following.

10We remark that this requirement is needed for those graph families for which the following question is open:
given a graph Z in the family with terminals K, is there another graph in the family over the vertex set K, that
preserves the shortest-path distances with respect to Z (up to some constant). This question is open, e.g., for planar
graphs.

11See [KLMN05] for a deﬁnition of decomposability. We remark that doubling metrics, planar metric, and more

generally metric arising from graphs excluding a ﬁxed minor, are all decomposable.

10

We shall use the following result:

Theorem 3. For any parameter t ≥ 1, a graph G = (V, E) on n vertices, and a set of terminals
K ⊆ V of size k, there exists a (4t − 1)-terminal graph spanner with at most O(n + √n · k1+1/t)
edges.
Remark: Note that the number of edges is linear in n whenever k ≤ n1/(2(1+1/t)).
(cid:1) of
Theorem 4 ([CE05]). Given a weighted graph G = (V, E) on n vertices and a set P ⊆
size p, then there exists a subgraph G(cid:48) with O(n + √n · p) edges, such that for all {u, v} ∈ P ,
dG(u, v) = dG(cid:48)(u, v).
(cid:1) be the set of edges
a (2t− 1) (metric) spanner H(cid:48) of this metric, using [ADD+93], and let P ⊆
of H(cid:48). Note that p = |P| ≤ O(k1+1/t). Now, apply Theorem 4 on the graph G with the set of pairs
P , and obtain a graph G(cid:48) that for every {u, v} ∈ P , has dG(cid:48)(u, v) = dG(u, v). This implies that G(cid:48) is
a (2t− 1)-spanner for each pair of vertices u, w ∈ K. Moreover, G(cid:48) has at most O(n +√n· p) edges.
Finally, create H out of G(cid:48) by adding a shortest path tree in G with the set K as its root. This
will guarantee that the spanner H will have for each non-terminal, a shortest path to its closest
terminal in G. This concludes the construction of H, and now we turn to bounding the distortion.
Since H is a subgraph clearly it is non-contracting. Fix any v ∈ K and u ∈ V , let ku be the closest
terminal to u, then dG(ku, v) ≤ dG(ku, u) + dG(u, v) ≤ 2dG(u, v), and thus

Proof of Theorem 3. The construction of the subgraph spanner with terminal distortion will be as
follows. Consider the metric induced on the terminals K by the shortest path metric on G. Create

(cid:0)K

2

(cid:0)V

2

dH (u, v) ≤ dH (u, ku) + dG(cid:48)(ku, v) ≤ dG(u, v) + (2t − 1)dG(ku, v) ≤ (4t − 1)dG(u, v) .

Finally observe that the total number of edges in H is at most O(n+√n·p) = O(n+√n·k1+1/t).
5 Light Terminal Trees for General Graphs

In this section we ﬁnd a single spanning tree of a given graph, that has both light weight, and
approximately preserves distances from a set of speciﬁed terminals. Theorem 1 can provide a tree
with terminal distortion 2k − 1 (using that any graph has a tree with distortion n − 1), but that
tree may not be a subgraph and may have large weight. The result of this section is summarized
as follows.

Theorem 5. For any parameter α ≥ 1, given a weighted graph G = (V, E, w), and a subset of
terminals K ⊆ V of size k, there exists a spanning tree T of G with terminal distortion at most
k · α + (k − 1) α2 and lightness at most 2α + 1 + 2
α−1 .

When substituting α = 1 in Theorem 5 we obtain a single tree with terminal distortion exactly
2k − 1, which is optimal (see Theorem 6), but no guarantee for lightness. More generally, for small
 > 0, we get terminal distortion 2k − 1 +  and lightness 3 + 6k
 . Also, note that the bound
2α + 1 + 2
α−1 is minimized by setting α = 2, so there is no point in using the theorem with α > 2.
Next we describe the algorithm for constructing a spanning tree that satisﬁes the assertion of
Theorem 5. We shall assume w.l.o.g that all edge weights are diﬀerent, and every two diﬀerent
paths have diﬀerent lengths.
If it is not the case, then one can break ties in an arbitrary (but
consistent) way.

11

A spanning tree T is an (α, β)-SLT with respect to a root v ∈ V , if for all u ∈ V , dT (v, u) ≤
α·dG(v, u), and T has lightness β. A small modiﬁcation of an SLT-constructing algorithm produces
for any subset K ⊂ V , a forest F , such that every component of F contains exactly one vertex of
K.12 The forest F has distortion α with respect to K, and lightness 1 + 2
α−1 . (Such a forest F is
said to have distortion α with respect to K, if for every vertex u ∈ V , dF (K, u) ≤ α · dG (K, u).)
The algorithm starts by building the aforementioned SLT-forest F from the terminal set K.
No two terminals belong to the same connected component of F . Denote K = {v1, . . . , vk},
let Vi be the unique connected component of F containing vi, and let Ti ⊆ F be the edges
It follows that for every u ∈ Vi, dF (K, u) = dTi (vi, u) ≤
of the forest F induced by Vi.
α · dG (K, u). Let G(cid:48) = (K, E(cid:48), w(cid:48)) be the super-graph in which two terminals share an edge
between them if and only if there is an edge between the components Vi to Vj in G. Formally,
E(cid:48) = {{vi, vj} : ∃ui ∈ Vi, uj ∈ Vj such that {ui, uj} ∈ E}. The weight w(cid:48) (vi, vj) is deﬁned to be

the length of the shortest path between vi and vj which uses exactly one edge that does not be-
long to F . (In other words, among all the paths between vi and vj in G which use exactly one
edge that does not belong to F , let P be the shortest one. Then w(cid:48) (vi, vj) = w (P ).) Note also
that w(cid:48) (vi, vj) is given by w(cid:48) (vi, vj) = min e∈E
that implements this minimum (w(cid:48) (vi, vj) = dF∪{ei,j} (vi, vj)) the representative edge of {vi, vj}.
(cid:110)
serve that {vi, vj} ∈ E(cid:48) implies that w(cid:48) (vi, vj) < ∞. Let T (cid:48) be the M ST of G(cid:48). Deﬁne R =
ei,j |ei,j is the representative edge of e(cid:48)
i=1 Ti ∪ R.
Obviously, T is a spanning tree of G. This concludes the construction, next we turn to the analysis.
As an embedding of a graph into its spanning tree is non-contractive, the tree T will have

(cid:8)dF∪{e} (vi, vj)(cid:9). We call the edge ei,j = {ui, uj}

. Finally, set T = F ∪ R =(cid:83)k

(Recall that w.l.o.g the shortest paths, and thus the representative edges, are unique.) Ob-

i,j = (vi, vj) ∈ T (cid:48)(cid:111)

The next lemma shows that for every pair of terminals vi, vj, there is a path between them in

terminal distortion α if for all v ∈ K, u ∈ V , dT (v, u) ≤ α · dG (v, u).
G(cid:48) in which all edges have weight (with respect to w(cid:48)) at most α · dG (vi, vj).
Lemma 2. [The bottleneck lemma:] For every vi, vj ∈ K, there exists a path P : vi = z0, z1, ..., zr =
vj in G(cid:48) such that for every s = 0, 1, . . . , r − 1, it holds that {zs,zs+1} ∈ E(cid:48) and w(cid:48) (zs, zs+1) ≤
α · dG (vi, vj).
Proof. Let Pi,j : vi = u0, u1, ..., us = vj be the shortest path from vi to vj in G, i.e., w(Pi,j) =
dG (vi, vj). For each 0 ≤ a ≤ s, denote by V (a) the connected component of F that contains ua,
and let v(a) be the unique terminal in that component. Consider the path P = v(0), v(1), ..., v(s).
(This path is not necessarily simple. In particular, it might contain self-loops. See Figure 1 for an
illustration.) For every index a < s,

(cid:48)(cid:16)

v(a), v(a+1)(cid:17)

w

(cid:16)

v(a), v(a+1)(cid:17)

dF∪{{ua,ua+1}}

≤(1)

(cid:16)

(cid:17)

(cid:16)

ua+1, v(a+1)(cid:17)

v(a), ua

+ dG (ua, ua+1) + dF

= dF
≤(2)
α · dG (vi, ua) + dG (ua, ua+1) + α · dG (vj, ua+1)
< α · (dG (vi, ua) + dG (ua, ua+1) + dG (vj, ua+1))
=
(3)

α · dG (vi, vj) .

12To obtain such a forest F , one should add a new vertex vK to the graph and connect it to each of the vertices of
K with edges of weight zero. Then we compute an (α, β)-SLT with respect to vK in the modiﬁed graph. Finally, we
remove vK from the SLT. The resulting forest is F .

12

≤ α · dG (vi, vj).

(cid:0)v(a), ua

Figure 1: An illustration for the bottleneck lemma: vi and vj are terminals. The edge {ua, ua+1} belongs
to the shortest path from vi to vj in G. We conclude that for terminals v(a), v(a+1) such that ua ∈ V (a) and

ua+1 ∈ V (a+1), it holds that w(cid:48)(cid:0)v(a), v(a+1)(cid:1)
Note that if for some index a it holds that v(a) = v(a+1) then w(cid:48)(cid:0)v(a), v(a+1)(cid:1) = 0, and the inequality
(cid:1) = dF (K, ua) ≤ α · dG (K, ua) ≤ α · dG (vi, ua)). Equality (3) follows

above holds trivially. Otherwise, if v(a) (cid:54)= v(a+1), then inequality (1) follows from the assumptions
that {ua, ua+1} ∈ E, ua ∈ V (a), ua+1 ∈ V (a+1). Inequality (2) follows from the properties of the
SLT tree T (as dF
because the edge {ua, ua+1} is on the shortest path from vi to vj in G.
We get a simple path P (cid:48)such that for every edge v, v(cid:48) on this path, we have w(cid:48) (v, v(cid:48)) ≤ α·dG (vi, vj),

In particular, one can remove cycles from P and obtain a simple path with the desired properties.

as required.

The following is a simple corollary.

Corollary 3. For {vi, vj} ∈ T (cid:48), we have w(cid:48) (vi, vj) = dT (vi, vj) ≤ α · dG (vi, vj).
Proof. By Lemma 2, w(cid:48) (vi, vj) ≤ α · dG (vi, vj). (Indeed, otherwise the edge {vi, vj} is strictly
the heaviest edge in a cycle in G(cid:48), contradiction to the assumption that it belongs to the MST of
G(cid:48).) Since {vi, vj} ∈ E(cid:48) and the representative edge of {vi, vj} was taken into T , it follows that
w(cid:48) (vi, vj) = dT (vi, vj).

We conclude the following lemma, which bounds the distortion of terminal pairs.

Lemma 4. For vi, vj ∈ K, we have dT (vi, vj) ≤ dT (cid:48) (vi, vj) ≤ α · (k − 1) · dG (vi, vj).
Proof. Let P (cid:48) : vi = v(0), v(1), . . . , v(h) = vj be the (unique) path in T (cid:48) between vi and vj. Since T (cid:48)
(cid:0)v(a), v(a+1)(cid:1). Also, we next argue
index a ∈ [h − 1], by Corollary 3, the edge w(cid:48)(cid:0)v(a), v(a+1)(cid:1) = dT
is a spanning tree of the k-vertex graph G(cid:48), it follows that h ≤ k − 1. Observe also that for every
Indeed, suppose for contradiction that w(cid:48)(cid:0)v(a), v(a+1)(cid:1) >
that w(cid:48)(cid:0)v(a), v(a+1)(cid:1)
α · dG (vi, vj). Let Pj,i be a path between vj and vi in G(cid:48) such that all its edges have weight at
w(cid:48)(cid:0)v(a), v(a+1)(cid:1) > α · dG (vi, vj), it follows that (cid:8)v(a), v(a+1)(cid:9) /∈ Pj,i. Consider the cycle P (cid:48)
in G(cid:48). It is not necessarily a simple cycle, but since (cid:8)v(a), v(a+1)(cid:9) /∈ Pj,i, the edge (cid:8)v(a), v(a+1)(cid:9)
most α · dG (vi, vj). The existence of this path is guaranteed by Lemma 2. In particular, since
◦ Pj,i
◦ Pj,i. The heaviest edge of C clearly does not belong to

belongs to a simple cycle C contained in P (cid:48)

≤ α · dG (vi, vj).

13

vi=u0u1u2uaua+1v(a)v(a+1)us−2us−1vj=usV(a+1)V(a)Figure 2: The two paths P (cid:48) and Pj,i considered in the proof of Lemma 4. The path P (cid:48) is contained
in T (cid:48), while all edges of Pj,i have weight at most α · dG (vi, vj).
Pj,i, because the edge(cid:8)v(a), v(a+1)(cid:9) is heavier than each of them. Hence the heaviest edge belongs
⊆ T (cid:48). This is a contradiction to the assumption that T (cid:48) is an MST of G(cid:48). (See

to P (cid:48), but P (cid:48)
Figure 2 for an illustration). Hence dT

≤ α · dG (vi, vj). Finally,

(cid:0)v(a), v(a+1)(cid:1) = w(cid:48)(cid:0)v(a), v(a+1)(cid:1)
v(a), v(a+1)(cid:17)
v(a), v(a+1)(cid:17)

h−1(cid:88)

(cid:48)(cid:16)

=

w

(cid:16)

dT

h−1(cid:88)
h−1(cid:88)

a=0

a=0

dT (vi, vj) ≤

≤

a=0

α · dG (vi, vj) ≤ h · α · dG (vi, vj) ≤ α · (k − 1) · dG (vi, vj) .

Next, we analyze the terminal distortion of T .

Lemma 5. The terminal distortion of T is at most k · α + (k − 1) α2.
Proof. For each terminal vi ∈ K and any vertex u ∈ Vj, for some j ∈ {1, 2, . . . , k}, it holds that

dT (vi, u) ≤ dT (vi, vj) + dT (vj, u) ≤ α · (k − 1) · dG (vi, vj) + α · dG (vi, u)

≤ α · (k − 1) · (dG (vi, u) + dG (u, vj)) + α · dG (vi, u)
≤ α · (k − 1) · (dG (vi, u) + α · dG (vi, u)) + α · dG (vi, u)

= (cid:0)k · α + (k − 1) α2(cid:1)

· dG (vi, u) .

The last inequality is because dG (vj, u) ≤ dF (vj, u) = dF (K, u) ≤ α · dG (K, u) ≤ α · dG (vi, u).

Next, we analyze the lightness of T . A tree T = (K, E(cid:48), w(cid:48)) is called a Steiner tree for a graph
G = (V, E, w) if (1) V ⊆ K, (2) for any edge e ∈ E ∩ E(cid:48), the edge has the same weight in both G
and T , i.e. w (e) = w(cid:48) (e), and (3) for any pair of vertices u, v ∈ V it holds that dT (u, v) ≥ dG (u, v).
The minimum Steiner tree T of G, denoted SM T (G), is a Steiner tree of G with minimum weight.
It is well-known that for any graph G, w (SM T (G)) ≥ 1
2 M ST (G). (See, e.g., [GP68], Section 10.)
The next lemma bounds the lightness of the tree T .

14

Pj,iP0vi=v(0)vj=v(h)v(1)v(i)Lemma 6. The lightness of T is bounded by Ψ (T ) ≤ 2α + 1 + 2
α−1 .
Proof. The main challenge is to bound w (R). (Recall that R is the set of the representative edges
of T (cid:48).) Consider an edge {vi, vj} ∈ T (cid:48), and let {ui, uj} be its representative edge. Then dG (ui, uj) ≤
w(cid:48) (vi, vj). Also, since {vi, vj} ∈ T (cid:48)
⊆ E(cid:48), it follows that w(cid:48) (vi, vj) = dG(cid:48) (vi, vj). Hence dG (ui, uj) ≤
graph (cid:101)G as the complete graph on the vertex set K, with weights ˜w induced by dG (the shortest
dG(cid:48) (vi, vj). Therefore, w (R) ≤ w(cid:48) (T (cid:48)). Next we provide an upper bound for w(cid:48) (T (cid:48)). Deﬁne the
path distances in G). Let (cid:101)T be the M ST of (cid:101)G. We build a new tree ˆT by the following process:
1. Let ˆT ← (cid:101)T ;

2. For each {vi, vj} = ˜e ∈ ˜T :

} is connected;

(a) Let P˜e be a path from vi to vj which consists of edges in E(cid:48), such that for each edge e

in P˜e, w(cid:48) (e) ≤ α · dG (vi, vj) = α · ˜w (˜e); (By Lemma 2, such a path exists);

∈ P˜e be an edge such that ( ˆT \ {˜e}) ∪ {e(cid:48)

(b) Let e(cid:48)
(c) Set ˆT ← ( ˆT \ {˜e}) ∪ {e(cid:48)
In each step in the loop we replace an edge ˜e = {vi, vj} from (cid:101)T by an edge e(cid:48) from G(cid:48) of weight
(cid:17)
(cid:16)(cid:101)T
w(cid:48) (e) ≤ α · ˜w (˜e). Hence, the resulting tree ˆT is a spanning tree of G(cid:48), and w(cid:48)(cid:16)
Since T (cid:48) is the M ST of G(cid:48), it follows that w(cid:48) (T (cid:48)) ≤ w(cid:48)(cid:16)
(cid:17)(cid:17)
(cid:16)
(cid:17)
(cid:16)(cid:101)T
(cid:18)

. The M ST of G is a Steiner tree for
≤

˜G, so that ˜w
2 · w (M ST (G)). We obtain that

· w (M ST (G)), we conclude that

≤ w (M ST (G)). Also, ˜w

≤ 2 · α · w (M ST (G)) .

M ST

˜G

= ˜w

˜T

Since w (F ) ≤

w (R) ≤ w

(cid:17)
(cid:16)

ˆT

(cid:48)(cid:0)T

(cid:48)(cid:1)

(cid:17)

(cid:48)(cid:16)

ˆT

(cid:16)

(cid:17)(cid:17)

(cid:17)
(cid:16)

ˆT

≤ α · ˜w

.

≤ w

≤ α · ˜w

≤ 2· ˜w

SM T

˜G

SM T

˜G

(cid:17)(cid:17)

(cid:16)

(cid:17)

(cid:16)

(cid:16)

(cid:16)

1 + 2
α−1

(cid:17)

};

w (T ) = w (R ∪ F ) = w (R) + w (F ) ≤

2α + 1 +

· w (M ST (G)) .

(cid:19)

2

α − 1

6 Lower Bounds on Distortion-Lightness Tradeoﬀs for a Single

Tree

In this section we provide lower bounds on the terminal distortion and lightness of k-terminal trees.
For each lower bound we start with showing a lower bound for graphs and proceed to showing a
lower bound for metric spaces. (Observe that the latter is more general.) The lower bounds exhibit
similar tradeoﬀs in both cases, while the analysis is signiﬁcantly simpler for graphs than for metric
spaces.

15

6.1 A lower bound for terminal distortion

Theorem 6. For any k there is a weighted graph G with n = 2k vertices and k terminals such that
any spanning tree has terminal distortion at least 2k − 1.
Proof. Consider the cycle graph C2k such that the terminals and the non-terminal vertices alternate
(as usual V (cid:48) stands for the set of terminals). Any spanning tree T of C2k is obtained by removing
a single edge {vi, vi+1}. Observe that either vi or vi+1 is a terminal. Hence the terminal distortion
is at least

dC2k\{vi,vi+1} (vi, vi+1)

dC2k (vi, vi+1)

= 2k − 1.

Remark 1. The same result for any n > 2k follows by adding additional n − 2k non-terminal
vertices to the graph, and connecting them all to an arbitrary vertex of C2k. In the resulting graph
every spanning tree has terminal distortion at least 2k − 1.

Next we extend Theorem 6 to metric spaces.

Theorem 7. For any k there is a metric space (M, d) with n = 2k vertices and k terminals such
that any spanning tree for (M, d) has terminal distortion at least 2k − 1.
Proof. Let M be the metric generated by the cycle graph C2k, where there are k terminals and the
terminals and the non-terminal vertices alternate. In [Gup01b], Lemma 7.1, Gupta showed that the
distortion of every spanning tree of M is at least n− 1 = 2k − 1. Moreover, the maximal distortion
is achieved by an original edge e of C2k. One of the two endpoints of e is a terminal. Hence the
terminal distortion of any spanning tree for M is at least 2k − 1.
Remark 2. One can extend Theorem 7 to n > 2k by adding additional n−2k non-terminal vertices
to M at a large distance from all the terminals. For a spanning tree T of M , if some shortest path
between a terminal v and a vertex u which is belongs to C2k uses at least one of the new vertices
then the terminal distortion is too high. Hence if the terminal distortion is small, the tree restricted
to C2k is connected. Hence by Theorem 7 it follows that the terminal distortion is at least 2k − 1.
6.2 A lower bound on the lightness in graphs

In this section we prove a lower bound on the tradeoﬀ between terminal distortion and lightness of
k-terminal trees.
Theorem 8. For any positive integer parameters k, n and  > 0 such that k ≤ 
2 n, there exists a
graph G with N = (n + 1) k vertices, such that any spanning tree T for G with terminal distortion

(cid:1) has lightness at least Ω(cid:0) 1

(cid:1).

at most (2k − 1)(cid:0)1 + 

k2

Proof. Consider the following graph G on N = k · (n + 1) vertices. There are k terminals V (cid:48) =
{v0, v1, ..., vk−1} in G. For every index i ∈ [0, k − 1], there is a n-vertex path Pi. All edges in these
paths have unit weight. Also, for each index i ∈ [0, k − 1], both vi and vi+1(mod k) are connected
to every vertex in Pi by edges of weight w, where w > 1 is a parameter that will be determined
later. (To simplify the notation we will henceforward write vi+1 instead vi+1(mod k). Generally,



16

Figure 3: An illustration of the graph used in the proof of Theorem 8. The k terminals are depicted
by the big dots. The vertices vi and vi+1 are connected to each vertex of an n-vertex path Pi by
edges of weight w.

all the arithmetic operations on indexes of vertices v0, ..., vk−1 and paths P0, ..., Pk−1 are performed
modulo k.) See Figure 3 for an illustration.

Each spanning tree of G contains N − 1 = k + kn − 1 edges. There are k · (n − 1) edges
of unit weight, and all the other edges have weight w. Hence the weight of the MST is at least
k (n − 1)·1+(2k − 1)·w. It is easy to verify that there actually exists a spanning tree of that weight.
w(2k−1) , every tree with terminal distortion at most (2k − 1) (1 + β)
We will show that for any β <
has weight at least Ω(nw).

1

Let T be a spanning tree for G with terminal distortion at most (2k − 1) (1 + β), for some
β > 0. There exists an index i such that the path between vi and vi+1 in T does not use vertices
from the path Pi. (Otherwise there is a cycle in T that passes through v0, . . . , vk−1.) Without loss
of generality assume that i = 0. Therefore, dT (v0, v1) ≥ (k − 1) · 2w.
Claim 7. For every vertex u in P0, if β <

(2k−1)w then either (v0, u) or (v1, u) is an edge of T .

1

Proof. Without loss of generality the shortest path from v0 to u goes through v1. Assume for
contradiction that the edge (v1, u) does not belong to T . Then the terminal distortion is at least

dT (v0, u)
dG (v0, u)

=

dT (v0, v1) + dT (v1, u)

dG (v0, u)

1
w

= 2k − 1 +
> (2k − 1) (1 + β) ,

= (2k − 1)

(cid:18)

≥

1 +

(2k − 1) w

(k − 1) 2w + w + 1

(cid:19)

w
1

contradiction.

By Claim 7, β <

1

terminal distortion at most (2k − 1) (1 + β), with β <
k(n−1)+(2k−1)w . We set w = k
 . Then the condition β <

(2k−1)w implies that w (T ) ≥ n · w. Hence for every k-terminal tree T with
w(M ST ) ≥
(2k−1)k . This

(2k−1)w , it holds that Ψ (T ) = w(T )

(2k−1)w translates to β <

nw

1

1



17

1wwwwww11wwww11wwww11wwww11wwww11ww1condition implies that

n k


=



nk

nk

nk + 2k2 =

n

n + 2k

.

Ψ (T ) =

As k ≤ 

k(n − 1) + (2k − 1) k

k(n − 1) + (2k − 1) k ≥
O(cid:0) 1
(cid:1). In the graph G from the above proof lightness smaller than 1
gap of O(cid:0)k2(cid:1) between the upper and lower bounds.

2 n we obtain Ψ (T ) ≥ 1
2 .
(cid:17)

at least (2k − 1)

Our algorithm from Theorem 5 guarantees terminal distortion (2k − 1) (1 + O ()) and lightness
 implies terminal distortion
. Hence our bounds are tight for k = O (1), but generally there is a

1 +





(2k−1)k

(cid:16)

In Appendix A we extend this lower bound to metric spaces.

7 Probabilistic Embedding into Ultrametrics with Strong Termi-

nal Distortion

In this section we show our terminal variant of the result of [FRT04]. We note that in a companion
paper [EFN15] a more general result is shown, and we give the full details here for completeness.
Recall that an ultrametric (U, d) is a metric space satisfying a strong form of the triangle
inequality, that is, for all x, y, z ∈ U , d(x, z) ≤ max{d(x, y), d(y, z)}. The following deﬁnition is
known to be an equivalent one (see [BLMN05]).

Deﬁnition 2. An ultrametric U is a metric space (U, d) whose elements are the leaves of a rooted
labeled tree T . Each z ∈ T is associated with a label Φ (z) ≥ 0 such that if q ∈ T is a descendant of
z then Φ (q) ≤ Φ (z) and Φ (q) = 0 iﬀ q is a leaf. The distance between leaves z, q ∈ U is deﬁned as
dT (z, q) = Φ (lca (z, q)) where lca (z, q) is the least common ancestor of z and q in T .

We now deﬁne probabilistic embeddings with terminal distortion. For a class of metrics Y, a
distribution D over embeddings fY : X → Y with Y ∈ Y has expected terminal distortion α if
each fY is non-contractive (that is, for all u, w ∈ X and Y ∈ supp(D), it holds that dX (u, w) ≤
dY (fY (u), fY (w))), and for all v ∈ K and u ∈ X,

EY ∼D[dY (fY (v), fY (u))] ≤ α · dX (v, u) .

The notion of strong terminal distortion translates to this setting in the obvious manner.

Let (X, d) be a metric on n points, and K ⊆ X the set of terminals of size |K| = k. Theorem 1
combined with [FRT04] gives an embedding to a distribution over ultrametrics with expected
terminal distortion O(log k). However, this does not give any guarantee on the distortion of two
non-terminal points.13 In order to obtain strong terminal distortion, we modify the FRT algorithm,
so that it gives ”preference” to the terminals. In particular, in the heart of the FRT algorithm is a
construction of a random partitioning scheme, based on [CKR04], whose purpose is to decompose
the metric to bounded diameter pieces, such that the probability of separating pairs is ”suﬃciently
small”. The partition is created by choosing a random permutation of X, a random radius in some
speciﬁed interval, and then creating clusters as balls of the chosen radius, in the order given by the
permutation. To obtain improved expected distortion guarantees for the terminals, we enforce them

13In fact, it is not hard to verify that this approach may lead to unbounded distortion.

18

to be the ﬁrst k points of the permutation. We show that this restriction improves dramatically
the expected distortion of any pair that contains a terminal, while all the other pairs suﬀer only a
factor of 2 in the expected distortion bound.

Theorem 9. Given a metric space (X, d) of size |X| = n and a subset of terminals K ⊆ X of size
|K| = k, there exists a distribution over embeddings of X into ultrametrics with strong terminal
distortion (O(log k), O(log n)).

Proof. Let ∆ be the diameter of X. We assume w.l.o.g that the minimal distance in X is 1, and let
δ be the minimal integer so that ∆ ≤ 2δ. We shall create a hierarchical laminar partition, where for
each i ∈ {0, 1, . . . , δ}, the clusters of level i have diameter at most 2i, and each of them is contained
in some level i + 1 cluster. Recall Deﬁnition 2. The ultrametric is built in the natural manner,
the root corresponds to the level δ cluster which is X, and each cluster in level i corresponds to
an inner node of the ultrametric with label 2i, whose children correspond to the level i − 1 clusters
contained in it. The leaves correspond to singletons, that is, to the elements of X. Clearly, the
ultrametric will dominate (X, d).14

In order to deﬁne the partition, we sample a permutation uniformly at random from the set of
permutations that have the terminals as the preface (there are k!· (n− k)! such permutations), and
sample a number β ∈ [1, 2] uniformly at random. In each step, each vertex x chooses the vertex
u with minimal value according to π among the vertices of distance at most βi = β · 2i−2 from x,
and joins the cluster of u. Note that a vertex may not belong to the cluster associated with it, and
some clusters may be empty (which we can discard). The description of the hierarchical partition
appears in Algorithm 1.

Algorithm 1 Modified FRT(X, K)
1: Choose a random permutation π of X such that π−1 (K) = [k].
2: Choose β ∈ [1, 2] randomly by the distribution with the following probability density function
3: Let Dδ = X; i ← δ − 1.
4: while Di+1 has non-singleton clusters do
5:

p (x) = 1

x ln 2 .

Set βi ← β · 2i−2.

for l = 1, . . . , n do

6:

7:

8:

9:

for every cluster S in Di+1 do

Create a new cluster in Di, consisting of all unassigned vertices in S closer than βi to
π (l).
end for

10:

end for
i ← i − 1.
11:
12: end while

Let T denote the (random) ultrametric created by the hierarchical partition of Algorithm 1,
and dT (u, v) the distance between u and v in T . Consider the clustering step at some level i,
where clusters in Di+1 are picked for partitioning. In each iteration l, all unassigned vertices z
such that d (z, π(l)) ≤ βi, assign themselves to the cluster of π(l). Fix an arbitrary pair {v, u}. We
14A metric d(cid:48) on X dominates d if for all x, y ∈ X, d(x, y) ≤ d(cid:48)(x, y).

19

T (v, u) to be(cid:80)
(cid:80)

say that center w settles the pair {v, u} at level i, if it is the ﬁrst center so that at least one of u
and v gets assigned to its cluster. Note that exactly one center w settles any pair {v, u} at any
particular level. Further, we say that a center w cuts the pair {v, u} at level i, if it settles them at
this level, and exactly one of u and v is assigned to the cluster of w at level i. Whenever w cuts a
pair {v, u} at level i, dT (v, u) is set to be 2i+1 ≤ 8βi. We charge this length to the vertex w and
deﬁne dw
i 1 (w cuts {v, u} at level i)· 8βi (where 1 (·) denotes an indicator function).
w∈X dw
Clearly, dT (v, u) ≤
We now arrange the vertices of K in non-decreasing order of their distance from the pair {v, u}
(breaking ties arbitrarily). Consider the sth terminal ws in this sequence. We now upper bound
the expected value of dws
T (v, u) for an arbitrary ws. W.l.o.g assume that dX (ws, v) ≤ dX (ws, u).
For a center ws to cut {v, u}, it must be the case that:

T (v, u).

1. dX (ws, v) ≤ βi < dX (ws, u) for some i.
2. ws settles {v, u} at level i.

dx
x·ln 2 .
Note that for each x ∈ [dX (ws, v) , dX (ws, u)), the probability that βi ∈ [x, x + dx) is at most
Conditioning on βi taking such a value x, any one of w1, . . . ws can settle {v, u}, and the probability
that ws is ﬁrst in the permutation among w1, . . . ws is 1

s . Thus we obtain,

E[dws

T (v, u)] ≤

dx
x ln 2 ·

1
s

8x ·

=

8(dX (ws, u) − dX (ws, v))

s · ln 2

16
s · dX (v, u) .

≤

(3)

The crucial observation is that if y ∈ X \ K, and at least one of v, u is a terminal, w.l.o.g v ∈ K,
then y cannot settle {v, u}. The reason is that v always appears before y in π, so v will surely be
assigned to a cluster when it is the turn of y to create a cluster. This leads to the conclusion that
for all v ∈ K and u ∈ X
E[dT (v, u)] ≤

= O(log k) · dX (v, u) .

≤ 16dX (v, u)

k(cid:88)

k(cid:88)

T (v, u)]

E[dws

1
s

(3)

s=1

s=1

It remains to bound the expected distortion of non-terminal pairs, so ﬁx some v, u ∈ X \ K.
Arrange the vertices y1, . . . , yn−k of X\K according to their distance from {v, u}, in non-decreasing
order. A similar reasoning as above gives the bound of (3) for the sth vertex ys in this ordering to
cut {v, u} (recall that the permutation over the non-terminals is uniformly distributed). In fact,
the bound is even slightly loose, because we disregard the possibility that a terminal will settle
{v, u}. We conclude that

(cid:90) dX (ws,u)

dX (ws,v)

E[dT (v, u)] ≤

E[dws

T (v, u)] +

E[dys

T (v, u)]

k(cid:88)

s=1

n−k(cid:88)
n−k(cid:88)

s=1

(cid:33)

(cid:32) k(cid:88)

+

1
s

1
≤ 16dX (v, u)
s
= O(log k + log n) · dX (v, u)
= O(log n) · dX (v, u) .

s=1

s=1

20

8 Probabilistic Embedding into Trees with Terminal Congestion

In this section we focus on embeddings into trees that approximate capacities of cuts, rather than
distances between vertices. This framework was introduced by R¨acke [R¨02] (for a single tree), and
in [R¨ac08] he showed how to obtain capacity preserving probabilistic embedding from a distance
preserving one, such as the ones given by [FRT04]. Later, [AF09] showed a complete equivalence
between these notions in random tree embeddings. Here we show our terminal variant of these
results. Informally, we construct a distribution over capacity-dominating trees (each cut in each
tree is at least as large as the corresponding cut in the original graph), and for each edge, its expected
congestion is bounded accordingly, with an improved bound for edges containing a terminal.

The path mapping relevant to the rest of this section is constructed as follows: given a tree

We next elaborate on the notions of capacity and congestion, and their relation to distance
and distortion, following the notation of [AF09]. Given a graph G = (V, E), let P be a collection
of multisets of edges in G. A map M : E → P, where M (e) is a path between the endpoints of
e, is called a path mapping (the path is not necessarily simple). Denote by Me(cid:48)(e) the number of
appearances of e(cid:48) in M (e).
∈ ET let PG(e(cid:48)) be a shortest path
T = (V, ET ) (not necessarily a subgraph), for each edge e(cid:48)
between the endpoints of e(cid:48) in G (breaking ties arbitrarily), and similarly for e ∈ E, let PT (e) be
the unique path between the endpoints of e in T . Then for an edge e ∈ E, where PT (e) = e(cid:48)
2 . . . e(cid:48)
1e(cid:48)
r,
the path M (e) is deﬁned as M (e) = PG(e(cid:48)
r) (where ◦ denotes concatenation).
distT (e) =(cid:80)
In what follows ﬁx a tree T , and let M be the path mapping of T .
Fix a weight function w : E → R+, and a capacity function c : E → R+. For an edge e ∈ E,
e(cid:48)∈E Me(e(cid:48))·c (e(cid:48))

e(cid:48)∈E Me(cid:48)(e)·w (e(cid:48)) is the weight of the path M (e), and loadT (e) =(cid:80)

2)◦···◦ PG(e(cid:48)

1)◦ PG(e(cid:48)

w(e)

to be the distortion of e in T , and congT (e) = loadT (e)

is the sum (with multiplicities) of the capacities of all the edges whose path is using e. Deﬁne
distortionT (e) = distT (e)
is the congestion
of e. Note that if T is a subgraph of G, then distT (e) is the length of the unique path between
the endpoints of e, while loadT (e) is the total capacity of all the edges of E that are in the cut
obtained by deleting e from T (for e /∈ T , loadT (e) = 0).
Deﬁnition 3. Let K ⊆ V be a set of terminals of size k, and let EK ⊆ E be the set of edges that
contain a terminal. We say that a distribution D over trees has strong terminal congestion (α, β)
if for every e ∈ EK.

c(e)

congD(e) := ET∼D[congT (e)] ≤ α ,

and for any e ∈ E, congD(e) ≤ β.

A tight connection between distance preserving and capacity preserving mappings was shown

in [AF09]. We generalize their theorem to the terminal setting in the following manner.

Theorem 10. The following statements are equivalent for a graph G:

• For every possible weight assignment G admits a probabilistic embedding into trees with strong

terminal distortion (α, β).

• For every possible capacity assignment G admits a probabilistic embedding into trees with

strong terminal congestion (α, β).

21

A corollary of Theorem 10, achieved by applying Theorem 9 using the algorithmic framework

described in [AF09], is:15

Proof of Theorem 10. Assuming the ﬁrst item holds we prove the second. Let κ(e) =

Corollary 8. For any graph G = (V, E) on n vertices, a set K ⊆ V of k terminals, and any capacity
function, there exists a distribution over trees with strong terminal congestion (O(log k), O(log n)).
Moreover, there is an eﬃcient procedure to sample from the distribution.

(cid:26) 1/α
e ∈ EK
1/β otherwise
in [AKPW95]), it suﬃces to show that for any coeﬃcients {λe}e∈E with λe ≥ 0 and(cid:80)
Given any capacity function c : E → R+, we would like to show that there exists a distribution
(cid:48) such that for any e ∈ E, ET∼D(cid:48)[κ(e) · congT (e)] ≤ 1. By applying the minimax principle (as
D
e∈E λe = 1,
there exists a single tree T such that(cid:88)

.

(4)

λe · κ(e) · congT (e) ≤ 1 .

e∈E

To this end, deﬁne the weights w(e) = κ(e)· λe
D over trees such that for any e ∈ E,

c(e) , and by the ﬁrst assertion there exists a distribution

By applying the minimax again, there exists a single tree T such that

ET∼D[κ(e) · distortionT (e)] ≤ 1 .
(cid:88)

λe · κ(e) · distortionT (e) ≤ 1 .

e∈E

Now,

1 ≥

=

=

=

=

e∈E

e∈E

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

e∈E

e(cid:48)∈E

e(cid:48)∈E

λe · κ(e) · distortionT (e)

w(e)

(cid:80)
e(cid:48)∈E Me(cid:48)(e) · w (e(cid:48))
(cid:80)
e(cid:48)∈E Me(cid:48)(e) · κ(e(cid:48)) · λe(cid:48)/c(e(cid:48))
(cid:80)

κ(e) · λe/c(e)
e∈E Me(cid:48)(e) · c(e)
c(e(cid:48))
(cid:48)
) · congT (e

) ·

) ,

λe · κ(e) ·

λe · κ(e) ·
(cid:48)

λe(cid:48) · κ(e

(cid:48)

λe(cid:48) · κ(e

which concludes the proof of (4). The second direction is symmetric.

15Even though the embedding of Theorem 9 is into ultrametrics, which contain Steiner vertices, these can be

removed while increasing the distortion of each pair by at most a factor of 8 [Gup01a].

22

Capacity Domination Property. As [R¨ac08, AF09] showed, under the natural capacity
assignment, any tree T supported by the distribution of Theorem 10 has the following property:
Any multi-commodity ﬂow in G can be routed in T with no larger congestion. We would like to
show this explicitly, using the language of cuts, as this will be useful for the algorithmic applications.
∈ ET let ST,e(cid:48) ⊆ V be the cut obtained by

Fix some tree T = (V, ET ), and for any edge e(cid:48)

deleting e(cid:48) from T . Deﬁne the capacities CT : ET → R+ by

(cid:88)

(cid:48)

CT (e

) =

c(e) ,

e∈E(ST,e(cid:48) , ¯ST,e(cid:48) )

where E(S, ¯S) denotes the set of edges in the graph crossing the cut S. (Observe that for spanning
trees, CT (e) = loadT (e).)

Lemma 9. For any graph G = (V, E) and tree T = (V, ET ) with capacities as deﬁned above, for

any set S ⊆ V it holds that(cid:88)

(cid:88)

(cid:88)

c(e) ≤

(cid:48)
CT (e

) ≤

e∈E(S, ¯S)

e(cid:48)∈ET (S, ¯S)

e∈E(S, ¯S)

loadT (e) .

(5)

Proof. We begin with the left inequality. For any graph edge e ∈ E(S, ¯S), there exists a tree edge
e(cid:48)
∈ PT (e), because the path PT (e) must cross the cut. Since removing e(cid:48)
∈ ET (S, ¯S) such that e(cid:48)
from T separates the endpoints of e, CT (e(cid:48)) will contain the term c(e). We conclude that

For the right inequality, consider an edge e ∈ E, and note that for any tree edge e(cid:48)

∈ ET such
∈ E(ST,e(cid:48), ¯ST,e(cid:48)) will have e ∈ M (e(cid:48)(cid:48)) and thus contribute to loadT (e)

that e ∈ PG(e(cid:48)), every edge e(cid:48)(cid:48)
(perhaps multiple times, due to diﬀerent e(cid:48)). This implies that

(cid:88)

c(e) ≤

e∈E(S, ¯S)

e(cid:48)∈ET (S, ¯S)

(cid:48)
CT (e

) .

(cid:88)

(cid:88)

Next, observe that any tree edge e(cid:48)
that e ∈ PG(e(cid:48)). This suggests that

(cid:88)

e∈E(S, ¯S)

loadT (e) =

{e(cid:48)∈ET : e∈PG(e(cid:48))}

(cid:48)

) .

CT (e

(6)

∈ ET (S, ¯S) must have at least one graph edge e ∈ E(S, ¯S) such

(cid:88)

(cid:88)
(cid:88)
{e(cid:48)∈ET :e∈PG(e(cid:48))}
(cid:48)
(cid:88)
|E(S, ¯S) ∩ PG(e

e∈E(S, ¯S)

e(cid:48)∈ET

(cid:48)

CT (e

) .

(cid:48)

)

CT (e

(cid:48)
)| · CT (e

)

loadT (e)

(6)
=

=

≥

e(cid:48)∈ET (S, ¯S)

23

9 Strong Terminal Embedding of Graphs into a Distribution of

Spanning Trees

In this section we consider strong terminal embedding of graphs into a distribution over their
spanning trees. We will show ( ˜O(log k), ˜O(log n))-strong terminal distortion as promised in the
introduction.

Theorem 11. Given a weighted graph G = (V, E, w) on n vertices, and a subset of k termi-
nals K ⊆ V , there exists a distribution over spanning trees of G with strong terminal distortion
( ˜O(log k), ˜O(log n)).

We will use the framework of [AN12], in particular their petal decomposition structure in order
to obtain the distribution over spanning trees. Roughly speaking, it is an iterative method to
build a spanning tree. In each level, the current graph is partitioned into smaller diameter pieces,
called petals, and a single central piece, which are then connected by edges in a tree structure.
Each of the petals is a ball in a certain metric. The main advantage of this framework, is that it
produces a spanning tree whose diameter is proportional to the diameter of the graph, but allows
very large freedom for the choice of radii of the petals. Speciﬁcally, if the graph diameter is ∆, each
radius can be chosen in an interval of length ≈ ∆. Intuitively, if a pair is separated by the petal
decomposition, then its distance in the tree will be O(∆). So we would like a method to choose
the radii, that will give the appropriate bounds both on pairs containing a terminal, and for all
other pairs, simultaneously. We note that in the star-partition framework of [EEST08] (used also
in [ABN08]), the tree radius increases introduces a factor to the distortion that inherently depends
on n, which does not seem to allow terminal distortion that depends on k alone.

In order to ”take care” of pairs containing a terminal, we will need to somehow give the terminals
a ”preference” in the decomposition. Since the [CKR04, FRT04] style partitioning scheme cannot
work in a graph setting (because it does not produce strong diameter clusters, and the cluster’s
center may not be contained in it), we turn to the partitions based on truncated exponential
distribution as in [Bar96, Bar04, ABN08]. To implement the ”terminal preference” idea, we ﬁrst
build petals with the terminals as centers, and only then build petals for the remaining points.
There are few technical subtleties needed to assure that pairs containing a terminal suﬀer small
expected distortion. By a careful choice for the petal’s center and the interval from which to choose
the radius, we guarantee that in a level where no terminals are separated, none of the relevant
balls around terminals are in danger of being cut. Using that the radius of clusters decreases
geometrically, we conclude that each ball is ”at risk” in at most O(log k) levels.

9.1 Petal decomposition description

In this section we present the petal decomposition algorithm, and quote some of its properties. We
do not provide full proofs of these properties, these can be found in [AN12]. The petals are built
using an alternative metric on the graph.

Deﬁnition 4 (Cone metric). Given a graph G = (V, E, w), a subset X ⊆ V and points x, y ∈ X, de-
ﬁne the cone-metric ρ = ρ(X, x, y) : X 2 → R+ as ρ(u, v) = |(dX (x, u) − dX (y, u)) − (dX (x, v) − dX (y, v))|.

This is actually a pseudo metric. For a cone metric ρ = ρ(X, x, y),

ρ(y, u) = |(dX (x, u) − dX (y, u)) − (dX (x, y) − dX (y, y))| = dX (x, y) + dX (y, u) − dX (x, u)

24

is the diﬀerence between the shortest path from x to u in G[X] and the shortest path from x to
u in G[X] that goes through y.16 Therefore, the ball B(X,ρ)(y, r) in the cone metric ρ = ρ(X, x, y)
centered in y with radius r, contains all such vertices u. Denote by Pxy(G) the shortest17 path
between x and y in G. If Y is a subset of the vertices of G, we denote by Pxy(Y ) the shortest path
from x to y in G[Y ].

(cid:83)
A petal is a union of balls in the cone metric. In the create-petal algorithm, while working
in a subgraph G[Y ] with two speciﬁed vertices: a center x0 and a target t, we deﬁne Wr (Y, x0, t) =
p∈Px0t: dY (p,t)≤r B(Y,ρ(Y,x0,p))(p, r−dY (p,t)
) which is union of balls in the cone metric, where any
vertex p in the shortest path from x0 to t of distance at most r from t is a center of a ball with
radius r−dY (p,t)
. We will often omit the parameters and write just Wr if Y, x0 and t are clear from
the context. The next claim, which is implicit in [AN12], states that Wr is monotone (in r) and
that Wr+4l contains the ball with radius l around Wr (where the ball is taken in the shortest path
metric in G[Y ]).

Claim 10. For Wr (Y, x0, t) =(cid:83)
1. Wr is monotone in r, i.e., for r ≤ r(cid:48) it holds that Wr ⊆ Wr(cid:48).
2. For every y ∈ Wr and l, the ball BY (y, l) contained in Wr+4l, i.e., ∀z, dY (y, z) ≤ l ⇒ z ∈

p∈Px0t: dY (p,t)≤r B(Y,ρ(Y,x0,p))(p, (r − dY (p, t))/2)

2

2

Wr+4l

Next, we quote some properties of the petal decomposition algorithm proved in [AN12]. Their
proofs remain valid even after our modiﬁcation, because the algorithm allows for arbitrary choice
of targets after the ﬁrst petal is built, and allows any radius in the appropriate interval. For a
subset X ⊆ V , let ∆X,x0 denote the radius of G[X] with respect to x0 (the maximal distance from
x0 in G[X]). We often omit the subscript x0 if it is clear from the context.

Fact 1. For a graph G, a vertex set X, and some vertices x0, t ∈ X, petal-decomposition (G [X] , x0, t, K)
returns as output the sequence (X0, . . . , Xs,{y1, x1} , . . . ,{ys, xs} , t0, . . . , ts) such that for each j ≤
s, ∆Xj ,xj ≤ 7∆X,x0/8.
Fact 2. The hierarchical-petal-decomposition algorithm returns a tree.
Fact 3. Every edge e ∈ E can have its weight multiplied by 1
of the algorithm. 18

2 at most once throughout the execution

Fact 4. For a graph G and tree a T created by the hierarchical-petal-decomposition,

∆T ≤ 4∆G.

Fact 5. Let 1 ≤ j ≤ s be an integer and z ∈ Yj,19 then Px0z (X) ⊆ G [Yj].
16For X ⊆ V , G[X] is the induced graph on the vertices of X.
17For simplicity, we assume that for each pair of vertices there is a unique shortest path in G.
18This multiplication may happen only for edges in the special paths Pxj ,tj for a petal Xj which is not the ﬁrst
special petal. Note that after the creation of Xj, tj will be the target for the ﬁrst special petal in the decomposition
of Xj which will ensure that the weights of the edges in Pxj ,tj won’t decrease again.

19Yj is deﬁned in the petal-decomposition procedure.

25

From Fact 4 we can deduce that if the radius of G was ∆ (with respect to some vertex x0) then
the diameter of the tree created by the hierarchical petal decomposition is bounded by 8∆. In lines
15 and 24 of the petal-decomposition procedure we divide the weight of some edges by 2. By
Fact 3 it can happen to any edge at most once, so in the analysis of the distortion we will ignore
this factor (for simplicity).

For completeness, we present the full petal decomposition algorithm. We illustrate below the

main changes compared to the version presented in [AN12].

1. The order of choosing targets in petal-decomposition. In the original algorithm the targets
were chosen arbitrarily, while in our version we ﬁrst choose terminals, and only when there
are no terminals left suﬃciently far from x0, we choose the other vertices. The purpose of this
ordering, is to ensure that only the terminal petals may cut certain balls around the other
terminals.

2. The segments sent to create petal procedure. In line 22 in petal-decomposition we send
an interval of a diﬀerent size from the original algorithm. The purpose of this change is to
ensure that petals which are created in line 22 are far away from any non-covered terminal.

3. We stop constructing petals when all points outside BX (x0, 7∆/8) have been clustered (rather
than BX (x0, 3∆/4)). The purpose is to ensure that small balls around terminals in X0 are
not cut.

4. The choice of the radius in the create-petal procedure is done by sampling according to a
truncated exponential distribution with parameter λ. The parameter is computed using the
density of terminals or other vertices around the target depending on whether the petal will
contain a terminal.

5. The interval in which we choose the radius is determined using the Reform-Interval proce-
dure. The purpose of this is to ensure that certain balls around terminals may be cut only
at levels when some terminals are separated (note that there can be at most k such levels).
The new interval returned is guaranteed to be contained in the original one.

Algorithm 2 T = hierarchical-petal-decomposition(G[X], x0, t, K)
1: if |X| = 1 then
return G[X].
2:
3: end if
4: Let (X0, . . . , Xs, (y1, x1), . . . , (ys, xs), t0, . . . , ts) = petal-decomposition(G[X], x0, t, K);
5: for each j ∈ [0, . . . , s] do
6:
7: end for
8: Let T be the tree formed by connecting T0, . . . , Ts using the edges {y1, x1}, . . . ,{ys, xs};

Tj = hierarchical-petal-decomposition(G[Xj], xj, tj, K ∩ Xj);

26

Algorithm 3 (X0, . . . , Xs,{y1, x1}, . . . ,{ys, xs}, t0, . . . , ts) = petal-decomposition(G[X], x0, t, K)
1: Let ∆ = ∆X,x0; Let Y0 = X; Set j = 1;
2: if dX (x0, t) ≥ 5∆/8 then

3:

4:

5:

Let (X1, x1) = create-petal(X, t, x0, [dX (x0, t) − 5∆/8, dX (x0, t) − ∆/2], K);
Let Y1 = Y0 \ X1;
Let y1 be the neighbor of x1 on Px0t (the one closer to x0);
Set t0 = y1, t1 = t; j = 2;

set t0 = t.

6:
7: else
8:
9: end if
10: Creating the terminal petals:
11: while K ∩ Yj−1 \ BX (x0, 3∆/4) (cid:54)= ∅ do

Let tj ∈ Yj−1 ∩ K be an arbitrary terminal satisfying dX (x0, tj) > 3∆/4;
Let (Xj, xj) = create-petal(Yj−1, tj, x0, [0, ∆/8], K);
Yj = Yj−1 \ Xj;
For each edge e ∈ Pxj tj , set its weight to be w(e)/2;
Let yj be the neighbor of xj on Px0tj (the one closer to x0);
Let j = j + 1;

12:

13:

14:

15:

16:

21:

22:

23:

24:

25:

17:
18: end while
19: Creating the non-terminal petals:
20: while Yj−1 \ BX (x0, 7∆/8) (cid:54)= ∅ do

Let tj ∈ Yj−1 be an arbitrary vertex satisfying dX (x0, tj) > 7∆/8;
Let (Xj, xj) = create-petal(Yj−1, tj, x0, [0, ∆/32],∅);
Yj = Yj−1 \ Xj;
For each edge e ∈ Pxj tj , set its weight to be w(e)/2;
Let yj be the neighbor of xj on Px0tj (the one closer to x0);
Let j = j + 1;

26:
27: end while
28: Let s = j − 1;
29: Creating the stigma X0:
30: Let X0 = Ys;

9.2 Analysis

In what follows, ﬁx a cluster X with center x0, a target t, and the set of terminals K contained in X.
Let (X0, . . . , Xs,{y1, x1}, . . . ,{ys, xs}, t0, . . . , ts) be the result of applying petal-decomposition(G[X], x0, t, K).
The following claim will be useful for bounding the number of levels in which a relevant ball around
a terminal is in danger of being cut.

Claim 11. The following assertions hold true:

• If X1 is a petal created at line 3 of petal-decomposition and K ∩ X1 = ∅, then for all

v ∈ K, BX (v, ∆/160) ∩ X1 = ∅.

• If Xj is a petal created at lines 3 or 13 of petal-decomposition and K ⊆ Xj, then for all

v ∈ K, BX (v, ∆/160) ⊆ Xj.

27

1: Wr =(cid:83)

2: if K (cid:54)= ∅ then

Algorithm 4 (W, x) = create-petal(X, Y, t, x0, [lo, hi], K)
p∈Px0t: dY (p,t)≤r B(Y,ρ(Y,x0,p))(p, (r − dY (p, t))/2);

[lo, hi] = Reform-Interval(Y, t, x0, [lo, hi], K);
Lk = (cid:100)log log k(cid:101); R = lo − hi;
Let 1 ≤ q ≤ Lk be the minimal integer satisfying
lo + (q − 1)R/Lk, b(cid:48) = a + R/2Lk, χ =
Set λ = (2 ln ˆχ)/(b(cid:48)

|X|k+1
|Wa|k

− a) = (4Lk ln ˆχ)/R = (160Lk ln ˆχ)/∆;

, ˆχ = max{χ, e};

(cid:12)(cid:12)Wlo+qR/Lk

(cid:12)(cid:12)k ≤

2|X|k

2log1−q/Lk k

; Set a =

3:

4:

5:

6:
7: else
8:

9:

Ln = (cid:100)log log n(cid:101); R = lo − hi;
Let 1 ≤ q ≤ Ln be the minimal integer satisfying
1)R/Ln, b(cid:48) = a + R/2Ln, χ =
Set λ = (2 ln ˆχ)/(b(cid:48)

|X|+1
|Wa| , ˆχ = max{χ, e};

− a) = (4Ln ln ˆχ)/R = (27Ln ln ˆχ)/∆;

10:
11: end if

(cid:12)(cid:12)Wlo+qR/L

(cid:12)(cid:12) ≤

2|X|n

2log1−q/Ln n

; Set a = lo + (q −

has the following density function: f (r) = λ·e−λr

12: Sample r ∈ [a, b(cid:48)] according to the truncated exponential distribution with parameter λ, which
13: Let r(cid:48)
≤ r be the maximum value such that there exists a point pr(cid:48) of distance r(cid:48) from t on
Px0t;

e−λ·a−e−λ·b(cid:48) ;

14: return (Wr, pr(cid:48));

• If Xj is a petal created at line 22 of petal-decomposition, then for all v ∈ K ∩ Yj−1,

BX (v, ∆/16) ∩ Xj = ∅.

Proof. Let Wr be as deﬁned in line 1 of create-petal when forming the petal Xj. For the ﬁrst
assertion, note that the condition of line 6 in reform-interval must be satisﬁed, no terminals are
in Wlo+2α/5, and thus hi(cid:48) is set to lo+α/5 (we use α as in reform-interval, the size of the interval
sent by create-petal.) Now, for every u ∈ X1 ⊆ Whi(cid:48) and v ∈ K, dX (u, v) ≥ α/20 = ∆/160, as
otherwise, Claim 10 implies that v ∈ Whi(cid:48)+4·α/20 = Wlo+2α/5, contradiction.
For the second assertion, observe that j ∈ {1, 2}, because X2 certainly contains a terminal since
we are at the ”creating terminal petals” stage. As K ⊆ Xj, it must be that the condition of line
3 in reform-interval is satisﬁed, and in line 4 we set lo(cid:48) to be lo + 4α/5. We conclude that if
u ∈ BX (v, ∆/160) for some v ∈ K, then dYj−1(u, v) ≤ ∆/160 (because by the ﬁrst assertion, this
ball around v was not cut by the ﬁrst petal). By Claim 10, u ∈ Wlo+3α/5+∆/40 = Wlo+4α/5 ⊆ Xj.
it must be that v ∈ BX (x0, 3∆/4). By Fact 5, all distances in Yj−1 to x0 remain the same as in X.
Note that the parameter r of the petal Xj = Wr is at most ∆/32, and that dX (x0, tj) ≥ 7∆/8. By
the deﬁnitions of a petal and of the cone-metric, for any p ∈ Px0t with dX (p, t) ≤ ∆/32 we have
that if u ∈ B(Yj−1,ρ(Yj−1,x0,p))(p, (r − dYj−1(p, t))/2) then

Finally we prove the third assertion. By the termination condition in line 11 of petal-decomposition,

dX (x0, u) ≥ dX (x0, p) + dYj−1(p, u) − (r − dYj−1(p, t))/2 > dX (x0, p) − r
≥ dX (x0, t) − dX (p, t) − ∆/32 ≥ 7∆/8 − 2∆/32 ≥ 13∆/16 .

By the triangle inequality we obtain that dX (v, u) ≥ dX (x0, u)−dX (x0, v) > ∆/16, which concludes
the proof.

28

1: Let Wr =(cid:83)

Algorithm 5 [lo(cid:48), hi(cid:48)] = Reform-Interval(Y, t, x0, [lo, hi], K)
p∈Px0t: dY (p,t)≤r B(Y,ρ(Y,x0,p))(p, (r − dY (p, t))/2);

return [lo + 4α/5, hi];

2: Set α ← hi − lo;
3: if K ⊆ Wlo+3α/5 then
4:
5: end if
6: if K ∩ Wlo+2α/5 = ∅ then
return [lo, lo + α/5];
7:
8: end if
9: return [lo + 2α/5, lo + 3α/5];

By Claim 11, given a terminal v in cluster X of radius ∆, and a ball B = BX (v, l) of radius
at most l ≤ ∆/160, the ball B might be cut in the petal decomposition of X only if the terminal
v is separated from some other terminal. petal-decomposition picks terminal targets arbitrary
but deterministically. Therefore we will be more speciﬁc, and decide that petal-decomposition
pick terminal targets by increasing order of the remaining terminals. If the ﬁrst petal is built in
line 3, then the ﬁrst target is given, and by the reform-interval procedure, it is deterministically
determined whether the ﬁrst petal will contain all, part, or none of the terminals.
If there are
terminals remaining, and the ﬁrst special petal (if exists) contains none of the terminals, then the
second target is once again picked deterministically, and again reform-interval deterministically
determines whether the petal will contain all or only part of the terminals. In any case, the issue of
whether all the terminals will be in single petal or not, is resolved deterministically. Hence, given a
cluster X, root x0 and target t, it is known if there is some danger that B may be cut. Moreover,
there are at most k levels in which some terminals are separated, and hence involving a danger of
cutting balls around terminals. (If l > ∆/160 then we do not care whether B is cut or not, because
the distortion induced on v and points outside of B will be a constant.)

9.3 Expected Distortion

When dealing with weighted graphs, it could be that a tiny ball participates in many recursive
levels, and thus is ”threatened” many times. In order to avoid such situations, we shall change the
algorithm slightly, and when performing a petal decomposition on a cluster X of radius ∆, we shall
contract for each vertex u ∈ X, the ball of radius ∆/n3 around u. In addition, if terminals are
separated (which is determined deterministically) then for each terminal v ∈ K, we contract the ball
of radius ∆/k3 around v. These contractions are done sequentially; when a vertex contracts a ball
of radius l it becomes a ”supernode” of all the vertices within distance l, and for any edge leaving a
vertex in the ball to some vertex z, we will have a corresponding edge with the same weight from the
supernode to z. These contractions yield a cluster X(cid:48), on which we run the petal-decomposition
algorithm (note that X(cid:48) may contains supernodes - vertices that correspond to several original
vertices, and that X(cid:48) induces a multi-graph). After the partition of X(cid:48) to X0, . . . , Xs is determined,
we expand back the contracted balls, so that each vertex belongs to the cluster of its supernode.

This guarantees that a ball of radius l around each terminal can participate only at partitions
of radii in the range [l, k3· l], and by Fact 1, the radii decrease by a factor of at least 7/8 every level,
so there are at most 16 log k levels in which each such ball participates. Similarly, a ball of radius
l(cid:48) around some vertex u ∈ X, can participate only at partitions of radii in the range [l(cid:48), n3 · l(cid:48)], so

29

there are at most 16 log n levels in which each such ball participates. This contraction, while saving
small balls from being cut, may have an eﬀect on the radius of the tree when we expand back the
vertices. We claim that this will be a minor increase. To see this, note that in a particular level,
expanding back the balls around terminals can increase distances by at most 2∆/k2 (because every
contracted ball has diameter at most 2∆/k3, and there can be at most k contracted balls). Similarly,
expanding back all the other contracted balls may increase distances by at most an additional term
of 2∆/n2. Now, since there are at most k iterations in which terminals are separated (only in such
levels the balls around them are contracted), even if the radius is increased by a factor of 1 + 2/k2
in every one of them, the total increase is at most (1 + 2/k2)k < e2/k. Similarly, there are at most
n iterations all in all (since ∅ (cid:40) X0 (cid:40) X), and even if the radius is increased by a factor of 1 + 2/n2
in every one of them, the total increase is at most (1 + 2/n2)n < e2/n. Henceforth we shall ignore
this minor increase, as it aﬀects the distortion of every pair by at most a factor of e2/k+2/n.

by

the

We

will

that

show

distribution

generated
the
hierarchical-petal-decomposition(G, x0, x0, K) algorithm has
strong terminal distortion
( ˜O(log k), ˜O(log n)) (where x0 is an arbitrary vertex). The hierarchical partition naturally corre-
sponds to a laminar family of clusters, that are arranged in a hierarchical tree structure denoted
by T (with V as the root, and each cluster X which is partitioned by petal-decomposition
to X0, . . . , Xs, has them as its children in T ). The level of a cluster is its distance in T to the
root. Note that there might be several trees that correspond to a single hierarchical partition
(this depends on the precise edges connecting the diﬀerent petals). For a pair of vertices x, y
and hierarchical tree T , let dT (x, y) be the maximal distance between x and y in a tree T that
corresponds to the hierarchical tree T . Note that if x is separated from y in the hierarchical tree
T in cluster X of radius ∆X , then by Fact 4, dT (x, y) ≤ 8∆X .
Fix any two points x, y ∈ V and denote by Bx = BG(x, d(x, y)). For j ∈ [s], we say that Bx
is cut by Xj if Bx ∩ Xj /∈ {∅, Bx}. Further, Bx is cut in X if there exists some petal Xj that cuts
Bx. For i ≥ 0, let SX,i be the event that Bx ⊆ X and X is a cluster in level i. When calling
petal-decomposition on the cluster X, a sequence of clusters X1, . . . , Xs, X0 is generated, with
Yj as deﬁned in the algorithm. For Y ⊆ X and integer j ≥ 1, let SX,i,Y,j denote the event that
SX,i holds, Bx ⊆ Y , and Y = Yj−1. Deﬁne the following events

CX,i,j = {Bx ∩ Xj /∈ {∅, Bx}}
FX,i,j = {Bx ∩ Xj = ∅}

“Bx cut in level i at iteration j”,
“Bx is not cut in level i iteration j”.

cut or contained in Xj, and let

Denote by FX,i,(<j) the event(cid:86)
0<h<j FX,i,h, by ¯FX,i,j = {Bx ∩ Xj (cid:54)= ∅} the event that Bx is either
(cid:83)

“Bx is cut in level i iteration j, but not before”.

EX,i,j = {CX,i,j ∧ FX,i,(<j)}

, as the event that Bx is cut for the ﬁrst time in level i.

Finally, deﬁne EX,i =
With our new notations, we can bound the expected distance, as follows:

j EX,i,j

SX,i ∧

(cid:110)

(cid:111)

30

T

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

X,i

X,i

T

X,i

E[dT (x, y)] ≤

=

=

(cid:88)
(cid:88)
Pr[T ] · dT (x, y)
(cid:88)
Pr[EX,i] · Pr[T | EX,i] · dT (x, y)

Pr[T | EX,i] · dT (x, y)

X⊆V
i∈N
Pr[EX,i]

T

(cid:88)

T

≤ 8

= 8

Pr[EX,i] · ∆X ·

Pr[EX,i] · ∆X .

Pr[T | EX,i]

(7)

(cid:110)

(cid:111)

(cid:110)

Recall the constants deﬁned in create-petal: Lk = (cid:100)log log k(cid:101) and Ln = (cid:100)log log n(cid:101). For
, and similarly ϕn(X, Y, x) =

|X|k

, e

Y ⊆ X ⊆ V deﬁne ϕk(X, Y, x) = max
max
terminal or an arbitrary vertex, is cut. We defer its proof to Section 9.3.1.

|BY (x,∆X /(28Ln))| , e

|BY (x,∆X /(28Lk))|k

|X|

. The following lemma bounds the probability that a ball around a

(cid:111)

Lemma 12. For any integer i, and a cluster X with radius ∆X (from some root vertex), it holds
that if x is a terminal (x ∈ K) then (where x, y are as deﬁned earlier)

Pr[EX,i]∆X ≤ 214d(x, y)Lk

SX,i,Y,j ∧ F X,i,j

j≤k+1

Y ⊆X

(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
Pr(cid:2)

j≤k+1

Y ⊆X

Y ⊆X

j

(cid:3) ln (ϕk (X, Y, x)) .
(cid:3) ln (ϕk (X, Y, x))
(cid:3) ln (ϕn (X, Y, x)) .

(8)

(9)

Moreover, without dependence wether x is a terminal, it holds that

Pr[EX,i]∆X ≤ 214d(x, y)Lk

+ 214d(x, y)Ln

SX,i,Y,j ∧ F X,i,j

SX,i,Y,j ∧ F X,i,j

The algorithm returns us a hierarchical tree T . We refer to the base level (where there are
only one cluster that contains all the vertices) as level 0, to the next level as level 1 and so on.
For a hierarchical tree T , let AT ⊆ N be the set of levels i, in which Bx is included in a cluster
X with radius ∆X , such that d(x, y) is larger than ∆X /k3. Note that if x is a terminal, due to
the contractions, if d(x, y) ≤ ∆X /k3, then the ball Bx could not be cut, hence EX,i = ∅. By
Fact 1, AT ⊆ N is of size at most log8/7(2 · k3) + 1 < 22 log k. (The radius has to be in the range
[d(u, v)/2, k3d(u, v)], once the radius is less than d(u, v)/2, Bx will surely be cut.) For any level
i, denote by AT ,i = {i(cid:48)
≥ i}. Similarly, let QT be the set of levels i, in which Bx is
included in a cluster X with diameter at most ∆X ≤ n3 · d(x, y). For every vertex x due to the
contraction, if d(x, y) ≤ ∆X /n3, EX,i = ∅. By Fact 1, QT ⊆ N is of size at most 22 log n. For any
level i, denote by QT ,i = {i(cid:48)
log8/7(29Lk)
of all the levels in the hierarchical tree to the sets Im = {i ∈ N :
{0, 1, . . . , lk − 1}. Similarly, for g ∈ {0, 1, . . . , ln − 1}, Jg = {i ∈ N :

. Consider the partition of the indices
i = m (mod lk)} for m ∈
i = g (mod ln)}. The next

(cid:109)
∈ QT : i(cid:48)

lemma, combined with Lemma 12, is used to bound the cut probability.

log8/7(29Ln)

Deﬁne lk =

, and ln =

∈ AT

≥ i}.

(cid:109)

(cid:108)

(cid:108)

i(cid:48)

:

31

Claim 13. For every positive integers m, g and t, it holds that:

(cid:88)
(cid:88)

(cid:88)
(cid:88)

X,j,Y

Pr(cid:2)
Pr(cid:2)

i∈Im: i≥t

i∈Jg: i≥t

X,j,Y

SX,i,Y,j ∧ F X,i,j

SX,i,Y,j ∧ F X,i,j

(cid:3) ln (ϕk (X, Y, x)) ≤
(cid:3) ln (ϕn (X, Y, x)) ≤

(cid:88)
(cid:88)

X,T

X,T

Pr[SX,t ∧ T ] (ln|X|k + |AT ,t|)

(10)

Pr[SX,t ∧ T ] (ln|X| + |QT ,t|)

(11)

possible X and i ≥ t. Hence(cid:80)

Proof. Fix any such m, we will show (10) by (reverse) induction on t ∈ Im.
For the base case, note that when t is suﬃciently large, x and y must have been separated. E.g.
if t = log8/7(2diam(G)/d(x, y)), at levels i ≥ t the radius of any cluster will be less then d(x, y)/2
(using that the radius drops by at least 7/8 at every level). We get that Pr[EX,i] = 0 for any
Assume (10) holds for t + lk ∈ Im, and prove for t. Observe that if Z is a cluster in level t + lk
such that event SZ,t+lk holds, then there must be a cluster X at level t (the ancestor of Z) such
that SX,t holds, and there are also Y and j such that Y = Yj−1, event ¯FX,i,j holds, and Z ⊆ Y ⊆ X
(Xj is the ancestor of Z at level t + 1). Also note that ∆X ≥ (8/7)lk ∆Z = 29Lk · ∆Z, therefore
Z ⊆ BZ(x, 2∆Z) ⊆ BY (x, ∆X /(28Lk)). It follows that

(cid:3) = 0 and (10) holds.

X,j,Y Pr(cid:2)
(cid:80)

SX,i,Y,j ∧ F X,i,j

i∈Im: i≥t

Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] · Pr[SZ,t+lk | SX,t,Y,j ∧ ¯FX,t,j ∧ T ] ·

T ,X,Y,Z,j : Z⊆Y ⊆X

· (ln|Z|k + |AT ,t+lk|)

Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] ·

T ,X,Y,Z,j : Z⊆Y ⊆X

(cid:18)

(cid:88)

T ,X,Y,j:Y ⊆X

· Pr[SZ,t+lk | SX,t,Y,j ∧ ¯FX,t,j ∧ T ]
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ]

ln|BY (x,

ln|BY (x,
∆X
28Lk

)|k + |AT ,t+lk|

(cid:18)

(cid:19)
(cid:19)
)|k + |AT ,t+lk|

∆X
28Lk

.

(12)

(cid:80)
Where the last inequality is by changing the order of summation and the fact that
Z⊆Y Pr[SZ,t+lk | SX,t,Y,j ∧ ¯FX,t,j ∧ T ] ≤ 1. Now, if in the hierarchical tree T , t ∈ AT , then

Pr[SZ,t+lk ∧ T ] (ln|Z|k + |AT ,t+lk|)

(cid:88)
(cid:88)

(cid:88)

Z,T

=

≤

≤

32

(cid:88)

(cid:88)
Pr(cid:2)
|AT ,t| ≥ |AT ,t+lk| + 1, so that
(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)

i∈Im, i≥t+lk
+

i∈Im, i≥t

X,j,Y

X,j,Y

=

Pr(cid:2)

SX,i,Y,j ∧ F X,i,j

SX,t,Y,j ∧ F X,t,j

SX,i,Y,j ∧ F X,i,j

(cid:3) ln (ϕk (X, Y, x))
(cid:3) ln (ϕk (X, Y, x))
(cid:3) ln (ϕk (X, Y, x))
(cid:88)
Pr(cid:2)

(10)

≤

(12)

≤

≤

T ,X,Y,j:Y ⊆X

(cid:18)
Pr[SX,t ∧ T ] (ln|X|k + |AT ,t+lk|) +
(cid:88)
(cid:88)

X,j,Yj−1
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ]
ln|BY (x,
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] ln ϕk(X, Y, x)
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] (ln|X|k + |AT ,t|) .

T ,X,Y,j

+

(cid:88)

T ,X,Y,j

X,j,Y

(cid:88)

X,T

SX,t,Y,j ∧ F X,t,j

(cid:3) ln (ϕk (X, Yj−1, x))
(cid:19)
)|k + |AT ,t+lk|

∆X
28Lk

In the last inequality we used that if ϕk(X, Y, x) =

|X|k

|BY (x,∆X /28Lk)|k

, then

ln|BY (x, ∆X /28Lk)|k + |AT ,t+l| + ln ϕk(X, Y, x) = ln|X|k + |AT ,t+l| ≤ ln|X|k + |AT ,t| ,

and if ϕk(X, Y, x) = e, then

ln|BY (x, ∆X /28L)|k + |AT ,t+l| + ln ϕk(X, Y, x) = ln|BY (x, ∆X /28L|k + |AT ,t+l| + 1

≤ ln|X|k + |At| .

(13)

(14)

In addition note that

(cid:88)

T ,X,Y,j

T ,X,Y,j

(cid:88)
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] (ln|X|k + |AT ,t|)
(cid:88)
(cid:88)

Pr[SX,t ∧ T ] (ln|X|k + |AT ,t|)
Pr[SX,t ∧ T ] (ln|X|k + |AT ,t|)

Pr[SX,t ∧ T ] · Pr[SX,t,Y,j ∧ ¯FX,t,j | SX,t ∧ T ] (ln|X|k + |AT ,t|)
Pr[SX,t,Y,j ∧ ¯FX,t,j | SX,t ∧ T ]

(cid:88)

T ,X

Y,j

=

=

=

T ,X

where the last equality follows by(cid:80)
therefore(cid:80)

Y,j Pr[SX,t,Y,j ∧ ¯FX,t,j | SX,t ∧ T ] = 1, which holds because for
every diﬀerent Y, j, the events SX,t,Y,j ∧ ¯FX,t,j are disjoint. This concludes the proof of (10).
The proof of (11) is fully symmetric. Fix some g, we will show (11) by (reverse) induction on
t ∈ Jg. The base case is trivial (for every X and t ≥ log8/7(2diam(G)/d(x, y)), Pr[SX,i] = 0 and

(cid:3) = 0.) Assume (11) holds for t + ln ∈ Jg, and prove

X,j,Y Pr(cid:2)
(cid:80)

for t. For cluster Z such that event SZ,t+ln holds, there are unique clusters X, Y and an index

SX,i,Y,j ∧ F X,i,j

i∈Jg: i≥t

33

j, such that the events SX,t, ¯FX,i,j holds, Y = Xj, and Z ⊆ BZ(x, 2∆Z) ⊆ BY (x, ∆X /(28Ln)).
Similarly to equation (12) we get

Pr[SZ,t+ln ∧ T ] (ln|Z| + |QT ,t+ln|)

(cid:88)

Z,T

=

≤

(cid:88)
(cid:88)
(cid:88)

=

T ,X,Y,Z,j : Z⊆Y ⊆X

Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] · Pr[SZ,t+ln | SX,t,Y,j ∧ ¯FX,t,j ∧ T ] ·

(cid:18)

(cid:19)
)| + |QT ,t+ln|

.

(15)

T ,X,Y,j:Y ⊆X

ln|BY (x,

∆X
28Ln

i∈Jg, i≥t+ln

X

j,Y

i∈Jg, i≥t

X

j,Y

(cid:88)

Pr(cid:2)

SX,i,Y,j ∧ F X,i,j

SX,i,Y,j ∧ F X,i,j

SX,t,Y,j ∧ F X,t,j

Now we make the induction step:

(cid:3) ln (ϕn (X, Y, x))

· (ln|Z| + |QT ,t+ln|)
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ]
(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)
Pr[SX,t+ln ∧ T ] (ln|X| + |QT ,t+ln|)
(cid:88)
(cid:88)
Pr(cid:2)
Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ]
(cid:88)
in equation (14) we have (cid:80)T ,X,Y,j Pr[SX,t,Y,j ∧ ¯FX,t,j ∧
T ] (ln|X| + |QT ,t|) =(cid:80)

(cid:3) ln (ϕn (X, Y, x))
(cid:3) ln (ϕn (X, Y, x))
(cid:3) ln (ϕn (X, Y, x))
(cid:18)
(cid:3) ln (ϕn (X, Yj−1, x))

X,T Pr[SX,t ∧ T ] (ln|X| + |QT ,t|), Which concludes the proof of (11).

Pr[SX,t,Y,j ∧ ¯FX,t,j ∧ T ] (ln|X| + |QT ,t|) .

SX,t,Y,j ∧ F X,t,j ∧ T

By the

same

calculation as

SX,t,Y,j ∧ F X,t,j

)| + |QT ,t+ln|

ln|BY (x,

T ,X,Y,j

+

+

X,T

+

(11)

≤

(15)

≤

≤

T ,X,Y,j

∆X
28Lk

T ,X,Y,j

X

j,Y

X

j,Y

(cid:19)

Proof of Theorem 11. The proof of Theorem 11 follows from Lemma 12, Claim 13 and equation
(7). We start by proving the ﬁrst assertion of Theorem 11. Recall that for every hierarchical tree
T , |AT | ≤ 22 log k. Note that |X|k ≤ k.

34

E[dT (x, y)]

(7)

≤ 8

(cid:88)
lk−1(cid:88)

X,i

Pr[EX,i] · ∆X

(cid:88)

(cid:88)

Pr[EX,i] · ∆X

= 8

(8)

X

m=0

i∈Im

lk−1(cid:88)
(cid:88)
≤ 217Lk · d(x, y)
(cid:88)
lk−1(cid:88)

i∈Im

m=0

(10)

(cid:88)

X,j≤k+1,Y

Pr(cid:2)

SX,i,Y,j ∧ F X,i,j

(cid:3) ln (ϕk (X, Y, x))

m=0

X,T

Pr[SX,0 ∧ T ] (ln|X|k + |AT ,0|)

≤ 217d(x, y)Lk
≤ 217Lk · d(x, y) (ln k + 22 log k) lk
≤ 229 log k log log k log log log k · d(x, y) = ˜O (log k) d(x, y) .

Pr[SV,0 ∧ T ]

T

(cid:88)

Similarly, for the second assertion of Theorem 11, recall that for every hierarchical tree T , |QT | ≤
22 log n. Note that |X| ≤ n.

8

8

(cid:88)
(cid:88)
(cid:88)

X,i

X,i

X,i

+ 8

Pr[EX,i] · ∆X

214d(x, y)Lk

j≤k
214d(x, y)Ln

217Lk · d(x, y)

+ 217d(x, y)Ln

217d(x, y)Lk

j

Y

Y

SX,i,Y,j ∧ F X,i,j

SX,i,Y,j ∧ F X,i,j

(cid:3) ln (ϕk (X, Y, x))
(cid:3) ln (ϕn (X, Y, x))
(cid:3) ln (ϕk (X, Y, x))
(cid:3) ln (ϕn (X, Y, x))

(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
Pr(cid:2)
lk−1(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)
ln−1(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)
(cid:88)
(cid:88)
lk−1(cid:88)
Pr[SX,0 ∧ T ] (ln|X|k + |AT ,0|)
(cid:88)
(cid:88)
ln−1(cid:88)

SX,i,Y,j ∧ F X,i,j

SX,i,Y,j ∧ F X,i,j

X,j≤k,Y

i∈Im

i∈Im

i∈Jg

X,T

X,j,Y

m=0

g=0

m=0

+ 217d(x, y)Ln

(cid:0)229 log k log log k log log log k + 229 log n log log n log log log n(cid:1) d(x, y)

Pr[SX,0 ∧ T ] (ln|X| + |QT ,0|)

i∈Jg

X,T

g=0

E[dT (x, y)]

(7)

≤

(9)

≤

≤

(10)∧(11)

≤

≤
=

˜O (log n) d(x, y) .

35

9.3.1 Proof of Lemma 12

Let X be the vertex set of the graph in the current level i of the petal decomposition, with arbitrary
center x0, target t and radius ∆ (with respect to x0). Recall the vertices x, y ∈ X, and the ball
Bx = BG(x, d(x, y)). Set γ = d(x, y)/∆. As X and i are ﬁxed, and all the probabilistic events in
the statement of the lemma are contained in SX,i, we will implicitly condition all the probabilistic
events during the proof on SX,i (i.e. our sample space is restricted to SX,i). We shall also omit X
and i from the subscript of the probabilistic events (i.e., we will write Cj,Fj,F(<j),Ej,E and we
will write ZY,j instead of SX,i,Y,j).
We make a small change in the numbering of the created petals: let t1, . . . , tk+1 be the terminal
targets chosen in lines 6 or 12 of petal-decomposition, and tk+2, . . . , tn+1 be the non-terminal
targets chosen in line 21. Observe that in that notation we always have exactly n + 1 petals, while
there might be an index j such that Xj = ∅, in that case we say that Xj is an imaginary petal.
Note that there are at most k + 1 terminal targets because there are just k terminals (in addition
to the ﬁrst special petal whose target is not necessarily a terminal).

The petal decomposition algorithm returns a partition (X0, . . . , Xs, (y1, x1), . . . , (ys, xs), t0, . . . , ts).

Recall the deﬁnitions from create-petal procedure, some of them depend on the type of petal
(terminal or non-terminal petal), and some of them are actually random variables (which depend
on the previously created petals). We will write these with an index j to clarify which petal they
correspond to. In the terminal petal case (j ≤ k + 1), Lk = (cid:100)log log k(cid:101), Rj = hi − lo = ∆/40 (after
reformation), aj = lo + (qj − 1)Rj/Lk, b(cid:48)
j = aj + Rj/(2Lk), bj = aj + Rj/Lk, where qj is chosen in
such a way that

2|X|k

2log1−(q−1)/Lk k ≤ |Waj|k ≤ |Wbj|k ≤

2|X|k

2log1−q/Lk k

.

(16)

|X|k+1
|Wa|k

2 ln ˆχj
b(cid:48)j−aj

=

4Lk ln ˆχj

Rj

160Lk ln ˆχj
λj·e−λj r

∆

=

, e}, λj =

j] with density function f (r) =

. The radius rj of the petal Xj = Wrj ,

Also, ˆχj = max{
is chosen from [aj, b(cid:48)
. Analogously, in the non-terminal
case (j > k + 1): Ln = (cid:100)log log n(cid:101), Rj = hi − lo = ∆/32 (no reformation), aj = lo + (qj − 1)Rj/Ln,
b(cid:48)
1−(qj−1)/Ln n ≤
j = aj + Rj/(2Ln), bj = aj + Rj/Ln, where qj is chosen in such a way that
4Ln ln ˆχj
|Waj| ≤ |Wbj| ≤
. The
radius rj of the petal Xj = Wrj , is chosen from [aj, b(cid:48)

|X|+1
|Wa| , e}, λj =

j] with density function f (r) =

. Also, ˆχj = max{

2|X|
1−qj /Ln n

e−λj·aj−e−λj·b(cid:48)j

∆
λj·e−λj r

2 ln ˆχj
b(cid:48)j−aj

2log
=

128Ln ln ˆχj

2|X|

2log

.

=

Rj

e−λj·aj−e−λj·b(cid:48)j
as otherwise the assertions of

(cid:3)).
Let δj = e−8λj γ∆. Towards the proof, we assume that γ ≤ 1
(cid:18)
210Lk
Pr(cid:2)
SX,i,Y,j ∧ F X,i,j

Y ⊆X Pr(cid:2)
(cid:80)

the lemma are trivial (as Pr[EX,i] ≤

(cid:80)

j

(cid:19)

(cid:3) + 2

Claim 14. For every 1 ≤ j ≤ n + 1, Pr [Cj | ZY,j] ≤ (1 − δj)
Proof. For ease of notation we write simply λ ,δ, χ, a and b(cid:48) instead of λj, δj, χj, aj, b(cid:48)
j, as the
proof is the same for both of the cases.20 Let ρ be the minimal number greater than a such that

(cid:3) = 1 and hence Pr [Cj | ZY,j] = 0 and we are

Wρ ∩ Bx (cid:54)= ∅. If ρ ≥ b(cid:48), then trivially Pr(cid:2)

20Note that if Xj = ∅ is imaginary petal created only for clarity in notation, then Pr [Cj | ZY,j] = 0 and the claim

Fj | ZY,j

Fj | ZY,j

ˆχ2
j

.

is obvious.

36

done. Otherwise, ρ ∈ [a, b(cid:48)], the probability that Bx intersects Xj is

Pr(cid:2)

b(cid:48)(cid:90)

(cid:3) =

b(cid:48)(cid:90)

λ · e−λr

e−λρ − e−λb(cid:48)
e−λ·a − e−λ·b(cid:48) .

ρ

ρ

f (r) dr =

f (r) dr =

Fj | ZY,j

ρ+8γ∆(cid:90)

Pr [Cj | ZY,j] ≤

e−λ·a − e−λ·b(cid:48) dr =
ρ+8γ∆(cid:90)
The ball Bx is of diameter at most 2γ∆, therefore by Claim 10, Bx ⊆ Wρ+8γ∆. Hence
e−λρ − e−λ(ρ+8γ∆)
e−λ·a − e−λ·b(cid:48) dr =
e−λ·a − e−λ·b(cid:48)
−λ8γ∆(cid:17)
e−λρ − e−λ·b(cid:48) + e−λ·b(cid:48)
(cid:33)
(cid:19)
e−λ·a − e−λ·b(cid:48)
(cid:19)
eλ·(b(cid:48)−a) − 1

(cid:32)
1 − e
e−λ·a − e−λ·b(cid:48)
e−λρ − e−λ·b(cid:48)
(cid:18)
(cid:3) +
Pr(cid:2)
e−λ·a − e−λ·b(cid:48) +
(cid:18)
Pr(cid:2)
(cid:3) +

e−λ·a − e−λ·b(cid:48)

= (1 − δ)
e−λ·b(cid:48)

= (1 − δ)

= (1 − δ)

λ · e−λr

Fj| ZY,j

e−λρ

(cid:16)

=

1

ρ

ρ

.

≤ (1 − δ)

Fj| ZY,j

2
ˆχ2

Where the last inequality follows since ˆχ ≥ 2.

We are now ready to bound the probability that one of the terminal petals cuts Bx.

 (cid:95)

j≤k+1

Pr

Cj

 =

Y ⊆X

(cid:88)
(cid:88)
(cid:88)

Y

j≤k+1

(cid:88)
(cid:88)
(cid:88)

j≤k+1

j≤k+1

(cid:32)
Pr(cid:2)
(1 − δj) Pr(cid:2)

(1 − δj)

≤

=

Pr [Cj | ZY,j] · Pr[ZY,j]

(17)

(cid:33)
(cid:88)
(cid:88)

2
ˆχ2
j

(cid:3) +
(cid:3) +

j≤k+1

Fj | ZY,j

· Pr[ZY,j]

Fj ∧ ZY,j

(1 − δj)

2
j · Pr[ZY,j] .
ˆχ2

Y

Y

(cid:104)

(cid:105)

(cid:105)

l<j Cl

Cj ∧

j≤k+1 Cj

j≤k+1 Pr

To see how the ﬁrst equality follows, note that the probability that Bx is cut by the ﬁrst k + 1
) is equal to the sum of the probabilities that Bx cut at the ﬁrst time by
petals (Pr

(cid:104)(cid:87)
(cid:86)
petal j ((cid:80)
cut by petal j ((cid:80)
). While for each j, the probability that Bx is cut at the ﬁrst
time by petal j is equal to the probability that Bx is active at iteration j (i.e. F(<j)), and is indeed
a set Y = Yj−1 such that Pr(cid:2)
Note that for j ≤ k + 1, 1 − δj = 1 − e−8λj γ∆ = 1 − e−8·160γLk ln ˆχj < 211γLk ln ˆχj. For
(cid:17)
(cid:54)= 0, necessarily a target tj and qj are chosen so that
Bx ∩ Wb(cid:48)j (cid:54)= ∅ (otherwise it is no possible that Xj intersects Bx). As Bx is a ball of radius γ∆ ≤
∆/(210Lk), increasing the petal radius by 4γ∆ we have x ∈ Wb(cid:48)j +4γ∆, and moreover B
⊆
Wb(cid:48)j +4γ∆+ ∆

Y ⊆X Pr [Cj | ZY,j] · Pr[ZY,j]).

Fj ∧ ZY,j

x, ∆
29Lk

= Wbj .

(cid:16)

(cid:3)

+ ∆

27Lk ⊆ Wb(cid:48)j + ∆

28Lk

27Lk ⊆ W

b(cid:48)j +

Rj
2Lk

37

(cid:3)

We may assume that ˆχj =
3 we get:

We will show that for such a Y , (for which Pr(cid:2)
(cid:32)
(cid:32)

log ˆχj = log

|X|k+1
|Wa|k

(cid:54)= 0 ), log ( ˆχj) ≤ 6 log (ϕk (X, Y, x)).21
, as otherwise ( ˆχj = e) the bound is trivial. Using that log1/Lk k ≤

Fj ∧ ZY,j

2|X|k

|X|k + 1

(cid:33)
(cid:12)(cid:12)k
(cid:12)(cid:12)Waj
(cid:33)
(cid:12)(cid:12)k
(cid:12)(cid:12)Waj
≤ log
≤ log1−(q−1)/Lk k
(cid:32)
(cid:33)
≤ 3 log1−q/Lk k
(cid:12)(cid:12)Wbj
(cid:12)(cid:12)k
(cid:18)
2|X|k
≤ 3 log

(16)

(16)

(cid:19)

2|X|k

≤ 3 log
|B (x, ∆/29Lk)|k
= 3 (log (ϕk (X, Y, x)) + 1)
≤ 6 log (ϕk (X, Y, x)) .

Note that in particular it is true that ln ˆχj ≤ 6 ln (ϕk (X, Y, x)). Hence we can bound the ﬁrst

component of the summation in (17):

(cid:88)

(cid:88)

j≤k+1

Y

(1 − δj) Pr(cid:2)

(cid:3)

Fj ∧ ZY,j

≤ 211γLk
≤ 6 · 211γLk

j≤k+1

Y

Fj ∧ ZY,j

(cid:88)
(cid:88)
ln ( ˆχj) Pr(cid:2)
(cid:3)
(cid:88)
(cid:88)
ln (ϕk (X, Y, x)) Pr(cid:2)
(cid:80)
Y (1 − δj) 2

j≤k+1

ˆχ2
j

Y

(18)

(cid:3)

1
ˆχj

=

(cid:27)

|Waj|k
|X|k+1 , 1

For bounding the second component ((cid:80)
(cid:26)
the partition X0, . . . , Xs). Note also that for each such partition, X0, . . . , Xs,(cid:12)(cid:12)Waj
(cid:80)

min
In addition, the probability of the event SY,j is equal to the sum
of probabilities of sequences X0, . . . , Xs, over all sequences for which Y = (Xj ∪ ··· ∪ Xs ∪ X0)
(while we abuse notation, Pr[X0, . . . , Xs] is the probability that the petal decomposition returned

|Xj|k
|X|k ≤ 1, because all the petals, X1, . . . , Xk+1, , are pairwise disjoint. We get

(cid:12)(cid:12)k ≤ |Xj|k and

· Pr[ZY,j]), note that

≤ |Waj|k
|X|k

j≤k+1

j≤k+1

.

e

Fj ∧ ZY,j

(cid:26)

21 Recall that ϕk (X, Y, x) = max

|BY (x,∆X /(28Lk))|k

|X|k

(cid:27)

, e

.

38

Pr[SY,j]

ˆχj

(cid:88)
(cid:88)
(cid:88)
(cid:88)

Y

j≤k+1

j≤k+1

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

j≤k+1

j≤k+1

(cid:88)

j≤k+1

=

≤

≤

≤

=

≤

(X0,...,Xs)

(X0,...,Xs)

Y : Bx⊆Y

(X0,...,Xs): Y =(Xj∪···∪Xs∪X0)

Pr[X0, . . . , Xs]

(cid:88)
(cid:88)
(cid:88)

1
ˆχj

(cid:12)(cid:12)Waj

(cid:12)(cid:12)k

|X|k

Pr[X0, . . . , Xs]

Pr[X0, . . . , Xs]|Xj|k
|X|k

Y : Bx⊆Y

(X0,...,Xs) : Y =(Xj∪···∪Xs∪X0)

(X0,...,Xs)

(X0,...,Xs)

Y : Bx⊆Y,Y =(Xj∪···∪Xs∪X0)
Pr[X0, . . . , Xs]|Xj|k
|X|k
|Xj|k
|X|k

(cid:88)

j≤k+1

Pr[X0, . . . , Xs]

Pr[X0, . . . , Xs] = 1 .

Where the third inequalitie follows by the fact that for a ﬁxed j and a particular partition X0, . . . , Xs
ˆχj ≤ 1 we
of X there might be only a single set Y such that Bx ⊆ Y = Xj ∪ ··· ∪ Xs ∪ X0. As
can bound the second component of the summation in (17):

ln ˆχj

(cid:88)

(cid:88)

j≤k+1

Y

(1 − δj)

2
j · Pr[ZY,j] ≤ 211γLk
ˆχ2

2
j · Pr[ZY,j]
ˆχ2
Pr[ZY,j]

Y

ln ˆχj

j≤k+1

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Pr(cid:2)
(cid:3) ln ϕk(X, Y, x) ≥

Fj ∧ ZY,j

j≤k+1

ˆχj

Y,j

Y

(cid:3) ln ϕk(X, Y, x) .
Y,j Pr(cid:2)
(cid:80)

Fj ∧ ZY,j

(19)

(cid:3) = 1

≤ 212γLk
≤ 212γLk
≤ 212γLk

Fj ∧ ZY,j

Where the last inequality follows by (cid:80)

Y,j Pr(cid:2)

(recall that all the probabilities are implicitly conditioned on SX,i, and Fj has to hold for some j).

39

We conclude:

Pr

 (cid:95)

j≤k+1
(17)

≤

(18)∧(19)

≤

=

Cj

(cid:88)


(cid:88)
(1 − δj) Pr(cid:2)
(cid:88)
(cid:0)6 · 211 + 212(cid:1) γLk
(cid:88)
(cid:88)
Pr(cid:2)

214γLk

j≤k+1

Y

j≤k+1

Y

j≤k+1

(cid:88)

(1 − δj)

(cid:88)
(cid:3) ln (ϕk (X, Y, v))

(cid:3) +
Pr(cid:2)
(cid:3) ln (ϕk (X, Y, v)) .

Fj ∧ ZY,j

Y

2
j · Pr[ZY,j]
ˆχ2

Fj ∧ ZY,j

(cid:88)

j≤k+1

Y

Fj ∧ ZY,j

Claim 15. If x ∈ K, then for j > k + 1, it holds that Pr [Cj | ZY,j] = 0.
Proof. Since we condition on ZY,j, it implies that Bx ⊆ Yj−1. As γ < 1/16, the third assertion of
Claim 11 implies that Xj ∩ Bx = ∅.

We are ready to prove the ﬁrst statement of Lemma 12. For terminal v ∈ K, Using Claim 15,

Pr[E] = Pr

(cid:104) (cid:95)

j≤n+1

Cj

(cid:88)

j≤k+1

(cid:105)
(cid:88)

(cid:104) (cid:95)
Pr(cid:2)

= Pr

Cj

j≤k+1
Fj ∧ ZY,j

(cid:3)
(cid:3) ln (ϕk (X, Y, v)) .

≤ 214γLk

Y

Pr

(cid:17)

Using a symmetric argument, we can also show the second assertion of Lemma 12. Set µ =
the probability that Bx is cut by terminal petal. Let In = k + 2, . . . , n + 1 be all the

(cid:16)(cid:87)
indices of the non-terminal petals. Note that for j ∈ In, 1−δj = 1−e−8λj γ∆ = 1−e−8·128·γLn ln ˆχj ≤
210γLn ln ˆχj. Hence for every vertex x ∈ X,

j≤k+1 Cj

Pr[E] = Pr

Cj

Y ⊆X

j≤n+1



 (cid:95)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

Y ⊆X

j∈In

j∈In

Y

≤ µ +

(1 − δj)

≤ µ + 210γLn

j∈In

Y

=

j≤n+1

= µ +

Pr [Cj | ZY,j] · Pr[ZY,j]

Pr [Cj | ZY,j] · Pr[ZY,j]

(cid:33)
(cid:3) +

(cid:3) +

(cid:32)
Pr(cid:2)
(cid:88)
ln ˆχj · Pr(cid:2)

2
ˆχ2
j

Fj | ZY,j

· Pr[ZY,j]

(cid:88)
(cid:88)
For Y such that Pr(cid:2)

Fj ∧ ZY,j

j∈In

Y


(cid:16)

2
ˆχj · Pr[ZY,j]

(cid:3)

Fj ∧ ZY,j

(cid:17)

(cid:54)= 0 it holds
⊆

x, ∆
29Ln

40

where the ﬁrst inequality is by Claim 14.
that Bx ∩ Wb(cid:48)j

(cid:54)= ∅. As γ ≤

210Lk ≤

1

1

210Ln

, by Claim 10 we have that Bx

Wb(cid:48)j +4γ∆+ ∆
If ˆχj = e this is trivial, hence we will assume that ˆχj =

27Ln ⊆ Wb(cid:48)j + ∆

27Ln ⊆ W

Rj
2Ln

+ ∆

b(cid:48)j +

28Ln

= Wbj . We will show that ln ˆχj ≤ 6 ln ϕn (X, Y, x).
|X|+1
|Wa| . By the maximality of qj
≤
≤ 3 (log (ϕn (X, Y, x)) + 1) ≤

(cid:18)|X|+1

) we get log ˆχj = log

|B(v,∆/29Ln)|

2|X|
|Waj|

≤ 3 log

≤ log

|Waj|

(cid:18)

(cid:19)

(cid:19)

(cid:17)

(cid:16)

2|X|

2log1−q/Ln n

2|X|

(cid:16) 2|X|

(cid:17)

|Wb|

By similar arguments (and deﬁnitions) to (19) we get

2|X|

(

6 log (ϕn (X, Y, x)).

2log1−(q−1)/Ln n ≤ |Waj| ≤ |Wbj| ≤
log1−(q−1)/Ln n ≤ 3 log1−q/Ln n ≤ 3 log
(cid:88)
(cid:88)

(cid:88)

(cid:88)

Pr[SY,j]

j∈In

j∈In

≤

ˆχj

Y

Y : Bx⊆Y

≤

(X0,...,Xs)

j∈In

(cid:88)
(cid:88)
(cid:88)
6
(cid:88)

(cid:88)

(cid:12)(cid:12)Waj

(cid:12)(cid:12)

|X|

Pr[X0, . . . , Xs]

(X0,...,Xs) : Y =(Xj∪···∪Xs∪X0)
Pr[X0, . . . , Xs]|Xj|
|X|
|Xj|
|X| ≤ 1 .

(cid:88)

Y,j Pr(cid:2)
(cid:80)

Fj ∧ ZY,j

As 1 ≤

=

Pr[X0, . . . , Xs]

j≤k+1

(X0,...,Xs)

(cid:3) ln ϕn(X, Y, x) we get
(cid:88)
ln (ϕk (X, Y, x)) · Pr(cid:2)
ln (ϕn (X, Y, x)) · Pr(cid:2)

(cid:88)
(cid:88)

j∈In

Y

j∈In

Y

Pr[E] ≤ µ + 210γLn

≤ µ + 213γLn

Fj ∧ ZY,j

(cid:3) .

Fj ∧ ZY,j



(cid:3) + 2

Hence the second assertion of Lemma 12 follows as well.

10 Applications

In this section we illustrate several algorithmic applications of our techniques. Some of our appli-
cations are suitable for graphs with a small vertex cover. Recall that for a graph G = (V, E), a
set A ⊆ V is a vertex cover of G, if for any edge e ∈ E, at least one of its endpoints is in A. A
polynomial time 2-approximation algorithm to this problem is folklore.

10.1 Sparsest Cut

In the sparsest-cut problem we are given a graph G = (V, E) with capacities on the edges c : E →
R+, and a collection of pairs (s1, t1), . . . , (sr, tr) along with their demands D1, . . . , Dr. The goal is
to ﬁnd a cut S ⊆ V that minimizes the ratio between capacity and demand across the cut:

(cid:80){u,v}∈E c(u, v)|1S(u) − 1S(v)|
(cid:80)r

φ(S) =

i=1 Di|1S(si) − 1S(ti)|
where 1S(·) is the indicator for membership in S. Arora et. al.
approximation algorithm to this problem. Our contribution is the following.

,

[ALN08] present an ˜O(cid:0)√log r(cid:1)

41

2

Algorithm 6 Sparsest Cut SDP Relaxation

min(cid:80){u,v}∈E c(u, v) · (cid:107)¯u − ¯v(cid:107)2
s.t. (cid:80)r
i=1 Di · (cid:107) ¯si − ¯ti(cid:107)2
2 = 1
For all u, v, w ∈ V , (cid:107)¯u − ¯v(cid:107)2
For all u ∈ V , ¯u ∈ Rn
Note that this is indeed a relaxation: if S is the optimal cut, set ρ =(cid:80)r
for u ∈ S set ¯u = ( 1√

2 ≥ (cid:107)¯u − ¯w(cid:107)2

2 + (cid:107)¯v − ¯w(cid:107)2

2

Theorem 12. If there exists a set K ⊆ V of size k such that any demand pair contains a vertex

of K, then there exists a ˜O(cid:0)√log k(cid:1) approximation algorithm for the sparsest-cut problem.
type metrics) into (cid:96)1, which has ˜O(cid:0)√log r(cid:1) contraction for all demand pairs. We will use the
the distortion to ˜O(cid:0)√log k(cid:1).

The key ingredient of the algorithm of [ALN08] is a non-expansive embedding from (cid:96)2

strong terminal embedding for negative type metrics given in item (7) of Corollary 1 to improve

2 (negative-

We now elaborate on how to use the embedding of (cid:96)2

2 into (cid:96)1 to obtain an approximation
algorithm for the sparsest-cut, all the details can be found in [LLR95, ARV09, ALN08], and we
provide them just for completeness. First, write down the following SDP relaxation with triangle
inequalities:

i=1 Di ·|1S(si)− 1S(ti)|;
ρ , 0, ..., 0), and for u /∈ S, set ¯u = (0, ..., 0). It can be checked to be a feasible

solution of value equal to that of the cut S.

Let K ⊆ V be a vertex cover of the demand graph (V,{{si, ti}r

i=1}) of size at most 2k (recall
that we can ﬁnd such a cover in polynomial time). Let X = {¯v ∈ Rn | v ∈ V } be an optimal
solution to the SDP (it can be computed in polynomial time), which is in particular an (cid:96)2
2 (pseudo)
metric. By Corollary 1 there exists a non-expansive embedding f : X → (cid:96)1 with terminal distortion

˜O(cid:0)√log k(cid:1) (where K is the terminal set).22 This implies that for any u, v ∈ V and any 1 ≤ i ≤ r,
Let (cid:107)f (¯v) − f (¯u)(cid:107)1 =(cid:80)

S⊆V αS |1S(v) − 1S(u)| be a representation of the (cid:96)1 metric as a nonneg-
ative linear combination of cut metrics (it is well known that there is such a representation with

(cid:112)
2 ≥ (cid:107)f (¯v) − f (¯u)(cid:107)1
2 ≤ ˜O(
log k) · (cid:107)f ( ¯si) − f (¯ti)(cid:107)1 .

(cid:107)¯u − ¯v(cid:107)2
(cid:107) ¯si − ¯ti(cid:107)2

(20)

22The embedding of Corollary 1 is in fact into (cid:96)2, but there is an eﬃcient randomized algorithm to embed (cid:96)2 into

(cid:96)1 with constant distortion [FLM77].

42

polynomially many cuts S having αS > 0). We conclude

opt(SDP) =

=

(20)

≥

=

≥

=

1

1

φ(S)

2

2

2

{u,v}∈E

c(u, v) · (cid:107)¯u − ¯v(cid:107)2

(cid:88)
(cid:80){u,v}∈E c(u, v) · (cid:107)¯u − ¯v(cid:107)2
(cid:80)r
(cid:80){u,v}∈E c(u, v) · (cid:107)f (¯v) − f (¯u)(cid:107)1
i=1 Di · (cid:107) ¯si − ¯ti(cid:107)2
i=1 Di · ˜O(cid:0)√log k(cid:1)
(cid:80)r
(cid:80){u,v}∈E c(u, v) ·
(cid:80)
· (cid:107)f ( ¯si) − f (¯ti)(cid:107)1
(cid:80)
(cid:80)r
˜O(cid:0)√log k(cid:1) ·
(cid:80){u,v}∈E c(u, v) · |1S(v) − 1S(u)|
(cid:80)r
˜O(cid:0)√log k(cid:1) min
˜O(cid:0)√log k(cid:1) .

i=1 Di · |1S(si) − 1S(ti)|

S(cid:40)V αS |1S(si) − 1S(ti)|

i=1 Di ·

S:αS >0

min

S:αS >0

S(cid:40)V αS |1S(v) − 1S(u)|

In particular, among the polynomially many sets S ⊆ V with αS > 0, there exists one which has
sparsity at most ˜O(√log k) times larger than the optimal one.

10.2 Min Bisection

and ¯S = V \ S, that minimizes (cid:80)

In the min-bisection problem, we are given a graph G = (V, E) on an even number n of vertices,

with capacities c : E → R+. The purpose is to ﬁnd a partition of V into two equal parts S ⊆ V
e∈E(S, ¯S) c(e). This problem is NP-hard, and the best known

approximation is O (log n) by [R¨ac08]. We obtain the following generalization.

Theorem 13. There exists a O(log k) approximation algorithm for min-bisection, where k is the
size of a minimal vertex cover of the input graph.

Proof. Our algorithm follows closely the algorithm of [R¨ac08], the major diﬀerence is that we use
our embedding into trees with terminal congestion. Let K ⊆ V be the set of terminals, which is
a vertex cover of size at most 2k, and D a distribution over trees with strong terminal congestion
(O(log k), O(log n)) given by Corollary 8. The algorithm will sample a tree T = (V, ET ) from D,
ﬁnd an optimal bisection in T and return it. We refer the reader to Section 8 for details on notation
and on the deﬁnition of capacities CT : ET → R+ for T . We note that there is polynomial time
It remains to analyze the algorithm. Let S ⊆ V be the optimal solution in G, and ST be
the optimal bisection for the tree T . The expected cost of using ST in G can be bounded using

algorithm (by dynamic programming) to ﬁnd a min-bisection in trees.

43

(cid:48)(cid:1)

CT

(cid:0)e
(cid:0)e
(cid:48)(cid:1)

(cid:88)
(cid:88)
(cid:88)

Pr [T ]

e(cid:48)∈ET (ST , ¯ST )

Pr [T ]

CT

e(cid:48)∈ET (S, ¯S)

Lemma 9 as follows(cid:88)

T∈supp(D)

(cid:88)

e∈E(ST , ¯ST )

c (e)

Pr [T ]

(5)

≤

≤

(5)

≤

=

≤

T

T

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

T

e∈E(S, ¯S)

e∈E(S, ¯S)

Pr [T ]

loadT (e)

e∈E(S, ¯S)
ET∼D [loadT (e)]

O (log k) · c(e)

where the last inequality uses that every edge touches a terminal, so its expected congestion is
O(log k).

= O (log k) · opt (G)

,

10.3 Online Algorithms: Constrained File Migration

We illustrate the usefulness of our probabilistic terminal embedding into ultrametric via the con-
strained ﬁle migration problem. This is an online problem, in which we are given a graph G = (V, E)
representing a network, each node v ∈ V has a memory capacity mv, and a parameter D ≥ 1. There
is some set of ﬁles that reside at the nodes, at most mv ﬁles may be stored at node v in any given
time. The cost of accessing a ﬁle that currently lies at v from node u is dG(u, v) (no copies of
ﬁles are allowed). Files can also be migrated from one node to another, this costs D times the
distance. When a sequence of ﬁle requests arrives online, the goal is to minimize the cost of serving
all requests. The competitive ratio of an online algorithm is the maximal ratio between its cost to
the cost of an optimal (oﬄine) solution. For randomized algorithms the expected cost is used.

We consider the case where there exists a small set of vertices which are allowed to store ﬁles
(i.e. mv > 0). One may think about these vertices as servers who store ﬁles, while allowing ﬁle
requests from all end users. Let K ⊆ V be the set of terminal vertices that are allowed to store
ﬁles, with |K| = k. Our result is captured by the following theorem.
Theorem 14. There is a randomized algorithm for the constrained ﬁle migration problem with
competitive ratio O(log m·log k), where k vertices can store ﬁles and m is the total memory available.
This theorem generalizes a result of [Bar96], who showed an algorithm with competitive ratio
O(log m · log n) for arbitrary graphs on n nodes. Both results are based on the following theorem.
(Recall that a 2-HST is an ultrametric (see Deﬁnition 2) such that the ratio between the label of
a node to any of its children’s label is at least 2.)

Theorem 15 ([Bar96]). For any 2-HST, there is a randomized algorithm with competitive ratio
O (log m) for constrained ﬁle migration with total memory m.

44

By Theorem 9 there is a distribution D over embeddings of G into ultrametrics with expected
terminal distortion O (log k), but in fact every tree in that distribution is a 2-HST. Assume that
in the optimal (oﬄine) solution there are suv times a ﬁle residing on v was accessed by u, and tuv
ﬁles were migrated from v to u. Let cuv = suv + D · tuv be the total cost of ﬁle traﬃc from v to u.
Note that as mv = 0 for any v /∈ K, then for any u ∈ V we have cuv = 0. Using the fact that the
terminal distortion guarantee of D applies to all of the relevant distances, we obtain that

(cid:88)

optG =

≥

=

u∈V,v∈K

1

cuv · dG(u, v)

(cid:88)

O(log k) ·
u∈V,v∈K
O(log k) · ET∼D

1

cuv · ET∼D[dT (u, v)]
(cid:104) (cid:88)

(cid:105)

cuv · dT (u, v)

u∈V,v∈K

(21)

.

manner as the optimal algorithm, which would have the cost(cid:80)

Observe that for any tree T ∈ supp (D) we could have served the request sequence in the same
u∈V,v∈K cuv · dT (u, v). In particular,
the optimal solution optT for the same requests with the input graph T cannot be larger than that,
i.e.

cuv · dT (u, v) ≥ optT .

(22)

(cid:88)

u∈V,v∈K

Our algorithm will operate as follows: Pick a random tree according to the distribution D, pick
a random strategy S for transmitting ﬁles in T according to the distribution S(T ) guaranteed to
exists by Theorem 15, and serve the requests according to S. Denote by costH (S) the cost of
applying strategy S with distances taken in the graph H. For any possible T ∈ supp (D) it holds
that

ES∼S(T )[costT (S)]

ES∼S(T )[costG (S)]

optT ≥

O(log m)

O(log m)

≥

,

(23)

where the last inequality holds since T dominates G (i.e. dT (u, v) ≥ dG(u, v) for all u, v ∈ V ).
Combining equations (21), (22) and (23) we get that

ET∼DES∼S(T )[costG (S)]

O(log k log m)

.

optG ≥

Hence our randomized algorithm has O (log m log k) competitive ratio, as promised.

11 Acknowledgements

We would like to thank Robert Krauthgamer, Yair Bartal and Manor Mendel for fruitful discussions,
and to an anonymous referee for an idea leading to Theorem 2.

References

[ABC+05]

Ittai Abraham, Yair Bartal, T-H. Hubert Chan, Kedar Dhamdhere Dhamdhere, Anupam Gupta,
Jon Kleinberg, Ofer Neiman, and Aleksandrs Slivkins. Metric embeddings with relaxed guaran-
tees. In Proceedings of the 46th Annual IEEE Symposium on Foundations of Computer Science,
FOCS ’05, pages 83–100, Washington, DC, USA, 2005. IEEE Computer Society.

45

[ABN08]

[ABN11]

[ABN15]

[ABP92]

In
Ittai Abraham, Yair Bartal, and Ofer Neiman. Nearly tight low stretch spanning trees.
FOCS ’08: Proceedings of the 2008 49th Annual IEEE Symposium on Foundations of Computer
Science, pages 781–790, Washington, DC, USA, 2008. IEEE Computer Society.

Ittai Abraham, Yair Bartal, and Ofer Neiman. Advances in metric embedding theory. Advances
in Mathematics, 228(6):3026 – 3126, 2011.

Ittai Abraham, Yair Bartal, and Ofer Neiman. Embedding metrics into ultrametrics and graphs
into spanning trees with constant average distortion. SIAM J. Comput., 44(1):160–192, 2015.

B. Awerbuch, A. Baratz, and D. Peleg. Eﬃcient broadcast and light-weight spanners. Technical
Report CS92-22, The Weizmann Institute of Science, Rehovot, Israel., 1992.

[ADD+93]

I. Alth¨ofer, G. Das, D. P. Dobkin, D. Joseph, and J. Soares. On sparse spanners of weighted
graphs. Discrete & Computational Geometry, 9:81–100, 1993.

[AF09]

Reid Andersen and Uriel Feige. Interchanging distance and capacity in probabilistic mappings.
Technical report, 2009.

[AKPW95] Noga Alon, Richard M. Karp, David Peleg, and Douglas West. A graph-theoretic game and its

application to the k-server problem. SIAM J. Comput., 24(1):78–100, 1995.

[ALN07]

[ALN08]

[AN12]

[AR98]

Sanjeev Arora, James R. Lee, and Assaf Naor. Fr´echet embeddings of negative type metrics.
Discrete & Computational Geometry, 38(4):726–739, 2007.

S. Arora, J. R. Lee, and A. Naor. Euclidean distortion and the sparsest cut. Journal of the
American Mathematical Society 21, 1:1–21, 2008.

Ittai Abraham and Ofer Neiman. Using petal-decompositions to build a low stretch spanning
tree. In STOC, pages 395–406, 2012.

Yonatan Aumann and Yuval Rabani. An O(log k) approximate min-cut max-ﬂow theorem and
approximation algorithm. SIAM Journal on Computing, 27(1):291–301, 1998.

[ARV09]

Sanjeev Arora, Satish Rao, and Umesh V. Vazirani. Expander ﬂows, geometric embeddings and
graph partitioning. J. ACM, 56(2), 2009.

[Bar96]

[Bar04]

[BFN16]

[BFR95]

Yair Bartal. Probabilistic approximations of metric spaces and its algorithmic applications. In
FOCS, pages 184–193, 1996.

Yair Bartal. Graph decomposition lemmas and their role in metric embedding methods. In ESA,
pages 89–97, 2004.

Yair Bartal, Arnold Filtser, and Ofer Neiman. Constructing almost minimum spanning trees
with constant average distortion. In SODA, 2016.

Yair Bartal, Amos Fiat, and Yuval Rabani. Competitive algorithms for distributed data man-
agement. J. Comput. Syst. Sci., 51(3):341–358, 1995.

[BLMN05] Yair Bartal, Nathan Linial, Manor Mendel, and Assaf Naor. Some low distortion metric ramsey

problems. Discrete & Computational Geometry, 33(1):27–41, 2005.

[Bou85]

[CE05]

J. Bourgain. On lipschitz embedding of ﬁnite metric spaces in hilbert space. Israel Journal of
Mathematics, 52(1-2):46–52, 1985.

Don Coppersmith and Michael Elkin. Sparse source-wise and pair-wise distance preservers. In
Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’05,
pages 660–669, Philadelphia, PA, USA, 2005. Society for Industrial and Applied Mathematics.

[CKR04] Gruia C˘alinescu, Howard J. Karloﬀ, and Yuval Rabani. Approximation algorithms for the 0-

extension problem. SIAM Journal on Computing, 34(2):358–372, 2004.

46

[CLLM10] Moses Charikar, Tom Leighton, Shi Li, and Ankur Moitra. Vertex sparsiﬁers and abstract
rounding algorithms. In 51th Annual IEEE Symposium on Foundations of Computer Science,
FOCS 2010, October 23-26, 2010, Las Vegas, Nevada, USA, pages 265–274, 2010.

[CXKR06] T.-H. Chan, Donglin Xia, Goran Konjevod, and Andrea Richa. A tight lower bound for the
steiner point removal problem on trees. In Proceedings of the 9th International Conference on Ap-
proximation Algorithms for Combinatorial Optimization Problems, and 10th International Con-
ference on Randomization and Computation, APPROX’06/RANDOM’06, pages 70–81, Berlin,
Heidelberg, 2006. Springer-Verlag.

[EEST08] Michael Elkin, Yuval Emek, Daniel A. Spielman, and Shang-Hua Teng. Lower-stretch spanning

trees. SIAM Journal on Computing, 38(2):608–628, 2008.

[EFN15] Michael Elkin, Arnold Filtser, and Ofer Neiman. Prioritized metric structures and embedding. In
Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing, STOC
2015, Portland, OR, USA, June 14-17, 2015, pages 489–498, 2015.

[EGK+14] Matthias Englert, Anupam Gupta, Robert Krauthgamer, Harald R¨acke, Inbal Talgam-Cohen,
and Kunal Talwar. Vertex sparsiﬁers: New results from old techniques. SIAM J. Comput.,
43(4):1239–1262, 2014.

[ES11]

[FLM77]

[FRT04]

Michael Elkin and Shay Solomon. Steiner shallow-light trees are exponentially lighter than
spanning ones. In IEEE 52nd Annual Symposium on Foundations of Computer Science, FOCS
2011, Palm Springs, CA, USA, October 22-25, 2011, pages 373–382, 2011.

T. Figiel, J. Lindenstrauss, and V.D. Milman. The dimension of almost spherical sections of
convex bodies. Acta Mathematica, 139(1):53–94, 1977.

Jittat Fakcharoenphol, Satish Rao, and Kunal Talwar. A tight bound on approximating arbitrary
metrics by tree metrics. J. Comput. Syst. Sci., 69(3):485–497, 2004.

[GNR10]

Anupam Gupta, Viswanath Nagarajan, and R. Ravi. An improved approximation algorithm for
requirement cut. Oper. Res. Lett., 38(4):322–325, 2010.

[GP68]

E. N. Gilbert and H. O. Pollak. Steiner minimal trees. SIAM Journal on Applied Mathematics,
16(1):1–29, Jan 1968.

[Gup01a] Anupam Gupta. Steiner points in tree metrics don’t (really) help. In Proceedings of the Twelfth
Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’01, pages 220–227, Philadel-
phia, PA, USA, 2001. Society for Industrial and Applied Mathematics.

[Gup01b] Anupam Gupta. Steiner points in tree metrics don’t (really) help. In SODA, pages 220–227,

2001.

[HPIS13]

Sariel Har-Peled, Piotr Indyk, and Anastasios Sidiropoulos. Euclidean spanners in high di-
In Proceedings of the Twenty-Fourth Annual ACM-SIAM Symposium on Discrete
mensions.
Algorithms, SODA ’13, pages 804–809. SIAM, 2013.

[JL84]

William Johnson and Joram Lindenstrauss. Extensions of Lipschitz mappings into a Hilbert
space. Contemporary Mathematics, 26:189206, 1984.

[KKN14]

Lior Kamma, Robert Krauthgamer, and Huy L. Nguyen. Cutting corners cheaply, or how to
remove steiner points. In SODA, pages 1029–1040, 2014.

[KLMN05] Robert Krauthgamer, James R. Lee, Manor Mendel, and Assaf Naor. Measured descent: a new
embedding method for ﬁnite metrics. Geometric and Functional Analysis, 15(4):839–858, 2005.

[KRY95]

Samir Khuller, Balaji Raghavachari, and Neal E. Young. Balancing minimum spanning trees
and shortest-path trees. Algorithmica, 14(4):305–321, 1995.

47

[KSW09]

Jon Kleinberg, Aleksandrs Slivkins, and Tom Wexler. Triangulation and embedding using small
sets of beacons. J. ACM, 56(6):32:1–32:37, September 2009.

[KV13]

[LLR95]

[LR99]

[Mat96]

[MM10]

[MN06]

[Moi09]

[R¨02]

[R¨ac08]

[RR98]

[RTZ05]

Telikepalli Kavitha and Nithin M. Varma. Small stretch pairwise spanners. In Proceedings of
the 40th International Conference on Automata, Languages, and Programming - Volume Part I,
ICALP’13, pages 601–612, Berlin, Heidelberg, 2013. Springer-Verlag.

N. Linial, E. London, and Y. Rabinovich. The geometry of graphs and some of its algorithmic
applications. Combinatorica, 15(2):215–245, 1995.

Frank Thomson Leighton and Satish Rao. Multicommodity max-ﬂow min-cut theorems and
their use in designing approximation algorithms. J. ACM, 46(6):787–832, 1999.

Jiri Matouˇsek. On the distortion required for embeding ﬁnite metric spaces into normed spaces.
volume 93, pages 333–344, 1996.

Konstantin Makarychev and Yury Makarychev. Metric extension operators, vertex sparsiﬁers
In 51th Annual IEEE Symposium on Foundations of Computer
and lipschitz extendability.
Science, FOCS 2010, October 23-26, 2010, Las Vegas, Nevada, USA, pages 255–264, 2010.

Manor Mendel and Assaf Naor. Ramsey partitions and proximity data structures. In FOCS,
pages 109–118, 2006.

Ankur Moitra. Approximation algorithms for multicommodity-type problems with guarantees
independent of the graph size. In FOCS, pages 3–12, 2009.

Harald R¨acke. Minimizing congestion in general networks. In Proceedings of the 43rd Symposium
on Foundations of Computer Science, FOCS ’02, pages 43–52, Washington, DC, USA, 2002.
IEEE Computer Society.

Harald R¨acke. Optimal hierarchical decompositions for congestion minimization in networks. In
STOC, pages 255–264, 2008.

Yuri Rabinovich and Ran Raz. Lower bounds on the distortion of embedding ﬁnite metric spaces
in graphs. Discrete & Computational Geometry, 19(1):79–94, 1998.

Liam Roditty, Mikkel Thorup, and Uri Zwick. Deterministic constructions of approximate dis-
tance oracles and spanners. In Proceedings of the 32Nd International Conference on Automata,
Languages and Programming, ICALP’05, pages 261–272, Berlin, Heidelberg, 2005. Springer-
Verlag.

48

Appendix

A A lower bound on the tradeoﬀ between lightness and stretch

for terminal trees in metric spaces

In this section we extend our lower bound from Section 6.2 to the metric case.

The metric space case is similar to the graph case. We will use the metric closure of the graph
from the previous section. The main diﬃculty is however to show that the non-graph edges do not
help at all.

bers, we deﬁne a graph Gk,n0,n1,...,nk−1. The graph has n = k +(cid:80)
For a positive integer parameter k and a k−sequence n0, n1, . . . , nk−1 of positive integer num-
i ni vertices and k terminals.
The k terminals are V (cid:48) = {v0, . . . , vk−1}. For every index i ∈ [0, k − 1] there is an ni-vertex path
Pi. (We will use Pi to denote both the path, and the set of vertices in the path.) All edges in
these paths have unit weight. Also, for each i ∈ [0, k − 1], both vi and vi+1 (the index arithmetic is
modulo k) are connected to every vertex in Pi by edges of weight w, for a parameter w > 1. Observe
that the graph G from Section 6.2 satisﬁes G = Gk,n0,n1,...,nk−1 with n0 = n1 = ··· = nk−1 = n.
Let Gk,n0,...,nk−1 denote the metric closure of Gk,n0,...,nk−1. We also write G = Gk,n0,...,nk−1 and
G = Gk,n0,...,nk−1.
Lemma 16. For any spanning tree T of Gk,n0,...,nk−1 there exists an index i such that for any vertex
u ∈ Pi either

(vi,u) ≥ 2k − 1 or

(vi,u) ≥ 2k − 1.

dT (vi+1,u)

dT (vi,u)

dGk,n0,...,nk−1

dGk,n0,...,nk−1

dT (vi+1,u)

dGk,n0,...,nk−1

dT (vi,u)
dGk,n0,...,nk−1

(vi,u) ≥ 2k − 1 and in the latter

Remark 3. Observe that for a graph spanning tree T this lemma follows directly from the observa-
tion that there exists an index i such that the path in T from vi to vi+1 does not contain vertices of
Pi. Indeed, for this index i and a vertex u ∈ Pi, either (vi, u) /∈ T or (vi+1, u) /∈ T . In the former
(vi+1,u) ≥ 2k − 1. The lemma proves
case
this statement in a much greater generality, speciﬁcally, for T being a spanning tree of the metric
closure Gk,n0,...,nk−1 of Gk,n0,...,nk−1.
Proof. For a spanning tree T of Gk,n0,...,nk−1 and an index i ∈ [0, k − 1], denote by tT,i the number
(vi+1,u) ≥ 2k − 1. We will
of vertices u in Pi such that
show that for any spanning tree T there exists an index i such that tT,i = ni. For a tree T ,
deﬁne γ (T ) = mini {ni − tT,i}. Observe that γ (T ) ≥ 0. It suﬃces to prove that for every tree T ,
γ (T ) = 0. Also, let µ = maxT {γ (T )}, where the maximum is taken over all spanning trees of
Gk,n0,...,nk−1. It is enough to show that µ = 0, i.e., that for every spanning tree T , γ (T ) = 0.
For each vertex, we deﬁne the right and the left hemisphere with respect to this vertex. Consider
a supergraph, where we replace each path Pi by a supernode pi. We obtain the 2k−cycle C2k. The
right hemisphere of vi consists of all the vertices between vi and its antipodal vertex (in the path
pi, vi+1, pi+1, . . . ), while the left hemisphere of vi consists of all the vertices in the other shortest
path from vi to its antipodal vertex (pi−1, vi−1, pi−2, . . . ). Formally, for a terminal vi, if k is even, let

(vi,u) ≥ 2k − 1 or

dGk,n0,...,nk−1

dGk,n0,...,nk−1

dT (vi+1,u)

dT (vi,u)

(cid:110)

(cid:111)(cid:111)

and L (vi) = (cid:83)(cid:110)(cid:110)
(cid:111)

(cid:111)
and L (vi) = (cid:83)(cid:110)

vi+ k

2

(cid:110)
(cid:110)

, Pi+ k

,

2

vi+ k

2

+1

Pi+ k−1

,

2

vi+ k+1

2

(cid:111)
(cid:111)

(cid:111)
(cid:111)

, . . . , Pi−1

if k is
.

, . . . , Pi−1

denote the right and the left hemispheres with respect to vi, respectively. Similarly,

R(vi) = (cid:83)(cid:110)
odd then R(vi) = (cid:83)(cid:110)

Pi,{vi+1} , Pi+1, . . . ,

vi+ k

2

Pi,{vi+1} , . . . , Pi+ k−1

2

i

Figure 4: An illustration of the partition of the graph to the right and the left hemispheres with
respect to a terminal vi. This example is for odd k. Note that the path Pi+ k−1
is both in the right
and the left hemispheres.

2

In addition we deﬁne hemispheres for non-terminal vertices.
vertices in Pi have the same hemispheres.

R(u) = (cid:83)(cid:110)
(cid:111)
(cid:83)(cid:110)(cid:110)

is

If

k

and L (u) = (cid:83)(cid:110)
(cid:111)
= (cid:83)(cid:110)
(cid:111)
(cid:111)

Pi+ k
,
{vi+1} , Pi+1,{vi+2} , . . . ,

For a vertex u ∈ Pi,
vi+ k

(cid:110)
(cid:110)

vi+ k+1

2

2

(cid:111)
(cid:111)(cid:111)

For an index i, all the
then
.

if k is even,
, Pi+ k

+1, . . . ,{vi}

+1

2

2

and L (u)

=

(cid:111)

{vi+1} , Pi+1,{vi+2} , . . . , Pi+ k
odd then R(u)

2

(cid:110)

2

2

2

,

+1

vi+ k+1

, Pi+ k+1

, . . . ,{vi}

. (See Figure 4 for an illustration.)

vi+ k+1
For a vertex u ∈ V and an index i ∈ [0, k − 1], we say that all the edges from u to Pi, i.e.,
{{u, z} | z ∈ Pi} , are of the same type. In addition, the edge from u to vi has a unique type. (Note
that each non-terminal vertex might have edges of 2k diﬀerent types, while a terminal vertex can
be incident to edges of 2k − 1 diﬀerent types.) An edge e = {u, z} such that u, z are in the same
path Pi called an path-internal edge. A vertex u is called a same-path neighbor of a, b in the tree
T , if there are edges {u, a} ,{u, b} in T and a, b belong to the same path Pi. For a simple path π
in Gk,n0,...,nk−1 we say that π is a one-sided path if for any internal vertex x in π, the two edges
(x, y1) , (x, y2) which are incident on x in π, connect x to diﬀerent hemispheres, i.e., e.g., y1 is in
the left hemisphere with respect to x, and y2 is in the right one.

i=1 ni = A. The base case where(cid:80)k

i=1 ni = k (i.e.,

for all i ∈ [0, k − 1], ni = 1) follows by Theorem 7.
The induction step: assume that the claim is true for A and we will prove it for A + 1. Let T
be some spanning tree of Gk,n0,...,nk−1 with minimal weight among all the trees with γ (T ) = µ. By

The proof (that µ = 0) is by induction on(cid:80)k
our assumption(cid:80)k

i=1 ni = A + 1.

Claim 17. For any vertex u (either terminal or a non-terminal one), if there exist two edges
{u, a},{u, b} in T that connect u to two vertices a, b ∈ R (u), then the two vertices a and b belong
to the same path Pi. The same is true for the left hemisphere L (u) of u as well.

Proof. Suppose for contradiction that there exist two edges {u, a},{u, b} in T as above (i.e., with
a, b ∈ R (u)) and such that these two edges have diﬀerent type.
(In other words, dG (u, a) (cid:54)=

ii

viL(vi)R(vi)vi−1vi+1PiPi−1Pi+k−12Figure 5: An illustration of the special edges that we use in the proof of Lemma 16.

Figure 6: An illustration of deleting a path-internal edge {u, z} in the tree T .

dG (u, b).) Without loss of generality dG (u, a) < dG (u, b). We construct a new tree T (cid:48) by replacing
{u, b} by {a, b} . This change decreases the weight of the tree. Note that any path π in T that
uses the edge {u, b} can be replaced by a similar path that uses the edges {u, a} and {a, b} instead
of {u, b}. Clearly, the length of the path does not change. Hence for every index i, the value tT,i
does not increase. Hence γ (T ) = mini {n − tT,i} does not decrease, and since T is a tree with
γ (T ) = µ = maxT (cid:48)(cid:48) {γ (T (cid:48)(cid:48))}, it follows that γ (T (cid:48)) = γ (T ) = µ. This is a contradiction to the
minimality of the weight of T among trees with γ () value equal to µ. Obviously, the same argument
also applies for a, b ∈ L (u).

We now continue proving Lemma 16. The rest of the proof splits into a number of cases which

are characterized by existence of certain edges in the tree T .

• Case 1: There is a path-internal edge in T . Assume there is a path-internal edge between
vertices in a path Pj, for some index j ∈ [0, k − 1]. Note that if all the vertices which have
path-internal edges in Pj have more than one path-internal edge incident on them in T , then
the graph induced by those vertices contains a cycle. However, this graph is a subgraph of T ,
contradiction. Hence there is a vertex u ∈ Pj such that u has exactly one path-internal edge
{u, z} incident on u in T . Assume without loss of generality that j = 0. Delete the vertex u
and replace each edge {u, a} incident on u in T by an edge {z, a}. (Note that u has only one
path-internal edge in T . Thus is the edge {u, z}. Therefore vertex a as above do not belong to
Pj = P0.) Denote the resulting tree by T (cid:48). Note that T (cid:48) is a spanning tree for Gk,n0−1,n1,...,nk−1.
(See Figure 6 for an illustration.) (T (cid:48) is obviously connected and we reduce the number of
edges by exactly 1, hence it is a spanning tree of Gk,n0−1,n1,...,nk−1.) Note that for every two
vertices a, b in Gk,n0−1,n1,...,nk−1, we have dT (cid:48) (a, b) ≤ dT (a, b), to see this consider the shortest

iii

vivi+1uwvivi+1u1u2InternaledgeCommonneighborv0vk−1uzv0vk−1zTT0path π from a to b in T . If the vertex u is not taking part in π then the claim is trivial, hence we
assume that u is taking part. If the path π include the edge {u, z}, then obviously π\{{u, z}}
is a path from a to b in T (cid:48) and therefore dT (cid:48) (a, b) ≤ dT (a, b). Otherwise, the path π does not
include the edge {u, z}, set π = aw1 . . . wruwr+1 . . . wmb where wr, wr+1 /∈ P0 because u has
only one path-internal edge to z, therefore π(cid:48) = aw1 . . . wrzwr+1 . . . wmb is path from a to b in
T (cid:48) of length smaller or equal then π in T (wr, wr+1 /∈ P0 implies dT (wr, u) = dT (cid:48) (wr, z)
and dT (u, wr+1) = dT (cid:48) (z, wr=1), and all the other edges remain in T with smaller or
equal weight.) Moreover, for each q ∈ Pi, dGk,n0,...,nk−1
(vi+1, q) =
(vi+1, q) = w, therefore dT (vi, q) ≥ dT (cid:48) (vi, q)
dGk,n0−1,n1,...,nk−1
≥
and dT (vi+1, q) ≥ dT (cid:48) (vi+1, q)
max
i = ni, for ev-

(vi, q) = dGk,n0−1,n1,...,nk−1

Gk,n0−1,n1,...,nk−1
ery i ∈ [1, k − 1] . By the induction hypothesis, there is an index i such that tT (cid:48),i = n(cid:48)
i. If
i (cid:54)= 0 then tT (cid:48),i = n(cid:48)
i, and in particular by the previews argument tT,i ≥ tT (cid:48),i. Since, by
deﬁnition, tT,i ≤ ni, it follows that tT,i = ni, as required. If i = 0 , then tT (cid:48),0 = n(cid:48)
0 = n0 − 1.
A vertex a ∈ P0\{u, z}, contributes 1 to tT (cid:48),0, and hence contributes 1 also to tT,0. Moreover,
dT (v0, u) , dT (v0, z) ≥ dT (cid:48) (v0, z), and analogously dT (v1, u) , dT (v1, z) ≥ dT (cid:48) (v1, z). Since
z contributes 1 to tT (cid:48),0 it follows that u and z each contribute 1 to tT,0 and so tT,0 = n0,
completing the proof of case 1.

Gk,n0,...,nk−1
0 = n0 − 1, n(cid:48)

dT(cid:48) (vi,q)
Gk,n0,...,nk−1
. Denote n(cid:48)

(vi, q) = dGk,n0,...,nk−1

dT(cid:48) (vi+1,q)
Gk,n0−1,n1,...,nk−1

(cid:26)
(cid:27)

implies max

dT(cid:48) (vi+1,q)

dT(cid:48) (vi,q)

(vi,q) ,

(cid:27)

(cid:26)

(vi+1,q)

(vi+1,q)

(vi,q)

,

• Case 2: There are no path-internal edges in T , and there is a path Pi, with two ver-
tices u1, u2 ∈ Pi which have a same-path neighbor z /∈ Pi. Without loss of generality
i = 0. Similarly to the previous case, delete u2 and replace any edge of the form {u2, a}
by edge of the form {u1, a}. Denote the resulting tree by T (cid:48). Note that T (cid:48) is a span-
(T (cid:48) is obviously connected and we reduce the number of
ning tree for Gk,n0−1,n1,...,nk−1.
edges by exactly 1.) For each two vertices a, b in Gk,n0−1,n1,...,nk−1, dT (cid:48) (a, b) ≤ dT (a, b), to
see this, consider the shortest path π from a to b in T .
If the vertex u2 does not taking
part in π then the claim is trivial. Otherwise, set π = aw1 . . . wru2wr+1 . . . wmb, therefore
π(cid:48) = aw1 . . . wru2wr+1 . . . wmb is path from a to b in T (cid:48) of equal length to the path π in
T (There are no path-internal edges hence dT (wr, u1) = dT (cid:48) (wr, u2) and dT (u1, wr+1) =
dT (cid:48) (u2, wr=1), and all the other edges remain with equal weight.). As in previews case,
this argument implies for every q ∈ Pi, max
≥
i = ni, for ev-
max

dT(cid:48) (vi,q)
Gk,n0,...,nk−1
. Denote n(cid:48)

Gk,n0,...,nk−1
0 = n0 − 1, n(cid:48)

dT(cid:48) (vi+1,q)

dT(cid:48) (vi,q)

(cid:27)

(cid:26)

(cid:27)

(cid:26)

(vi+1,q)

(vi+1,q)

(vi,q)

(vi,q)

dT(cid:48) (vi+1,q)
Gk,n0−1,n1,...,nk−1

ery i ∈ [1, k − 1] . By the induction hypothesis, there is a path P (cid:48)
i. If
i (cid:54)= 0 then obviously tT,i = n(cid:48)
i. Otherwise, i = 0, vertex a ∈ P0\{u2}, contributes 1 to
tT (cid:48),0, and hence contributes 1 also to tT,0. In particular max{dT (u2, v0) , dT (u2, vk−1)} ≥
max{dT (cid:48) (u1, v0) , dT (cid:48) (u1, vk−1)}, hence u2 also contributes 1 to tT (cid:48),0, we get tT,0 = tT (cid:48),0 + 1 =
n(cid:48)
0 + 1 = n0 as required.

i such that tT (cid:48),i = n(cid:48)

Gk,n0−1,n1,...,nk−1

,

,

• Case 3: There are no path-internal edges, and no same-path neighbors in T . In particular,
any vertex has at most two edges: one edge to his right and left hemispheres (There is at
most one type in each hemisphere, because two edges of the same type implies same-path
neighbor.) Hence any path π in T is one-sided. There have to be two terminals vi, vi+1 such

iv

Figure 7: A visualization of the contradiction during the proof of Theorem 16. We assume that u
does not have outgoing edge of weight w. From the assumption that the distance from u to vi is
(2k − 1) w we conclude that the distance from q to vi is larger then (2k − 1) w, a contradiction.

that there is no path between them of length 2w (otherwise, there is a cycle). Hence for all
u ∈ Pi there are no edges to both vi, vi+1. If without loss of generality {u, vi} /∈ T , then
the shortest one-sided path between u and vi is of length at least 2k − 1, implying that the
terminal distortion is at least 2k − 1, hence tT,i = 0 as required!

Theorem 16. For any positive integer parameters k, n and  > 0 such that k ≤ 
tree T of Gk,n,n,...,n where w = k

 , with terminal distortion at most (2k − 1)(cid:0)1 + 

at least Ω(cid:0) 1

(cid:1).

(cid:1) has lightness

2 n, any spanning
k2



Proof. By Lemma 16 there is a path Pi such that any u ∈ Pi has distortion at least 2k − 1 from vi
or vi+1. We will show that each u ∈ Pi is included in non path-internal edge of weight at least w.
Some observations before we prove it:

• Each u ∈ Pi is at distance exactly (2k − 1) · w from vi or vi+1. Otherwise the distance is at

least (2k − 1) w + 1 which implies

dT (u, vi)

dGk,n,...,n

(u, vi)

=

in contradiction to the (2k − 1)(cid:0)1 + 

= (2k − 1)

k2

(cid:18)

1 +

(cid:19)

(2k − 1) w + 1

w

= (2k − 1)

(cid:19)
(cid:18)
(cid:1) terminal distortion.

(2k − 1) k

1 +



1

(cid:16)

(2k − 1) w
1 +

(cid:17)


k2

> (2k − 1)

• For two neighbors u1, u2 in a tree, and any other vertex v. The shortest path from u1 to v
goes trough u2 or the shortest path from u2 to v goes trough u1. Otherwise there is a cycle.

Assume by contradiction, that there is u ∈ Pi with no outgoing edge of weight at least w.
Let p be the ﬁrst vertex on the shortest path from u to vi, and q be the ﬁrst vertex on the
shortest path from u to vi+1. W.l.o.g dT (vi, u) = (2k − 1) w. Hence dT (vi, p) < (2k − 1) w which

v

upqvivi+1implies dT (vi+1, p) = (2k − 1) w. The shortest path from p to vi+1 goes through u, as otherwise
dT (vi+1, u) > (2k − 1) w, contradiction. Hence p (cid:54)= q. Necessarily the shortest path from q to vi
goes through u, which implies dT (vi, q) > dT (vi, u) = (2k − 1) w, contradiction.

As k ≤ 

2 n we obtain Ψ (T ) ≥ 1

(2k − 1) w + (n − 1) k
2 as required.

We conclude that w (T ) > n · w. Hence,
n · w

Ψ (T ) =

w (T )

w (M ST ) ≥

=



n · k
 + (n − 1) k

(2k − 1) k

>

n

n + 2k

.

vi

