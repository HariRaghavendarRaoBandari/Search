6
1
0
2

 
r
a

 

M
6
1

 
 
]
P
A

.
t
a
t
s
[
 
 

1
v
7
9
2
5
0

.

3
0
6
1
:
v
i
X
r
a

A Computationally Eﬃcient Framework for Automatic

Inertial Sensor Calibration

James Balamutaa, St´ephane Guerriera, Roberto Molinarib, Wenchao Yanga

aDepartment of Statistics, University of Illinois at Urbana-Champaign, 725 S. Wright St.,

bResearch Center for Statistics, University of Geneva, 1208 Geneva, Switzerland

Champaign IL, 61820, USA

Abstract

The calibration of (low-cost) inertial sensors has become increasingly important

over the past years since their use has grown exponentially in many applica-

tions going from unmanned aerial vehicle navigation to 3D-animation. How-

ever, this calibration procedure is often quite problematic since the signals is-

sued from these sensors have a complex spectral structure and the methods

available to estimate the parameters of these models are either unstable, com-

putationally intensive and/or statistically inconsistent. This paper presents a

new software platform for inertial sensor calibration based on the Generalized

Method of Wavelet Moments which provides a computationally eﬃcient, ﬂexi-

ble, user-friendly and statistically sound tool to estimate and select from a wide

range of complex models. The software is developed within the open-source

statistical software R and is based on C++ language allowing it to achieve high

computational performance.

Keywords: Generalized method of wavelet moments, Wavelet variance, Allan

variance, Error modeling, Time series, Estimation methods,

Micro-electro-mechanical systems, Kalman ﬁlter, R software.

Email addresses: balamut2@illinois.edu (James Balamuta), stephane@illinois.edu

(St´ephane Guerrier), roberto.molinari@unige.ch (Roberto Molinari),
wyang40@illinois.edu (Wenchao Yang)

Preprint submitted to Signal Processing

March 18, 2016

1. Introduction

An inertial measurement unit (IMU) is a device whose composition is typ-

ically a triad of accelerometers and gyroscopes, which provide a measurement

of the speciﬁc force of acceleration as well as the rate of angular movement.

With the advances in microtechnology, the premise of a low-cost miniaturized

IMU is possible through the construction of a Micro-Electro-Mechanical Sys-

tem (MEMS) device, which is a compact and light version of an IMU [1]. As

a result of low cost, light weight, and lower energy consumption, the number

of applications privy to inertial sensors have increased tremendously, leading

to a considerable amount of attention being aﬀorded to device performance by

researchers. These developments have thus enabled inertial sensors to be em-

bedded in countless consumer-facing goods that range from smart phones to

exercise equipment as autonomous automobiles, while also ﬁnding further use

in military applications such as unmanned aerial vehicles [2].

Despite the considerable amount of applications that MEMS sensors are used

for, their small size and low cost compared to the higher grade IMU comes at the

price of fairly large and variable measurement errors. As a result, there is a con-

siderable amount of research that solely focuses on modelling and compensating

for these errors by attempting to characterize their complex noise structure. To

do so, there are diﬀerent methods which have been regularly used to date, albeit

being aﬀected by diﬀerent drawbacks. The main and most statistically sound

of the latter approaches is represented by the Maximum Likelihood (ML) which

has been widely studied and used for the task of inertial sensor calibration. In

[3], the ML was implemented through the use of the Expectation-Maximization

(EM) algorithm employed alongside a Kalman ﬁlter to attempt the parameter

estimation of a State-Space Model (SSM). Although this procedure works well

in simple SSM settings, it tends to diverge in only moderately more complex

scenarios which are often more realistic for the characterization of inertial sensor

error signals. A similar approach was used in [4] and [5] to improve the results

by implementing, respectively, a nonlinear adaptive Kalman Filter (KF) and a

2

log-sampling scheme without however overcoming the mentioned convergence

and numerical instability issues. Moreover, the ML can be time consuming to

implement and may require considerable eﬀort to estimate a new model (see [3]).

To mainly tackle the latter obstacle, another existing method is the “graphi-

cal” Allan Variance Linear Regression (AVLR) which makes use of the slope in

the linear regions of a log-log plot of the Allan variance (AV) to estimate the

parameters of the underlying processes. For this method, [2] and [6] provide a

thorough overview of the approach describing how to distinguish the diﬀerent

underlying processes via graphical representations of the AV. Nevertheless, al-

though still being widely used, [7] formally proved that this method is ineﬃcient

and inconsistent in the vast majority of cases. Considering this, a diﬀerent use

of the AV was presented in [8] where the parameters of a process composed by

a white noise and a random walk were simultaneously estimated in a method of

moments fashion.

Given the limitations of existing techniques, a new estimation method was

proposed by [9] called the Generalized Method of Wavelet Moments (GMWM).

Based on the idea of Generalized Method of Moments (GMM) estimators, the

GMWM makes use of the relation between the Wavelet Variance (WV) and

the parameters of a process, estimating the latter by minimizing the distance

between the empirical and model-based WV (see Section 2). It must be noted

that this method could also be based on the AV since the Haar WV is simply

twice the AV. Having said this, in a way this estimator can be viewed as a

generalized version of [8] with additional beneﬁts. This estimator beneﬁts from

numerous advantages, among which we can highlight its good statistical prop-

erties, its ease of implementation and its computational eﬃciency. Moreover,

the nature of this estimator has allowed to deliver additional statistical tools

which are of particular interest for the purpose of inertial sensor calibration.

For instance, the development of a model selection criteria to eﬀectively rank

models while taking into account their complexity. In addition, there exists a

robust estimation version of the GMWM that is applicable for dealing with data

that has become contaminated (e.g. outliers or inﬂuential points). Additional

3

research is being developed to extend this estimation framework to multivari-

ate and non-stationary (dynamic) settings which are also of interest for sensor

calibration.

Considering these results and properties, this paper introduces the software

platform which allows practitioners and researchers to have wide access to all

the tools linked to the GMWM, going from the calculation of the WV to the

estimation of parameters and selection of simple and complex error models.

This platform is provided by the newly developed “gmwm” package in the R

open source statistical software and makes use of the C++ language to ensure

higher computational eﬃciency (see Appendix A for some details). As de-

scribed in Section 3, developing an R package not only allows anyone to access

the methodologies and functions of the GMWM but also provides a platform

which is eﬃcient and can easily be brought up to date with the most recent

developments.

The paper is organized as follows: in Section 2 we give a brief overview of

the GMWM and its related existing tools while in Section 3 we introduce the

software platform by presenting its main features in the relative subsections

going from model identiﬁcation to model selection. Finally, Section 4 concludes

by giving an overview of the upcoming developments of the GMWM which will

be included in future software updates to deliver additional important tools for

inertial sensor calibration.

2. The Generalized Method of Wavelet Moments

In this section, we provide a brief description of the GMWM estimator along

with an overview of the main tools that have been derived and are implemented

within the package (for a more thorough description the methods and their prop-

erties refer to [9, 10, 11]). As mentioned in the previous section, the GMWM

relies on the WV, which is the variance of the wavelet coeﬃcients (Wj,t), is-

sued from a wavelet decomposition of a signal (see, for example, [12] for an

overview). In the context of the GMWM, this decomposition is currently based

4

solely on the Haar wavelet and therefore all the results in this paper rely on

this type of ﬁlter. Furthermore, the platform is able to provide both the Dis-

crete Wavelet Transform (DWT) and the Maximum Overlap Discrete Wavelet

Transform (MODWT), which are unbiased estimators with the later being more

eﬃcient. Due to the signiﬁcant eﬃciency gain provided by the latter, it is the

default method on which the WV estimator is built using the proposal of [13]

who deﬁnes the MODWT WV estimator ˆν2

ˆν2
j =

1

T − Lj + 1

W 2

j,t.

(1)

j as

T(cid:88)

t=Lj

where T represents the length of the signal, j = 1, . . . , J (with J = (cid:98)log2(T )(cid:99),
where (cid:98)·(cid:99) denotes the largest integer not greater than the corresponding argu-
ment) represents the scale of decomposition and Lj is the length of the (Haar)

wavelet ﬁlter at scale j.

Having presented the WV estimator, we can now brieﬂy describe the WV
implied by a stochastic process Fθ where θ ∈ Θ ⊆ (cid:146)p represents the parameter
vector which deﬁnes the model. Denoting SFθ (f ) as being the Power Spectral

Density (PSD) of the process (Yt), this parameter vector is mapped to the WV

through the following relationship

(cid:90) 1/2

(cid:90) 1/2

ν2
j (θ) =

SWj (f )df =

−1/2

−1/2

|Hj(f )|2SFθ (f )df.

(2)

where Hj is the transfer function of the wavelet ﬁlters at scale j and | · | de-
notes the modulus operator. We can therefore see that the WV is a function

of the model parameters thereby providing a theoretical quantity which can be

matched with its estimated counterpart. The GMWM is based exactly on the

latter idea by attempting to inverse the relation between the WV and the param-
j ]j=1,...,J . To do so, the GMWM estimator ˆθ

eters to obtain θ(ˆν), where ˆν = [ν2

is deﬁned as

ˆθ = argmin

θ∈Θ

( ˆν − ν(θ))T Ω ( ˆν − ν(θ))

(3)

which therefore is the result of a generalized least squares minimization where

Ω represents a positive deﬁnite weighting matrix chosen in a suitable manner

5

[see e.g. 9]. Conditioned on the positive deﬁniteness of this matrix and denoting
the covariance matrix of ˆν as V , such that ν (θ) ≡ var ( ˆν), the main role of
Ω is to make the GMWM estimator as eﬃcient as possible and it was shown
that Ω = V −1 is the matrix which allows the GMWM estimator to achieve
maximum asymptotic eﬃciency.

In [9] the large sample properties of the GMWM were studied showing that

it is consistent and normally distributed for a wide range of time series mod-

els. A robust version of the GMWM was also given in [11] allowing to limit

the inﬂuence of contamination in the observed signal on the estimation process

while preserving suitable asymptotic properties. Using these properties and the

GMM form of the GMWM, additional useful results were derived for inference

purposes allowing to obtain, for example, conﬁdence intervals for the parame-

ters, goodness-of-ﬁt of the estimated models and selection criteria to determine

which model(s) is “best”.

While the parameter conﬁdence intervals are simply based on the asymptotic

normality of the GMWM, the goodness-of-ﬁt test is based on the test for over-

identifying restrictions for GMM-type estimators (also known as J-test). The

test statistic is given by

(cid:16)

ˆν − ν( ˆθ)

T

(cid:17)T

Ω∗(cid:16)

(cid:17) D−−→

H0

ˆν − ν( ˆθ)

χ2

J−p

(4)

where the Ω∗ denotes an appropriate weighting matrix whose form can be found
in [14]. The test statistic, as can be seen, follows a χ2 distribution under the null

hypothesis H0 which generally states that the diﬀerence between the empirical

vs. the theoretical WV is zero. That is, the sample moments are equivalent

to the true population moments. The asymptotic properties associated with

this test indicate that the test will not reject H0 asymptotically if the empirical

and theoretical moments align. However, it is known that models are only an

approximation of reality and, unless there exists a model that is “true”, the test

will nearly always reject this hypothesis when the sample size is extremely large.

This is indeed the case for inertial sensor calibration where the length of the

measured error signals are in the order of millions. Given this setting, another

6

useful development of the GMWM is the proposal of a selection criterion in [10]

called the Wavelet Information Criterion (WIC) whose estimator is deﬁned as

(cid:20)(cid:16)

follows

W IC = E

(cid:124)

ˆν − ν

ˆν − ν

Ω

(cid:16)

(cid:16) ˆθ
(cid:17)(cid:17)T
(cid:123)(cid:122)

A

(cid:17)(cid:17)(cid:21)
(cid:16) ˆθ
(cid:125)

+ 2 tr

(cid:124)

(cid:20)

cov

(cid:104)

(cid:17)(cid:105)T(cid:21)
(cid:16) ˆθ
(cid:125)

ˆν, Ων

(cid:123)(cid:122)

B

(5)

where tr [·] denotes the trace operator. This estimator is an unbiased estimate of
the “prediction” error made by using the estimated parameters from one signal

to predict the WV on another signal from the same data-geneating process.

Term A could be called “apparent loss” and is a measure of how well the model

ﬁts the observed signal. The latter typically diminishes as the model complexity

increases (e.g. adding more underlying models and parameters to the composite

process of interest) while term B does the opposite and therefore grows as the

model complexity increases. The latter term could be called “optimism” and

acts as a complexity-based penalty. There are diﬀerent manners to compute

this term such as parametric bootstrap (see [10], [15]) or using its asymptotic

approximation given in [16]. Considering these terms, the goal would be to

select the model with the smallest WIC value, meaning that we are selecting

the model with the smallest estimated prediction error.

To summarize, the GMWM provides a set of extremely useful tools for the

task of modelling the purely stochastic errors of inertial sensors for calibration

purposes. Based on these theoretical results, the next section presents the new

software platform with which it is possible to easily make use of all the advan-

tages of this new approach to signal characterization and modelling.

3. Implementation of the GMWM

The new software platform is developed and made available within the R

statistical software which is an open source implementation made available by

the R Foundation [17].

In this framework, the new platform is implemented

within the R package called “gmwm” whose main functions have been imple-

mented based on C++ language to ensure a high computational eﬃciency. This

7

is possible by making use of Rcpp [18] and RcppArmadillo [19] which provide

a seamless means to link R to C++ interfaces and the C++ matrix algebra

library known as Armadillo [20]. Therefore, having been streamlined in C++,

all methods written within the package are highly eﬃcient and are considerably

faster than the few existing counterparts implemented in R (see Appendix A).

Using this ﬂexible and eﬃcient framework, the gmwm package contains all

the features that are available within its predecessor, [21], while adding a con-

siderable amount of new features and functions. The main features of the new

platform can be summarized as follows:

1. Signal decomposition across dyadic scales τj = 2j, j = 1, ..., J:

• Supported wavelet ﬁlters: Daubechies (d), Fejer-Korovkin (fk),

Battle-Lemarie (bl), Least Asymmetric (la), and Minimum Band-

width (mb)

• Discrete Wavelet Transform (DWT);
• Maximum Overlap DWT (MODWT).

2. Computation of summary statistics:

• Allan Variance (AV): computed under the traditional deﬁnition or

the modiﬁed deﬁnition as described in [22] (denoted as σ¯y);

• Hadamard Variance (HV): a modiﬁcation of the AV as described in

[22];

• Wavelet Variance (WV): computed based on the diﬀerent ﬁlters and

transforms (with an option for it to be computed robustly in case of

outliers in the signal).

3. Identifying the Models:

• WV plots: the log-log WV plots are used in the same way as the

AV plots where the slopes of the linear parts and the non-linear

parts indicate the presence of certain processes in the model which

underlies the observed signal [see, for example, 6].

8

4. Estimating the Models:

• Parameter estimation: under a supplied model, identiﬁed from the

WV plot, the “gmwm()” function contains many options to estimate

the model parameters;

• Statistical Inference: either asymptotic or bootstrapped infer-

ence is available to create parameter conﬁdence intervals and model

goodness-of-ﬁt tests.

5. Model Selection:

• Graphical WV ﬁt: Having estimated the model, the WV implied

by the latter can be compared to the observed WV to understand

how well it describes the error signal;

• Selection procedure: under a speciﬁc set of models (or a general

model) a criterion is computed to obtain a “best” model(s) for the

signal as described in [23].

The ﬁrst step to take in order to make use of these features is, of course, to

load the calibration measurements onto the platform using either the function

read.imu() (speciﬁcally tailored to loading certain IMU measurements) or the

general R function read.table(). In the context of this paper, in order to better

describe these features within the following sections, we will make use of real-life

IMU data which is made available within a package called “imudata”1. Each

dataset comes from a diﬀerent sensor (e.g. MTi-G Micro-Electro-Mechanical

System (MEMS), NavChip, etc.) and has varying lengths of measurement. For

the purposes of this paper, we focus on examples using the NavChip and MTi-G

datasets that contain respectively around 3, 100, 000 and 900, 000 static obser-

vations with six columns representing the measurements for each accelerometer

and gyroscope axis. The MTi-G MEMS data was previously analyzed in [9] (we

will refer to this dataset as mtig), while the NavChip data is a recent acquire

1“imudata” R package is available at: https://github.com/smac-group/datarepo or by

using “gmwm::install imudata()” in R

9

which was sampled at 250Hz for roughly 3.5 hours (we will refer to this dataset

as navchip).

3.1. Identifying the Models

Once the data is available in the R session (see Appendix B), we can start

the procedure of modelling the stochastic error issued from an inertial sensor

which, ﬁrst of all, consists in understanding what kind of model could best

describe the observed signal. This is not necessarily an easy task but a simple

and useful tool which is often employed for this purpose is the log-log plot

of the AV versus its scales [6].

Indeed, according to the form of the AV, a

researcher can understand what kind of underlying processes are contributing

to the overall error model where a linear or non-linear behaviour in certain

regions of the plot can be linked to speciﬁc processes. The WV based on the

Haar wavelet decomposition is simply a rescaled version of the AV (i.e. σ¯y = 2ν)

and therefore the gmwm package makes use of the same visualization technique

(i.e. a log-log plot of the WV versus its corresponding scales). In order to begin

the visualization process, one must ﬁrst obtain the WV of the process(es) by

using the “wvar()” function. The results of this calculation can then be plotted

by using the function “plot()” to obtain the plot in Figure 1a, which depicts

the WV for each signal separately. By adding the parameter of “split = F”

to the “plot()” function, one is able to have the WV superimposed according

to whether the sensor is either a gyroscope or an accelerometer as in Figure

1b. It is also possible to compute the robust WV [see 11, 24] by adding the

“robust = T” parameter to the “wvar()” function. Within the same function,

it is also possible to specify the degree of eﬃciency of the robust estimator

with respect to the standard one where an eﬃciency close to 0.5 ensures a

high level of robustness and viceversa for a value close to 1. Computing the

WV from a robust perspective is helpful to check whether there appears to be

contamination (e.g. outliers or extreme observations) in the captured signal.

Indeed, to understand if modeling within a robust paradigm is required, one

should compare the standard WV with the robust version by using the function

10

(a) WV by Sensor and Axis

(b) Overlaid WV by Sensor

Figure 1: Plots produced by using the function plot() on the WV issued from

the function wvar() on the NavChip IMU. (a) Plot with parameter split=TRUE;

(b) Plot with parameter split=FALSE.

“compare.wvar()” to produce Figure 2. If the robust WV is visually diﬀerent

from the standard WV, then a robust analysis of the signals is preferable.

3.2. Estimating the models

The new platform, as seen in the previous section, makes available some

ﬂexible plotting tools which are already used (in diﬀerent forms) to identify the

models characterizing inertial sensor stochastic errors. However, the parameters

of these models are obviously not known and need to be estimated. As described

in Section 2, the GMWM allows for the estimation of these parameters in an

eﬃcient and consistent manner and the function which implements this method

is gmwm(). There are multiple arguments to this function which provide the

users with a ﬂexible range of options to tailor the estimation to their needs. In

the case of IMUs, there exists a function with preset values ideal to model IMU

error signals called gmwm.imu(). Both of these functions rely on users supplying

an error model which can be speciﬁed using a combination of all or a subset of

the following processes:

• GM(β,σ2

GM ): a Gauss-Markov process;

11

XYZ10-810-610-410-210-810-610-4AccelerometerGyroscope10-210-110010110210310410-210-110010110210310410-210-1100101102103104Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)HaarWaveletVarianceRepresentation110-810-610-410-210-810-610-4AccelerometerGyroscope10-210-1100101102103104Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)AxisXYZHaarWaveletVarianceRepresentation2Figure 2: Plot produced by the function compare.wvar() on objects containing

the standard and robust WV respectively.

• AR1(φ,σ2): a ﬁrst-order autoregressive process;

• WN(ν2): a white noise process;

• QN(Q2): quantization noise process;

• RW(γ2): a random walk process;

• DR(ω): a drift process;

• AR(p): a p-order autoregressive process;

• MA(q): a q-order moving average process;

• ARMA(p, q): an autoregressive-moving average process.

It must be underlined that a ﬁrst-order autoregressive process (AR1()) is

simply a reparametrization of the Guass-Markov process (GM()). Denoting the

frequency as f , the parameterization of the AR1()’s φ is related to the GM()’s β

by

φ = exp (−β∆t)

12

10-910-810-710-610-5100101102103104105106Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)ClassicalRobustHaarWaveletVarianceRepresentation4where ∆t = 1

f . Similarly, the σ2 term of the AR1() is related to the GM()’s σ2

GM

by

σ2 = σ2

GM (1 − exp (−2β∆t)) .

With this in mind, if the frequency f of the data is equivalent to 1, then the GM()

process will be equivalent to the AR1(). This is the default frequency assumed

by the software unless otherwise speciﬁed during the estimation procedure.

The latent processes underlying the error signal, whose parameters need to

be estimated, can be speciﬁed by simply adding the diﬀerent processes men-

tioned above via the “+” operator. However, there are some limits to how

many times a process can be included in a model. In particular, only the GM()

or AR1() models can be included more than once (say k times) by specifying,

for example, k*GM() while the other processes can only be included once within

the same model. With these conditions in mind, once the model is speciﬁed

the software will perform a grid search to obtain appropriate starting values

for the optimization procedure in (3) (see Appendix C for details). However,

one can also supply starting values for the GMWM optimization by writing the

exact values within the bracket (e.g. “AR1(phi=0.9,sigma2=0.1)+WN(sigma2

= 1)”).

To provide an example of model estimation using the above features, let

us consider the navchip data and take the second column (Y-axis gyroscope).

In order to describe the latter we consider a reasonably complex model made

by the sum of three Gauss-Markov processes in addition to a white noise, a

quantization noise and random walk process which we estimate as follows:

> gyro.y = gmwm.imu(3*GM()+WN()+QN()+RW(), navchip[,2])

As for the wvar() function, also in this case it is possible to opt for a robust

model estimation by simply adding the “robust = TRUE” parameter. The esti-

mates for both of the models are presented in Table 1 alongside their standard

deviation. For the most part, the estimates between the classical and robust

GMWM seem to agree since there does not appear to be a signiﬁcant diﬀerence

13

between them. The only exception is represented by the third Gauss-Markov

process where β3 and σ2

GM,3 diﬀer between the two estimations. These diﬀer-
ences can be also noticed in Figure 2 where the standard and robust WV appear

to slightly diﬀer (keeping in mind the logarithmic scale). It therefore appears

that a robust analysis might be more appropriate.

Estimates

2.50 · 10
7.08 · 10
6.28 · 10
1.28 · 10
8.48 · 100
6.48 · 10
6.94 · 10
2.29 · 10
3.90 · 10

Classical
−1 (1.30 · 10
−9 (5.92 · 10
−3 (1.83 · 10
−8 (1.10 · 10

−13)
−13)
−13)
−13)
(1.52 · 10−14)
−11)
−9 )
−9 )
−14)

−9 (1.44 · 10
−7 (2.01 · 10
−6 (8.79 · 10
−14 (4.50 · 10

Robust (eﬀ = 0.6)
−1 (1.93 · 10
−9 (6.58 · 10
−3 (2.74 · 10
−8 (1.19 · 10

−13)
−13)
−13)
−13)
(3.32 · 10−14)
−11)
−9 )
−8 )
−14)

−8 (2.73 · 10
−7 (2.52 · 10
−6 (1.24 · 10
−14 (5.10 · 10

3.11 · 10
6.57 · 10
7.26 · 10
1.12 · 10
1.25 · 101
1.33 · 10
5.30 · 10
2.74 · 10
5.44 · 10

β1

σ2

GM,1

β2

σ2

GM,2

β3

σ2

GM,3

σ2

Q2

γ2

Table 1: Standard vs robust parameter estimates for the NavChip Y-axis gy-

roscope. The robust estimator is based on an eﬃciency of 0.6 compared to the

standard estimator.

Once the model is estimated, the software provides the ability to graphically

validate it.

Indeed, a ﬁrst way to understand if the model ﬁts the observed

error signal well is to compare the relative observed WV and the WV implied

by the estimated model as shown in Figure 3a. This plot can be produced

simply by applying the plot() function to the object containing the estimated

model. Additionally, one can seek to improve the ﬁt by graphically observ-

ing individual processes which contribute to the model by using the parameter

“process.decomp = TRUE”, which gives Figure 3b.

Aside from this graphical validation tool, the software provides rigorous sta-

tistical measures to assess the signiﬁcance of the estimated parameters and of the

model as a whole. Supposing that the model has been saved in an object called

14

(a) Comparison of observed WV (blue line)

(b) WV comparison with underlying process

and model-implied WV (orange line)

breakdown

Figure 3: WV implied by the estimated 3*AR1()+WN()+QN()+RW() model com-

pared to the empirical WV of the NavChip Y-axis gyroscope.

“gyro.y”, it is possible to obtain parameter conﬁdence intervals (CIs) and a

goodness-of-ﬁt test (see equation (4)) by using the function “summary(gyro.y,

inference = TRUE)”. The CIs provide a measure of how accurate the parame-

ters estimations are thereby giving information as to whether or not parameters

associated with a speciﬁc underlying process are signiﬁcantly diﬀerent from zero

(e.g. H0 : θ = 0). Thus, this gives a reasonable indication of whether a process

should be kept in the model or not. However, with this being said, it is known in

the statistics literature that conﬁdence intervals are conditional on the presence

of other parameters in the model. As a result, the main conclusion of whether a

model is accurate should be obtained from the goodness-of-ﬁt test as it assesses

how well the overall model explains the signal.

The tools provided by the new platform and described in this section are

extremely important to understand which models can be considered as good

candidates to best describe the observed signal. Therefore, the following step

that is needed is to select the “best” model(s) for which the related tools are

described in the next section.

15

10-910-810-710-610-510-210-1100101102103104Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)EmpiricalWVˆ⌫CI(ˆ⌫,0.95)ImpliedWVˆ⌫HaarWaveletVarianceClassicalRepresentation110-910-810-710-610-510-210-1100101102103104Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)EmpiricalWVˆ⌫CI(ˆ⌫,0.95)AR1AR1AR1WNQNRWImpliedWVˆ⌫HaarWaveletVarianceClassicalRepresentation23.3. Selecting the Model

The main goal of model selection is to identify the most appropriate model,

among those that have been estimated, to describe and predict future stochastic

error measurements. Using the WIC, the two main options available to rank

the models according to this criterion are the following:

1. Manual: the function rank.models() allows to enter a set of candidate

models from which the user would like to select the best.

2. Automatic: the function auto.imu() allows to deﬁne an overall general
model, say MK, in which all K candidate models are nested (e.g. Mk ⊆
MK, for k = 1, . . . , K). An example of this approach applied to the mtig
data is given in Figure 4 where the implied WV of the selected models is

compared to the observed WV for each accelerometer and gyroscope.

Considering these two options, for both of them the platform also allows to

choose the approach to estimate term B in (5) as mentioned in Section 2. The

ﬁrst option is given by the parametric bootstrap where B simulations are per-
to obtain estimates of ˆν(h) and ν( ˆθ)(h)
formed on the kth candidate model F ˆθk
that are then used to estimate this “optimism” term. This option has been

k

shown to possess good properties in various simulation studies and can be used

by specifying the parameter “bootstrap = TRUE”. However, the latter is very

demanding from a computational standpoint while the asymptotic option, due

to its closed analytical form, is less computationally intensive and has some op-

timal theoretical properties as shown in [16]. Indeed, in terms of computational

time, the asymptotic option is roughly K times faster than the bootstrap option

while at the same time being asymptotically loss eﬃcient with a null probability

of underﬁtting.

In conclusion, given the features presented in this section and the previous

ones, the challenge for the correct model estimation for inertial sensor stochastic

errors can more easily be met through this new platform. The latter not only

easily estimates the complex error models which usually characterize IMUs but

also delivers additional tools to allow researchers better understand these error

16

Figure 4: Results of running auto.imu() on the “mtig” data. Dashed line is

the implied WV while the solid line is the empirical WV.

models and to support their decisions for sensor calibration purposes. As a

support to the reader and potential user, an example of the code used to generate

the results in the previous sections can be found in Appendix D.

4. Upcoming features

The platform responds to the current needs for inertial sensor calibration

while adding useful features which were not available before. However, the

idea of modelling latent processes which is behind the GMWM allows it to

be particularly suitable for extensions to more complicated settings. Diﬀerent

developments are indeed underway, or close to completion, concerning issues

which are extremely relevant for inertial sensor calibration. The following sec-

tions brieﬂy describe these extensions which will soon be implemented within

the new software platform.

4.1. Multivariate GMWM

Currently sensor calibration is carried out separately for each accelerometer

and gyroscope that build an IMU. This procedure is valid if one supposes that

17

XYZ10-710-610-510-410-310-210-910-810-710-610-5AccelerometerGyroscope10-110010110210310-110010110210310-1100101102103Scale⌧(s)WaveletVarianceˆ⌫(rad2/s2)AutomaticModelSelectionResults5the error signals of each of these components are independent from each other

which may not always be a realistic assumption to make. Using the latent

process structure, the idea is to explain the possible dependence of gyroscopes

and accelerometers through a common model which is shared among them. To

provide an example, we could suppose that the error signals of the triad of
gyroscopes (Y (x)

) can be expressed as follows:

, Y (y)

, Y (z)

t

t

t

Y (x)
t
Y (y)
t
Y (z)
t

= Vt + W (x)

t

= Vt + W (y)

t

= Vt + W (z)

t

where Vt is the process which is shared between the gyroscopes and W (i)
the speciﬁc process that characterizes the error signal of the ith-axis gyroscope.

is

t

The idea of expressing the model in this manner deﬁnes a new method for

the modelling of multivariate time series that is inspired by dynamic factor

analysis. In this manner, we don’t only explain the dependence between the

sensor components but we also reduce the number of parameters to estimate

and obtain better ﬁts. This feature will be added to the proposed platform once

the theoretical properties of the method are conﬁrmed.

4.2. Calibration under dynamics

The correlation of IMU errors with system dynamics is a topic of great

importance that may increase with the spreading use of low-cost inertial sensors.

Recent studies conﬁrmed that system dynamics may have an important inﬂuence

on the characteristics of the error signal issued from inertial sensors (see [25]).

The possibility of adapting noise models according to the dynamics that the

system is subject to should therefore be considered in the navigation ﬁlters to

enhance the performance of stochastic modeling. The proposed methodology

is based on a non-stationary adaptation of the GMWM framework. Let us

consider the following example of a non-stationary AR1 process:

Yt = ρtYt−1 + t,

t

iid∼ (0, σ2
 )

18

where ρt is the autoregressive parameter that now depends on the time t through
a function m(·) : R (cid:55)→ (−1, 1). Indeed, we deﬁne ρt = m(Zt−1β) where Zt−1
denotes a vector of dynamics and β is the parameter that explains the impact of

these dynamics on the parameters of the error signal model. This approach can

be extended to other parameters of typical error models considered for inertial

sensor calibration. The properties of the WV estimator ˆν and the implied

WV ν(θ) considering such circumstances are being developed and will be later

included in the proposed platform.

4.3. Additional features

Other features are envisaged for the future updates of the package that are

based on recently developed methods and improvements on existing results.

For example, it has been shown in [26] that adding further process moments to

the WV vector, such as the the mean or autocovariances, greatly improve the

eﬃciency of the GMWM estimator. This estimator is called the Augmented

GMWM (GMWM+) and will be implemented as an additional option in the

gmwm.imu() function with the possibility to specify the requirement on addi-

tional moments of the WV vector. Furthermore, a test will be implemented to

determine whether two error signals are generated from the same model or not.

Finally, additional features are planned such as the possibility to employ other

kinds of wavelet ﬁlters and use the robust WV as a basis for fault detection and

isolation.

5. Conclusion

This paper presented the main features and function descriptions of the

new software platform for inertial sensor calibration based on the GMWM.

This software is contained in an open-source R package called “gmwm” which

provides all the tools for the modelling of the complex stochastic error signals

that characterize IMUs, although this does not exclude the possibility of using it

to estimate complex stochastic error models from other engineering applications.

19

As a statistically sound alternative to the AVLR and as a computationally

eﬃcient and numerically stable alternative to the ML, the new platform based

on C++ language allows to visualize data using the WV as the main summary

statistic in order to identify the possible models which can then be quickly and

consistently estimated. With graphical tools to assess how well the models ﬁt the

observed signals, the package also provides functions to (automatically) select

the best model(s) based on their estimated prediction error. Once the model

has been identiﬁed and the relative parameters have been estimated through

the software, these can be inserted into a navigation ﬁlter (usually an extended

Kalman ﬁlter) to improve the navigation accuracy of the sensors.

References

[1] N. El-Sheimy, X. Niu, The Promise of MEMS to the Navigation Commu-

nity, Inside GNSS 2 (2) (2007) 46–56.

[2] O. J. Woodman, An Introduction to Inertial Navigation, University of Cam-

bridge, Computer Laboratory, Tech. Rep. UCAMCL-TR-696 14 (2007) 15.

[3] Y. Stebler, S. Guerrier, J. Skaloud, M.-P. Victoria-Feser, Constrained

Expectation-Maximization Algorithm for Stochastic Inertial Error Mod-

eling: Study of Feasibility, Measurement Science and Technology 22 (8)

(2011) 1–12.

[4] Y. Zaho, M. Horemuz, L. E. Sj¨oberg, Stochastic Modelling and Analysis of

IMU Sensor Errors, Archives of Photogrammetry, Cartography and Remote

Sensing 22 (2011) 437–449.

[5] J. Nikolic, P. Furgale, A. Melzer, R. Siegwart, Maximum Likelihood Identi-

ﬁcation of Inertial Sensor Noise Model Parameters, Sensors Journal, IEEE

16 (1) (2016) 163–176.

[6] N. El-Sheimy, H. Hou, X. Niu, Analysis and Modeling of Inertial Sensors

using Allan Variance, IEEE Transactions on Instrumentation and Measure-

ment 57 (1) (2008) 140–149.

20

[7] Guerrier, S. and Molinari, R. and Stebler, Y., Theoretical Limitations of

Allan Variance-based Regression for Time Series Model Estimation, IEEE

Signal Processing Letters (to appear) (2016) 1–10.

[8] R. J. Vaccaro, A. S. Zaki, Statistical Modeling of Rate Gyros, IEEE Trans-

actions on Instrumentation and Measurement 61 (3) (2012) 673–684.

[9] S. Guerrier, J. Skaloud, Y. Stebler, M.-P. Victoria-Feser, Wavelet Vari-

ance based Estimation for Composite Stochastic Processes, Journal of the

American Statistical Association 108 (503) (2013) 1021–1030.

[10] S. Guerrier, R. Molinari, J. Skaloud, Automatic Identiﬁcation and Calibra-

tion of Stochastic Parameters in Inertial Sensors, Navigation 62 (4) (2015)

265–272.

[11] S. Guerrier, R. Molinari, Robust Inference for Time Series Models: a

Wavelet-based Framework, Submitted Manuscript (2015) 1–62.

[12] D. B. Percival, A. T. Walden, Wavelet Methods for Time Series Analysis,

Cambridge University Press, 2000.

[13] D. B. Percival, On Estimation of the Wavelet Variance, Biometrika 82

(1995) 619–631.

[14] L. P. Hansen, Large Sample Properties of Generalized Method of Moments

Estimators, Econometrica: Journal of the Econometric Society (1982)

1029–1054.

[15] B. Efron, The Estimation of Prediction Error, Journal of the American

Statistical Association 99 (467) (2004) 619–632.

[16] Zhang, X. and Guerrier, S., Covariance Penalty Based Model Selection

Criterion for Indirect Estimators, Submitted Working Paper (2015) 1–30.

[17] R. C. Team, R: A Language and Environment for Statistical Computing,

R Foundation for Statistical Computing, Vienna, Austria, URL http://

www.R-project.org, 2014.

21

[18] D. Eddelbuettel, R. Fran¸cois, J. Allaire, J. Chambers, D. Bates, K. Ushey,

Rcpp: Seamless R and C++ integration, Journal of Statistical Software

40 (8) (2011) 1–18.

[19] D. Eddelbuettel, C. Sanderson, RcppArmadillo: Accelerating R with High-

Performance C++ Linear Algebra, Computational Statistics & Data Anal-

ysis 71 (2014) 1054–1063.

[20] C. Sanderson, Armadillo: An Open Source C++ Linear Algebra Library

for Fast Prototyping and Computationally Intensive Experiments, 2010.

[21] Y. Stebler, S. Guerrier, J. Skaloud, M.-P. Victoria-Feser, Generalized

Method of Wavelet Moments (GMWM) Modelling Software, EPFL, CH-

1015 Lausanne, Switzerland, 1.1 edn., 2012.

[22] W. Riley, Handbook of Frequency, NIST, 2008.

[23] S. Guerrier, R. Molinari, J. Skaloud, M.-P. Victoria-Feser, An Algorithm

for Automatic Inertial Sensors Calibration, in: ION GNSS, 2013.

[24] D. Mondal, D. B. Percival, M-Estimation of Wavelet Variance, Annals of

the Institute of Statistical Mathematics 64 (1) (2012) 27–53.

[25] Y. Stebler, S. Guerrier, J. Skaloud, R. Molinari, M. P. Victoria-Feser,

Study of MEMS-based Inertial Sensors Operating in Dynamic Conditions,

in: Position, Location and Navigation Symposium - PLANS 2014, 2014

IEEE/ION, 1227–1231, 2014.

[26] S. Guerrier, R. Molinari, Y. Stebler, Wavelet-based Improvements for In-

ertial Sensor Error Modelling, Submitted working paper .

[27] W. Kusnierczyk, rbenchmark: Benchmarking Routine for R, R package

version 1.0.0, 2012.

[28] Y. Stebler, S. Guerrier, J. Skaloud, M. P. Victoria-Feser, Generalized

Method of Wavelet Moments for Inertial Navigation Filter Design, IEEE

Transactions on Aerospace and Electronic Systems 50 (3) (2014) 2269–2283.

22

Appendix A. Benchmarks

One of the driving design principles behind the proposed platform is its

computational eﬃciency. To achieve this goal, the computational backend is

written completely in C++ using the Armadillo matrix library [see 20]. The

implementation of each function is highly eﬃcient due to manner in which they

are implemented. Speciﬁcally, multiple functions for the same task were created

within C++ and then benchmarked. The benchmarking was conducted using

the “rbenchmark” package [27] with each function being called 100 times. The

function that used the least amount of time among the C++ implementations

was then included within the package. This bottom-up approach used to create

the package not only delivers a very eﬃcient implementation of the GMWM

estimator but also of diﬀerent wavelet-based methods and random process gen-

eration. To illustrate, we provide details on the overall computational time

across a wide range of sample sizes to estimate a 3*GM() model under both the

standard and robust settings in two diﬀerent modes: user-supplied and guessed

parameters. The user-supplied parameters were taken to be the exact param-

eters whereas the guessed parameters relied on the initial starting algorithm

described in Appendix C. The latter algorithm was based on a range of initial

guesses going from 100 to 1,000,000. The time reported in both tables is by the

number of seconds required to estimate the model.

Type

100

1,000

10,000

100,000

1,000,000

Exact Values

0.0100

0.0188

0.0300

0.1408

1.5473

Guessed 1,000

0.0342

0.0369

0.0594

0.1714

1.5965

Guessed 10,000

0.0755

0.0794

0.1250

0.2511

1.6647

Guessed 20,000

0.1216

0.1386

0.2005

0.3411

1.7917

Table A.2: Standard estimation of a 3*GM() model using “gmwm.imu()” in

seconds

23

Type

1,000

10,000

100,000

1,000,000

Exact Values

0.0327

0.0816

0.6839

11.4097

Guessed 1,000

0.0546

0.1081

0.6875

11.4575

Guessed 10,000

0.1135

0.1791

0.7687

11.5385

Guessed 20,000

0.1666

0.2516

0.8556

11.5957

Table A.3: Robust estimation of a 3*GM() model using “gmwm.imu()” in seconds

Appendix B. How to Import IMU Data

The ﬁrst step towards the modelling of the inertial sensor stochastic error is

loading the data onto the platform. This is done by:

1. Loading data in .txt or .csv format;

2. Reading in IMU binary ﬁles.

In the ﬁrst case, the user must also cast the data as an “imu” object whereas

this is automatically done when loading the data in the second case. Below is

an example that displays each of these cases.

# Case 1a: Reads in data that is separated by tab

ds = read.table("path/to/file.txt")

# Case 1b: Reads in data that is separated by comma

ds = read.csv("path/to/file.csv")

# Case 2: Cast data loaded into R to IMU object-type for use in the gmwm

# routines

sensors = imu(ds, accelerometer = 1:3, gyroscope = 1:3, freq = 100)

# Case 3: Read an imu binary file and cast object as an IMU-type

sensors = read.imu("~/path/to/file.imu", "IMU_TYPE")

The binary ﬁle reader currently supports the binary record format used

by well known commercial software such as Applanix (PosProc) and Nova-

tel/Waypoint (IExplorer). This format is aptly described as a seven column

layout where the ﬁrst column of the data contains time data, columns 2-4 con-

tain gyroscope values and columns 5-7 contain accelerometer values for axes X,

24

Y, and Z. Upon loading, appropriate scaling factors are applied to the data.

As a result, the following types of IMU can be loaded via their binary: IMAR,

LN200, LN200IG, IXSEA, NAVCHIP INT and NAVCHIP FLT. For more de-

tails, please see the read.imu() help documentation.

Appendix C. Optimization Starting Values Algorithm

To start any optimization procedure starting values are needed and this is the

case also for the GMWM procedure with the optimization in (3). The platform

uses an algorithm to ﬁnd appropriate starting values and this is described in

three parts below: a general overview of the algorithm (Algorithm 1), a heuristic

approach to determining the dominating process (Algorithm 2), and a focus on

a speciﬁc step based on the required processes to be estimated (Algorithm 3).

25

Inputs : An empty parameter vector θ that deﬁnes the model, the

wavelet variance for the ﬁrst two scales, and the slope of the

(cid:16) min(x)−max(x)

(cid:17)

data

length (x)

.

Output: Starting values to estimate the parameter vector θ

Step 1: Compute the total variance ˆσ2

T = var ˆν for all scales obtained

with Equation 1.

Step 2: Determine the process that dominates the initial scales using

Algorithm 2.

Step 3a: Randomly sample G times from the parameter spaces

depending on the type of process. At the start of each new round of

guessing for all parameters, use the domination result from Step 2 to

select the starting condition of the “GM” / “AR1” process:

if QN dominates then

Draw R ∼ U [0, 1]
if R ≤ 0.75 then

Start AR1 or GM on condition 2 in Algorithm 3

else if WN dominates then

Start AR1 or GM on condition 2 in Algorithm 3

Step 3b: See Algorithm 3 for details on parameter selection for each

process.

Step 4: Select the starting parameter vector ˆθ(0) with the smallest

objective function value given by the ﬂattening algorithm described in

[28]:

(cid:18)

1 − ν (θ)
ˆν

(cid:19)T(cid:18)

1 − ν (θ)
ˆν

(cid:19)

ˆθ(0) = arg min

θ∈Θ

(C.1)

Algorithm 1: Starting Values Algorithm

26

Inputs : Process’ wavelet variance, and the slope of the data

(cid:16) min(x)−max(x)

(cid:17)

length (x)

.

Output: Process that dominates the initial scales.

Step 2a: Compute the slope, s, between the ﬁrst wavelet variance, ˆν1,

and the upper and lower conﬁdence bounds of the second,

(cid:104)
ˆη = max(cid:0)(N − Lj + 1) /2j, 1(cid:1)

ˆη ˆν2
ˆη(0.975) ,
χ2

(cid:105)

χ2

ˆη(0.025)

a =

ˆη ˆν2

, using s = log(a)−log(ˆν1)

log(4)

, where

Step 2b: Determine whether QN, WN, or AR1/GM dominates the

initial scales based on a slope heuristic:
if max (s) < −.5 then

QN Dominates

else if min (s) > −.5 then

AR1/GM Dominates

else

WN Dominates

Algorithm 2: Process Domination Algorithm

27

Inputs : An empty parameter vector θ that deﬁnes the model, the

process’ wavelet variance, and the slope of the data.

Output: A parametric model Fθ

Step 3b: Select the appropriate realization generator based on process

type

if AR1 or GM then

if AR/GM on condition 1 then

Draw U ∼ U (0, 1/3) for φ = 1−√
Draw σ2 ∼ U

T (1−φ)2

2

else if AR/GM on condition 2 then

Draw φi ∼ U (max (0.9, φi−1) , 0.999995)
Draw σ2 ∼ U

T (1−φ2
ˆσ2
i )

0,

1−3U
5

T (1 − φ)2(cid:17)
,(cid:98)σ2
(cid:19)
T (1 − φ)2(cid:17)
,(cid:98)σ2

(cid:16)(cid:98)σ2
(cid:18)

(cid:16)(cid:98)σ2

else

100

Draw U ∼ U (0, 1/3) for φi = (.999995 − φi−1)(cid:0)√

1 − 3U(cid:1) + φi−1

Draw σ2 ∼ U

T (1−φ)2

2

Increase the condition by 1.

Calculate the slope of the data: R = max(x)−min(x)

length(x)

else if DR then

else if RW then
Draw γ2 ∼ U

T

2

(cid:1)

100 , R

Draw ω ∼ U(cid:0) R
(cid:16) ˆσ2
(cid:16) ˆσ2
(cid:16) ˆσ2

if WN Dominates then
2 , ˆσ2

Draw σ2 ∼ U

105·N , ˆσ2

Draw σ2 ∼ U

else

T
N

T

T

(cid:17)
(cid:17)
(cid:17)

T

105 , ˆσ2

T
10

else if WN then

else

(cid:16) ˆσ2
(cid:16) ˆσ2

T

if QN Dominates then
8 , ˆσ2

Draw Q2 ∼ U

T
3

else

Draw Q2 ∼ U

2·105 , ˆσ2

T
100

T

(cid:17)

(cid:17)

28

Algorithm 3: Process-speciﬁc Starting Values Algorithm

Appendix D. Code Used in Paper

The following code was used to generate some of the results and ﬁgures

included in the paper and provides insight to the use of the “gmwm” platform.

Please note that the following code was executed under version 3.0.0 of both

the “gmwm” and “imudata” R package.

# 0. Preparing the workspace Load R Package

library("gmwm")

# Load in MTIG data, if not present, then install the data package.
if (!require("imudata")) {

install_imudata()

library("imudata")

}

# Read in Binary IMU Data

navchip = read.imu("~/IMU_data/navchip_4h.imu", "NAVCHIP_FLT")

# 1. WAV-AR All Navchip Obtain the wavelet variance of all sensors in imu

# object.

wv.navchip = wvar(navchip)

# Plot the Wavelet Variance of each sensor

plot(wv.navchip)

# 2. Generate models for each sensor

navchip.gx = gmwm.imu(2 * GM() + WN() + DR() + QN() + RW(), navchip[, 1])

navchip.gy = gmwm.imu(3 * GM() + WN() + QN() + RW(), navchip[, 2])

navchip.gz = gmwm.imu(2 * GM() + WN() + DR() + QN() + RW(), navchip[, 3])

navchip.ax = gmwm.imu(4 * GM() + QN() + RW(), navchip[, 4])

navchip.ay = gmwm.imu(4 * GM() + QN() + RW(), navchip[, 5])

navchip.az = gmwm.imu(3 * GM() + QN(), navchip[, 6])

# Robust model generation

navchip.gy.r = gmwm.imu(3 * GM() + WN() + QN() + RW(), navchip[, 2], robust = T)

# Summary statistics

sm.navchip.gy = summary(navchip.gy, inference = T)

29

sm.navchip.gy.r = summary(navchip.gy.r, inference = T)

# 3. Compare Classical with Robust WV

compare.wvar(navchip.gy, navchip.gy.r)

# 4. Load and cast data for MTiG

data("imu6")

# Cast as an IMU

sensors = imu(imu6, gyros = 1:3, accels = 4:6, freq = 100)

# 5. Obtain WV and plot WV

wv.sensors = wvar(sensors)

plot(wv.sensors)

# 6. Automatic Model Selection with Overall Model Guess

models.sensors = auto.imu(sensors, model = 4 * AR1() + WN() + RW())

# 7. Visually see the best models

plot(models.sensors)

30

