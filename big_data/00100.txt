6
1
0
2

 
r
a

M
1

 

 
 
]

R
C
.
s
c
[
 
 

1
v
0
0
1
0
0

.

3
0
6
1
:
v
i
X
r
a

Crashing Modulus Attack on Modular Squaring

for Rabin Cryptosystem

Masahiro Kaminaga, Hideki Yoshikawa,Arimitsu Shikoda,and Toshinori Suzuki∗†

March 2, 2016

Abstract

The Rabin cryptosystem has been proposed protect the unique ID
(UID) in radio-frequency identiﬁcation tags. The Rabin cryptosystem is
a type of lightweight public key system that is theoretetically quite secure;
however it is vulnerable to several side-channel attacks. In this paper, a
crashing modulus attack is presented as a new fault attack on modular
squaring during Rabin encryption. This attack requires only one fault in
the public key if its perturbed public key can be factored. Our simulation
results indicate that the attack is more than 50% successful with several
faults in practical time. A complicated situation arises when reconstrucing
the message, including the UID, from ciphertext, i.e., the message and the
perturbed public key are not relatively prime. We present a complete and
mathematically rigorous message reconstruction algorithm for such a case.
Moreover, we propose an exact formula to obtain a number of candidate
messages. We show that the number is not generally equal to a power of
two.

1 Introduction

It is quite important that the modular squaring map f (x) = x2 mod N from
Z∗
N = (Z/N Z)∗, is the reduced residue system
N = (Z/N Z)∗ to itself, where Z∗
mod N . The algorithmic complexity of the modular quadratic equation x2 ≡ C
(mod N ) for quadratic residue C mod N is equivalent to factoring N . Thus, f
has one-wayness if factoring N is suﬃciently diﬃcult.

There are various applications of the modular squaring map with N = pq for
large distinct primes p and q. For example, Blum et al. [1] constructed a unpre-
dictable pseudorandom sequence to take the parity of xi for xi = f (xi−1) mod N
with a secret initial value x0 ∈ Z∗
N . This is known as the Blum-Blum-Shub

∗M. Kaminaga, H. Yoshikawa, and T. Suzuki are with the Department of Electrical En-
gineering and Information Technology, and A. Shikoda is with the Department of Electri-
cal Engineering, Tohoku Gakuin University, 13-1, Chuo-1, Tagajo, 985-8537, Japan e-mail:
(kaminaga@mail.tohoku-gakuin.ac.jp).

†Manuscript received xxxx xx, xxxx; revised xxxx xx, xxxx.

1

pseudorandom number generator, and it is theoretically quite important. An-
other important example is the Rabin cryptosystem developed by Michael C.
Rabin [2]. The Rabin cryptosystem is a public key cryptosystem with public
key N and secret keys p and q.
In this system, message M is encrypted as
C = M 2 mod N and decrypted as four possible roots of C using √C mod p
and √C mod q and the Chinese remainder theorem (CRT) (see Section 2.2).
The security of the Rabin cryptosystem, similar to that of RSA, is related
to the practical diﬃculty of factoring N = pq. The Rabin cryptosystem has a
theoretical advantage in that there exists an exact proof of its security equiv-
alent to factoring N , which is not currently known to be true for RSA. Being
theoretically important, the Rabin cryptosystem is also useful for passive ra-
dio frequency identiﬁcation (RFID). The use of passive RFID tags to prevent
counterfeiting by embedding them in a product is an emerging application.
RFID systems comprises tags and interrogators. RFID tags are low-cost wire-
less devices that associate a unique ID (UID) with the product. These tags are
powered passively by the interrogator. Implementation of a public key cryp-
tosystem on RFID tags is challenging, because the hardware limited. Therefore,
“lightweight” cryptosystems are required for RFID tags. RSA is a well-known
and eﬀective public key cryptosystem; however, it is not suitable for RFID tags.
RSA encryption requires many modular multiplications, relatively long process-
ing time, and a relatively large data-path area. In addition, RSA consumes a
signiﬁcant amount of energy. There are two major lightweight public key cryp-
tosystems suitable for RFID tags, i.e., the elliptic curve cryptosystem (ECC)
and the Rabin cryptosystem.

ECC can be applied to small devices and has shorter processing time than
RSA. Moreover, ECC is suitable for various RFID applications. Many academic
papers on ECC for RFID tags have been published. For example, F¨urbass-
Wolkerstorfer [3], Lee-Sakiyama-Batina-Verbauwhede [4], Hutter-Feldhofer-Plos [5],
Hutter-Feldhofer-Wolkerstorfer [6], Hutter-Joye-Sierra [7], Pessl-Hutter [8], and
Kern-Feldhofer [9] have reported remarkable results on ECC implementation for
RFID tag chip.

The Rabin cryptosystem requires only one modular squaring, which is ad-
vantageous for use with RFID tags.
Indeed, Oren-Feldhofer [10], [11], Arbit
et al. [12] successfully applied Rabin encryption variant to RFID tags. The
variant, known as WIPR (Weizmann-IAIK[Institute for Applied Information
Processing and Communications] Public Key for RFID) was developed by Nac-
cache [13] and Shamir [14], [15]. WIPR is smaller, faster, and requires less
power than ECC implementations. Giesecke & Devrient GmbH [16] proposed
proposed the Rabin-Montgomery Cryptosystem (RAMON), a public key proto-
col for RFID tags based on the Rabin cryptosystem. RAMON uses Montgomery
reduction [17] to avoid trial division. Therefore, it is very likely that the Rabin
cryptosystem will be implemented on various types of RFID tag chips.

Since the publication of Boneh, DeMillo, and Lipton’s landmark paper [18],
diﬀerential fault analysis(DFA) has been an active area in cryptography. DFA
is a technique to extract secret information from a cryptographic device by
provoking a computational fault. DFA is a real threat for cryptographic devices,

2

such as smartcard [19]; therefore, a vast number of research papers about DFA
have been published. The monograph edited by Joye-Tunstall [20] is a good
guide to this ﬁeld.

1 pe2

However, conventional fault attack research for public key cryptosystems has
focused on DFA for smartcards, particularly signature schemes using RSA and
ECC. Little attention has been paid to Rabin cryptosystem implemented on an
RFID tag chip. We propose a powerful fault attack by one-byte perturbation of
public key N based on the assumption that an attacker can induce faults as the
device moves one byte of N from non-volatile memory to a register. Under this
assumption, the attacker can create a new faulted public key ˆN = pe1
2 ··· peω
ω ,
where pj are mutually distinct primes and ej are positive integers.
We provide a mathematical analysis and demonstrate the eﬀectiveness of the
proposed fault attack through simulation. Although there have been some re-
lated studies [21], [22], they are not directly applicable to our target. An attack
against RSA, ﬁrst developed by Seifert [21] and extended to the general case
by Muir et al. [22], can obtain a new secret exponent e−1 mod ϕ( ˆN ), where e
is a public exponent and ϕ is Euler’s totient function. This approach is not ap-
plicable to Rabin cryptosystems; therefore, a secret message M including UID
must be reconstructed directly. Conversely, it is known that an attacker can
obtain modular quadratic equation M 2 ≡ C (mod ˆN ) by solving each M 2 ≡ C
(mod pej
j ) and computing M using CRT only if gcd(M, ˆN ) = 1 holds. How-
ever, generally, some prime factors of ˆN are small. As a result, cases in which
gcd(M, ˆN ) 6= 1 occur frequently. We also present a complete mathematical
method to reconstruct the message in such cases.

The remainder of this paper is organized as follows. Section II presents
a brief description of quadratic residues, the Rabin cryptosystem, and basic
facts about the target implementation of a Rabin cryptosystem in an RFID tag.
Section III presents the general principle and procedure of our attack, as well as
a complete and mathematically rigorous message reconstruction algorithm. We
show an exact formula to obtain the number of candidate message in Section
IV. Simulated attack results are presented in Section V, and conclusions are
presented in Section VI.

2 Preliminaries

2.1 Quadratic Residues
Let p be an odd prime. An integer C ∈ Z∗
p is called a quadratic residue mod p
if there exists x such that x2 ≡ C (mod p). We denote the set of all quadratic
2 ≡ 1
residues mod p by QRp. We can use Euler’s criterion to claim that C
(mod p) to determine C ∈ QRp or not.
2 ≡ 1 (mod p)
2 ≡ −1 (mod p) holds if C 6∈ QRp. Using Euler’s
holds if C ∈ QRp, or C
criterion, square roots of C mod p can be represented as

In other words, C

p−1

p−1

p−1

√C = ±C

p+1

4 mod p

3

p+1

4

p−1

p+1

2 ≡ C

4 )2 ≡ C

if p ≡ 3 (mod 4). Note that p+1
is a positive integer under the condition
2 C ≡ C (mod p). If p 6≡ 3 (mod 4), i.e., p ≡
and (±C
1 (mod 4), then we require the Tonelli-Shanks algorithm to ﬁnd the square
roots. The Tonelli-Shanks algorithm runs in polynomial time assuming that the
generalized Riemann hypothesis is true. We can ﬁnd the roots mod pe of C as
follows. First, we ﬁnd all square roots mod p. Then using the Hensel lift(see
e.g., section 13.3.2 of Shoup’s book [23]), we lift each of these square roots to
obtain all of the roots p2, and then lift these to obtain all square roots mod
p3, and so on. Quadratic residue can be generalized for the mod of an odd
composite number N = pe1
2 ··· peω
ω . A quadratic residue mod N is an integer
N that satisﬁes β ≡ α2 (mod N ). Using the
β such that there exists an α ∈ Z∗
CRT, it can be demonstrated that β is a quadratic residue mod N if and only
if it is a quadratic residue mod of each pei
i , and one obtain every root mod N
from all roots mod pei

1 pe2

i ’s.

2.2 Rabin Cryptosystem

The Rabin cryptosystem [2] is a public key system based on the factorization
diﬃculty of N = pq where p and q are large and distinct balanced primes. The
length n of N must be greater than or equal to 1,024 to be safe. N is its
public key, and p and q are its secret keys. To reduce decryption complexity,
choose p and q that satisfy p ≡ q ≡ 3 (mod 4) should be chosen. According
to the Dirichlet’s theorem on arithmetic progressions (see e.g., Theorem 5.52 of
Shoup’s book [23]), inﬁnitely many prime numbers p that satisfy p ≡ 3 (mod 4)
N = (Z/N Z)∗ be the reduced residue system mod N . Generally, the
exist. Let Z∗
plaintext M ∈ Z∗
N is generated from a shorter message, including the UID, in
our case. In the Rabin cryptosystem, to encrypt M ∈ Z∗
N , the sender computes
its square mod N :

C = M 2 mod N.

To decrypt the ciphertext C, the receiver computes its square roots √C of C
p+1
4 mod p
q+1
4 mod q using an eﬃcient exponentiation algorithm.

mod N using p and q as follows. First, compute Cp = √C mod p = C
and Cq = √C mod q = C
Second, using the CRT, the four roots are computed as follows:

√C = ±Cpq(q−1 mod p) ± Cqp(p−1 mod q).

Finally, the receiver recognizes the valid plaintext based on its format, such as
redundancy and structure.

The Rabin cryptosystem has two signiﬁcant advantages with respect to al-
ternative public key schemes. First, it is provably diﬃcult to factor N . Second,
it imposes a small computational burden, has relatively lightweight implementa-
tion, and requires only a single squaring and modular reduction for encryption.

lightweight implementation, and requires

4

2.3 WIPR Scheme

The most time consuming process of Rabin encryption is trial division by N
because it is a RAM-intensive process. There are two well-known ways to avoid
trial division. One is using Montgomery reduction [17], and the other is using the
WIPR scheme. When we use Montgomery reduction, we compute A2R−1 mod
N (R = 2n) rather than A2 mod N , where N is n-bits long; therefore, it is simply
a data format problem. Conversely, the WIPR scheme includes an essentially
diﬀerent process. Thus, we describe only the WIPR scheme.

To reduce the trial division process, Naccache [13] and Shamir [14], [15]
proposed a variant by replacing the modular multiplication by adding a large
random multiple of N , where the size of the random number r is at least 80 bits
longer than the size of N :

C′ = M 2 + rN.

Obviously, C′ ≡ C (mod N ), and C′ is fully randomized. The decryption pro-
cess is identical to Rabin’s original process. This randomized variant of Rabin’s
scheme is easier to implement because it has only multiplications without mod-
ular reduction. It is lighter than the original Rabin scheme; however, it requires
a register that is approximately twice as long for the ciphertext.

The WIPR scheme replaces r with the output of a light stream cipher,
which was developed by Oren-Feldhofer [10]. This stream cipher is implemented
by creating a Feistel network. Arbit et al. [12] reported that their successful
implementation had a data-path area of 4,184 gate equivalents, an encryption
time of 180 ms and an average power consumption of 11 µW.

We describe the WIPR challenge-response protocol as follows.

1. Challenge: The interrogator sends the challenge(random bit string) c of

length s to the tag.

2. Response: The RFID tag generates two random bit strings Rtag and r,
where |Rtag| = n− s−|UID|, and |r| = n+ t. The tag generates a message
as follows:

M = BYTE MIX(c||Rtag||UID),

where || denotes concatenation operator, and transmits the following ci-
phertext:

C′ = M 2 + rN,

and BYTE MIX is a simple byte-interleaving operation (see Oren-Feldhofer [11]
for details).

3. Verify: The interrogator decrypts C′ using the secret key (p, q) and ﬁnds

the correct message, including the UID, in four square roots.

Here, s and t are security parameters (originally set to s = t = 80).

Note that using the Rabin function f (x) = x2 mod N to encrypt a message
M that satisﬁes |M| < n requires some kind of random padding. Some padding
schemes with short random padding are vulnerable to attacks based on Copper-
smith’s Theorem for a univariate polynomial [24] and Franklin-Reiter’s related
message attack [25], [26].

5

2.4 RAMON

Another way to avoid trial division is using Montgomery reduction [17]. When
we use Montgomery reduction, we compute ABR−1 mod N (R = 2n) rather
than AB mod N , where N is n-bits long. Montgomery reduction computes S
that satisﬁes the following Diophantine equation:

AB + T N = SR.

Clearly, S ≡ ABR−1 (mod N ).
the following ciphertext:

RAMON was proposed by Giesecke & Devrient GmbH [16]. RFID tag sends

C∗ = M 2R−1 mod N,

where R = 2n.
In 1024 bit N case, the message M is formatted as follows:
M (128 bytes) = challenge(10 bytes) || tag random number(10 bytes) || TLV-
coded signed Tag UID(n bytes) || variable length ﬁlling(x bytes) || checksum(2
bytes) || The last byte must be left free; i.e., set to zero (1 byte).
Note that C∗ 6= C; therefore, the interrogator transforms C∗ into normal
ciphertext as follows:

C = C∗R mod N = (M 2R−1)R mod N.

Then, the interrogator computes four roots of C mod N using the secret key
(p, q) and ﬁnds the correct M based on its format.

3 Proposed Attack

3.1 Principle

In the following, we consider only the WIPR protocol for convenience. The
fundamental idea of our attack method uses perturbed public key ˆN of N . In
this case, the ciphertext changes as follows:

ˆC = M 2 + r ˆN .

(1)

Generally, the attacker cannot factor the coprime N in realistic time. Con-
versely, a perturbation ˆN of N can be factored at high probability.
If the
attacker has factored ˆN successfully, such as ˆN = pe1
ω , then the mod-
ular quadratic equation ˆC = M 2 (mod ˆN ) derived from (1) splits into ω smaller
equations:

2 ··· peω

1 pe2

M 2 ≡ ˆC (mod pej
j ),

j = 1, 2,··· , ω.

(2)

Equation (2) can be solved using the Tonelli-Shanks algorithm and the Hensel
lift. CRT leads us to all roots of (1) from the roots Mjk(k ≥ 2) of (2), i.e., we
obtain:

ω

M0 =

Xj=1

Mjk ˆNj( ˆN −1

j mod pej

j ),

(3)

6

where ˆNj = ˆN /pej
j . The attacker obtains the correct roots M by modifying the
above M0 as (M0 + k ˆN ) mod N for the smallest k such that M0 + k ˆN > N . The
perturbed modular quadratic equation (1) typically has 2ω roots, and these roots
contain the correct message including the UID. The number of roots exceeds 2ω
in some cases depending on the values of gcd( ˆC, pej
j ) for j = 1, 2,··· , ω. We
discuss these problems in Sections 3.5 and 4.

3.2 Fault Models

The WIPR protocol requires two online multiplications to compute C = M 2 +
rN . Optimal implementation of WIPR with 1,024 bit N was shown by Arbit
et al. [12]. This multiplication process is performed on a multiply-accumulate
register by convolution. Assuming a word size of one byte, a single multiply-
accumulate register perform this multiplication in approximately 216 steps. The
public key N moves from non-volatile memory to the register byte by byte.
We assume that the attacker can inject a one-byte fault into this data moving
process. In this paper, we consider two fault models.

3.2.1 Crash a byte of N

The ﬁrst fault model that we choose to perform our attack with is derived from
those used by Berzati et al. [27], [28] to successfully attack standard RSA.

Here let Z[a, b] be a set of integers in the interval [a, b]. We assume that
the attacker can inject a transient fault that public key N modiﬁes by byte,
that is, the injected fault aﬀects only one byte of the public key by modifying
it randomly as follows:

ˆN = N ⊕ ǫ

where ⊕ is bitwise exclusive OR and ǫ = Ri · 28i, Ri ∈ Z[1, 28 − 1] for i 6= 0
which is required to preserve the parity of ˆN . We assume the attacker knows the
position i, but the correct value of the faulty public key ˆN is unknown by the
attacker. The attacker must factor 255 (= 28 − 1) candidates of ˆN . Our attack
also works for a fault that aﬀects several bytes of N . However, the attacker’s
task grows in proportion to the number of candidates ˆN of perturbed N .

This is a natural assumption for both WIPR and RAMON. In the WIPR
case, the attack target is the time at which the i-th byte N [i] of N moves from
non-volatile memory to the register for multiplication before multiplying r and
N . In the RAMON case, the fault is injected while N moves from non-volatile
memory, such as EEPROM, to a register at the trensfer time of the i-th byte
prior to Montgomery squaring M 2R−1 mod N .

3.2.2 Instruction skip

The second fault model is based on the instruction skip technique. Instruction
skip is equivalent to replacing an instruction with a no operation in assembly
language. Several researchers have investigated DFA using an instruction skip,

7

or a bypass operation [29], [30], [31]. Instruction skip does not aﬀect the reg-
isters, internal memory, and calculation process. Successful instruction skip
attacks have been reported for PIC16F877 [29], ATmega 128 [30], and ATmega
168 [31] microcontrollers. Choukri-Tunstall [29] and Park et al. [30] showed that
an entire Advanced Encryption Standard secret key could be reconstructed by
skipping a branch instruction used to check the number of rounds. Kaminaga
et al. [32] showed that it is possible to reconstruct an entire secret exponent
with 63(= 26 − 1) faulted signatures in a short time for a 1536-bit RSA im-
plementation with the 26-ary method using instruction skipping technique in
precomputation phase.

Our attack target is a conditional branch operation for moving the last byte
of N at the counter i = 127. If the conditional branch operation is skipped, the
attacker obtains the faulted public key ˆN as follows:

ˆN =

126

Xi=0

N [i](28)i,

where each N [i] ∈ Z[0, 255]. Clearly, ˆN is one byte shorter than the original N ,
and preserves its parity.

3.3 Target Byte Location

Some Rabin cryptosystems for RFID tags adopt special types of modulus N for
restricted hardware resources. WIPR for RFID proposed by Oren-Feldhofer [11]
uses modulus N with a predeﬁned upper half to reduce ROM cost by half.
RAMON uses modulus N to satisfy the condition N ≡ 1 (mod 2n/2), which
means that approximately one-half of the least signiﬁcant bits of N (except for
the last one) are zeroes to reduce multiplications [16]. Half of the processes in
which modulus data is transferring from EEPROM to a register are reduced in
such cases. Therefore, the attacker must set the location of the target byte to
the lower half bytes of N for implementation of Oren-Feldhofer’s proposal [11],
and the attack must set the location of the byte to upper half bytes of N for
RAMON [16].

3.4 Attack Procedure

The attacker’s goal is to reconstruct the secret message M , including the UID.
The following steps provide an example of our attack process.

Step 1. Create a perturbed public key ˆN by injecting a fault to a byte of the

public key N .

Step 2. Factorize 255 candidates ˆNk(k = 1, 2,··· , 255) of ˆN . When factor-
ing consumes too much amount of time, perturb another byte of N and
attempt this process again.

Step 3. Solve modular quadratic equation x2 ≡ ˆC (mod ˆNk).

8

Step 4. Find the correct message M based on data format in all roots of

x2 ≡ ˆC (mod ˆNk).

Step 2 is the most time concuming process in computation for the attacker.
Most of ˆNk(k = 1, 2,··· , 255) have relatively small factors; thus, these can
be factored in a short time. However, some cases require more time to factor
ˆNk. Then, the attacker shifts the position of the target byte and attempt the
factoring process again. Step 3 is a technical process, and we must consider the
degenerate case, gcd( ˆC, ˆNk) 6= 1. Mathematicians have paid little attention to
the degenerate case; however, such case arises in our attack.

3.5 Reconstruction of Roots

Our attack method comes down to ﬁnding all roots of the following modular
quadratic equation with a square number ˆC:

x2 ≡ ˆC (mod pe),

(4)

where p is an odd prime and e is a positive integer. The oddness of p obeys the
fact that our attack targets a byte of N that is not the lowest byte.

We use assumption (A), i.e., ˆC is squared mod pe, throughout this paper.
j ) is derived from our

Assumption (A) is very natural because ˆC ≡ M 2 (mod pej
target equation ˆC = M 2 + r ˆN .

We denote ˆC mod ˆN by ˆC. The algorithm for ﬁnding the roots of (4) depends
on whether gcd(p, ˆC) = 1. We distinguish the “degenerate” case gcd( ˆC, ˆN ) 6= 1
from the “non-degenerate” case gcd( ˆC, ˆN ) = 1.

3.5.1 Non-degenerate Case
Here, let ˆC ≡ M 2 (mod ˆN ) for some M ∈ Z. For gcd(p, ˆC) = 1, ﬁnding the
roots of (4) is not diﬃcult (see e.g., Section 2.8.2 of Shoup’s book [33]).

Theorem 1. (Theorem 2.25 [33]) If gcd(p, ˆC) = 1, then the modular quadratic
equation (4) is equivalent to x ≡ ±M (mod pe). In particular, (4) has only two
roots.

Proof. Here, we show the proof for Theorem 1. Since gcd(M, p) = 1, there exists
the inverse M −1 mod p. Therefore, (4) is equivalent to (xM −1)2 ≡ 1 (mod pe).
Let γ be xM −1, and we obtain

(γ + 1)(γ − 1) ≡ 0

(mod pe).

Thus, there exists non-negative integers δ1, δ2(δ1 + δ2 = e) such that pδ1|(γ + 1)
or pδ2|(γ− 1). Then, 2 = (γ + 1)− (γ− 1) divides p if both δ1 and δ2 are positive,
which leads to a contradiction because p is an odd prime, therefore, δ1 = 0 or
δ2 = 0.
(cid:3)

9

Theorem 2. For p ≡ 3 (mod 4) and gcd(p, ˆC) = 1, all the roots of (4) are
given by:

(mod pe),

(5)

where ϕ is Euler’s totient function.

p ˆC ≡ ± ˆC

ϕ(pe )+2

4

Proof. It is easy to verify (5) directly. From Theorem 1, the number of roots of
(4) is two. Note that ϕ(pe) + 2 = pe−1(p − 1) + 2 ≡ 2(−1)e−1 + 2 ≡ 0 (mod 4)
follows from p ≡ 3 (mod 4). By using Euler’s totient theorem ˆCϕ(pe) ≡ 1
(mod pe) and squaring ˆC, we obtain:

(mod pe).

(6)

ˆCϕ(pe)/2 ≡ 1
)2 ≡ ˆC

4

ϕ(pe )+2

Using (6), we obtain ( ˆC
means that ˆC
mod pe of C are given by ± ˆC

ϕ(pe)+2

4

ϕ(pe )+2

(mod pe) ≡ ˆC (mod pe). This
is a square root mod pe of ˆC, therefore, all square roots
(cid:3)

ϕ(pe)+2

2

4

.

For p ≡ 1 (mod 4), we ﬁrst solve the following equation:

x2 ≡ ˆC (mod p).

(7)

We require the Tonneli-Shanks algorithm to solve (7). The Tonneli-Shanks

algorithm can be described as follows.

1. Determine s such that p − 1 = 2st where t is odd.
2. Find a non-quadratic residue v mod p.
3. Compute z = ˆC t mod p.
4. Find u such that (vt)u mod p = z.
5. Compute k = 2s
6. Output ˆC (t+1)/2(vt)k/2 mod p as a solution.
It is easy to check if ˆC(t+1)/2(vt)k/2 mod p is a square root mod p of ˆC. In-
deed, using Fermat’s little theorem, we obtain ( ˆC(t+1)/2(vt)k/2)2 ≡ vtu ˆCvp−1−tu ≡
ˆC (mod p).
After solving (7), the roots can be lifted to mod pu(u > 1) using the follow-

− u.

ing.
Theorem 3. (Hensel’s lifting lemma) Let f (x) ∈ Zp[x] and x0 ∈ Zp satisfy
f (x0) ≡ 0 (mod pk) and f ′(x0) 6≡ 0 (mod p). Then, there is unique x ∈ Zp
such that f (x) = 0 (mod pk+m) and x ≡ x0 (mod pk). Furthermore, this x is
unique in mod pk+m, and can be represented explicitly as:

where

x = x0 + tpk

t = −

f (x0)

pk

· (f ′(x0)−1).

The division by pk denotes ordinary integer division, and the inversion f ′(x0)−1
is computed in mod pm.

10

3.5.2 Degenerate Case
Here we consider the degenerate case, i.e., gcd( ˆC, ˆN ) 6= 1.
Theorem 4. All roots of the modular quadratic equation x2 ≡ 0 (mod pe) are
given by x = kp⌈e/2⌉ for k ∈ Z[0, p⌊e/2⌋ − 1]. In particular, the number of its
roots is p⌊e/2⌋.
Proof. It is clear that x = kp⌈e/2⌉ for k ∈ Z[0, p⌊e/2⌋ − 1] satisﬁes x2 ≡ 0
(mod pe). Thus, we only have to show that other forms of the roots do not
exist. Let x = kpt with gcd(k, p) = 1. Since gcd(x2, pe) 6= 1, x is a multiple
number of p, therefore, t ≥ 1. Then x2 = k2p2t ≡ 0 (mod pe) if and only if
2t ≥ e holds.
Theorem 5. All roots of x2 ≡ ˆC (mod pe) for ˆC = apℓ(ℓ < e), which is
squared, and gcd(a, p) = 1 are given by

(cid:3)

x = ypℓ/2 + kpe−ℓ/2,

k ∈ Z[0, pℓ/2 − 1],

where y is a root of y2 ≡ a (mod pe−ℓ). In particular, the number of its roots
is 2pℓ/2.

Proof. Note that ℓ must be even under assumption (A). Let x = ypt such that
gcd(y, p) = 1, and substitute x into the quadratic equation; thus, we obtain:

x2 = y2p2t ≡ apℓ

(mod pe).

Suppose that 2t < ℓ, y2 ≡ apℓ−2t (mod pe−2t) holds, which means that y is a
multiple of p and is contradictory. Conversely, suppose that 2t > ℓ, y2p2t−ℓ ≡ a
(mod pe−ℓ) holds, which means that a is a multiple of p and is contradictory.
Therefore, 2t = ℓ holds, and we obtain:

y2 ≡ a (mod pe−ℓ).

(8)

From Theorem 1, (8) has only two roots in modulo pe−ℓ. Therefore, the root x
of x2 ≡ apℓ (mod pe) can be represented as:

x = ypℓ/2 + bpe−ℓ

(9)

for some b ∈ Z. (9) satisﬁes x2 ≡ apℓ (mod pe). Then, we have x2 − apℓ ≡
(ypℓ/2 + bpe−ℓ)2 − apℓ = 2ybpe−ℓ/2 + b2p2e−2ℓ = bpe−ℓ/2(2y + bpe+ℓ/2) (mod pe).
We learn 2by ≡ 0 (mod pℓ/2). Since p is odd and y is invertible, b is a multiple
of pℓ/2. Then, b = kpℓ/2 for some k ∈ Z. Substituting b = kpℓ/2 into (9), we
reach x = ypℓ/2 + kpe−ℓ/2 for k ∈ Z[0, pℓ/2 − 1]. Since only two y satisfy (8),
the number of x is 2pℓ/2.

(cid:3)

Remark 1. The degenerate case occurs frequently when ˆN has a small prime
factor. Therefore, in many cases, we can easily ﬁnd the desired roots by brute
force without using Hensel’s lifting lemma.

11

eω( ˆN )
ω( ˆN )

1 ··· p
ν( ˆC, pe) = 


2
2pℓ/2
p⌊e/2⌋

if
if
if

gcd( ˆC, pe) = 1
gcd( ˆC, pe) = pℓ(0 < ℓ < e)
gcd( ˆC, pe) = pe.

4 Number of Candidates of Message

We really need for the perturbed public key ˆN is to be easily factorable. After
factoring, the problem breaks down to ﬁnd the roots of the modular quadratic
equation. Complexity of ﬁnding square roots mod ˆN depends on prime factor
decomposition of ˆN . Complicated cases arise when ˆN is not square-free. Here
we denote the function the number of distinct prime factor of ˆN by ω( ˆN ), and
the number of roots of x2 ≡ ˆC (mod ˆN ) by η( ˆC, ˆN ). CRT equality (3) says
that η( ˆC, ˆN ) is a multiplicative function. Combining Theorem 1, 4, and 5, each
η( ˆC, pe) can be represented explicitly as follows.

Theorem 6.

η( ˆC, ˆN ) = η( ˆC, pe1

1 )··· η( ˆC, p

eω( ˆN )
ω( ˆN)

)

for ˆN = pe1

, and where

It is well known that the following asymptotic estimate for Q(x), which is

the number of square-free numbers below x.

Theorem 7. (Theorem 333, Hardy-Write [34], p.355)

Q(x) ∼

6

π2 x + O(√x)

(x → ∞).

This estimate tells us that the probability that a number should be square-
free is approximated as 6
π2 ≈ 0.6079 ··· for large x. Note that ℓ is even because
ˆC is squared, and η( ˆC, p) = 1 if and only if gcd( ˆC, p) = p. Theorem 6 implies
the following upper bound for square-free ˆN :

η( ˆC, ˆN ) ≤ 2ω( ˆN).

(10)

The equality holds in (10) if and only if gcd( ˆC, ˆN ) = 1. Therefore, Theorem 6
and 7 mean that the probability that the inequality (10) holds is greater than
π2 asymptotically. The asymptotic behavior of ω( ˆN ) is described
or equal to 6
by Theorem 8.
Theorem 8. (Erd¨os and Kac[35]) The function (ω(n) − ln ln n)/√ln ln n is

normally distributed in the sense that, for any ﬁxed z, one has:

1
T

♯(cid:26)n ≤ T ;

ω(n) − ln ln n

√ln ln n

≤ z(cid:27) → Z z

−∞

e−ζ2/2
√2π

dζ

as T → ∞, where we denote the cardinality of a set A as ♯A.

12

Theorem 8 tells us the distribution of ω( ˆN ) obeys normal distribution with

mean ln ln ˆN and variance ln ln ˆN . We use the rough estimate ω( ˆN ) ≈ ln ln(21024) =
6.564959 for 1,024-bit ˆN . However, convergence is slow because the term ln ln ˆN
increases very slowly as ˆN becomes large.

Since both WIPR and RAMON uses at east an 80 bit challenge, the probabil-
ity that a candidate correct message M has the same data format accidentally is
less than or equal to 1/280. According to the above mathematical observations,
it is quite rare that plural candidates of M will appear.

5 Time of attack process

5.1 Evaluation method

In the attack procedure discused in Section 3.4, the most time-consuming pro-
cess is the factorization of ˆN at Step 2. When this process takes too much time,
another fault injection is required (Step 1). The other steps are straightforward.
Therefore, in this section, the number of repeated fault injections and the
time for factorization are evaluated by computer simulation. For simplicity, we
explain only the case ‘crash of a byte of N ’. The simulation procedure is as
follows where T3 is the average calculation time in Steps (3) and (4).

Step (0): Generate a 1,024 bit N (128 bytes). Let N = P127

Step (1a): Decide fault position j. j = 1, 2, . . . , 126 in uniform distribution.

i=0 N [i](28)i.

Step (1b):

Decide fault pattern k0. k0 = 1, 2, . . . , 255 in uniform distribu-

tion. As a notation,

ˆNk0[i] = (cid:26) N [i] ⊕ k0,
ˆNk0 [i](28)i. Attackers know j, but do not know k0.

if i = j
otherwise

N [i].

and ˆNk0 = P127

i=0

Step (2):

Let k = 1. Reset timer T , which accumulates the processing
time of Steps (2a) through (4). Reset counter c, which counts successful
factorization.

Step (2a):

Make ˆNk and attempt to factorize it within 1 min. If factoriza-
tion is successful, proceed to Steps 3 and 4 in Section III-D. Let c = c + 1.
If factorization does not ﬁnish, proceed to Step (4).

Step (3):

If k = k0, go to Step (5).

Step (4):

k = k + 1. When k < 256, go back to Step (2a); otherwise, proceed

to Step (6).

Step (5): The attack is successful. Time consumed is T +cT3. The simulation

ends.

Step (6): The attack is in fail. Consuming time is T + cT3. Simulation ends.

13

5.2 Results

Using a desktop PC with a Core i7-2600 CPU at 3.4 GHz with 12 GB RAM, the
simulation runs on Mathematica 9 for Windows 7 Pro 64 bit. A simulated one
attack begins at Step (0). If this attack ends at Step (5), the attack can ﬁnd
the correct message, i.e., the attack is successful. Otherwise, it ends at Step
(6), which means the attack has failed. As a result, 28 cases were successful
among 195 simulated attacks, which is an 14.4% success rate. According to
this result, attack with X fault injections has a success rate of 1 − 0.856X.
The success rate is 54% for X = 5. Figure 1 shows the distribution of time
consumed T per single attack. For successful attacks, the mean T is 115.4 min,
the median is 136.8 min, and the standard deviation is 78.1 min. For failed
attacks, the mean, median, and standard deviation of T are 226.4 min, 226.6
min, and 4 min, respectively. T can be 255 min at most. However, when
factorization ﬁnishes within 1 min, T will be less than 255 min. Moreover, the
attack is complete when the correct message is found; thus, T becomes much
less than 255 min. if the factorized fault pattern k is the true fault pattern, k0.
The distribution of the number of successful factorizations, c is shown in Fig.2.
Here, c is 30.91 on average for failed attack cases. For successful attacks, the
factorization will break at Step (3); therefore, it does not reach the ﬁnal fault
pattern k = 255 with high probability. Thus, the successful factorization rate is
estimated as 30.91/255 ≈ 12.1%. Note that, in this simulation, the time limit
for the factorization process is 1 min at Step (2a), which is just an example.
The time limit for factorization would be optimized by considering total attack
time and/or the cost of fault injections. This issue will be the focus of future
study.

stop at Step(5)
stop at Step(6)

l

s
e
p
m
a
x
e

 
f

o

 
r
e
b
m
u
N

0
2
1

0
0
1

0
8

0
6

0
4

0
2

0

10

30

50

70

90

130

110
150
Time used[min.]

170

190

210

230

250

Figure 1: Distribution of T

14

stop at Step(5)
stop at Step(6)

l

s
e
p
m
a
x
e

 
f

o
 
r
e
b
m
u
N

0
6

0
5

0
4

0
3

0
2

0
1

0

5

10

15

20

25

30

35

40

45

Number of successful factorization

Figure 2: Distribution of c

6 Conclusion

In this paper, we have proposed a powerful fault attack technique against a
Rabin cryptosystem implemented in a passive RFID tag chip. Our attack uses
one byte perturbation ˆN of public key N . One diﬃculty with our attack is
how to reconstruct the message M , including the UID, when gcd(M, ˆN ) 6= 1.
We have provideed a complete algorithm to reconstruct M for such cases. This
attack requires only one fault in the public key if its perturbed public key can
be factored. The most time consuming process of our attack is the factorization
of ˆN . Empirically, the successful factorization rate is estimated as 12.2% of
ˆN , even if factorization is limited within 1 min using a desktop PC. When this
process takes too much time, another fault injection is preferable.

acknowledgements

This work was supported by the Japan Society for the Promotion of Science
KAKENHI Grant Number 25330157.

References

[1] L. Blum, M. Blum, and M. Shub, “A Simple Unpredictable Pseudo-
Random Number Generator”, SIAM Journal on Computing, vol. 15, pp.
364-383(1986).

[2] M. Rabin, Digitalized Signatures and Public-Key Functions as Intractable

as Factorization, tech. report, MIT, 1979.

15

[3] F¨urbass and Wolkerstorfer, “ECC Processor with Low Die Size for RFID
Applications,” IEEE International Symposium on Circuits and Systems, 2007,
pp. 1835-1838(2007).

[4] Y. K. Lee, K. Sakiyama, L. Batina, and I. Verbauwhede, “Elliptic-Curve-
Based Security Processor for RFID,” IEEE Transactions on Computers,
57(11), pp. 1514-1527(2008).

[5] M. Hutter, M. Feldhofer, and T. Plos, “An ECDSA Processor for RFID
Authentication,” In S. B. O. Yalcin, editor, RFIDsec 2010, 6th Workshop, Is-
tanbul, Turkey, June 7-9, volume 6370 of LNCS, Springer, pp. 189-202(2010).

[6] M. Hutter, M. Feldhofer, and J. Wolkerstorfer. “A Cryptographic Processor
for Low Resource Devices: Canning ECDSA and AES like Sardines,” In C. A.
Ardagna and J. Zhou, editors, Information Security Theory and Practices -
WISTP, Heraklion, Crete, Greece, June 1-3, volume 6633 of LNCS, Springer,
pp. 144-159(2011).

[7] M. Hutter, M. Joye, and Y. Sierra. Memory-Constrained Implementations of
Elliptic Curve Cryptography in Co-Z Coordinate Representation. In A. Nitaj
and D. Pointcheval, editors, AFRICACRYPT 2011, Dakar, Senegal, July 5-7,
volume 6737 of LNCS, Springer, pp. 170-187(2011).

[8] P. Pessl and M. Hutter, “Curved Tags - A Low-Resource ECDSA Imple-
mentation tailored for RFID,” Radio Frequency Identiﬁcation: Security and
Privacy Issues Lecture Notes in Computer Science Volume 8651, pp. 156-
172(2014).

[9] T. Kern and M. Feldhofer, “Low-Resource ECDSA Implementation for Pas-
sive RFID Tags,” In ICECS, December 12-15, Athens, Greece, pp. 1236-
1239(2010).

[10] Y. Oren and M. Feldhofer, “WIPR–Public-Key Identiﬁcation on Two

Grains of Sand,” Proc. Workshop on RFID Security 2008, pp. 15-27(2008).

[11] Y. Oren and M. Feldhofer, “A Low-Resource Public-Key Identiﬁcation
Scheme for RFID Tags and Sensor Nodes,” Proc. 2nd International Conf.
Wireless Network Security (WiSec 09), ACM, pp. 59-68(2009).

[12] A. Arbit, Y. Livne, Y. Oren, A. Wool, “Implementing public-key cryptogra-
phy on passive RFID tags is practical,” International Journal of Information
Security, February 2015, Volume 14, Issue 1, pp 85-99(2015)

[13] D. Naccache, Method, Sender Apparatus and Receiver Apparatus for Mod-
ulo Operation, European Patent Application 91402958.2, ﬁled 27 Oct. 1992.

[14] A. Shamir, “Memory Eﬃcient Variants of Public-Key Schemes for Smart
Card Applications,” Proc. Advances in Cryptology (EUROCRYPT’94),
LNCS 950, pp. 445-449(1995).

16

[15] A. Shamir, “SQUASH - a new MAC with provable security properties for
highly constrained devices such as RFID tags” In Fast Software Encryption,
Springer, pp. 144-157(2008).

[16] W. Hinz, K. Finkenzeller, M. Seysen, “Secure UHF Tags with Strong Cryp-
tography - Development of ISO/IEC 18000-63 Compatible Secure RFID Tags
and Presentation of First Results,” SENSORNETS, pp. 5-13(2013)

[17] P. Montgomery, “Modular Multiplication Without Trial Division,” Math.

Computation, vol. 44, pp. 519–521(1985).

[18] D. Boneh, R.A. DeMillo, and R.J. Lipton, “On the importance of elimi-
nating errors in cryptographic computations,” J. Cryptol. vol.14, no.2, pp.
101-119, Springer-Verlag, Berlin, 2001. Earlier version published in EURO-
CRYPT’ 97.

[19] H. Bar-Ei, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan, “The
sorcerer’s apprentice guide to fault attacks,” In Proc. of the IEEE 94(2), pp.
370-382(2006).

[20] M. Joye, and M. Tunstall eds., Fault Analysis in Cryptography, Springer,

2012.

[21] J. Seifert, “On authenticated computing and RSA-based authentication.”
In Proc. of the 12th ACM Conference on Computer and Communications
Security (CCS 2005), pp. 122-127(2005).

[22] J. A. Muir, “Seifert’s RSA fault attack: Simpliﬁed analysis and generaliza-
tions, ” In ICICS’06 Proc. of the 8th International Conference on Information
and Communications Security, pp.420-434(2006).

[23] V. Shoup, A Computational Introduction to Number Theory and Algebra -

Second ed., Cambridge University Press, 2009.

[24] D. Coppersmith, Small solutions to polynomial equations, and low expo-
nent RSA with vulnerabilities, Journal of Cryptology 10, pp.233-260(1997).

[25] M. Franklin and M. Reiter, A Linear Protocol Failure for RSA with expo-

nent three, in CRYPTO’95 Rump Session, Aug. 1995.

[26] D. Coppersmith, M. Franklin, J. Patarin, and M. Reiter, Low-exponent
RSA with related messages, in EUROCRYPT’98, vol. 1403 of LNCS, pp.
58-71(1998).

[27] A. Berzati, and L. Goubin, Perturbing RSA Public Keys: an Improved
Attack. In E. Oswald, P. Rohatgi (eds.): Cryptographic Hardware and Em-
bedded Systems (CHES 2008), Lecture Notes in Computer Science vol. 5154,
Springer, pp. 380-395(2008).

17

[28] A. Berzati, C. Canovas-Dumas, and L. Goubin, Fault Attacks on RSA Pub-
lic Keys: Left-To-Right Implementations are also Vulnerable. In M. Fischlin
(ed.): CT-RSA 2009, Lecture Notes in Computer Science vol. 5473, Springer,
pp. 414-428(2009).

[29] H. Choukri and M. Tunstall, “Round reduction using faults,” In Proc. of

FDTC 2005, pp.13-24(2005).

[30] J. Park, S. Moon, D. Choi, Y. Kang, and J. Ha, “Diﬀerential fault analysis
for round-reduced AES by fault injection,” ETRI J. vol. 33, no.3, pp.434-
441(2011).

[31] H. Yoshikawa, M. Kaminaga, and A. Shikoda, “Round addition using faults
for generalized Feistel network,” IEICE Trans. Inf. & Syst., vol.E96-D, no.1,
pp.146-150(2013).

[32] M. Kaminaga, H. Yoshikawa, and T. Suzuki, Double Counting in 2t-ary
RSA Precomputation Reveals the Secret Exponent, IEEE Trans. on Inform.
Forensics & Sec., pp.1394-1401(2015).

[33] V. Shoup, A Computational Introduction to Number Theory and Alge-

bra(2nd ed.), Cambridge University Press, 2009.

[34] G. H. Hardy and E. M. Wright(revised by D. R. Heath-Brown and J. H. Sil-
verman), An Introduction to The Theory of Numbers(Sixth Edition), Oxford
University Press, 2008.

[35] P. Erd¨os and M. Kac, The Gaussian law of errors in the theory of additive
number theoretic functions, American Journal of Mathematics 62, pp. 738-
742(1940) .

18

