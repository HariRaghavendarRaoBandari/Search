Space Bounds for Adaptive Renaming

Maryam Helmi1, Lisa Higham2, and Philipp Woelfel3

University of Calgary

Department of Computer Science
Calgary, T2N1N4 Alberta, Canada

Abstract. We study the space complexity of implementing long-lived and one-shot adaptive renaming
from multi-reader multi-writer registers, in an asynchronous distributed system with n processes. As a
result of an f -adaptive renaming algorithm each participating process gets a distinct name in the range
{1, . . . , f (k)} provided k processes participate.
Let f : {1, . . . ,n} → N be a non-decreasing function satisfying f (1) ≤ n− 1 and let d = max{x | f (x) ≤
n − 1}. We show that any non-deterministic solo-terminating long-lived f -adaptive renaming object
requires d + 1 registers. This implies a lower bound of n− c registers for long-lived (k + c)-adaptive
renaming, which we observe is tight.
We also prove a lower bound of ⌊ 2(n−c)
c+2 ⌋ registers for implementing any non-deterministic solo-
terminating one-shot (k + c)-adaptive renaming. We provide two one-shot renaming algorithms: a wait-
free algorithm and an obstruction-free algorithm. Each algorithm employs a parameter to depict the
tradeoff between space and adaptivity. When these parameters are chosen appropriately, this results in
a wait-free one-shot ( 3k2
one-shot f -adaptive renaming algorithm from only min{n,x | f (x) ≥ 2n} + 1 registers.

2 )-adaptive renaming algorithm from ⌈√n⌉ + 1 registers, and an obstruction-free

6
1
0
2

 
r
a

 

M
9
2

 
 
]

C
D
.
s
c
[
 
 

5
v
7
6
0
4
0

.

3
0
6
1
:
v
i
X
r
a

1mhelmikh@ucalgary.ca, +1 403 210-9416
2higham@ucalgary.ca, +1 403 220-7696
3woelfel@ucalgary.ca, +1 403 220-7259

1 Introduction

Distributed systems with a large number of processes, such as the Internet, provide services that are typically used
by only a small number of processes simultaneously. This is problematic if the time or space used by the service
is a function of the size of the name-space of the processes that could use it. The time or space consumed by such
applications can be signiﬁcantly decreased by having each process that wants to use the application ﬁrst acquire a
temporary name from a name space that is adequate to distinguish all the participants, but much smaller than the
name-space of the distributed system, and then return the temporary name to the pool when it is ﬁnished with the
service. This is the role of a shared renaming object. A related application of the renaming object is in operating
systems where processes repeatedly acquire and release names that correspond to a limited number of resources [12].
Renaming is an important tool in distributed computing [5] because it enhances the practicality and usefulness of
distributed system services. A renaming object may be even more useful if the time and space resources it consumes
is a reasonable function of the actual number of processes that are currently either holding, acquiring, or releasing a
name. In this paper, we address the renaming problem for the standard asynchronous shared memory model with n
processes.

With an f -adaptive renaming object, each of the n processes can perform a getName() and return a distinct name
in a small domain {1, . . . , f (k)} where k is the number of participants. Herlihy and Shavit [24], and also Rajbaum
and Casta˜neda [13] showed that there is no deterministic, wait-free implementation of (2k − 2)-adaptive renaming
from multi-reader multi-writer registers. This result also follows from the relationship between the adaptive renam-
ing problem and strong symmetry breaking (SSB): a (2k − 2)-renaming algorithm implies a solution to SSB [7], for
which there is no deterministic wait-free solution [7, 9, 20]. This impossibility can be circumvented by using random-
ness or stronger primitives such as compare-and-swaps [2, 4, 16, 28, 29]. The step complexity of deterministic and
randomized algorithms has been studied extensively in asynchronous systems (see e.g., [1, 3, 4, 10, 17]). However,
there are no previous results on the space complexity of adaptive renaming. Because renaming seems to require that
participants discover information about each other, adaptive renaming appears related to f -adaptive collect. A collect
algorithm is f -adaptive to total contention, if its step complexity is f (k), where k is the number of processes that ever
took a step. Attiya, Fich and Kaplan [6], proved that W ( f −1(n)) multi-reader multi-writer registers are required for
f -adaptive collect.

Suppose you have m shared registers available to construct a renaming object for a system with n processes. First
we would like to know under what additional conditions such an implementation exists, and when it does, how best
to use the m registers. Suppose, when there are k participants, the acquired names are in the range {1, . . . , f (k)}. Will
f (k) = kc for a small constant c sufﬁce for the application? Must f (k) be closer to k, say within a constant? Perhaps
it should even be exactly k (tight adaptive renaming)? Does the application need to permit processes to repeatedly
acquire and release a name (long-lived renaming), or do processes get a name at most once (one-shot renaming)? How
strong a progress guarantee is required? Is the number of participants usually less than some bound b much smaller
than n? If so, is there still some signiﬁcant likelihood that the number of participants is somewhat bigger than b, or
is there conﬁdence that the bound b is never, or only very rarely, exceeded? In the rare cases when there are a large
number of participants, can the system tolerate name assignments from a very large name space?

In order to study the space complexity implication for these questions, we ﬁrst generalize the adaptive renaming def-
inition. Both versions (long-lived and one-shot) of b-bounded f -adaptive renaming support the operation getName(),
which returns a name to each invoking process. The long-lived version also supports an operation relName(), which
releases the name to the available name domain. Both versions must satisfy 1) no two processes that have completed a
getName() and have not started their following relName(), receive the same name, 2) if there are k ≤ b processes that
have invoked getName() and have not completed their subsequent relName() during an execution of getName() by
process p, then p returns a name in {1, . . . , f (k)}. Observe that for the one-shot case, k is the number of processes that
have started a getName() before p completes its getName(). We call the problem of n-bounded f -adaptive renaming
simply f -adaptive renaming. The special case when f (k) = k and b = n is called tight renaming. Our goal is to deter-
mine the relationships between b, f (k), and m for one-shot versus long-lived, and wait-free versus non-deterministic
solo-terminating implementations of adaptive renaming objects from multi-reader/multi-writer registers.

Let f : {1, . . . ,n} → N be a non-decreasing function satisfying f (1) ≤ n− 1 and let d = max{x | f (x) ≤ n− 1}.

Note that if f (1) ≥ n, f -adaptive renaming is a trivial problem. In this paper we show:

1

f -adaptive renaming object.

• At least d + 1 registers are required to implement any non-deterministic solo-terminating long-lived d-bounded
• At least ⌊ 2(n−c)
c+2 ⌋ registers are required to implement any non-deterministic solo-terminating one-shot (k + c)-
adaptive renaming object where, c is any non-negative integer constant.
• For any b ≤ n, there is a wait-free one-shot (b− 1)-bounded (k(k + 1)/2)-adaptive renaming algorithm imple-
mented from b bounded registers. When k ≥ b, the returned names are in the range {1, . . . ,n + b(b−1)
• For any b ≤ n, there is an obstruction-free one-shot (b − 1)-bounded k-adaptive renaming algorithm imple-
mented from b + 1 bounded registers. When k ≥ b, the returned names are in the range {1, . . . ,n + b− 1}.

2

}.

c ≥ 0.

2 )-adaptive renaming algorithm that uses only ⌈√n⌉ + 1 registers.

By using these results and setting b appropriately we then derive the following corollaries:
• A wait-free one-shot ( 3k2
• An obstruction-free one-shot f -adaptive renaming algorithm that uses only min{n,x | f (x) ≥ 2n} + 1 registers.
• A tight space lower bound of n− c registers for long-lived (k + c)-adaptive renaming for any integer constant
Our lower bound proofs use covering techniques ﬁrst introduced by Burns and Lynch [11]. The main challenge is
to exploit the semantics of the renaming object to force the processes to write to a large number of registers. In the
lower bound for the one-shot case, we ﬁrst build an execution in which some processes are poised to write to (cover)
a set of registers. Then we argue that if enough new processes take steps after this, at least one of them must become
poised to write to a register not already covered, since, otherwise, the covering processes can obliterate all the traces
of the new processes, causing some getName() to return an incorrect result. For the lower bound for the long-lived
case, we exploit that fact that processes can perform getName() and relName() repeatedly to build a long execution,
where in each inductive step either another register is covered or an available name is used up without being detected
by other processes.

2 Preliminaries

This section describes our model of computation and the notation, vocabulary and general techniques used in this
paper. Previous work by many researchers (for example [8, 11, 18, 19, 23, 27]) has collectively developed similar
tools that serve to make our description of results and presentation of proofs precise, concise and clear. Much of the
terminology presented in this section is borrowed or adapted from this previous research.

Our computational model is an asynchronous shared memory system consisting of n processes P = {p1, . . . , pn}
and m shared registers R = {R1, . . . ,Rm}. Each process executes code that can access its own independent random
number generator and its own private registers as well as the shared registers. Each shared register supports two
operations, read and write. Each such operation happens atomically in memory. Processes can only communicate via
those operations on shared registers. The algorithm is deterministic if each process’ code is deterministic; that is, no
process’ code contains any random choice.

Informally, an execution arises one step at a time, where a step consists of some process, chosen arbitrarily, execut-
ing the next instruction in its code. This instruction could be a shared memory access, or a local memory access, or
a local operation including, possibly, a random choice. Notice, however, that after a process takes a shared memory
step, the outcome of all its subsequent local operations and random choices up to (but not including) its next shared
memory operation is independent of any intervening operations by other processes. Therefore, there is no loss of
generality in assuming that a step by a process consists of a single shared memory access (or, initially, its method-call
invocation) followed by all its subsequent local operations and random choices, up to the point where that process is
poised to execute its next shared memory operation.

A conﬁguration C is a tuple (s1, . . . ,sn,v1, . . . ,vm), denoting that process pi, 1 ≤ i ≤ n, is in state si and register r j,
1 ≤ j ≤ m, has value v j. Furthermore the state si of pi is one in which pi’s next operation is either a shared memory
operation or an invocation of a method-call (getName() or relName()). Conﬁgurations will be denoted by capital
letters. The initial conﬁguration, where each process’ next step is to invoke a method-call, is denoted C∗.

Given a conﬁguration, C, a step from C is a pair of the form (p,t ) where p is a process identiﬁer, and t

is a sequence
of outcomes that arise from the sequence of all random choices that p makes after completing its pending shared mem-

2

ory operation starting from conﬁguration C up to the point where p is poised to do its next shared memory operation.
An execution is an alternating sequence of conﬁgurations and steps starting and ending with a conﬁguration, and
deﬁned inductively as follows. The 0-step or empty execution starting at C is (C). A k-step execution, k ≥ 1, starting
at C0 is a sequence (C0, (q1,t 1),C1, (q2,t 2), . . . , (qk,t k),Ck) where

• (C0, (q1,t 1),C1, (q2,t 2), . . . , (qk−1,t k−1),Ck−1) is a k− 1 step execution starting at C0, and
• (qk,t k) is a step from Ck−1 and Ck is the conﬁguration resulting from that step.

An execution is a k-step execution for any integer k ≥ 0. A subsequence, s = ((q1,t 1), . . . , (qk,t k)), consisting of
the steps from an execution starting at C is called a schedule starting at C. If s
is a schedule starting at C, then the
execution starting at C arising from s
is abbreviated E = (C;s ) and s (C) denotes the ﬁnal conﬁguration of E. If
an algorithm is deterministic, then the second component of every step of every execution of the algorithm is empty
because there are no random choices. So in this case a schedule is simpliﬁed to just a sequence of process identiﬁers.
, such that s (C∗) = C. Let s and p be two ﬁnite
, and
is P-only if all the identiﬁers
is p-only. We denote

A conﬁguration, C, is reachable if there exists a ﬁnite schedule, s
schedules such that s
is a schedule starting at C. Let P ⊆ P be a set of processes, and s a schedule. We say s
of processes that appear in s are in P. If the set P contains only one process, p, then we say s
the set of processes that appear in schedule s by procs(s ).

starts at conﬁguration C and p starts at s (C). Then s

denotes the concatenation of s and p

A deterministic implementation of a method is wait-free if, for any reachable conﬁguration C and any process p, p
completes its method call in a ﬁnite number of its own steps, regardless of the steps taken by other processes. An im-
plementation of a method is non-deterministic solo-terminating if, for any reachable conﬁguration C and any process
p, there exists a ﬁnite p-only schedule, s
, starting from C such that p has ﬁnished its method call in conﬁguration
s (C)[18]. Hence, by making the right non-deterministic choices, a process can ﬁnish its method call whenever there
is no interference from other processes [23]. If a method implementation is deterministic then non-deterministic solo-
termination implies that in a p-only execution starting from any reachable conﬁguration C, p ﬁnishes its method call
in a ﬁnite number of its own steps. In this case the implementation is obstruction-free.

We say process p covers register r in a conﬁguration C, if p writes to r in its next step. A set of processes P covers
a set of registers R if for every register r ∈ R there is a process p ∈ P such that p covers r. If |P| = |R|, then we
say P exactly covers R. Consider a process set P that exactly covers the register set R in conﬁguration C. Let p P be
any permutation which includes exactly one step by each process in P. Then the execution (C;p P) is called a block-
write by P to R. Two conﬁgurations C = (s1, . . . ,sn,v1, . . . ,vm) and C′ = (s′1, . . . ,s′n,v′1, . . . ,v′m) are indistinguishable
to process pi if si = s′i and v j = v′j for 1 ≤ j ≤ n. Let P be a set of processes, and s
any P-only schedule starting at
conﬁguration C. If for every process p ∈ P, C and C′ are indistinguishable to p, then s
is also a schedule starting at
C′ and s (C) and s (C′) are indistinguishable to p.

A process p participates in conﬁguration C if in C, p has started a getName() operation and has not completed the
following relName(). A process is called idle in conﬁguration C if it does not participate in C. A conﬁguration C is
called quiescent if, ∀p ∈ P , p is idle in C. We say process p owns name x in conﬁguration C if in C, p has completed
a getName() operation that returned name x and p has not started relName(). Let C0, . . . ,Ce be a sequence of
conﬁgurations arising from execution E. The number of participants in E is the maximum over all i, 0 ≤ i ≤ e, of the
number of participants in Ci. Given these deﬁnitions, the deﬁnition of a renaming object can be stated more precisely
as follows. Let f : {1, . . . ,n} → N be a non-decreasing function satisfying f (1) ≤ n− 1. Both long-lived and one-
shot b-bounded f -adaptive renaming support the operation getName(). Operation getName() by process p returns a
name x to p. The long-lived version also supports the operation relName(), which releases the name x. Both versions
must satisfy 1) there is no reachable conﬁguration in which two processes own the same name, 2) if the number of
participants during p’s getName(), k, is at most b then, x ∈ {1, . . . , f (k)}. Observe that, properties 1) and 2) imply
that f (k) ≥ k for all k ∈ {1, . . . ,n}.

3 A Space Lower Bound for Long-Lived Loose Renaming Objects

For any non-decreasing function f satisfying f (1) ≤ n− 1, let d be the largest integer such that f (d) ≤ n− 1. We
prove that at least d + 1 registers are required for non-deterministic solo-terminating long-lived f -adaptive renaming
in our system. The proof relies on two lemmas. Lemma 3.1 says that there is no reachable conﬁguration C in which
n− d processes own names in the range {1, . . . ,n− 1} while all of the other d processes are idle and unaware of any of

3

p
the processes with names. The intuition for this proof is simple: if such a reachable conﬁguration C exists, then there
is a conﬁguration reachable from C in which (n− d) + d = n processes all own names in the range {1, . . . ,n− 1}.
Lemma 3.2 provides the core of the lower bound argument and the intuition is as follows. Let C be any reachable
conﬁguration in which fewer than n− d processes own names in the range {1, . . . ,n− 1} while all of the other d + 1
processes are idle and unaware of the processes with names. Then there is a reachable conﬁguration from C in which
either d + 1 distinct registers are written, or one more name is owned, and the unnamed processes are again idle
and still unaware of the processes with names. Since the initial conﬁguration has no processes with names, and all
processes are idle, we can apply Lemma 3.2 repeatedly until either we have exactly covered d +1 registers or we reach
a conﬁguration in which n− d − 1 processes own names in the range {1, . . . ,n− 1}. Since, according to Lemma 3.1,
we cannot get beyond an (n− d − 1)-invisibly-named conﬁguration, we must eventually exactly cover d + 1 registers,
completing the proof. We will see, in the formal proof, that the result applies even when the renaming implementation
is (d + 1)-bounded.

The deﬁnitions and lemmas that follow refer to any non-deterministic solo-terminating implementation from shared
registers of a long-lived f -adaptive renaming object. For a conﬁguration C and a set of processes Q, we say Q is
invisible in C, if there is a reachable quiescent conﬁguration D such that C and D are indistinguishable to all processes
in Q. If the set Q contains only one process q, then we say process q is invisible. Conﬁguration C is called ℓ-invisibly-
named, if there is a set Q of ℓ processes, such that in C every process in Q owns a name in {1, . . . ,n− 1} and Q is
invisible.
Lemma 3.1. For the largest integer d satisfying f (d) ≤ n− 1, there is no reachable (n− ).-invisibly-named conﬁgu-
ration.

Proof. By way of contradiction, suppose that there exists a set Q of n− d processes such that in conﬁguration C, all
processes in Q are invisible and own names in the range {1, . . . ,n− 1}. Since Q is invisible in C, there is a reachable
quiescent conﬁguration D such that D and C are indistinguishable to Q. Let s be a Q-only schedule such that in
execution (D;s ), all processes in Q perform a complete getName(). Because |Q| = d all processes in Q get names
in the range {1, . . . , f (d)} ⊆ {1, . . . ,n− 1}. Since C and D are indistinguishable to Q, all processes in Q perform a
complete getName() during (C;s ) and get names in the range {1, . . . , f ().} as well. Therefore in conﬁguration s (C)
all processes in Q∪ Q have names in the range {1, . . . ,n− 1}. However |Q∪ Q| = n. This is a contradiction because
this implies that the acquired names are not distinct.

The intuition for Lemma 3.2 is as follows. Recall that in an ℓ-invisibly-named conﬁguration, ℓ processes have
names, the n − ℓ others are idle and unaware of the presence of the invisibly-named processes, and no register is
covered. Starting from this conﬁguration we select one process at a time from the set of idle processes and let
it execute until either it covers a register not already covered, or it gets a name without covering a new register.
We continue this construction as long as the selected process covers a new register.
If we reach d + 1 processes
covering distinct registers we are done. Otherwise, we reached a conﬁguration in which one more process holds a
name. Furthermore, we can obliterate the trace of this process with the appropriate block write, and then let all other
non-idle processes complete their getName() methods and the following relName(). This takes us to an (ℓ + 1)-
invisibly-named conﬁguration.
Lemma 3.2. Let d be the largest integer such that f (d) ≤ n − 1. For any 0 ≤ ℓ ≤ n − d − 1 and any reachable
ℓ-invisibly-named conﬁguration C, there exists a schedule s

, where |procs(s )| ≤ d + 1, and either

• in conﬁguration s (C) at least d + 1 distinct registers are exactly covered; or
• conﬁguration s (C) is (ℓ + 1)-invisibly-named.

Proof. Let C be an ℓ-invisibly-named conﬁguration, and let Q be the set of ℓ processes that are invisible in C. Let D
be a quiescent conﬁguration that is indistinguishable from C for all processes in Q. First, we inductively construct a
sequence of schedules d 0,d 1, . . . until we have constructed d
a) d + 1 registers are exactly covered, or,
b) (ℓ + 1) processes own names in {1, . . . ,n− 1}.

last such that in d

last(C) either

4

We maintain the invariant that for each i ∈ {0, . . . ,last} in conﬁguration d
a set Li of i distinct registers, Pi ∩ Q = /0, and d
d 0(C) = C, no register is covered, so the invariant is true for P0 = L0 = /0.
Now consider i ≥ 0. If a) or b) holds for d
distinct registers is covered, we have i ≤ d. We construct d
p-only schedule such that either
1) p does a complete getName() in execution (d
i(C);g ), or
2) in conﬁguration g (d

i(C)), p covers a register r /∈ Li.

i+1 be d

i(C), a set Pi of i processes exactly covers
i is Pi-only. Let d 0 be the empty schedule. Then in conﬁguration

i, we let last = i and are done. Otherwise, since in d

i(C) a set Li of i
i+1 as follows. Select p ∈ Pi ∪ Q. Let g be the shortest

last = d

i+1.

last = d

last we construct schedule s

.

If d

last(C) satisﬁes a), let s = d

ig . First assume case 1) happens. By construction the process that performs d 1 does not write to any
Let d
register. If i = 0 and p does a complete getName() in execution (d 0(C);g ), then last = 1 and we are done. For any
i ≥ 1, because Q is invisible to p, in (d
i(C);g ) p becomes aware of at most the i− 1 ≤ d other processes in Pi. Since
f (d) ≤ n− 1, p gets a name in {1, . . . ,n− 1}, and thus in conﬁguration d
i+1(C) all processes in Q∪{p} own names
in {1, . . . ,n− 1} and |Q∪{p}| = ℓ + 1. So condition b) is achieved, the construction stops and d
Now suppose case 2) happens. If i+1 = d +1, then condition a) is achieved, the construction stops and d
i+1.
Otherwise, the invariant remains satisﬁed for Li+1 = Li ∪{r} and Pi+1 = Pi ∪{p}. Clearly, after at most d + 1 steps
either a) or b) is achieved.
Now, using schedule d
last and the lemma holds.
lastp Plast−1(C);a )
Hence, suppose that d
every process q ∈ Plast−1 completes its pending getName() operation and performs a complete relName(). During
execution (C;d
last(C), Plast−1 exactly covers these
last = d
registers. Because d
last, after a block write by Plast−1, conﬁgurations
last−1p Plast−1(C) are indistinguishable to Q∪{p}. Since C and D are indistinguishable to Q, con-
lastp Plast−1(C) and d
lastp Plast−1(C)
ﬁgurations d
and d
last−1p Plast−1
a (D)
are indistinguishable to (Q∪{p}). Since d
a (C) is an (ℓ + 1)-
invisibly-named conﬁguration. Therefore, the lemma holds for s = d
Theorem 3.3. Let d be the largest integer such that f (d) ≤ n− 1. Any non-deterministic solo-terminating implemen-
tation of a long-lived d-bounded f -adaptive renaming object requires at least d + 1 registers.

last−1p Plast−1(D) are indistinguishable to Q∪{p}. Hence, conﬁgurations d
lastp Plast−1

for some p-only postﬁx g of d
last−1p Plast−1(D) are also indistinguishable to Q. So, conﬁgurations d

last(C) satisﬁes b). Let a be the Plast−1-only schedule such that in execution (d

lastp Plast−1
a (D) is quiescent, conﬁguration d
.

last) only registers in Llast−1 were written and in conﬁguration d

last−1g
last−1p Plast−1(C) and d

a (C) and d
lastp Plast−1

last−1p Plast−1

i, |procs(s

i)| ≤ d + 1, such that Ci+1 = s

Proof. Note that C∗ is a reachable 0-invisibly-named conﬁguration. We iteratively construct a sequence of schedules
s 0,s 1, . . . ,s
last as follows: If 0 ≤ i ≤ n−d and Ci is a reachable i-invisibly-named conﬁguration, we apply Lemma 3.2
to obtain a schedule s
i(Ci) is either an (i + 1)-invisibly-named conﬁguration,
or in Ci+1 at least d + 1 distinct registers are covered. In the latter case we let last = i + 1 and ﬁnish the iterative
construction. By Lemma 3.1, there is no (n− d)-invisibly-named conﬁguration. Hence if the iterative construction
reaches a (n− d− 1)-invisibly-named conﬁguration, by Lemma 3.2, there is a reachable conﬁguration, in which d + 1
registers are covered.
Corollary 3.1. Let c ∈ {1, . . . ,n − 1} and b = n− c. Any non-deterministic solo-terminating implementation of a
long-lived b-bounded (k + c)-adaptive renaming object requires at least b registers.

4 A Space Lower Bound for One-shot Additive Loose Renaming

In one-shot renaming, each process is constrained to call getName() at most once (and does not invoke relName()),
which imposes a severe restriction on the techniques available for proving lower bounds. In particular, constructions
that rely on processes repeatedly getting and releasing names cannot be used for one-shot lower bounds. We observed
however, that a straightforward linear lower bound for tight renaming actually applies even for one-shot adaptive
renaming. Thus, we are motivated to study one-shot renaming objects with looseness constrained by a constant,
speciﬁcally k-renaming and (k + c)-renaming. We refer to one-shot (k + c)-renaming object as an additive loose
renaming object, where k is the number of participants and c ≥ 0 is an integer constant. For the case c = 0, it is called
an adaptive tight renaming object.

5

d
a
Our lower bound proof has a recursive structure and it relies on a generalization of additive loose renaming as
follows. For any set T ⊂ {1, . . . ,k + c} where |T| ≤ c, a [(k + c)\T ]-renaming object for k processes requires that each
participating process returns a unique name from the range {1, . . . ,k + c}\T .
Lemma 4.1. Any implementation of [(k + c)\T ]-renaming uses at least as many registers as an implementation of
[(k + c−|T|)\/0]-renaming.
Proof. Let A be a [(k + c)\T ]-renaming algorithm. Then we construct [(k + c−|T|)\/0]-renaming algorithm A′ from
A without any additional registers as follows. If A returns name x, then A′ returns x−|{t ∈ T | t ≤ x}|. Since A returns
distinct names in the range {1, . . . ,k + c}\T , obviously A′ returns distinct names in the range {1, . . . ,k + c−|T|}.

A process is called startable in conﬁguration C if in C, it has not started a getName(). Since in one-shot renam-
ing, there is no relName() operation, in our proofs in this section instead of using quiescent conﬁgurations we are
interested in conﬁgurations in which each process either has completed its getName() operation or it has not started
a getName(). We call such conﬁgurations, quiet conﬁgurations.
Lemma 4.2. Let D be a reachable quiet conﬁguration with n′ ≥ c + 2 startable processes. For every startable process
p, let s p denote a p-only schedule such that p performs a complete getName() in execution (D;s p). Let Q be any
subset of startable processes of size c + 1, then there exists a process q ∈ Q such that q writes to a register during
(D;s q).

Proof. Let X be the set of processes that own names in conﬁguration D. Then processes in X own names in range
{1, . . . ,|X| + c}. Let Q = {q1, . . . ,qc+1}. By way of contradiction assume that there is no process q ∈ Q such that q
writes to a register during (D;s q). Then for all i, 1 ≤ i ≤ c + 1, conﬁgurations s q1 . . .s qc+1(D) and s qi(D) are indis-
s q′(D) and s q′(D) are indistinguishable
tinguishable to qi. Let q′ be a startable process not in Q. Hence, s q1 . . .s qc+1
s q′).
to q′. Therefore, all processes in Q plus q′ return names from {1, . . . ,|X| + 1 + c} in execution (D;s q1 . . .s qc+1
This is a contradiction because |X| + c + 2 processes receive names from a set of size |X| + c + 1 implying that they
cannot be assigned distinct names.

Lemma 4.3. Let D be a reachable conﬁguration in which:

• a set Q of at least c + 1 processes covers a set of ℓ ≥ 1 registers,
• there exists a set Q′ ⊆ Q of size c + 1 such that no process in Q′ has written to a register and,
• there is a set of c + 1 startable processes P, disjoint from Q.

Then, there is a P-only schedule s P such that at least ℓ + 1 registers are covered in s P(D).

Proof. Let X be the set of processes that own names in conﬁguration D. Since no process in Q′ has written to a register,
processes in X own names in range {1, . . . ,|X| +|Q|−|Q′| + c}. Let L be the set of registers covered by Q and Q′′ ⊆ Q
be a set of processes that exactly covers L. Let cs P be a P-only schedule such that in execution (D;cs P) all processes in P
complete their getName() operations. Then all processes in P return names from {1, . . . ,|X| +|Q|−|Q′| +|P| + c} =
{1, . . . ,|X| +|Q| + c} in execution (D;cs P). Suppose that in execution (D;cs P), there is a process in P that writes to
a register not in L. Then let s P be the shortest preﬁx of cs P such that a register r /∈ L is covered by a process in
P. Hence in conﬁguration s P(D), L is covered by Q and r is covered by P. Thus we are done. Therefore, assume
that in execution (D;cs P) all processes in P write only to L. Let p Q′′ be a block-write to L by Q′′. Let s Q be a Q-
only schedule such that in execution (s Pp Q′′(D);s Q) all processes in Q complete their getName() operations. Since
conﬁgurations s Pp Q′′(D) and p Q′′(D) are indistinguishable to all processes in Q, processes in Q return names from
{1, . . . ,|X| +|Q| + c} in execution (s Pp Q′′(D);s Q). This is a contradiction because |X| +|Q| +|P| = |X| +|Q| + c + 1
processes receive names from a set of size |X| +|Q| + c implying that they cannot be assigned distinct names.

6

Lemma 4.4. Let D be a reachable conﬁguration in which:

• a set P of processes exactly covers a set of ℓ ≥ 1 registers,
• there exists a process q ∈ P such that q has not written to any register and,
• there exists a set of n′ ≥ c startable processes.

c+1 ⌋ registers are covered.

c+1 ⌋ registers are covered.

Then, there exists a conﬁguration reachable from D, in which at least ℓ +⌊ n′−c
Proof. Let P ′ be the set of all startable processes in D and Q ⊆ P ′ be a set of c processes. Then in conﬁguration
D, processes in Q∪ P cover a set of ℓ registers where |Q∪ P| ≥ c + 1 and, no process in set Q∪{q} has written to a
register. Hence using startable processes in P ′\Q, we can inductively apply Lemma 4.3, until we reach a conﬁguration
in which ℓ +⌊ n′−c
Lemma 4.5. Let A be an non-deterministic solo-terminating implementation of one-shot adaptive tight renaming. Let
D be any reachable quiet conﬁguration with n′ ≥ 2 startable processes. Then there is an execution of A, starting from
D that requires at least n′ registers.
Proof. Let p be a startable process and cs p be a p-only schedule such that in (D;cs p), p completes its getName().
Then by Lemma 4.2, p writes to a register. Let s p be the shortest preﬁx of cs p such that in (D;s p), p covers a register.
Then by Lemma 4.4, there exists a conﬁguration reachable from s p(D), in which at least 1 + n′ − 1 = n′ registers are

covered.
In Lemma 4.6, we show at least ⌊ 2(n′−c)
c+2 ⌋ registers are required for a non-deterministic solo-terminating implemen-
tation of one-shot (k + c)-adaptive renaming starting from a quiet conﬁguration with n′ ≥ 2c + 2 startable processes.
The intuition for this lemma is as follows. We prove the lemma by induction on c. Starting from any quiet conﬁgura-
tion, ﬁrst we select a set Q of c + 1 startable processes such that one of them writes to a register in a solo-run and we
stop it immediately before it writes. Then we choose a process p not in Q and run it until it covers a new register. If
we succeed, we select another startable process not in Q. We might not succeed for two reasons. First, we are out of
startable processes in which case we are done. Second, process p completes its getName() and only writes to the set
of covered registers. Then Lemma 4.4 provides a lower bound. Furthermore, starting from this conﬁguration, if the
set of covering processes perform a block-write and cover p’s trace, then no other process distinguishes this execution
from one in which p has not run at all. Therefore by Lemma 4.1, our problem reduces to one-shot (k + c− 1)-adaptive
renaming. Hence we can invoke the induction hypothesis and conclude a second lower bound. Our ﬁnal lower bound
is the maximum of these two lower bounds.

Lemma 4.6. Let A be a non-deterministic solo-terminating implementation of one-shot (k + c)-adaptive renaming.
Let D be any reachable quiet conﬁguration with n′ ≥ 2c + 2 startable processes. Then there is an execution of A,
starting from D that requires at least ⌊ 2(n′−c)
Proof. Let P ′ be the set of startable processes in D. We prove the lemma by induction on c. For the base case c = 0,
by Lemma 4.5, the hypothesis is true. Suppose that the induction hypothesis is true for c− 1 ≥ 0. Since, |P ′| > c + 1,
by Lemma 4.2 there is a process q ∈ P ′ that writes to a register in a solo-execution starting from D. Let s q be the
shortest q-only schedule such that in conﬁguration s q(D), there is a register r covered by q. Let Q ⊆ (P ′\{q}) be a
First, we inductively construct a sequence of schedules d 1,d 2, . . . until we have constructed d ℓ such that in d ℓ(D)

c+2 ⌋ registers.

set of c processes.

either
a) |P ′\Q| registers are covered or,
b) a process q′ in P ′\Q has completed its getName() and has written only to registers covered by other processes.
We maintain the invariant that for each i ∈ {1, . . . , ℓ} in conﬁguration d
i(D), a set Pi ⊆ (P ′\Q) of i processes covers
a set Li of i distinct registers and d
i is Pi-only.
Let d 1 be s q. Then in conﬁguration d 1(D), one register is covered, so the invariant is true for P1 = {q} and L1 = {r}.
Now consider i ≥ 1. If a) or b) holds for d
i, we let ℓ = i and the construction stops. Furtheremore in case b), let q′

be the process that completes its getName().

7

i(D) a set Li of i distinct registers is covered, we construct d

Otherwise, since in d
P ′\(Pi ∪ Q). Let g be the shortest p-only schedule such that either
1) p does a complete getName() in execution (d
2) in conﬁguration g (d

i(D)), p covers a register r′ /∈ Li.

i(D);g ) and only writes to Li, or

i+1 as follows. Select p ∈

c+1

Let d
i+1 be d
ig . First assume case 1) happens. Then condition b) is achieved, the construction stops and we let
d ℓ = d
i+1 and q′ = p. Now suppose case 2) happens. If i + 1 = |P ′\Q|, then condition a) is achieved, the construction
stops and d ℓ = d
i+1. Otherwise, the invariant remains satisﬁed for Li+1 = Li ∪{r′} and Pi+1 = Pi ∪{p}. Clearly, after
at most |P ′\Q| steps either a) or b) is achieved.
In case a), in conﬁguration d ℓ(D), ℓ = n′ − c registers are covered so the lemma holds in this case. Now suppose
case b) happens. In conﬁguration d ℓ−1(D), a set of ℓ− 1 registers (i.e Lℓ−1) are covered exactly by a set of processes
Pℓ−1 and process q in Pℓ−1 has not written to any registers. Furthermore in conﬁguration d ℓ−1(D), all processes in
P ′\Pℓ−1 ⊇ Q are startable. Therefore, by Lemma 4.4, there is a conﬁguration reachable from d ℓ−1(D) in which at
⌋ registers are covered. Let p Pℓ−1 be a block-write by Pℓ−1. Let s Pℓ−1 be a Pℓ−1-only schedule
least ℓ− 1 +⌊ n′−ℓ+1−c
such that in execution (d ℓp Pℓ−1(D);s Pℓ−1) all processes in Pℓ−1 complete their getName(). Let x be the name taken
by q′ in execution (D;d ℓ). Let X be the set of processes that own names in conﬁguration D. Since in conﬁguration
d ℓ(D), only processes in X ∪ Pℓ have invoked a getName(), x ∈ {1, . . . ,|X| + ℓ + c}. Note that d ℓp Pℓ−1
s Pℓ−1(D) and
s Pℓ−1(D) are indistinguishable to all processes except q′. Hence in any (P ′\Pℓ)-only execution starting from
d ℓ−1p Pℓ−1
d ℓ−1p Pℓ−1
s Pℓ−1(D), names returned by processes in P ′\Pℓ are in {1, . . . ,k + c}\{x} where k ≥ |X| + ℓ and therefore
s Pℓ−1(D), algorithm A requires as many registers as a
{x} ⊂ {1, . . . ,k + c}. Thus by Lemma 4.1, starting at d ℓ−1p Pℓ−1
(k + c− 1)-renaming algorithm starting at a quiet conﬁguration with |P ′ − Pℓ| = n′ − ℓ startable processes. Therefore,
by the induction hypothesis there is a reachable conﬁguration from d ℓ−1p Pℓ−1
s Pℓ−1(D), in which at least ⌊ 2(n′−ℓ−c+1)
⌋
registers are covered.
⌋ = ⌊ 2(n′−ℓ−c+1)
The minimum of ℓ − 1 + ⌊ n′−ℓ+1−c
⌋.
Hence, ℓ = ⌊ n′−c
Theorem 4.7. Any non-deterministic solo-terminating implementation of one-shot (k +c)-adaptive renaming requires
at least ⌊ 2(n−c)
Proof. The initial conﬁguration is a quiet conﬁguration with n startable processes. Hence, by Lemma 4.6, there is an
execution, starting from the initial conﬁguration that requires at least ⌊ 2(n−c)
Observe that by setting c = 0, it follows from Theorem 4.7 that any non-deterministic solo-terminating implemen-
tation of one-shot adaptive tight renaming requires n registers. Since the number of startable processes is initially n,
next corollary also follows from Lemma 4.6.

c+2 ⌋− 1. Therefore the algorithm requires at least ⌊ 2(n′−c)

⌋, is maximized when ℓ − 1 + ⌊ n′−ℓ+1−c

c+2 ⌋ registers.

⌋ and ⌊ 2(n′−ℓ−c+1)

c+1

c+2 ⌋ registers.

c+2 ⌋ registers.

c+1

c+1

c+1

c+1

Corollary 4.1. Any non-deterministic solo-terminating implementation of one-shot adaptive tight renaming requires
at least n registers.

5 Wait-Free One-shot (b− 1)-Bounded (k(k + 1)/2)-Adaptive Renaming
In this section we present a wait-free one-shot (b − 1)-bounded (k(k + 1)/2)-adaptive renaming algorithm from b
registers. Since 0-bounded adaptive renaming is a trivial problem, we assume that b ≥ 2.
The algorithms in this section employ a set R = {R[0], . . . ,R[b− 1]} of shared atomic registers. In our proofs, a
register conﬁguration is a tuple (V0, . . . ,Vb−1), denoting that register R[i], 0 ≤ i ≤ b− 1, has value Vi. The proofs
focus on just the sub-sequence of register conﬁgurations produced by an execution. Speciﬁcally, given an execution
E = (C0;s ), let write schedule bs be the sub-sequence of s
that produces write steps in (C0;s ). Execution E gives rise
to the sequence of register conﬁgurations G E = C0,C1, . . . such that the i-th step of bs
is a write that changes register
conﬁguration Ci−1 to register conﬁguration Ci. For any scan operation s in E, deﬁne index(s) = i, if s occurs in E
between Ci and Ci+1 in G E. For any write operation w in E, deﬁne index(w) = i, if w is the i-th step of bs
. Notice
that the view returned by a scan with index i is equal to Ci. A register conﬁguration C = (V0, . . . ,Vb−1) is consistent if
V0 = ··· = Vb−1 in which case we say V0 is the content of C. Let Ci and C j be register conﬁgurations in the sequence

8

shared: R = R[0, . . . ,b− 1] is an array of multi-writer multi-reader registers, each register is initialized to /0
local: An array r[0, . . . ,b− 1]; pos ∈ {0, . . . ,b− 1} initialized to 0; S initialized to {id};
Algorithm 1: getName()

1 repeat
2
3

4
5

R[pos].write(S)
r[0, . . . ,b− 1] := R .scan()
S := Sb−1
pos := (pos + 1) mod b

i=0 r[i]∪ S

6 until (|S| ≥ b)∨ (r[0] = r[1] = ··· = r[b− 1] = S)
7 if |S| ≤ b− 1 then
8
9 else
10
11 end

return (|S|(|S|− 1))/2 + rank(id,S)
return b(b− 1)/2 + id

Figure 1: (b− 1)-Bounded (k(k + 1)/2)-Adaptive Renaming Using Atomic Scan

G E = C0,C1, . . . such that i ≤ j. Interval[i, j] denotes the sub-sequence of steps in execution E that begins at write
operation w where index(w) = i, and ends immediately after write operation u where index(u) = j. We use n C(R) to
denote the content of register R in conﬁguration C. A local variable x in these algorithms is denoted by xp when it is
used in the method call invoked by process p.

5.1 (b− 1)-Bounded (k(k + 1)/2)-Adaptive Renaming Using Atomic Scan
Fig. 1 presents a wait-free implementation of a one-shot (b− 1)-bounded (k(k + 1)/2)-adaptive renaming algorithm
assuming an atomic scan operation. In Section 5.2, we show how to remove this assumption.
Each process maintains a set of processes, S, that it knows are participating including itself, and alternately executes
write and scan operations. In the write operation, it writes S to the next register after where it last wrote, in cyclic
order through the b registers. After each of its scan operations, it updates S to all the processes it sees in the scan
together with the processes already in its set. The process stops with an assigned name when either its scan shows
exactly its own set, S, in every register, or S has grown to size at least b. If |S| is less than b, its name is based on |S|
and its rank in S, where rank(id,S) = |{i | (i ∈ S)∧ (i ≤ id)}|. If |S| is b or greater, it returns a safe but large name.
Correctness and space complexity.

Since it is clear that the algorithm in Fig. 1 uses b registers, the space complexity will follow immediately after
conﬁrming that it is a correct adaptive renaming algorithm. The correctness of this algorithm relies on the fact that if
any two processes return names based on a set of size s < b, then they have the same set. The main component of the
proof is to establish this fact.
Observation 5.1. For any write operation with value S by process p, p ∈ S.
Lemma 5.2. For any execution E, let Ca be a consistent register conﬁguration with content bS. For any register
conﬁguration D following Ca in E, deﬁne TD = {R ∈ R |bS 6⊆ n D(R)}. Then there exists a one-to-one function fD :
TD → P satisfying, ∀R ∈ TD, fD(R) ∈ n D(R) and fD(R) performs at least one write in the execution interval between
Ca and D.

Proof. Let Ca,Ca+1, . . . be the sequence of register conﬁgurations that arises from E starting at Ca. We prove the
lemma by induction on the indices of this sequence. The base case ℓ = a, is trivially true since set TCa is the empty
set.

9

Suppose that the induction hypothesis is true for ℓ− 1 ≥ a. Let the write step between Cℓ−1 and Cℓ be the operation,
w, by process p, into register bR with value V . Let s be the most recent scan operation by p preceding w if it exists.
If bS ⊆ V , then TCℓ = TCℓ−1 \{bR}. Deﬁne fCℓ (R) = fCℓ−1 (R), ∀R ∈ TCℓ. Since fCℓ−1 satisﬁes the induction hypothesis,
and TCℓ ⊆ TCℓ−1, fCℓ also satisﬁes the induction hypothesis.
Now consider the case bS 6⊆ V . So TCℓ = TCℓ−1 ∪ {bR}. We ﬁrst show that s happens before Ca or w is the ﬁrst
write by p. Suppose, for the purpose of contradiction, that a ≤ index(s) ≤ ℓ− 1. We have ∀R ∈ R , bS 6⊆ n Cindex(s)(R)
since otherwise, by Line 4, bS ⊆ V . Thus |TCindex(s)| = b. By the induction hypothesis, fCindex(s) selects a distinct process
from each register in TCindex(s), implying, by Line 4, that the size of Sp is at least b. Hence p would have stopped
in Line 6 before performing any write operation. Therefore s happens before Ca or w is the ﬁrst write by p, and
consequently any write by p before w happens before Ca. On the other hand, ∀R ∈ TCℓ−1, fCℓ−1(R) performs a write
during Interval[a, ℓ− 1] implying p is not in { fCℓ−1(R) | R ∈ TCℓ−1}. By Observation 5.1, p ∈ V and p performs a write
after Ca. Therefore by deﬁning fCℓ(R) = fCℓ−1(R), ∀R ∈ (TCℓ−1 \{bR}) and fCℓ (bR) = p, the induction hypothesis holds
for ℓ.
Lemma 5.3. For any execution E, let bSp and bSq be the value of Sp and Sq in Line 7 for p and q when they have
completed the repeat loop. If | bSp| = |bSq| < b then bSp = bSq.
Proof. Let Cp and Cq be the consistent register conﬁgurations that resulted in bSp and bSq respectively and assume,
without loss of generality, that Cp precedes Cq in G E. By Line 6, R[0] = ··· = R[b− 1] = bSq in Cq. Thus, either
∀R ∈ R , bSp ⊆ n Cq (R) or ∀R ∈ R , bSp 6⊆ n Cq (R).
For the ﬁrst case, by Line 4, bSp ⊆ bSq and since | bSp| = |bSq|, bSp = bSq. For the latter case, set TCq = {R ∈ R | bSp 6⊆
n Cq (R)} has size b. By Lemma 5.2, there is a distinct process in each register in TCq. So there are at least b distinct
processes in bSq contradicting |bSq| < b.
Lemma 5.4. The names returned by any two distinct processes are distinct.
Proof. Let bSp and bSq be the values of Sp and Sq in Line 7. Without loss of generality, assume that | bSp| ≤|bSq|. If | bSp|≥ b
and |bSq| ≥ b, the names returned by p and q in Line 10 are distinct because p 6= q. If | bSp| < b and |bSq| ≥ b, then, by
Line 8, the name returned by p is at most (b− 1)(b− 2)/2 + (b− 1) = b(b− 1)/2 and, by Line 10, the name returned
by q is bigger than b(b− 1)/2. If | bSp| < b and |bSq| < b, both processes return at Line 8. First suppose ℓ = | bSp| < |bSq|.
Then the name returned by p is at most (ℓ + 1)(ℓ)/2 and the name returned by q is at least (ℓ + 1)(ℓ)/2 + 1. If
| bSp| = |bSq|, by Lemma 5.3, bSp = bSq. Therefore rank(p, bSp) 6= rank(q, bSq). Thus, in all cases the names returned by p
and q are distinct.
Observation 5.5. Set {p} is written by p before any other write of any set V ⊇ {p}.
Lemma 5.6. Let k be the number of participating processes during process p’s getName(). Then, any name returned
by p is in the range {1, . . . , k(k+1)
Proof. By Observation 5.5, ∀q ∈ Sp, q performs at least one write before p returns. Thus, ∀q ∈ Sp, q is a participating
process. Hence, |Sp| ≤ k. If k < b, then |Sp| < b. Therefore, process p returns in Line 8, and the name is in the
range {1, . . . , k(k+1)
}. If k ≥ b, then p returns either in Line 8 or in Line 10. Therefore the name is in the range
{1, . . . , b(b−1)
2 + n}.
In summary, Lemmas 5.4 and 5.6 imply that the algorithm in Fig. 1 is an (b− 1)-bounded (k(k + 1)/2)-adaptive

} if k < b and in the range {1, . . . ,n + b(b−1)

renaming algorithm that uses b registers assuming the availability of the atomic scan operation.

2

} if k ≥ b.

2

2

Step complexity.

We now bound the maximum number of steps (scans and writes) that any process can take during its execution of
getName. Lemma 5.7 establishes the most important piece of the step complexity of the algorithm in Fig. 1. In
this lemma we prove that if there exists a register conﬁguration in which there are at least k registers, each of which

10

contains a set of size at least k, then the number of distinct process names in any subsequent scan is at least k. We
call such a register conﬁguration k-complete, and any set of such registers is a k-full-set. The core idea is that after
a k-complete conﬁguration with k-full-set R ′, every write with set size less than k to a register in R ′ is performed
by a distinct writer. It then follows that the union of the sets appearing in R ′ always will have size at least k. For
the proof, given set of registers R ′ ⊆ R and a register conﬁguration D, we will be interested in those registers in R ′
that contain a set smaller than k, and in the processes that wrote these small sets to these registers. Therefore, deﬁne
r R ′(D,k) = {R ∈ R ′ (cid:12)(cid:12) |n D(R)| < k}. Let writer( j,R) denote the process that performs the most recent write to register
R preceding register conﬁguration C j. For any set of registers R ′, register conﬁguration C j and an integer k, deﬁne
WR ′( j,k) = {writer( j,R) | R ∈ r R ′(C j,k)}. Notice that a register conﬁguration D is k-complete if there exists a set R ′
of k registers where r R ′(D,k) = /0. Furthermore, R ′ is k-full-set at register conﬁguration D.

Lemma 5.7 uses a proof structure that is more elaborate than, but reminiscent of, that of Lemma 5.2.

Lemma 5.7. For any execution E, let Ca be a k-complete register conﬁguration where 0 ≤ k ≤ b− 1 and let R ′ be
a k-full-set of Ca. For any register conﬁguration Ce following Ca in G E, there exists a one-to-one and onto function
gCe : r R ′(Ce,k) → WR ′(e,k) satisfying, ∀R ∈ r R ′(Ce,k), gCe(R) ∈ n Ce(R). Furthermore, each process in WR ′(e,k)
performs at least one write in Interval[a,e].

Proof. Let Ca,Ca+1, . . . be the sequence of all register conﬁgurations starting at Ca. We prove the lemma by induction
on the indices of this sequence. The base case ℓ = a, is trivially true since set r R ′(Ca,k) is the empty set.

Suppose that the induction hypothesis is true for ℓ− 1 ≥ a. Let the write step between Cℓ−1 and Cℓ be the operation,
w, by process q, into register bR with value V . Let s be the most recent scan operation by q preceding w if it exists.
Suppose that bR /∈ R ′. Then r R ′(Cℓ−1,k) = r R ′(Cℓ,k) and WR ′(ℓ− 1,k) = WR ′(ℓ,k), so the induction hypothesis
holds trivially for ℓ by setting gCℓ = gCℓ−1.
Suppose that bR ∈ R ′ and |V| ≥ k. Then r R ′(Cℓ,k) = r R ′(Cℓ−1,k) \ {bR} and WR ′(ℓ,k) = WR ′(ℓ − 1,k) \
{writer(ℓ− 1,bR)}. So the hypothesis holds for ℓ by setting gCℓ = gCℓ−1 for each R ∈ r R ′(Cℓ,k).
Finally, consider the case bR ∈ R ′ and |V| < k. We ﬁrst show that s happens before Ca or w is the ﬁrst write by q. Sup-
pose, for the purpose of contradiction, that s happens after Ca. Then a ≤ index(s) ≤ ℓ− 1. For each R ∈ R ′, we have
|n Cindex(s)(R)| < k since otherwise, by Line 4, |V| ≥ k. Thus |r R ′(Cindex(s),k)| = k. By the induction hypothesis, gCindex(s)
is a bijection, so |r R ′(Cindex(s),k)| =|WR ′(index(s),k)| = k, and ∀R∈ r R ′(Cindex(s),k), gCindex(s)(R)∈ n Cindex(s)(R). There-
fore, by Line 4, the size of Sq, and hence the size of V , is at least k, which is a contradiction.
Therefore s happens before Ca or w is the ﬁrst write by q, and consequently any write by q before w happens
before Ca. On the other hand, by the induction hypothesis, ∀R ∈ r R ′(Cℓ−1,k), writer(ℓ − 1,R) performs a write
during Interval[a, ℓ− 1] implying q is not in WR ′(ℓ− 1,k). We have r R ′(Cℓ,k) = r R ′(Cℓ−1,k)∪{bR} and WR ′(ℓ,k) =
WR ′(ℓ− 1,k)\ writer(ℓ− 1,bR)∪{q}, whether or not bR is in r R ′(Cℓ−1,k). Furthermore, q performs a write after Ca.
Therefore, the induction hypothesis holds for ℓ by deﬁning gCℓ = gCℓ−1 for each R ∈ r R ′(Cℓ,k)\{bR}, and gCℓ(bR) = q.

Lemma 5.8. Let D be a k-complete register conﬁguration. Then for each process p in P , p’s second write after D if
it exists, has a value with size at least k.

Proof. Let w be the second write operation by p after D if it exists. Let s be the most recent scan operation by p
preceding w. Since w is the second write by p, the value returned by s is equal to a register conﬁguration D′ following
D. Let R ′ be the k-full-set of D. If ∃R ∈ R , |n D′ (R)| ≥ k, then by Line 4, the size of Sp at s is at least k. Otherwise, all
registers, and hence all registers in R ′, contain sets of size less than k. Therefore, |r R ′(D′,k)| = k. So, by Lemma 5.7,
|WR ′(index(D′),k)| = k. Thus, again by Line 4, the size of Sp at s is at least k. Hence w has a value with size at least
k.

Lemma 5.9. Let E be an execution whose ﬁrst operation is a write by p and contains the next b scans by p. Further-
more, during E, every write by p has value Q and no write has value Q′ ( Q. Then p either terminates or the size of
Sp increases.

11

Proof. By Lines 2-3, each scan operation is preceded by a write operation. Hence E contains b writes by p. Therefore,
during E, p writes Q to all b registers. Let (V0, . . . ,Vb−1) be the value returned by p’s last scan during E. Because E
does not contain any write with value Q′ ( Q either V0 = ··· = Vb−1 = Q in which case p terminates or ∃i, 0 ≤ i ≤ b−1
such that Vi 6⊆ Q. In the latter case by Line 4, the size of Sp increases.

Lemma 5.10. Let D be a k-complete register conﬁguration where 0 ≤ k ≤ b− 1. Then for each process p in P , p’s
(bk + 2)-nd write after D, if it exists, has a value with size at least k + 1.
Proof. Let w be the second write by p after D. Suppose that p writes Q at w. By Lemma 5.8, |Q| ≥ k. If |Q| ≥ k + 1
or p terminates before writing bk more times, we are done. Therefore, suppose that |Q| = k and p performs bk writes
after w. Then |Q\{p}| = k − 1. By Lemma 5.8, after D, ∀q ∈ Q, q writes a value with size smaller than k at most
once.
Let E be the execution whose ﬁrst operation is w and contains the next bk scan operations by p. Partition E into
disjoint segments, E = (E1, . . . ,Ek), satisfying ∀ℓ, 1 ≤ ℓ ≤ k, the ﬁrst operation in Eℓ is a write operation by p and
Eℓ contains the next b scans by p. Notice that E contains exactly bk write operations by p and since w is the ﬁrst
operation of E, p performs at least one more write after E ends. Since there are at most |Q\{p}| = k− 1 writes after
w that have a value V satisfying V ( Q, there exists an ℓ, 1 ≤ ℓ ≤ k such that all writes during Eℓ have a value that is
not a proper subset of Q. Since p does not terminate during Eℓ, by Lemma 5.9, the size of Sp after Eℓ (hence, after E)
is at least k + 1. Hence, p’s (bk + 2)-nd write after D has a value with size at least k + 1.

Lemma 5.11. For any execution E in which p does not terminate, let O be the set of all scan operations by p during
E. Let Z = {writer(index(s),R) | s ∈ O and R ∈ R }. Then |Z| < b.
Proof. For any scan s ∈ O and any register R, writer(index(s),R) ∈ n Cindex(s)(R). Therefore, by Line 4, for any s ∈ O,
after s, Sp contains writer(index(s),R). Since p does not terminate after s, at s, |Sp| < b. Hence |Z| < b.

Lemma 5.12. Let D be a k-complete register conﬁguration where 0≤ k ≤ b−1. Then for each process p in P , p makes
at most bk + 1 + b( (b−1)(bk+1)
+ 1) write operations before it terminates or a (k + 1)-complete register conﬁguration
is achieved.

b−k

b−k

b−k

b−k
+1), satisfying ∀ℓ, 1 ≤ ℓ ≤ (b−1)(bk+1)

Proof. By Lemma 5.11, p’s (bk +2)-nd write, say w, after D has a value with size at least k +1. Let E be the execution
whose ﬁrst operation is w and contains the next b( (b−1)(bk+1)
+1) scan operations by p. Partition E into segments, E =
+ 1, the ﬁrst operation in Eℓ is a write operation by p and Eℓ
(E1, . . . ,E (b−1)(bk+1)
contains the next b scans by p. Let O be the set of all scan operations by p during E. Let Z = {writer(index(s),R) | s ∈
O and R ∈ R }. Let U be the set of all write operations by processes in Z during E such that ∀u ∈ U, the value
of u has a size smaller than or equal to k. By Lemmas 5.10 and 5.11, |U| ≤ (bk + 1)|Z| ≤ (b − 1)(bk + 1). Let
Uℓ = {u | u ∈ U and u happens during Eℓ}.
By the pigeon whole principle, there exists an ℓ such that |Uℓ| < b− k. Let sℓ be p’s last scan during Eℓ. Since
during Eℓ, p writes a value with size at least k + 1 to all b registers and the number of writes with value smaller than
k + 1 and scanned by p (i.e |Uℓ|), is less than b− k, sℓ returns a view in which at least k + 1 registers have size at least
k + 1. Hence, Cindex(sℓ) is (k + 1)-complete.

Lemma 5.13. No process writes more than 3b4 ln b times.

Proof. By Lemma 5.12, a process can write at most bk + 1 + b( (b−1)(bk+1)
+ 1) times between a k-complete and a
(k + 1)-complete conﬁguration. The initial conﬁguration is 0-complete and an b-complete conﬁguration cannot exist.

b−k

12

Therefore a process can write a most

=

=

<

times before it terminates.

b−1

k=0
b−1

k=0
b−1

k=0
b3
2

(bk + 1 + b) + b(b− 1)
k=1
b2
k − b +

+ b− 1 + b2 + b2

b(cid:229)

(

k=1

k

1
k

) < 3b4 ln b

(cid:0)bk + 1 + b(

(b− 1)(bk + 1)

+ 1)(cid:1)

b− k
(bk + 1 + b) + b(b− 1)

b−1

k=0

b(cid:229)

)

(

bk + 1
b− k
(cid:0) b2 − bk + 1

(cid:1)

5.2 (b− 1)-Bounded (k(k + 1)/2)-Adaptive Renaming Using Registers
We replace the atomic scan in Fig. 1 with a new function, newScan(), and the getName() algorithm also changes
accordingly. The revised renaming algorithm is shown in Fig. 2. In the getName() algorithm, processes augment the
values they write to each register with their ids and sequence numbers in order to guarantee the uniqueness of the value
of each write. This prevents the ABA problem. Each register R ∈ R stores an ordered triple (set,id,seqNumber).
During a newScan() operation by process p, p performs a collect(R ) in Line 18, by reading R[0] through
R[b−1] consecutively and returns a collect. After each collect(R ), p updates its set S from this collect. It repeatedly
gets a collect until either the size of set S becomes at least b or it obtains two identical consecutive collects and returns
this collect. If newScan() terminates at Line 24, then the returned collect is equivalent to the returned value of a
linearizable implementation of a scan [21, 26, 25, 14, 15]. Hence all the proofs in Section 5.1 hold when newScan()
terminates at Line 24. So to establish the correctness, we need to prove that when a process p returns in Line 21, in
fact more than b− 1 processes are participating, hence the name returned by p’s getName() is valid. This is shown in
Lemma 5.14. In Lemma 5.13, we showed that the number of writes by each process is bounded. Since the sequence
number seqNumber, cannot get larger than the number of write operations by each process, the size of each register is
also bounded. Therefore, after Lemma 5.14 it will remain to prove that the getName() algorithm in Fig. 2 is wait-free.
This will be established in Lemmas 5.15 through 5.17, by bounding the number of steps of each newScan() operation.
For any read operation o of register R, deﬁne writeOp(o) to be the most recent write operation to R preceding o if
it exists and ⊥ otherwise. For any write operation w, let performer(w) denote the process that performs w. For any
set of write operations W , let Z(W ) = {performer(w) | w ∈ W}.
Lemma 5.14. Let k be the number of participating processes during process p’s getName(). If a newScan() opera-
tion by p returns in Line 21, then k ≥ b.
Proof. Let bSp be the value of Sp when p’s getName() returns. Since p’s newScan() operation returns in Line 21,
| bSp| ≥ b. By Observation 5.5, ∀q ∈ bSp, q performs at least one write before p returns. Thus, ∀q ∈ bSp, q has invoked a
getName() before p returns. Therefore, k ≥ | bSp| ≥ b.
Lemma 5.15. Let E be an execution such that any step by process p during E is part of a single newScan() operation.
If E contains at least 3b reads by p and does not contain any write operations, then p’s newScan() terminates during
E.

Proof. Since E contains no write operation, every 3b reads by p must contain two complete identical collects. Hence,
p must terminate due to Line 23.

13

(cid:229)
(cid:229)
(cid:229)
(cid:229)
shared: R[0 . . . b− 1] is an array of multi-writer multi-reader registers, each register is initialized to (/0,0,0);
local: r[0, . . . ,b− 1]; pos ∈ {0, . . . ,b− 1} initialized to 0; seqNumber is a non-negative integer initialized to 0; S is
initialized to {id}; largeSet is a boolean;
Algorithm 2: getName()

seqNumber = seqNumber + 1
R[pos].write(S,id,seqNumber)
(largeSet, r[0, . . . ,b− 1]) := R .newScan(S)
if largeSet then

1 repeat
2
3
4
5
6
7

8
9

return b(b− 1)/2 + id

end
S := Sb−1
pos := (pos + 1) mod b

i=0 r[i].set

10 until (|S| ≥ b)∨ (r[0].set = r[1].set = ··· = r[b− 1].set = S)
11 if |S| ≤ b− 1 then
12
13 else
14
15 end

return (|S|(|S|− 1))/2 + rank(id,S)
return b(b− 1)/2 + id

local:

a[0 . . . b − 1];
Algorithm 3: newScan(S)

a′[0 . . . b − 1]

each

element

is

initialized

to

(/0,0,0);

16 repeat
17
18

a := a′
a′ :=collect(R )
S := Sb−1
i=0 a′[i].set ∪ S
if |S| > b− 1 then
return (True, a′)
end

19
20
21
22
23 until a = a′
24 return (False, a′)

Figure 2: (b− 1)-Bounded (k(k + 1)/2)-Adaptive Renaming Using Registers

14

Lemma 5.16. Let E be an execution such that any step by process p during E is part of a single newScan() operation,
s. Let O be the set of all reads by p during E and W = {writeOp(o) | o ∈ O}\{⊥}. If |Z(W )| ≥ b, then s contains
at most 2b read operations after E ends.

Proof. If p performs fewer than 2b read operations after E ends, we are done. Let E′ be an execution which starts
after E ends and contains 2b reads by p. Since every 2b reads by p must contain a complete collect, after p’s complete
collect during E′, by Line 19, Sp includes all processes in Z(W ). Hence, after p’s complete collect during E′,
|Sp| ≥ |Z(W )| ≥ b. Therefore, by Line 20, s must terminate.
Lemma 5.17. No newScan() operation contains more than 10b6 ln b reads.

Proof. By way of contradiction, let E be an execution in which process p performs a single newScan() s, and it
contains more than 10b6 ln b reads. Let E′ be a preﬁx of E that contains 9b6 lnb reads by p. Partition E′ into disjoint
segments, E′ = (E1, . . . ,E3b5 ln b), satisfying ∀ℓ, 1 ≤ ℓ ≤ 3b5 ln b, Eℓ contains 3b reads by p. Let O be the set of all read
operations by p during E′ and W = {writeOp(o) | o ∈ O}\{⊥}.
Suppose there is an ℓ such that Eℓ contains no write operation in W . This implies that Eℓ contains no write operation.
Therefore by Lemma 5.15, p terminates s during Eℓ.

Otherwise, each Eℓ contains at least one write in W . Hence |W| ≥ 3b5 ln b. Since by Lemma 5.13, each process p
performs at most 3b4 lnb writes, |Z(W )| ≥ b. Therefore, by Lemma 5.16, s contains at most 2b reads after E′ ends.
Hence E contains at most 9b6 ln b + 2b < 10b6 ln b reads by p.

Lemma 5.18. No process performs more than 31b10 ln2 b shared steps (read or write).

Proof. By Lemma 5.13, each process p performs at most 3b4 ln b writes. Hence, p performs at most 3b4 ln b
newScan() operations. By Lemma 5.17, p performs at most 10b6 ln b reads in each newScan() operation. Hence
p performs at most 3b4 ln b + (3b4 ln b)(10b6 lnb) ≤ 31b10 ln2 b shared steps.
Theorem 5.19. For any b ≥ 2, there is a wait-free one-shot (b− 1)-bounded (k(k + 1)/2)-adaptive renaming al-
gorithm implemented from b bounded registers. Additionally, when k ≥ b, the returned names are in the range
{1, . . . ,n + b(b−1)
Setting b = ⌈√n⌉ + 1, we have a wait-free one-shot ⌈√n⌉-bounded (k(k + 1)/2)-adaptive renaming algorithm from
⌈√n⌉ + 1 bounded registers. This implies that the algorithm returns names in the range {1, . . . , (k(k + 1)/2)} when
k ≤ ⌈√n⌉, and returns names in the range {1, . . . ,n + ⌈√n⌉(⌈√n⌉+1)
} when k ≥ ⌈√n⌉ + 1. Note that when k ≥ ⌈√n⌉ + 1,
n + ⌈√n⌉(⌈√n⌉+1)
Corollary 5.1. There is a wait-free one-shot (3k2)/2)-adaptive renaming algorithm implemented from ⌈√n⌉ + 1

2 . Hence, ∀k ∈ {1, . . . ,n}, the algorithm returns names in the range {1, . . . , (3k2)/2}.

≤ k2 + k2

2

}.

2

bounded registers.

2

6 Obstruction-Free (b− 1)-Bounded k-Adaptive Renaming
Fig. 3 presents pseudo-code for an obstruction-free one-shot (b− 1)-bounded k-adaptive renaming algorithm from b
registers assuming an atomic scan operation. In Theorem 6.7, we show how to remove this assumption by adding an
extra register.

Algorithm Description.

A naming set is a set of ordered pairs where each pair is a process id and a proposed name with the property that no
process id occurs in more than one pair in the set. Let S be a naming set. In our algorithm and the analysis we use the
following notation:

• Procs(S) = {x | (x,y) ∈ S},
• Names(S) = {y | (x,y) ∈ S},
• if (p,n) ∈ S, then name(p,S) is n; otherwise it is undeﬁned.

15

shared: R = R[1, . . . ,b] is an array of multi-writer multi-reader registers, each register is initialized to (/0,⊥,1)
local: r[1, . . . ,b]; pos ∈ {1, . . . ,b} initialized to 1; S initialized to /0; proposed ∈ N initialized to 1.
Algorithm 4: getName()

1 repeat
2
3
4
5
6
7
8
9
10

R[pos].write(S,id,proposed)
r[1, . . . ,b] := R .scan()
S := Update(S,r[1, . . . ,b])
proposed = min{i ∈ N | i /∈ Names(S)}
if ∃i, s.t. (r[i].writer = id)∧ (r[i] 6= (S,id,proposed)) then
else if ∃ j, s.t. r[ j] 6= (S,id,proposed) then
end

pos := max{i | (r[i].writer = id)∧ (r[i] 6= (S,id,proposed))}
pos := j

11 until (|S| + 1 ≥ b)∨ (r[1] = r[2] = ··· = r[b] = (S,id,proposed))
12 if |S| + 1 ≤ b− 1 then
return proposed
13
14 else
15
16 end

return b− 1 + id

Algorithm 5: Update()
17 Snew = /0
18 for all w ∈ {r[i].writer | 1 ≤ i ≤ b}\{id,⊥} do
Let j ∈ {1, . . . ,b} such that r[ j].writer = w
namew := r[ j].proposal
Snew := Snew ∪{(w,namew)}

19
20
21
22 end
23 for ∀p ∈ Procs(Sb

i=1 r[i].set)\ (Procs(Snew)∪{id}) do

if ∃i, j, (i < j)∧ (r[i].writer = r[ j].writer)∧ (p ∈ Procs(r[ j].set)) then
else

namep := name(p,r[ j].set)

24
25
26
27
28

Let j ∈ {1, . . . ,b} s.t. p ∈ Procs(r[ j].set)
namep := name(p,r[ j].set)

end
Snew := Snew ∪{(p,namep)}

29
30
31 end
32 for ∀p ∈ Procs(S)\ (Procs(Snew)∪{id}) do
33
34 end
35 return Snew

Snew := Snew ∪{(p,name(p,S))}

Figure 3: (b− 1)-Bounded k-Adaptive Renaming

16

The algorithm in Fig. 3 employ a set R = {R[1], . . . ,R[b]} of shared atomic registers. Each register R stores an ordered
triple (set,writer,proposal) where set is a naming set, writer is a process id or ⊥ (initially) and proposal is a positive
integer less than or equal b− 1. Each process p maintains a naming set Sp and alternates between write and scan
operations until it terminates with a name for itself. Each scan returns a view, which is an atomic snapshot of the
content of all registers. Each write by p writes a triple consisting of its set Sp, its id p, and its proposed name namep,
to some register R[ j]. Process p uses its last view and its previous value of Sp to determine the new value of Sp, namep
and j.

Function Update describes how p constructs Sp in three steps. In the ﬁrst step (Lines 18-22), p creates a naming set
based only on the writers and proposals of each register in its view. If the view contains a writer with more than one
proposal, p chooses one pair arbitrarily. In the second step (Lines 23-31), p augments its naming set with additional
pairs for processes that are not writers in its view but occur in the union of all naming sets in its view. The main issue
occurs when there is some process that is paired with more than one name from two or more naming sets in different
registers. In this case, if there are two such registers with the same writer then, p chooses the pair which occurs in the
register with bigger index. Otherwise, p picks one pair arbitrarily. Finally (Lines 32-34), p adds any pair (q,nq) such
that q exists in the previous version of Sp and is not yet added. Observe that Sp is a naming set and p /∈ Procs(Sp).
other process in Sp.

In Line 5 p chooses its proposal for its own name, namep, to be the smallest integer that is not paired with some

Lines 6-10 describe how p sets j. If there is any register in p’s preceeding view with writer component equal to p
but with content different from (Sp, p,namep) then p writes to register R[ j] where j is the biggest index amongst these
registers. Otherwise it writes to some register whose content is different than (Sp, p,namep). Process p continues
until either in some scan, all registers contain the same information that p has written or |Sp| is larger than or equal
b− 1. In the ﬁrst case p returns namep and in the second case it returns b + p− 1.
Proof of Correctness
Overview of proof Once a process p terminates with name np ≤ b− 1, the pair (writer, proposal) of every register
is equal to (p,np). The core idea is that after p terminates, every register that is overwritten with the wrong name for
p or no name for p, has a distinct writer component. Therefore, if a subsequent scan by another process, say q, does
not include the correct name for p, the set of processes in that scan is large and q terminates with a name larger than
or equal b. If the set of processes in the scan is not large, then there is some writer that is in the writer component of
at least 2 registers. In that case, we prove that for any such pair of registers with the same writer, the correct name for
p is in the register with the larger index. In this way, the algorithm ensures that process q keeps (p,np) in its naming
set, and discards incorrect names for p.

For our proof, we use the notion and terminology for register conﬁguration, consistent conﬁguration, index(op) of
operation op, interval and content of register R in conﬁguration C, n C(R), as deﬁned in Section 5. Let p be a process
that has terminated and returned name np. Deﬁne last p to be the last scan by p. For any register conﬁguration D
following register conﬁguration Cindex(last p), deﬁne a set of registers Fp(D) = {R ∈ R | (n D(R).writer 6= p)∧ ((p,np) /∈
n D(R).set)} and a set of processes Op(D) = SR∈Fp(D){n D(R).writer}.
Lemma 6.1. Let E be any execution starting in the initial conﬁguration and ending in conﬁguration C. If there are
two integers i and j such that i < j, n C(R[i]).writer = n C(R[ j]).writer = p and n C(R[i]) 6= n C(R[ j]), then the last write
to R[i] happens before the last write to R[ j] and both are by the same process.

Proof. By Line 2, the writer segment of each register indicates the id of the process which writes that value. Hence,
n C(R[i]) and n C(R[ j]) are both written by the same process p. Let wi and w j be the most recent writes to R[i] and
R[ j] preceding C, respectively. Thus, value of wi (respectively w j) is n C(R[i]) (respectively n C(R[ j])). By way of
contradiction assume that w j happens before wi. Let si be the most recent scan operation by p before wi. Hence si
happens after w j and before wi. Since w j is the most recent write to R[ j] preceding si, n Cindex(si)(R[ j]) = n C(R[ j]). Let
bSp and \proposed p be the value of Sp and proposed p at wi respectively. Then ( bSp, p, \proposed p) = n C(R[i]). Therefore,
when p executed Line 6 preceding wi and after si, bSp and \proposed p are values of Sp and proposed p respectively.
Let br j be the value of r[ j] at si. Thus br j = n Cindex(si )(R[ j]). Furthermore, br j is the value of r[ j], when p executes

17

Line 6 after si and preceding wi. Therefore at the execution of Line 6 after si and preceding wi, (Sp, p,proposed p) =
( bSp, p, \proposed p) = n C(R[i]) 6= n C(R[ j]) = n Cindex(si)(R[ j]) = br j = r[ j] and r[ j].id = br j.id = p. Thus, Line 6 evaluates

to true. Since j > i, by Line 7, p does not write into R[i] before writing into R[ j].

Informally, Lemma 6.2 says that every register that contains an incorrect name for p after a consistent conﬁguration

containing the correct name for p has a distinct writer component.
Lemma 6.2. Consider an execution E in which process p’s getName() call returns name np ≤ b− 1. Then for any
register conﬁguration Ce where e ≥ index(last p),
i) |Fp(Ce)| = |Op(Ce)|;
ii) ∀q ∈ Op(Ce), q performs a write in Interval[index(last p),e]; and
iii) for any write operation o by any process q during Interval[index(last p),e], let v be the value of o. If o is not q’s

ﬁrst write during Interval[index(last p),e], then (p,np) ∈ v.set.

Proof. Let Cindex(last p),Cindex(last p)+1, . . . be the sequence of all register conﬁgurations starting at Cindex(last p). We prove
the lemma by induction on the indices of this sequence. Let bSp be the value of Sp at last p. For the base case
ℓ = index(last p), since np ≤ b − 1, p returns in Line 13. Therefore the condition r[1] = ··· = r[b] = ( bSp, p,np)
held when p last executed Line 11. Hence, condition R[1] = ··· = R[b] = ( bSp, p,np) held at Cindex(last p). Therefore the
induction hypothesis (i) and (ii) hold for the base case ℓ = index(last p) because Fp(Cindex(last p)) = Op(Cindex(last p)) = /0.
Furthermore, since Interval[index(last p),index(last p)] contains only one write, (iii) is true for the base case.

Suppose that the lemma holds for ℓ − 1 ≥ index(last p). Let w be the write that changes register conﬁguration
Cℓ−1 to Cℓ, and let x be the process that performs w. Then clearly x 6= p, since p has performed its last write before
Cindex(last p). Suppose w writes value (bSx,x,nx) into register R, and let s be x’s scan operation that precedes w if it exists.
Suppose (p,np) ∈ bSx. Let Fp(Cℓ) = Fp(Cℓ−1)\{R} and Op(Cℓ) = Op(Cℓ−1)\{n Cℓ−1 (R).writer}. If R ∈ Fp(Cℓ−1),
then by deﬁnition, n Cℓ−1(R).writer ∈ Op(Cℓ−1) and if R /∈ Fp(Cℓ−1), then by deﬁnition, n Cℓ−1(R).writer /∈ Op(Cℓ−1).
Since |Fp(Cℓ−1)| = |Op(Cℓ−1)|, |Fp(Cℓ)| = |Op(Cℓ)|. Therefore (i) is true. Since Op(Cℓ) ⊆ Op(Cℓ−1), (ii) holds. Since
(p,np) ∈ bSx, (iii) is true.
Now consider the case (p,np) /∈ bSx. We ﬁrst show that Cindex(s) precedes Cindex(last p) in G E or w is the ﬁrst write
by x. Suppose, for the purpose of contradiction, that index(last p) ≤ index(s) ≤ ℓ − 1. First consider the case that
there exists an i such that n Cindex(s)(R[i]).writer = p. Since at Cindex(lastp) all registers contain ( bSp, p,np) and p does not
write after lastp, n Cindex(s)(R[i]).proposal = np. Hence by Line 21, (p,np) ∈ bSx. Otherwise suppose that in Cindex(s),
there are at least two distinct registers whose writer are the same process and not p. Then, choose any indices i, j
such that i < j and n Cindex(s)(R[i]).writer = n Cindex(s)(R[ j]).writer = u 6= p. Let w1 and w2 be the most recent writes
to R[i] and R[ j] preceding Cindex(s). Hence w1 has value n Cindex(s)(R[i]) and w2 has value n Cindex(s)(R[ j]) and they both
are performed by process u. Furthermore, since at Cindex(lastp) all registers contain ( bSp, p,np), w1 and w2 occur in
Interval[index(last p),index(s)]. Suppose n Cindex(s)(R[i]) 6= n Cindex(s)(R[ j]), then by Lemma 6.1, w1 precedes w2 in E
and by the induction hypothesis (iii), (p,np) ∈ n Cindex(s)(R[ j]).set. Otherwise suppose n Cindex(s)(R[i]) = n Cindex(s)(R[ j])
then again by induction hypothesis (iii), (p,np) ∈ n Cindex(s)(R[ j]).set. In either case, when x performs Line 24 after
s and preceding w, this line evaluates to true. Hence by Line 25, (p,np) ∈ bSx. Finally, if ∀i, j, 1 ≤ i, j ≤ b and i 6=
j, n Cindex(s)(R[i]).writer 6= n Cindex(s)(R[ j]).writer, then by induction hypothesis (i), |Fp(Cindex(s))| = |Op(Cindex(s))| = b.
Therefore, by the for-loop (Lines 18-22), |bSx| + 1 ≥ |Op(Cindex(s))| = b. Hence, by Line ??, the presumed write w by
x cannot happen. Thus, in all cases, we have established that if (p,np) /∈ bSx then Cindex(s) precedes Cindex(last p) in G E or
w is the ﬁrst write by x.
Consequently, any write by x before w happens before Cindex(last p). On the other hand, by the induction hypothesis,
for all q ∈ Op(Cℓ−1), q performs a write during Interval[index(last p), ℓ− 1] implying x is not in Op(Cℓ−1). Thus by
deﬁning Fp(Cℓ) = Fp(Cℓ−1)∪{R} and Op(Cℓ) = Op(Cℓ−1)\{n Cℓ−1 (R).writer}∪{x}, the induction hypothesis (i) and
(ii) hold for ℓ. Since the most recent operation before w by x happens before Cindex(last p), x performs only one write
operation in Interval[index(last p), ℓ]. Therefore, (iii) holds for ℓ.

18

Lemma 6.3. Let p and q be two distinct processes that have terminated in execution E and returned names np and
nq respectively. Suppose that Cindex(last p) precedes Cindex(lastq) in G E. If np,nq ≤ b− 1, then |Fp(Cindex(lastq))| = 0.
Proof. Since nq ≤ b− 1, q returns in Line 13. Hence Cindex(lastq) is consistent with content (Sq,q,nq). Therefore,
|Fp(Cindex(lastq))| ∈ {0,b}. By Lemma 6.2, |Fp(Cindex(lastq))| = |Op(Cindex(lastq))|. Since in Cindex(lastq), R.writer = q for
all R ∈ R , |Op(Cindex(lastq))| ≤ 1, and thus |Fp(Cindex(lastq))| ≤ 1. Therefore |Fp(Cindex(lastq))| = 0.

Lemma 6.4. The names returned by any two distinct processes are distinct.
Proof. For any two distinct processes p and q, let np and nq be the names returned by p and q, respectively. Let bSp
(respectively, bSq) be the value of Sp (respectively, Sq) when p (respectively, q) executes Line 12. If | bSp|,|bSq| ≥ b− 1,
the names returned by p and q in Line 15 are distinct because p 6= q.
Consider the case | bSp| ≤ b − 2 and |bSq| ≥ b − 1. Process p returns np in Line 13. Since |Names(Sp)| ≤ |Sp|,
by Line 5, np must be smaller than or equal to b − 1. Furthermore the name returned by q in Line 15 is larger
than or equal b. The case |bSq| ≤ b− 2 and | bSp| ≥ b− 1 is true by symmetry. Consider the case | bSp|,|bSq| ≤ b− 2
implying np,nq ≤ b− 1. Without loss of generality assume that Cindex(last p) precedes Cindex(lastq) in G E. By Lemma 6.3,
|Fp(Cindex(lastq))| = 0. Since ∀R ∈ R , n Cindex(lastq)(R).writer = q 6= p, (p,np) ∈ n Cindex(lastq)(R).set. Thus by Line 23,
(p,np) ∈ bSq. Therefore by Line 5, proposedq 6= np.

Observation 6.5. Let bSp be the value of Sp created by Update in Line 5 following p’s scan operation scanp in Line 3.
Then ∀q ∈ Procs( bSp), q performs at least one write before scanp.
Lemma 6.6. Let k be the number of participating processes during process p’s getName(). Then, the name returned
by p, is in the range {1, . . . ,k}, if k ≤ b− 1 and in the range {1, . . . ,n + b− 1}, if k ≥ b.
Proof. Let bSp be the value of Sp when p executes Line 4 for the last time and np be the name returned by p. By Obser-
vation 6.5, ∀q ∈ Procs( bSp), q performs at least one write before p returns. Thus, ∀q ∈ Procs( bSp), q is a participating
process. Hence, | bSp| + 1 ≤ k.
If k ≤ b − 1, process p returns in Line 13. By deﬁnition, |Names( bSp)| ≤ | bSp| ≤ k − 1. Therefore by Line 5,
np ≤ |Names( bSp)| + 1 ≤ k.
If k ≥ b, then p returns either in Line 13 or in Line 15. Therefore the name is in the range {1, . . . ,b + n− 1}.

Theorem 6.7. For any b≥ 2 there is an obstruction-free (b−1)-bounded k-adaptive renaming algorithm implemented
from b + 1 bounded registers such that when k ≥ b the returned names are in the range {1, . . . ,n + b− 1}.
Proof. There is an obstruction-free implementation of b-component snapshot objects from b + 1 bounded regis-
ters [22]. Since our algorithm in Fig. 3 is deterministic we can replace the atomic scan registers with a linearizable
scan. By Lemma 6.6 and Lemma 6.4, the algorithm solves (b− 1)-bounded k-adaptive renaming. Thus, it sufﬁces to
prove that the algorithm is obstruction-free.
If p runs alone then the value of Sp computed in Line 4 and proposed p computed in Line 5 remain the same.
Therefore after b write operations all registers contain (Sp, p,proposed p). Therefore, in the b-th iteration of the
repeat-until loop (Line 11) evaluates to true and p stops.

Let f : {1, . . . ,n} → N be a non-decreasing function where, ∀k ∈ {1, . . . ,n},

f (k) ≥ k and f (1) ≤ n − 1. Let
d′ = min{n,x | f (x) ≥ 2n}. Hence, d′ ≤ n. Setting b = d′, we have an obstruction-free one-shot d′-bounded k-adaptive
renaming algorithm from d′ + 1 registers. This implies that the algorithm returns names in the range {1, . . . ,k} when
k ≤ d′ − 1, and returns names in the range {1, . . . ,n + d′ − 1} when k ≥ d′. Note that ∀k ∈ {1, . . . ,d′ − 1}, k ≤ f (k).
Furthermore, when k ≥ d′, n + d′ − 1 < 2n ≤ f (d′). Hence, ∀k ∈ {1, . . . ,n}, the algorithm returns names in the range
{1, . . . , f (k)}.

19

Corollary 6.1. There is an obstruction-free one-shot
min{n,x | f (x) ≥ 2n} + 1 bounded registers.

7 Observations and Open Problems

f -adaptive renaming algorithm implemented from

f : {1, . . . ,n} → N be a non-decreasing function where, ∀k ∈ {1, . . . ,n},

Let
f (k) ≥ k and f (1) ≤ n − 1. Let
=. max{x |
f (x) ≤ n − 1}. We proved a lower bound of +. 1 for non-deterministic solo-terminating long-lived f -
adaptive renaming. Furthermore, for any integer constant 0 ≤ c ≤ n, we showed a lower bound of ⌊ 2(n−c)
c+2 ⌋ for
non-deterministic solo-terminating one-shot (k + c)-adaptive renaming. This implies a tight space bound of n for both
one-shot and long-lived tight renaming. We also presented an obstruction-free one-shot f -adaptive algorithm from
min{n,x | f (x) ≥ 2n} + 1 registers.
An obvious solution for any obstruction-free long-lived or one-shot f -adaptive renaming is as follows. A set Q ⊆ P
of ⌊ f (1)⌋− 1 processes always return names in the range {1, . . . ,max(⌊ f (1)⌋− 1,1)} without taking any steps. In
any (P\Q)-solo execution, process in P\Q using universal construction, get names in the range {⌊ f (1)⌋, . . . ,k +
⌊ f (1)⌋− 1}. Universal construction for |P\Q| processes requires |P|−|Q| = n−⌊ f (1)⌋ + 1 registers. Observe that
this is a tight upper bound for obstruction-free long-lived (k + c)-adaptive renaming. One of the most noticeable open
problems is whether implementing one-shot f -adaptive renaming requires asymptotically less space than long-lived
f -adaptive renaming.
We designed a wait-free one-shot (b − 1)-bounded (k(k + 1)/2)-adaptive renaming algorithm from b bounded
registers, and established that this algorithm has a polynomial step complexity.
It appears that if we modify the
newScan() function of our algorithm, so that each process returns when the set of all processes know to it grows even
by one, the step complexity would reduce considerably. However this change would require much more elaborate
and challenging proofs because the values returned by newScan() would not be equivalent to values returned by a
linearizable scan.

For some systems, it seems reasonable to have the register space, as well as the name space, adapt to the actual
number of participants. The one-shot lower bound can also be modiﬁed to express the actual register use as a function
of k. On the other hand, the one-shot algorithms in this paper require a ﬁxed number of registers regardless of the
number of participants.

References

[1] Y. Afek and M. Merritt. Fast, wait-free (2k-1)-renaming. In Proc. of 18th PODC, pages 105–112. Journal of the

ACM, 1999.

[2] D. Alistarh, J. Aspnes, K. Censor-Hillel, S. Gilbert, and M. Zadimoghaddam. Optimal-time adaptive strong

renaming, with applications to counting. In Proc. of 30th PODC, pages 239–248, 2011.

[3] D. Alistarh, J. Aspnes, S. Gilbert, and R. Guerraoui. The complexity of renaming. In Proc. of 52nd FOCS, pages

718–727, 2011.

[4] D. Alistarh, H. Attiya, S. Gilbert, A. Giurgiu, and R. Guerraoui. Fast randomized test-and-set and renaming. In

Proc. of 24th DISC, pages 94–108, 2010.

[5] H. Attiya, A. Bar-Noy, D. Dolev, D. Peleg, and R. Reischuk. Renaming in an asynchronous environment.

Journal of the ACM, 37(3):524–548, 1990.

[6] H. Attiya, F. Fich, and Y. Kaplan. Lower bounds for adaptive collect and related objects. In Proc. of 23rd PODC,

pages 60–69, 2004.

[7] H. Attiya and A. Paz. Counting-based impossibility proofs for renaming and set agreement. In Proc. of 26th

DISC, pages 356–370, 2012.

20

[8] H. Attiya and J. Welch. Distributed Computing: Fundamentals, Simulations and Advanced Topics. John Wiley

Interscience, 2004.

[9] E. Borowsky and E. Gafni. Generalized ﬂp impossibility result for t-resilient asynchronous computations. In

Proc. of 25th ACM STOC, pages 91–100, 1993.

[10] A. Brodsky, F. Ellen, and P. Woelfel. Fully-adaptive algorithms for long-lived renaming. Journal of Distributed

Computing, 24(2):119–134, 2011.

[11] J. Burns and N. Lynch. Bounds on shared memory for mutual exclusion. Journal of Information and Computa-

tion, 107(2):171–184, 1993.

[12] J. Burns and G. Peterson. The ambiguity of choosing. In Proc. of 8th PODC, PODC ’89, pages 145–157. Journal

of the ACM, 1989.

[13] A. Casta˜neda and S. Rajsbaum. New combinatorial topology upper and lower bounds for renaming. In Proc. of

27th PODC, pages 295–304, 2008.

[14] Danny Dolev and Nir Shavit. Bounded concurrent time-stamping. SIAM Journal on Computing, 26(2):418–455,

1997.

[15] Cynthia Dwork and Orli Waarts. Simple and efﬁcient bounded concurrent timestamping and the traceable use

abstraction. Journal of the ACM, 46(5):633–666, 1999.

[16] W. Eberly, L. Higham, and J. Warpechowska-Gruca. Counting-based impossibility proofs for renaming and set

agreement. In Proc. of 26th DISC, pages 149–160, 1998.

[17] F. Ellen and P. Woelfel. An optimal implementation of fetch-and-increment.

In Proc. of 27th DISC, pages

284–298, 2013.

[18] F. Fich, M. Herlihy, and N. Shavit. On the space complexity of randomized synchronization. Journal of the

ACM, pages 843–862, 1998.

[19] F. Fich and E. Ruppert. Hundreds of impossibility results for distributed computing. Distributed Computing,

16(2-3):121–163, 2003.

[20] E. Gafni. Read-write reductions. In Proceedings of the 8th International Conference on Distributed Computing

and Networking, pages 349–354, 2006.

[21] Rainer Gawlick, Nancy A. Lynch, and Nir Shavit. Concurrent timestamping made simple. In 1st Israel Sympo-

sium on Theory of Computing Systems (ISTCS), pages 171–183, 1992.

[22] G. Giakkoupis, M. Helmi, L. Higham, and P. Woelfel. An O(sqrt n) space bound for obstruction-free leader

election. In Proc. of 31st DISC, pages 46–60, 2013.

[23] M. Helmi, L. Higham, E. Pacheco, and P. Woelfel. The space complexity of long-lived and one-shot timestamp

implementations. Journal of the ACM, 61(1):7–27, 2014.

[24] M. Herlihy and N. Shavit. The topological structure of asynchronous computability. Journal of the ACM,

46(6):858–923, 1999.

[25] Amos Israeli and Ming Li. Bounded time-stamps. Distributed Computing, 6(4):205–209, 1993.

[26] Amos Israeli and Meir Pinhasov. A concurrent time-stamp scheme which is linear in time and space.

In

Distributed Algorithms, 6th International Workshop (WDAG), pages 95–109, 1992.

[27] N. Lynch. Distributed Algorithms. Morgan Kaufmann, 1996.

21

[28] M. Moir and J. Garay. Fast, long-lived renaming improved and simpliﬁed. In Procedeeding of the 10th Interna-

tional Workshop on Distributed Algorithms (WDAG), pages 287–303, 1996.

[29] A. Panconesi, M. Papatriantaﬁlou, P. Tsigas, and P. Vitnyi. Randomized naming using wait-free shared variables.

Journal of Distributed Computing, 11:113–124, 1998.

22

