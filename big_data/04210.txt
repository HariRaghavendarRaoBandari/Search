6
1
0
2

 
r
a

 

M
5
1

 
 
]

G
C
.
s
c
[
 
 

2
v
0
1
2
4
0

.

3
0
6
1
:
v
i
X
r
a

The Runaway Rectangle Escape Problem

Aniket Basu Roy∗

Sathish Govindarajan∗

Anil Maheshwari†

Neeldhara Misra‡

Subhas C Nandy§

Shreyas Shetty¶

March 16, 2016

Abstract

Motivated by the applications of routing in PCB buses, the Rect-
angle Escape Problem was recently introduced and studied. In this
problem, we are given a set of rectangles S in a rectangular region R, and
we would like to extend these rectangles to one of the four sides of R.
Deﬁne the density of a point p in R as the number of extended rectangles
that contain p. The question is then to ﬁnd an extension with the smallest
maximum density.

We consider the problem of maximizing the number of rectangles that
can be extended when the maximum density allowed is at most d. It is
known that this problem is polynomially solvable for d = 1, and NP-hard
for any d ≥ 2. We consider approximation and exact algorithms for ﬁxed
values of d. We also show that a very special case of this problem, when
all the rectangles are unit squares from a grid, continues to be NP-hard
for d = 2.

1 Introduction

The Rectangle Escape Problem was introduced in [16], and was further
explored in [5]. In its original formulation, the problem is the following. Let
S be a set of rectangles in a rectangular region R. The goal is to extend these

∗Department of Computer Science and Automation,

Indian Institute of Science,

aniket.basu|gsat@csa.iisc.ernet.in

†School of Computer Science, Carleton University, anil@scs.carleton.ca
‡Indian Institute of Technology, Gandhinagar, neeldhara.m@iitgn.ac.in
§Advanced Computing and Microelectronics Unit, Indian Statistical Institute, Kolkata,

nandysc@isical.ac.in

¶Department of Computer Science and Engineering, Indian Institute of Technology,

Madras, shshett@cse.iitm.ac.in

A preliminary version of this work appeared in the Proceedings of the 26th Canadian

Conference on Computational Geometry, 2014 [19].

1

rectangles to one of the four sides of R while ensuring that the maximum number
of overlaps is minimized. In particular, deﬁne the density of a point p in R as
the number of extended rectangles that contain p. The question is then to ﬁnd
an extension with the smallest maximum density.

The problem ﬁnds its motivation in a closely related escape routing problem
on the bus levels in PCBs. A detailed exposition of how the formulation above
captures the essence of the bus-routing problem is provided in [5].

It turns out, by the combined results in [16, 5], that this question is in-
tractable — indeed, it is NP-hard to determine if all rectangles can be extended
with density at most d for any ﬁxed d ≥ 2 (the result was known for d ≥ 3 in [16]
and was established for d = 2 in [5]), even when the given set of rectangles are
disjoint to begin with. However, the case when d = 1 is solvable in polynomial
time — the ﬁrst proposed algorithm from [15] had a running time of O(n6). Sub-
sequently, Assadi et al. demonstrate a dynamic programming approach with an
improved running time of O(n4) in [5]. The recursive formulations in the DP
involve ﬁnding the maximum number of rectangles that can be routed in a given
subset of directions while being completely disjoint in their extended state. For
the problem of optimizing the density, a factor-4 approximation is known in
general (by standard rounding techniques), and a PTAS can be obtained on
the assumption that the optimal density is high. We refer the readers to [5] for
details.

In certain scenarios, the density of any point p in R cannot exceed a threshold
value d, which is ﬁxed by practical considerations. Here, the natural question
is to maximize the number of rectangles that can be extended, subject to this
ﬁxed density d. We call this problem, the d-Runaway Rectangle Escape
Problem. Note that this problem is complementary to the original Rectangle
Escape Problem. The Rectangle Escape Problem asks to extend all
the rectangles minimizing the density. The d-Runaway Rectangle Escape
Problem asks to extend the maximum number of rectangles subject to density
at most d, for any input parameter d.

This problem turns out to have strong connections to the classical k-fold
packing problem, which is a generalization of the independent set problem.
Precisely, the d-Runaway Rectangle Escape Problem in Rm with density
parameter d is related to the (d − 1)-fold packing of boxes in Rm−1 to achieve
approximate solutions.

The k-fold packing problem for geometric objects in Rm is deﬁned as follows.
Given a set of objects R in Rm and an integer parameter k, a k-fold packing
R′ ⊆ R is a subset of the set of input objects such that for every point x ∈ Rm,
|{R | x ∈ R, ∀R ∈ R′}| ≤ k, i.e., the number of objects in R′ containing x is at
most k for every x ∈ Rm [20, Chap 2]. Note that for k = 1 it is an independent
set of the objects. The problem is to maximize the size of the k-fold packing. Ene
et al. [10] have studied approximation algorithms for this problem in geometric
context. For our purposes, the objects are intervals and rectangles. The problem
is polynomial time solvable for intervals [11] whereas iteratively using the LP
based algorithm for solving the maximum independent set of rectangles, due
to Chalermsook and Chuzhoy [6], one can get an O(log log n) approximation

2

factor.

Th d-Runaway Rectangle Escape Problem is clearly NP-hard for d ≥
2, since it is NP-hard to determine whether all rectangles can be extended, i.e.,
is the optimum for this problem equal to n? We explore this problem from the
point of view of approximation and ﬁxed-parameter tractability. We also give a
randomized algorithm that outputs an O(1 − ǫ)-approximate solution with ap-
propriate restrictions on the density. On the approximation front, we show that
if the rectangles are disjoint, then we have a 4(1 + 1/(d − 1))-approximation for
the problem, and in general, we have a (4d)-approximation. We further extend
the ideas to boxes, 3-dimensional rectangles, where for disjoint boxes we have
an O(d log log n)-approximation, and in general, we have an O(d(log log n)3)-
approximation.

For the disjoint setting, we use the k-fold packing of the projections of rect-
angles (boxes), i.e., intervals (rectangles) to get the approximation algorithm.
Moreover, we show that the implications are also in the other direction, i.e., bet-
ter approximations for the d-Runaway Rectangle Escape Problem where
the boxes are disjoint implies better approximation for the (d − 1)-fold packing
of rectangles problem. We will describe this in more detail at the end of section
3.2.

The decision version of the d-Runaway Rectangle Escape Problem
may be informally stated as follows: are there at least k rectangles that can be
extended with density at most d? There are two natural parameters for this
problem; namely k, the number of rectangles that we wish to extend, and d,
the maximum density that is allowed. Since the problem is NP-complete even
for constant values of d, we do not expect this problem to be ﬁxed-parameter
tractable parameterized by d alone. On the other hand, we show that when
parameterized by k, for ﬁxed d, the problem is indeed ﬁxed-parameter tractable,
as long as the input rectangles have density at most (d − 1).

We also consider the following closely related question: can we extend at
least p non-boundary rectangles horizontally (i.e., towards the right or left), and
at least q non-boundary rectangles vertically (i.e., towards the top or bottom)
without violating the density constraints? A non-boundary rectangle is one
that doesn’t share an edge with the boundary of R. It is natural to consider
only non-boundary rectangles in our demand for extension, since the ones on
the boundary, without loss of generality, can be “extended” to the boundary
that they are on. We show that this problem is W[1]-hard, which implies that
a ﬁxed-parameter tractable algorithm does not exist unless the Exponential
Time Hypothesis fails.

Finally, we consider a special case of Rectangle Escape Problem when
all the rectangles are unit squares aligned to an underlying grid. For this prob-
lem when d = 2, we show a non-trivial reduction from a variant of Not-All-
Equals SAT, establishing NP-hardness. We also show that this problem enjoys
a 2-factor approximation algorithm.

3

2 Preliminaries

Let S be a set of rectangles in a rectangular region R. For T ⊆ S, let Γ(S, T ) be
obtained from S by extending each rectangle in T to one of the four borders of
R. We call Γ(S, T ) the extended conﬁguration of S with respect to T . Further,
we say that Γ(S, T ) has density at most d if every point in R is contained in
at most d rectangles in the extended conﬁguration. We will refer the maximum
density over all points in R, before extending the rectangles, to be the input
density of S.

For a ﬁxed d, the size of the largest subset T for which the density of
Γ(S, T ) ≤ d is called the runaway number of S with respect to d, which we
denote by ρ(S, d). We study the following decision version of the d-Runaway
Rectangle Escape Problem:

d-Runaway Rectangle Escape Problem — Decision version
Input: A set of n rectangles S in a rectangular region R, and an integer k.
Question: Is ρ(S, d) ≥ k?

The exact algorithms are considered in the framework of parameterized com-
plexity. We only introduce the terminology that we use in this work, the reader
is referred to the books [17, 13, 9] for a comprehensive exposition. A parameter-
ized problem Π is a subset of Γ∗ × N, where Γ is a ﬁnite alphabet. An instance
of a parameterized problem is a tuple (x, k), where x is the input string and
k is called the parameter. A central notion in parameterized complexity is
ﬁxed-parameter tractability (FPT) which means, for a given instance (x, k), de-
cidability is in time f (k) · p(|x|), where f is a computable function of k and p is
a polynomial in the input size |x|. We now deﬁne the notion of parameterized
reduction.

Deﬁnition 1. Let A, B be parameterized problems. We say that A is (uniformly
many:1) fpt-reducible to B if there exist functions f, g : N → N, a constant α ∈
N and an algorithm Φ which transforms an instance (x, k) of A into an instance
(x′, g(k)) of B in time f (k)|x|α so that (x, k) ∈ A if and only if (x′, g(k)) ∈ B.

A parameterized problem is considered unlikely to be ﬁxed-parameter tractable

if it is W [i]-hard for some i ≥ 1. To show that a problem is W [1]-hard, it is
enough to give a parameterized reduction from a known W [1]-hard problem. It
is well known that the parameterized version of the Maximum Clique Prob-
lem is W [1]-hard. In particular, we use the following popular variant of the
problem [12]:

Multi-Colored Clique
Input: A graph G whose vertex set is partitioned into k parts, V1 ⊎ · · · ⊎ Vk.
Question: Is there a subset S of vertices such that G[S] is a clique and

4

|S ∩ Vi| = 1 for all 1 ≤ i ≤ k?
Parameter: k.

3 Approximation Algorithms

In this section, we consider the optimization version of the problem, where the
goal is to extend the maximum number of rectangles with density at most d. We
devise approximation algorithms for rectangles in the plane and also extend the
idea for boxes, i.e., rectangles in 3-dimensional space. Thereafter, we assume
that the rectangles are disjoint in the input instance, and show that better
approximations can be reached under this assumption.

In order to approximate the optimum solution we will focus our attention
to a particular direction or axis and look into the problem restricted to that
direction or axis λ ∈ Λ where Λ is the set of directions (axes), i.e., the rectangles
are allowed to extend only in the direction (along the axis) λ. We denote the
optimum solution by OPT and when the problem is restricted to λ, then its
optimum solution is denoted by OPT λ. We claim the following statement.

Lemma 1. There exists a direction (axis) λ∗ ∈ Λ such that

|OPT λ∗ | ≥

|OPT |

|Λ|

Proof. We partition the optimum solution into sets Sλ such that in each set
every rectangle is extended in the direction (axis) λ.

OPT = ]λ∈Λ

Sλ

As the maximum is at least the average there exists a direction (axis) λ∗ such
that |Sλ∗ | ≥ |OPT |/|Λ|. For every λ, |OPT λ| ≥ |Sλ| because Sλ is a feasible
solution to the problem restricted to the direction (axis) λ. Together with the
previous inequality, the claim follows.

3.1 Arbitrary Family of Rectangles

Let (R, S, d) be an instance of d-Runaway Rectangle Escape Problem.
Let OPT denote an optimum solution. Note that at least half the rectangles
in OPT are pushed either horizontally or vertically. So we consider the follow-
ing problem: given the rectangles S, what is the largest number of rectangles,
OPT x, that can be extended vertically with density at most d? We show that
this can be approximated to within a factor of 2d, and repeating the argument
along the horizontal direction, and reporting the best of both solutions leads us
to a (4d)-approximation overall.

5

We remark that in [5], the problem of determining if at least k rectangles can
be extended vertically with density one (that is, with no overlapping rectangles)
is shown to be polynomially solvable. They use a natural greedy strategy:
consider the rectangles in the order of decreasing y-coordinates of the bottom
edges. Let this order be R1, . . . , Rn. For 1 ≤ i ≤ n, we try to extend Ri
upwards if this causes no conﬂicts, else we attempt to extend it downwards. If
Ri is blocked in both directions, we choose not to extend it and move to the next
rectangle on the list. However, this strategy does not work as-is, for instance,
when d = 2.

As a preprocessing step, we will ﬁrst forbid some rectangles from consider-
ation. For a rectangle Y whose x-projection is given by the interval (a, b), let
us denote by B(Y ) the region between the lines x = a and x = b. Call a rect-
angle Y stuck if there are points p1, p2 of density d (in the input conﬁguration)
contained in B(Y ), with p1 above Y and p2 below Y , see ﬁgure 1. Note that
the set of stuck rectangles do not participate in any solution. We now turn our
attention to the remaining rectangles, which we refer to as “good” rectangles.

p1

Y

p2

Figure 1: The notion of stuck rectangles.

We begin by considering the projections of the good rectangles on the x-
axis. Compute a maximum independent set A among these intervals. Return
the rectangles corresponding to A. As the returned rectangles are not ‘stuck’
and they do not overlap with each other, they indeed form a feasible solution.

Analysis. Note that for intervals a maximum independent set can be com-
puted in polynomial time. Moreover, its size is same as that of the minimum
sized piercing set1 as stated by Tibor Gallai in an unpublished work [14]. Next
consider the projection of the rectangles in OP Tx. Observe that the size of the
maximum clique in this set of intervals is at most 2d. If not, then there exists a
point on the x-axis with density more than 2d. This means that there are more

1A point set in the real line is called a piercing set of the set of intervals if every interval

contains at least one point from the set.

6

than d rectangles extended, either upwards or downwards, that are stabbed by
the vertical line passing through this point having density more than 2d. Hence,
|OP Tx| ≤ 2d|A|. Thus, as claimed, the problem restricted to a direction can be
approximated within a factor of 2d. A similar argument holds for the problem
of extending rectangles in the horizontal direction, and the better of the two
solutions is a (4d)-approximation overall.

Theorem 2. There exists a polynomial time 4d-approximation algorithm for
the d-Runaway Rectangle Escape Problem.

Boxes

Here, in addition to the 2 axes (i.e., horizontal and vertical) we also have the
lateral axis (z-axis). We consider the following restricted problem: what is
the largest number of rectangles that can be extended along a ﬁxed axis with
density at most d? Lemma 1 implies that there exists an axis along which at
least one-third of the rectangles in the optimum solution, OPT , are extended.
We solve the 3 restricted problems and return the best of the 3 solutions.

Hereafter, we look into the restricted problem where boxes are allowed to
extend only along the z-axis. We will return a solution that is approximate
to the optimum within a factor of O(d(log log n)3). The approximation ratio
suﬀers for boxes due to the approximation factors involved in computing the
maximum independent set of rectangles and the upper bound on the duality
gap between the piercing and independent set problems for rectangles.

We project every box in each of the three orthogonal planes. Without loss
of generality, we stick to the xy-plane. Similar to the 2-dimensional case, we
call a box stuck if extending the box alone in either of the directions in the
z-axis violates the density constraint. We will forbid the stuck boxes from
consideration.

Now, we have a set of rectangles R in the xy-plane, after removing the stuck
boxes. We compute an independent set A with the best known polynomial time
approximation algorithm. We return the boxes corresponding to the rectangles
in the computed independent solution. The solution is feasible as these boxes
are disjoint and good.

Analysis. Let ν be the size of the maximum independent set in R. Us-
ing the algorithm by Chalermsook and Chuzhoy [6], the size of A is at least
Ω(ν/ log log |R|). Thus, the approximation factor is O(log log n) as |R| ≤ n,
where n is the number of input boxes. Now consider the minimum sized pierc-
ing set2 of R where the size of such a set is denoted by τ . In fact, also consider
the set of straight lines L parallel to the z-axis passing through the piercing
points in the xy-plane. We will call the straight line Lp that is parallel to the
z-axis passing through the piercing point p in the xy-plane. So, all the good
boxes are stabbed by some line Lp because their projections on the xy-plane

2A point set in plane is called a piercing set of R if every rectangle contains at least one

point from the set.

7

are pierced by some point p. Now, consider the projection on the xy-plane of
the optimum solution, OPT z, where boxes are restricted to extend only along
the z-axis. Observe that the maximum clique number of these rectangles can
be at most 2d. If not then there exists a point q in the xy-plane that is cov-
ered by at least 2d + 1 rectangles, which means Lq witnesses density of at least
d + 1 in either positive or negative direction of the z-axis. As the minimum
piercing number is τ and the maximum clique size is 2d therefore, the number
of rectangles (projections of boxes in OPT z) is at most 2dτ .

Correa et al. [8], showed an upper bound of O(ν(log log ν)2) for τ . Thus,
|OPT z| ≤ O(2dν(log log ν)2). Therefore, the approximation factor of the re-
stricted problem is the following.

|A|

|OPT z|

≥

Ω(ν/ log log n)

O(dν(log log ν)2)

|A| ≥ Ω(

|OPT z|

d(log log n)3 )

As ν ≤ n, the last inequality holds. Also, returning the best of the 3 so-
lutions along the 3 axes will incur an approximation factor of 3, which will
not aﬀect the overall approximation factor asymptotically. Hence, there is an
O(d(log log n)3)-approximation algorithm for computing the d-Runaway Box
Escape Problem.

Theorem 3. There exists a polynomial time O(d(log log n)3)-approximation
algorithm for the Disjoint d-Runaway Box Escape Problem.

3.2 Disjoint Family of Rectangles

We consider the d-Runaway Rectangle Escape Problem when the rect-
angles are disjoint, i.e., the input density is at most unity. We recall that this
problem remains NP-complete due to the reduction in [5] for all d ≥ 2. For this
case, we obtain a 4(1 + 1/(d − 1))-approximation algorithm. Let OPT be the
optimum solution for the given instance of the Disjoint d-Runaway Rectan-
gle Escape Problem. We consider the four directions {x+, x−, y+, y−} and
restrict the problem in each one of them. From Lemma 1 we know that there
exists a direction λ∗ ∈ {x+, x−, y+, y−} such that the optimum solution size to
the problem restricted to the direction λ∗, |OPT λ∗ | ≥ |OPT |/4.

Without loss of generality, let us assume that λ∗ = y+. Let I denote the
It is well known that an
projections of the input rectangles on the x-axis.
optimum d-fold packing for a system of intervals on the real line can be obtained
in polynomial time [11].

Consider an optimum (d − 1)-fold packing, A, of I. We observe it gives us

a feasible solution to the problem restricted to a given direction.

Lemma 4. The rectangles corresponding to the (d−1)-fold packing, A, of I is a
feasible solution to the Disjoint d-Runaway Rectangle Escape Problem
restricted to extend to the upward (downward) direction.

8

Since the input rectangles are disjoint, the upward extensions of the rectan-
gles corresponding to any (d − 1)-fold packing will ensure the maximum density
to be at most d. Let νd−1 denote the size of A. The approximation algorithm
outputs the rectangles corresponding to intervals in A.

Analysis. We note that a d-fold packing may not be a feasible solution when
the corresponding rectangles are extended upwards. This is because we may
have an input rectangle positioned such that it intercepts a density d region
from the extension, causing the overall density to “spill over” to (d + 1). On the
other hand, since a d-fold packing on the interval projection can be obtained
from an upward extension of density at most d, we have:

νd−1 ≤ |OPT λ| ≤ νd

Now, we use the fact that any d-fold packing of intervals is a disjoint union
of d independent sets of intervals (see, for example, [11]). Let C1, C2, ..., Cd be
the independent sets in an optimum d-fold packing of I, where we index them in
non-increasing order of their sizes. Let ti = |Ci| and also ti ≥ ti+1 for 1 ≤ i < d.

Thus, νd = P1≤i≤d ti and νd−1 ≥ νd − td, since removing an independent set

from a d-fold packing yields a feasible (d−1)-fold packing. Now, by an averaging
argument, we have td ≤ νd/d. Thus, νd−1 ≥ νd(1 − 1/d). Hence, the following
holds.

|A| ≥ |OPT λ|(1 − 1/d)

Returning the best among the 4 solutions, each corresponding to a direction,
will incur another factor of 4. Thus, the overall approximation factor is 4(1 +
1
d−1 ).
Theorem 5. There exists a polynomial time 4(1 + 1
rithm for the Disjoint d-Runaway Rectangle Escape Problem.

d−1 )-approximation algo-

Disjoint Boxes

Consider a family of non-overlapping boxes. The problem is to maximize the
number of boxes that can be extended without violating the given density con-
straint. Let OPT be the optimum solution.

Now, we pose the same problem but restricting ourselves to one of the 6
directions {x+, x−, y+, y−, z+, z−} each time and choose the best of the 6 so-
lutions. Let the optimum solution when rectangles are allowed to escape only
in a given direction λ be OPT λ. From Lemma 1 there exists a direction λ∗
such that |OPT λ∗ | ≥ |OPT |
. Thus for every direction λ we would consider
approximating OPT λ.

6

Now we project the boxes on the plane in some direction λ to obtain a family
of rectangles R. We compute a (d − 1)-fold packing A [10], and return the boxes
corresponding to it.

9

Analysis. We note again that a d-fold packing may not be a feasible solution
for similar reasons as were in the 2-dimensional case. From Ene et al.
[10,
Lemma 2.2], we know that repeatedly using an LP-based α-approximation al-
gorithm for k times gives a 2α-approximation algorithm for k-fold packing. As
Chalermsook and Chuzhoy [6], gave an O(log log n)-approximation algorithm
for computing maximum independent set of rectangles, we use the same algo-
rithm d − 1 times to get a (d − 1)-fold packing, A such that its size is at least
Ω(νd−1/ log log n).

Now we compare νd with νd−1. Consider the optimum d-fold packing Pd
that is a disjoint union of t ≤ O(d2) color classes. The maximum clique size of
the intersection graph of a d-fold packing of rectangles is d, and the chromatic
number of such a graph is bounded by the square of the clique number [4].
Therefore, the number of color classes is at most O(d2). The union of the
largest d − 1 such classes is indeed a feasible (d − 1)-fold packing. Moreover its
size is at least

t/(d−1) . This means,

νd

νd−1 ≥ Ω(cid:16) νd
d (cid:17) .

Thus, |A| ≥ Ω(νd/d log log n) holds. Since, OPT λ is a feasible d-fold packing

the following approximation holds.

|A| ≥ Ω(cid:18) |OPT λ|
d log log n(cid:19)

As before, choosing the best out of the 6 solutions does not aﬀect the
approximation factor asymptotically. Therefore, we have an O(d log log n)-
approximation algorithm for the Disjoint d-Runaway Box Escape Prob-
lem.

Theorem 6. There exists a polynomial time O(d log log n)-approximation algo-
rithm for the Disjoint d-Runaway Box Escape Problem.

It is interesting to note that when the boxes are cubes, i.e., equal in all the
3 dimensions, then similar approaches as above will yield O(d)-approximation,
both for the general and disjoint case. Constant factor approximation algorithms
as well as PTAS are known for computing maximum independent set of squares
[7]. For squares the transversal number τ ≤ 4ν where ν is the independence
number [1]. Even independently, k-fold packing problem for squares enjoys a
PTAS where k is a constant [3].

Discussion. Above, we saw how solution to a (k−1)-fold packing of rectangles
can be used as an approximate solution to the Disjoint k-Runaway Box Es-
cape Problem. Now we shall show that given an α-approximation algorithm
for Disjoint k-Runaway Box Escape Problem restricted to one direction
there exists an αk-approximation algorithm of the k-fold packing of rectangles.
We are given an arbitrary family of rectangles in the plane and we like to com-
pute the maximum k-fold packing of the rectangles. We create a disjoint family

10

of boxes in R3 such that their projection on a ﬁxed direction will give back
the original family of rectangles. The claim is that if we have an algorithm
that returns an α-approximate solution A to the k-Runaway Rectangle Es-
cape Problem restricted to the ﬁxed direction, then we can actually get an
αk-approximate solution to the k-fold packing just by returning the rectangles
corresponding to A. Any feasible solution with density at most k to this run-
away problem gives a feasible solution for the k-fold packing problem. Let OPT
be the optimum solution to the restricted problem. From the above discussions
it is clear that νk−1 ≤ |OPT | ≤ νk and νk−1 ≥ νk/k. Now, |A| ≥ |OPT |/α.
Thus, |A| ≥ νd/(αk). Thus the claim follows.

4 A Randomized Algorithm

In this section we will present a randomized algorithm for the Runaway Rect-
angle Escape Problem. Our algorithm will follow very closely the algorithm
given by Assadi et al. [5]. Precisely, we will prove the following theorem.

Theorem 7. There is a randomized algorithm for the Runaway Rectangle
Escape Problem that outputs a feasible solution whose size is at least (1 −
ǫ)|OPT |, with high probability, provided the given density d ≥ Ω(ln n/(ǫ2α2))
and every point has an input density at most (1 − α)d, where α is a positive
fraction independent of d.

Proof. We will solve the relaxed linear program for the problem and scale the
values appropriately before doing a randomized rounding. Then, we shall argue
that the solution is feasible and near-optimal with high probability.

Given a family of rectangles S there are at most 4n2 points to capture the
constraints of the problem. This is possible by extending the two vertical and
two horizontal sides of every rectangle. This would result to a 2n × 2n grid and
the set of grid points is denoted by G.

For every rectangle Ri, we deﬁne four variables ri,↑, ri,↓, ri,← and ri,→ each
for the four directions. Next, for every grid point p, deﬁne Sp = {(i, λ) | p ∈ Rλ
i }
where Rλ
is the extended region outside rectangle Ri after being extended in
i
the direction λ. We denote Λ as the set {↑, ↓, ←, →}. Also, let dp be the density
of p prior to any extension.

The following is the linear program formulation.

maximize Xi∈[n],λ∈Λ
subject to X(i,λ)∈Sp
Xλ∈Λ

ri,λ ≥ 0

ri,λ

ri,λ ≤ 1,

ri,λ + dp ≤ d, ∀p ∈ G

∀i ∈ [n]

∀i ∈ [n], ∀λ ∈ Λ

Next for every rectangle Ri, we do the following random experiment. We
extend Ri in at most 1 of the 4 directions. The probability that it is extended

11

in the direction λ is (1 − ǫ)ri,λ and the probability that it is not extended is ǫ
for ǫ ∈ (0, 1/2). Thus there may be rectangles not extended after this random
experiment.

We claim that the solution returned is feasible with high probability. For
every rectangle Ri deﬁne ˆri,λ be the 0/1 random variable denoting whether Ri
has been extended in the direction λ. For every point p deﬁne random variable,

Dp = X(i,λ)∈Sp

ˆri,λ + dp.

Now, we would like to show probabilistically for every point p, Dp is at most
d with high probability. More formally, we will apply Chernoﬀ bounds to show
that Dp does not deviate too much from its expected value. The expected value
of Dp is at most (1 − ǫ)(d − dp) + dp from the constraints of the linear program.
Also, dp ≤ d, thus we assume µp = (1 − ǫ)d + ǫdp.

We would like to lower bound Pr[∩p (Dp ≤ (1 + δp)µp)] for some value of
δp that we are going to state shortly. Instead, we will bound the probability
of the complementary event, i.e., Pr[∪p (Dp > (1 + δp)µp)]. This can be upper
bounded by the union bound.

Pr"[p

(Dp > (1 + δp)µp)# ≤Xp

Pr [Dp > (1 + δp)µp]

We apply Chernoﬀ bound, taking δp = d/µp − 1 and µp as deﬁned earlier.

Note that the values of µp and δp diﬀers for every point p in G.

Pr[Dp > (1 + δp)µp] ≤ exp(

−µpδ2
p

3

)

We would like the RHS to be at most 1/n3. As we assume, from the theorem
statement, that dp ≤ (1−α)d for a ﬁxed positive fraction α which is independent
of d, we express dp = (1 − αp)d, where αp ≥ α is an appropriate positive fraction
independent of d, and the following inequality holds

d ≥ 9 ln n

(1 − ǫαp)

ǫ2α2
p

then Pr[Dp > d] ≤ 1/n3. Therefore, the probability of any point having density
more than d is at most 1/n, summing over all the O(n2) grid points and applying
the union bound provided

d ≥ 9 ln n

(1 − ǫα)

ǫ2α2

where, α = minp αp.

Finally, we prove that the solution returned is near optimal with high prob-
ability. Here again the expected solution size is (1 − ǫ)|OPT LP |. We would
like to upper bound Pr[|A| < (1 − ǫ)2|OPT |]. Applying Chernoﬀ bound, again

12

3

this is exp(−ǫ2(1 − ǫ)|OPT LP |/3), and we would like this to be at most 1/n.
Thus, |OPT LP | ≥
ǫ2(1−ǫ) ln n and the RHS tends to 0 with ǫ. Hence, |A| ≥
(1 − ǫ)2|OPT LP | with probability at least 1 − 1/n provided |OPT LP | ≥ Ω( ln n
ǫ2 ).
As the density is already assumed to be Ω(ln n (1−ǫα)
ǫ2α2 ) and the optimum solu-
tion is at least the density, the assumption over OPT LP is redundant. This
completes the proof.

5 Parameterized Algorithms and Hardness

In this section, we consider the d-Runaway Rectangle Escape problem pa-
rameterized by k. Note that if the input density is greater than d, then we have
a trivial No-instance. On the other hand, we show that if the input density is
at most (d − 1), then the problem is FPT. Unfortunately, this algorithm does
not immediately extend to accommodate the situation when the input may have
points of density d.

We also consider a natural variation of this problem, for which we obtain
a parameterized hardness result. Let us call a rectangle internal if none of its
sides coincide with the boundaries of R. We introduce the following question:

d-Constrained Runaway Rectangle Escape
Input: A set of n rectangles S in a rectangular region R, and integers p, q.
Question: Is it possible to extend at least p internal rectangles along the
horizontal axis, and at least q internal rectangles along the vertical axis,
such that the extended conﬁguration has density at most d?
Parameter: p + q

We show that this particular variant is in fact W[1]-hard by a reduction from

Multi-Colored Clique, even when d = 2.

Fixed-Parameter Tractability. Let (R, S, k, d) be an instance of d-Runaway
Rectangle Escape, where the input density is at most (d − 1). We recall that
this problem is NP-complete since the problem was shown, in [5] to be NP-
complete for d = 2, k = n even when all the rectangles are disjoint.

As with the approximation algorithm in the previous section, we consider the
projections of the input rectangles on the x-axis and arrange them according to
their left endpoints. Choose a maximum independent set among these intervals
by greedily choosing the intervals that end the earliest (and eliminating intervals
that overlap with the chosen one). Let {X1, . . . , Xp} be such an independent set,
arranged according to their right endpoints, and let T := {T1, . . . , Tp} denote
the rectangles from S corresponding to this independent set. Let ai and bi
denote, respectively, the left and right endpoints of Xi. Note that if p ≥ k,
then we may return Yes at this point, since the rectangles in χ can be extended
upwards without any mutual conﬂicts, and this extension will have density at
most d because input density is at most (d − 1) to begin with. Therefore, p < k.

13

i, b′

We repeat this process on the y-projections of the rectangles, and let T ′ :=
1, . . . , T ′
{T ′
q} denote the rectangles from S corresponding to the independent set
obtained in this case. We let (a′
i) denote the top and bottom endpoints of the
y-projection of T ′
i . Again, we may assume that q < k, otherwise we are done.
Now consider the lines given by x = bi for 1 ≤ i ≤ p and y = b′
j for 1 ≤ j ≤ q.
Let g(i, j) denote the intersection of the lines x = bi and y = b′
j. For every
rectangle H in S, observe that there exists 1 ≤ i ≤ p and 1 ≤ j ≤ q such that
H contains g(i, j). Indeed, suppose not. Then this would imply, for instance,
that H is not stabbed by any of the vertical lines x = bi, which implies that
there exists i ∈ [p] for which the left endpoint of the x-projection of H is after
bi, and the right endpoint is before bi+1. However, this contradicts the greedy
construction of χ. A similar argument can be made for the horizontal lines.

Now, we have a collection of less than k2 points that pierce all the rectangles
in S. Since the input density was at most (d−1), each g(i, j) can be contained in
at most (d−1) of the input rectangles. Therefore, the total number of rectangles
is at most (dk2). We may now guess the subset of k rectangles that we would
like to extend in time:

k (cid:19)k
(cid:18)dk2
k (cid:19) ≤(cid:18) dk2e

= (dke)k.

For each guess, we can further guess the direction of the extension of the
chosen rectangles — noting that there are at most four possibilities for each rect-
angle, this is an additional overhead of 4k. Note that we spend polynomial time
in identifying the stabbing lines (and resolving the instance at that stage if it is
called for). So overall, the running time of our algorithm is O((dke)k4k)nO(1).

Theorem 8. The d-Runaway Rectangle Escape Problem can be resolved
in time 2O(k log k)nO(1) when the input conﬁguration has density at most (d − 1).

Note that the diﬃculty with input conﬁgurations that have points of density
d is that having an independent set of size k on the x-projections does not
imply that we have a solution, because quite possibly many of the rectangles
in the independent set are “blocked” by points of density d. Even if we forbid
such rectangles upfront, as in the previous section, we may have an unbounded
number of rectangles that are stuck horizontally or vertically. As it turns out, the
rectangles that are stuck horizontally and vertically pose no problems, because
they can be declared forbidden and eliminated from the search space. Similarly,
the number of rectangles that are not stuck in either direction can be bounded by
(k2d) by an argument along the lines of what we had for Theorem 8. However,
there may be an unbounded number of rectangles that are stuck only vertically
(or only horizontally), and this is where the argument for Theorem 8 does not
extend to the case when the input density is d.

W-hardness We now turn to the 2-Constrained Runaway Rectangle
Escape. Let (G, V, k) be an instance of Multi-Colored Clique, where the
partitions of V are given by V1 ⊎ · · · ⊎ Vk. We assume, without loss of generality,

14

that all the parts have the same number of vertices. We denote the vertices in
Vi by vi[1], . . . , vi[t].

The reader is referred to Figure 2 for a schematic of the construction that
we are going to describe. We ﬁrst introduce the rectangles corresponding to
vertices, which we call selection gadgets. Every vertex in V is associated with a
rectangle of unit width and height (t + 1). We use Ti[j] to refer to the rectangle
corresponding to the vertex vi[j], where 1 ≤ i ≤ k and 1 ≤ j ≤ t.

Figure 2: A cross-section schematic, not drawn to scale, of the reduction from
Multi-Colored Clique. The groups of blue rectangles correspond to vertices
from a particular partition in the instance of Multi-Colored Clique. The red
rectangles indicate two overlapping rectangles placed along the borders of R,
while the green rectangle is a single rectangle, again aligned to the right border
of R. The orange rectangles are the incidence gadgets and the black rectangles
correspond to the edges.

We place the bottom-left corner of Ti[j] at (2 + 2j, 3 + j + (2t + 5)(i − 1)).
This is simply a collection of t rectangles cascading successively in the top-right

15

direction, with the collection of rectangles for vertices in Vi appropriately oﬀset
from the collection corresponding to vertices in Vi+1. We use Ti to refer to
{Ti[j] | j ∈ [t]}. Note that at most two of the rectangles from any Ti can be
extended either to the right or the left (since d = 2 and all of these rectangles
are stabbed by a single horizontal line). We will reﬁne this observation further
with the help of additional rectangles, to ensure that at most one of them can
be extended to the right, and none of them in any of the other directions.

We now turn to the edges in G. For each eℓ ∈ G, we introduce an unit square
Tℓ with its lower left corner at (3t + 12ℓ, (2t + 5)2). Informally, all the squares
corresponding to the edges are placed on one horizontal line, suitably spaced
out. Further, the y-coordinates of their lower-left corners are large enough to
ensure that the squares are placed above all the vertex gadgets.

Next, we add incidence gadgets. These rectangles ensure that if Ti[j] is
extended to the right and Tℓ is extended downwards, then the edge eℓ is incident
to vi[j]. We ﬁrst informally describe the setup. Let Ba[r] denote the rectangle
obtained by extending Ta[r] towards the right. Let eℓ = (va[p], vb[q]). We will
place two rectangles Wa[p], Za[p] to the right of Ta and below Tℓ. The rectangle
Wa[p] will intercept the bands Ba[r] for r > p, but will not overlap Ba[p], and
the rectangle Za[p] will intercept the bands Ba[r] for r < p, but again will not
overlap Ba[p]. This ensures that if Ta[r] is extended to the right and eℓ is not
incident to r, then a point of density two is created by the overlap of either
Wa[p] or Za[p] with the extended rectangle Ta[r], thus forbidding Tℓ from being
extended downwards. This process is repeated for the collection Tb.

Formally, for every edge eℓ = (va[p], vb[q]), we place the following four rect-
angles, which we call incidence gadgets. All these rectangles are seven units
wide, and the x-coordinate of their lower-left corner is three units less than
the x-coordinate of the lower-left corner of Tℓ. That is, if we consider the x-
projections of these four rectangles along with the x-projection of Tℓ, then we
will ﬁnd the x-projection of Tℓ exactly at the center, and the remaining four
intervals coinciding. We now describe how Wa[p], Za[q] are placed along the
y-axis, and note that the rectangles Wb[q] and Zb[q] are placed similarly.

1. The rectangle Wa[p]. The y-coordinate of the bottom edge of Wa[p] is the
same as the y-coordinate of the upper edge of Ta[p]. The y-coordinate
of the top edge of Wa[p] is two more than the y-coordinate of the upper
edge of Ta[t], that is, we make sure that this rectangle “juts out” over and
above the last rectangle in the group Ta. This will be useful later, when
we would like to forbid this rectangle from extending to the right, without
forbidding any of the rectangles in Ti from extending to the right.

2. The rectangle Za[p]. The y-coordinate of the top edge of Za[p] is the same
as the y-coordinate of the bottom edge of Ta[p]. The y-coordinate of the
bottom edge of Za[p] is two less than the y-coordinate of the bottom edge
of Ta[1].

We now incorporate some rectangles along the boundary, which we will refer
to as guards. The purpose here is to “block” certain extensions. To begin with,

16

we place two overlapping unit-width rectangles along the entire left boundary,
and two overlapping unit-height rectangles along the top boundary of R. This
ensures, for example, that none of the internal rectangles can be extended to
either the left or the top. Further, we place a single rectangle, denoted by H,
that covers the entire right boundary (stopping short of the guard rectangles on
top to avoid a region of density three).

Next, we would like to ensure that the rectangles Ti[j] can only be extended
to the right. To this end, we place two overlapping rectangles of unit height
along the bottom boundary of R, wide enough to block any Ti[j] from extending
downwards, for 1 ≤ i ≤ k and 1 ≤ j ≤ t. Speciﬁcally:

• The x-coordinate of the bottom left corner of these rectangles is one less

than the x-coordinate of the bottom left corner of T1[1].

• The x-coordinate of the bottom right corner of these rectangles is one

more than the x-coordinate of the bottom right corner of T1[t].

We add a unit square on the right boundary (overlapping H), whose lower-
right corner has the y-coordinate (2t+ 5)2. This eﬀectively blocks the rectangles
corresponding to the edges from extending to the right.

1 , . . . , H †

Finally, we add rectangles along the bottom and right boundaries to ensure
that the rectangles in the incidence gadgets are blocked from being extended to
either the right or the downwards. In this context, we introduce unit squares
H1, . . . , Hk and H †
k, to be placed along the right boundary. The y-
coordinate of the upper-right corner of the square Hi is two more than the
y-coordinate of the upper edge of Ti[t]. This, together with H, ensures that
the rectangles Wi[j] are blocked from extending towards the right, for any 1 ≤
i ≤ k and 1 ≤ j ≤ t. Similarly, the y-coordinate of the lower-right corner of
the square H †
is two less than the y-coordinate of the bottom edge of Ti[1].
i
Again, together with H, this ensures that the rectangles Zi[j] are blocked from
extending towards the right, for any 1 ≤ i ≤ k and 1 ≤ j ≤ t. Note that these
rectangles do not block any rectangles in Ti from extending to the right, because
of their unit height.

For this instance, we let p = k and q =(cid:0)k

of the construction, and we now turn to a proof of correctness. It is useful to
keep in mind that the guards are the only rectangles that are not internal.

2(cid:1). This completes the description

In the forward direction, let c1, . . . , ct, ci ∈ [t], be such that the vertices vi[ci]
form a multi-colored clique. We then extend the rectangles Ti[ci] to the right,
and the unit squares Tℓ corresponding to the edges of the clique downwards. It is
easy to check that the guards do not interfere with any of these extensions, that
is, there are no points of density three on the boundary after these rectangles are
extended as described. Also, extending the rectangles from the selection gadgets
alone creates no points of density greater than two. We now address the edge
extensions. Let eℓ = (vi[ci], vj [cj]) be an edge in the clique. Observe that the
rectangles in the incidence gadget corresponding to the rectangle Tℓ skirt the
edges of the bands Bi[ci] and Bj[cj], without overlapping them. Therefore, it

17

can be veriﬁed that we create no points of density greater than two when the
square Tℓ is extended downwards.

In the reverse direction, we observe that at most one rectangle can be ex-
tended to the right from Ti, and none of them can be extended to the left.
Further, none of the other internal rectangles can be extended along the hori-
zontal axis while maintaining density at most two. Since we have to extend at
least k rectangles along the horizontal axis, it follows that any solution extends
exactly one rectangle from each Ti, for 1 ≤ i ≤ k. Let 1 ≤ ci ≤ t be such
that Ti[ci] was the rectangle that was extended to the right. We claim that
the vertices vi[ci] form a multi-colored clique in G. Indeed, observe that if Tℓ
is extended downwards, where eℓ = (vi[p], vj[q]), then the rectangle extended
from Ti must be Ti[p] and the rectangle extended from Tj must be Tj[q] —
indeed, the extension of any other rectangle from either collection will lead to a
point of density three (combined with the incidence gadgets for Tℓ. Therefore,
a rectangle corresponding to an edge can be extended downwards only if it is an
edge from G[{v1[c1], . . . , vt[ct]}]. Recall that the guard vertices are positioned
so that none of the internal rectangles can be extended upwards, and only the
squares corresponding to the edges can be extended downwards. Therefore, if
the claimed subgraph does not induce a clique, we conclude that the solution

falls short of the(cid:0)k

we have shown the following.

2(cid:1) extensions that were required along the vertical axis. Thus,

Theorem 9. The 2-Constrained Runaway Rectangle Escape is W [1]-
hard.

6 The Square Escape Problem

In this section, we look in to a special case of the Rectangle Escape Prob-
lem, where the rectangular region R is given as a grid of unit squares, and
every rectangle is a unit square aligned to the grid. This is same as having
grid points instead of squares and orthogonal line segments joining the grid
points to the boundary of R instead of extensions of the squares. As it turns
out this problem, in the latter guise, has been studied for unit density and an
O(n2 log n) time algorithm is devised in [18]. We show that despite being a
rather severely specialized version of Rectangle Escape Problem, even this
formulation is NP-hard for density two. In particular, the problem of determin-
ing if all the squares can be extended while maintaining density two is NP-hard,
while the “runaway” version enjoys an improved approximation algorithm and
is ﬁxed-parameter tractable irrespective of the density of the input squares.

d-Runaway Square Escape
Input: A set S of n squares from an m × m grid R, and an integer k.
Question: Is ρ(S, d) ≥ k?

18

We ﬁrst show that the d-Runaway Square Escape is NP-hard even when
k = n and d = 2. We reduce from the version of Not-All-Equals SAT. It
is known that not-all-equals satisﬁability continues to be NP-complete for this
restricted formulation [2].

Not-All-Equals SAT
Input: A conjunction of clauses each containing 2 or 3 variables, all in their
positive form, and every variable appears in at most 3 clauses.
Question: Does their exists a satisfying assignment φ such that every clause
has at least one variable to be true and at least another variable to be false?

Before we describe the construction, we introduce some terminology. For a
square s located on the ith row and the jth column of the given grid, we use R(s)
and C(s) to refer to i and j, respectively. We say we place a square at (i, j) to
indicate that a square is placed in the location determined by the intersection
of the ith row and jth column.

Suppose we are working on an m × m grid. When we say that we block a
square s, say, in the upward direction, then this means that we introduce two
overlapping squares at (m, C(s)), if they are not already present. We are only
allowed to block a square s if there are either no squares at (m, C(s)), or if there
are two squares at (m, C(s)). The terminology is motivated by the fact that
when we block a square s in the upward direction, no extension of density at
most two can extend s in the upward direction.

When we say that we partially block a square s in the upward direction, then
this means that we introduce one square at (m, C(s)), if not already present.
In particular, a square on column j cannot be partially blocked if there are two
squares placed already at (m, j). These squares are called guards.

We let φ denote an instance of Not-All-Equals SAT where every clause
has two or three variables and every variable occurs in at most three clauses.
Let v1, . . . , vn be the variables involved in φ, and let C1, . . . , Cm denote the
clauses of φ.

For every variable, we will introduce three squares corresponding to the
variable, which we simply call the variable gadget. We then add more squares
to ensure that these three squares are always extended in the same direction,
and these collections of squares are called the copy gadgets. Finally, we add
three squares for every clause, which we call the clause gadgets.

For a variable vi, let Vi := {si[1], si[2], si[3]} denote the three squares in-
volved in the corresponding variable gadget. We say we place Vi at (x, y) to
mean that si[1] is placed at (x, y + 4), si[2] is placed at (x + 2, y + 2) and si[3] is
placed at (x + 4, y). The envelope of a variable gadget that is placed at (x, y),
denoted by Ei, is deﬁned as the rectangular region whose lower-left corner is at
(x, y) and whose upper-right corner is at (x + 25, y + 25). All the squares that
participate in the copy gadget for Vi will be placed in Ei. We now describe the
individual components of the construction.

19

Variable Gadgets The variable gadget corresponding to v1 is placed at (0, 0).
The variable gadget corresponding to vi is placed at the top-right corner of Ei−1,
for 2 ≤ i ≤ n. All the squares in the variable gadgets are blocked downwards
and to their left, while they are partially blocked upwards and to their right.

Clause Gadgets Let C1, . . . , Cm be an arbitrary but ﬁxed ordering of the
clauses. Let Cj = {vi1 , vi2 , vi3 } be a clause of length three. Within a clause, we
order the variables according to increasing order of their indices. Let Cj be the
fj[x]th clause that vix appears in. For example, for a clause C3 := {v2, v3, v7},
we may have f3[1] = 2 to denote the fact that C3 is the second clause that v2
appears in. Note that fj[x] ∈ {1, 2, 3} for the particular instance of Not-All-
Equals SAT that we have started with.

For this clause Cj , we introduce squares tj[1]U , tj[2]U , tj[3]U and tj[1]R, tj[2]R, tj[3]R,

placed in the following manner.

1. For x ∈ {1, 2, 3}, the square tj[x]U is placed in the same column as
six [fj[x]]. The row it is placed in is 2j + 25n + 10. In particular, it is
2j + 10 units above En.

2. For x ∈ {1, 2, 3}, the square tj[x]R is placed in the same row as six [fj[x]].
The column it is placed in is 2j + 25n + 10. In particular, it is 2j + 10
units to the right of En.

If we have a clause of length two, then we place squares tj[1]U , tj[2]U and
tj[1]R, tj[2]R exactly as described above. Further, we add two dummy squares
P and Q, where P is placed on the same row as tj[1]U , tj[2]U , and is placed
on an empty column c such that C(tj[1]U ) < c < C(tj[2]U ). Similarly, Q is
placed on the same column as tj[1]R, and is placed on an empty row r such that
R(tj[1]U ) < r < R(tj[2]U ). The square P is blocked up and down, while the
square Q is blocked on the right and left. We note that if empty rows or columns
are not available, then the spacing between the envelopes of the variables can
be easily adjusted to free up space. We do not incorporate this detail in the
interest of a simpler presentation.

Figure 3: A schematic of the clause gadget.

Copy Gadgets Let Vi be a variable gadget placed at (x, y). Then we intro-
duce the following squares in the copy gadget corresponding to Vi:

20

• We place squares at (x, y + 8), (x + 2, y + 12), (x + 2, y + 16), (x + 4, y + 20).
Further, we place squares at (x + 8, y + 2), (x + 12, y + 4), (x + 16, y), (x +
20, y + 2).

• We place squares at (x + 8, y + 8), (x + 12, y + 12), (x + 16, y + 16), (x +

20, y + 20). We call these the blockers.

• For each blocker at (p, q), we place two additional squares at (p − 2, q) and
(p, q − 2). These we call the anchors. The anchors at (p − 2, q) are blocked
upwards and downwards, while the rest of the anchors are blocked to their
left and right.

Figure 4: A general schematic of a copy gadget.

The variable gadgets, their corresponding copy gadgets, and the clause gad-
gets, together comprise the reduced instance. We now argue the equivalence of
the two instances.

In the forward direction, let τ : {v1, . . . , vn} → {0, 1} be a not-all-equals
satisfying assignment. If τ (vi) = 1, then we extend all the squares in Vi to the
right, and if τ (vi) = 0, then we extend all the squares in Vi upwards. It can be
shown that all the squares in the copy gadgets continue to have a valid extension
(see Figure 4 onwards for illustration). It is important to ensure here that for any
ﬁxed column (or row), we extend at most one square upwards (or rightwards)
along that column (or row). This ensures that all the “crossings” encountered
when we proceed to extend the squares corresponding to clause gadgets have
density at most two. Also, extending two squares to the left or downwards

21

along any row or column causes no problems, because any potential interference
comes from clause gadgets being extended (respectively) downwards or to the
left — but the placements of these gadgets are such that these extensions are
guaranteed to be parallel, and consequently, non-crossing.

Among the squares tj[1]U , tj[2]U , tj[3]U , notice that at most two of them are
in locations with density two because at most two of the corresponding squares
in the variable gadgets were extended upwards (recall that we start with a
not-all-equals satisfying assignment). Therefore, we extend the square that is
free upwards, and the other two to the left and right, respectively. A similar
argument works for the squares tj[1]R, tj[2]R, tj[3]R. Finally, all the guards can
be trivially extended to the edge that they are the closest to.

In the reverse direction, we ﬁrst note that in any valid extension, all the
squares in a variable gadget must be extended in the same direction. For exam-
ple, for any 1 ≤ i ≤ n, if si[1] and si[2] are extended upwards and to the right
respectively, then there are corresponding anchor squares that are forced to be
extended to the right and upwards, which then create a point of density three
at the corresponding blocker square. It can be argued, therefore, that si[1] and
si[2] must be extended in the same direction, and similarly, that si[2] and si[3]
must be extended in the same direction. It follows that all three of them must
be extended in the same direction — and since they are blocked on the left and
downwards, they must be extended either upwards or to the right.

We suggest an assignment to the variables of φ as follows. If the squares in
Vi are extended to the right, then we set vi to 1 and to 0 otherwise. If this is
not a valid not-all-equals assignment, then consider the squares corresponding
to a violated clause. Assume, without loss of generality, that all variables in this
clause were set to one, therefore, the squares corresponding to the variables were
extended to the right. If this was a clause of length three, then observe that the
square in the clause gadget corresponding to the second variable is now blocked
in all four directions (recall that the squares corresponding to the variables were
partially blocked on the right), and cannot be extended. If this was a clause of
length two, then the dummy square Q corresponding to the clause is similarly
blocked in all four directions. In all four cases, we get the desired contradiction.
Thus we have shown the following.

Theorem 10. d-Runaway Square Escape is NP-complete even when d = 2
and k = n.

On the other hand, we know that for the d-Runaway Square Escape Problem,
we may ﬁnd the maximum number of rectangles that can be extended vertically
in polynomial time. Indeed, for every column, we extend the d squares “closest
to the top” upwards, and the d squares “closest to the bottom” downwards. This
is evidently an optimal solution. A similar argument holds for ﬁnding the maxi-
mum number of rectangles that can be extended horizontally. Since any solution
that extends the squares in any of the four directions extends at least half of
the squares either vertically or horizontally, we have a simple two-approximation
algorithm. It is also easy to check that the ﬁxed-parameter tractable algorithm

22

described for rectangles works for squares with no assumptions on the density
of the input conﬁguration.

Figure 5: When all copies of a variable are extended upwards.

7 Future Directions

Studying this natural optimization version of Rectangle Escape Problem
leads us to several new questions. First, to obtain a constant-factor approxima-
tion algorithm that is independent of d, we would like to be able to answer the
question of whether at least k rectangles can be pushed along one direction in
polynomial time, and further address the question of whether k rectangles can
be pushed up or down with density at most d in polynomial time. From the
reduction in [16] it can be seen that the question of whether all rectangles can
be pushed with density at most three when the only available directions are top
and right, is already NP-hard. It would be interesting to examine what happens
when the combinations of directions that are available are parallel (like up and
down, or right and left), and one of the motivations is that this directly impacts
the approximation ratio.

There are unresolved questions in the parameterized context as well. For
example, is the problem ﬁxed-parameter tractable when the input conﬁguration
has points of density d? Further, for the cases when the input conﬁguration
has density at most (d − 1), the algorithm presented here has a running time of
2O(k log k)nO(1). Can this be improved, for instance, 2O(k)nO(1)?

23

Figure 6: When all copies of a variable are extended to the right.

A general direction of interest is to obtain substantially improved algorithms
for the special case when the rectangles are squares aligned to a grid, for which
we establish NP-hardness here.

Acknowledgements

We would like to thank Sue Whitesides who suggested to consider the problem
in 3-dimensions.

References

[1] R. Ahlswede and I. Karapetyan.

Intersection graphs of rectangles and
segments. General Theory of Information Transfer and Combinatorics,
4123:1064–1065, 2006.

[2] B. M. Anthony and R. Denman.

k-Bounded Positive Not All Equal

LE3SAT. In Brown Working Papers, 2009.

[3] R. Aschner, M. Katz, G. Morgenstern, and Y. Yuditsky. Approximation
schemes for covering and packing. WALCOM: Algorithms and Computa-
tion, 7748:89–100, 2013.

[4] E. Asplund and B. Gr¨unbaum. On a coloring problem. Math. Scand.,

8:181–188, 1960.

24

Figure 7: A violation when two copies are extended in diﬀerent directions.

[5] S. Assadi, E. Emamjomeh-Zadeh, S. Yazdanbod, and H. Zarrabi-Zadeh. On
the rectangle escape problem. In Canadian Conference on Computational
Geometry (CCCG), pages 235–240, 2013.

[6] P. Chalermsook and J. Chuzhoy. Maximum independent set of rectangles.

In SODA, pages 892–901, 2009.

[7] T. M. Chan and S. Har-Peled. Approximation Algorithms for Maximum
Independent Set of Pseudo-Disks. Discrete and Computational Geometry,
pages 373–392, 2012.

[8] J. Correa, L. Feuilloley, P. P´erez-Lantero, and J. A. Soto.

Independent
and hitting sets of rectangles intersecting a diagonal line: Algorithms and
complexity. Discrete & Computational Geometry, 53(2):344–365, 2015.

[9] R. G. Downey and M. R. Fellows. Parameterized complexity, volume 3.

Springer Heidelberg, 1999.

[10] A. Ene, S. Har-Peled, and B. Raichel. Geometric Packing under Non-

uniform Constraints. CoRR, abs/1107.2, 2011.

[11] U. Faigle and W. M. Nawijn. Note on scheduling intervals on-line. Discrete

Applied Mathematics, 58(1):13–17, 1995.

[12] M. R. Fellows, D. Hermelin, F. Rosamond, and S. Vialette. On the pa-
rameterized complexity of multiple-interval graph problems. Theoretical
Computer Science, 410(1):53–61, 2009.

25

[13] J. Flum and M. Grohe. Parameterized Complexity Theory. Springer, 2006.

[14] A. Gy´arf´as and J. Lehel. Covering and coloring problems for relatives of

intervals. Discrete Mathematics, 55(2):167–180, 1985.

[15] H. Kong, Q. Ma, T. Yan, and M. D. F. Wong. An optimal algorithm for
ﬁnding disjoint rectangles and its application to pcb routing. In Proceedings
of the 47th Design Automation Conference, DAC ’10, pages 212–217, New
York, NY, USA, 2010. ACM.

[16] Q. Ma, H. Kong, M. D. Wong, and E. F. Young. A provably good ap-
proximation algorithm for rectangle escape problem with application to
pcb routing.
In Proceedings of the 16th Asia and South Paciﬁc Design
Automation Conference, pages 843–848. IEEE Press, 2011.

[17] R. Niedermeier. Invitation to Fixed-Parameter Algorithms. Oxford Univer-

sity Press, 2006.

[18] L. Palios. Connecting the maximum number of nodes in the grid to the
boundary with nonintersecting line segments. J. Algorithms, 22(1):57–92,
Jan. 1997.

[19] A. B. Roy, S. Govindarajan, N. Misra, and S. Shetty. On the d-runaway
rectangle escape problem. In Proceedings of the 26th Canadian Conference
on Computational Geometry, CCCG 2014, Halifax, Nova Scotia, Canada,
2014, 2014.

[20] C. D. Toth, J. O’Rourke, and J. E. Goodman. Handbook of discrete and

computational geometry. CRC press, 2004.

26

