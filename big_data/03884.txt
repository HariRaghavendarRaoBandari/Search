Grounding Recursive Aggregates: Preliminary Report

Martin Gebser1,3, Roland Kaminski3, and Torsten Schaub2,3⋆

1 Aalto University, HIIT

2 INRIA Rennes

3 University of Potsdam

Abstract. Problem solving in Answer Set Programming consists of two steps,
a ﬁrst grounding phase, systematically replacing all variables by terms, and a
second solving phase computing the stable models of the obtained ground pro-
gram. An intricate part of both phases is the treatment of aggregates, which are
popular language constructs that allow for expressing properties over sets. In
this paper, we elaborate upon the treatment of aggregates during grounding in
gringo series 4. Consequently, our approach is applicable to grounding based
on semi-naive database evaluation techniques. In particular, we provide a series
of algorithms detailing the treatment of recursive aggregates and illustrate this by
a running example.

1 Introduction

Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive
database evaluation techniques [3,4] for avoiding duplicate work during grounding.
Grounding is seen as an iterative bottom-up process guided by the successive expansion
of a program’s Herbrand base, that is, the set of variable-free atoms constructible from
the signature of the program at hand. During this process, a ground rule is only pro-
duced if its positive body atoms belong to the current Herbrand base, in which case its
head atom is added to the current Herbrand base. The basic idea of semi-naive database
evaluation is to focus this process on the new atoms generated at each iteration in order
to avoid reproducing the same ground rules. This idea is based on the observation that
the production of a new ground rule relies on the existence of an atom having been new
at the previous iteration. Accordingly, a ground rule is only produced if its positive body
contains at least one atom produced at the last iteration.

In what follows, we show how a grounding framework relying upon semi-naive
database evaluation techniques can be extended to incorporate recursive aggregates. An
example of such an aggregate is shown in Table 1, giving an encoding of the Company
Controls Problem [5]: A company X controls a company Y , if X directly or indirectly
controls more than 50% of the shares of Y . The aggregate sum + implements summa-
tion over positive integers. Notably, it takes part in the recursive deﬁnition of controls/2
in Table 1. A corresponding problem instance is given in Table 2. Note that a systematic
instantiation of the four variables in Table 1 with the eight constants in Table 2 results in
64 ground rules. However, taken together, the encoding and the instance are equivalent
to the program in Table 3, which consists of four ground rules only. In fact, all liter-

⋆ Afﬁliated with Simon Fraser University, Canada, and IIIS Grifﬁth University, Australia.

6
1
0
2

 
r
a

 

M
2
1

 
 
]
I

A
.
s
c
[
 
 

1
v
4
8
8
3
0

.

3
0
6
1
:
v
i
X
r
a

controls (X, Y ) ← sum +{S : owns(X, Y, S);

S, Z : controls (X, Z), owns(Z, Y, S)} > 50

∧ company (X) ∧ company (Y ) ∧ X 6= Y

Table 1. Company Controls Encoding

company(c1).

company (c2).

company (c3).

company (c4).

owns(c1, c2, 60).

owns(c1, c3, 20).

owns(c2, c3, 35).

owns(c3, c4, 51).

Table 2. Company Controls Instance

als in Table 3 can even be evaluated in view of the problem instance, which moreover
allows us to evaluate the aggregate atoms, so that the grounding of the above com-
pany controls instance boils down to the four facts controls(c1, c2), controls(c3, c4),
controls(c1, c3), and controls(c1, c4).

Accordingly, the goal of this paper is to elaborate upon the efﬁcient computation
of the relevant grounding of programs with recursive aggregates. Section 2 starts with
recalling the formal preliminaries from [6]. Section 3 provides basic grounding algo-
rithms (cf. [1]), paving the way for the more sophisticated algorithms addressing recur-
sive aggregates in Section 4. We summarize our contribution and relate it to the state of
the art in Section 5. The developed approach is implemented in gringo series 4.

2 Formal Preliminaries

This section recalls the formal preliminaries regarding the syntax and semantics of
gringo’s input language, developed in [6].

2.1 Syntax

Alphabet. We consider numerals, (symbolic) constants, variables, and aggregate names,
along with the symbols

6=
⊥

,

;

<

∼

:

>

∧

(

≤
∨

)

≥ 4
←

{

}

(1)
(2)
(3)

Numerals are strings of numbers optionally preceded with a minus symbol. Constants
are strings of letters, underscores, and numbers starting with a lowercase letter. Vari-
ables are strings of letters, underscores, and numbers starting with an uppercase letter.5

Terms. Numerals, constants, and variables are terms. Given a constant f and a term
tuple t, f (t) is a term as well. A variable-free term is said to be ground.

4 Equality is not included here because it is treated specially in gringo; a description is beyond

the scope of this paper.

5 We use _ to denote anonymous variables, i.e., each _ stands for unique variable.

controls (c1, c2) ← sum +{60 : owns(c1, c2, 60)} > 50

∧ company (c1) ∧ company (c2) ∧ c1 6= c2

controls (c3, c4) ← sum +{51 : owns(c3, c4, 51)} > 50

∧ company (c3) ∧ company (c4) ∧ c3 6= c4

controls (c1, c3) ← sum +{20 : owns(c1, c3, 20);

35, c2 : controls (c1, c2), owns(c2, c3, 35)} > 50

∧ company (c1) ∧ company (c3) ∧ c1 6= c3

controls (c1, c4) ← sum +{51, c3 : controls (c1, c3), owns(c3, c4, 51)} > 50

∧ company (c1) ∧ company (c4) ∧ c1 6= c4

Table 3. Relevant Grounding of Company Controls

Interpretation of numerals and aggregates. A numeral n corresponds to the integer n.
There is a total order on all ground terms extending that on numerals, that is, for any
integers m and n, m ≤ n if m ≤ n.

For a ground term tuple t, weight (t) is n, if the ﬁrst element of t is a numeral of

form n, otherwise it is 0.

Each aggregate name α is associated with a function bα from the set of sets of ground
term tuples into the set of ground terms. Given a set T of ground term tuples, we con-
sider the aggregate names/functions deﬁned by

– dsum(T ) = Σt∈T weight (t), if the subset of tuples with non-zero weights is ﬁnite,
– \sum +(T ) = Σt∈T,weight (t)>0weight (t), if the subset of tuples with positive

and 0 otherwise;

weights is ﬁnite, and ∞ otherwise.6

Atoms and literals. Symbolic atoms have the form p(t) where p is a constant and t is a
term tuple. Comparison atoms have form u1 ≺ u2 where u1 and u2 are terms. We use
atom ⊥ to denote a comparison atom that is false (e.g., 0 > 0), and use ⊤ analogously.
Simple literals have form a or ∼a where a is a symbolic or comparison atom.

Aggregate atoms have form

α{t1 : L1; . . . ; tn : Ln} ≺ s

(4)

where

– n ≥ 0
– α is an aggregate name
– each ti is a term tuple
– each Li is a tuple of simple literals
– ≺ is one of the symbols (1)
– s is a term, also called guard

6 n < ∞ holds for any numeral n.

Finally, literals have the form a or ∼a where a is either a symbolic, comparison, or
aggregate atom.7

Rules and programs. Rules are of form h ← l1 ∧ · · · ∧ ln, where n ≥ 0, h is a symbolic
atom, and each li is a literal. A program is a ﬁnite set of rules.

Miscellaneous deﬁnitions. We use the following projection functions on rules.

– head(r) = h in a rule r of the above form
– body(r) = {l1, . . . , ln} in a rule r of the above form
– body+(r) = {a ∈ body(r) | a is a symbolic atom}
– body−(r) = {a | ∼a ∈ body(r), a is a symbolic atom}
– body±(r) = body+(r) ∪ body−(r)

In the following, some body literals are marked. The binary relation r † l holds if

the literal l ∈ body(r) of rule r is marked. Marked body literals are indicated by l†.

A substitution is a mapping from variables to (ground) terms. We represent substi-
tutions by sets of form {x1 7→ t1, . . . , xn 7→ tn} where n ≥ 0, each xi is a variable,
and each ti is a ground term. A substitution σ of the above form applied to a literal l,
written lσ, replaces all occurrences of variables xi in l with corresponding terms ti.

Moreover, we associate in what follows each occurrence of an aggregate in a logic
program with a unique identiﬁer. We use αi, xi, and si to refer to the aggregate func-
tion, tuple of global variables, and guard of the aggregate occurrence identiﬁed by i.
g refers to the ground guard where the variables listed in tuple xi are
Furthermore, (si)xi
replaced with the corresponding terms in tuple g in si.

An aggregate α together with a relation ≺ is monotone, if for any sets T1 ⊆ T2 of

ground term tuples and ground term s, we have that α(T1) ≺ s implies α(T2) ≺ s.

2.2 Semantics

The semantics of programs rests upon a translation into (inﬁnitary) propositional for-
mulas along with their stable models [7].

Ground simple literals are mapped via τ on propositional atoms as follows.

– τ (a) = a for (ground) symbolic atom a
– τ (t1 ≺ t2) is ⊤, if the relation ≺ holds between t1 and t2, and ⊥ otherwise
– τ (∼a) = ¬τ (a) for a literal ∼a

Global variables. A variable is global

– in a simple literal, if it occurs in the literal
– in an aggregate literal, if it occurs in the guard
– in a rule, if it is global in the head or a body literal

7 gringo as well as its semantic underpinnings in [6] also allow for double negated literals of

form ∼∼a.

Aggregate literals. The translation τ extends to aggregate atoms a as in (4) as follows.
An instance of an aggregate element t : L is obtained by substituting all its variables
with ground terms. We let τ L stand for the conjunction of applications of τ to the
ground simple literals in L.

Let E be the set of all instances of aggregate elements in a. A set ∆ ⊆ E justiﬁes
a, if the relation ≺ holds between bα{t | (t : L) ∈ ∆} and the guard s. Then, τ a is the
conjunction of formulas V(t:L)∈∆ τ L → W(t:L)∈E\∆ τ L for all sets ∆ ⊆ E that do
not justify a.

A negative aggregate literal ∼a is treated analogous to a negative simple literal.

Rules and programs. An instance of a rule r is obtained by substituting all global
variables with ground terms. Then, τ r is the set of formulas τ l1 ∧ · · · ∧ τ ln → τ h for
all instances h ← l1 ∧ · · · ∧ ln of rule r, and τ P = Sr∈P τ r for a program P .

Stable models. The stable models of a logic program P are the stable models of the
(inﬁnitary) propositional formula τ P [7].

2.3 Safety and Rule Dependency Graph

A global variable is safe in a rule, if it is bound by a positive symbolic literal in the
rule body. A non-global variable is safe in an aggregate element, if it is bound by a
positive symbolic literal in the corresponding aggregate element. A rule is safe, if all
its variables are safe. A program is safe, if all its rules are safe. In what follows, we
consider safe programs only.

The rule dependency graph G = (V, E) of a (normal) logic program P is
a directed graph such that V = P and E = {(r1, r2) ∈ V × V |
l ∈
body±(r2), head(r1) uniﬁes l}.8 The positive rule dependency graph G+ is deﬁned
similarly but considers edges induced by positive literals only (l ∈ body+(r2)).

3 Basic Grounding Algorithms

This section provides some basic algorithms underlying semi-naive evaluation based
grounding (see also [1]). All of them apply to normal logic programs and are thus
independent of the treatment of recursive aggregates described in the next section.

We illustrate the basic algorithms by means of a Hamiltonian cycle example9 using
the graph in Figure 1. This graph is represented by the problem instance in Table 4.
The actual problem encoding is given in (5) to (13) below. The resulting Hamiltonian
cycle is expressed through instances of predicate path/2; a detailed discussion of such
encodings can be found in [8,9,10].

8 Uniﬁcation assumes that variables in r1 and r2 are distinct, even if they have the same name.
9 https://en.wikipedia.org/wiki/Hamiltonian_path_problem

a

c

b

d

node(a).

node(b).

node(c).

node(d).

start (a).

edge(a, b).

edge(a, c).

edge(b, c).

edge(b, d).

edge(c, a).

edge(c, d).

edge(d, a).

Fig. 1. Hamiltonian Cycle Instance (Graph)

Table 4. Hamiltonian Cycle Instance

path(X, Y ) ← edge(X, Y ) ∧ ∼omit (X, Y )

omit (X, Y ) ← edge(X, Y ) ∧ ∼path(X, Y )

← path(X, Y ) ∧ path(X ′, Y ) ∧ X < X ′
← path(X, Y ) ∧ path(X, Y ′) ∧ Y < Y ′

on_path(Y ) ← path(X, Y ) ∧ path(Y, Z)
← node(X) ∧ ∼on_path(X)

reach(X) ← start(X)
reach(Y ) ← reach(X) ∧ path(X, Y )

← node(X) ∧ ∼reach(X)

(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)

3.1 Analyzing Logic Programs

The function Analyze given in Algorithm 1 takes a logic program P , classiﬁes oc-
currences of recursive symbolic atoms (Ar), and groups rules into components suitable
for successive grounding. The classiﬁcation of atoms can be used to apply on-the-ﬂy
simpliﬁcations in the following algorithms (cf. Algorithm 3).

Analyze ﬁrst determines the strongly connected components of the program’s
dependency graph (Lines 2-3). This graph contains dependencies induced by both pos-
itive and negative literals. The outer loop (Lines 5-10) iterates over its components in
topological order.10 Each component is then further reﬁned in terms of its positive de-
pendency graph (Lines 6-7).

The set Ar of recursive symbolic atoms is determined in Line 9. These are all body
literals whose atom uniﬁes with the head of a rule in the current or a following com-
ponent. Finally, the reﬁned component together with its recursive atoms is appended to
the list L in Line 10. This list is the result of the algorithm returned in Line 11.

Figure 2 shows the dependency graph of the encoding given in (5) to (13). Positive
edges are depicted with solid lines, negative ones with dashed lines. Recursive atoms
are typeset in bold. The negative edge from Component1,2 to Component1,1 is due to
the fact that path(X, Y ) in the negative body of (6) uniﬁes with path(X, Y ) in the head
of (5). Furthermore, the occurrence of path(X, Y ) in (6) is recursive because it induces
an edge from a later component in the topological ordering at hand. In contrast to pos-
itive literals, the recursiveness of negative literals depends on the topological ordering.

10 A component C1 precedes C2 when there is an edge (r1, r2) with r1 ∈ C1 and r2 ∈ C2.

1 function Analyze(P )
2

let G be the dependency graph of P

3

4

5

6

7

8

9

10

11

S be the strongly connected components of G

L ← []
foreach C in S do

let G+ be the positive dependency graph of C

S+ be the strongly connected components of G+

foreach C + in S+ do

let Ar = {a ∈ body±(r2) | r1 ∈ P, r2 ∈ C +, head(r1) uniﬁes a}
(L, P ) ← (L + [(C +, Ar)], P \ C +)

return L

Algorithm 1: Analyze Logic Programs for Grounding

Component1,1:

omit(X, Y ) ← edge(X, Y ) ∧ ∼path(X, Y)

Component1,2:

path(X, Y ) ← edge(X, Y ) ∧ ∼omit(X, Y )

Component2,1:

← path(X, Y ) ∧ path(X ′, Y ) ∧ X < X ′

Component3,1:

← path(X, Y ) ∧ path(X, Y ′) ∧ Y < Y ′

Component4,1:

on_path(Y ) ← path (X, Y ) ∧ path(Y, Z)

Component5,1:

← node(X) ∧ ∼on_path(X)

Component6,1:

reach(X) ← start (X)

Component7,1:

reach(Y ) ← reach(X) ∧ path(X, Y )

Component8,1:

← node(X) ∧ ∼reach(X)

Fig. 2. Hamiltonian Cycle Dependency Graph

For instance, omit (X, Y ) would be recursive in the topological order obtained by ex-
changing Component1,1 and Component1,2. Regarding Component7,1, the occurrence
of reach(X) in the body of (12) is recursive because it uniﬁes with the head of the same
rule. Accordingly, it induces a self-loop in the dependency graph.

3.2 Preparing Components for Grounding

The function Prepare sets up the rules in a component C for grounding w.r.t. its
recursive atoms Ar. To this end, it adds one of the subscripts n, o, or a to the predicate
names of the atoms in the positive rule bodies of a given component.11 These subscripts

11 The alphabet in Section 2 does not allow for predicate names with subscripts. During ground-

ing, we temporarily extend this alphabet with such predicate names.

1 function Prepare(C, Ar)
2

L ← ∅
foreach r in C do

D ← ∅
let S = body+(r) ∩ Ar
foreach p(x) in S do

3

4

5

6

7

8

9

10

11

D ← D ∪ {p(x)}

L ← L ∪

head(r) ← Vq(y)∈D qo(y) ∧ pn(x)
∧ Vq(y)∈body+(r)\(D∪{p(x)}) qa(y)
∧ Vl∈body(r)\body+(r) l
L ← L ∪( head(r) ← Vp(x)∈body+(r) pn(x)
∧ Vl∈body(r)\body+(r) l)



if S = ∅ then

return L

Algorithm 2: Prepare Components

indicate new, old, and all atoms belonging to the current materialization of the Herbrand
base. In turn, they are used in the course of semi-naive database evaluation to avoid
duplicate work when grounding a component w.r.t. an expanding Herbrand base.

The loop in Lines 3-10 iterates over the rules in the component at hand. Each such
rule r is expanded into a set of rules (loop in Lines 6-8) w.r.t. the recursive atoms in
its body (Line 5). In the ﬁrst row of Line 7, predicate names of recursive atoms already
considered (set D) receive subscript o, and the predicate name of the recursive atom
p(x) receives subscript n. In the second row, the recursive atoms not yet considered as
well as non-recursive atoms of the positive body receive subscript a. Finally, in the third
row, the remaining body literals are kept unmodiﬁed. If there are no recursive atoms
(Line 9), then subscript n is added to all positive body elements (ﬁrst row of Line 10).
As in the case with recursive atoms, the remaining body literals are kept unmodiﬁed
(second row).

The result of preparing all components of the dependency graph in Figure 2 is
given in Figure 3. All rules but r8 contain only non-recursive positive body literals,
which are adorned with subscript n. Unlike this, the non-recursive positive body literal
path(X, Y ) in r8 is adorned with a, while only the recursive one, reach(X), receives
subscript n. Since there is only one recursive body atom, only one rule is generated.

3.3 Grounding Rules

The rule grounding algorithm relies upon two auxiliary functions. First, function order
returns a safe body order of a rule body.12 A safe body order of a body {b1, . . . , bn}
is a tuple (b1, . . . , bn) such that {b1, . . . , bi} is safe for each 1 ≤ i ≤ n. For example,

12 The runtime of instantiation algorithms is sensitive to the chosen body order. In the context of

ASP, heuristics for ordering body literals have been studied in [11].

Component1,1:

omit(X, Y ) ← edge n(X, Y ) ∧ ∼path(X, Y)

Component1,2:

path(X, Y ) ← edge n(X, Y ) ∧ ∼omit(X, Y )

Component2,1:

← path n(X, Y ) ∧ path n(X ′, Y ) ∧ X < X ′

Component3,1:

← path n(X, Y ) ∧ path n(X, Y ′) ∧ Y < Y ′

Component4,1:

on_path(Y ) ← path n(X, Y ) ∧ path n(Y, Z)

Component5,1:

← node n(X) ∧ ∼on_path(X)

Component6,1:

reach(X) ← start n(X)

Component7,1:

reach(Y ) ← reachn(X) ∧ path a(X, Y )

Component8,1:

← node n(X) ∧ ∼reach(X)

Fig. 3. Prepared Hamiltonian Cycle Encoding

(r1)

(r2)

(r3)

(r4)

(r5)

(r6)

(r7)

(r8)

(r9)

(p(X), ∼q(X)) is a safe body order, while (∼q(X), p(X)) is not. Second, given a sym-
bolic atom a, a substitution σ, and a set A of ground atoms, function matches(a, σ, A)
returns the set of matches for a in A w.r.t. σ. A match is a ⊆-minimal substitution
σ′ such that aσ′ ∈ A and σ ⊆ σ′. For instance, matches(p(X, Y ), {Y 7→ a},
{p(a, a), p(b, b), p(c, a)}) yields {X 7→ a, Y 7→ a} and {X 7→ c, Y 7→ a}.

With both functions at hand, we assemble the basic algorithm GroundRule for
grounding individual rules in Algorithm 3. Note that the original rule r′ along with its
marking † can be ignored in our context; they are only relevant when treating aggregates
in Section 4.13 The algorithm proceeds along the safe body order determined in Line 20.
If no body literals remain, a ground rule is generated in Line 7 provided that its head
is not among the established facts. Moreover, if the rule in focus has become a fact, its
head is added to Af in Line 8. The remainder constitutes a case analysis upon the type
of the left-most body literal. If b1 is a positive body literal, an instance of b1 is added in
turn to the (partial) ground body B for each match of b1. However, this is only done if
the literal is not marked and the instance does not yet belong to the established facts. If
b1 is a negative body literal, the instance obtained by applying the current substitution
is added to the ground body. Again, this is only done if the literal is not marked, and the
literal is recursive or there is already a derivation for it. Substitutions where the instance
is a fact are skipped altogether. Finally, comparison literals are directly evaluated and
rule instantiation is only pursued if the test was successful.

For illustration, we trace in Figure 4 the application of GroundRule to rule r1,
viz. ‘omit (X, Y ) ← edge n(X, Y ) ∧ ∼path(X, Y )’, from Figure 3. Figure 4 also gives

13 This is the rule before the application of function Prepare. That is, the positive body literals
of r′ are free of subscripts o, n, and a. The conditions r′ 6 † p(x) and r′ 6 † b1 in Line 11 or 15,
respectively, are tautological in this section.

1 function GroundRule(r, Ar, An, Ao, Aa, Af )
2

let r′ be the original version of rule r
G ← ∅
function GroundRule′(B, (b1, . . . , bn), σ)

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

if n = 0 then

if head(r)σ 6∈ Af then

G ← G ∪ {head(r)σ ← B}
Af ← Af ∪ {head(r)σ | B = ∅}
else if b1 = px(x) for x ∈ {o, n, a} then

foreach σ′ ∈ matches(p(x), σ, Ax) do

B′ ← B ∪ {p(x)σ′ | r′ 6 † p(x), p(x)σ′ /∈ Af }
GroundRule′(B′, (b2, . . . , bn), σ′)

else if b1 = ∼a then
if aσ 6∈ Af then

B′ ← B ∪ {b1σ | r′ 6 † b1, a ∈ Ar or aσ ∈ Aa}
GroundRule′(B′, (b2, . . . , bn), σ)

else

if b1σ is true then

GroundRule′(B, (b2, . . . , bn), σ)

// rule instance

// positive literals

// negative literals

// comparison atoms

GroundRule′(∅, order(body(r)), ∅)
return (G, Af )

Algorithm 3: Grounding Rules

edge n(X, Y ) ∼path (X, Y )

omit(X, Y )

Ar = {path(X, Y )}

edge(a, b)

∼path (a, b)

omit(a, b)

edge(a, c)

∼path (a, c)

omit(a, c)

edge(b, c)

∼path (b, c)

omit(b, c)

edge(b, d)

∼path (b, d)

omit(b, d)

edge(c, a)

∼path (c, a)

omit(c, a)

edge(c, d)

∼path (c, d)

omit(c, d)

edge(d, a)

∼path (d, a)

omit(d, a)

edge(b, c), edge(b, d),

edge(c, a), edge(c, d),



edge(a, b), edge(a, c),

edge(d, a), . . .

Af =

Ao = ∅
An = Af
Aa = Af

Fig. 4. Call to GroundRule(r1, Ar, An, Ao, Aa, Af )

the contents of the respective sets of atoms (when tackling the very ﬁrst component in
Figure 3). The header in Figure 4 contains the ordered body followed by the rule head.
Starting with the ﬁrst positive body literal edge n(X, Y ) results in eight distinct matches
of edge(X, Y ) in An. The atoms resulting from a set of matches are connected with
undirected edges in Figure 4. Note that none of the instances of edge(X, Y ) is added to

1 function Ground(P, Af )
2

(Pg, Aa) ← (∅, Af )
foreach (C, Ar) in Analyze(P ) do

3

4

5

6

7

8

9

10

11

12

(An, Ao) ← (Aa, ∅)
repeat

A∆ ← ∅
foreach r in Prepare(C, Ar) do

g, Af ) ← GroundRule(r, Ar, An, Ao, Aa, Af )

(P ′
(A∆, Pg) ← (A∆ ∪ {head(rg) | rg ∈ P ′

g}, Pg ∪ P ′
g)

(An, Ao, Aa) ← (A∆ \ Aa, Aa, A∆ ∪ Aa)

until An = ∅ or {r ∈ C | body+(r) ∩ Ar 6= ∅} = ∅

return Pg

Algorithm 4: Grounding Logic Programs

the (empty) body, since they are all found to be facts. Looking at the trace for the ﬁrst
match, we observe that GroundRule’ is next called with the empty body, the singleton
(∼path(X, Y )), and substitution {X 7→ a, Y 7→ b}. Given that the atom path(a, b) is
not a fact and recursive, no simpliﬁcations apply, as indicated by underlining, and the
instance is added to the body. The following call with body {∼path(a, b)}, the empty
tuple, and the same substitution results in the ground rule ‘omit (a, b) ← ∼path(a, b)’.
Analogously, the other six matches result in further instances of r1.

3.4 Grounding Logic Programs

The above functions are put together in Algorithm 4 for grounding entire (normal) logic
programs. The function Ground takes a partition of a program into genuine rules P
and atoms Af stemming from facts, and returns (upon termination) a set of ground in-
stantiated rules Pg. The latter is incrementally constructed by following the topological
order of components determined by Analyze. Then, in turn, each adorned rule in the
prepared component is instantiated via GroundRule. The loop in Lines 5-11 is exe-
cuted only once whenever the component is free of recursive positive body literals, and
otherwise until no new (head) atoms are forthcoming. This is accomplished by manip-
ulating the following sets of atoms:

– Aa the set of all relevant atoms up to the current grounding step,
– An ⊆ Aa the set of atoms atoms newly instantiated in the previous grounding step,
– Ao = Aa \ An the set of atoms that are not new w.r.t. the previous step,
– A∆ the set of atoms resulting from the current grounding step, and
– Af ⊆ Aa ∪ A∆ the set of atoms having a corresponding fact in Pg.

The set Aa comprises the relevant Herbrand base when the algorithm terminates.

For illustration, let us trace Ground in Figure 5 when grounding the last but one
component from Figure 3. To be more precise, this deals with the prepared version of
Component7,1 containing rule r8 only, viz. ‘reach(Y ) ← reachn(X) ∧ path a(X, Y )’.
The recursive nature of this rule results in three iterations of the loop in Lines 5-11.

reach n(X)

path a(X, Y )

reach(Y )

Ar = {reach (X)}

A1
A1

f = {reach (a), . . . }
o = ∅

n =

a = A1
n

A1

A1

1

1.1



reach(a)

path(a, b)

reach(b)

path(a, c)

reach(c)

reach(b)

path(b, c)

reach(c)

path(b, d)

reach(d)

reach(c)

path(c, a)

reach(a)

path(c, d)

reach(d)

reach(d)

path(d, a)

reach(a)

path(a, b), path(a, c),

path(b, c), path(b, d),

path(c, a), path(c, d),

path(d, a), reach (a), . . .

A2
A2
A2
A2

f = A1
f
o = A1
a
n = {reach(b), reach (c)}
a = A1

a ∪ A2
n

A3
A3
A3
A3

f = A2
f
o = A2
a
n = {reach(d)}
a = A2

a ∪ A3
n

1.2

1.3

Fig. 5. Grounding Component7,1

Accordingly, we index the atom sets in Figure 5 to reﬂect their state in the respective
iteration. Moreover, we only provide the parts of Ao, An, Aa, and Af that are relevant
to grounding r8. Otherwise, conventions follow the ones in Figure 4.

At the ﬁrst iteration, the atom reach(a) (obtained from grounding Component6,1)

is used to obtain rule instances

reach(b) ← path(a, b)

reach(c) ← path(a, c)

Note that reach(a) is removed from both rule bodies because it belongs to the estab-
lished facts. Moreover, this iteration yields the new atoms reach(b) and reach(c), which
are used in the next iteration to obtain the four rule instances

reach(c) ← reach(b) ∧ path(b, c)

reach(d) ← reach(b) ∧ path(b, d)
reach(a) ← reach(c) ∧ path(c, a)

reach(d) ← reach(c) ∧ path(c, d)

Unlike above, no simpliﬁcations can be performed because no facts are involved. The
iteration brings about a single new atom, reach(d), which yields the rule instance

reach(a) ← reach(d) ∧ path(d, a)

1 function Rewrite(P )
2

Q ← ∅
// in the loop below, ⋄ ∈ {ǫ, ∼} stands for the sign of the aggregate literal
foreach r in P with a ∈ body(r), a = ⋄α{t1 : L1; . . . ; tn : Ln} ≺ s do

3

4

5

6

7

8

9

let i be a unique identiﬁer

x be the global variables in a

replace occurrence a in P with ⋄aggr i(x)

B(L) =Vl∈body(r)\L,l is a simple literal l†
Q ← Q ∪ {accu i(x, neutral ) ←bα(∅) ≺ s ∧ B(∅)}
∪ {accu i(x, tuple(tj)) ←Vl∈Lj

∪ {aggr i(x) ← accu i(x, _) ∧ ⊥}

l ∧ B(Lj) | 1 ≤ j ≤ n}

return P ∪ Q

Algorithm 5: Rewrite Logic Programs

This iteration produces no new atoms and ends the instantiation of Component7,1.

The other components are grounded analogously but within a single iteration due
to their lack of recursive positive body literals. This is enforced by the second stop
criterion in Line 11 of Algorithm 4.

4 Grounding Recursive Aggregates

Having laid the foundations of grounding normal logic programs, we now continue
with the treatment of recursive aggregates. The idea is to translate aggregate atoms into
normal logic programs, roughly one rule per aggregate element, and then to reuse the
basic grounding machinery as much as possible. In addition, some aggregate-speciﬁc
propagation takes place. At the end, the resulting aggregate instances are re-assembled
from the corresponding rules.

4.1 Rewriting Logic Programs with Aggregates

The function Rewrite given in Algorithm 5 takes as input a logic program (possibly
with recursive aggregates) and rewrites it into a normal logic program with additional
predicates capturing aggregates and aggregate elements.14

Each aggregate occurrence is replaced with an atom of form aggr i(x) in Line 7,
where i is a unique identiﬁer associated with the aggregate occurrence and x are the
global variables occurring in the aggregate. The idea is that each atom over predi-
cate aggr i in the grounding of the rewriting corresponds to a ground aggregate, which
is substituted for the atom in the ﬁnal grounding.

To represent aggregate elements like tj : Lj, auxiliary rules deﬁning atoms of form
accu i(x, t) are added in Line 8, where x are the global variables as above and t is the
tuple that is aggregated (or the special constant neutral). Here, the idea is to inspect

14 We assume that predicates aggr i and accu i are not used elsewhere in the program.

controls(X, Y ) ← aggr 1(X, Y ) ∧ B

accu 1(X, Y, neutral ) ← 0 > 50 ∧ B†
accu 1(X, Y, tuple(S)) ← owns(X, Y, S) ∧ B†

accu 1(X, Y, tuple(S, Z)) ← controls (X, Z) ∧ owns(Z, Y, S) ∧ B†

aggr 1(X, Y ) ← accu 1(X, Y, _) ∧ ⊥

where B = company (X) ∧ company (Y ) ∧ X 6= Y

Table 5. Rewritten Company Controls Encoding

the grounding for rules with atoms over accu i in the head. If enough such atoms are
accumulated to satisfy an aggregate, then corresponding atoms over aggr i are added to
the Herbrand base to further ground the program.

The ﬁrst rule in Line 8 handles the special case that the aggregate is satisﬁed for
an empty set of tuples (e.g., anti-monotone aggregates like sum +{t : L} ≤ s). Its
body contains a comparison literal that checks whether the empty aggregate is satisﬁed.
Furthermore, we have to make sure that the rule is safe so that it can be instantiated.
For this purpose, all simple literals of the rule in which the aggregate i occurs are
added to the rule body (via function B). Hence, if the original rule is safe, the auxiliary
rule is also safe because global variables are bound by positive symbolic literals only.
Furthermore, literals responsible for binding global variables are marked (via †).

The second set of rules in Line 8 is in charge of accumulating tuples of aggregate
elements. The rule body contains the literals of the condition of the aggregate element
as well as marked literals necessary for ensuring the rule’s safety. Remember that the
resulting ground rules represent ground aggregate atoms, where the marking is used to
distinguish literals not belonging to the conditions of reconstituted aggregate elements.
Finally, one last rule is added in Line 8 for ensuring that the dependencies induced
by the aggregate are kept intact. Since this rule contains ⊥, it never produces instances
though.

The result of rewriting the company controls encoding from Table 1 is given in
Table 5. The global variables in the (single) aggregate are X and Y , which occur ﬁrst in
all atoms over aggr 1/2 and accu 1/3. Since the empty aggregate is not satisﬁed, the rule
accumulating the neutral tuple never produces any instances (and could in principle be
dropped from the rewriting).

4.2 Analyzing and Preparing Logic Programs with Aggregates

Figure 6 captures the result of function Analyze with Prepare called for each
component of the rewritten company controls encoding in Table 5. The rules in
Component1,1 and Component2,1 depend on facts only, and thus both induce a singleton
component. Component3,1 contains the remaining rules. The aggregate of the company
controls encoding is recursive in this component in view of the atom controls(X, Z) in
its second aggregate element. Note that not all aggregate elements are involved in this
recursion, given that direct shares are accumulated via the rule in Component2,1.

Component1,1:

accu 1(X, Y, neutral ) ← 0 > 50 ∧ B†
n

Component2,1:

accu 1(X, Y, tuple(S)) ← owns n(X, Y, S) ∧ B†
n

Component3,1:

aggr 1(X, Y ) ← accu1n(X, Y, _) ∧ ⊥

controls (X, Y ) ← aggr1n(X, Y) ∧ Ba

accu 1(X, Y, tuple(S, Z)) ← controlsn(X, Z)

∧ owns a(Z, Y, S) ∧ B†
a

where Bx = company x(X) ∧ company x(Y ) ∧ X 6= Y

Fig. 6. Dependency Graph for Company Controls Program

1 function Propagate(I, r, Aa, Af )
2

A∆ ← ∅
foreach i, g where i ∈ I and accu i(g, t) ∈ Aa do

3

4

5

6

7

8

9

10

11

let Tf = {t | accu i(g, tuple(t)) ∈ Af , t is relevant for αi}
Ta = {t | accu i(g, tuple(t)) ∈ Aa, t is relevant for αi}
g is true then

if exists Tf ⊆ T ⊆ Ta wherebαi(T ) ≺i (si)xi
if (aggregate i is monotone andbαi(Tf ) ≺i (si)xi

or (not r and Ta \ Tf = ∅) then
Af ← Af ∪ {aggr i(g)}

g )

A∆ ← A∆ ∪ {aggr i(g)}

return (A∆, Af )

Algorithm 6: Propagation of Aggregates

4.3 Propagating Aggregates

The function Propagate inspects the partial grounding of an aggregate instance in
view of its grounded aggregate elements. To this end, it checks atoms over predicate
accu i obtained during grounding. The loop in Lines 3-10 iterates over the given ag-
gregate indices I and tuples of global variables stored in atoms over predicate accu i
appearing among the atoms in Aa. Whenever there are enough tuples captured by such
atoms to satisfy the corresponding aggregate, Propagate adds atoms over predicate
aggr i to A∆ for further instantiation. While Line 4 collects tuples that are necessar-
ily accumulated by the aggregate function, Line 5 gathers tuples whose conditions can
possibly hold. Also note that the relevance check skips tuples that do not change the
result of an aggregate function.15 For sum aggregates, this amounts to excluding zero-
weight tuples by stipulating weight (t) 6= 0. Given these sets of tuples, Line 6 checks
whether the aggregate can be satisﬁed using the tuples accumulated so far. For sum ag-

15 For non-recursive aggregates, where the ﬂag r is false, Line 8 checks whether Ta \ Tf is empty.

This is why only relevant tuples are gathered.

1 function Assemble(Pg)
2

foreach aggr i(g) occurring in Pg do

// below, body(r) is assumed to convert to a tuple of literals
let E = {t : body(r) | r ∈ Pg, head(r) = accu i(g, tuple(t))}
replace all occurrences of aggr i(g) in Pg with αi(E) ≺i (si)xi

g

3

4

5

6

remove all rules with atoms over accu i in the head from Pg
return Pg

Algorithm 7: Assembling Aggregates

gregates, this can be tested by adding up the weights of factual tuples and, on the one
hand, the negative weights to obtain a minimum, min, or the positive weights to obtain
a maximum, max . Then, depending on the relation, the aggregate is satisﬁable

– if max ≺ (si)xi
– if min ≺ (si)xi
– if min ≺ (si)xi

g is true for ≺ ∈ {≥, >},
g is true for ≺ ∈ {≤, <}, or
g or max ≺ (si)xi

g is true for ≺ ∈ {6=}.

If the test in Line 6 succeeds, the ground aggregate atom is added to the new atoms in
Line 10. In addition, given a non-recursive or monotone aggregate, the corresponding
ground aggregate atom is added to Af whenever the aggregate is found to be true. At
this point, a non-recursive aggregate is true, if all its elements are facts (Line 8), and a
monotone aggregate is true, if enough facts to satisfy the aggregate have been accumu-
lated (Line 7). Finally, the sets of new and factual atoms are returned in Line 11.

4.4 Assembling Aggregates

After Rewrite has decomposed aggregate atoms into normal program rules,
Assemble given in Algorithm 7 reconstructs their grounded counterparts from the
rewritten ground program. That is, all occurrences of atoms of form aggr i(g) are re-
placed by their corresponding aggregates. In doing so, the aggregate elements are re-
constructed from rules with head atoms accu i(g, tuple(t)) in Line 3, where an element
consists of the term tuple t along with the condition expressed by the rule body.16 The
actual replacement takes place in Line 4, followed by the deletion of obsolete rules in
Line 5. Finally, the reconstructed ground program is returned in Line 6.

4.5 Grounding Logic Programs with Aggregates

Algorithm 8 extends the Ground function in Algorithm 4 to logic program with
aggregates. To this end, the extended Ground function uses algorithms Rewrite,
Propagate, and Assemble from the previous subsections. The changes in the algo-
rithm are highlighted with a gray background, while other parts are left untouched.

The ﬁrst change is in Line 3, where function Rewrite is called to turn the logic
program P into a normal logic program before calling Analyze. Then, Lines 4 and 5

16 Recall that marked literals, added for safety, are stripped off by GroundRule in Algorithm 3.

1 function Ground(P, Af )
2

(Pg, Aa) ← (∅, Af )
foreach (C, Ar) in Analyze(Rewrite(P )) do
let I = {i | aggr i occurs in a rule head in C}

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

Ir = {i | r ∈ C, head(r) = accu i(x, t), a ∈ body+(r) ∩ Ar, r 6 † a}

(An, Ao) ← (Aa, ∅)
repeat

A∆ ← ∅
foreach r in Prepare(C, Ar) do

g, Af ) ← GroundRule(r, Ar, An, Ao, Aa, Af )

(P ′
(A∆, Pg) ← (A∆ ∪ {head(rg) | rg ∈ P ′

g}, Pg ∪ P ′
g)

if A∆ ⊆ Aa then

(A∆, Af ) ← Propagate(I \ Ir, false, Aa, Af )

if A∆ ⊆ Aa then

(A∆, Af ) ← Propagate(I ∩ Ir, true, Aa, Af )

(An, Ao, Aa) ← (A∆ \ Aa, Aa, A∆ ∪ Aa)

until An = ∅ or {r ∈ C | body+(r) ∩ Ar 6= ∅} = ∅

return Assemble(Pg)

Algorithm 8: Grounding Logic Programs with Aggregates

are added, just before the loop in charge of grounding each component. Here, all ag-
gregate indices that have to be propagated during the instantiation of a component are
collected. First, all indices for which a rule with aggr i in the head appears in the com-
ponent are gathered in I. Remember that these rules do not contribute instances because
⊥ belongs to their bodies (cf. third row in Line 8 of Algorithm 5). Instead, Propagate
is adding atoms over aggr i to A∆. Second, in Line 5, aggregate indices associated with
recursive aggregates are collected, where the (positive) recursion involves some aggre-
gate element indicated by a rule with head atom accu i(x, t), yet without considering
the auxiliary body part marked with †.

The collected indices are in Lines 12-15 used to propagate the corresponding ag-
gregates in the current component. Propagation of aggregates is triggered whenever
no more new atoms are obtained in the grounding loop in Lines 9-11. First, non-
recursive aggregates I \ Ir are instantiated. At this point, if there is at least one ground
atom of form accu i(g, t) ∈ Aa, all aggregate elements of the corresponding aggre-
gate (uniquely determined by the terms g for global variables) have been gathered. The
aggregate can thus be propagated, and function Propagate can apply additional sim-
pliﬁcations (cf. Line 8 in Algorithm 6). Afterwards, recursive aggregates I ∩ Ir are
propagated in Line 15. In this case, we cannot assume that all aggregate elements have
already been accumulated, and propagation can thus not use all of the simpliﬁcations
applicable to non-recursive aggregates, where the distinction is implemented by set-
ting the second argument of Propagate to true. Finally, in Line 18, aggregates are
reconstructed from the intermediate grounding by calling function Assemble.

c†
n(X)

c†
n(Y )

X 6= Y

a1(X, Y, n)

0 > 50

×

on(X, Y, S)

o(c1, c2, 60)

o(c1, c3, 20)

o(c2, c3, 35)

o(c3, c4, 51)

c†
n(X)
c(c1)

c(c1)

c(c2)

c(c3)

c†
n(Y )
c(c2)

c(c3)

c(c3)

c(c4)

X 6= Y

c1 6= c2

c1 6= c3

c2 6= c3

c3 6= c4

X 6= Y
c†
a(Y )

a1(X, Y, t(S))

a1(c1, c2, t(60))

a1(c1, c3, t(20))

a1(c2, c3, t(35))

a1(c3, c4, t(51))

g1(X, Y )

r(X, Y )

X 6= Y

a1(X, Y, t(S, Z))

1

1.1

2

2.1

3

3.1

3.2

3.3

3.4

3.5

3.6

3.7

3.8

3.9

⊥

a1n(X, Y, _)

c†
a(X)

c†
g1n(X, Y )
a(Y )
c†
rn(X, Z)
a(X)
Propagate: {g1(c1, c2), g1(c3, c4)}

oa(Z, Y, S)

c(c1)

c(c3)

c(c2)

c(c4)

c1 6= c2

c3 6= c4

r(c1, c2)

r(c3, c4)

×

g1(c1, c2)

g1(c3, c4)

×

×

×

r(c1, c2)

o(c2, c3, 35)

c(c1)

c(c3)

c1 6= c3

a1(c1, c3, t(35, c2))

r(c3, c4)
Propagate: {g1(c1, c3)}

×

×

g1(c1, c3)

c(c1)

c(c3)

c1 6= c3

r(c1, c3)

×

×

×

r(c1, c3)
o(c3, c4, 51)
Propagate: {g1(c1, c4)}

×

c(c1)

c(c4)

c1 6= c4

a1(c1, c4, t(51, c3))

g1(c1, c4)

c(c1)

c(c4)

c1 6= c4

r(c1, c4)

×

×

×

r(c1, c4)

×

a1 = accu 1, g1 = aggr 1, r = controls, c = company, o = owns, n = neutral , t = tuple

Fig. 7. Grounding Company Controls

Figure 7 traces the whole grounding process of the rewritten company controls en-
coding given in Figure 6. The grounding of each component is separated by a horizontal

double line, and the instantiation of a component is shown analogously to Figure 5. Due
to lack of space, we refrain from giving sets Ar, An, Ao, and Aa. For each component,
indicated by its number on the right, the contained rules are listed ﬁrst, followed by
grounding iterations for the component in focus. Each iteration is separated by a solid
line and indexed with an iteration number on the right, where (instances of) the three
rules in Component3,1 are separated by dashed lines. The symbol × indicates that a
body literal does not match, which corresponds to the case that the GroundRule’
function in Algorithm 3 backtracks.

The grounding of Component1,1 produces no rule instances because the comparison
atom 0 > 50 is false. By putting this literal ﬁrst in the safe body order, the remaining
rule body can be completely ignored. Next, in the grounding of Component2,1, direct
shares given by facts over owns/3 are accumulated, where the obtained atoms over
accu 1/3 are classiﬁed as facts as well. Then, we trace the grounding of Component3,1.
In the ﬁrst iteration, none of the rules produces instances because there are no atoms
over controls/2 and aggr 1/2 yet. Hence, aggregate propagation is triggered, resulting in
aggregate atoms aggr 1(c1, c2) and aggr 1(c3, c4), for which enough shares have been
accumulated upon grounding Component2,1. Note that, since the aggregate is mono-
tone, both atoms are established as facts. In the second iteration, the newly obtained
aggregate atoms are used to instantiate the second rule of the component, leading to
new atoms over controls/2. Observe that, by putting aggr 1(X, Y ) ﬁrst in the safe body
order, GroundRule can instantiate the rule without backtracking. In the third iter-
ation, the newly obtained atoms over controls/2 yield accu 1(c1, c3, t(35, c2)) via an
instance of the third rule of the component, which in turn leads to the aggregate atom
aggr 1(c1, c3). The following iterations proceed in a similar fashion until no new tuples
are accumulated and the grounding loop terminates. Conﬁned to the original predicate
controls/2, the instantiation generates four atoms, controls(c1, c2), controls(c3, c4),
controls(c1, c3), and controls(c1, c4), all of which are produced as facts.

Note that the utilized safe body order affects the amount of backtracking in rule
instantiation [11]. One particular strategy used in gringo is to prefer recursive atoms
with subscript n when ordering a rule body. As seen in the grounding of Component3,1
above, this helps to avoid backtracking upon generating new rule instances. Further-
more, for the company controls encoding, simpliﬁcations ensure that the program is
evaluated to facts. In general, this is guaranteed for programs with stratiﬁed negation
and monotone aggregates only [12].

5 Discussion

We presented an algorithmic framework for grounding logic programs based on
semi-naive database evaluation techniques. Our framework, which is implemented in
gringo series 4, constitutes the ﬁrst approach capturing full-ﬂedged aggregates under
Ferraris’ semantics [13,6]. While semi-naive evaluation techniques trace back to the
ﬁeld of database systems [3,4], their introduction to grounding in ASP was pioneered
by the dlv system [14], laying out basic semi-naive grounding algorithms (cf. [1]) sim-
ilar to those in Section 3. Given this proximity, our grounding techniques for handling
recursive aggregates could be adopted within dlv, which is so far restricted to strati-

ﬁed aggregates. Other grounding approaches are pursued in gidl [15], lparse [16],
and earlier versions of gringo [17,18,2]. The latter two also support recursive (con-
vex) aggregates but are limited by the necessity to bind non-global variables by domain
predicates, given that programs have to be ω- [16] or λ-restricted [17], respectively. Un-
like this, our approach merely relies on the safety condition and no further restriction is
imposed on the input language.

Regarding the implementation, our approach aims at reusing existing grounding
techniques for (normal) logic programs. To this end, programs with aggregates are
rewritten, and conventional semi-naive evaluation is extended with a propagation step
for aggregates. Eventually, ground aggregates are reconstructed from the obtained rule
instances in a post-processing step. While the present paper considered sum and sum +
aggregates only, our approach is applicable to any aggregate function. In fact, count,
min, and max aggregates are also supported in gringo series 4, and it is easily
amenable to further aggregates (by extending the Propagate function).

Acknowledgments This work was funded by AoF (grant 251170), DFG (grants SCHA
550/8 and 550/9), as well as DAAD and AoF (joint project 57071677 / 279121).

References

1. Faber, W., Leone, N., Perri, S.: The intelligent grounder of DLV. [19] 247–264
2. Gebser, M., Kaminski, R., König, A., Schaub, T.: Advances in gringo series 3. In Delgrande,
J., Faber, W., eds.: Proceedings of the Eleventh International Conference on Logic Program-
ming and Nonmonotonic Reasoning (LPNMR’11). Springer-Verlag (2011) 345–351

3. Ullman, J.: Principles of Database and Knowledge-Base Systems. Computer Science Press

(1988)

4. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley (1995)
5. Mumick, I., Pirahesh, H., Ramakrishnan, R.: The magic of duplicates and aggregates. In
McLeod, D., Sacks-Davis, R., Schek, H., eds.: Proceedings of the Sixteenth International
Conference on Very Large Data Bases (VLDB’90). Morgan Kaufmann Publishers (1990)
264–277

6. Gebser, M., Harrison, A., Kaminski, R., Lifschitz, V., Schaub, T.: Abstract Gringo. Theory

and Practice of Logic Programming 15(4-5) (2015) 449–463

7. Truszczy´nski, M.: Connecting ﬁrst-order ASP and the logic FO(ID) through reducts. [19]

543–559

8. Niemelä, I.: Logic programs with stable model semantics as a constraint programming

paradigm. Annals of Mathematics and Artiﬁcial Intelligence 25(3-4) (1999) 241–273

9. Marek, V., Truszczy´nski, M.: Stable models and an alternative logic programming paradigm.
In Apt, K., Marek, V., Truszczy´nski, M., Warren, D., eds.: The Logic Programming
Paradigm: A 25-Year Perspective. Springer-Verlag (1999) 375–398

10. Gebser, M., Kaminski, R., Kaufmann, B., Schaub, T.: Answer Set Solving in Practice. Mor-

gan and Claypool Publishers (2012)

11. Leone, N., Perri, S., Scarcello, F.: Improving ASP instantiators by join-ordering methods.

[20] 280–294

12. Alviano, M., Calimeri, F., Faber, W., Leone, N., Perri, S.: Unfounded sets and well-founded
semantics of answer set programs with aggregates. Journal of Artiﬁcial Intelligence Research
42 (2011) 487–527

13. Ferraris, P.: Logic programs with propositional connectives and aggregates. ACM Transac-

tions on Computational Logic 12(4) (2011) 25:1–25:44

14. Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., Scarcello, F.: The DLV
system for knowledge representation and reasoning. ACM Transactions on Computational
Logic 7(3) (2006) 499–562

15. Wittocx, J., Mariën, M., Denecker, M.: Grounding FO and FO(ID) with bounds. Journal of

Artiﬁcial Intelligence Research 38 (2010) 223–269

16. Syrjänen, T.: Omega-restricted logic programs. [20] 267–279
17. Gebser, M., Schaub, T., Thiele, S.: Gringo: A new grounder for answer set programming. In
Baral, C., Brewka, G., Schlipf, J., eds.: Proceedings of the Ninth International Conference
on Logic Programming and Nonmonotonic Reasoning (LPNMR’07). Springer-Verlag (2007)
266–271

18. Gebser, M., Kaminski, R., Ostrowski, M., Schaub, T., Thiele, S.: On the input language of
ASP grounder gringo. In Erdem, E., Lin, F., Schaub, T., eds.: Proceedings of the Tenth Inter-
national Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’09).
Springer-Verlag (2009) 502–508

19. Erdem, E., Lee, J., Lierler, Y., Pearce, D., eds.: Correct Reasoning: Essays on Logic-Based

AI in Honour of Vladimir Lifschitz. Springer-Verlag (2012)

20. Eiter, T., Faber, W., Truszczy´nski, M., eds.: Proceedings of the Sixth International Confer-
ence on Logic Programming and Nonmonotonic Reasoning (LPNMR’01). Springer-Verlag
(2001)

