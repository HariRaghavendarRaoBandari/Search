6
1
0
2

 
r
a

 

M
1
2

 
 
]

.

O
L
h
t
a
m

[
 
 

1
v
7
4
5
6
0

.

3
0
6
1
:
v
i
X
r
a

Constructive canonicity for lattice-based ﬁxed point

logics

Willem Conradie 1 Andrew Craig

Department of Pure and Applied Mathematics, University of Johannesburg, South Africa

Alessandra Palmigiano 2

Department of Pure and Applied Mathematics, University of Johannesburg, South Africa

Faculty of Technology, Policy and Management, Delft University of Technology, the

Netherlands

Zhiguang Zhao

Faculty of Technology, Policy and Management, Delft University of Technology, the

Netherlands

Abstract

We prove the algorithmic canonicity of two classes of µ-inequalities in a constructive meta-
theory of normal lattice expansions. This result simultaneously generalizes Conradie and
Craig’s canonicity for µ-inequalities based on a bi-intuitionistic bi-modal language, [4], and
Conradie and Palmigiano’s constructive canonicity for inductive inequalities [11] (restricted to
normal lattice expansions to keep the page limit). Besides the greater generality, the uniﬁ-
cation of these strands smoothes the existing treatments for the canonicity of µ-formulas and
inequalities. In particular, the rules of the algorithm ALBA used for this result have exactly the
same formulation as those of [11], with no additional rule added speciﬁcally to handle the ﬁxed
point binders. Rather, ﬁxed points are accounted for by certain restrictions on the application
of the rules, concerning the order-theoretic properties of the term functions associated with the
formulas to which the rules are applied.

Keywords: Constructive canonicity, modal mu-calculus, normal lattice expansions, Sahlqvist
theory, uniﬁed correspondence.

1 Introduction
The present contribution lies at the crossroads of at least three active lines of research
in nonclassical logics: the one investigating the semantic and proof-theoretic environ-

1 The research of the ﬁrst author has been made possible by the National Research Foundation of South
Africa, Grant number 81309.
2 The research of the third and fourth author has been made possible by the NWO Vidi grant 016.138.314,
by the NWO Aspasia grant 015.008.054, and by a Delft Technology Fellowship awarded in 2013.

2

Constructive canonicity for lattice-based ﬁxed point logics

ment of ﬁxed point expansions of logics algebraically captured by varieties of (dis-
tributive) lattice expansions [2,22,26,3,18]; the one investigating constructive canon-
icity for intuitionistic and substructural logics [20,27]; the one uniformly extending
the state-of-the-art in Sahlqvist theory to families of nonclassical logics, and applying
it to issues both semantic and proof-theoretic [8,12,10,6,15,25,24,13,14,11,21,23,17],
known as ‘uniﬁed correspondence’.

We prove the algorithmic canonicity of two classes of µ-inequalities in a construc-
tive meta-theory of normal lattice expansions. This result simultaneously generalizes
Conradie and Craig’s canonicity results for µ-inequalities based on a bi-intuitionistic
bi-modal language [4], and Conradie and Palmigiano’s constructive canonicity for in-
ductive inequalities [9] (restricted to normal lattice expansions to keep the page limit).
Besides the greater generality, the uniﬁcation of these strands smoothes the existing
proofs for the canonicity of µ-formulas and inequalities. Speciﬁcally, the two canon-
icity results proven in [4], (namely, the tame and proper canonicity, cf. Section 3)
fully generalize to the constructive setting and normal LEs. Remarkably, the rules of
the algorithm ALBA used for this result have exactly the same formulation as those
of [9], with no additional rule added speciﬁcally to handle the ﬁxed point binders.
Rather, ﬁxed points are accounted for by certain restrictions on the application of the
rules, concerning the order-theoretic properties of the term functions associated with
the formulas to which the rules are applied.

Applications of these results include the formalization of common knowledge-type
processes of social interaction. For instance, in ongoing work [7] we are exploring
the formalization of processes giving rise to categorization systems (where categories
arise, as in Formal Concept Analysis, as Galois-stable sets from a given polarity)
agreed upon by a whole community.
Structure of the paper. In Section 2, we collect the needed preliminaries. In Section
4, we deﬁne the classes of mu-inequalities to which the canonicity results apply. In
Section 3, we introduce and expand on the two notions of canonicity mentioned above.
In Section 5, we outline the constructive and general lattice version of the algorithm
ALBA which is the main tool for the two canonicity results (more details are given in
the appendix). In Section 6, we state our main results. Due to space constraints we do
not include proofs, but these may be found online in the an expanded version of the
present paper [5].

2 Preliminaries
In this section we collect the needed preliminaries about the syntax and algebraic
semantics of lattice-based mu-calculi.

2.1 The language of lattice expansions
In the present subsection, we introduce the propositional fragments of the lattice-based
µ-languages we consider in this paper. We will make use of the following auxiliary
deﬁnitions: an order-type over n ∈ N 3 is an element ε ∈ {1, ∂}n. For every order-
type ε, we denote its opposite order-type by ε∂, that is, ε∂
i = 1 iﬀ εi = ∂ for every

3 Throughout the paper, order-types will be typically associated with arrays of variables p := (p1, . . . , pn).

Conradie, Craig, Palmigiano and Zhao

3

1 ≤ i ≤ n. For any lattice A, we let A1 := A and A∂ be the dual lattice, that is,
the lattice associated with the converse partial order of A. For any order-type ε, we
Aεi. Sometimes we will write ⊤1 and ⊤∂ for ⊤ and ⊥ respectively.
let Aε := Πn
Similarly, we will write ⊥1 and ⊥∂ for ⊥ and ⊤ respectively. For both order-types and
tuples of variables, we will use the symbol ⊕ to denote concatenation.

i=1

The LE-language L(F , G) (abbreviated as L when no confusion arises) takes as
parameters: 1) a denumerable set PROP of proposition letters, elements of which are
denoted p, q, r, possibly with indices; 2) disjoint sets of connectives F and G. Each
f ∈ F (resp. g ∈ G) has arity n f ∈ N (resp. ng ∈ N), and is associated with some order-
type ε f over n f (resp. εg over ng).The terms (formulas) of L are deﬁned recursively as
follows:

ϕ ::= p | ⊥ | ⊤ | ϕ ∧ ϕ | ϕ ∨ ϕ | f (ϕ) | g(ϕ)

where p ∈ PROP, f ∈ F , g ∈ G. Terms in L will be denoted either by s, t, or by
lowercase Greek letters such as ϕ, ψ, γ etc.

2.2 Lattice expansions, and their canonical extensions
The following deﬁnition captures the algebraic setting of the present paper, namely
the normal lattice expansions of [11].

Deﬁnition 2.1 For any LE-signature L = L(F , G), a lattice expansion (LE) is a tuple
A = (L, F A, GA) such that L is a bounded lattice, F A = { f A | f ∈ F } and GA = {gA |
g ∈ G}, such that every f A ∈ F A (resp. gA ∈ GA) is an n f -ary (resp. ng-ary) operation
on A. An LE A is normal if every f A ∈ F A (resp. gA ∈ GA) preserves ﬁnite (hence
also empty) joins (resp. meets) in each coordinate with ε f (i) = 1 (resp. εg(i) = 1) and
reverses ﬁnite (hence also empty) meets (resp. joins) in each coordinate with ε f (i) = ∂
(resp. εg(i) = ∂). Let LE be the class of LEs. Sometimes we will refer to certain LEs
as L-algebras to emphasize the signature. In the remainder of the paper, we will abuse
notation and write e.g. f for f A when this causes no confusion. From now on, normal
lattice expansions will be abbreviated as LEs.

Each language L is interpreted in the appropriate class of LEs. In particular, for
every LE A, each operation f A ∈ F A (resp. gA ∈ GA) is ﬁnitely join-preserving (resp.
meet-preserving) in each coordinate when regarded as a map f A : Aε f → A (resp.
gA : Aεg → A).

2.3 The ‘tense’ language Lt
Any language L = L(F , G) can be associated with the language Lt = LLE(F t, Gt),
where F t ⊇ F and Gt ⊇ G are obtained by adding:

(i) for f ∈ F and 1 ≤ i ≤ n f , the n f -ary connective f ♯

i , the intended interpretation
of which is the right residual of f in its ith coordinate if ε f (i) = 1 (resp. its
Galois-adjoint if ε f (i) = ∂);

(ii) for g ∈ G and 1 ≤ i ≤ ng, the ng-ary connective g♭

i , the intended interpretation of
which is the left residual of g in its ith coordinate if εg(i) = 1 (resp. its Galois-
adjoint if εg(i) = ∂).

4

Constructive canonicity for lattice-based ﬁxed point logics

i ∈ F t if ε f (i) = ∂. Dually, g♭

We stipulate that f ♯
i ∈ Gt if ε f (i) = 1, and f ♯
i ∈ F t
i ∈ Gt if εg(i) = ∂. The order-type assigned to the additional
if εg(i) = 1, and g♭
connectives is predicated on the order-type of their intended interpretations. That is,
for any f ∈ F and g ∈ G,
(i) if ε f (i) = 1, then ε f ♯
(ii) if ε f (i) = ∂, then ε f ♯
(iii) if εg(i) = 1, then εg♭
(iv) if εg(i) = ∂, then εg♭
The algebraic semantics of Lt := L({t, Gt) is given by the class of ‘tense’ Lt-algebras,
deﬁned as those Lt-algebras A = (L, (F t)A, (Gt)A) such that

(i) = 1 and ε f ♯
(i) = ∂ and ε f ♯
(i) = 1 and εg♭
(i) = ∂ and εg♭

( j) = (ε f ( j))∂ for any j , i.
( j) = ε f ( j) for any j , i.

( j) = (εg( j))∂ for any j , i.
( j) = εg( j) for any j , i.

i

i

i

i

i

i

i

i

(i) for every f ∈ F s.t. n f ≥ 1, all a1, . . . , an f , b ∈ L, and each 1 ≤ i ≤ n f ,

• if ε f (i) = 1, then f (a1, . . . , ai, . . . an f ) ≤ b iﬀ ai ≤ f ♯
• if ε f (i) = ∂, then f (a1, . . . , ai, . . . an f ) ≤ b iﬀ ai ≤∂ f ♯

i (a1, . . . , b, . . . , an f );
i (a1, . . . , b, . . . , an f ).

(ii) for every g ∈ G s.t. ng ≥ 1, any a1, . . . , ang, b ∈ L, and each 1 ≤ i ≤ ng,

• if εg(i) = 1, then b ≤ g(a1, . . . , ai, . . . ang) iﬀ g♭
• if εg(i) = ∂, then b ≤ g(a1, . . . , ai, . . . ang) iﬀ g♭

i (a1, . . . , b, . . . , ang) ≤ ai.
i (a1, . . . , b, . . . , ang) ≤∂ ai.

2.4 Canonical extensions, constructively
Canonical extensions provide a purely algebraic encoding of Stone-type dualities, and
indeed, the existence of the canonical extensions of the best-known varieties of LEs
can be proven via preexisting dualities. However, alternative, purely algebraic con-
structions are available, such as those of [19,16]. These constructions are in fact more
general, in that their deﬁnition does not rely on principles such as Zorn’s lemma. In
what follows we will recall them relative to the setting of LEs introduced above.

Deﬁnition 2.2 Let A be a (bounded) sublattice of a complete lattice A′.

(i) A is dense in A′ if every element of A′ can be expressed both as a join of meets

and as a meet of joins of elements from A.

(ii) A is compact in A′ if, for all S , T ⊆ A′, if W S ≤ V T then W S ′ ≤ V T ′ for

some ﬁnite S ′ ⊆ S and T ′ ⊆ T .

(iii) The canonical extension of a lattice A is a complete lattice Aδ containing A as a

dense and compact sublattice.

Let K(Aδ) and O(Aδ) denote the meet-closure and the join-closure of A in Aδ
respectively. The elements of K(Aδ) are referred to as closed elements, and elements
of O(Aδ) as open elements. The canonical extension of a bounded lattice A exists
and is unique up to any isomorphism ﬁxing A (cf. [19, Propositions 2.6 and 2.7]). In
meta-theoretic settings in which Zorn’s lemma is available, the canonical extension of
a lattice A is a perfect lattice. That is, in addition to being complete, is both completely
join-generated by the set J∞(A) of the completely join-irreducible elements of A,
and completely meet-generated by the set M∞(A) of the completely meet-irreducible
elements of A. In our present, constructive setting, canonical extensions might not be

Conradie, Craig, Palmigiano and Zhao

5

perfect.

The canonical extension of an LE A will be deﬁned as a suitable expansion of the
canonical extension of the underlying lattice of A. Before turning to this deﬁnition,
recall that taking order-duals interchanges closed and open elements: K((Aδ)∂) =
O(Aδ) and O((Aδ)∂) = K(Aδ); similarly, K((An)δ) = K(Aδ)n, and O((An)δ) = O(Aδ)n.
Hence, K((Aδ)ε) = Qi K(Aδ)ε(i) and O((Aδ)ε) = Qi O(Aδ)ε(i) for every LE A and
every order-type ε on any n ∈ N, where

K(Aδ)ε(i) :=

K(Aδ)
O(Aδ)





if ε(i) = 1
if ε(i) = ∂

O(Aδ)ε(i) :=

O(Aδ)
K(Aδ)





if ε(i) = 1
if ε(i) = ∂.

1 × Aδ

As a consequence of these observations, taking the canonical extension of a lat-
tice commutes with taking order duals and products, namely: (A∂)δ
= (Aδ)∂ and
2 (cf. [16, Theorem 2.8]). Hence, (A∂)δ can be identiﬁed with
(A1 × A2)δ = Aδ
(Aδ)∂, (An)δ with (Aδ)n, and (Aε)δ with (Aδ)ε for any order-type ε. Thanks to these
identiﬁcations, in order to extend operations of any arity and which are monotone or
antitone in each coordinate from a lattice A to its canonical extension, treating the
case of monotone and unary operations suﬃces:
Deﬁnition 2.3 For every unary, order-preserving operation f
π-extension of f are deﬁned as follows:

: A → A, the σ- and

f σ(u) = W{V{ f (a) : k ≤ a ∈ A} : u ≥ k ∈ K(Aδ)}
f π(u) = V{W{ f (a) : o ≥ a ∈ A} : u ≤ o ∈ O(Aδ)}.

It is easy to see that the σ- and π-extensions of ε-monotone maps are ε-monotone.
Moreover, the σ-extension of a map which sends ﬁnite (resp. ﬁnite nonempty) joins
or meets in the domain to ﬁnite (resp. ﬁnite nonempty) joins in the codomain sends
arbitrary (resp. arbitrary nonempty) joins or meets in the domain to arbitrary (resp.
arbitrary nonempty) joins in the codomain. Dually, the π-extension of a map which
sends ﬁnite (resp. ﬁnite nonempty) joins or meets in the domain to ﬁnite (resp. ﬁnite
nonempty) meets in the codomain sends arbitrary (resp. arbitrary nonempty) joins or
meets in the domain to arbitrary (resp. arbitrary nonempty) meets in the codomain
(cf. [19, Lemma 4.6]; notice that the proof given there holds in a constructive meta-
theory). Therefore, depending on the properties of the original operation, it is more
convenient to use one or the other extension. This justiﬁes the following:
Deﬁnition 2.4 The canonical extension of an L-algebra A = (L, F A, GA) is the L-
algebra Aδ := (Lδ, F Aδ , GAδ) such that f Aδ and gAδ are deﬁned as the σ-extension of
f A and as the π-extension of gA respectively, for all f ∈ F and g ∈ G.

The canonical extension of an LE A is a quasi-perfect LE:

Deﬁnition 2.5 An LE A = (L, F A, GA) is quasi-perfect if L is a complete lattice, and
the inﬁnitary versions of the distribution laws deﬁning normality are satisﬁed for each
f ∈ F and g ∈ G.

2.5 Adding the ﬁxed point operators
In this subsection, we describe two ways of extending any LE-language by adding
ﬁxed point operators. The distinction between the two extensions will become clear

6

Constructive canonicity for lattice-based ﬁxed point logics

when we deﬁne their interpretations on LEs. In what follows, FVAR, PHVAR are
disjoint sets of ﬁxed point variables and placeholder variables, respectively.

For any LE-language L, let L1 be the set of terms which extends L by allowing
terms µx.t(x) and νx.t(x) where t ∈ L1, x ∈ FVAR and t(x) is positive in x. The second
extension is denoted L2 and extends L by allowing construction of the terms µ2x.t(x)
and ν2x.t(x) where t ∈ L2, x ∈ FVAR and t(x) is positive in x.

Terms in L are interpreted in LEs as described above. If t(x1, x2, . . . , xn) ∈ L1 and

a1, . . . , an−1 ∈ A, then

µx.t(x, a1, . . . , an−1) := V{ a ∈ A | t(a, a1, . . . , an−1) ≤ a }

if this meet exists, otherwise µx.t(x, a1, . . . , an−1) is undeﬁned. Similarly,

νx.t(x, a1, . . . , an−1) := W{ a ∈ A | a ≤ t(a, a1, . . . , an−1) }

if this join exists, otherwise νx.t(x, a1, . . . , an−1) is undeﬁned. For each ordinal α we
deﬁne tα(⊥, a2, . . . , an) as follows:

t0(⊥, a1, . . . , an−1) = ⊥,
tλ(⊥, a1, . . . , an−1) = Wα<λ tα(⊥, a1, . . . , an−1)
t0(⊤, a1, . . . , an−1) = ⊤,
tλ(⊤, a1, . . . , an−1) = Vα<λ tα(⊤, a1, . . . , an−1)

for limit ordinals λ;

for limit ordinals λ.

tα+1(⊥, a1, . . . , an−1) = t(cid:0)tα(⊥, a1, . . . , an−1), a1, . . . , an−1(cid:1),

tα+1(⊤, a1, . . . , an−1) = t(cid:0)tα(⊤, a1, . . . , an−1), a1, . . . , an−1(cid:1),

If t(x1, . . . , xn) ∈ L2, then we let

µ2x.t(x, a1, . . . , an−1) := Wα≥0 tα(⊥, a1, . . . , an−1)
ν2x.t(x, a1, . . . , an−1) := Vα≥0 tα(⊤, a1, . . . , an−1)

if this join and meet exist, otherwise are undeﬁned.

A lattice expansion A is of the ﬁrst kind (of the second kind) if tA(a1, . . . , an) is
deﬁned for all a1, . . . , an ∈ A and all t ∈ L1 (t ∈ L2). Henceforth we will refer to
these algebras as mu-algebras of the ﬁrst kind (of the second kind). When restricted
to the Boolean case, our mu-algebras of the ﬁrst kind are essentially the modal mu-
algebras deﬁned in [3, Deﬁnition 2.2] and [1, Deﬁnition 5.1]. Every mu-algebra of the
second kind is a mu-algebra of the ﬁrst kind. (cf. [1, Proposition 2.4] and [4, Lemma
2.2]. These proofs straightforwardly extend to the setting of general LEs). Hence,
the interpretation of the two types of ﬁxed point binders on mu-algebras of the second
kind will agree. That is, µX.ϕ(X) = µ2X.ϕ(X) and νX.ψ(X) = ν2X.ψ(X) in mu-algebras
of the second kind.

The ﬁnal sets of terms, L∗ (resp. Lt

∗), are obtained as extensions of L (resp.
Lt) by allowing µ∗x.s(x) and ν∗x.s(x) whenever s ∈ L∗ (resp. s ∈ Lt
∗) and is
positive in x. Terms in L∗ and Lt
∗ are only interpreted in the constructive canon-
ical extensions Aδ of lattice expansions A.
∗ and
a1, . . . , an−1 ∈ Aδ, then µ∗x1.s(x1, a1, . . . , an−1) := V{ a ∈ A | s(a, a1, . . . , an−1) ≤ a }
and ν∗x1.s(x1, a2, . . . , an) := W{ a ∈ A | a ≤ s(a, a1, . . . , an−1) }. As the canonical
extension Aδ is a complete lattice, the interpretation of µ∗x.t(x) or ν∗x.t(x) is always
deﬁned. For any term ϕ ∈ Lt
∗ term obtained from ϕ by replac-
ing all occurrences of µ and ν with µ∗ and ν∗, respectively. The main feature of the µ∗
and ν∗ binders is that their interpretation does not change from A to Aδ.

If s(x1, x2, . . . , xn) ∈ L∗ ∪ Lt

1 we let ϕ∗ denote the Lt

Conradie, Craig, Palmigiano and Zhao

7

2.6 The language of constructive ALBA for LEs
The expanded language manipulated by the algorithm µ∗-ALBA (cf. section 5) in-
cludes the Lt-connectives, as well as a denumerably inﬁnite set of sorted variables
NOM called nominals, a denumerably inﬁnite set of sorted variables CO-NOM, called
co-nominals, and ﬁxed point binders (depending on the language). We let i, j denote
nominals, and m, n denote co-nominals. While in the non-constructive setting nom-
inals and co-nominals range over the completely join-irreducible and the completely
meet-irreducible elements of perfect LEs, respectively, in the present, constructive set-
ting, nominals and co-nominals will be interpreted as elements of K(Aδ) and O(Aδ),
respectively.

Formulas in the extended language L+

1 are deﬁned by the following recursion:

ϕ ::= ⊥ | ⊤ | p | X | j | m | ϕ ∧ ψ | ϕ ∨ ψ | f (ϕ) | g(ϕ) | µX.ϕ(X) | νX.ϕ(X)

where p ∈ PROP, X ∈ FVAR, j ∈ NOM, m ∈ CNOM, f ∈ F t, g ∈ Gt, and ϕ
∗ ) are deﬁned by
is positive in X in µX.ϕ(X) and νX.ϕ(X). Formulas in L+
replacing the ﬁxed point operators µ, ν with µ2, ν2 (resp. µ∗, ν∗).

2 (resp. L+

Placeholder variables from PHVAR, denoted x, y, z, will be used as generic vari-
ables which can take on the roles of propositional and ﬁxed point variables. They will
also be used to enhance the clarity of the exposition when dealing with substitution
instances of formulas. Let τ be an order-type over n. An L+
∗ ) formula
is pure if it contains no ordinary (propositional) variables but only, possibly, nominals
∗ )-sentence if it contains no free ﬁxed
and co-nominals, and is an L+
point variables.

1 (resp. L+

1 (resp. L+

2 , L+

2 , L+

A quasi-inequality of L+

1 (resp. L+

2 , L+

∗ ) is an expression of the form ϕ1 ≤
1 (resp.

∗ ).
2 , L+

ψ1 & · · · & ϕn ≤ ψn ⇒ ϕ ≤ ψ where the ϕi, ψi, ϕ and ψ are formulas of L+
L+
Quasi-inequalities, assignments, validity. Constructive canonical extensions of L-
algebras can be naturally endowed with the structure of L+-algebras (cf. Section 2.6
[9]). Building on this fact, we can use constructive canonical extensions of L-algebras
as a semantic environment for the language L+ as follows. For any L-algebra A, an
assignment on A sends propositional variables to elements of A and is extended to for-
mulas of L1, L2 and L∗ in the usual way, where these are deﬁned. An assignment on
Aδ is a map v : PROP∪NOM∪CO-NOM → Aδ sending propositional variables to ele-
ments of Aδ, nominals to K(Aδ) and co-nominals to O(Aδ) and extends to all formulas
2 . An admissible assignment on Aδ is an assignment which takes all
of L+
propositional variables to elements of A. An L+-inequality α ≤ β is admissibly valid
on A, denoted Aδ |=A α ≤ β, if it holds under all admissible assignments. A quasi-
inequality ϕ1 ≤ ψ1 & · · · & ϕ1 ≤ ψ1 ⇒ ϕ ≤ ψ is satisﬁed under an assignment V in an
algebra A of the appropriate sort, written A, V |= ϕ1 ≤ ψ1 & · · · & ϕn ≤ ψn ⇒ ϕ ≤ ψ if
A, V 6|= ϕi ≤ ψi for some 1 ≤ i ≤ n or A, v |= ϕ ≤ ψ. A quasi-inequality is (admissibly)
valid in an algebra if it is satisﬁed by every (admissible) assignment.
Signed generation trees. For any formula/term ϕ in L+
∗ , we assign two
1 and L+
signed generation trees +ϕ and −ϕ. The generation tree is constructed as usual, begin-
ning at the root with the main connective and then branching out into n-nodes at each
n-ary connective. Each leaf is either a propositional variable, a ﬁxed point variable, or

1 and L+

∗ , L+

8

Constructive canonicity for lattice-based ﬁxed point logics

A |= α ≤ β

⇔

Aδ |=A α ≤ β

⇔

Aδ |= α ≤ β

⇒
⇐

Aδ |=A ALBA(α ≤ β)

⇐⇒

Aδ |= ALBA(α ≤ β)

Fig. 1. The U-shaped argument for canonicity of inequalities interpreted on a LE A.

a constant. Each node is signed as follows:
• the root node of +ϕ is signed + and the root node of −ϕ is signed −;
• if a node is ∨, ∧ assign the same sign to its successor nodes;
• if a node is h ∈ F t ∪ Gt, assign the same (resp. the opposite) sign to every node

corresponding to a coordinate i such that εh(i) = 1 (resp. εh(i) = ∂);

• if a node is µx.ϕ(x), µ∗x.ϕ(x), νx.ϕ(x) or ν∗x.ϕ(x) (with every free occurrence of x
in the positive generation tree of ϕ labelled positively) then assign the same sign to
the successor node.

A node in a signed generation tree is positive if it is signed “+” and negative if it is
signed “−”.

3 Two kinds of canonicity, constructively
In this section we give a brief conceptual and methodological overview of the main
results of this paper.

The arguments for canonicity have the “U-shaped” format typical of the uniﬁed
correspondence paradigm (see [8]) as generically illustrated in Figure 1. Going down
the left-hand arm of the diagram, the ﬁrst bi-implication is justiﬁed by the fact that
validity in A is the same as admissible validity in Aδ, provided we make some stipu-
lations regarding the interpretation of ﬁxed point binders. The extended language L+
∗
can be interpreted in Aδ with nominals and co-nominals running over closed and open
elements, respectively.

The inequality is now equivalently transformed into a set of pure (quasi-) inequali-
ties, denoted ALBA(α ≤ β) in Figure 1. This is done by means of a calculus of rewrite
rules encapsulated in the constructive µ∗-ALBA, which we present in Section 5. The
fact that admissible and ordinary validity coincide for pure inequalities allows us to
traverse the the bi-implication forming the base of the “U”.

We proceed up the right-hand arm of the “U” by reversing the rewrite rules applied
when going down the left-hand side. The equivalences are justiﬁed by the fact that
these rules preserve validity on quasi-perfect algebras (cf. Deﬁnition 2.5).

If ϕ is a formula without ﬁxed point binders, then the term function ϕAδ extends
the term function ϕA, i.e., they agree on arguments from A. This is usually of crucial
importance in proving that an equation is canonical. As soon as we add ﬁxed point
binders, this extension property fails. Indeed, (ϕ(X))Aδ can have more pre-ﬁxed points
in Aδ than (ϕ(X))A has in A, and so (µX.ϕ(X))Aδ would generally be smaller than

Conradie, Craig, Palmigiano and Zhao

9

(µX.ϕ(X))A. This phenomenon creates signiﬁcant obstacles for standard canonicity
arguments, and is not an additional diﬃculty posed by the constructive environment.
One way around these diﬃculties, adopted by Bezhanishvili and Hodkinson [3], is
to require that only pre-ﬁxed points from the smaller algebra A are used in calculating
(µX.ϕ(X))Aδ. This is tantamount to interpreting µX.ϕ(X) in Aδ as (µ∗X.ϕ(X))Aδ.Thus,
in [4], two diﬀerent notions of canonicity for the mu-calculus were considered, and
their two ensuing canonicity results were shown for certain classes of mu-inequalities.
The counterparts of these results hold in a constructive general lattice environment.
Speciﬁcally, following [4], we call an inequality ϕ ≤ ψ tame canonical when A |= ϕ ≤
ψ if and only if Aδ |= ϕ∗ ≤ ψ∗ for all µ-algebras A of the ﬁrst kind. We generalize the
tame inductive mu-inequalities of [4] to the LE-setting, and prove that they are tame
canonical in a constructive meta-theory.

Of course, the usual notion of canonicity may also be applied to formulas with
ﬁxed-point binders, i.e., that A |= ϕ ≤ ψ iﬀ Aδ |= ϕ ≤ ψ, where ﬁxed points are inter-
preted in the standard way, e.g. least ﬁxed points in Aδ are calculated as the meet of all
pre-ﬁxed points in Aδ. A canonicity result of this kind can be proved by generalizing
the class of restricted inductive mu-inequalities of [4] to the LE-setting, and showing
that they are preserved under constructive canonical extensions of mu-algebras of the
second kind.

Whenever a tame run of µ∗-ALBA succeeds on a mu-inequality ϕ ≤ ψ, we have
that ϕ ≤ ψ is tame canonical. Moreover, whenever a proper run succeeds on a mu-
inequality α ≤ β, then α ≤ β will be canonical. Finally, for every tame inductive
mu-inequality (respectively, a restricted inductive mu-inequality), there exists a tame
(respectively, proper) run of µ∗-ALBA which succeeds on that inequality.

4 Syntactic classes
In this section, we introduce some syntactically deﬁned classes of mu-inequalities,
the most general of which is the counterpart, in the language of normal LEs plus ﬁxed
points, of the recursive mu-inequalities introduced in [6]. In a constructive setting,
the members of this class will all have correspondents in a ﬁrst-order language plus
ﬁxed points. The remaining two classes of mu-inequalities deﬁned in this section are
subclasses of the class of recursive mu-inequalities, and are those for which the two
canonicity results hold.

For any L1-sentence ϕ(p1, . . . pn), any order-type ε over n, and any 1 ≤ i ≤ n,
an ε-critical node in a signed generation tree of ϕ is a (leaf) node +pi with εi = 1,
or −pi with εi = ∂. An ε-critical branch in the tree is a branch terminating in an ε-
critical node. The intuition, which will be built upon later, is that variable occurrences
corresponding to ε-critical nodes are to be solved for, according to ε.

In the signed generation tree of a L1-sentence ϕ(p1, . . . pn) a live branch is a branch
ending in a (signed) propositional variable. In particular, all critical branches are live.
A branch is not live iﬀ it ends in a propositional constant (⊤ or ⊥) or in a ﬁxed point
variable.

For every L1-sentence ϕ(p1, . . . pn), and every order-type ε, we say that +ϕ (resp.
−ϕ) agrees with ε, and write ε(+ϕ) (resp. ε(−ϕ)), if every leaf node in the signed
generation tree of +ϕ (resp. −ϕ) which is labelled with a propositional variable is ε-

10

Constructive canonicity for lattice-based ﬁxed point logics

Outer Skeleton (P3)

Inner Skeleton (P2)

∆-adjoints

+ ∨
− ∧
SLR
f
+
− g

Binders
+ µ
− ν
SLA
f
+ ∨
− ∧ g

(n f = 1)
(ng = 1)

+
−

SLR
f
g

(n f ≥ 2)
(ng ≥ 2)

Table 1

Skeleton and PIA nodes.

PIA (P1)
Binders
+ ν
− µ
SRA

+ ∧ g
f
− ∨
SRR
g
f

+
−

(ng = 1)
(n f = 1)

(ng ≥ 2)
(n f ≥ 2)

critical. We will also make use of the sub-tree relation γ ≺ ϕ, which extends to signed
generation trees, and we will write ε(γ) ≺ ∗ϕ to indicate that γ, regarded as a sub-
(signed generation) tree of ∗ϕ, agrees with ε.
Deﬁnition 4.1 Nodes in signed generation trees will be called skeleton nodes and PIA
nodes and further classiﬁed as ∆-adjoint, SLR, Binders, SLA, SRA or SRR, according
to the speciﬁcation given in Table 1. 4 Let ϕ(p1, . . . , pn) be a formula in the proposi-
tional variables p1, . . . , pn, and let ε be an order-type on {1, . . . , n}.

A branch in a signed generation tree ∗ϕ, for ∗ ∈ {+, −}, ending in a propositional
variable is an ε-good branch if, apart from the leaf, it is the concatenation of three
paths P1, P2, and P3, each of which may possibly be of length 0, such that P1 is a path
from the leaf consisting only of PIA-nodes, P2 consists only of inner skeleton-nodes,
and P3 consists only of outer skeleton-nodes and, moreover, it satisﬁes conditions
(GB1), (GB2) and (GB3), below.
(GB1) The formula corresponding to the uppermost node on P1 is a sentence.
(GB2) For every SRR-node in P1 of the form h(γ, β), where β is the coordinate where
the branch lies, every γ in γ is a mu-sentence and ε∂(γ) ≺ ∗ϕ (i.e., each γ contains
no variable occurrences to be solved for — see above).

(GB3) For every SLR-node in P2 of the form h(γ, β), where β is the coordinate where
the branch lies, every γ in γ is a mu-sentence and ε∂(γ) ≺ ∗ϕ (see above for this
notation).

Our main interest is in ε-good branches satisfying some of the additional properties in
the following deﬁnition.
Deﬁnition 4.2 Let ϕ(p1, . . . , pn) be a formula, ε be an order-type on {1, . . . , n}, and
<Ω a strict partial order on the variables p1, . . . pn. An ε-good branch may satisfy one
or more of the following properties:

4 The abbreviations SLR, SLA, SRA and SRR stand for syntactically left residual, left adjoint, right adjoint
and right residual, respectively. Nodes are thus classiﬁed according to the order-theoretic properties of their
interpretations, see [8,11] for further discussion on methodology and nomenclature.

Conradie, Craig, Palmigiano and Zhao

11

(NB-PIA) P1 contains no ﬁxed point binders.
(NL) For every SLR-node in P2 of the form h(γ, β), where β is the coordinate where

the branch lies, the signed generation tree of each γ contains no live branches.

(Ω-CONF) For every SRR-node in P1 of the form h(γ, β), where β is the coordinate
where the branch lies, p j <Ω pi for every p j occurring in γ, where pi is the propo-
sitional variable labelling the leaf of the branch.

Deﬁnition 4.3 For any order-type ε and strict partial order <Ω on the variables
p1, . . . pn, the signed generation tree ∗ϕ, ∗ ∈ {−, +}, of a term ϕ(p1, . . . pn) is called
(i) ε-recursive if every ε-critical branch is ε-good.
(ii) (Ω, ε)-inductive it is ε-recursive and every ε-critical branch satisﬁes (Ω-CONF).
(iii) restricted (Ω, ε)-inductive if it is (Ω, ε)-inductive and

(a) every ε-critical branch satisﬁes (NB-PIA) and (NL),
(b) every occurrence of a binder is on an ε-critical branch.

(iv) tame (Ω, ε)-inductive if it is (Ω, ε)-inductive and

(a) Ω = ∅,
(b) no binder occurs on any ε-critical branch,
(c) the only nodes involving binders which are allowed to occur are +ν and −µ.
An inequality ϕ ≤ ψ is ε-recursive (resp., (Ω, ε)-inductive, restricted (Ω, ε)-inductive,
tame (Ω, ε)-inductive) if +ϕ and −ψ are both ε-recursive (resp., (Ω, ε)-inductive, re-
stricted (Ω, ε)-inductive, tame (Ω, ε)-inductive).

An inequality ϕ ≤ ψ is recursive (resp., inductive, restricted inductive, tame induc-
tive) if ϕ ≤ ψ is ε-recursive (resp., (Ω, ε)-inductive, restricted (Ω, ε)-inductive, tame
(Ω, ε)-inductive) for some strict partial order Ω and order-type ε.

The corresponding classes of inequalities will be referred to as the recursive (resp.,
inductive, restricted inductive, tame inductive) mu-inequalities, or the recursive (resp.,
inductive, restricted inductive, tame inductive) mu-formulas, if the inequality signs
have been replaced with implications.

5 Constructive µ∗-ALBA
In this section, we introduce the constructive and general lattice version of the al-
gorithm µ∗-ALBA introduced in [4], which in its turn is a restricted version of the
algorithm µ-ALBA, introduced in [6] to calculate ﬁrst-order correspondents of recur-
sive inequalities from bi-intuitionistic modal mu-calculus. Constructive µ∗-ALBA is
the fundamental tool to prove the canonicity results via the argument discussed in
Section 3. As usual, the goal of constructive µ∗-ALBA is to eliminate propositional
variables from inequalities, while maintaining admissible validity. The purpose of
this is to make the transition from admissible validity to validity in the argument for
canonicity. Below, we outline its general strategy.

Constructive µ∗-ALBA, from now on abbreviated as ALBA,

takes an L1-
inequality ϕ ≤ ψ as input, and proceeds in three stages. The ﬁrst stage preprocesses by
eliminating all uniformly occurring propositional variables, applying distribution rules
for f ∈ F and g ∈ G and splitting rules exhaustively, and converting all occurrences

12

Constructive canonicity for lattice-based ﬁxed point logics

i ≤ ψ′

i, 1 ≤ i ≤ n.

i.
i ≤ ψ′

of µX.ϕ(X) to µ∗X.ϕ(X) and all occurrences of νX.ψ(X) to ν∗X.ψ(X). We emphasize
that this step is required in both tame and proper runs of ALBA (see Appendix A).
The preprocessing produces a ﬁnite set of inequalities, ϕ′

Now ALBA forms the initial quasi-inequalities & S i ⇒ Ineqi, compactly repre-
sented as tuples (S i, Ineqi) referred to as systems, with each S i initialized to the empty
set and Ineqi initialized to ϕ′

The second stage (called the reduction stage) transforms S i and Ineqi through
the application of transformation rules (see Appendix A). The aim is to eliminate all
propositional variables from S i and Ineqi in favour of nominals and co-nominals. A
system for which this has been done will be called pure or puriﬁed. The actual elim-
inations are eﬀected through the Ackermann rules, while the other rules are used to
bring S i and Ineqi into the appropriate shape which make these applications possi-
ble. Once all propositional variables have been eliminated, this phase terminates and
returns the pure quasi-inequalities & S i ⇒ Ineqi.
The third stage either reports failure if some system could not be puriﬁed, or else
returns the conjunction of the pure quasi-inequalities & S i ⇒ Ineqi, which we denote
by ALBA(ϕ ≤ ψ).

A more complete outline of each of the three stages will be given in Appendix A.

6 Main results
In this section we state the main results of the paper, namely that all restricted induc-
tive inequalities are constructively canonical and that all tame inductive inequalities
are constrictively tame canonical. The proof strategy is the same in both cases: one
ﬁrst proves, by means of a ‘U-shaped’ argument as discussed in Section 3, that suc-
cessful runs of constructive ALBA satisfying certain conditions guarantee these types
of canonicity. Then it is shown that all members of the two classes of inequalities are
successfully reducible by means of runs respectively satisfying these properties. The
main canonicity results then follow as corollaries. Because of space limitations we do
not include the proofs.

A proof combining insights from the proofs of [4, Theorems 9.9 and 9.4] and [9,

Theorem 7.1] suﬃces to establish the following two propositions:
Proposition 6.1 Let A be a mu-algebra of the second kind and let ϕ ≤ ψ be an L1-
inequality on which a proper and pivotal run of µ∗-ALBA succeeds. If A |= ϕ ≤ ψ then
Aδ |= ϕ ≤ ψ.
Proposition 6.2 All L1-inequalities on which a tame and pivotal run of constructive
µ∗-ALBA succeeds are constructively tame canonical.

Again, generalizing to the non-distributive environment and amalgamating the

strategies from [4, Section 10] and [9, Section 6] yields the next proposition:
Proposition 6.3 Constructive µ∗-ALBA succeeds on all restricted inductive L-
inequalities by means of proper and pivotal runs.
Proposition 6.4 Constructive µ∗-ALBA succeeds on all tame inductive L-inequalities
by means of tame and pivotal runs.

The canonicity of restricted inductive L-inequalities now follows as a corollary of

Conradie, Craig, Palmigiano and Zhao

13

Propositions 6.1 and 6.3.

Theorem 6.5 All restricted inductive L-inequalities are constructively canonical
over mu-algebras of the second kind.

Similarly, the tame canonicity of all tame inductive inequalities follows from

Propositions 6.2 and 6.4.

Theorem 6.6 All tame inductive L-inequalities are constructively canonical over mu-
algebras of the ﬁrst kind.

References

[1] Ambler, S., M. Kwiatkowska and N. Measor, Duality and the completeness of the modal µ-calculus,

Theoretical Computer Science 151 (1995), pp. 3–27.

[2] Baelde, D., Least and greatest ﬁxed points in linear logic, ACM Transactions on Computational Logic

(TOCL) 13 (2012), p. 2.

[3] Bezhanishvili, N. and I. Hodkinson, Sahlqvist theorem for modal ﬁxed point logic, Theoretical

Computer Science 424 (2012), pp. 1–19.

[4] Conradie, W. and A. Craig, Canonicity results for mu-calculi: An algorithmic approach, Journal of

Logic and Computation (forthcoming).
URL http://arxiv.org/abs/1408.6367

[5] Conradie, W., A. Craig, A. Palmigiano and Z. Zhao, Constructive canonicity for lattice-based ﬁxed

point logics, ArXiv preprint .

[6] Conradie, W., Y. Fomatati, A. Palmigiano and S. Sourabh, Algorithmic correspondence for

intuitionistic modal mu-calculus, Theoretical Computer Science 564 (2015), pp. 30–62.

[7] Conradie, W., S. Frittella, A. Palmigiano, M. Piazzai, A. Tzimoulis and N. Wijnberg, Reasoning about

categories with generalized Kripke frames, in preparation .

[8] Conradie, W., S. Ghilardi and A. Palmigiano, Uniﬁed correspondence, in: A. Baltag and S. Smets,
editors, Johan van Benthem on Logic and Information Dynamics, Outstanding Contributions to Logic
5, Springer International Publishing, 2014 pp. 933–975.

[9] Conradie, W. and A. Palmigiano, Constructive canonicity of inductive inequalities Submitted.
[10] Conradie, W. and A. Palmigiano, Algorithmic correspondence and canonicity for distributive modal

logic, Annals of Pure and Applied Logic 163 (2012), pp. 338 – 376.

[11] Conradie, W. and A. Palmigiano, Algorithmic correspondence and canonicity for non-distributive

logics, Journal of Logic and Computation (forthcoming).

[12] Conradie, W., A. Palmigiano and S. Sourabh, Algorithmic modal correspondence: Sahlqvist and

beyond Submitted.

[13] Conradie, W., A. Palmigiano, S. Sourabh and Z. Zhao, Canonicity and relativized canonicity via

pseudo-correspondence: an application of ALBA Submitted.

[14] Conradie, W., A. Palmigiano and Z. Zhao, Sahlqvist via translation Submitted.
[15] Conradie, W. and C. Robinson, On Sahlqvist theory for hybrid logic, Journal of Logic and Computation

(2015).

[16] Dunn, J. M., M. Gehrke and A. Palmigiano, Canonical extensions and relational completeness of some

substructural logics, Journal Symbolic Logic 70 (2005), pp. 713–740.

[17] Frittella, S., A. Palmigiano and L. Santocanale, Dual characterizations for ﬁnite lattices via
correspondence theory for monotone modal logic, Journal of Logic and Computation (forthcoming).

[18] Gavazzo, F., Investigations into linear logic with ﬁxed-point operators (2015), iLLC MoL Thesis.
[19] Gehrke, M. and J. Harding, Bounded lattice expansions, Journal of Algebra 238 (2001), pp. 345–371.
[20] Ghilardi, S. and G. Meloni, Constructive canonicity in non-classical logics, Annals of Pure and

Applied Logic 86 (1997), pp. 1–32.

[21] Greco, G., M. Ma, A. Palmigiano, A. Tzimoulis and Z. Zhao, Uniﬁed correspondence as a proof-

theoretic tool, Journal of Logic and Computation (forthcoming).

[22] Hartonas, C., Duality for modal µ-logics, Theoretical Computer Science 202 (1998), pp. 193–222.

14

Constructive canonicity for lattice-based ﬁxed point logics

[23] Ma, M. and Z. Zhao, Uniﬁed correspondence and proof theory for strict implication, Journal of Logic

and Computation (forthcoming).

[24] Palmigiano, A., S. Sourabh and Z. Zhao, J´onsson-style canonicity for ALBA-inequalities, Journal of

Logic and Computation (2015).

[25] Palmigiano, A., S. Sourabh and Z. Zhao, Sahlqvist theory for impossible worlds, Journal of Logic and

Computation (forthcoming).

[26] Santocanale, L., Completions of µ-algebras, in: Logic in Computer Science, 2005. LICS 2005.

Proceedings. 20th Annual IEEE Symposium on, IEEE, 2005, pp. 219–228.

[27] Suzuki, T., Canonicity results of substructural and lattice-based logics, The Review of Symbolic Logic

4 (2011), pp. 1–42.

Appendix
A Stages and rules of µ∗-ALBA
A.1 Stage 1: Preprocessing and initialization
ALBA receives an L1-inequality ϕ ≤ ψ as input. It applies the following rules for
elimination of monotone variables to ϕ ≤ ψ exhaustively, in order to eliminate any
propositional variables which occur uniformly:

α(p) ≤ β(p)
α(⊥) ≤ β(⊥)

γ(p) ≤ δ(p)
γ(⊤) ≤ δ(⊤)

for α(p) ≤ β(p) positive and γ(p) ≤ δ(p) negative in p, respectively. 5

Next, ALBA exhaustively distributes f ∈ F over +∨, and g ∈ F over −∧, so as
to bring occurrences of +∨ and −∧ to the surface wherever this is possible, and then
eliminate them via exhaustive applications of splitting rules.
Splitting-rules.

α ≤ β ∧ γ

α ∨ β ≤ γ

α ≤ β α ≤ γ

α ≤ γ β ≤ γ

This gives rise to a set of inequalities {ϕ′

| 1 ≤ i ≤ n}. For each of them,
ALBA converts all occurrences of µX.ϕ(X) to µ∗X.ϕ(X) and all occurrences of νX.ψ(X)
to ν∗X.ψ(X), and forms the initial quasi-inequality & S i ⇒ Ineqi, compactly repre-
sented as a tuple (S i, Ineqi) referred as initial system, with each S i initialized to the
empty set and Ineqi initialized to ϕ′
i. Each initial system is passed separately to
stage 2, described below, where we will suppress indices i.

i ≤ ψ′
i

i ≤ ψ′

A.2 Stage 2: Reduction and elimination
The aim of this stage is to eliminate all occurring propositional variables from a given
system (S , Ineq). This is done by means of the following approximation rules, resid-
uation rules, splitting rules, and Ackermann rules, collectively called reduction rules.
The terms and inequalities in this subsection are from L+
∗ .

5 A term ϕ is positive (negative) in a variable p if in the generation tree +ϕ all p-nodes are signed + (−).
An inequality ϕ ≤ ψ is positive (negative) in p if ϕ is negative (positive) in p and ψ is positive (negative) in
p.

Conradie, Craig, Palmigiano and Zhao

15

Approximation rules. There are four approximation rules. Each of these rules func-
tions by simplifying Ineq and adding an inequality to S . We write α(!x) to indicate
that the placeholder variable x has a unique occurrence in formula α.
Left-positive approximation rule.

(S , ϕ′(γ/!x) ≤ ψ)

(S ∪{j ≤ γ}, ϕ′(j/!x) ≤ ψ)

(L+A)

with +x ≺ +ϕ′(!x), the branch of +ϕ′(!x) starting at +x subject to the restrictions
detailed below, γ belonging to the smaller language L∗ and j being the ﬁrst nominal
variable not occurring in S or ϕ′(γ/!x) ≤ ψ.

Left-negative approximation rule.

(S , ϕ′(γ/!x) ≤ ψ)

(S ∪{γ ≤ m}, ϕ′(m/!x) ≤ ψ)

(L−A)

with −x ≺ +ϕ′(!x), the branch of +ϕ′(!x) starting at −x subject to the restrictions
detailed below, γ belonging to the smaller language L∗ and m being the ﬁrst co-
nominal not occurring in S or ϕ′(γ/!x) ≤ ψ.

Right-positive approximation rule.

(S , ϕ ≤ ψ′(γ/!x))

(S ∪{j ≤ γ}, ϕ ≤ ψ′(j/!x))

(R+A)

with +x ≺ −ψ′(!x), the branch of −ψ′(!x) starting at +x subject to the restrictions
detailed below, γ belonging to the smaller language L∗ and j being the ﬁrst nominal
not occurring in S or ϕ ≤ ψ′(γ/!x).
Right-negative approximation rule.

(S , ϕ ≤ ψ′(γ/!x))

(S ∪{γ ≤ m}, ϕ ≤ ψ′(m/!x))

(R−A)

with −x ≺ −ψ′(!x), the branch of −ψ′(!x) starting at −x subject to the restrictions
detailed below, γ belonging to the smaller language L∗ and m being the ﬁrst co-
nominal not occurring in S or ϕ ≤ ψ′(γ/!x)).
The restrictions on ϕ′ and ψ′ in the approximation rules above are formulated in

terms of the following:
Deﬁnition A.1 For any mu-algebra C and order-type τ, a join W S in (Cδ)τ is called
Cτ-targeted if W S ∈ Cτ. A map f
: (Cδ)τ → Cδ preserves Cτ-targeted joins if
f (W S ) = Ws∈S f (s) for every S ⊆ (Cδ)τ such that W S is Cτ-targeted. Targeted meets
and their preservation are deﬁned order-dually.

Let us now list the requirements on ϕ′ and ψ′:

(i) ϕ′, ψ′, ∈ L∗;
(ii) the branches of ϕ′ and ψ′ starting at x going up to the root consist only of Skele-

ton nodes. 6

6 The purpose of this restriction is to enforce preservation of non-empty joins by the term function ϕ′C.
The soundness of the rule is founded upon this and approximation of the argument γ as the join of all
closed elements below it. In the non-constructive setting of [11] the same strategy is followed, except that

16

Constructive canonicity for lattice-based ﬁxed point logics

(iii) for every node of the form +µX.ψ(x, X) or of the form −νX.ϕ(x, X) in such
branches, which is not in the scope of another binder, all propositional variables
and free ﬁxed point variables in ψ(x, X) and ϕ(x, X) must be among x and X;
moreover,
(a) the associated term function ψ(x, X) : (Cδ)τ × Cδ → Cδ preserves (Cτ × C)-
targeted joins for all µ-algebras C of the second kind; moreover ψ(x, X) is
required to be positive (negative) in xi if τi = 1 (τi = ∂), i.e. ψ(x, X) must be
τ-positive in x;

(b) the associated term function ϕ(x, X) : (Cδ)τ × Cδ → Cδ preserves (Cτ × C)-
targeted meets for all LLE-algebras C of the second kind; moreover ϕ(x, X)
is required to be positive (negative) in xi if τi = 1 (τi = ∂), i.e. ϕ(x, X) must
be τ-positive in x.

Remark A.2

(i) The approximation rules above, as stated, are sound both under
admissible and under arbitrary assignments. However, their liberal application
gives rise to topological complications in the proof of canonicity. Therefore,
we will restrict the applications of approximation rules to nodes !x giving rise
to maximal skeleton branches.Such applications will be called pivotal. Also,
executions of ALBA in which approximation rules are applied only pivotally
will be referred to as pivotal.

(ii) In [4], approximation rules were formulated speciﬁcally for formulas having a
ﬁxed point binder as main connective. These rules had a substantially more
cumbersome formulation than the one given above, which, modulo the restric-
tions about the preservation of targeted joins and meets, follows verbatim the
approximation rules of [11]. Moreover, the approximation rules [4] could give
rise to the splitting of the quasi-inequality into a set of quasi-inequalities, which
is not the case of the present setting. This is thanks to the fact that nominals and
co-nominals are not interpreted as completely join-primes (resp. meet-primes),
but as closed and open elements, and this notion is compatible with products (cf.
Section 2, page 5).

Residuation rules. These rules operate on the inequalities in S , by rewriting a chosen
inequality in S into another inequality. For every f ∈ F and g ∈ G, and any 1 ≤ i ≤ n f
and 1 ≤ j ≤ ng,

f (ϕ1, . . . , ϕi, . . . , ϕn f ) ≤ ψ
ϕi ≤ f ♯
i (ϕ1, . . . , ψ, . . . , ϕn f )

ε f (i) = 1

f (ϕ1, . . . , ϕi, . . . , ϕn f ) ≤ ψ
f ♯
i (ϕ1, . . . , ψ, . . . , ϕn f ) ≤ ϕi

ε f (i) = ∂

ψ ≤ g(ϕ1, . . . , ϕi, . . . , ϕng)
g♭
i (ϕ1, . . . , ψ, . . . , ϕng) ≤ ϕi

εg(i) = 1

ψ ≤ g(ϕ1, . . . , ϕi, . . . , ϕng)
ϕi ≤ g♭
i (ϕ1, . . . , ψ, . . . , ϕng)

εg(i) = ∂

the approximation is done by means of completely join-irreducibles. Since this can give rise to empty sets
of approximants and hence empty joins, +∨ is excluded in the analogous approximation rule in [11], as the
join does not preserve empty joins coordinate-wise. In the present setting, the set of closed approximants is
never empty, and hence this restriction may be dropped. Similar considerations apply to −∧.

Conradie, Craig, Palmigiano and Zhao

17

In a given system, each of these rules replaces an instance of the upper inequality with
the corresponding instances of the two lower inequalities.
Ackermann rules The Ackermann rules are used for the crucial task of eliminating
propositional variables from quasi-inequalities.

∃p[&n
&m

i=1 αi ≤ p & &m
j=1 β j(Wn

i=1 αi/p) ≤ γ j(Wn

j=1 β j(p) ≤ γ j(p)]

i=1 αi/p)

(RA)

subject to the restrictions that the αi are p-free and syntactically closed, the β j are
positive in p and syntactically closed, while the γ j are negative in p and syntactically
open (cf. subsection below).

∃p[&n
&m

i=1 p ≤ αi & &m
j=1 γ j(Vn

i=1 αi/p) ≤ β j(Vn

j=1 γ j(p) ≤ β j(p)]

i=1 αi/p)

(LA)

subject to the restrictions that the αi are p-free and syntactically open, the β j are
positive in p and syntactically open, while the γ j are negative in p and syntactically
closed.
A.2.1 Syntactically (almost) open and closed formulas
As mentioned in the introduction, when formulas from the extended language L+ are
interpreted in Aδ, an assignment V will have V(NOM) ⊆ K(Aδ) and V(CNOM) ⊆
O(Aδ). For any assignment V, the assignment V ′ is a p-variant (or, a j-variant or m-
variant) of V if V ′ agrees with V on all elements of PROP ∪ NOM ∪ CNOM except
possibly at p (respectively, at j or m). If so, we write V ′ ∼p V (respectively, V ′ ∼j V
or V ′ ∼m V). From this point on, we will use V to denote both the assignment V :
PROP ∪ NOM ∪ CNOM → Aδ and its unique homomorphic extension V : L+ → Aδ.
In the following deﬁnition we will use f ∈ F and g ∈ G to denote connectives
of the original signature, and h ∈ F + \ F and k ∈ G+ \ G to denote connectives of
the expanded (‘tense’) language. To simplify notation, we will disregard the actual
order of the coordinates, but keep track of their polarity. So, for instance we will write
f (ψ, ϕ) and k(ϕ, ψ), where in both cases the coordinates are divided in two possibly
empty arrays, the ﬁrst (resp. second) of which contains the positive (resp. negative)
coordinates.

Deﬁnition A.3 The syntactically open formulas ϕ and syntactically closed formulas
ψ are deﬁned by simultaneous mutual recursion as follows:

ϕ ::= ⊥ | ⊤ | p | m | ϕ1 ∧ ϕ2 | ϕ1 ∨ ϕ2 | g(ϕ, ψ) | f (ϕ, ψ) | k(ϕ, ψ) | ν∗X.ϕ
ψ ::= ⊥ | ⊤ | p | i | ψ1 ∧ ψ2 | ψ1 ∨ ψ2 | f (ψ, ϕ) | g(ψ, ϕ) | h(ψ, ϕ) | µ∗X.ψ

where p ∈ PROP, i ∈ NOM, and m ∈ CNOM.

The syntactically almost open formulas and syntactically almost closed formulas

are deﬁned by adding µ∗X.ϕ (resp. ν∗X.ψ) to the recursive deﬁnition of ϕ (resp. ψ).

Informally, an L+

∗ -term is syntactically almost open (resp. syntactically almost
closed) if, in it, all occurrences of nominals and h ∈ F + \ F are negative (resp. posi-
tive), while all occurrences of co-nominals and k ∈ G+ \G are positive (resp. negative).

18

Constructive canonicity for lattice-based ﬁxed point logics

If, in addition, all occurrences of µ∗ are negative (resp. positive) and all occurrences of
ν∗ positive (resp. negative), the term is syntactically open (resp. syntactically closed).

A.3 Stage 3: Success, failure and output
If stage 2 succeeded in eliminating all propositional variables from each system,
the algorithm returns the conjunction of these puriﬁed quasi-inequalities, denoted by
ALBA(ϕ ≤ ψ). Otherwise, the algorithm reports failure and terminates.

A tame run of µ∗-ALBA is one during which the approximation rules are applied
only to formulas ϕ′(γ/!x) and ψ′(γ/!x) such that no ﬁxed point binder occurs in the
branch from x to the root of ϕ′ and ψ′. By contrast, a proper run of µ∗-ALBA is one
during which all occurrences of ﬁxed point binders lie along some branch ending with
a subterm γ which the application of an approximation rule extracts. We say that a run
of the algorithm µ∗-ALBA succeeds if all propositional variables are eliminated from
the input inequality, ϕ ≤ ψ, and denote the resulting set of pure quasi-inequalities by
ALBA(ϕ∗ ≤ ψ∗). An inequality on which some run of µ∗-ALBA succeeds is called a
µ∗-ALBA inequality.

