Unambiguous Prioritized Repairing of Databases∗

†
Benny Kimelfeld

Technion

Haifa 32000, Israel

bennyk@cs.technion.ac.il

esterliv@cs.technion.ac.il

Ester Livshits

Technion

Haifa 32000, Israel

Liat Peterfreund

Technion

Haifa 32000, Israel

liatpf@cs.technion.ac.il

6
1
0
2

 
r
a

M
6

 

 
 
]

B
D
.
s
c
[
 
 

1
v
0
2
8
1
0

.

3
0
6
1
:
v
i
X
r
a

ABSTRACT
In its traditional deﬁnition, a repair of an inconsistent database
is a consistent database that differs from the inconsistent one
in a “minimal way.” Often, repairs are not equally legiti-
mate, as it is desired to prefer one over another; for example,
one fact is regarded more reliable than another, or a more
recent fact should be preferred to an earlier one. Motivated
by these considerations, researchers have introduced and in-
vestigated the framework of preferred repairs, in the context
of denial constraints and subset repairs. There, a priority
relation between facts is lifted towards a priority relation
between consistent databases, and repairs are restricted to
the ones that are optimal in the lifted sense. Three notions
of lifting (and optimal repairs) have been proposed: Pareto,
global, and completion.

In this paper we investigate the complexity of deciding
whether the priority relation sufﬁces to clean the database
unambiguously, or in other words, whether there is exactly
one optimal repair. We show that the different lifting se-
mantics entail highly different complexities. Under Pareto
optimality, the problem is coNP-complete, in data complex-
ity, for every set of functional dependencies (FDs), except
for the tractable case of (equivalence to) one FD per rela-
tion. Under global optimality, one FD per relation is still
tractable, but we establish Πp
2-completeness for a relation
with two FDs. In contrast, under completion optimality the
problem is solvable in polynomial time for every set of FDs.
In fact, we present a polynomial-time algorithm for arbitrary
conﬂict hypergraphs. We further show that under a general
assumption of transitivity, this algorithm solves the problem
even for global optimality. The algorithm is extremely sim-
ple, but its proof of correctness is quite intricate.

1.

INTRODUCTION

Managing database inconsistency has received a lot of at-
tention in the past two decades. Inconsistency arises for dif-
ferent reasons and in different applications. For example, in
common applications of Big Data, information is obtained
from imprecise sources (e.g., social encyclopedias or social
networks) via imprecise procedures (e.g., natural-language
processing). It may also arise when integrating conﬂicting
∗This research is supported by the Israeli Science Founda-
tion, Grant #1295/15.
†Taub Fellow, supported by the Taub Foundation.

data from different sources (each of which can be consis-
tent). Arenas, Bertossi and Chomicki [3] introduced a prin-
cipled approach to managing of inconsistency, via the no-
tions of repairs and consistent query answering. Informally,
a repair of an inconsistent database I is a consistent database
J that differs from I in a “minimal” way, where minimal-
ity refers to the symmetric difference. In the case of anti-
symmetric integrity constraints (e.g., denial constraints and
the special case of functional dependencies), such a repair is
a subset repair (i.e., J is a consistent subinstance of I that is
not properly contained in any consistent subinstance of I).

Various computational problems around database repairs
have been extensively investigated. Most studied is the prob-
lem of computing the consistent answers of a query q on an
inconsistent database I; these are the tuples in the intersec-

tion(cid:84){q(J) : J is a repair of I} [3, 29]. Hence, in this ap-

proach inconsistency is handled at query time by returning
the tuples that are guaranteed to be in the result no matter
which repair is selected. Another well studied question is
that of repair checking [1]: given instances I and J, deter-
mine whether J is a repair of I. Depending on the type
of repairs and the type of integrity constraints, these prob-
lems may vary from tractable to highly intractable complex-
ity classes. See [4] for an overview of results.

In the above framework, all repairs of a given database in-
stance are taken into account, and they are treated on a par
with each other. There are situations, however, in which it
is natural to prefer one repair over another [8, 16, 36, 37].
For example, this is the case if one source is regarded to be
more reliable than another (e.g., enterprise data vs. Internet
harvesting, precise vs. imprecise sensing equipment, etc.) or
if available timestamp information implies that a more re-
cent fact should be preferred over an earlier fact. Recency
may be implied not only by timestamps, but also by evolu-
tion semantics; for example, “divorced” is likely to be more
updated than “single,” and similarly is “Sergeant” compared
to “Private.”1 Motivated by these considerations, Staworko,
Chomicki and Marcinkowski [36, 37] introduced the frame-
work of preferred repairs. The main characteristic of this
framework is that it uses a priority relation between conﬂict-
ing facts of an inconsistent database to deﬁne a notion of
preferred repairs.

Speciﬁcally, the notion of Pareto optimality and that of
global optimality are based on two different notions of im-
provement—the property of one consistent subinstance be-
ing preferred to another. Improvements are basically lifting

1See [15] for a survey on aspects of data quality.

1

of the priority relation from facts to consistent subinstances;
J is an improvement of K if J contains a fact that is bet-
ter than all those in K \ J (in the Pareto semantics), or if
for every fact in K \ J there exists a better fact in J \ K
(in the global semantics).
In each of the two semantics,
an optimal repair is a repair that cannot be improved. A
third semantics proposed by Staworko et al. [37] is that of
a completion-optimal repair, which is a globally optimal re-
pair under some extension of the priority relation into a total
relation. In this paper, we refer to these preferred repairs as
p-repair, g-repair and c-repair, respectively.

Fagin et al. [13] have built on the concept of preferred re-
pairs (in conjunction with the framework of document span-
ners [14]) to devise a language for declaring inconsistency
cleaning in text information-extraction systems. They have
shown there that preferred repairs capture ad-hoc cleaning
operations and strategies of some prominent existing sys-
tems for text analytics [2, 9].

Staworko et al. [37] have proved several results about pre-
ferred repairs. For example, every c-repair is also a g-repair,
and every g-repair is also a p-repair. They also showed that
p-repair and c-repair checking are solvable in polynomial
time (under data complexity) when constraints are given as
denial constraints, and that there is a set of functional depen-
dencies (FDs) for which g-repair checking is coNP-complete.
Later, Fagin et al. [12] extended that hardness result to a
full dichotomy in complexity over all sets of FDs: g-repair
checking is solvable in polynomial time whenever the set of
FDs is equivalent to a single FD or two key constraints per
relation; in every other case, the problem is coNP-complete.
While the classic complexity problems studied in the the-
ory of repairs include repair checking and consistent query
answering, the presence of repairs gives rise to the cleaning
problem, which Staworko et al. [37] refer to as categoricity:
determine whether the provided priority relation sufﬁces to
clean the database unambiguously, or in other words, decide
whether there is exactly one optimal repair. The problem of
repairing uniqueness (in a different repair semantics) is also
referred to as determinism by Fan et al. [18]. In this paper,
we study the three variants of this computational problem,
under the three optimality semantics Pareto, global and com-
pletion, and denote them as p-categoricity, g-categoricity
and c-categoricity, respectively.

It is known that under each of the three semantics there is
always at least one preferred repair, and Staworko et al. [37]
present a polynomial-time algorithm for ﬁnding such a re-
pair.
(We recall this algorithm in Section 3.) Hence, the
categoricity problem is that of deciding whether the output
of this algorithm is the only possible preferred repair. As we
explain next, it turns out that each of the three variants of the
problem entails quite a unique picture of complexity.

For the problem of p-categoricity, we focus on integrity
constraints that are FDs, and establish the following dichotomy
in data complexity, assuming that P (cid:54)= NP. For a relational
schema with a set ∆ of FDs:

• If ∆ associates (up to equivalence) a single FD with
every relation symbol, then p-categoricity is solvable

2

in polynomial time.

• In any other case, p-categoricity is coNP-complete.

For example, with the relation symbol R(A, B, C) and the
FD A → B, p-categoricity is solvable in polynomial time;
but if we add the dependency B → A then it becomes coNP-
complete. Our proof uses a reduction technique from past
dichotomies that involve FDs [12, 25], but requires some
highly nontrivial additions.

We then turn to investigating c-categoricity, and establish
a far more positive picture than the one for p-categoricity.
In particular, the problem is solvable in polynomial time for
every set of FDs. In fact, we present an algorithm for solving
c-categoricity in polynomial time, assuming that constraints
are given as an input conﬂict hypergraph [10]. (In particu-
lar, we establish polynomial-time data complexity for other
types of integrity constraints, such as conditional FDs [5]
and denial constraints [19].) The algorithm is extremely
simple, yet its proof of correctness is quite intricate.

Finally, we explore g-categoricity, and focus ﬁrst on FDs.
We show that in the tractable case of p-categoricity (equiva-
lence to a single FD per relation), g-categoricity is likewise
solvable in polynomial time. For example, R(A, B, C) with
the dependency A → B has polynomial-time g-categoricity.
Nevertheless, we prove that if the we add the dependency
∅ → C (that is, the attribute C should have the same value
across all tuples), then g-categoricity becomes Πp
2-complete.
We do not complete a dichotomy as in p-categoricity, and
leave that open for future work. Lastly, we observe that in
our proof of Πp
2-hardness, our reduction constructs a non-
transitive priority relation, and we ask whether transitivity
makes a difference. The three semantics of repairs remain
different in the presence of transitivity.
In particular, we
show such a case where there are globally-optimal repairs
that are not completion optimal repairs. Nevertheless, quite
interestingly, we are able to prove that g-categoricity and
c-categoricity are actually the same problem if transitivity
is assumed. In particular, we establish that in the presence
of transitivity, g-categoricity is solvable in polynomial time,
even when constraints are given as a conﬂict hypergraph.

2. PRELIMINARIES

We now present some general terminology and notation

that we use throughout the paper.
2.1 Signatures and Instances
A (relational) signature is a ﬁnite set R = {R1, . . . , Rn}
of relation symbols, each with a designated positive integer
as its arity, denoted arity(Ri). We assume an inﬁnite set
Const of constants, used as database values. An instance I
over a signature R = {R1, . . . , Rn} consists of ﬁnite rela-
tions RI
denote the set {1, . . . , arity(Ri)}, and we refer to the mem-

i ⊆ Constarity(Ri), where Ri ∈ R. We write(cid:74)Ri(cid:75) to
bers of(cid:74)Ri(cid:75) as attributes of Ri. If I is an instance over R

i , then we say that Ri(t) is a fact of
and t is a tuple in RI
I. By a slight abuse of notation, we identify an instance I
with the set of its facts. For example, Ri(t) ∈ I denotes that

Ri(t) is a fact of I. As another example, J ⊆ I means that
i ⊆ RI
i for every Ri ∈ R; in this case, we say that J is
RJ
subinstance of I.
In our examples, we often name the attributes and refer
to them by their names. For instance, in Figure 1 we refer
to the relation symbol as CompCEO(company, ceo) where
company and ceo refer to Attributes 1 and 2, respectively.
In the case of generic relation symbols, we implicitly name
their attributes by capital English letters with the correspond-
ing numeric values; for instance, we may refer to Attributes
1, 2 and 3 of R/3 by A, B and C, respectively. We stress
that attribute names are not part of our formal model, but are
rather used for readability.
2.2

Integrity and Inconsistency

Let R be a signature, and I an instance over R. In this
paper we consider two representation systems for integrity
constraints. The ﬁrst is functional dependencies and the sec-
ond is conﬂict hypergraphs.
2.2.1 Functional Dependencies
Let R be a signature. A Functional Dependency (FD for
short) over R is an expression of the form R : X → Y ,
where R is a relation symbol of R, and X and Y are subsets
and write simply X → Y . A special case of an FD is a key
constraint, which is an FD of the form R : X → Y where

of(cid:74)R(cid:75). When R is clear from the context, we may omit it
X ∪ Y = (cid:74)R(cid:75). An FD R : X → Y is trivial if Y ⊆ X;

otherwise, it is nontrivial.

When we are using the alphabetic attribute notation, we
may write X and Y by simply concatenating the attribute
symbols. For example, if we have a relation symbol R/3,
then A → BC denotes the FD R : {1} → {2, 3}. An
instance I over R satisﬁes an FD R : X → Y if for every
two facts f and g over R, if f and g agree on (i.e., have the
same values for) the attributes of X, then they also agree on
the attributes of Y . We say that I satisﬁes a set ∆ of FDs if
I satisﬁes every FD in ∆; otherwise, we say that I violates
∆. Two sets ∆ and ∆(cid:48) of FDs are equivalent if for every
instance I over R it holds that I satisﬁes ∆ if and only if it
satisﬁes ∆(cid:48). For example, for R/3 the sets {A → BC, C →
A} and {A → C, C → AB} are equivalent.
In this work, a schema S is a pair (R, ∆), where R is a
signature and ∆ is a set of FDs over R. If S = (R, ∆) is a
schema and R ∈ R, then we denote by ∆|R the restriction
of ∆ to the FDs R : X → Y over R.

EXAMPLE 2.1. In our ﬁrst running example, we use the
schema S = (R, ∆), deﬁned as follows. The signature
R consists of a single relation CompCEO(company, ceo),
which associates companies with their Chief Executive Of-
ﬁcers (CEO). Figure 1 depicts an instance I over R. We
deﬁne ∆ as the following set of FDs over R.

∆ def= {company → ceo , ceo → company}

Hence, ∆ states that in CompCEO, each company has a sin-
gle CEO and each CEO manages a single company. Observe
that I violates ∆. For example, Google has three CEOs,

3

CompCEO

ceo

company
f g
Pichai
Google
pi
f g
Page
Google
pa
f g
Brin
Google
br
f a
Page
pa Alphabet
f a
pi Alphabet Pichai

Figure 1: Inconsistent database of the company-CEO
running example

Alphabet has two CEOs, and each of Pichai and Page is the
CEO of two companies.
2.2.2 Conﬂict Hypergraphs
While FDs deﬁne integrity logically, at the level of the
signature, a conﬂict hypergraph [10] provides a direct speci-
ﬁcation of inconsistencies at the instance level, by explicitly
stating sets of tuples that cannot co-exist. In the case of FDs,
the conﬂict hypergraph is a graph that has an edge between
every two facts that violate an FD. Formally, for an instance
I over a signature R, a conﬂict hypergraph H (for I) is a
hypergraph that has the facts of I as its node set. A subin-
stance J of I is consistent with respect to (w.r.t.) H if J is an
independent set of H; that is, no hyperedge of H is a subset
of J. We say that J is maximal if J ∪{f} is inconsistent for
every f ∈ I \ J. When all the edges of a conﬂict hypergraph
are of size two, we may call it a conﬂict graph.

Recall that conﬂict hypergraphs can represent inconsisten-
cies for various types of integrity constraints, including FDs,
the more general conditional FDs [5], and the more general
denial constraints [19]. In fact, every constraint that is anti-
monotonic (i.e., where subsets of consistent sets are always
consistent) can be represented as a conﬂict hypergraph. In
the case of denial constraints, the translation from the logical
constraints to the conﬂict hypergraph can be done in polyno-
mial time under data complexity (i.e., when the signature and
constraints are assumed to be ﬁxed).
Let S = (R, ∆) be a schema, and let I be an instance over
S. Recall that S is assumed to have only FDs. We denote by
HI
S the conﬂict graph for I that has an edge between every
two facts that violate some FD of S. Note that a subinstance
J of I satisﬁes ∆ if and only if J is consistent w.r.t. HI
S.
As an example, the left graph of Figure 2 depicts the graph
HI
S for our running example; for now, the reader should ig-
nore the directions on the edges, and view the graph as an
undirected one. The following example involves a conﬂict
hypergraph that is not a graph.

EXAMPLE 2.2. In our second running example, we use
the toy scenario where the signature has a single relation
symbol Follows/2, where Follows(x, y) means that person
x follows person y (e.g., in a social network). We have two
sets of people: ai for i = 1, 2, 3, and bj for j = 1, . . . , 5.
All the facts have the form Follows(ai, bj); we denote such
a fact by fij. The instance I has the following facts:
f11, f12, f21, f22, f23, f24, f31, f32, f34, f35

The hypergraph H for I encodes the following rules:

• Each ai can follow at most i people.
• Each bj can be followed by at most j people.
Speciﬁcally, H contains the following hyperedges:
• {f11, f12}, {f21, f22, f23}, {f21, f22, f24},
{f21, f23, f24}, {f22, f23, f24}, {f31, f32, f34, f35}
• {f11, f21}, {f11, f31}, {f21, f31}, {f12, f22, f32}

An example of a consistent subinstance J is
{f11, f22, f23, f32, f34, f35} .

The reader can verify that J is maximal.
2.3 Prioritizing Inconsistent Databases
We now recall the framework of preferred repairs by Sta-
worko et al. [37]. Let I be an instance over a signature R. A
priority relation (cid:31) over I is an acyclic binary relation over
the facts in I. By acyclic we mean that I does not contain
any sequence f1, . . . , fk of facts such that fi (cid:31) fi+1 for all
i = 1, . . . , k − 1 and fk (cid:31) f1. If (cid:31) is a priority relation over
I and K is a subinstance of I, then max(cid:31)(K) denotes the
set of tuples f ∈ K such that no g ∈ K satisﬁes g (cid:31) f.
An inconsistent prioritizing instance over R is a triple
(I,H,(cid:31)), where I is an instance over R, H is a conﬂict
hypergraph for I, and (cid:31) a priority relation over I with the
following property: for every two facts f and g in I, if f (cid:31) g
then f and g are neighbors in H (that is, f and g co-occur
in some hyperedge).2 For example, if H = HI
S (where all
the constraints in S are FDs), then f (cid:31) g implies that {f, g}
violates at least one FD.

br and f a

pa (cid:31) f a

EXAMPLE 2.3. We continue our running company-CEO
example. We deﬁne a priority relation (cid:31) by f g
pi (cid:31) f g
pa,
pa (cid:31) f g
pi. We denote (cid:31) by corresponding
f g
arrows on the left graph of Figure 2. (Therefore, some of
the edges are directed and some are undirected.) We then
get the inconsistent prioritizing instance (I,HI
S,(cid:31)) over R.
Observe that the graph does not contain directed cycles, as
required from a priority relation.

EXAMPLE 2.4. Recall that the instance I of our follow-
ers example is deﬁned in Example 2.2. The priority relation
(cid:31) is given by fil (cid:31) fjk if one of the following holds: (a)
i = j and k = l + 1, or (b) j = i + 1 and l = k. For
example, we have f11 (cid:31) f12 and f12 (cid:31) f22. But we do not
have f11 (cid:31) f22 (hence, (cid:31) is not transitive).
Let (I,H,(cid:31)) be an inconsistent prioritizing instance over
a signature R. We say that (cid:31) is total if for every two facts
f and g in I, if f and g are neighbors then either f (cid:31) g or
g (cid:31) f. A priority (cid:31)c over I is a completion of (cid:31) (w.r.t. H) if
(cid:31) is a subset of (cid:31)c and (cid:31)c is total. As an example, the mid-
dle and right graphs of Figure 2 are two completions of the
2This requirement has been made with the introduction of
the framework [37]. Obviously, the lower bounds we present
hold even without this requirement. Moreover, our main up-
per bound, Theorem 6.1, holds as well without this require-
ment. We defer to future work the thorough investigation of
the impact of relaxing this requirement.

f g
br

f g
pa

f g
pi

f a
pi

f g
br

f g
pa

f g
pi

f a
pi

f g
br

f g
pa

f g
pi

f a
pi

f a
pa

f a
pa

f a
pa

Figure 2: The conﬂict graph HI
S and the priority rela-
tion (cid:31) for the company-CEO running example (left), and
two completions of (cid:31) (middle and right)

priority relation (cid:31) depicted on the left side. A completion of
(I,H,(cid:31)) is an inconsistent prioritizing instance (I,H,(cid:31)c)
where (cid:31)c is a completion of (cid:31).
2.4 Preferred Repairs
Let D = (I,H,(cid:31)) be an inconsistent prioritizing instance
over R. As deﬁned by Arenas et al. [3], J is a repair of D
if J is a maximal consistent subinstance of I. Staworko et
al. [37] deﬁne three different notions of preferred repairs:
Pareto optimal, globally optimal, and completion optimal.
The ﬁrst two notions are based on checking whether a re-
pair J of I can be improved by replacing a set of facts in
J with a more preferred set of facts from I. They differ by
the way they deﬁne when one set of facts is considered more
preferred than another one. The last notion is based on the
notion of completion. Next we give the formal deﬁnitions.

DEFINITION 2.5

(IMPROVEMENT). Let (I,H,(cid:31)) be an
inconsistent prioritizing instance over a signature R, and J
and J(cid:48) two distinct consistent subinstances of I.

• J is a Pareto improvement of J(cid:48) if there exists a fact
f ∈ J \ J(cid:48) such that f (cid:31) f(cid:48) for all facts f(cid:48) ∈ J(cid:48) \ J.
• J is a global improvement of J(cid:48) if for every fact f(cid:48) ∈
J(cid:48) \ J there exists a fact f ∈ J \ J(cid:48) such that f (cid:31) f(cid:48).
That is, J is a Pareto improvement of J(cid:48) if, in order to
obtain J from J(cid:48), we insert and delete facts, and one of the
inserted facts is preferred to all deleted facts. And J is a
global improvement of J(cid:48) if, in order to obtain J from J(cid:48),
we insert and delete facts, and every deleted fact is preferred
to by some inserted fact.

EXAMPLE 2.6. We continue the company-CEO running

example. We deﬁne three consistent subinstances of I.

def= {f g
def= {f g

pi} J2
pa} J4

br, f a
br, f a

def= {f g
def= {f g

pi}
pa, f a
pa}
pi, f a

J1

J3

pa ∈ J2 \ J1 and f g

Note the following. First, J2 is a Pareto improvement of J1,
pa (cid:31) f for every fact in J1 \ J2
since f g
(where in this case there is only one such an f, namely f g
br).
pi (cid:31) f g
Second, J4 is a global improvement of J2 because f g
and f a

pi. (We refer to J3 in later examples.)

pa (cid:31) f a

pa

We then get the following variants of preferred repairs.

4

DEFINITION 2.7

(P/G/C-REPAIR). Let D be an incon-
sistent prioritizing instance (I,H,(cid:31)), and let J be a consis-
tent subinstance of I. Then J is a:

• Pareto-optimal repair of D if there is no Pareto im-

provement of J.

• globally-optimal repair of D if there is no global im-

provement of J.

• completion-optimal repair of D if there exists a com-
pletion Dc of D such that J is a globally-optimal re-
pair of Dc.

We abbreviate “Pareto-optimal repair,” “globally-optimal
repair,” and “completion-optimal repair” by p-repair, g-repair
and c-repair, respectively.

We remark that in the deﬁnition of a completion-optimal
repair, we could replace “globally-optimal” with “Pareto-
optimal” and obtain an equivalent deﬁnition [37].
Let D = (I,H,(cid:31)) be an inconsistent prioritizing instance
over a signature R. We denote the set of all the repairs, p-
repairs, g-repairs and c-repairs of D by Rep(D), PRep(D),
GRep(D) and CRep(D), respectively. The following was
shown by Staworko et al. [37].

PROPOSITION 2.8. [37] For all inconsistent prioritizing

instances D we have CRep(D) (cid:54)= ∅, and moreover,

CRep(D) ⊆ GRep(D) ⊆ PRep(D) ⊆ Rep(D) .

EXAMPLE 2.9. We continue our company-CEO exam-
ple. Recall the instances Ji deﬁned in Example 2.6. We have
shown that J1 has a Pareto improvement, and therefore, J1 is
not a p-repair (although it is a repair in the ordinary sense).
The reader can verify that J2 has no Pareto improvements,
and therefore, it is a p-repair. But J2 is not a g-repair, since
J4 is a global improvement of J2. The reader can verify that
J3 is a g-repair (hence, a p-repair). Finally, observe that J4
is a g-repair w.r.t. the left completion of (cid:31) in Figure 2 (and
also w.r.t. the right one). Hence, J4 is a c-repair (hence, a
g-repair and a p-repair). In constrast, observe that J3 has
a global improvement (and a Pareto improvement) in both
completions; but it does not prove that J3 is not a c-repair
(since, conceptually, one needs to consider all possible com-
pletions of (cid:31)).

EXAMPLE 2.10. We now continue the follower example.
The inconsistent prioritizing instance (I,H,(cid:31)) is deﬁned in
Examples 2.2 and 2.4. Consider the following instance.

def= {f11, f22, f23, f32, f34, f35}

J1

The reader can verify that J1 is a c-repair (e.g., by com-
pleting (cid:31) through the lexicographic order). The subinstance
J2 = {f12, f21, f22, f34, f35} is a repair but not a p-repair,
since we can add f11 and remove both f12 and f21, and thus
obtain a Pareto improvement.

3. CATEGORICITY

In this section we deﬁne the computational problem of cat-
egoricity, which is the main problem that we study in this
paper. Proposition 2.8 states that, under each of the seman-
tics of preferred repairs, at least one such a repair exists. In
general, there can be many possible preferred repairs. The
problem of categoricity [37] is that of testing whether there
is precisely one such a repair; that is, there do not exist two
distinct preferred repairs, and therefore, the priority rela-
tion contains enough information to clean the inconsistent
instance unambiguously.

PROBLEM 3.1. Problems p-categoricity, g-categoricity,
and c-categoricity are those of testing whether |PRep(D)| =
1, |GRep(D)| = 1 and |CRep(D)| = 1, respectively, given
a signature R and an inconsistent prioritizing instance D
over R.

As deﬁned, categoricity takes as input both the signature
R and the inconsistent prioritizing instance D, where con-
straints are represented by a conﬂict hypergraph. We also
study this problem from the perspective of data complexity,
where we ﬁx a schema S = (R, ∆), where ∆ is a set of
FDs. In that case, the input consists of an instance I over
R and a priority relation ≺ over I. The conﬂict hypergraph
is then implicitly assumed to be HI
S. We denote the cor-
responding variants of the problem by p-categoricity(cid:104)S(cid:105), g-
categoricity(cid:104)S(cid:105) and c-categoricity(cid:104)S(cid:105), respectively.

EXAMPLE 3.2. Continuing our company-CEO example,
we showed in Example 2.9 that there are at least two g-
repairs and at least three p-repairs. Hence, a solver for g-
categoricity(cid:104)S(cid:105) should return false on (I,(cid:31)), and so is a
solver for p-categoricity(cid:104)S(cid:105). In contrast, we will later show
that there is precisely one c-repair (Example 6.2); hence, a
solver for c-categoricity(cid:104)S(cid:105) should return true on (I,(cid:31)). If,
on the other hand, we replaced (cid:31) with any of the comple-
tions in Figure 2, then there would be precisely one p-repair
and one g-repair (namely, the current single c-repair). This
follows from a result of Staworko et al. [37], stating that cat-
egoricity holds in the case of total priority relations.
4. PRELIMINARY INSIGHTS

We begin with some basic insights into the different vari-

ants of the categoricity problem.
4.1 Greedy Repair Generation

We recall an algorithm by Staworko et al. [37] for greed-
ily constructing a c-repair. This is the algorithm FindCRep
of Figure 3. The algorithm takes as input an inconsistent
prioritizing instance (I,H,(cid:31)) and returns a c-repair J. It
begins with an empty J, and incrementally inserts tuples to
J, as follows. In each iteration of lines 3–6, the algorithm
selects a fact f from max(cid:31)(I) and removes it from I. Then,
f is added to J if it does not violate consistency, that is, if
H does not contain any hyperedge e such that e ⊆ J ∪ {f}.
The speciﬁc way of choosing the fact f among all those in
max(cid:31)(I) is (deliberately) left unspeciﬁed, and hence, dif-
ferent executions may result in different c-repairs. In that

5

Algorithm FindCRep(I,H,(cid:31))

1: J := ∅
2: while max(cid:31)(I) (cid:54)= ∅ do
3:
4:
5:
6:
7: return J

J := J ∪ {f}

choose a fact f in max(cid:31)(I)
I := I \ {f}
if J ∪ {f} is consistent w.r.t. H then

Figure 3: Finding a c-repair [37]

sense, the algorithm is nondeterministic. Staworko et al. [37]
proved that the possible results of these different executions
are precisely the c-repairs.

THEOREM 4.1. [37] Let (I,H,(cid:31)) be an inconsistent pri-
oritizing instance over R. Let J be a consistent subinstance
of I. Then J is a c-repair if and only if there exists an exe-
cution of FindCRep(I,H,(cid:31)) that returns J.

Due to Theorem 4.1, we often refer to a c-repair as a
greedy repair. This theorem, combined with Proposition 2.8,
has several implications for us. First, we can obtain an x-
repair (where x is either p, g or c) in polynomial time. Hence,
if a solver for x-categoricity determines that there is a single
x-repair, then we can actually generate that x-repair in poly-
nomial time. Second, c-categoricity is the problem of test-
ing whether FindCRep(I,H,(cid:31)) returns the same instance
J on every execution. Moreover, due to Proposition 2.8, p-
categoricity (resp. g-categoricity) is the problem of testing
whether every p-repair (resp. g-repair) is equal to the one
that is obtained by some execution of the algorithm.

EXAMPLE 4.2. We consider the application of the algo-
rithm FindCRep to the instance of our company-CEO ex-
ample (where H = HI
S). The following are two different
executions. We denote inclusion in J (i.e., the condition of
line 5 is true) by plus and exclusion from J by minus.

• +f g
• +f a

pi, −f g
pa, −f a

pa, −f g
pi, +f g

br, +f a
pi, −f g

pa, −f a
pi.
pa, −f g
br.

pa}. This is
Observe that both executions return J4 = {f g
in par with the statement in Example 3.2 that in this running
example there is a single c-repair.
4.2 Complexity Insights

pi, f a

Our goal is to study the complexity of x-categoricity (where
x is g, p and c). This problem is related to that of x-repair
checking, namely, given D = (I,H,(cid:31)) and J, determine
whether J is an x-repair of D. The following is known about
this problem.

THEOREM 4.3. [12, 37] The following hold.
• p-repair checking and c-repair checking are solvable
in polynomial time; g-repair checking is in coNP [37].

6

• Let S = (R, ∆) be a ﬁxed schema. If ∆|R is equivalent
to either a single FD or two key constraints for every
R ∈ R, then g-repair checking is solvable in poly-
nomial time; otherwise, g-repair checking is coNP-
complete [12].

Recall from Proposition 2.8 that there is always at least
one x-repair. Therefore, given (I,H,(cid:31)) we can solve the
problem using a coNP algorithm with an oracle to x-repair
checking: for all two distinct subinstances J1 and J2, either
J1 or J2 is not an x-repair. Therefore, from Theorem 4.3 we
conclude the following.

COROLLARY 4.4. The following hold.
• p-categoricity and c-categoricity are in coNP.
• For all ﬁxed schemas S = (R, ∆), g-categoricity(cid:104)S(cid:105)
is in Πp
2, and moreover, if ∆|R is equivalent to either a
single FD or two key constraints for every R ∈ R then
g-categoricity(cid:104)S(cid:105) is in coNP.

2-hard).

We stress here that if x-categoricity is solvable in poly-
nomial time, then x-categoricity(cid:104)S(cid:105) is solvable in polyno-
mial time for all schemas S; this is true since for every ﬁxed
schema S the hypergraph HI
S can be constructed in polyno-
mial time, given I. Similarly, if x-categoricity(cid:104)S(cid:105) is coNP-
hard (resp. Πp
2-hard) for at least one S, then x-categoricity is
coNP-hard (resp. Πp
When we are considering x-categoricity(cid:104)S(cid:105), we assume
that all the integrity constraints are FDs. Therefore, unlike
the general problem of x-categoricity, in x-categoricity(cid:104)S(cid:105)
conﬂicting facts always belong to the same relation. It thus
follows that our analysis for x-categoricity(cid:104)S(cid:105) can restrict to
single-relation schemas. Formally, we have the following.
PROPOSITION 4.5. Let S = (R, ∆) be a schema and x
be one of p, g and c. For each relation R ∈ R, let S|R be
the schema ({R}, ∆|R).
• If x-categoricity(cid:104)S|R(cid:105) is solvable in polynomial time
for every R ∈ R, then x-categoricity(cid:104)S(cid:105) is solvable in
polynomial time.
2-hard) for
at least one R ∈ R, then x-categoricity(cid:104)S(cid:105) is coNP-
hard (resp. Πp

• If x-categoricity(cid:104)S|R(cid:105) is coNP-hard (resp. Πp

2-hard).

Observe that the phenomenon of Proposition 4.5 does not
hold for x-categoricity, since the given conﬂict hypergraph
may include hyperedges that cross relations.

In the following sections we investigate each of the three

variants of categoricity: p-categoricity (Section 5), c-categoricity
(Section 6) and g-categoricity (Section 7).
5. P-CATEGORICITY
In this section we prove a dichotomy in the complexity
of p-categoricity(cid:104)S(cid:105) over all schemas S (where ∆ consists
of FDs). This dichotomy states that the only tractable case
is where the schema associates a single FD (which can be
trivial) to each relation symbol, up to equivalence.
In all
other cases, p-categoricity(cid:104)S(cid:105) is coNP-complete. Formally,
we prove the following.

THEOREM 5.1. Let S = (R, ∆) be a schema. The prob-
lem p-categoricity(cid:104)S(cid:105) can be solved in polynomial time if
∆|R is equivalent to a single FD for every R ∈ R. In every
other case, p-categoricity(cid:104)S(cid:105) is coNP-complete.

The proof of Theorem 5.1 is involved, and we outline it in
the rest of this section. The tractability side is fairly simple
(as we show in the next section), and the challenge is in the
hardness side. Due to Proposition 4.5, it sufﬁces to consider
schemas S with a single relation. Hence, in the remainder of
this section we consider only such schemas S.
5.1 Proof of Tractability

In this section we ﬁx a schema S = (R, ∆), such that R
consist of a single relational symbol R. We will prove that
p-categoricity(cid:104)S(cid:105) is solvable in polynomial time if ∆ is a
singleton. We denote the single FD in ∆ as X → Y . We ﬁx
the input (I,(cid:31)) for p-categoricity(cid:104)S(cid:105).
For a fact f ∈ RI, we denote by f [X] and f [Y ] the restric-
tion of the tuple of f to the attributes in X and Y , respec-
tively. Adopting the terminology of Koutris and Wijsen [29],
a block of I is a maximal collection of facts of I that agree on
all the attributes of X (i.e., facts f that have the same f [X]).
Similarly, a subblock of I is a maximal collection of facts
that agree on both X and Y . For tuples a and b constants,
we denote by Ia the block of facts f with f [X] = a, and by
Ia,b the subblock of facts f with f [X] = a and f [Y ] = b.

EXAMPLE 5.2. Consider again the instance I of Figure 1,
and suppose that ∆ consists of only company → ceo (i.e.,
each company has a single CEO, but a person can be the
CEO of several companies). Then for a = (Google) and
b = (Pichai) the block Ia is {f g
br} and the subblock
Ia,b is the singleton {f g
pi}.
Tractability for S is based on the following lemma.

pa, f g

pi, f g

LEMMA 5.3. Let J be a subinstance of I. Then J is a
p-repair if and only if J is a union of p-repairs over all the
blocks Ia of I. Moreover, each p-repair of a block Ia is a
subblock Ia,b.

We then get the following lemma.

LEMMA 5.4. The following are equivalent.
1. I has a single p-repair.
2. Each block Ia has a single p-repair.
3. No block Ia has two distinct subblocks Ia,b and Ia,c

that are p-repairs of Ia.

A polynomial-time algorithm then follows directly from
Lemma 5.4 and the fact that p-repair checking is solvable in
polynomial time (Theorem 4.3).
5.2 Proof of Hardness

The hardness side of the dichotomy is more involved than
its tractability side. Our proof is based on the concept of a
fact-wise reduction [26], which has also been used by Fagin
et al. [12] in the context of g-repair checking.

7

5.2.1 Fact-Wise Reduction
Let S = (R, ∆) and S(cid:48) = (R(cid:48), ∆(cid:48)) be two schemas. A
mapping from R to R(cid:48) is a function µ that maps facts over
R to facts over R(cid:48). We naturally extend a mapping µ to map
instances J over R to instances over R(cid:48) by deﬁning µ(J) to
be {µ(f ) | f ∈ J}. A fact-wise reduction from S to S(cid:48) is a
mapping Π from R to R(cid:48) with the following properties.

1. Π is injective; that is, for all facts f and g over R, if

Π(f ) = Π(g) then f = g.

2. Π preserves consistency and inconsistency; that is, for
every instance J over S, the instance Π(J) satisﬁes ∆(cid:48)
if and only if J satisﬁes ∆.

3. Π is computable in polynomial time.
Let S and S(cid:48) be two schemas, and let Π be a fact-wise
reduction from S to S(cid:48). Given an inconsistent instance I
over S and a priority relation (cid:31) over I, we denote by Π((cid:31))
the priority relation (cid:31)(cid:48) over Π(I) where Π(f ) (cid:31)(cid:48) Π(g)
if and only if f (cid:31) g.
If D is the inconsistent prioritiz-
S,(cid:31)), then we denote by Π(D) the triple
ing instance (I,HI
(Π(I),HΠ(I)
, Π((cid:31))), which is also an inconsistent prioritiz-
ing instance. The usefulness of fact-wise reductions is due
to the following proposition, which is straightforward.

S(cid:48)

PROPOSITION 5.5. Let S and S(cid:48) be two schemas, and
suppose that Π is a fact-wise reduction from S to S(cid:48). Let I
be an inconsistent instance over S, (cid:31) a priority relation over
S,(cid:31)).
I, and D the inconsistent prioritizing instance (I,HI
Then there is a bijection between PRep(D) and PRep(Π(D)).

Speciﬁc Schemas

We then conclude the following corollary.
COROLLARY 5.6. If there is a fact-wise reduction from
S to S(cid:48), then there is a polynomial-time reduction from p-
categoricity(cid:104)S(cid:105) to p-categoricity(cid:104)S(cid:48)(cid:105).
5.2.2
In the proof we consider seven speciﬁc schemas. The im-
portance of these schemas will later become apparent. We
denote these schemas by Si, for i = 0, 1, . . . , 6, where each
Si is the schema (Ri, ∆i), and Ri is the singleton {Ri}.
The speciﬁcation of the Si is as follows.
0. R0/2 and ∆0 = {A → B, B → A}
1. R1/3 and ∆1 = {AB → C, BC → A, AC → B}
2. R2/3 and ∆2 = {A → B, B → A}
3. R3/3 and ∆3 = {AB → C, C → B}
4. R4/3 and ∆4 = {A → B, B → C}
5. R5/3 and ∆5 = {A → C, B → C}
6. R6/3 and ∆6 = {∅ → A, B → C}
(In the deﬁnition of S6, recall that ∅ → A denotes the
FD ∅ → {1}, meaning that all tuples should have the same
value for their ﬁrst attribute.) In the proof we use fact-wise
reductions from the Si, as we explain in the next section.

One FD

Two Keys

Other
Schemas

S0

S1

S2

S3

S4

S5

S6

Figure 4: The structure of fact-wise reductions for prov-
ing the hardness side of the dichotomy of Theorem 5.1

5.2.3 Two Hard Schemas
Our proof boils down to proving coNP-hardness for two
speciﬁc schemas, namely S0 and S6, and then using (known
and new) fact-wise reductions in order to cover all the other
schemas. For S6 the proof is fairly simple. But hardness for
S0 turns out to be quite challenging to prove, and in fact,
this part is the hardest in the proof of Theorem 5.1. Note
that S0 is the schema of our company-CEO running example
(introduced in Example 2.1).

THEOREM 5.7. The problems p-categoricity(cid:104)S0(cid:105) and p-

categoricity(cid:104)S6(cid:105) are both coNP-hard.

The proof (as well as all the other proofs for the results in

this paper) can be found in the appendix.
5.2.4 Applying Fact-Wise Reductions
The following has been proved by Fagin et al. [12].
THEOREM 5.8. [12] Let S = (R, ∆) be a schema such
that R consists of a single relation symbol. Suppose that ∆
is equivalent to neither any single FD nor any pair of keys.
Then there is a fact-wise reduction from some Si to S, where
i ∈ {1, . . . , 6}.

In the appendix we prove the following two lemmas, giv-

ing additional fact-wise reductions.

LEMMA 5.9. Let S = (R, ∆) be a schema such that R
consists of a single relation symbol. Suppose that ∆ is equiv-
alent to a pair of keys, and ∆ is not equivalent to any single
FD. Then there is a fact-wise reduction from S0 to S.

LEMMA 5.10. For all i = 1, . . . , 5 there is a fact-wise

reduction from S0 to Si.

The structure of our fact-wise reductions is depicted in
Figure 4. Dashed edges are known fact-wise reductions,

8

Algorithm CCategoricity(I,H,(cid:31))

1: i := 0
2: J := ∅
3: while I (cid:54)= ∅ do
4:
5:
6:
7: Ni := {f ∈ I | H has a hyperedge e s.t. f ∈ e,

i := i + 1
Pi := max(cid:31)+(I)
J := J ∪ Pi
(e \ {f}) ⊆ J, and (e \ {f}) (cid:31)+ f}
I := I \ (Pi ∪ Ni)

8:
9: return true iff J is consistent

Figure 5: Algorithm for c-categoricity

while solid edges are novel. Observe that each single-relation
schema on the hardness side of Theorem 5.1 has an ingoing
path from either S0 or S6, both shown to have coNP-hard
p-categoricity (Theorem 5.7).

6. C-CATEGORICITY

We now investigate the complexity of c-categoricity. Our

main result is that this problem is tractable.

THEOREM 6.1. The c-categoricity problem is solvable in

polynomial time.

In the remainder of this section we establish Theorem 6.1
by presenting a polynomial-time algorithm for solving c-
categoricity. The algorithm is very simple, but its proof of
correctness (given in the appendix) is intricate.
6.1 Notation
To present our algorithm, some notation is required. Let
(I,H,(cid:31)) be an inconsistent prioritizing instance. The tran-
sitive closure of (cid:31), denoted (cid:31)+, is the priority relation over
the facts of I where for every two facts f and g in I it holds
that f (cid:31)+ g if and only if there exists a sequence f0, . . . , fm
of facts, where m > 0, such that f = f0, fm = g, and
fi (cid:31) fi+1 for all i = 0, . . . , m− 1. Obviously, (cid:31)+ is acyclic
(since (cid:31) is acyclic). But unlike (cid:31), the relation (cid:31)+ may com-
pare between facts that are not necessarily neighbors in H.
Let (I,H,(cid:31)) be an inconsistent prioritizing instance, let
K be a set of facts of I, and let f be a fact of I. By K (cid:31)+ f
we denote the fact that g (cid:31)+ f for every fact g ∈ K.
6.2 Algorithm

Figure 5 depicts a polynomial-time algorithm for solving
c-categoricity. We next explain how it works, and later dis-
cuss its correctness.
As required, the input for the algorithm is an inconsis-
tent prioritizing instance (I,H,(cid:31)). (The signature R is not
needed by the algorithm.) The algorithm incrementally con-
structs a subinstance J of I, starting with an empty J. Later
we will prove that there is a single c-repair if and only if

J is consistent; and in that case, J is the single c-repair.
The loop in the algorithm constructs fact sets P1, . . . , Pt and
N1, . . . , Nt. Each Pi is called a positive stratum and each
Ni is called a negative stratum. Both Pi and Ni are con-
structed in the ith iteration. On that iteration we add all the
facts of Pi to J and remove from I all the facts of Pi and all
the facts of Ni. The sets Pi and Ni are deﬁned as follows.
• Pi consists of the maximal facts in the current I, ac-
cording to (cid:31)+.
• Ni consists of all the facts f that, together with P1 ∪
··· ∪ Pi, complete a hyperedge of preferred facts; that
is, H contains a hyperedge that contains f, is contained
in P1 ∪ ··· ∪ Pi ∪ {f}, and satisﬁes g (cid:31)+ f for every
incident g (cid:54)= f.

The algorithm continues to iterate until I gets empty. As
said above, in the end the algorithm returns true if J is con-
sistent, and otherwise false. Next, we give some examples
of executions of the algorithm.

EXAMPLE 6.2. Consider the inconsistent prioritizing in-
stance (I,H,(cid:31)) from our company-CEO running example,
illustrated on the left side of Figure 2. The algorithm makes
a single iteration on this instance, where P1 = {f g
pa} and
pa}. Both f g
N1 = {f g
pa are in P1 since both
pa is in conﬂict with
are maximal. Also, each of f g
pi (cid:31) f g
P1, and we have f g
pa, f a

pi and f a
pa, f a
pa (cid:31) f a

pi (cid:31)+ f g
br.

pa, f a

pi, f g

pi and f g

pi, and f g

pi, f a

EXAMPLE 6.3. Now consider the inconsistent prioritiz-
ing instance (I,H,(cid:31)) from our followers running example.
Figure 6 illustrates the execution of the algorithm, where
each column describes Pi or Ni, from left to right in the
order of their construction. For convenience, the priority re-
lation (cid:31), as deﬁned in Example 2.4, is depicted in Figure 6
using corresponding edges between the facts.
On iteration 1, for instance, we have P1 = {f11, f34},
since f11 and f34 are the facts without incoming edges on
Figure 6. Moreover, we have N1 = {f12, f21, f31}. The
reason why N1 contains f12, for example, is that {f11, f12}
is a hyperedge, the fact f11 is in P1, and f11 (cid:31) f12 (hence,
f11 (cid:31)+ f12). For a similar reason N1 contains f21. Fact f31
is in N1 as {f11, f31} is a hyperedge, and though f11 (cid:54)(cid:31) f31,
we have f11 (cid:31)+ f31. As another example, N3 contains f24
since H has the hyperedge {f22, f23, f24}, the set {f22, f23}
is contained in P1 ∪ P2 ∪ P3, and {f22, f23} (cid:31)+ f24.
In the end, J = {f11, f22, f23, f32, f34, f35}, which is
also the subinstance J1 of Example 2.10. Since J is con-
sistent, the algorithm will determine that there is a single
c-repair, and that c-repair is J.

EXAMPLE 6.4. We now give an example of an execution
on a negative instance of c-categoricity. (In Section 7 we re-
fer to this example for a different reason.) Figure 7 shows
an instance I over the schema S1, which is deﬁned in Sec-
tion 5.2.2. Recall that in this schema every two attributes
form a key. Each fact R1(a1, a2, a3) in I is depicted by a tu-
ple that consists of the three values. For example, I contains
the (conﬂicting) facts R1(A, a, 1) and R1(A, a, 2). Hereon,
we write Xyi instead of R1(X, y, i). The priority relation (cid:31) is

N2

P2

f22

P1

f11

N1

f12

f21

f31

N3

f24

P3

f23

f32

f34

f35

Figure 6: Execution of CCategoricity on the followers
example

A b 2

B a 3

A a 1

A a 2

B b 3

B b 1

B a 2

A b 3

Figure 7: An inconsistent instance I over S1 with a pri-
ority relation (cid:31) over I

S1

given by the directed edges between the facts; for example,
Aa1 (cid:31) Aa2. Undirected edges are between conﬂicting facts
that are incomparable by (cid:31) (e.g., Ab2 and Ab3).
,(cid:31)) is as fol-
The execution of the algorithm on (I,HI
lows. On the ﬁrst iteration, P1 = {Aa1, Ab2, Ba3, Bb1} and
N1 = {Aa2, Bb3}. In particular, note that N1 does not con-
tain Ba2 since it conﬂicts only with Ba3 in P1, but the two
are incomparable. Similarly, N1 does not contain Ab3 since
it is incomparable with Ab2. Consequently, in the second
iteration we have P2 = {Ba2, Ab3} and N2 = ∅. In the end,
J = P1 ∪ P2 is inconsistent, and therefore, the algorithm
Indeed, the reader can easily verify that
will return false.
each of the following is a c-repair: {Aa1, Ab2, Ba3, Bb1},
{Aa1, Ab2, Ba2, Bb1}, and {Aa1, Ba3, Ab3, Bb1}.

6.3 Correctness

Correctness of CCategoricity is stated in the following

theorem.

THEOREM 6.5. Let (I,H,(cid:31)) be an inconsistent priori-
tizing instance, and let J be the subinstance of I constructed
in the execution of CCategoricity(I,H,(cid:31)). Then the follow-
ing are equivalent.

1. J is consistent.
2. There is a single c-repair.

Moreover, if J is consistent then J is the single c-repair.

Theorem 6.5, combined with the observation that the al-
gorithm CCategoricity terminates in polynomial time, imply
Theorem 6.1. As previously said, the proof of Theorem 6.5
is quite involved. The direction 1 → 2 is that of soundness—
if the algorithm returns true then there is precisely one c-

9

repair. The direction 2 → 1 is that of completeness—if there
is precisely one c-repair then the algorithm returns true.
Soundness is the easier direction to prove. We assume, by
way of contradiction, that there is a c-repair J(cid:48) different from
the subinstance J returned by the algorithm. Such J(cid:48) must
include a fact f(cid:48) from some negative stratum. We consider
an execution of the algorithm FindCRep that returns J(cid:48), and
establish a contradiction by considering the ﬁrst time such
an f(cid:48) is being added to the constructed solution.

Proving completeness is more involved. We assume, by
way of contradiction, that the constructed J is inconsistent.
We are looking at the ﬁrst positive stratum Pi such that P1 ∪
··· ∪ Pi contains a hyperedge. Then, the crux of the proof
is in showing that we can then construct two c-repairs using
the algorithm FindCRep: one contains some fact from Pi
and another one does not contain that fact. We then establish
that there are at least two c-repairs, hence a contradiction.

7. G-CATEGORICITY

In this section, we investigate the complexity of the g-
categoricity. We ﬁrst show a tractability result for the case of
a schema with a single FD. Then, we show Πp
2-completeness
for a speciﬁc schema. Finally, we discuss the implication of
assuming transitivity in the priority relation, and show a gen-
eral positive result therein.
7.1 Tractable Schemas
Recall from Theorem 5.1 that, assuming P (cid:54)= NP, the
problem p-categoricity(cid:104)S(cid:105) is solvable in polynomial time if
and only if S consists (up to equivalence) of a single FD per
relation. The reader can verify that the same proof works for
g-categoricity(cid:104)S(cid:105). Hence, our ﬁrst result is that the tractable
schemas of p-categoricity remain tractable for g-categoricity.
THEOREM 7.1. Let S = (R, ∆) be a schema. The prob-
lem g-categoricity(cid:104)S(cid:105) can be solved in polynomial time if
∆|R is equivalent to a single FD for every R ∈ R.

It is left open whether there is any schema S that is not as
in Theorem 7.1 where g-categoricity(cid:104)S(cid:105) is solvable in poly-
nomial time. In the next section we give an insight into this
open problem (Theorem 7.4).
7.2
Our next result shows that g-categoricity(cid:104)S(cid:105) hits a harder
complexity class than p-categoricity(cid:104)S(cid:105). In particular, while
p-categoricity(cid:104)S(cid:105) is always in coNP (due to Theorem 4.4),
we will show a schema S where g-categoricity(cid:104)S(cid:105) is Πp
2-
complete. This schema is the schema S6 from Section 5.2.2.

Intractable Schemas

THEOREM 7.2. g-categoricity(cid:104)S6(cid:105) is Πp

2-complete.

The proof of Theorem 7.2 is by a reduction from the Πp
2-
complete problem QCNF2: Given a CNF formula ψ(x, y),
determine whether it is the case that for every truth assign-
ment to x there exists a truth assignment to y such that the
two assignments satisfy ψ.

We can generalize Theorem 7.2 to a broad set of schemas,
by using fact-wise reductions from S6. This is done in the
following theorem.

THEOREM 7.3. Let S = (R, ∆) be a schema such that
R consists of a single relation symbol R and ∆ consists of
two nontrivial FDs X → Y and W → Z. Suppose that
each of W and Z contains an attribute that is in none of the
other three sets. Then g-categoricity(cid:104)S(cid:105) is Πp

2-complete.

As an example, recall that in S6 we have ∆ = {∅ →
A, B → C}. This schema is a special case of Theorem 7.3,
since we can use ∅ → A as X → Y and B → C as W → Z;
and indeed, each of W and Z contains an attribute (namely
B and C, respectively) that is not in any of the other three
sets. Additional examples of sets of FDs that satisfy the
conditions of Theorem 7.3 (and hence the corresponding g-
categoricity(cid:104)S(cid:105) is Πp
2-complete) follow. All of these sets are
over a relation symbol R/4. (And in each of these sets, the
ﬁrst FD corresponds to X → Y and the second to W → Z.)

• A → B, C → D
• A → C, AB → CD
• A → B, ABC → D
• A → B, C → ABD
Unlike S6, to this day we do not know what is the com-
plexity of g-categoricity(cid:104)Si(cid:105) for any of the other Si (deﬁned
in Section 5.2.2). This includes S0, for which all we know is
membership in coNP (as stated in Theorem 4.4). However,
except for this open problem, the proof technique of Theo-
rem 5.1 is valid for g-categoricity(cid:104)S(cid:105). Consequently, we can
show the following.

THEOREM 7.4. The following are equivalent.
• g-categoricity(cid:104)S0(cid:105) is coNP-hard.
• g-categoricity(cid:104)S(cid:105) is coNP-hard for every schema S that
falls outside the polynomial-time cases of Theorem 7.1.

7.3 Transitive Priority
Let (I,H,(cid:31)) be an inconsistent prioritizing instance. We
say that (cid:31) is transitive if for every two facts f and g in I, if f
and g are neighbors in H and f (cid:31)+ g, then f (cid:31) g. Transitiv-
ity is a natural assumption when (cid:31) is interpreted as a partial
order such as “is of better quality than” or “is more current
than.” In this section we consider g-categoricity in the pres-
ence of this assumption. The following example shows that a
g-repair is not necessarily a c-repair, even if (cid:31) is transitive.
This example provides an important context for the results
that follow.

EXAMPLE 7.5. Consider again I and (cid:31) from Example 6.4
(depicted in Figure 7). Observe that (cid:31) is transitive. In partic-
ular, there is no priority between Ab2 and Ba2, even though
Ab2 (cid:31) Ba2, because Ab2 and Ba2 are not in conﬂict (or
put differently, they are not neighbors in HI
S1). Consider the
following subinstance of I.

J def= {Aa1, Ba2, Ab3, Bb1}

The reader can verify that J is a g-repair, but not a c-repair
(since no execution of FindCRep can generate J).

10

Example 7.5 shows that the notion global optimality is dif-
ferent from completion optimality, even if the priority rela-
tion is transitive. Yet, quite remarkably, the two notions be-
have the same when it comes to categoricity.

THEOREM 7.6. Let D = (I,H,(cid:31)) be an inconsistent
prioritizing instance such that (cid:31) is transitive. |CRep(D)| =
1 if and only if |GRep(D)| = 1.

PROOF. The “if” direction follows from Proposition 2.8,
since every c-repair is also a g-repair. The proof of the “only
if” direction is based on the special structure of the c-repair,
as established in Section 6, in the case where only one c-
repair exists. Speciﬁcally, suppose that there is a single c-
repair J and let J(cid:48) (cid:54)= J be a consistent subinstance of I. We
need to show that J(cid:48) has a global improvement. We claim
that J is a global improvement of J(cid:48). This is clearly the case
if J(cid:48) ⊆ J. So suppose that J(cid:48) (cid:54)⊆ J. Let f(cid:48) be a fact in J(cid:48) \ J.
We need to show that there is a fact f ∈ J \ J(cid:48) such that
f (cid:31) f(cid:48). We complete the proof by ﬁnding such an f.
Recall from Theorem 6.5 that J is the result of executing
CCategoricity(I,H,(cid:31)). Consider the positive strata Pi and
the negative strata Nj constructed in that execution. Since J
is the union of the positive strata, we get that f(cid:48) necessarily
belongs to a negative stratum, say Nj. From the deﬁnition
of Nj it follows that H has a hyperedge e such that f(cid:48) ∈ e,
(e \ {f(cid:48)}) ⊆ P1 ∪ ··· ∪ Pj, and (e \ {f(cid:48)}) (cid:31)+ f(cid:48). Let e
be such a hyperedge. Since J(cid:48) is consistent, it cannot be the
case that J(cid:48) contains all the facts in e. Choose a fact f ∈ e
such that f /∈ J(cid:48). Then f (cid:31)+ f(cid:48), and since (cid:31) is transitive
(and f and f(cid:48) are neighbors), we have f (cid:31) f(cid:48). So f ∈ J \ J(cid:48)
and f (cid:31) f(cid:48), as required.

Combining Theorems 6.1 and 7.6, we get the following.

COROLLARY 7.7. For transitive priority relations, prob-
lems g-categoricity and c-categoricity coincide, and in par-
ticular, g-categoricity is solvable in polynomial time.

COMMENT 7.8. The reader may wonder whether Theo-
rem 7.6 and Corollary 7.7 hold for p-categoricity as well.
This is not the case. The hardness of p-categoricity(cid:104)S6(cid:105)
(Theorem 5.7) is proved by constructing a reduction where
the priority relation is transitive (and in fact, it has no chains
of length larger than one).

In their analysis, Fagin et al. [12] have constructed various
reductions for proving coNP-hardness of g-repair checking.
In several of these, the priority relation is transitive. We con-
clude that there are schemas S such that, on transitive prior-
ity relations, g-repair checking is coNP-complete whereas
g-categoricity is solvable in polynomial time.

8. RELATED WORK ON DATA CLEANING

We now discuss the relationship between our work and
past work on data cleaning. Speciﬁcally, we focus on re-
lating and contrasting our complexity results with ones es-
tablished in past research. To the best of our knowledge,

11

Bohannon et al. [6] have studied a repairing framework
where repairing operations involve attribute updates and tu-
ple insertions, and where the quality of a repair is determined
by a cost function (aggregating the costs of individual oper-
ations). They have shown that ﬁnding an optimal repair is
NP-hard, in data complexity, even when integrity constraints
consist of only FDs. This result could be generalized to
hardness of categoricity in their model (e.g., by a reduction
from the unique exact 3-cover problem [35]). The source
of hardness in their model is the cost minimization, and it
is not clear how any of our hardness results could derive
from those, as the framework of preferred repairs (adopted
here) does not involve any cost-based quality; in particular,
as echoed in this paper, an optimal repair can be found in
polynomial time under each of the three semantics [37].

In the framework of data currency [15, Chapter 6] [16],
relations consist of entities with attributes, where each entity
may appear in different tuples, every time with possibly dif-
ferent (conﬂicting) attribute values. A partial order on each
attribute is provided, where “greater than” stands for “more
current.” A completion of an instance is obtained by com-
pleting the partial order on an attribute of every entity, and
it deﬁnes a current instance where each attribute takes its
most recent value. In addition, a completion needs to sat-
isfy given (denial) constraints, which may introduce interde-
pendencies among completions of different attributes. Fan
et al. [16] have studied the problem of determining whether
such a speciﬁcation induces a single current instance (i.e.,
the corresponding version of categoricity), and showed that
this problem is coNP-complete under data complexity.
It
is again not clear how to simulate their hardness in our p-
categoricity and g-categoricity, since their hardness is due to
the constrains on completions, and these constraints do not
have correspondents in our case (beyond the partial orders).
A similar argument relates our lower bounds to those in the
framework of conﬂict resolution by Fan Geerts [15, Chap-
ter 7.3], where the focus is on establishing a unique tuple
from a collection of conﬂicting tuples.

there has not been any work on the complexity of categoric-
ity within the prioritized repairing of Staworko et al. [36].
Fagin et al. [13] investigated a static version of categoricity
in the context of text extraction, but the settings and prob-
lems are very different, and so are the complexity results
(e.g., Fagin et al. [13] establish undecidability results).

Fan et al. [16] show that in the absence of constraints, their
categoricity problem can be solved in polynomial time (even
in the presence of “copy functions”). This tractability result
can be used for establishing the tractability side of Theo-
rem 5.1 in the special case where the single FD is a key
constraint. In the general case of a single FD, we need to
argue about relationships among sets, and in particular, the
differences among the three x-categoricity problems matter.
Cao et al. [8] have studied the problem of entity record
cleaning, where again the attributes of an entity are repre-
sented as a relation (with missing values), and a partial order
is deﬁned on each attribute. The goal is to increase the accu-
racy of values from the partial orders and an external source
of reliable (“master”) data. The speciﬁcation now gives up-

date steps that have the form of logical rules that specify
when one value should replace a null, when new preferences
are to be derived, and when data should be copied from the
master data. Hence, cleaning is established by chasing these
rules. They study a problem related to categoricity, namely
the Church-Rosser property: is it the case that every applica-
tion of the chase (in any rule-selection and grounding order)
results in the same instance? They show that this property is
testable in polynomial time by giving an algorithm that tests
whether some invalid step in the end of the execution has
been valid sometime during the execution. We do not see
any clear way of deriving any of our upper bounds from this
result, due to the difference in the update model (updating
nulls and preferences vs. tuple deletion), and the optimality
model (chase termination vs. x-repair).

The works on certain ﬁxes [17, 18] [15, Chapters 7.1–
7.2] consider models that are substantially different from
the one adopted here, where repairs are obtained by chas-
ing update rules (rather than tuple deletion), and unique-
ness applies to chase outcomes (rather than maximal subin-
stances w.r.t. preference lifting). The problems relevant to
our categoricity are the consistency problem [18] (w.r.t. guar-
antees on the consistency of some attributes following cer-
tain patterns), and the determinism problem [18]. They are
shown to be intractable (coNP-complete [17] and PSPACE-
complete [18]) under combined complexity (while we focus
here on data complexity).

Finally, we remark that there have several dichotomy re-
sults on the complexity of problems associated with incon-
sistent data [12, 28, 31], but to the best of our knowledge
this paper is the ﬁrst to establish a dichotomy result for any
variant of repair uniqueness identiﬁcation.

9. CONCLUDING REMARKS

We investigated the complexity of the categoricity prob-
lem, which is that of determining whether the provided pri-
ority relation sufﬁces to clean the database unambiguously
in the framework of preferred repairs. Following the three
semantics of optimal repairs, we investigated the three vari-
ants of this problem: p-categoricity, g-categoricity and c-
categoricity. We established a dichotomy in the data com-
plexity of p-categoricity for the case where constraints are
FDs, partitioning the cases into polynomial time and coNP-
completeness. We further showed that the tractable side of p-
categoricity extends to g-categoricity, but the latter can reach
Πp
2-completeness already for two FDs. Finally, we showed
that c-categoricity is solvable in polynomial time in the gen-
eral case where integrity constraints are given as a conﬂict
hypergraph. We complete this paper by discussing direc-
tions for future research.

In this work we did not address any qualitative discrimi-
nation among the three notions of x-repairs. Rather, we con-
tinue the line of work [13, 36] that explores the impact of
the choice on the entailed computational complexity. It has
been established that, as far as repair checking is concerned,
the Pareto and the completion semantics behave much bet-
ter than the global one, since g-repair checking is tractable

12

only in a very restricted class of schemas [13]. In this work
we have shown that from the viewpoint of categoricity, the
Pareto semantics departs from the completion one by being
likewise intractable (while the global semantics hits an even
higher complexity class), hence the completion semantics
outstands so far as the most efﬁcient option to adopt.

It would be interesting to further understand the complex-
ity of g-categoricity, towards a dichotomy (at least for FDs).
We have left open the question of whether there exists a
schema with a single relation and a set of FDs, not equiv-
alent to a single FD, such that g-categoricity is solvable in
polynomial time. Beyond that, for both p-categoricity and
g-categoricity it is important to detect islands of tractability
based on properties of the data and/or the priority relation
(as schema constraints do not get us far in terms of efﬁcient
algorithms, at least by our dichotomy for p-repairs), beyond
transitivity in the case of g-categoricity (Corollary 7.7).

Another interesting direction would be the generalization
of categoricity to the problems of counting and enumerating
the preferred repairs. For classical repairs (without a pri-
ority relation), Maslowski and Wijsen [31, 32] established
dichotomies (FP vs. #P-completeness) in the complexity of
counting in the case where constraints are primary keys. For
the general case of denial constraints, counting the classi-
cal repairs reduces to the enumeration of independent sets
of a hypergraph with a bounded edge size, a problem shown
by Boros et al. [7] to be solvable in incremental polynomial
time (and in particular polynomial input-output complexity).
For a general given conﬂict hypergraph, repair enumeration
is the well known problem of enumerating the minimal hy-
pergraph transversals (also known as the hypergraph duality
problem); whether this problem is solvable in polynomial to-
tal time is a long standing open problem [22].

In this work we focused on cleaning within the frame-
work of preferred repairs, where integrity constraints are
anti-monotonic and cleaning operations are tuple deletions
(i.e., subset repairs). However, the problem of categoricity
arises in every cleaning framework that is based on deﬁning
a set of repairs with a preference between repairs, including
different types of integrity constraints, different cleaning op-
erations (e.g., tuple addition and cell update [38]), and differ-
ent priority speciﬁcations among repairs. This includes pref-
erences by means of general scoring functions [24, 33], ag-
gregation of scores on the individual cleaning operations [6,
11, 18, 18, 27], priorities among resolution policies [30] and
preferences based on soft rules [23, 34]. This also includes
the LLUNATIC system [20, 21] where priorities are deﬁned
by lifting partial orders among “cell groups,” representing ei-
ther semantic preferences (e.g., timestamps) or level of com-
pleteness (e.g., null vs. non-null). A valuable future direc-
tion would be to investigate the complexity of categoricity
in the above frameworks, and in particular, to see whether
ideas or proof techniques from this work can be used to an-
alyze their categoricity.

Motivated by the tractability of c-categoricity, we plan to
pursue an implementation of an interactive and declarative
system for database cleaning, where rules are of two kinds:
integrity constraints and priority speciﬁcations (e.g., based

on the semantics of priority generating dependencies of Fa-
gin et al. [13]). To make such a system applicable to a wide
range of practical use cases, we will need to extend beyond
subset repairs, and consequently, investigate the fundamen-
tal direction of extending the framework of preferred repairs
towards such repairs.

10. REFERENCES
[1] F. N. Afrati and P. G. Kolaitis. Repair checking in

inconsistent databases: algorithms and complexity. In
ICDT, pages 31–41. ACM, 2009.

[2] D. E. Appelt and B. Onyshkevych. The common
pattern speciﬁcation language. In TIPSTER Text
Program: Phase III, pages 23–30. Association for
Computational Linguistics, 1998.

[3] M. Arenas, L. E. Bertossi, and J. Chomicki.

Consistent query answers in inconsistent databases. In
PODS, pages 68–79. ACM, 1999.

[4] L. E. Bertossi. Database Repairing and Consistent

Query Answering. Synthesis Lectures on Data
Management. Morgan & Claypool Publishers, 2011.

[5] P. Bohannon, W. Fan, F. Geerts, X. Jia, and
A. Kementsietsidis. Conditional functional
dependencies for data cleaning. In ICDE, pages
746–755. IEEE, 2007.

[6] P. Bohannon, M. Flaster, W. Fan, and R. Rastogi. A

cost-based model and effective heuristic for repairing
constraints by value modiﬁcation. In SIGMOD, pages
143–154. ACM, 2005.

[7] E. Boros, K. M. Elbassioni, V. Gurvich, and

L. Khachiyan. An efﬁcient incremental algorithm for
generating all maximal independent sets in
hypergraphs of bounded dimension. Parallel
Processing Letters, 10(4):253–266, 2000.

[8] Y. Cao, W. Fan, and W. Yu. Determining the relative
accuracy of attributes. In SIGMOD, pages 565–576.
ACM, 2013.

[9] L. Chiticariu, R. Krishnamurthy, Y. Li, S. Raghavan,

F. Reiss, and S. Vaithyanathan. SystemT: An algebraic
approach to declarative information extraction. In
ACL, pages 128–137, 2010.

[10] J. Chomicki and J. Marcinkowski. Minimal-change

integrity maintenance using tuple deletions. Inf.
Comput., 197(1-2):90–121, 2005.

[11] M. Dallachiesa, A. Ebaid, A. Eldawy, A. K.

Elmagarmid, I. F. Ilyas, M. Ouzzani, and N. Tang.
NADEEF: a commodity data cleaning system. In
SIGMOD, pages 541–552. ACM, 2013.

[12] R. Fagin, B. Kimelfeld, and P. G. Kolaitis.

Dichotomies in the complexity of preferred repairs. In
PODS, pages 3–15. ACM, 2015.

[13] R. Fagin, B. Kimelfeld, F. Reiss, and

S. Vansummeren. Cleaning inconsistencies in
information extraction via prioritized repairs. In
PODS, pages 164–175. ACM, 2014.

[14] R. Fagin, B. Kimelfeld, F. Reiss, and S. Vansummeren.

Document spanners: A formal approach to
information extraction. J. ACM, 62(2):12, 2015.

[15] W. Fan and F. Geerts. Foundations of Data Quality

Management. Synthesis Lectures on Data
Management. Morgan & Claypool Publishers, 2012.

[16] W. Fan, F. Geerts, and J. Wijsen. Determining the

currency of data. ACM Trans. Database Syst.,

13

37(4):25, 2012.

[17] W. Fan, J. Li, S. Ma, N. Tang, and W. Yu. Towards

certain ﬁxes with editing rules and master data. VLDB
J., 21(2):213–238, 2012.

[18] W. Fan, S. Ma, N. Tang, and W. Yu. Interaction

between record matching and data repairing. J. Data
and Information Quality, 4(4):16:1–16:38, 2014.

[19] T. Gaasterland, P. Godfrey, and J. Minker. An

overview of cooperative answering. J. Intell. Inf. Syst.,
1(2):123–157, 1992.

[20] F. Geerts, G. Mecca, P. Papotti, and D. Santoro. The

LLUNATIC data-cleaning framework. PVLDB,
6(9):625–636, 2013.

[21] F. Geerts, G. Mecca, P. Papotti, and D. Santoro.

Mapping and cleaning. In ICDE, pages 232–243.
IEEE, 2014.

[22] G. Gottlob and E. Malizia. Achieving new upper

bounds for the hypergraph duality problem through
logic. In CSL-LICS, pages 43:1–43:10. ACM, 2014.

[23] S. Greco, C. Sirangelo, I. Trubitsyna, and

E. Zumpano. Feasibility conditions and preference
criteria in querying and repairing inconsistent
databases. In DEXA, volume 3180 of LNCS, pages
44–55. Springer, 2004.

[24] S. Greco, C. Sirangelo, I. Trubitsyna, and

E. Zumpano. Preferred repairs for inconsistent
databases. In Encyclopedia of Database Technologies
and Applications, pages 480–485. Idea Group, 2005.

[25] B. Kimelfeld. A dichotomy in the complexity of

deletion propagation with functional dependencies. In
PODS, pages 191–202, 2012.

[26] B. Kimelfeld, J. Vondrák, and R. Williams.
Maximizing conjunctive views in deletion
propagation. ACM Trans. Database Syst., 37(4):24,
2012.

[27] S. Kolahi and L. V. S. Lakshmanan. On approximating
optimum repairs for functional dependency violations.
In ICDT, volume 361 of ACM International
Conference Proceeding Series, pages 53–62. ACM,

2009.

[28] P. Koutris and D. Suciu. A dichotomy on the

complexity of consistent query answering for atoms
with simple keys. In ICDT, pages 165–176.
OpenProceedings.org, 2014.

[29] P. Koutris and J. Wijsen. The data complexity of

consistent query answering for self-join-free
conjunctive queries under primary key constraints. In
PODS, pages 17–29. ACM, 2015.

[30] M. V. Martinez, F. Parisi, A. Pugliese, G. I. Simari,
and V. S. Subrahmanian. Inconsistency management
policies. In KR, pages 367–377. AAAI Press, 2008.

[31] D. Maslowski and J. Wijsen. A dichotomy in the

complexity of counting database repairs. J. Comput.
Syst. Sci., 79(6):958–983, 2013.

[32] D. Maslowski and J. Wijsen. Counting database

repairs that satisfy conjunctive queries with self-joins.
In ICDT, pages 155–164. OpenProceedings.org, 2014.

[33] A. Motro, P. Anokhin, and A. C. Acar. Utility-based

resolution of data inconsistencies. In IQIS, pages
35–43. ACM, 2004.

[34] D. V. Nieuwenborgh and D. Vermeir. Preferred answer

sets for ordered logic programs. TPLP,
6(1-2):107–167, 2006.

[35] O. Schulte, W. Luo, and R. Greiner. Mind change

optimal learning of bayes net structure from
dependency and independency data. Inf. Comput.,
208(1):63–82, 2010.

[36] S. Staworko, J. Chomicki, and J. Marcinkowski.

Preference-driven querying of inconsistent relational
databases. In EDBT Workshops, volume 4254 of
LNCS, pages 318–335. Springer, 2006.

[37] S. Staworko, J. Chomicki, and J. Marcinkowski.

Prioritized repairing and consistent query answering in
relational databases. Ann. Math. Artif. Intell.,
64(2-3):209–246, 2012.

[38] J. Wijsen. Database repairing using updates. ACM

Trans. Database Syst., 30(3):722–768, 2005.

14

APPENDIX
A. PROOFS FOR SECTION 5

In this section we provide proofs for Section 5.

A.1 Proof of Lemma 5.3
In the following section, we say that a block Ia (respectively, Ia,b) is the block (respectively, subblock) of a fact f if f ∈ Ia
(respectively f ∈ Ia,b). Note that each fact has a unique block and subblock.

of I. Moreover, each p-repair of a block Ia is a subblock Ia,b.

LEMMA 5.3. Let J be a subinstance of I. Then J is a p-repair if and only if J is a union of p-repairs over all the blocks Ia
PROOF. Recall that ∆ is the set {A → B}. We start by proving the second part of the lemma. That is, we show that each
p-repair of a block Ia is a subblock Ia,b. Let K be a p-repair of Ia. Then K is contained in a single subblock of Ia, since K is
consistent. Moreover, K contains all the facts in Ia,b, or otherwise K has a Pareto improvement.

Next, we prove the ﬁrst part of the lemma.

The “if” direction. Let J be a p-repair of I. We need to show that J is a union of p-repairs over all the blocks Ia of I.
Observe that J is consistent, and so, for each block Ia it contains facts from at most one subblock Ia,b. Moreover, since J is
maximal, it contains at least one representative from each block Ia, and furthermore, it contains the entire subblock of each
such a representative. We conclude that J is the union of subblocks of I. It is left to show that if a subblock Ia,b is contained
in J, then Ia,b is a p-repair of Ia. Let Ia,b be a subblock contained in J and assume, by way of contradiction, that K is a
Pareto-improvement of Ia,b in Ia. Let J(cid:48) be the instance that is obtained from J by replacing Ia,b with K. Observe that J(cid:48) is
consistent, since no facts in J other than those in Ia,b conﬂict with facts from K. Then clearly, J(cid:48) is a Pareto improvement of
J, which contradicts the fact that J is a p-repair.

The “only if” direction. Let J be a union of p-repairs over all the blocks Ia of I. We need to show that J is a p-repair. By
the second part of the lemma, J is a union of subblocks. Since each subblock is consistent and facts from different blocks
are consistent, we get that J is consistent. It is left to show that J does not have a Pareto improvement. Assume, by way of
contradiction, that J has a Pareto improvement K. By the deﬁnition of a Pareto improvement, K contains a fact f such that
f (cid:31) g for all g ∈ J \ K. Let f be such a fact. Let Ia be the subblock of f. Then, by our assumption the subinstance J contains
a p-repair of Ia, and from the second part of the lemma this p-repair is a subblock of Ia, say Ia,b. But then, f is not in Ia,b
(since f /∈ J), and therefore, K does not contain any fact from Ia,b (since K is consistent). We conclude that f (cid:31) g for all
g ∈ Ia,b, and hence, Ia,b has a Pareto improvement (namely {f}), in contradiction to the fact that Ia,b is a p-repair of Ia.
A.2 Proof of Theorem 5.7

We now prove Theorem 5.7
THEOREM 5.7. The problems p-categoricity(cid:104)S0(cid:105) and p-categoricity(cid:104)S6(cid:105) are both coNP-hard.

We give a separate proof for each of the two schemas.
A.2.1 Hardness of p-categoricity(cid:104)S0(cid:105)
We construct a reduction from the Exact-Cover problem (XC) to the complement of p-categoricity(cid:104)S0(cid:105). The input to XC is
a set U of elements and a collection X of subsets of U, such that their union is U. The goal is to identify whether there is an
exact cover of U by X . An exact cover of U by X is a collection of pairwise disjoint sets from X whose union is U.
Construction. Given an input (X ,U) to XC, we construct input (I,(cid:31)) for p-categoricity(cid:104)S0(cid:105). For each u ∈ U, X ∈ X and
x ∈ X, the instance I consists of the following facts:
(i) R0(u, u)
(ii) R0(u, fu)
(iii) R0(Xx, fu)
(iv) R0(Xx, Xx)
(v) R0(Xx, x)
(vi) R0(Xxi+1, xi) for each i = 0, . . . , n−1, where X = {x0, . . . , xn−1} and plus is interpreted modulo n (e.g., (n−1)+1 =

0)

In the sequel, we relate to these facts by types according to their roman number. For example, facts of the form R0(Xx, fu),
where X ∈ X , x ∈ X and u ∈ U, will be referred to as facts of type (iii).

For all u ∈ U, X ∈ X and x ∈ X, the priority relation (cid:31) is deﬁned as follows:

15

Type (iii)

Type (iv)

A2, f4

A2, f3

A2, f2

A2, f1

A1, f4

A1, f3

A1, f2

A1, f1

A2, 1

A1, 2

B4, 3

B3, 4

C3, 2

C2, 3

A1, 1

A2, 2

B3, 3

B4, 4

C2, 2

C3, 3

Type (v)

Type (vi)

A2, A2

A1, A1

B4, B4

B3, B3

C3, C3

C2, C2

1, 1

2, 2

3, 3

4, 4

1, f1

2, f2

3, f3

4, f4

Figure 8: Illustration of the reduction from XC to p-categoricity(cid:104)S0(cid:105)

Type (i)

Type (ii)

• R0(u, u) (cid:31) R0(u, fu),
• R0(Xx, Xx) (cid:31) R0(Xx, fu),
• R0(u, u) (cid:31) R0(Xx, u),
• R0(Xx, fu) (cid:31) R0(Xx, x), and
• R0(Xxi+1, xi) (cid:31) R0(Xxi, xi), for i = 0, . . . , n − 1 where X = {x0, . . . , xn−1} and plus is interpreted modulo n. Note
Our construction is partly illustrated in Figure 8 for the following input to the XC problem: U = {1, 2, 3, 4}, X = {A, B, C}
where A = {1, 2}, B = {3, 4} and C = {2, 3}. Note that we denote the fact R0(a, b) by (a, b). In this case, there is an exact
cover of U by X that consists of the sets A and B. The gray facts represent a p-repair.
Proof of Hardness. We start by ﬁnding a c-repair.

that each X ∈ X has a corresponding n.

LEMMA A.1. There is a c-repair that consists of the following facts for all u ∈ U, X ∈ X and x ∈ X.
• R0(u, u)
• R0(Xx, Xx)
PROOF. It is straightforward to show that there is a run of the algorithm FindCRep(I,H,(cid:31)) that returns exactly this c-

repair.
In the the remainder of the proof, we relate to the the c-repair from Lemma A.1 by J0. Note that every c-repair is also a p-repair
and therefore J0 is a p-repair of I. To complete the proof we show that there is a solution to XC if and only if I has a p-repair
different from J0.

16

Lemma A.6

Lemma A.5

Lemma A.12

Lemma A.8

Lemma A.7

Lemma A.14

Lemma A.10

Lemma A.9

Lemma A.11

Lemma A.13

Lemma A.15

Figure 9: Dependencies between the lemmas in the proof of the “only if” direction of p-categoricity(cid:104)S0(cid:105)

The “if” direction. We show that if there is a solution to XC then I has a p-repair different from J0.
We construct a p-repair of I, namely K, different from J0 based on a solution to XC. Let the collection of sets X 1, . . . X l ∈ X
be a solution to XC. Let K consist of the following facts for all X ∈ X , x ∈ X and u ∈ U.
(1) R0(Xx, x) if X ∈ {X 1, . . . , X l}
(2) R0(Xx, Xx) if X (cid:54)∈ {X 1, . . . , X l}
(3) R0(u, fu)
Note that since K is different from J0 (see Lemma A.1), it is left to show that K is a p-repair of I. To do so, we show that K
is consistent and that it does not have a Pareto improvement.

LEMMA A.2. K is a consistent subinstance of I.

The proof of this lemma is straightforward based on the above construction.

LEMMA A.3. K does not have a Pareto improvement.
PROOF. It sufﬁces to show that for all f in I \ K, there exists f(cid:48) in K such that {f, f(cid:48)} is inconsistent (w.r.t. ∆0) and
f (cid:54)(cid:31) f(cid:48). For each f ∈ I \ K we choose f(cid:48) ∈ K such that the conditions hold. We divide to different cases according to the
type of f.

• f is of type (i): That is, there exists an element u in U such that f = R0(u, u). Since the collection {X 1, . . . , X l} is a
cover of U, there exists X in {X 1, . . . , X l} such that u ∈ X. Hence, R0(Xu, u) ∈ K and we choose f(cid:48) = R0(Xu, u).

• f is of type (ii): This is impossible, since K contains all the facts of this type.
• f is of type (iii): That is, there exists X ∈ X , x ∈ X and u ∈ U such that f = R0(Xx, fu). We choose f(cid:48) = R0(u, fu).
• f is of type (iv): That is, there exists a set X ∈ X and x ∈ X such that f = R0(Xx, Xx). Since f (cid:54)∈ K, it holds that

X ∈ {X 1, . . . , X l}. Hence R0(Xx, x) ∈ K and we choose f(cid:48) = R0(Xx, x).

• f is of type (v): That is, there exists a set X ∈ X and x ∈ X such that f = R0(Xx, x). Since f (cid:54)∈ K, it holds that

X (cid:54)∈ {X 1, . . . , X l}. Hence R0(Xx, Xx) ∈ K and we choose f(cid:48) = R0(Xx, Xx).

• f is of type (vi): That is, there exists a set X ∈ X where X = {x0, . . . , xn−1} and 0 ≤ i ≤ n − 1 such that
f = R0(Xxi+1, xi). Since the collection {X 1, . . . , X l} is a cover of U, there exists some Y in {X 1, . . . , X l} such that
xi ∈ Y . Hence, we get that R0(Yxi, xi) ∈ K and we choose f(cid:48) = R0(Yxi, xi).

It holds that in all of the above cases {f, f(cid:48)} is inconsistent and f (cid:54)(cid:31) f(cid:48).

Lemmas A.2 and A.3 imply the following.

LEMMA A.4. K is a p-repair of I.

17

Given a solution to XC, we constructed a p-repair K different from the above c-repair. This completes the “if” direction.

The “only if” direction. We show that if I has a p-repair different from J0 (from Lemma A.1) then there is a solution to
XC. The proof of this direction consists of several lemmas, and the dependencies between them are described in Figure 9. For
example, the proof of Lemma A.10 is based on Lemmas A.5, A.7 and A.8.

Let K be a p-repair different from J0. In the next two lemmas we show that facts of types (iii) and (vi) are not in K.
LEMMA A.5. For all X ∈ X , x ∈ X and u ∈ U, it holds that R0(Xx, fu) (cid:54)∈ K.
PROOF. Let X ∈ X , x ∈ X and u ∈ U. Assume, by way of contradiction, that R0(Xx, fu) ∈ K. Since K is consistent and
R0(Xx, Xx) is inconsistent with R0(Xx, fu), we obtain that R0(Xx, Xx) (cid:54)∈ K. Since R0(Xx, Xx) (cid:31) R0(Xx, fu), it holds
that K must contain a fact f that is inconsistent with R0(Xx, Xx) (but is consistent with R0(Xx, fu)). Therefore, f must agree
with R0(Xx, Xx) on B. That leads to a contradiction since there is no such fact.

LEMMA A.6. For all X ∈ X , x ∈ X and u ∈ U where u (cid:54)= x, it holds that R0(Xx, u) (cid:54)∈ K.
PROOF. Let X ∈ X , x ∈ X and u ∈ U where u (cid:54)= x. Assume that R0(Xx, u) ∈ K. Since for all X ∈ X , x ∈ X and u ∈ U,
we have that R0(u, u) (cid:31) R0(Xx, u), the p-repair K must contain a fact f that is inconsistent with R0(u, u) (but is consistent
with R0(Xx, u)). Since K is consistent, f must agree with R0(u, u) on A. Thus, f must be the fact R0(u, fu). Replacing both
facts R0(Xx, u) and R0(u, fu) with R0(u, u) results in a Pareto improvement of K which leads to a contradiction since K is
a p-repair.

We establish a connection between facts of type (i) and (ii).
LEMMA A.7. Let u ∈ U. If the fact R0(u, u) (cid:54)∈ K then R0(u, fu) ∈ K.
PROOF. Assume R0(u, u) (cid:54)∈ K. Assume, by way of contradiction, that R0(u, fu) (cid:54)∈ K. Since K is maximal, it must
contain a fact f that is inconsistent with R0(u, fu). If f agrees with R0(u, fu) on A then it can only be of type (i). That is, the
only possibility is that f = R0(u, u) which leads to a contradiction. If f agrees with R0(u, fu) on B, it can only be of type
(iii) which leads to a contradiction since by Lemma A.5, such a fact cannot be in a p-repair.

Moreover, we establish a connection between facts of type (ii) and (v).

LEMMA A.8. Let u ∈ U. If R0(u, fu) ∈ K then there exists X ∈ X such that u ∈ X and R0(Xu, u) ∈ K.
PROOF. Assume R0(u, fu) ∈ K. Since K is consistent, R0(u, u) (cid:54)∈ K. It follows from R0(u, u) (cid:31) R0(u, fu) that K must
contain a fact f that is inconsistent with R0(u, u). Since K is consistent, f is consistent with R0(u, fu). Therefore, f must
agree with R0(u, u) on B. The possible types for f are (vi) and (v). By Lemme A.6, f is not of type (vi). Thus, f must be of
type (v). Therefore, R0(Xu, u) ∈ K for X ∈ X such that u ∈ X (there exists such X since the union of sets of X is U).
We conclude the following connection between facts of types (i) and (v).

LEMMA A.9. Let u ∈ U. If R0(Xu, u) (cid:54)∈ K for all X ∈ X such that u ∈ X, then R0(u, u) ∈ K.
PROOF. Assume R0(Xu, u) (cid:54)∈ K for all X ∈ X . Assume, by way of contradiction, that R0(u, u) (cid:54)∈ K. By Lemma A.7,

R0(u, fu) ∈ K. By Lemma A.8, there exists X ∈ X such that u ∈ X and R0(Xu, u) ∈ K. This is a contradiction.
We state that either R0(u, u) ∈ K for all u ∈ U or none of the facts R0(u, u), where u ∈ U, is in K.

LEMMA A.10. Let u0 ∈ U. If R0(u0, u0) ∈ K then R0(u, u) ∈ K for all u ∈ U.
PROOF. Let u0 ∈ U and assume R0(u0, u0) ∈ K. Assume, by way of contradiction, there exists u ∈ U such that u (cid:54)= u0
and R0(u, u) (cid:54)∈ K. By Lemma A.7, R0(u, fu) ∈ K. Thus, by Lemma A.8 we have that R0(Uu, u) ∈ K for some U ∈ X
such that u ∈ U. Note that since R0(Uu, fu0) (cid:31) R0(Uu, u), there must be a fact in K that is inconsistent with R0(Uu, fu0)
and is consistent with R0(Uu, u). The only such a fact is R0(u0, fu0 ) (i.e, R0(u0, fu0 ) ∈ K). This is a contradiction since
R0(u0, u0) ∈ K and K is consistent.
We prove that all facts of type (i) are not in K.
LEMMA A.11. For all u ∈ U, R0(u, u) (cid:54)∈ K.
PROOF. Let u ∈ U and assume, by way of contradiction, that R0(u, u) ∈ K. By Lemma A.10, for all u ∈ U R0(u, u) ∈ K.
Since K is consistent, it does not contain facts of the form R0(u, fu) for all u ∈ U (since the fact R0(u, fu) is inconsistent
with R0(u, u)). Moreover, K does not contain facts of the form R0(Xu, u) where X ∈ X and u ∈ X (for a similar reason).
By Lemma A.5 (respectively, A.6), K does not contain facts of the form R0(Xx, fu) (respectively, R0(Xx, u)) where X ∈ X
and u ∈ X. It holds that K is maximal and thus it contains all of the facts of type (iv). Thus, we conclude that K is exactly J0
which leads to a contradiction.

18

We show that if a fact of type (iv) is in K, then all of the facts of type (iv) are in K.
LEMMA A.12. Let X ∈ X . If R0(Xx(cid:48), x(cid:48)) ∈ K for some x(cid:48) ∈ X then for all x ∈ X we have R0(Xx, x) ∈ K.
PROOF. Let us denote X = {x0, . . . , xn−1} and assume without loss of generality that x0 = x(cid:48). We prove by induction on

i that R0(Xxi , xi) ∈ K for all i = 0, . . . , n − 1.
Basis. Trivial.
Induction Step. Assume R0(Xxi , xi) ∈ K. Since R0(Xxi+1, xi) (cid:31) R0(Xxi, xi), there must be a fact f ∈ K that is
inconsistent with R0(Xxi+1 , xi). Since K is consistent, f must agree with R0(Xxi+1, xi) on A. By Lemma A.5, f is not of
the form R0(Xxi+1, fu) for u ∈ U and by Lemma A.6 f is also not of the form R0(Xxi+1, u) for u ∈ U. Therefore, f must be
R0(Xxi+1, xi+1).

Next, we show that K encodes a solution for XC. Speciﬁcally, we contend that there is an exact cover of U by X , namely C,
that is deﬁned as follows: C ∈ C if and only if R0(Cc, c) ∈ K for some c ∈ C.

LEMMA A.13. For all u ∈ U there exists C ∈ C such that u ∈ C.
PROOF. Let u ∈ U and assume, by way of contradiction, that for all C ∈ C, it holds that u (cid:54)∈ C. By our assumption, X (cid:54)∈ C
for all X ∈ X such that u ∈ X. Note that since the union of the sets in X is U, there exists a set X ∈ X such that u ∈ X.
Thus, the deﬁnition of the set C implies that for all X ∈ X such that u ∈ X, we have that R0(Xu, u) (cid:54)∈ K. By Lemma A.9,
R0(u, u) ∈ K. By Lemma A.11, this is a contradiction.

LEMMA A.14. For all C, C(cid:48) ∈ C where C (cid:54)= C(cid:48), it holds that C ∩ C(cid:48) = ∅.
PROOF. Let C, C(cid:48) ∈ C where C (cid:54)= C(cid:48). Assume, by way of contradiction, that there exists u ∈ C ∩ C(cid:48). By C’s deﬁnition,
R0(Cc, c) ∈ K for some c ∈ C. Lemma A.12 implies that for all c ∈ C, it holds that R0(Cc, c) ∈ K. Similarly, for all c(cid:48) ∈ C(cid:48),
we have that R0(C(cid:48)
u, u) are in K. This is a contradiction to
K’s consistency.

c(cid:48), c(cid:48)) ∈ K. Since u ∈ C ∩ C(cid:48), both facts R0(Cu, u) and R0(C(cid:48)

Finally, we conclude the following.

LEMMA A.15. C is an exact cover of U
PROOF. Follows from Lemmas A.13 and A.14.
Given K, a p-repair different from J0, we showed that there exists a solution to XC, (i.e., an exact cover of U). This completes
the “only if” direction.
A.2.2 Hardness of p-categoricity(cid:104)S6(cid:105)
We construct a reduction from CNF satisﬁability to p-categoricity(cid:104)S6(cid:105). The input to CNF is a formula ψ with the free
variables x1, . . . , xn, such that ψ has the form c0 ∧···∧ cm where each cj is a clause. Each clause is a conjunction of variables
from the set {xi,¬xi : i = 1, . . . , n}. The goal is to determine whether there is a true assignment τ : {x1, . . . , xn} → {0, 1}
that satisﬁes ψ. Given such an input, we will construct the input (I,(cid:31)) for p-categoricity(cid:104)S6(cid:105). For each i = 1, . . . , n and
j = 0, . . . , m, I contains the following facts:

• R6((cid:12), xi, 0)
• R6((cid:12), xi, 1)
• R6(⊗, cj, cj)

The priority relation (cid:31) is deﬁned as follows:

• R6(⊗, cj, cj) (cid:31) R6((cid:12), xi, 0) if xi appears in clause cj,
• R6(⊗, cj, cj) (cid:31) R6((cid:12), xi, 1) if ¬xi appears in clause cj, and
• R6(⊗, cj, cj) (cid:31) R6((cid:12), xi, b), where b ∈ {0, 1}, if neither xi nor ¬xi appear in clause cj.

Our construction is illustrated in Figure 10 for the CN F formula: ψ = (x1∨ x2∨¬x4)∧ (¬x2∨ x3∨¬x4)∧ (¬x1∨¬x3∨ x4).
Observe that the subinstance J that consists of the facts R6(⊗, cj, cj) for all j, is the only c-repair. To complete the proof, we
will show that ψ is satisﬁable if and only if I has a p-repair different from J.
The “if” direction. Assume ψ is satisﬁable. That is, there exists an assignment τ : {x1, . . . , xn} → {0, 1} that satisﬁes ψ.
We claim that the subinstance K that consists of the facts R6((cid:12), xi, τ (xi)) for all i is a p-repair (that is different from J). K
is consistent since τ is an assignment (i.e., each xi has exactly one value and the constraint B → C ∈ ∆6 is satisﬁed). For

19

(cid:12), x1, 0
(cid:12), x1, 1

(cid:12), x2, 0
(cid:12), x2, 1

(cid:12), x3, 0
(cid:12), x3, 1

(cid:12), x4, 0
(cid:12), x4, 1

⊗, c1, c1

⊗, c2, c2

⊗, c3, c3

Figure 10: Illustration of the reduction from CN F to p-categoricity(cid:104)S6(cid:105)

the same reason, K is maximal (facts of the form R6(⊗, cj, cj) cannot be added to K because of the constraint ∅ → A). It is
left to show that K does not have a Pareto improvement. Assume, by way of contradiction, that it does. That is, there exists a
fact f ∈ I \ K such that f (cid:31) g for every g ∈ K. Note that follows from (cid:31)’s deﬁnition, f must be of the form R6(⊗, cj, cj).
Nevertheless, this implies the clause cj is not satisﬁed by τ which leads us to the conclusion that ψ is not satisﬁed by τ.

The “only if” direction. Assume there is a p-repair K different from J. Since K is different from J, it must contain a fact
R6((cid:12), xi, bi) for some i. Since K is consistent and the FD ∅ → A is in ∆6, it holds that for all facts f in K, we have that
f [A] = (cid:12). K is maximal and consistent and thus induces a true assignment τ, deﬁned by τ (xi) def= bi. Assume, by way of
contradiction, that τ does not satisfy ψ. That is, there exists a clause cj that is not satisﬁed. By (cid:31)’s deﬁnition, R6(⊗, cj, cj) (cid:31)
R6((cid:12), xi, bi) for each xi that appears in cj (with or without negation). Moreover, R6(⊗, cj, cj) (cid:31) R6((cid:12), xl, bl) for each xl
that does not appear in cj (with or without negation). Therefore R6(⊗, cj, cj) (cid:31) f for every f ∈ K, which implies that K has
a Pareto improvement that contains the fact R6(⊗, cj, cj). Hence, we get a contradiction.
A.3 Proof of Lemma 5.9

LEMMA 5.9. Let S = (R, ∆) be a schema such that R consists of a single relation symbol. Suppose that ∆ is equivalent to

a pair of keys, and ∆ is not equivalent to any single FD. Then there is a fact-wise reduction from S0 to S.

PROOF. Denote the single relation symbol in R by R. It holds that ∆ is equivalent to a pair of keys and therefore we can

denote it by {X → (cid:74)R(cid:75), Y → (cid:74)R(cid:75)} where X, Y are subsets of(cid:74)R(cid:75). Let f = R0(a, b). We deﬁne a fact-wise reduction

,Π : R0 → R, using the constant (cid:12) ∈ Const. That is, denote Π(f ) = (d1, . . . , dn) where for all i = 1, . . . , n

a

di

def=

i ∈ X \ Y
i ∈ Y \ X
b
(cid:12) otherwise.

In order to prove that Π is indeed a fact-wise reduction, we should show it is well-deﬁned, preserves consistency and inconsis-
tency and is injective.
It is straightforward to see that Π is injective. Note that since ∆ is not equivalent to a single FD, it holds that X \ Y (cid:54)= ∅ and
Y \ X (cid:54)= ∅. Therefore, there exist i and j such that di = a and dj = b. To show that it preserves consistency, we should show
that for every two facts f and f(cid:48), the set {f, f(cid:48)} is consistent w.r.t ∆0 if and only if {Π(f ), Π(f(cid:48))} is consistent w.r.t ∆.
The “if” direction. Assume that {f, f(cid:48)} is consistent w.r.t ∆0, we contend that {Π(f ), Π(f(cid:48))} is consistent w.r.t ∆. Since
{f, f(cid:48)} is consistent w.r.t ∆0, if f and f(cid:48) agree on A then they must also agree on B and if they do not agree on A then they
also do not agree on B. Thus, either a = a(cid:48), b = b(cid:48) or a (cid:54)= a(cid:48), b (cid:54)= b(cid:48).
If a = a(cid:48) and b = b(cid:48) then by Π’s deﬁnition, it holds that Π(f ) = Π(f(cid:48)) and thus {Π(f ), Π(f(cid:48))} = {Π(f )} is consistent w.r.t
∆.
n). If a (cid:54)= a(cid:48) and b (cid:54)= b(cid:48) then by Π’s deﬁnition and since X \ Y and
Let Π(f ) = (d1, . . . , dn) and let Π(f(cid:48)) = (d(cid:48)
Y \ X are not empty it holds that there exists i ∈ X \ Y such that di (cid:54)= d(cid:48)
j. Thus Π(f ) and
Π(f(cid:48)) do not agree on X nor on Y . That is, {Π(f ), Π(f(cid:48))} is consistent with respect to ∆.

i and j ∈ Y \ X such that dj (cid:54)= d(cid:48)

1, . . . , d(cid:48)

20

The “only if” direction. Assume {f, f(cid:48)} is inconsistent w.r.t ∆0, we contend that {Π(f ), Π(f(cid:48))} is inconsistent w.r.t ∆.
Since {f, f(cid:48)} is inconsistent w.r.t ∆0, if f and f(cid:48) agree on A then they must disagree on B and if they disagree on A then they
must agree on B. Thus, either a = a(cid:48), b (cid:54)= b(cid:48) or a (cid:54)= a(cid:48), b = b(cid:48). Both cases are symmetric and thus we will prove the claim
only for the case where a = a(cid:48) and b (cid:54)= b(cid:48). Let Π(f ) = (d1, . . . , dn) and Π(f(cid:48)) = (d(cid:48)
1, . . . , d(cid:48)
i for
k = (cid:12). That is, the facts Π(f ) and Π(f(cid:48))
i ∈ X \ Y and dj (cid:54)= d(cid:48)
j for j ∈ Y \ X. Moreover, for all other k, it holds that dk = d(cid:48)
agree on X and disagree on Y . Hence, {Π(f ), Π(f(cid:48))} is inconsistent w.r.t ∆
A.4 Proof of Lemma 5.10

n). By Π’s deﬁnition, di = d(cid:48)

LEMMA 5.10. For all i = 1, . . . , 5 there is a fact-wise reduction from S0 to Si.
PROOF. Recall our schemas Si, for i = 1, . . . , 5, where each Si is the schema (Ri, ∆i), and Ri is the singleton {Ri}. The

speciﬁcation of the Si is as follows.
0. R0/2 and ∆0 = {A → B, B → A}
1. R1/3 and ∆1 = {AB → C, BC → A, AC → B}
2. R2/3 and ∆2 = {A → B, B → A}
3. R3/3 and ∆3 = {AB → C, C → B}
4. R4/3 and ∆4 = {A → B, B → C}
5. R5/3 and ∆5 = {A → C, B → C}
Let f = R0(a, b) be a fact over R0/2. For all i = 1, . . . , 5 we deﬁne the fact-wise reduction Πi : R0 → Ri, using

⊗ ∈ Const, by:
1. Π1(f ) def= R1(a, b,⊗),
2. Π2(f ) def= R2(a, b,⊗),
3. Π3(f ) def= R3(⊗, a, b),
4. Π4(f ) def= R4(a, b, a),
5. Π5(f ) def= R5(a, b,(cid:104)a, b(cid:105)).
Regarding the fact-wise reduction Π5, note that (cid:104)a, b(cid:105) = (cid:104)a(cid:48), b(cid:48)(cid:105) if and only if a = a(cid:48) and b = b(cid:48). Note that for each i = 1, . . . , 5,
we have that Πi is computable in polynomial time. Moreover, it is straightforward to see that for each i = 1, . . . , 5, it holds
that Πi is injective. Thus, it is left to show that for each i = 1, . . . , 5, the fact-wise reduction Πi preserves consistency and
inconsistency. That is, given two facts f = R0(a, b) and f(cid:48) = R0(a(cid:48), b(cid:48)), we show that for each i = 1, . . . , 5, it holds that
{Πi(f ), Πi(f(cid:48))} is consistent w.r.t ∆i, if and only if {f, f(cid:48)} is consistent w.r.t ∆0.

We prove the above for i = 5.

The “if” direction. Let f = R0(a, b) and f(cid:48) = R0(a(cid:48), b(cid:48)). Assume that {f, f(cid:48)} is inconsistent with respect to ∆0. We
contend that {Π5(f ), Π5(f(cid:48))} is inconsistent w.r.t ∆1. Note that since {f, f(cid:48)} is inconsistent with respect to ∆0, f and f(cid:48) must
agree on one attribute and disagree on the second. Both cases are symmetric and thus it sufﬁces to show that if f = R0(a, b)
and f(cid:48) = R0(a(cid:48), b(cid:48)) agree on A and disagree on B then {Π5(f ), Π5(f(cid:48))} is inconsistent w.r.t ∆1. Indeed, f = R0(a, b) and
f(cid:48) = R0(a(cid:48), b(cid:48)) agree on A which implies a = a(cid:48), and disagree on B which implies b (cid:54)= b(cid:48). Thus, Π5(f ) = R1(a, b,(cid:104)a, b(cid:105))
and Π5(f(cid:48)) = R1(a(cid:48), b(cid:48),(cid:104)a(cid:48), b(cid:48)(cid:105)) agree on A but do not agree on C. That is, {Π5(f ), Π5(f(cid:48))} is inconsistent w.r.t ∆1.
The “only if” direction. Let f = R0(a, b) and f(cid:48) = R0(a(cid:48), b(cid:48)) and assume that {f, f(cid:48)} is consistent with respect to ∆0. We
contend that {Π5(f ), Π5(f(cid:48))} is consistent w.r.t ∆1. If f and f(cid:48) agree on A (i.e., a = a(cid:48)), since they are consistent w.r.t ∆0
they must agree also on B (i.e., b = b(cid:48)). Hence f = f(cid:48) and therefore Π5(f ) = Π5(f(cid:48)). We conclude that {Π5(f ), Π5(f(cid:48))} is
consistent w.r.t ∆1. If f and f(cid:48) do not agree on A (i.e., a (cid:54)= a(cid:48)), since they are consistent w.r.t ∆0 they must also disagree on B
(i.e., b (cid:54)= b(cid:48)). Thus, Π5(f ) and Π5(f(cid:48)) do not agree on A nor on B. That is, ∆1 holds and thus {Π5(f ), Π5(f(cid:48))} is consistent
w.r.t ∆1.

Similarly, this can be shown for each i = 1, . . . , 4 (which are simpler cases than i = 5).

B. PROOFS FOR SECTION 6

In the current section we prove the correctness of the CCategoricity algorithm, introduced in Section 6. In particular, we

prove Theorem 6.5. For convenience, we repeat the theorem here.

THEOREM 6.5. Let (I,H,(cid:31)) be an inconsistent prioritizing instance, and let J be the subinstance of I constructed in the

execution of CCategoricity(I,H,(cid:31)). Then the following are equivalent.

21

1. J is consistent.
2. There is a single c-repair.

Moreover, if J is consistent then J is the single c-repair.

We will divide our proof into two parts. First we will prove that the algorithm is sound (i.e., if J is consistent, then I has
precisely one c-repair). Later, we will prove that the algorithm is complete (i.e., if I has precisely one c-repair, then J is
consistent). Before that, we need a basic lemma that will be used in both parts of the proof.
B.1 Basic Lemma

Let (I,H,(cid:31)) be an inconsistent prioritizing instance over a signature R. We start by proving the following lemma.
LEMMA B.1. Suppose that P1, . . . , Pt are the positive strata constructed by executing CCategoricity(I,H,(cid:31)). For every
k ∈ {1, . . . , t}, if Jk = P1 ∪ ··· ∪ Pk is consistent, then there exists an execution of the FindCRep algorithm on (I,H,(cid:31)),
such that at the beginning of some iteration of that execution the following hold:

• The set of facts included in J is P1 ∪ ··· ∪ Pk.
• Every fact f ∈ Pk+1 belongs to max(cid:31)(I).
PROOF. Let us start the execution of the FindCRep algorithm on (I,H,(cid:31)) as follows. First, we will select all of the facts
from P1 and add them to J (one by one), then we will select all of the facts from P2 and add them to J and so on. If we can
add all of the facts from P1 ∪ ··· ∪ Pk to J during this process, and at the end all of the facts in Pk+1 belong to max(cid:31)(I), then
there exists an execution of the FindCRep algorithm that satisﬁes all the conditions and that will conclude our proof.

max(cid:31)(I).

Otherwise, one of the following holds.
• One of the facts in P1 ∪ ··· ∪ Pk cannot be added to J.
• After adding all of the facts from P1 ∪ ··· ∪ Pk (and only these facts) to J, one of the facts in Pk+1 does not belong to
If the ﬁrst case holds, let Pi be the ﬁrst positive stratum such that a fact f ∈ Pi cannot be added to J after adding all of the facts
in P1∪···∪Pi−1 and maybe some of the facts in Pi to J. Note that P1∪···∪Pk does not contain a hyperedge, thus if f cannot
be added to J, it holds that f does not belong to max(cid:31)(I). That is, there exists at least one fact g, such that g (cid:31) f. Moreover,
there exists at least one ﬁnite sequence, h1 (cid:31) ··· (cid:31) hm (cid:31) f, of facts in I (with m ≥ 1), such that h1 ∈ max(cid:31)(I). Note that
for each such sequence of facts, it holds that h (cid:31)+ f for every fact h in the sequence. In this case, one of the following holds
for each fact h:

• h belongs to Pj or Nj for some j < i.
• h belongs to Pj or Nj for some j ≥ i.

We assumed that we were able to add all the facts from P1 ∪ ··· ∪ Pi−1 to J, thus h ∈ {h1, . . . , hm} cannot belong to Pj for
some j < i. Furthermore, by the deﬁnition of Pi, after removing all of the facts from P1 ∪ ··· ∪ Pi−1 and N1 ∪ ··· ∪ Ni−1,
every fact f ∈ Pi belongs to max+(cid:31)(I) (and consequently to max(cid:31)(I)). This cannot be the case if there exists a fact h (cid:31)+ f
that belongs to Pj or Nj for some j ≥ i. Thus, the only possibility left is that every fact h ∈ {h1, . . . , hm} belongs to Nj for
some j < i.
Since for every such sequence of facts, h1 belongs to max(cid:31)(I), it can be selected in line 3 of the algorithm at the next
iteration. By the deﬁnition of Nj, there exists a hyperedge that is contained in P1 ∪···∪ Pj ∪{h1}. We know that all the facts
in P1 ∪ ··· ∪ Pj were added to J, thus h1 will be excluded from J. After selecting fact h1 from each sequence and removing
it from I, the next fact, h2, in each sequence belongs to max(cid:31)(I). The previous arguments hold for h2 as well, thus h2 can
be selected in line 3 of the algorithm at the next iteration. Note that if a fact h belongs to more than one sequence, it will be
removed after all the previous facts in each one of these sequences are removed. We can continue with this process until it
holds that f ∈ max(cid:31)(I), and then add it to J, in contradiction to our assumption.
If the second case holds, at each of the next iterations of the algorithm (and before adding facts that do not belong to
P1 ∪ ··· ∪ Pk to J), there exists a fact f ∈ Pk+1 that does not belong to max(cid:31)(I). Similarly to the previous part, if f does
not belong to max(cid:31)(I), there exist at least one sequence h1 (cid:31) ··· (cid:31) hm (cid:31) f of facts, such that h (cid:31)+ f for every fact in
the sequence and each fact h belongs to Nj for some j < k + 1. We again can select all of the facts in each sequence as the
maximal elements in line 3 of the algorithm by topological order until f ∈ max(cid:31)(I). This is a contradiction to our assumption,
thus f does belong to max(cid:31)(I) after adding all of the facts in P1 ∪···∪ Pk to J and removing all of the corresponding facts in
N1 ∪···∪ Nk from I. Note that in this case, we will be able to select f in line 3 of the algorithm at the next iteration; however,
we may not be able to add f to J, since Jk+1 is not consistent.

EXAMPLE B.2. Consider the CCategoricity execution on the inconsistent prioritizing instance (I,H,(cid:31)) from our followers
running example, illustrated in Figure 6. In this example, P1 ∪ P2 is consistent. We can start building the repair J, using the

22

FindCRep algorithm as follows. (We recall that we denote inclusion in J by plus and exclusion from J by minus.)

+f11, +f34,−f12,−f21,−f31, +f22, +f35

As Lemma B.1 states, at the current iteration of the algorithm, all the facts in P1 ∪ P2 belong to J. Moreover, the facts in P3
(that is, f23 and f32) belong to max(cid:31)(I), as the second part of the lemma states.

Note that in our example, there exists a different execution of the FindCRep algorithm.

+f11,−f12,−f21,−f31, +f22,
+f23, +f32,−f24, +f34, +f35

In this case, there does not exist an iteration of the algorithm that satisﬁes the conditions from Lemma B.1. Thus, different
executions of the algorithm may be possible; however, there always exists an execution of the FindCRep algorithm that satisﬁes
the conditions from the lemma.
B.2 Soundness
Next, we prove that if J is consistent, then I has precisely one c-repair. Let us denote by t the number of iterations of the
CCategoricity algorithm on the input (I,H,(cid:31)). That is, it holds that J = P1 ∪ ··· ∪ Pt at the end of the algorithm. Since J is
consistent, Lemma B.1 and the fact that the FindCRep algorithm is sound (Theorem 4.1) imply that there exists a c-repair K
that includes all of the facts in P1 ∪ ··· ∪ Pt. The following lemma proves that a c-repair cannot include any fact that belongs
to Ni for some i ∈ {1, . . . t}.

LEMMA B.3. If J is consistent, then no c-repair contains any fact from N1 ∪ ··· ∪ Nt.
PROOF. Let us assume, by way of contradiction, that there exists a c-repair K(cid:48) that includes at least one fact from N1 ∪
··· ∪ Nt. By Theorem 4.1, FindCRep is complete, thus there exists an execution of the algorithm that produces K(cid:48). Consider
an execution of FindCRep that produces K(cid:48). In that execution, consider the ﬁrst time that a fact from a negative stratum is
added to K(cid:48); let g be that fact. That is, g ∈ Ni for some i ∈ {1, . . . , t}. By the deﬁnition of Ni, there exists a hyperedge
e = {f1, . . . , fm, g} that is contained in P1 ∪ ··· ∪ Pi ∪ {g}, such that for every other fact f ∈ e it holds that f (cid:31)+ g. If we
are able to choose fact g for the repair at some iteration of the algorithm, it necessarily belongs to max(cid:31)(I) at this iteration.
Therefore, all of the other facts in e are no longer included in I.
This may be the case if all of the other facts in the hyperedge were already added to K(cid:48). However, adding g to K(cid:48) will result
in a hyperedge, in contradiction to the fact the K(cid:48) is a repair. Therefore, at least one of the facts in the hyperedge was removed
from I without being added to K(cid:48); let f be such a fact. That is, there exists another hyperedge e(cid:48) that includes f, such that all
of the other facts in this hyperedge were added to K(cid:48) before f was removed from I. All of these facts, including f, belong
to P1 ∪ ··· ∪ Pt, since we assumed that g is the ﬁrst fact from some Ni that was chosen for the repair. Hence, we found a
hyperedge, e(cid:48), that is contained in P1 ∪···∪ Pt, in contradiction to the fact that P1 ∪···∪ Pt is consistent. Thus, a fact g ∈ Ni
cannot be added to any repair of I.

Lemma B.3 implies that every c-repair is contained in J. Moreover, as said above, there exists a c-repair that includes all of

the facts in J. Thus, J is the only c-repair of I and this concludes the proof of soundness of the CCategoricity algorithm.
B.3 Completeness
Finally, we prove that if I has precisely one c-repair, then J is consistent. Throughout this section we ﬁx (I,H,(cid:31)) and
assume that there is exactly one c-repair, which we denote by K. Let Ji denote the subinstance P1 ∪ ··· ∪ Pi. We prove
by induction on k that after the kth iteration of CCategoricity, the instance Jk = P1 ∪ ··· ∪ Pk is consistent. Then, we will
conclude that J is consistent when the algorithm reaches line 9, and consequently, the algorithm returns true as we expect.

The basis of the induction, k = 0, is proved by observing that J0 is an empty set, thus it does not include any hyperedge. For
the inductive step, we need to prove that if Jk is consistent then Jk+1 is also consistent. So, suppose that Jk is consistent. Let
us assume, by way of contradiction, that Jk+1 is inconsistent, that is, Jk+1 contains a hyperedge. We next prove the following
lemma.

LEMMA B.4. There exists a fact f ∈ Pk+1 and a hyperedge e such that the following hold:
• f ∈ e.
• (e \ {f}) ⊆ P1 ∪ ··· ∪ Pk.
PROOF. Let e be a hyperedge that is contained in P1∪···∪Pk+1 and has a minimal intersection with Pk+1. Let {f1, . . . , fm}
be the set e ∩ Pk+1. Then m > 0 since Jk does not contain a hyperedge. To prove the lemma, we need to show that m = 1.
Suppose, by way of contradiction, that m > 1. Since Jk is consistent, Lemma B.1 implies that we can start building a c-
repair using the FindCRep algorithm by ﬁrst choosing all of the facts in P1 ∪ ··· ∪ Pk. Moreover, after choosing all of these
facts, there exists an iteration i in which each fact in Pk+1 belongs to max(cid:31)(I). Since FindCRep always produces a c-repair

23

(Theorem 4.1), we can now choose the fact f1, which will result in a c-repair J1. This holds true due to our assumption that
m > 1 and m is minimal (hence, adding a signle fact to a set of facts that currently includes only facts from P1 ∪···∪ Pk does
not result in the containment of a hyperedge).
The c-repair J1 cannot contain all of the facts in {f1, . . . , fm}, since a repair cannot contain a hyperedge. Let us assume
that fj ∈ {f1, . . . , fm} is not in J1. If we choose fj instead of f1 at the ith iteration, the FindCRep algorithm will produce a
c-repair J2 that includes fj. Again, we can choose fj due to our assumption that m > 1 and m is minimal. That is, we have
two distinct c-repairs, J1 and J2, in contradiction to our assumption that I has precisely one c-repair.
Since we assumed that I has exactly one c-repair and P1 ∪ ··· ∪ Pk is consistent, Lemma B.4 implies that there exists a
hyperedge e = {f1, . . . , fm} such that precisely one of the fi belongs to Pk+1, while the other facts belong to P1 ∪ ··· ∪ Pk.
Without loss of generality, we can assume that f1 ∈ Pk+1. We next prove the existence of two distinct c-repairs:

• A c-repair that includes all of the facts in e \ {f1} and does not include f1.
• A c-repair that includes f1.
LEMMA B.5. There exists a c-repair that does not include f1.
PROOF. Lemma B.1 implies that it is possible to build a c-repair using FindCRep by ﬁrst choosing all of the facts in
P1 ∪ ··· ∪ Pk. As all of the facts in {f2, . . . , fm} belong to P1 ∪ ··· ∪ Pk, all of them will be chosen in this process as well.
Since the FindCRep algorithm is sound (Theorem 4.1), this speciﬁc execution of the algorithm will result in a c-repair J of I
that includes all of the facts f2, . . . , fm. The fact f1 cannot be included in J, since adding it to J will result in a repair that
contains a hyperedge, which is impossible by deﬁnition.

To complete the proof of completeness, we prove that there exists another c-repair of I that includes f1. In order to do so,

we again take advantage of the algorithm FindCRep, and prove the following lemma.

LEMMA B.6. There exists a c-repair that includes f1.
PROOF. In order to prove the lemma, we start building the corresponding c-repair, using the FindCRep algorithm, by ﬁrst
selecting in line 3 of the algorithm only facts from P1 ∪ ··· ∪ Pk that either cannot be added to J or satisfy at least one of the
following conditions:

• h belongs to Pj or Nj for some j < k + 1.
• h belongs to Pj or Nj for some j ≥ k + 1.

24

• g (cid:31)+ f1.
• f1 and g are not neighbors in H.

Note that not all of the facts in P1 ∪ ··· ∪ Pk that satisfy at least one of the conditions can be selected in this process. A fact
g ∈ P2, for example, may be left out of J if a fact f ∈ P1 is not selected because it does not satisfy any of the conditions
and it holds that f (cid:31) g. In this case, g will not belong to max(cid:31)(I) until f is selected by the algorithm. However, since Jk
is consistent, all of the facts from P1 ∪ ··· ∪ Pk that can be selected in line 3 of the algorithm during this process can also be
added to J.

We will now prove that after selecting all of these facts, the algorithm can add the fact f1 to J next (that is, before adding
any other fact to J). This will eventually result in a c-repair that includes f1 and will conclude our proof. Let us assume, by
way of contradiction, that we cannot add f1 to J next. That is, one of the following holds:
• There exists a hyperedge that contains f1 such that all of the other facts in the hyperedge have already been added to J.
• We must add another fact to J before it holds that f1 ∈ max(cid:31)(I).
If the ﬁrst case holds, then there exists a hyperedge e, such that f1 ∈ e and all of the other facts in the hyperedge were added
to J in the previous iterations of the algorithm. Note that all of the facts that have already been added to J, including e \ {f1},
belong to P1 ∪ ··· ∪ Pk. Moreover, it holds that h (cid:31)+ f1 for every fact h ∈ e \ {f1}, since a fact h ∈ e \ {f1} that does not
hold h (cid:31)+ f1, does not satisfy any of the conditions and could not have been added to J. Hence, we found a hyperedge e, such
that f1 ∈ e, and for every other fact h ∈ e it holds that h ∈ P1 ∪ ··· ∪ Pk and h (cid:31)+ f1. By the deﬁnition of negative stratum,
it should hold that f1 ∈ Ni for some i ∈ {1, . . . k + 1} (the exact value of i depends on the other facts in this hyperedge), in
contradiction to the fact that f1 ∈ Pk+1. Thus, the ﬁrst case is impossible.
If the second case holds, then at one of the next iterations, only facts that can be added to J belong to max(cid:31)(I), while f1
does not belong to max(cid:31)(I) yet. In this case, the FindCRep algorithm must add another fact to J before adding f1 to J. Since
f1 does not belong to max(cid:31)(I), there exists at least one fact g such that g (cid:31) f1. Moreover, there exists at least one ﬁnite
sequence, h1 (cid:31) ··· (cid:31) hm (cid:31) f, of facts in I (with m ≥ 1), such that h1 ∈ max(cid:31)(I). Note that for each such sequence of
facts, it holds that h (cid:31)+ f for every fact h in the sequence. In this case, one of the following holds for each fact h:

By the deﬁnition of Pk+1, after removing all of the facts from P1 ∪···∪ Pk and N1 ∪···∪ Nk, every fact f ∈ Pk+1 belongs to
max+(cid:31)(I). This cannot be the case if there exists a fact h (cid:31)+ f that belongs to Pj or Nj for some j ≥ k + 1. Thus, each fact h
either belongs to Pj or Nj for some j < k + 1. If h1 belongs to some Pj, then h1 was not added to J since it does not satisfy
any of the conditions. This holds true since h1 ∈ max(cid:31)(I), thus it can be selected in line 3 of the algorithm. That is, there
exists a hyperedge e ⊆ P1 ∪ ··· ∪ Pk+1, such that {f1, h1} ⊆ e and it does not hold that h1 (cid:31)+ f1. This is a contradiction to
the fact that h1 (cid:31)+ f, thus this cannot be the case.
The only possibility left is that h1 ∈ Nj for some j < k + 1. Since it also holds that h1 ∈ max(cid:31)(I), the fact h1 can
be selected in line 3 of the algorithm next. Note that by the deﬁnition of Nj, there exists a hyperedge that is contained in
P1 ∪ ··· ∪ Pj ∪ {h1}, such that for every other fact h(cid:48) in the hyperedge it holds that h(cid:48) (cid:31)+ h1. Since h1 ∈ max(cid:31)(I) none of
these facts still belongs to I, thus they have already been added to J, and h1 will not be added to J, but only removed from I.
We can continue with this process and choose all of the facts in each one of the corrsponding sequences by topological order,
until f1 ∈ max(cid:31)(I). (If a fact h belongs to more than one sequence, it will be removed after all the previous facts in each one
of these sequences are removed.)
Then, we can add f1 to J, since every hyperedge that contains f1 and is included in P1 ∪ ··· ∪ Pk ∪ {f1} also contains at
least one fact g that does not satisfy g (cid:31)+ f (otherwise, f1 would belong to some Nj). That is, each hyperedge that contains
f1 contains at least one fact that does not satisfy any of the conditions and was not added to J, and adding f1 to J will not
close any hyperedge. This is a contradiction to our assumption, thus f1 can be chosen for the repair next. As said above, this
concludes our proof.

From Lemma B.5 and Lemma B.6 we can conclude that there exist two distinct c-repairs of I. This is a contradiction
to our assumption that I has precisely one c-repair. Hence, Jk+1 is necessarily consistent, and this concludes our proof of
completeness.

C. PROOFS FOR SECTION 7

C.1 Proof of Theorem 7.2

THEOREM 7.2. g-categoricity(cid:104)S6(cid:105) is Πp
PROOF. To show Πp

2-complete.

2-hardness, we construct a reduction from QCNF2 to the problem of g-categoricity(cid:104)S6(cid:105). The input
to QCNF2 consists of a CNF formula ψ(x, y) where x and y are disjoint sequences of variables. The goal is to determine
whether for every assignment to x there exists an assignment to y such that the two satisfy ψ. We denote x by x1, . . . , xn, y
by y1, . . . , yk and ψ = c1 ∧ ··· ∧ cm. The input (I,(cid:31)) is constructed from ψ by adding to it the following facts:

• R6(0, xi, 0) and R6(0, xi, 1) for each variable xi,
• R6(1, xi, 0) and R6(1, xi, 1) for each variable xi,
• R6(1, yl, 0) and R6(1, yl, 1) for each variable yl,
• R6(0, cj, cj) for each clause cj
• R6(2, 0, 0) which we denote by f0.

The priority is deﬁned by:

• R6(1, xi, b) (cid:31) R6(0, xi, b) for all b = 0, 1 and for all variables xi,
• R6(1, xi, 1) (cid:31) R6(0, cj, cj) if xi appears in clause cj,
• R6(1, xi, 0) (cid:31) R6(0, cj, cj) if ¬xi appears in clause cj and
• f0 (cid:31) R6(1, w, b) for all variables w and b = 0, 1.
Our construction is illustrated in Figure 11 for the following input to QCNF2: x = x, w, y = y, z and ψ = (w ∨ y ∨ z) ∧
(x ∨ ¬w ∨ y) ∧ (¬x ∨ ¬w ∨ ¬z).
Observe that the subinstance {f0} is a c-repair and thus it is also a g-repair. To complete the proof we will show that {f0} is
the only g-repair if and only if ψ is a “yes” instance; that is, for every assignment to x there exists an assignment to y such that
the two satisfy ψ.
The “if” direction:. Assume that ψ is a “yes” instance and let J be a g-repair of I. We contend that J is exactly {f0}.
Assume, by way of contradiction that J (cid:54)= {f0}. Since J is consistent and since ∆6 contains the FD ∅ → A, it holds that all
of the facts in J agree on A. By our assumption that J (cid:54)= {f0}, there are two cases:
1. For each fact f ∈ J, it holds that f [A] = 1. By (cid:31)’s deﬁnition, we have that {f0} is a global improvement of J which is

in contradiction to J being a g-repair.

25

0, x, 0

0, x, 1

0, w, 0

0, w, 1

2, 0, 0

1, x, 0

1, x, 1

1, w, 0

1, w, 1

1, y, 0

1, y, 1

1, z, 0

1, z, 1

0, c1, c1

0, c2, c2

0, c3, c3

Figure 11: Illustration of the reduction from QCNF2 to g-categoricity(cid:104)S6(cid:105)

2. For each fact f ∈ J, it holds that f [A] = 0. We state that for all j, the fact R6(0, cj, cj) ∈ J. Assume, by way of
contradiction, there exists j for which R6(0, cj, cj) (cid:54)∈ J. Since J is maximal it contains a fact f that is inconsistent with
R6(0, cj, cj). Since for each fact f ∈ J, it holds that f [A] = 0, there is no such fact and as a consequence no such j.
Hence for all j, we have that R6(0, cj, cj) ∈ J. Moreover, since J is maximal, it must contain a fact R6(0, xi, b) for
each xi ∈ x. Note that ∆6 contains the FD B → C. This insures that J cannot contain both of the facts R6(0, xi, 0) and
R6(0, xi, 1). This implies that J encodes an assignment τx for the variables xi ∈ x. This assignment is given by

(cid:40)

τx(xi) def=

0 R6(0, xi, 0) ∈ J
1 R6(0, xi, 1) ∈ J

Since ψ is a “yes” instance, there exists an assignment τy for the variables yl ∈ y that together with τx satisﬁes ψ. Let
K be the subinstance of I that consists of the facts R6(1, xi, τx(xi)) for all i and R6(1, yl, τy(yl)) for all l. Note that K
is consistent. We contend that K is a global improvement of J. Since J and K are disjoint, it sufﬁces to show that for
every fact f ∈ J there is a fact f(cid:48) ∈ K such that f(cid:48) (cid:31) f. Let f ∈ J. If f is of the form R6(0, xi, b) then we choose
f(cid:48) = R6(1, xi, b). If f is of the form (0, cj, cj), then we choose f(cid:48) = R6(1, w, b) where w is the variable of a literal that
satisﬁes cj under the union of τx and τy. We conclude that K is a global improvement of J, That is, J is not a g-repair in
contradiction to our assumption.

The “only if” direction:. Assume that {f0} is the only g-repair of I. We contend that for every assignment to x there exists
an assignment to y such that the two satisfy ψ. Let τx be an assignment for x and let J be a consistent subinstance of I that
consists of the facts R6(0, cj, cj) for j = 1, . . . , k and R6(0, xi, τx(xi)) where xi ∈ x. Since {f0} is the only g-repair, it holds
that J has a global improvement. Let us denote such a global improvement by K. Assume, without loss of generality, that K
is maximal (if not, we can extend K with additional facts). By (cid:31)’s deﬁnition, K must consist of facts of the form R6(1, w, b).
Since the FD ∅ → A is in ∆6, for each fact f ∈ K, it holds that f [A] = 1. Since K is maximal and since B → C is in ∆6, we
have that K encodes an assignment τ for x and y. This assignment is given by
0 R6(1, w, 0) ∈ K
1 R6(1, w, 1) ∈ K

τ (w) def=

(cid:40)

Since K is a global improvement of J, it must contain the fact R6(1, xi, bi) whenever R6(0, xi, bi) is in J (this is true since
no other fact has a priority over R6(0, xi, bi)). Therefore τ extends τx. Finally we observe that every cj is satisﬁed by τ. A
satisfying literal is one that corresponds to a fact R6(1, w, b) that satisﬁes R6(1, w, b) (cid:31) cj. We conclude that ψ is a “yes”
instance as claimed.

C.2 Proof of Theorem 7.3

THEOREM 7.3. Let S = (R, ∆) be a schema such that R consists of a single relation symbol R and ∆ consists of two
nontrivial FDs X → Y and W → Z. Suppose that each of W and Z contains an attribute that is in none of the other three
sets. Then g-categoricity(cid:104)S(cid:105) is Πp

2-complete.

26

PROOF. Recall the schema S6 = (R, ∆) where R consists of a single ternary relation R6/3 and ∆6 = {∅ → A, B → C}.
We deﬁne a fact-wise reduction Π : R6 → R, using the constants (cid:12),⊕ ∈ Const. Let f = R6(a, b, c). We deﬁne Π by
Π(f ) = R6(d1, . . . , dn) where for all i = 1, . . . , n

(cid:12) i ∈ X
a
b
c
⊕ otherwise

i ∈ Y \ X
i ∈ W \ (X ∪ Y ∪ Z)
i ∈ Z \ (X ∪ Y ∪ W )



di

def=

It is left to show that Π is a fact-wise reduction. To do so, we prove that Π is well deﬁned, is injective and preserves consistency
and inconsistency.

Π is well deﬁned.
It sufﬁces to show that each di is well-deﬁned. We show that the sets in the deﬁnition of di are pairwise
disjoint. Indeed, X is disjoint from the sets Y \ X, W \ (X ∪ Y ∪ Z) and Z \ (X ∪ Y ∪ W ). Moreover, Y \ X is a subset of
Y and therefore it is disjoint from W \ (X ∪ Y ∪ Z) and Z \ (X ∪ Y ∪ W ). Clearly, W \ (X ∪ Y ∪ Z) and Z \ (X ∪ Y ∪ W )
are disjoint. Hence, each di is well-deﬁned.
Π is injective. Let f, f(cid:48) ∈ R6 where f = R6(a, b, c) and f(cid:48) = R6(a(cid:48), b(cid:48), c(cid:48)). Assume that Π(f ) = Π(f(cid:48)). Let us denote
n). Note that Y \ X is not empty since the FD X → Y is nontrivial. Moreover,
Π(f ) = (d1, . . . , dn) and Π(f(cid:48)) = (d(cid:48)
W \ (X ∪ Y ∪ Z) and Z \ (X ∪ Y ∪ W ) are not empty since each of W and Z contains an attribute that is in none of the other
three sets. Therefore, there are i, j and k such that di = a, dj = b and dk = c. Hence, Π(f ) = Π(f(cid:48)) implies that di = d(cid:48)
i,
dj = d(cid:48)
Π preserves consistency. Let f = R6(a, b, c) and f(cid:48) = R6(a(cid:48), b(cid:48), c(cid:48)). We contend that {f, f(cid:48)} is consistent w.r.t ∆6 if and
only if {Π(f ), Π(f(cid:48))} is consistent w.r.t ∆.

k. Therefore we obtain a = a(cid:48), b = b(cid:48) and c = c(cid:48) which implies f = f(cid:48).

j and dk = d(cid:48)

1, . . . , d(cid:48)

The “if” direction:.
Assume {f, f(cid:48)} is consistent w.r.t ∆6. We prove that {Π(f ), Π(f(cid:48))} is consistent w.r.t ∆. Note that Π(f ) and Π(f(cid:48)) agree
on X since for each i ∈ X we have that di = (cid:12), regardless of the input. Since {f, f(cid:48)} is consistent w.r.t ∆6, it holds that
a = a(cid:48). By the deﬁnition of Π and since a = a(cid:48), we have that Π(f ) and Π(f(cid:48)) agree on Y . Hence, {Π(f ), Π(f(cid:48))} satisﬁes the
constraint X → Y . Assume that Π(f ) and Π(f(cid:48)) agree on W . By the deﬁnition of Π , since W \ (X ∪ Y ∪ Z) is not empty,
it holds that b = b(cid:48). Since {f, f(cid:48)} is consistent w.r.t ∆6, the fact that b = b(cid:48) implies that also c = c(cid:48) (due to the constraint
B → C). Hence, Π(f ) = Π(f(cid:48)). This implies and that {Π(f ), Π(f(cid:48))} = {Π(f )} is consistent w.r.t ∆.

The “only if” direction:.

Assume {f, f(cid:48)} is inconsistent w.r.t ∆6. We prove that {Π(f ), Π(f(cid:48))} is inconsistent w.r.t ∆. There are two cases
• f and f(cid:48) do not agree on A. It holds, by Π’s deﬁnition, that Π(f ) and Π(f(cid:48)) agree on X. Nevertheless, since f and f(cid:48)
do not agree on A, we have that a (cid:54)= a(cid:48). Hence Π(f ) and Π(f(cid:48)) do agree on Y . That is, the constraint X → Y is not
satisﬁed, which leads us to the conclusion that {Π(f ), Π(f(cid:48))} is inconsistent w.r.t ∆.

• f and f(cid:48) agree on A. Since {f, f(cid:48)} is inconsistent w.r.t ∆6, we have that f and f(cid:48) agree on B (i.e., b = b(cid:48)) but disagree
on C (i.e., c = c(cid:48)). Note that Π(f ) and Π(f(cid:48)) agree on W since a = a(cid:48) and b = b(cid:48). Nevertheless, they do not agree on Z
since c (cid:54)= c(cid:48) and the set Z \ (X ∪ Y ∪ W ) is not empty. That is, the constraint W → Z is not satisﬁed which leads us to
the conclusion that {Π(f ), Π(f(cid:48))} is inconsistent w.r.t ∆.

27

