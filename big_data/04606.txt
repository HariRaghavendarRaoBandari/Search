6
1
0
2

 
r
a

 

M
5
1

 
 
]

C
C
.
s
c
[
 
 

1
v
6
0
6
4
0

.

3
0
6
1
:
v
i
X
r
a

Some Complete and Intermediate Polynomials in

Algebraic Complexity Theory

Meena Mahajan and Nitin Saurabh

The Institute of Mathematical Sciences, Chennai, India

meena@imsc.res.in, nitin@imsc.res.in

Abstract. We provide a list of new natural VNP-intermediate polynomial families, based on basic
(combinatorial) NP-complete problems that are complete under parsimonious reductions. Over ﬁnite
ﬁelds, these families are in VNP, and under the plausible hypothesis ModpP 6⊆ P/poly, are neither
VNP-hard (even under oracle-circuit reductions) nor in VP. Prior to this, only the Cut Enumerator
polynomial was known to be VNP-intermediate, as shown by B¨urgisser in 2000.
We next show that over rationals and reals, two of our intermediate polynomials, based on satisﬁability
and Hamiltonian cycle, are not monotone aﬃne polynomial-size projections of the permanent. This
augments recent results along this line due to Grochow.
Finally, we describe a (somewhat natural) polynomial deﬁned independent of a computation model, and
show that it is VP-complete under polynomial-size projections. This complements a recent result of Du-
rand et al. (2014) which established VP-completeness of a related polynomial but under constant-depth
oracle circuit reductions. Both polynomials are based on graph homomorphisms. A simple restriction
yields a family similarly complete for VBP.

1

Introduction

The algebraic analogue of the P versus NP problem, famously referred to as the VP ver-
sus VNP question, is one of the most signiﬁcant problem in algebraic complexity theory.
Valiant [28] showed that the Permanent polynomial is VNP-complete (over ﬁelds of char
6= 2). A striking aspect of this polynomial is that the underlying decision problem, in fact
even the search problem, is in P. Given a graph, we can decide in polynomial time whether
it has a perfect matching, and if so ﬁnd a maximum matching in polynomial time [12]. Since
the underlying problem is an easier problem, it helped in establishing VNP-completeness of
a host of other polynomials by a reduction from the Permanent polynomial (cf. [4]). In-
spired from classical results in structural complexity theory, in particular [20], B¨urgisser [5]
proved that if Valiant’s hypothesis (i.e. VP 6= VNP) is true, then, over any ﬁeld there is a p-
family in VNP which is neither in VP nor VNP-complete with respect to c-reductions. Let us
call such polynomial families VNP-intermediate (i.e. in VNP, not VNP-complete, not in VP).
Further, B¨urgisser [5] showed that over ﬁnite ﬁelds, a speciﬁc family of polynomials is VNP-
intermediate, provided the polynomial hierarchy PH does not collapse to the second level. On
an intuitive level these polynomials enumerate cuts in a graph. This is a remarkable result,
when compared with the classical P-NP setting or the BSS-model. Though the existence
of problems with intermediate complexity has been established in the latter settings, due
to the involved “diagonalization” arguments used to construct them, these problems seem
highly unnatural. That is, their deﬁnitions are not motivated by an underlying combinatorial
problem but guided by the needs of the proof and, hence, seem artiﬁcial. The question of

whether there are other naturally-deﬁned VNP-intermediate polynomials was left open by
B¨urgisser [4]. We remark that to date the cut enumerator polynomial from [5] is the only
known example of a natural polynomial family that is VNP-intermediate.

The question of whether the classes VP and VNP are distinct is often phrased as whether
Permn is not a quasi-polynomial-size projection of Detn. The importance of this reformula-
tion stems from the fact that it is a purely algebraic statement, devoid of any dependence
on circuits. While we have made very little progress on this question of determinantal com-
plexity of the permanent, the progress in restricted settings has been considerable. One
of the success stories in theoretical computer science is unconditional lower bound against
monotone computations [24, 25, 1]. In particular, Razborov [25] proved that computing the
permanent over the Boolean semiring requires monotone circuits of size at least nΩ(log n).
Jukna [18] observed that if the Hamilton cycle polynomial is a monotone p-projection of the
permanent, then, since the clique polynomial is a monotone projection of the Hamiltonian
cycle [28] and the clique requires monotone circuits of exponential size [1], one would get
a lower bound of 2nΩ(1) for monotone circuits computing the permanent, thus improving
on [25]. The importance of this observation is also highlighted by the fact that such a mono-
tone p-projection, over the reals, would give an alternate proof of the result of Jerrum and
Snir [17] that computing the permanent by monotone circuits over R requires size at least
2nΩ(1). (Jerrum and Snir [17] proved that the permanent requires monotone circuits of size
2Ω(n) over R and the tropical semiring.) The ﬁrst progress on this question raised in [18]
was made recently by Grochow [15]. He showed that the Hamiltonian cycle polynomial is
not a monotone sub-exponential-size projection of the permanent. This already answered
Jukna’s question in its entirety, but Grochow [15] used his techniques to further establish
that polynomials like the perfect matching polynomial, and even the VNP-intermediate cut
enumerator polynomial of B¨urgisser [5], are not monotone polynomial-size projections of the
permanent. This raises an intriguing question of whether there are other such non-negative
polynomials which share this property.

While the Perm vs Det problem has become synonymous with the VP vs VNP question,
there is a somewhat unsatisfactory feeling about it. This rises from two facts: one, that the
VP-hardness of the determinant is known only under the more powerful quasi-polynomial-
size projections, and, second, the lack of natural VP-complete polynomials (with respect
to polynomial-size projections) in the literature. (In fact, with respect to p-projections, the
determinant is complete for the possibly smaller class VBP of polynomial-sized algebraic
branching programs.) To remedy this situation, it seems crucial to understand the compu-
tation in VP. B¨urgisser [4] showed that a generic polynomial family constructed using a
topological sort of a generic VP circuit, while controlling the degree, is complete for VP.
Raz [23], using the depth reduction of [29], showed that a family of “universal circuits” is
VP-complete. Thus both families directly depend on the circuit deﬁnition or characterization
of VP. Last year, Durand et al. [11] made signiﬁcant progress and provided a natural, ﬁrst of
its kind, VP-complete polynomial. However, the natural polynomials studied by Durand et
al. lacked a bit of punch because their completeness was established under polynomial-size
constant depth c-reductions rather than projections.

2

In this paper, we make progress on all three fronts. First, we provide a list of new
natural polynomial families, based on basic (combinatorial) NP-complete problems [14] whose
completeness is via parsimonious reductions [27], that are VNP-intermediate over ﬁnite ﬁelds
(Theorem 1). Then, we show that over reals, some of our intermediate polynomials are not
monotone aﬃne polynomial-size projections of the permanent (Theorem 2). As in [15], the
lower bound results about monotone aﬃne projections are unconditional. Finally, we improve
upon [11] by characterizing VP and establishing a natural VP-complete polynomial under
polynomial-size projections (Theorem 6). A modiﬁcation yields a family similarly complete
for VBP (Theorems 7, 8).

Organization of the paper. We give basic deﬁnitions in Section 2. Section 3 contains our
discussion on intermediate polynomials. In Section 4 we establish lower bounds under mono-
tone aﬃne projections. The discussion on completeness results appears in Section 5. We end
in Section 6 with some interesting questions for further exploration.

2 Preliminaries

Algebraic complexity: We say that a polynomial f is a projection of g if f can be obtained
from g by setting the variables of g to either constants in the ﬁeld, or to the variables
of f . A sequence (fn) is a p-projection of (gm), if each fn is a projection of gt for some
t = t(n) polynomially bounded in n. There are other notions of reductions between families
of polynomials, like c-reductions (polynomial-size oracle circuit reductions), constant-depth
c-reductions, and linear p-projections. For more on these reductions, see [4].

An arithmetic circuit is a directed acyclic graph with leaves labeled by variables or
constants from an underlying ﬁeld, internal nodes labeled by ﬁeld operations + and ×, and
a designated output gate. Each node computes a polynomial in a natural way. The polynomial
computed by a circuit is the polynomial computed at its output gate. A parse tree of a circuit
captures monomial generation within the circuit. Duplicating gates as needed, unwind the
circuit into a formula (fan-out one); a parse tree is a minimal sub-tree (of this unwound
formula) that contains the output gate, that contains all children of each included × gate,
and that contains exactly one child of each included + gate. For a complete deﬁnition see [21].
A circuit is said to be skew if at every × gate, at most one incoming edge is the output of
another gate.

A family of polynomials (fn(x1, . . . , xm(n))) is called a p-family if both the degree d(n) of
fn and the number of variables m(n) are bounded by a polynomial in n. A p-family is in VP
(resp. VBP) if a circuit family (skew circuit family, resp.) (Cn) of size polynomially bounded
in n computes it. A sequence of polynomials (fn) is in VNP if there exist a sequence (gn) in VP,

and polynomials m and t such that for all n, fn(¯x) =P¯y∈{0,1}t(¯x) gn(x1, . . . , xm(n), y1, . . . , yt(n)).

(VBP denotes the algebraic analogue of branching programs. Since these are equivalent to
skew circuits, we directly use a skew circuit deﬁnition of VBP.)

Boolean complexity: We need some basics from Boolean complexity theory. Let P/poly de-
note the class of languages decidable by polynomial-sized Boolean circuit families. A function

3

φ : {0, 1}∗ → N is in #P if there exists a polynomial p and a polynomial time deterministic
Turing machine M such that for all x ∈ {0, 1}∗, f (x) = |{y ∈ {0, 1}p(|x|) | M(x, y) = 1}|. For
a prime p, deﬁne

#pP = {ψ : {0, 1}∗ → Fp | ψ(x) = φ(x) mod p for some φ ∈ #P},

ModpP = {L ⊆ {0, 1}∗ |

for some φ ∈ #P, x ∈ L ⇐⇒ φ(x) ≡ 1 mod p}

It is easy to see that if φ : {0, 1}∗ → N is #P-complete with respect to parsimonious
reductions (that is, for every ψ ∈ #P , there is a polynomial-time computable function
f : {0, 1}∗ → {0, 1}∗ such that for all x ∈ {0, 1}∗, ψ(x) = φ(f (x))), then the language
L = {x | φ(x) ≡ 1 mod p} is ModpP-complete with respect to many-one reductions.

Graph Theory: We consider the treewidth and pathwidth parameters for an undirected
graph. We will work with a “canonical” form of decompositions which is generally useful in
dynamic-programming algorithms.

A (nice) tree decomposition of a graph G is a pair T = (T, {Xt}t∈V (T )), where T is a tree,
rooted at Xr, whose every node t is assigned a vertex subset Xt ⊆ V (G), called a bag, such
that the following conditions hold:
1. Xr = ∅, |Xℓ| = 1 for every leaf ℓ of T , and ∪t∈V (T )Xt = V (G).

That is, the root contain the empty bag, the leaves contain singleton sets, and every
vertex of G is in at least one bag.

2. For every (u, v) ∈ E(G), there exists a node t of T such that {u, v} ⊆ Xt.
3. For every u ∈ V (G), the set Tu = {t ∈ V (T ) | u ∈ Xt} induces a connected subtree of T .
4. Every non-leaf node t of T is of one of the following three types:

– Introduce node: t has exactly once child t′, and Xt = Xt′ ∪ {v} for some vertex

v /∈ Xt′. We say that v is introduced at t.

– Forget node: t has exactly one child t′, and Xt = Xt′ \ {w} for some vertex w ∈ Xt′.

We say that w is forgotten at t.

– Join node: t has two children t1, t2, and Xt = Xt1 = Xt2.

The width of a tree decomposition T is one less than the size of the largest bag; that is,
maxt∈V (T ) |Xt| − 1. The tree-width of a graph G is the minimum possible width of a tree
decomposition of G.

In a similar way we can also deﬁne a nice path decomposition of a graph. For a complete

deﬁnition we refer to [8].

A sequence (Gn) of graphs is called a p-family if the number of vertices in Gn is polyno-
mially bounded in n. It is further said to have bounded tree(path)-width if for some absolute
constant c independent of n, the tree(path)-width of each graph in the sequence is bounded
by c.

A homomorphism from G to H is a map from V (G) to V (H) preserving edges. A graph
is called rigid if it has no homomorphism to itself other than the identity map. Two graphs
G and H are called incomparable if there are no homomorphisms from G → H as well as
H → G. It is known that asymptotically almost all graphs are rigid, and almost all pairs of
nonisomorphic graphs are also incomparable. For the purposes of this paper, we only need a
collection of three rigid and mutually incomparable graphs. For more details, we refer to [16].

4

3 VNP-intermediate

In [5], B¨urgisser showed that unless PH collapses to the second level, an explicit family
of polynomials, called the cut enumerator polynomial, is VNP-intermediate. He raised the
question, recently highlighted again in [15], of whether there are other such natural VNP-
intermediate polynomials. In this section we show that in fact his proof strategy itself can
be adapted to other polynomial families as well. The strategy can be described abstractly
as follows: Find an explicit polynomial family h = (hn) satisfying the following properties.

M: Membership. The family is in VNP.
E: Ease. Over a ﬁeld Fq of size q and characteristic p, h can be evaluated in P. Thus if h is

VNP-hard, then we can eﬃciently compute #P-hard functions, modulo p.

H: Hardness. The monomials of h encode solutions to a problem that is #P-hard via
parsimonious reductions. Thus if h is in VP, then the number of solutions, modulo p, can
be extracted using coeﬃcient computation.

Then, unless ModpP ⊆ P/poly (which in turn implies that PH collapses to the second level,
[19]), h is VNP-intermediate.

We provide a list of p-families that, under the same condition ModpP 6⊆ P/poly, are VNP-
intermediate. All these polynomials are based on basic combinatorial NP-complete problems
that are complete under parsimonious reduction.
(1) The satisﬁablity polynomial Satq = (Satq
possible clauses of size 3 over 2n literals. There are n variables ˜X = {Xi}n
clause-variables ˜Y = {Yc}c∈Cln, one for each 3-clause c.

i 
 Yc ∈Cln


n): For each n, let Cln denote the set of all
i=1, and also 8n3

n := Xa∈{0,1}n

 Yi∈[n]:ai=1

X q−1

Satq

.

Y q−1

c 


a satisﬁes c

For the next three polynomials, we consider the complete graph Gn on n nodes, and we

have the set of variables ˜X = {Xe}e∈En and ˜Y = {Yv}v∈Vn.
(2) The vertex cover polynomial VCq = (VCq

n):

VCq

n := XS⊆Vn 

Y

e∈En : e is incident on S

X q−1

e ! Yv∈S

Y q−1

v ! .

(3) The clique/independent set polynomial CISq = (CISq

n):

CISq

n := XT⊆En Ye∈T

X q−1

e !  Yv incident on T

Y q−1

v ! .

(4) The clow polynomial Clowq = (Clowq
n): A clow in an n-vertex graph is a closed walk of
length exactly n, in which the minimum numbered vertex (called the head) appears exactly

5

once.

Clowq

n := Xw: clow of length n  Ye: edges in w

e !

X q−1

 Yv: vertices in w

(counted only once)

.

Y q−1

v 


If an edge e is used k times in a clow, it contributes X k(q−1)
v contributes only Y q−1

even if it appears more than once. More precisely,

e

v

to the monomial. But a vertex

Clowq

n := Xw=hv0,v1,...,vn−1i:

∀j>0, v0<vj


Yi∈[n]

X q−1

(vi−1,vi mod n)



 Yv∈{v0,v1,...,vn−1}

Y q−1

v 
 .

(5) The 3D-matching polynomial 3DMq = (3DMq
n): Consider the complete tripartite hyper-
graph, where each part in the partition (An, Bn, Cn) contain n nodes, and each hyperedge
has exactly one node from each part. We have variables Xe for hyperedge e and Yv for node
v.

3DMq

n := XM⊆An×Bn×Cn Ye∈M

e !

X q−1

 Yv∈M

(counted only once)

.

Y q−1

v 


We show that if ModpP 6⊆ P/poly, then all ﬁve polynomials deﬁned above are VNP-

intermediate.

Theorem 1. Over a ﬁnite ﬁeld Fq of characteristic p, the polynomial families Satq, VCq,
CISq, Clowq, and 3DMq, are in VNP. Further, if ModpP 6⊆ P/poly, then they are all VNP-
intermediate; that is, neither in VP nor VNP-hard with respect to c-reductions.

Proof. (M) An easy way to see membership in VNP is to use Valiant’s criterion ([28]; see also
Proposition 2.20 in [4]); the coeﬃcient of any monomial can be computed eﬃciently, hence
the polynomial is in VNP. This establishes membership for all families.

We ﬁrst illustrate the rest of the proof by showing that the polynomial Satq satisﬁes the

properties (H), (E).

(H): Assume (Satq

n) is in VP, via polynomial-sized circuit family {Cn}n≥1. We will use
Cn to give a P/poly upper bound for computing the number of satisfying assignments of
a 3-CNF formula, modulo p. Since this question is complete for ModpP, the upper bound
implies ModpP is in P/poly.

Satq

Given an instance φ of 3SAT, with n variables and m clauses, consider the projection of
n obtained by setting all Yc for c ∈ φ to t, and all other variables to 1. This gives the
j=1 djtj(q−1) where dj is the number of assignments (modulo p) that

satisfy exactly j clauses in φ. Our goal is to compute dm.

polynomial Satqφ(t) =Pm

We convert the circuit C into a circuit D that compute elements of Fq[t] by explicitly
giving their coeﬃcient vectors, so that we can pull out the desired coeﬃcient. (Note that after
the projection described above, C works over the polynomial ring Fq[t].) Since the polynomial

6

computed by C is of degree m(q − 1), we need to compute the coeﬃcients of all intermediate
polynomials too only upto degree m(q −1). Replacing + by gates performing coordinate-wise
addition, × by a sub-circuit performing (truncated) convolution, and supplying appropriate
coeﬃcient vectors at the leaves gives the desired circuit. Since the number of clauses, m, is
polynomial in n, the circuit D is also of polynomial size. Given the description of C as advice,
the circuit D can be evaluated in P, giving a P/poly algorithm for computing #3-SAT(φ)
mod p. Hence ModpP ⊆ P/poly.

(E) Consider an assignment to ˜X and ˜Y variables in Fq. Since all exponents are multiples
of (q − 1), it suﬃces to consider 0/1 assignments to ˜X and ˜Y . Each assignment a contributes
0 or 1 to the ﬁnal value; call it a contributing assignment if it contributes 1. So we just need
to count the number of contributing assignments. An assignment a is contributing exactly
when ∀i ∈ [n], Xi = 0 =⇒ ai = 0, and ∀c ∈ Cln, Yc = 0 =⇒ a does not satisfy c. These
two conditions, together with the values of the X and Y variables, constrain many bits of a
contributing assignment; an inspection reveals how many (and which) bits are so constrained.
If any bit is constrained in conﬂicting ways (for example, Xi = 0, and Yc = 0 for some clause
c containing the literal ¯xi), then no assignment is contributing (either ai = 1 and the X part
becomes zero due to X ai
i , or ai = 0 and the Y part becomes zero due to Yc). Otherwise, some
bits of a potentially contributing assignment are constrained by X and Y , and the remaining
bits can be set in any way. Hence the total sum is precisely 2(# unconstrained bits) mod p.

Now assume Satq is VNP-hard. Let L be any language in ModpP, witnessed via #P-
function f . (That is, x ∈ L ⇐⇒ f (x) ≡ 1 mod p.) By the results of [6, 4], there exists a
p-family r = (rn) ∈ VNPFp such that ∀n, ∀x ∈ {0, 1}n, rn(x) = f (x) mod p. By assumption,
there is a c-reduction from r to Satq. We use the oracle circuits from this reduction to decide
instances of L. On input x, the advice is the circuit C of appropriate size reducing r to Satq.
We evaluate this circuit bottom-up. At the leaves, the values are known. At + and × gates,
we perform these operations in Fq. At an oracle gate, the paragraph above tells us how to
evaluate the gate. So the circuit can be evaluated in polynomial time, showing that L is in
P/poly. Thus ModpP ⊆ P/poly.

For the other four families, it suﬃces to show the following, since the rest is identical as

for Satq.

H’. The monomials of h encode solutions to a problem that is #P-hard via parsimonious

reductions.

E’. Over Fq, h can be evaluated in P.

We describe this for the polynomial families one by one.

The vertex cover polynomial VCq = (VCq

n):

VCq

n := XS⊆Vn 

Y

e∈En : e is incident on S

X q−1

e ! Yv∈S

Y q−1

v ! .

(H’): Given an instance of vertex cover A = (V (A), E(A)) such that |V (A)| = n and |E(A)| =
m, we show how VCq
n encodes the number of solutions of instance A. Consider the following

7

projection of VCq
and set Xe = 1. Thus, we have

n. Set Yv = t, for v ∈ V (A). For e ∈ E(A), set Xe = z; otherwise e /∈ E(A)

VCq

n(z, t) = XS⊆Vn

z(# edges incident on S)(q−1)t|S|(q−1).

n(z, t).

Hence, it follows that the number of vertex cover of size k, modulo p, is the coeﬃcient of
zm(q−1)tk(q−1) in VCq
(E’): Consider the weighted graph given by the values of ˜X and ˜Y variables. Each subset
S ⊆ Vn contributes 0 or 1 to the total. A subset S ⊆ Vn contributes 1 to VCq
n if and only
if every vertex in S has non-zero weight, and every edge incident on each vertex in S has
non-zero weight. That is, S is a subset of full-degree vertices. Therefore, the total sum is
2(# full-degree vertices) mod p.

The clique/independent set polynomial CISq = (CISq

n):

CISq

n := XT⊆En Ye∈T

X q−1

e !  Yv incident on T

Y q−1

v ! .

(H’): Given an instance of clique A = (V (A), E(A)) such that |V (A)| = n and |E(A)| = m,
we show how CISq
n encodes the number of solutions of instance A. Consider the following
projection of CISq
n. Set Yv = t, for v ∈ V (A). For e ∈ E(A), set Xe = z; otherwise e /∈ E(A)
and set Xe = 1. (This is the same projection as used for vertex cover.) Thus, we have

CISq

n(z, t) = XT⊆En

z|T∩E(A)|(q−1)t(# vertices incident on T )(q−1).

n(z, t).

2)(q−1)tk(q−1) in CISq

Now it follows easily that the number of cliques of size k, modulo p, is the coeﬃcient of
z(k
(E’): Consider the weighted graph given by the values of ˜X and ˜Y variables. Each subset
T ⊆ En contributes 0 or 1 to the sum. A subset T ⊆ En contributes 1 to the sum if and
only if all edges in T have non-zero weight, and every vertex incident on T must have non-
zero weight. Therefore, we consider the graph induced on vertices with non-zero weights.
Any subset of edges in this induced graph contributes 1 to the total sum; all other subsets
contribute 0. Let ℓ be the number of edges in the induced graph with non-zero weights. Thus,
the total sum is 2ℓ mod p.

The clow polynomial Clowq = (Clowq
n): A clow in an n-vertex graph is a closed walk of
length exactly n, in which the minimum numbered vertex (called the head) appears exactly
once.

Clowq

n := Xw: clow of length n  Ye: edges in w

8

e !

X q−1

 Yv: vertices in w

(counted only once)

.

Y q−1

v 


(If an edge e is used k times in a clow, it contributes X k(q−1)
(H’): Given an instance A = (V (A), E(A)) of the Hamiltonian cycle problem with |V (A)| = n
and |E(A)| = m, we show how Clowq
n encodes the number of Hamiltonian cycles in A.
Consider the following projection of Clowq
n. Set Yv = t, for v ∈ V (A). For e ∈ E(A), set
Xe = z; otherwise e /∈ E(A) and set Xe = 1. (The same projection was used for VCq and
CISq.) Thus, we have

to the monomial.)

e

Clowq

n(z, t) = Xw: clow of length n


 Ye: edges in w∩E(A)

zq−1



 Yv: vertices in w

(counted only once)

tq−1


.

From the deﬁnition, it now follows that number of Hamiltonian cycles in A, modulo p, is the
coeﬃcient of zn(q−1)tn(q−1).
n on instantiations of ˜X and ˜Y variables, we consider the weighted
(E’): To evaluate Clowq
graph given by the values to the variables. We modify the edge weights as follows: if an edge
is incident on a node with zero weight, we make its weight 0 irrespective of the value of the
corresponding X variable. Thus, all zero weight vertices are isolated in the modiﬁed graph
G. Hence, the total sum is equal to the number of closed walks of length n, modulo p, in this
modiﬁed graph. This can be computed in polynomial time using matrix powering as follows:
Let Gi denote the induced subgraph of G with vertices {i, . . . , n}, and let Ai be its adjacency
matrix. We represent Ai as an n × n matrix with the ﬁrst i − 1 rows and columns having
only zeroes. Now the number of clows with head i is given by the [i, i] entry of AiAn−2

i+1 Ai.

The 3D-matching polynomial 3DMq = (3DMq
n): Consider the complete tripartite
hyper-graph, where each partition contain n nodes, and each hyperedge has exactly one
node from each part. As before, there are variables Xe for hyperedge e and Yv for node v.

3DMq

n := XM⊆An×Bn×Cn Ye∈M

e !

X q−1

 Yv∈M

(counted only once)

.

Y q−1

v 


(H’): Given an instance of 3D-Matching H, we consider the usual projection. The variables
corresponding to the vertices are all set to t. The edges present in H are all set to z, and the
ones not present are set to 1. Then the number of 3D-matchings in H, modulo p, is equal to
the coeﬃcient of zn(q−1)t3n(q−1) in 3DMq
(E’): To evaluate 3DMq
n over Fq, consider the hypergraph obtained after removing the ver-
tices with zero weight, edges with zero weight, and edges that contain a vertex with zero
weight (even if the edges themselves have non-zero weight). Every subset of hyperedges in
this modiﬁed hypergraph contributes 1 to the total sum, and all other subsets contribute 0.
Hence, the evaluation equals 2(# edges in the modiﬁed hypergraph) mod p.
⊓⊔

n(z, t).

It is worth noting that the cut enumerator polynomial Cutq, showed by B¨urgisser to be
VNP-intermediate over ﬁeld Fq, is in fact VNP-complete over the rationals when q = 2, [9].
Thus the above technique is speciﬁc to ﬁnite ﬁelds.

9

4 Monotone projection lower bounds

We now show that some of our intermediate polynomials are not monotone p-projections of
the Permanent polynomial. The results here are motivated by the recent results of Gro-
chow [15]. Recall that a polynomial f (x1, . . . , xn) is a projection of a polynomial g(y1, . . . , ym)
if f (x1, . . . , xn) = g(a1, . . . , am), where ai’s are either constants or xj for some j. The poly-
nomial f is an aﬃne projection of g if f can be obtained from g by replacing each yi with
an aﬃne linear function ℓi(˜x). Over any subring of R, or more generally any totally ordered
semi-ring, a monotone projection is a projection in which all constants appearing in the
projection are non-negative. We say that the family (fn) is a (monotone aﬃne) projection
of the family (gn) with blow-up t(n) if for all suﬃciently large n, fn is a (monotone aﬃne)
projection of gt(n).

Theorem 2. Over the reals (or any totally ordered semi-ring), for any q, the families Satq
and Clowq are not monotone aﬃne p-projections of the Permanent family. Any monotone
aﬃne projection from Permanent to Satq must have a blow-up of at least 2Ω(√n). Any
monotone aﬃne projection from Permanent to Clowq must have a blow-up of at least
2Ω(n).

Before giving the proof, we set up some notation. For more details, see [2, 26, 15]. For any
polynomial p in n variables, let Newt(p) denote the polytope in Rn that is the convex hull of
the vectors of exponents of monomials of p. For any Boolean formula φ on n variables, let
p-SAT(φ) denote the polytope in Rn that is the convex hull of all satisfying assignments of
φ. Let Kn = (Vn, En) denote the n-vertex complete graph. The travelling salesperson (TSP)
polytope is deﬁned as the convex hull of the characteristic vectors of all subsets of En that
deﬁne a Hamiltonian cycle in Kn.

For a polytope P , let c(P ) denote the minimal number of linear inequalities needed to
deﬁne P . A polytope Q ⊆ Rm is an extension of P ⊆ Rn if there is an aﬃne linear map
π : Rm → Rn such that π(Q) = P . The extension complexity of P , denoted xc(P ), is the
minimum size c(Q) of any extension Q (of any dimension) of P .

The following are straightforward, see for instance [15, 13].

Fact 3 1. c(Newt(Permn)) 6 2n.
2. If polytope Q is an extension of polytope P , then xc(P ) 6 xc(Q).

We use the following recent results.

Proposition 1. 1. Let f (x1, . . . , xn) and g(y1, . . . , ym) be polynomials over a totally ordered
semi-ring R, with non-negative coeﬃcients. If f is a monotone projection of g, then
the intersection of Newt(g) with some linear subspace is an extension of Newt(f ). In
particular, xc(Newt(f )) 6 m + c(Newt(g)). [15]

2. For every n there exists a 3SAT formula φ with O(n) variables and O(n) clauses such

that xc(p-SAT(φ)) > 2Ω(√n). [2]

3. The extension complexity of the TSP polytope is 2Ω(n). [26]

10

Proof. (of Theorem 2.) Let φ be a 3SAT formula with n variables and m clauses as given by
Proposition 1 (2). For the polytope P = p-SAT(φ), xc(P ) is high.

Let Q be the Newton polytope of Satq

n. It resides in N dimensions, where N = n +
|Cln| = n + 8n3, and is the convex hull of vectors of the form (q − 1)h˜a˜bi where ˜a ∈ {0, 1}n,
˜b ∈ {0, 1}N−n, and for all c ∈ Cln, ˜a satisﬁes c if and only if bc = 1. For each ˜a ∈ {0, 1}n,
there is a unique ˜b ∈ {0, 1}N−n such that (q − 1)h˜a˜bi is in Q.

Deﬁne the polytope R, also in N dimensions, to be the convex hull of vectors that are

vertices of Q and also satisfy the constraintPc∈φ bc ≥ m. This constraint discards vertices of

Q where ˜a does not satisfy φ. Thus R is an extension of P (projecting the ﬁrst n coordinates
of points in R gives a (q − 1)-scaled version of P ), so by Fact 3(2), xc(P ) ≤ xc(R). Further,
we can obtain an extension of R from any extension of Q by adding just one inequality;
hence xc(R) ≤ 1 + xc(Q).

Suppose Satq is a monotone aﬃne projection of Permn with blow-up t(n). By Fact 3(1) and
Proposition 1(1), xc(Newt(Satq)) = xc(Q) ≤ t(n)+c(Permt(n)) ≤ O(t(n)). From the preceding
discussion and by Proposition 1(2), we get 2Ω(√n) ≤ xc(P ) ≤ xc(R) ≤ 1 + xc(Q) ≤ O(t(n)).
It follows that t(n) is at least 2Ω(√n).

For the Clowq polynomial, let P be the TSP polytope and Q be Newt(Clowq). The vertices
of Q are of the form (q − 1)˜a˜b where ˜a ∈ {0, 1}(n
2) picks a subset of edges, ˜b ∈ {0, 1}n picks
a subset of vertices, and the picked edges form a length-n clow touching exactly the picked

vertices. Deﬁne polytope R by discarding vertices of Q where Pi∈[n] bi < n. Now the same

argument as above works, using Proposition 1(3) instead of (4).

⊓⊔

5 Complete families for VP and VBP

The quest for a natural VP-complete polynomial has generated a signiﬁcant amount of re-
search [4, 23, 22, 7, 11]. The ﬁrst success story came from [11], where some naturally deﬁned
homomorphism polynomials were studied, and a host of them were shown to be complete for
the class VP. But the results came with minor caveats. When the completeness was estab-
lished under projections, there were non-trivial restrictions on the set of homomorphisms H,
and sometimes even on the target graph H. On the other hand, when all homomorphisms
were allowed, completeness could only be shown under seemingly more powerful reductions,
namely, constant-depth c-reductions. Furthermore, the graphs were either directed or had
weights on nodes. It is worth noting that the reductions in [11] actually do not use the full
power of generic constant-depth c-reductions; a closer analysis reveals that they are in fact
linear p-projection. That is, the reductions are linear combinations of polynomially many
p-projections (see Chapter 3, [4]). Still, this falls short of p-projections.

In this work, we remove all such restrictions and show that there is a simple explicit
homomorphism polynomial family that is complete for VP under p-projections. In this family,
the source graphs G are speciﬁc bounded-tree-width graphs, and the target graphs H are
complete graphs. We also show that a similar family with bounded-path-width source graphs
is complete for VBP under p-projections. Thus, homomorphism polynomials are rich enough
to characterise computations by circuits as well as algebraic branching programs.

11

The polynomials we consider are deﬁned formally as follows.

Deﬁnition 4 Let G = (V (G), E(G)) and H = (V (H), E(H)) be two graphs. Consider the
set of variables ¯Z := {Zu,a | u ∈ V (G) and a ∈ V (H)} and ¯Y := {Y(u,v) | (u, v) ∈ E(H)}.
Let H be a set of homomorphisms from G to H. The homomorphism polynomial fG,H,H in
the variable set ¯Y , and the generalised homomorphism polynomial ˆfG,H,H in the variable set
¯Z ∪ ¯Y , are deﬁned as follows:

fG,H,H = Xφ∈H
ˆfG,H,H = Xφ∈H


 Y(u,v)∈E(G)

 Yu∈V (G)

Y(φ(u),φ(v))
 .

Zu,φ(u)
 Y(u,v)∈E(G)


Y(φ(u),φ(v))
 .

Let Hom denote the set of all homomorphisms from G to H. If H equals Hom, then we
drop it from the subscript and write fG,H or ˆfG,H.

Note that for every G, H, H, fG,H,H( ¯Y ) equals ˆfG,H,H( ¯Y ) | ¯Z=¯1. Thus upper bounds for ˆf

give upper bounds for f , while lower bounds for f give lower bounds for ˆf .

We show in Theorem 5 that for any p-family (Hm), and any bounded tree-width (path-
width, respectively) p-family (Gm), the polynomial family (fm) where fm = ˆfGm,Hm is in VP
(VBP, respectively). We then show in Theorem 6 that for a speciﬁc bounded tree-width family
(Gm), and for Hm = Km6, the polynomial family (fGm,Hm) is hard, and hence complete, for
VP with respect to projections. An analogous statement is shown in Theorem 7 for a speciﬁc
bounded path-width family (Gm) and for Hm = Km2. Over ﬁelds of characteristic other
than 2, VBP-hardness is obtained for a simpler family of source graphs Gm, as described in
Theorem 8.

5.1 Upper Bound

In [11], it was shown that the homomorphism polynomial ˆfTm,Kn where Tm is a binary tree
on m leaves, and Kn is a complete graph on n nodes, is computable by an arithmetic circuit
of size O(m3n3). Their proof idea is based on recursion: group the homomorphisms based on
where they map the root of Tm and its children, and recursively compute the sub-polynomials
within each group. The sub-polynomials of a speciﬁc group have a special set of variables
in their monomials. Hence, the homomorphism polynomial can be computed by suitably
combining partial derivatives of the sub-polynomials. The partial derivatives themselves can
be computed eﬃciently using the technique of Baur and Strassen, [3].

Generalizing the above idea to polynomials where the source graph is not a binary tree
Tm but a bounded tree-width graph Gm seems hard. The very ﬁrst obstacle we encounter
is to generalize the concept of partial derivative to monomial extension. Combining sub-
polynomials to obtain the original polynomial also gets rather complicated.

12

We sidestep this diﬃculty by using a dynamic programming approach [10] based on a
“nice” tree decomposition of the source graph. This shows that the homomorphism polyno-
mial ˆfG,H is computable by an arithmetic circuit of size at most 2|V (G)| · |V (H)|tw(G)+1 ·
(2|V (H)| + 2|E(H)|), where tw(G) is the tree-width of G.

Let T = (T, {Xt}t∈V (T )) be a nice tree decomposition of G of width τ . For each t ∈ V (T ),
let Mt = {φ | φ : Xt → V (H)} be the set of all mappings from Xt to V (H). Since |Xt| 6 τ +1,
we have |Mt| 6 |V (H)|τ +1. For each node t ∈ V (T ), let Tt be the subtree of T rooted at

Gr = G.

node t, Vt := St′∈V (Tt) Xt′, and Gt := G[Vt] be the subgraph of G induced on Vt. Note that

We will build the circuit inductively. For each t ∈ V (T ) and φ ∈ Mt, we have a gate
ht, φi in the circuit. Such a gate will compute the homomorphism polynomial from Gt to
H such that the mapping of Xt in H is given by φ. For each such gate ht, φi we introduce
another gate ht, φi′ which computes the “partial derivative” (or, quotient) of the polynomial
computed at ht, φi with respect to the monomial given by φ. As we mentioned before, the
construction is inductive, starting at the leaf nodes and proceeding towards the root.

Base case (Leaf nodes): Let ℓ ∈ V (T ) be a leaf node. Then, Xℓ = {u} such that u ∈ V (G).
Note that any φ ∈ Mℓ is just a mapping of u to some node in V (H). Hence, the set Mℓ can
be identiﬁed with V (H). Therefore, for all h ∈ V (H), we label the gate hℓ, hi by the variable
Zu,h. The derivative gate hℓ, hi′ in this case is set to 1.

Introduce nodes: Let t ∈ V (T ) be an introduce node, and t′ be its unique child. Then,
Xt \ Xt′ = {u} for some u ∈ V (G). Let N(u) := {v|v ∈ Xt′ and (v, u) ∈ E(Gt)}. Note
that there is a one-to-one correspondence between φ ∈ Mt and pairs (φ′, h) ∈ Mt′ × V (H).
Therefore, for all φ(= (φ′, h)) ∈ Mt such that ∀v ∈ N(u), (φ′(v), h) ∈ E(H), we set

ht, φi := Zu,h ·

ht, φi′ := ht′, φ′i′,

 Yv∈N (u)

Y(φ′(v),h)


· ht′, φ′i

and,

otherwise we set ht, φi = ht, φi′ := 0.

Forget nodes: Let t ∈ V (T ) be a forget node and t′ be its unique child. Then, Xt′ \ Xt = {u}
for some u ∈ V (G). Again note that there is a one-to-one correspondence between pairs
(φ, h) ∈ Mt × V (H) and φ′ ∈ Mt′. Let N(u) := {v|v ∈ Xt and (v, u) ∈ E(Gt′)}. Therefore,
for all φ ∈ Mt, we set

ht, φi := Xh∈V (H)

ht′, (φ, h)i

and,

ht, φi′ :=

Xh∈V (H) such that

∀v∈N (u),(φ(v),h)∈E(H)

Zu,h ·

 Yv∈N (u)

Y(φ(v),h)


· ht′, (φ, h)i′.

13

Join nodes: Let t ∈ V (T ) be a join node, and t1 and t2 be its two children; we have
Xt = Xt1 = Xt2. Then, for all φ ∈ Mt, we set

ht, φi := ht1, φi · ht2, φi′ (= ht1, φi′ · ht2, φi)
ht, φi′ := ht1, φi′ · ht2, φi′.

The output gate of the circuit is hr, ∅i. The correctness of the algorithm is readily seen via
induction in a similar way. The bound on the size also follows easily from the construction.
We observe some properties of our construction. First, the circuit constructed is a constant-
free circuit. This was the case with the algorithm from [11] too. Second, if we start with a
path decomposition, we obtain skew circuits, since the join nodes are absent. The algorithm
from [11] does not give skew circuits when Tm is a path. (It seems the obstacle there lies in
computing partial-derivatives using skew circuits.)

From the above algorithm and its properties, we obtain the following theorem.

Theorem 5. Consider the family of homomorphism polynomials (fm), where fm = fGm,Hm( ¯Z, ¯Y ),
and (Hm) is a p-family of complete graphs.

– If (Gm) is a p-family of graphs of bounded tree-width, then (fm) ∈ VP.
– If (Gm) is a p-family of graphs of bounded path-width, then (fm) ∈ VBP.

5.2 VP-completeness

We now turn our attention towards establishing VP-hardness of the homomorphism polyno-
mials. We need to show that there exists a p-family (Gm) of bounded tree-width graphs such
that (fGm,Hm( ¯Y )) is hard for VP under projections.

We use rigid and mutually incomparable graphs in the construction of Gm. Let I :=
{I0, I1, I2} be a ﬁxed set of three connected, rigid and mutually incomparable graphs. Note
that they are necessarily non-bipartite. Let cIi = |V (Ii)|. Choose an integer cmax > max {cI0, cI1, cI2}.
Identify two distinct vertices {v0
distinct vertices {v2
p} in I2.

r } in I0, three distinct vertices {v1

p} in I1, and three

ℓ , v1

r , v1

ℓ , v0

ℓ , v2

r , v2

For every m a power of 2, we denote a complete (perfect) binary tree with m leaves by Tm.
We construct a sequence of graphs Gm (Fig. 1) from Tm as follows: ﬁrst replace the root by
the graph I0, then all the nodes on a particular level are replaced by either I1 or I2 alternately
(cf. Fig. 1). Now we add edges; suppose we are at a ‘node’ which is labeled Ii and the left
child and right child are labeled Ij, we add an edge between vi
p in the left child, and an
edge between vi
p in the right child. Finally, to obtain Gm we expand each added edge
into a simple path with cmax vertices on it (cf. Fig. 1). That is, a left-edge connection between
two incomparable graphs in the tree looks like, Ii(vi
p)Ij.
Theorem 6. Over any ﬁeld, the family of homomorphism polynomials (fm), with fm( ¯Y ) =
fGm,Hm( ¯Y ), where

ℓ) − (path with cmax vertices) − (vj

r and vj

ℓ and vj

– Gm is deﬁned as above (see Fig. 1), and
– Hm is an undirected complete graph on poly(m), say m6, vertices,

14

I0

I1

path with cmax vertices

I1

I2

I2

I2

I2

I1

I1

I1

I1

I1

I1

I1

I1

Fig. 1. The graph Gm.

is complete for VP under p-projections.

Proof. Membership in VP follows from Theorem 5.

We proceed with the hardness proof. The idea is to obtain the VP-complete universal
polynomial from [23] as a projection of fm. This universal polynomial is computed by a
normal-form homogeneous circuit with alternating unbounded fanin-in + and bounded fan-
in × gates. We would like to put its parse trees in bijection with homomorphisms from G
to H. This becomes easier if we use an equivalent universal circuit in a nice normal form as
described in [11]. The normal form circuit is multiplicatively disjoint; sub-circuits of × gates
are disjoint (see [21]). This ensures that even though Cn itself is not a formula, all its parse
trees are already subgraphs of Cn even without unwinding it into a formula.

Our starting point is the related graph J′n in [11]. The parse trees in Cn are complete
alternating unary-binary trees. The graph J′n is constructed in such a way that the parse
trees are now in bijection with complete binary trees. To achieve this, we “shortcut” the +
gates, while preserving information about whether a subtree came in from the left or the
right. For completeness sake we describe the construction of J′n from [11].

We obtain a sequence of graphs (J′n) from the undirected graphs underlying (Cn) as
follows. Retain the multiplication and input gates of Cn. Let us make two copies of each. For
each retained gate, g, in Cn; let gL and gR be the two copies of g in J′n. We now deﬁne the edge
connections in J′n. Assume g is a × gate retained in J′n. Let α and β be two + gates feeding
into g in Cn. Let {α1, . . . , αi} and {β1, . . . , βj} be the gates feeding into α and β, respectively.
Assume without loss of generality that α and β feed into g from left and right, respectively.
We add the following set of edges to J′n: {(α1L, gL), . . . , (αiL, gL)}, {(β1R, gL), . . . , (βjR, gL)},
{(α1L, gR), . . . , (αiL, gR)} and {(β1R, gR), . . . , (βjR, gR)}. We now would like to keep a single
copy of Cn in these set of edges. So we remove the vertex rootR and we remove the remaining
spurious edges in following way. If we assume that all edges are directed from root towards
leaves, then we keep only edges induced by the vertices reachable from rootL in this directed
graph. In [11], it was observed that there is a one-to-one correspondence between parse trees
of Cn and subgraphs of J′n that are rooted at rootL and isomorphic to T2k(n).

We now transform J′n using the set I = {I0, I1, I2}. This is similar to the transformation
we did to the balanced binary tree Tm. We replace each vertex by a graph in I; rootL gets I0

15

and the rest of the layers get I1 or I2 alternately (as in Fig. 1). Edge connections are made
so that a left/right child is connected to its parent via the edge (vj
r). Finally we
replace each edge connection by a path with cmax vertices on it (as in Fig. 1), to obtain the
graph Jn. All edges of Jn are labeled 1, with the following exceptions: Every input node
contains the same rigid graph Ii. It has a vertex vi
p. Each path connection to other nodes
has this vertex as its end point. Label such path edges that are incident on vi
p by the label
of the input gate.

ℓ)/(vj

p, vi

p, vi

Let m := 2k(n). The choice of poly(m) is such that 4sn 6 poly(m), where sn is the size of
Jn. The ¯Y variables are set to {0, 1, ¯x} such that the non-zero variables pick out the graph
Jn. From the observations of [11] it follows that for each parse tree p-T of Cn, there exists a
homomorphism φ : G2k(n) → Jn such that mon(φ) is exactly equal to mon(p-T). By mon(·)
we mean the monomial associated with an object. We claim that these are the only valid
homomorphisms from G2k(n) → Jn. We observe the following properties of homomorphisms
from G2k(n) → Jn, from which the claim follows. In the following by a rigid-node-subgraph
we mean a graph in {I0, I1, I2} that replaces a vertex.

(i) Any homomorphic image of a rigid-node-subgraph of G2k(n) in Jn, cannot split across two
mutually incomparable rigid-node-subgraphs in Jn. That is, there cannot be two vertices
in a rigid subgraph of G2k(n) such that one of them is mapped into a rigid subgraph say
n1, and the other one is mapped into another rigid subgraph say n2. This follows because
homomorphisms do not increase distance.

(ii) Because of (i), with each homomorphic image of a rigid node gi ∈ G2k(n), we can associate
at most one rigid node of Jn, say ni, such that the homomorphic image of gi is a subgraph
of ni and the paths (corresponding to incident edges) emanating from it. But such a
subgraph has a homomorphism to ni itself: fold each hanging path into an edge and then
map this edge into an edge within ni. (For instance, let ρ be a path hanging oﬀ ni and
attached to ni at u, and let v be any neighbour of u within ni. Mapping vertices of ρ
to u and v alternately preserves all edges and hence is a homomorphism.) Therefore,
we note that in such a case we have a homomorphism from gi → ni. By rigidity and
mutual incomparability, gi must be the same as ni, and this folded-path homomorphism
must be the identity map. The other scenario, where we cannot associate any ni because
gi is mapped entirely within connecting paths, is not possible since it contradicts non-
bipartiteness of mutually-incomparable graphs.

Root must be mapped to the root: The rigidity of I0 and Property (ii) implies that
I0 ∈ G2k(n) is mapped identically to I0 in Jn.
Every level must be mapped within the same level: The children of I0 in G2k(n) are
mapped to the children of the root while respecting left-right behaviour. Firstly, the left child
cannot be mapped to the root because of incomparability of the graphs I1 and I0. Secondly,
the left child cannot be mapped to the right child (or vice versa) even though they are the
same graphs, because the minimum distance between the vertex in I0 where the left path
emanates and the right child is cmax + 1 whereas the distance between the vertex in I0 where
the left path emanates and the left child is cmax. So some vertex from the left child must be
mapped into the path leading to the right child and hence the rest of the left child must be

16

mapped into a proper subgraph of right child. But this contradicts rigidity of I1. Continuing
like this, we can show that every level must map within the same level and that the mapping
⊓⊔
within a level is correct.

5.3 VBP-completeness

Finally, we show that homomorphism polynomials are also rich enough to characterize com-
putation by algebraic branching programs. Here we establish that there exists a p-family (Gk)
of undirected bounded path-width graphs such that the family (fGk,Hk( ¯Y )) is VBP-complete
with respect to p-projections.

We note that for VBP-completeness under projections, the construction in [11] required
directed graphs. In the undirected setting they could establish hardness only under linear
p-projection, that too using 0-1 valued weights.

As before, we use rigid and mutually incomparable graphs in the construction of Gk.
Let I := {I1, I2} be two connected, non-bipartite, rigid and mutually incomparable graphs.
Arbitrarily pick vertices u ∈ V (I1) and v ∈ V (I2). Let cIi = |V (Ii)|, and cmax = max{cI1, cI2}.
Consider the sequence of graphs Gk (Fig. 2); for every k, there is a simple path with (k −
1) + 2cmax edges between a copy of I1 and I2. The path is between the vertices u ∈ V (I1)
and v ∈ V (I2). The path between vertices a and b in Gk contains (k − 1) edges.

I1(u)

a

b

(v)I2

cmax edges

k − 1 edges

cmax edges

Fig. 2. The graph Gk.

In other words, connect I1 and I2 by stringing together a path with cmax edges between
u and a, a path with k − 1 edges between a and b, and a path with cmax edges between b
and v.

Theorem 7. Over any ﬁeld, the family of homomorphism polynomials (fk), where

– Gk is deﬁned as above (see Fig. 2),
– Hk is the undirected complete graph on O(k2) vertices,
– fk( ¯Y ) = fGk ,Hk( ¯Y ),

is complete for VBP with respect to p-projections.

Proof. Membership: It follows from Theorem 5.
Hardness: Let (gn) ∈ VBP. Without loss of generality, we can assume that gn is computable
by a layered branching program of polynomial size such that the number of layers, ℓ, is more
than the width of the algebraic branching program.

Let B′n be the undirected graph underlying the layered branching program An for gn. Let
Bn be the following graph: I1(u) − (s)B′n(t) − (v)I2, that is, u ∈ I1 is connected to s ∈ B′n

17

via a path with cmax edges and t ∈ B′n is connected to v ∈ I2 via a path with cmax edges (cf.
Fig. 2). The edges in B′n inherits the weight from An, and the rest of the edges in Bn have
weight 1.

Let us now consider fℓ when the variables on the edges of Hℓ are instantiated to values
in {0, 1} or variables of gn so that we obtain Bℓ as a subgraph of Hℓ. We claim that a valid
homomorphism from Gℓ → Bℓ must satisfy the following properties:

(P1) I1 in Gℓ must be mapped to I1 in Bℓ using the identity homomorphism,
(P2) I2 in Gℓ must be mapped to I2 in Bℓ using the identity homomorphism.

Assuming the claim, it follows that homomorphisms from Gℓ → Bℓ are in one-to-one
correspondence with s-t paths in An. In particular, the vertex a ∈ Gℓ is mapped to the
vertex s in Bℓ, and the vertex b ∈ Gℓ is mapped to the vertex t in Bℓ. Also, the monomial
associated with a homomorphism and its corresponding path are the same. Therefore, we
have,

fGℓ,Bℓ = gn.

Since ℓ is polynomially bounded, we obtain VBP-completeness of (fk) over any ﬁeld.

Let us now prove the claim. We ﬁrst prove that a valid homomorphism from Gℓ → Bℓ

must satisfy the property (P1). There are three cases to consider.

– Case 1: Some vertex of V (I1) ⊆ V (Gℓ) is mapped to u in Bℓ. Since homomorphisms
cannot increase distances between two vertices, we conclude that V (I1) must be mapped
within the subgraph I1(u) − (a). Suppose further that some vertex on the (u) − (a)
path other than u is also in the homomorphic image of V (I1). Some neighbour of u in
V (I1) ⊆ V (Bℓ), say u′, must also be in the homomorphic image, since otherwise we have
a homomorphism from the non-bipartite I1 to a path, a contradiction. But note that
I1(u) − (a) has a homomorphism to I1: fold the (u) − (a) path onto the edge u − u′ in
I1. Hence, composing the two homomorphisms we obtain a homomorphism from I1 to I1
which is not surjective. This contradicts the rigidity of I1. So in fact the homomorphism
must map V (I1) from Gℓ entirely within I1 from Bℓ, and by rigidity of I1, this must be
the identity map.

– Case 2: Some vertex of V (I1) ⊆ V (Gℓ) is mapped to v in Bℓ. Since homomorphisms
cannot increase distances between two vertices, we conclude that V (I1) must be mapped
within the subgraph (b) − (v)I2. But note that (b) − (v)I2 has a homomorphism to I2
(fold the (b) − (v) path onto any edge incident on v within I2). Hence, composing the
two homomorphisms, we obtain a homomorphism from I1 to I2. This is a contradiction,
since I1 and I2 were incomparable graphs to start with.

– Case 3: No vertex of V (I1) ⊆ V (Gℓ) is mapped to u or v in Bℓ. Then V (I1) ⊆ V (Gℓ)
must be mapped entirely within one of the following disjoint regions of Bℓ: (a) I1 \ {u},
(b) bipartite graph between vertices u and v, and (c) I2\{v}. But then we contradict rigid-
ity of I1 in the ﬁrst case, non-bipartiteness of I1 in the second case, and incomparability
of I1 and I2 in the last.

In a similar way, we could also prove that a valid homomorphism from Gℓ → Bℓ must
⊓⊔

satisfy the property (P2).

18

In the above proof, we crucially used incomparability of I1 and I2 to rule out ﬂipping
an undirected path. It turns out that over ﬁelds of characteristic not equal to 2, this is not
crucial, since we can divide by 2. We show that if the characteristic of the underlying ﬁeld
is not equal to 2, then the sequence (Gk) in the preceding theorem can be replaced by a
sequence of simple undirected cycles of appropriate length. In particular, we establish the
following result.

Theorem 8. Over ﬁelds of char 6= 2, the family of homomorphism polynomials (fk), fk =
fGk,Hk, where

– Gk is a simple undirected cycle of length 2k + 1 and,
– Hk is an undirected complete graph on (2k + 1)2 vertices,

is complete for VBP under p-projections.

Proof. Membership: As before, it follows from Theorem 5.
Hardness: Let (gn) ∈ VBP. Without loss of generality, we can assume that gn is computable
by a layered branching program of polynomial size satisfying the following properties:

– The number of layers, ℓ > 3, is odd; say ℓ = 2m + 1. So every path from s to t in the

branching program has exactly 2m edges.

– The number of layers, is more than the width of the algebraic branching program,

Let us consider fm when the variables on the edges of Hm have been set to 0, 1, or
variables of gn so that we obtain the undirected graph underlying the layered branching
program An for gn as a subgraph of Hm. Now change the weight of the (s, t) edge from 0
to weight y, where y is a new variable distinct from all the other variables of gn. Call this
modiﬁed graph Bm. Note that without the new edge, Bm would be bipartite.

Let us understand the homomorphisms from Gm to Bm. Homomorphisms from a simple
cycle C to a graph G are in one-to-one correspondence with closed walks of the same length
in G. Moreover, if the cycle C is of odd length, the closed walk must contain a simple odd
cycle of at most the same length. Therefore, the only valid homomorphism from Gm to Bm
are walks of length ℓ = 2m + 1, and they all contain the edge (s, t) with weight y. But the
cycles of length ℓ in Bm are in one-to-one correspondence with s-t paths in An. Each cycle
contributes 2ℓ walks: we can start the walk at any of the ℓ vertices, and we can follow the
directions from An or go against those directions. Thus we have,

fGm,Bm = (2(2m + 1)) · y · gn = (2ℓ) · y · gn.

Let p be the characteristic of the underlying ﬁeld. If p = 0, we substitute y = (2ℓ)−1 to
obtain gn. If p > 2, then 2ℓ has an inverse if and only if ℓ has an inverse. Since ℓ > 3 is an
odd number, either p does not divide ℓ or it does not divide ℓ + 2. Hence, at least one of ℓ,
ℓ + 2 has an inverse. Thus gn is a projection of fm or fm+1 depending on whether ℓ or ℓ + 2
has an inverse in characteristic p.

Since ℓ = 2m + 1 is polynomially bounded in n, we therefore show (fk) is VBP-complete
⊓⊔

with respect to p-projections over any ﬁeld of characteristic not equal to 2.

19

6 Conclusion

In this paper, we have shown that over ﬁnite ﬁelds, ﬁve families of polynomials are in-
termediate in complexity between VP and VNP, assuming the PH does not collapse. Over
rationals and reals, we have established that two of these families are provably not monotone
p-projections of the permanent polynomials. Finally, we have obtained a natural family of
polynomials, deﬁned via graph homomorphisms, that is complete for VP with respect to
projections; this is the ﬁrst family deﬁned independent of circuits and with such hardness.
An analogous family is also shown to be complete for VBP.

Several interesting questions remain.
The deﬁnitions of our intermediate polynomials use the size q of the ﬁeld Fq, not just
the characteristic p. Can we ﬁnd families of polynomials with integer coeﬃcients, that are
VNP-intermediate (under some natural complexity assumption of course) over all ﬁelds of
characteristic p? Even more ambitiously, can we ﬁnd families of polynomials with integer
coeﬃcients, that are VNP-intermediate over all ﬁelds with non-zero characteristic? at least
over all ﬁnite ﬁelds? over ﬁelds Fp for all (or even for inﬁnitely many) primes p?

Equally interestingly, can we ﬁnd an explicit family of polynomials that is VNP-intermediate

in characteristic zero?

A related question is whether there are any polynomials deﬁned over the integers, that
are VNP-intermediate over Fq (for some ﬁxed q) but that are monotone p-projections of the
permanent.

Can we show that the remaining intermediate polynomials are also not polynomial-sized
monotone projections of the permanent? Do such results have any interesting consequences,
say, improved circuit lower bounds?

References

[1] Noga Alon and Ravi B. Boppana. The monotone circuit complexity of Boolean functions. Combinatorica,

7(1):1–22, 1987.

[2] David Avis and Hans Raj Tiwary. On the extension complexity of combinatorial polytopes.

In Automata,

Languages, and Programming - 40th International Colloquium, ICALP Part I, pages 57–68, 2013.

[3] Walter Baur and Volker Strassen. The complexity of partial derivatives. Theoretical Computer Science, 22(3):317

– 330, 1983.

[4] P. B¨urgisser. Completeness and Reduction in Algebraic Complexity Theory, volume 7 of Algorithms and Com-

putation in Mathematics. Springer, 2000.

[5] Peter B¨urgisser. On the structure of Valiant’s complexity classes. Discrete Mathematics & Theoretical Computer

Science, 3(3):73–94, 1999.

[6] Peter B¨urgisser. Cook’s versus Valiant’s hypothesis. Theoretical Computer Science, 235(1):71–88, 2000.
[7] Florent Capelli, Arnaud Durand, and Stefan Mengel. The arithmetic complexity of tensor contractions. In

Symposium on Theoretical Aspects of Computer Science STACS, volume 20 of LIPIcs, pages 365–376, 2013.

[8] Marek Cygan, Fedor V. Fomin, Lukasz Kowalik, Daniel Lokshtanov, D´aniel Marx, Marcin Pilipczuk, Michal

Pilipczuk, and Saket Saurabh. Parameterized Algorithms. Springer, 2015.

[9] Nicolas de Rugy-Altherre. A dichotomy theorem for homomorphism polynomials. In Mathematical Foundations

of Computer Science 2012, volume 7464 of LNCS, pages 308–322. Springer Berlin Heidelberg, 2012.

[10] Josep D´ıaz, Maria J. Serna, and Dimitrios M. Thilikos. Counting h-colorings of partial k-trees. Theoretical

Computer Science, 281(1-2):291–309, 2002.

[11] Arnaud Durand, Meena Mahajan, Guillaume Malod, Nicolas de Rugy-Altherre, and Nitin Saurabh. Homo-
morphism polynomials complete for VP. In 34th Foundation of Software Technology and Theoretical Computer
Science Conference, FSTTCS, pages 493–504, 2014.

20

[12] Jack Edmonds. Paths, trees, and ﬂowers. Canadian Journal of Mathematics, 17:449–467, 1965.
[13] Samuel Fiorini, Serge Massar, Sebastian Pokutta, Hans Raj Tiwary, and Ronald de Wolf. Exponential lower

bounds for polytopes in combinatorial optimization. J. ACM, 62(2):17, 2015.

[14] M. R. Garey and David S. Johnson. Computers and Intractability: A Guide to the Theory of NP-Completeness.

W. H. Freeman, 1979.

[15] Joshua A. Grochow. Monotone projection lower bounds from extended formulation lower bounds.

arXiv:1510.08417 [cs.CC], 2015.

[16] Pavol Hell and Jaroslav Neˇsetˇril. Graphs and homomorphisms. Oxford lecture series in mathematics and its

applications. Oxford University Press, 2004.

[17] Mark Jerrum and Marc Snir. Some exact complexity results for straight-line computations over semirings. J.

ACM, 29(3):874–897, 1982.

[18] Stasys

Jukna.

Why

is

Hamilton

Cycle

so

diﬀerent

from

Permanent?

http://cstheory.stackexchange.com/questions/27496/why-is-hamiltonian-cycle-so-diﬀerent-from-permanent,
2014.

[19] Richard M Karp and Richard Lipton. Turing machines that take advice. L’enseignement math´ematique,

28(2):191–209, 1982.

[20] Richard E. Ladner. On the structure of polynomial time reducibility. J. ACM, 22(1):155–171, 1975.
[21] Guillaume Malod and Natacha Portier. Characterizing Valiant’s algebraic complexity classes. Journal of

Complexity, 24(1):16–38, 2008.

[22] Stefan Mengel. Characterizing arithmetic circuit classes by constraint satisfaction problems.

In Automata,

Languages and Programming, volume 6755 of LNCS, pages 700–711. Springer Berlin Heidelberg, 2011.

[23] Ran Raz. Elusive functions and lower bounds for arithmetic circuits. Theory of Computing, 6:135–177, 2010.
[24] A. A. Razborov. Lower bounds on the monotone complexity of some Boolean functions. Dokl. Akad. Nauk

SSSR, 281(4):798–801, 1985.

[25] A.A. Razborov. Lower bounds on monotone complexity of the logical permanent. Mathematical notes of the

Academy of Sciences of the USSR, 37(6):485–493, 1985.

[26] Thomas Rothvoß. The matching polytope has exponential extension complexity. In Symposium on Theory of

Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014, pages 263–272, 2014.

[27] Janos Simon. On the diﬀerence between one and many (preliminary version). In Automata, Languages and
Programming, Fourth Colloquium, University of Turku, Finland, July 18-22, 1977, Proceedings, pages 480–491,
1977.

[28] Leslie G. Valiant. Completeness classes in algebra.

In Symposium on Theory of Computing STOC, pages

249–261, 1979.

[29] Leslie G. Valiant, Sven Skyum, S. Berkowitz, and Charles Rackoﬀ. Fast parallel computation of polynomials

using few processors. SIAM Journal on Computing, 12(4):641–644, 1983.

21

