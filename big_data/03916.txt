6
1
0
2

 
r
a

 

M
5
1

 
 
]

Y
S
.
s
c
[
 
 

2
v
6
1
9
3
0

.

3
0
6
1
:
v
i
X
r
a

Robust Supervisors for Intersection
Collision Avoidance in the Presence of
Uncontrolled Vehicles

Journal Title
XX(X):1–21
c(cid:13)The Author(s) 2016
Reprints and permission:
sagepub.co.uk/journalsPermissions.nav
DOI: 10.1177/ToBeAssigned
www.sagepub.com/

Heejin Ahn1, Andrea Rizzi2, Alessandro Colombo3, and Domitilla Del Vecchio1

Abstract
We present the design and validation of a centralized controller, called a supervisor, for collision avoidance of multiple
human-driven vehicles at a road intersection, considering measurement errors, unmodeled dynamics, and uncontrolled
vehicles. We design the supervisor to be least restrictive, that is, to minimize its interferences with human drivers.
This performance metric is given a precise mathematical form by splitting the design process into two subproblems:
veriﬁcation problem and supervisor-design problem. The veriﬁcation problem determines whether an input signal
exists that makes controlled vehicles avoid collisions at all future times. The supervisor is designed such that if the
veriﬁcation problem returns yes, it allows the drivers’ desired inputs; otherwise, it overrides controlled vehicles to
prevent collisions. As a result, we propose exact and efﬁcient supervisors. The exact supervisor solves the veriﬁcation
problem exactly but with combinatorial complexity. In contrast, the efﬁcient supervisor solves the veriﬁcation problem
within a quantiﬁed approximation bound in polynomially bounded time with the number of controlled vehicles. We
validate the performances of both supervisors through simulation and experimental testing.

1 Introduction

Autonomous robots have drawn attention in various
applications, such as exploring unknown environment
(Maimone et al. (2007)), moving materials in warehouses
(Wurman et al. (2008)), and collecting data on ocean
conditions (Smith et al. (2010)). Recently, there has been
extensive research on autonomous vehicles from academic,
industrial, and governmental sectors for the purpose of
reducing the number of trafﬁc accidents. Research has
focused on developing fully autonomous vehicles as well
as improving safety of human-driven vehicles by means of
newly available automation, sensing, and communication
capabilities. A major obstacle to the development of
collision avoidance architecture for large trafﬁc networks is
computational complexity.

In general, there have been several approaches to reduce
computational complexity in collision avoidance for multiple
vehicles. In a decentralized framework, each vehicle makes
its own decision to avoid collisions with its neighboring
vehicles, thereby dividing a large problem into smaller
local problems. To design a decentralized control law,
Hoffmann and Tomlin (2008) and Gillula et al. (2011) used
reachability analysis for hybrid systems, and Mastellone et al.
(2008) deﬁned a potential function. While computationally
efﬁcient, this framework is usually more conservative
and unable to prevent a deadlock, where no further

Prepared using sagej.cls [Version: 2015/06/09 v1.01]

control input exists to terminate processes (Cassandras
and Lafortune (2008)). A centralized framework considers
a whole system and thus can be less conservative, but
computationally demanding. Collision avoidance problems
were formulated into mixed integer linear programming
(MILP) by assuming discrete-time linear vehicle dynamic
models (Richards et al. (2002); Borrelli et al. (2006)) and
considering geometric construction of collisions with vehicle
models of instantaneous speed or angle changes (Pallottino
et al. (2002); Alonso-Ayuso et al. (2011)). These MILP
formulations are then solved by commercially available
software. In this paper, we present a centralized controller,
in which the collision avoidance problem is translated
into a scheduling problem and then solved by solving this

1Department of Mechanical Engineering, Massachusetts Institute of
Technology, Cambridge, MA, USA
2Tri-Institutional Program in Computational Biology and Medicine, Weill
Cornell Medical College, New York, NY, USA
3 Dipartimento di Elettronica Informazione e Bioingegneria, Politecnico
di Milano, Milano, Italy

Corresponding author:
Heejin Ahn, Department of Mechanical Engineering, Massachusetts
Institute of Technology, 77 Massachusetts Avenue, Cambridge, MA
02139, USA.
Email: hjahn@mit.edu

2

Journal Title XX(X)

scheduling problem. Moreover, we provide an approximate
solution of this problem.

In collision avoidance problems at road intersections, the
complexity can be mitigated to some extent by exploiting
the fact that vehicles follow predeﬁned paths, and side-
impacts can be avoided by approximately scheduling
their time of occupancy of the shared intersection (Peng
and Akella (2005a,b)). Based on this concept, several
autonomous intersection management schemes have been
studied. Kowshik et al. (2011) proposed a hybrid architecture
comprising an interplay between centralized coordination
and distributed agents. Centralized coordination assigns time
slots to agents, and distributed agents determine if they
can cross an intersection within allocated time slots while
avoiding rear-end collisions. Wu et al. (2012) employed
an ant colony algorithm as an approximate solution for
ﬁnding an optimal sequences of vehicles to improve trafﬁc
efﬁciency. Collision avoidance problems were formulated
into nonlinear constrained optimization to eliminate overlaps
of given trajectories inside an intersection (Lee and Park
(2012)) and to minimize the risk of collision (Kamal et al.
(2014)). These works consider fully autonomous vehicles
and can solve collision avoidance problems by ﬁnding one
safe input. However, when human operators drive vehicles,
a controller needs to be least-restrictive, that is, override
human drivers only when they can cause a collision.

To ensure least

restrictiveness, all possible inputs
must be taken into account, usually at expense of
computational cost. Moreover, this exhaustive evaluation
must be done frequently because controllers must keep
monitoring vehicles’ safety and intervene only when
drivers are unable to prevent collisions. In Hafner and
Del Vecchio (2011); Hafner et al. (2013), a safety control
was designed for two vehicles. Their controller was validated
in laboratory experiments (Hafner and Del Vecchio (2011))
and ﬁeld experiments (Hafner et al. (2013)). Colombo
and Del Vecchio (2012) translated a collision detection
problem to a scheduling problem and employed a scheduling
algorithm to design a safety control for multiple vehicles.
Rear-end collisions as well as intersection collisions were
considered in Colombo and Del Vecchio (2014).

In this paper, we propose a least-restrictive controller,
called a supervisor, that prevents intersection collisions
among human-driven vehicles. Our work extends the result
of Colombo and Del Vecchio (2012) in that 1) we consider
sources of uncertainty,
including measurement errors,
unmodeled dynamics, and uncontrolled vehicles, and 2) we
perform a lab-based experiment to validate the supervisor
in a setting subject to many sources of uncertainty. Here,
controlled vehicles communicate with and are controlled by
the supervisor, whereas uncontrolled vehicles are not. The
inclusion of uncontrolled vehicles accounts for a realistic

mixed-trafﬁc scenario where unequipped vehicles still travel
on roads.

To design a supervisor, we formulate two problems:
veriﬁcation problem and supervisor-design problem. The
veriﬁcation problem determines the existence of an input
signal that makes controlled vehicles avoid all future
collisions. We prove that this problem is equivalent to
an Inserted Idle-Time (IIT) scheduling problem, where
an inserted idle-time represents a set of time intervals
during which uncontrolled vehicles can occupy the
intersection. This formulation was introduced in Ahn et al.
(2014) to account for uncontrolled vehicles under perfect
measurement and dynamic models. The supervisor is
designed to override the drivers of controlled vehicles only
when the veriﬁcation problem determines that there will be
no input signal to avoid collisions.

In order to study the trade-off between exactness and
computational efﬁciency, we propose exact and efﬁcient
supervisors. The exact supervisor solves the veriﬁcation
problem exactly, and thus, overrides drivers only when
strictly necessary. However, since the veriﬁcation problem
has combinatorial complexity, this supervisor is not scalable
with the number of controlled vehicles. To improve
the computational efﬁciency, the efﬁcient supervisor is
designed to solve the veriﬁcation problem within a
quantiﬁed approximation bound in polynomially bounded
time. We validate the supervisors by performing computer
simulations and lab-based experimental testing. Some of
these experimental results were presented in Ahn et al.
(2015).

This paper is organized as follows. In Section 2, we deﬁne
an intersection model and a vehicle dynamic model. In
Section 3, we formulate two problems: veriﬁcation problem
and supervisor-design problem, which are solved exactly in
Section 4 and approximately in Section 5. The simulation
results are given in Section 6, and the experimental results
in Section 7.

2 System Deﬁnition
In this section, we introduce an intersection model and the
vehicle dynamics.

2.1 Intersection model
Consider n human-driven vehicles approaching an
intersection along n different paths. As shown in Figure
1, the intersection is modeled as an area containing the
points at which these paths intersect. An open interval
(αi, βi) ⊂ R denotes the location of this conﬂict area on
the longitudinal path of vehicle i. Among n vehicles,
nc vehicles are communicating with a supervisor, which
takes control of these vehicles when potential crashes are
detected and returns control back to the drivers when there

Prepared using sagej.cls

Supervisors for Intersection Collision Avoidance

3

γ(·) if wγ(t) ≤ w(cid:48)

j(·) if uj(t) ≤ u(cid:48)
y,i(t) and dv,i(t) ≤ d(cid:48)

Let uj(·) ∈ Uj and wγ(·) ∈ Wγ denote an input signal
to controlled vehicle j ∈ C and a driver-input signal
to uncontrolled vehicle γ ∈ ¯C, respectively. Let di(·) =
(dy,i(·), dv,i(·)) ∈ Di denote a disturbance signal of vehicle
i ∈ C ∪ ¯C. We say uj(·) ≤ u(cid:48)
j(t) for all t.
Similarly, wγ(·) ≤ w(cid:48)
γ(t) for all t, and
i(·) if dy,i(t) ≤ d(cid:48)
di(·) ≤ d(cid:48)
v,i(t) for
all t.
Let xj(t, uj(·), dj(·), xj(0)) denote the state of controlled
vehicle j at time t with an input signal uj(·) and a
disturbance signal dj(·) starting at an initial state xj(0).
Similarly, let xγ(t, wγ(·), dγ(·), xγ(0)) denote the state of
uncontrolled vehicle γ at time t with a driver-input signal
wγ(·) and a disturbance signal dγ(·) starting at xγ(0).
Unless the input signals and initial state are important, we
write xi(t) and xγ(t). We say xi(t) ≤ x(cid:48)
i(t)
and vi(t) ≤ v(cid:48)
i(t) for all t for i ∈ C ∪ ¯C and make the
following assumptions.
Assumption 1. The functions Fj and Fγ in (1) are order-
preserving. That is, if uj(·) ≤ u(cid:48)

i(t) if yi(t) ≤ y(cid:48)

j(·), we have

xj(t, uj(·), dj(·), xj(0)) ≤ xj(t, u(cid:48)

j(·), dj(·), xj(0)).

Similarly, if dj(·) ≤ d(cid:48)

j(·), we have

xj(t, uj(·), dj(·), xj(0)) ≤ xj(t, uj(·), d(cid:48)

j(·), xj(0)).

Furthermore, if xj(0) ≤ x(cid:48)

j(0), we have

xj(t, uj(·), dj(·), xj(0)) ≤ xj(t, uj(·), dj(·), x(cid:48)

j(0)).

the

The same relations hold for the state of uncontrolled vehicle
γ.
Assumption 2. For all
t. Thus,
outputs
yγ(t, wγ(·), dγ(·), xγ(0)) are non-decreasing in t.
Assumption 3. For all j ∈ C, xj(t, uj(·), dj(·), xj(0)) is
continuously dependent on uj(·) ∈ Uj, and the input signal
space Uj is path-connected.

i ∈ C ∪ ¯C,
yj(t, uj(·), dj(·), xj(0))

˙yi(t) ≥ 0 for all
and

Let x(t, u(·), w(·), d(·), x(0)) denote the aggregate state
with u(·) ∈ U, w(·) ∈ W, and d(·) ∈ D. This can also be
written as x(t) if the other arguments are not important.

Notice that the vehicle dynamics (1) are subject to
uncertainty originated from disturbances dj and dγ and
an unknown driver-input wγ. In addition to these, we
consider a measurement noise δi := (δy,i, δv,i) for i ∈ C ∪
¯C, where δy,i ∈ R and δv,i ∈ R are noises on the position
measurement ym,i(t) and the speed measurement vm,i(t)
at some time t, respectively. Then, the actual state xi(t) =
(yi(t), vi(t)) satisﬁes the following equation:

yi(t) = ym,i(t) + δy,i,

(2)
Let xm,i(t) = (ym,i(t), vm,i(t)) denote the state measure-
ment. Then, (2) can be rewritten as xi(t) = xm,i(t) + δi.
We make an assumption as follows.

vi(t) = vm,i(t) + δv,i.

Figure 1. Road intersection (left) and its simpliﬁed model
(right). We assume that the vehicles follow the prescribed paths,
which intersect at one point. An intersection is modeled as an
area containing this point (the shaded area), and its location is
denoted by an open interval (αi, βi) along the path of vehicle i.

is no more threat. The other n¯c = n − nc vehicles are
not communicating with, and can never be controlled by
the supervisor. The supervisor however can measure their
positions and speeds and use these measurements to predict
their possible future behaviors. We deﬁne a controlled set
C as a set of controlled vehicles and an uncontrolled set ¯C
as a set of uncontrolled vehicles. For notational simplicity,
we number the vehicles such that C = {1, 2, . . . , nc} and
¯C = {nc + 1, nc + 2, . . . , n}.

2.2 Vehicle model
To describe the longitudinal dynamics of vehicle i ∈
C ∪ ¯C, we introduce a state xi(t) = (yi(t), vi(t)) ∈ Xi ⊂
R2, where yi(t) ∈ Yi ⊆ R and vi(t) ∈ [vi,min, vi,max] ⊂
R are the position and the speed along the longitudinal
path. Let di(t) = (dy,i(t), dv,i(t)) ∈ R2 denote a distur-
bance, where dy,i(t) ∈ [dy,i,min, dy,i,max] and dv,i(t) ∈
[dv,i,min, dv,i,max] account for unmodeled dynamics of
yi(t) and vi(t), respectively. The longitudinal dynamics of
controlled vehicle j ∈ C and uncontrolled vehicle γ ∈ ¯C are
modeled as

˙xj = Fj(xj, uj, dj),

˙xγ = Fγ(xγ, wγ, dγ),

(1)
where uj ∈ Uj := [uj,min, uj,max] ⊂ R is a throttle or
brake input to controlled vehicle j applied by a supervisor,
and wγ ∈ [wγ,min, wγ,max] ⊂ R is a driver-input
to
uncontrolled vehicle γ.

The parallel composition of (1) is denoted as follows:

˙x = F(x, u, w, d),

x = (x1, . . . , xnc, xnc+1, . . . , xn) ∈ X,

where
u =
(u1, u2, . . . , unc) ∈ U,
w = (wnc+1, wnc+2, . . . , wn),
and d = (d1, . . . , dnc , dnc+1, . . . , dn). The output of
the system is the position of all vehicles, denoted by
y = (y1, . . . , ync , ync+1, . . . , yn) ∈ Y.

Prepared using sagej.cls

3112234

Journal Title XX(X)

Assumption 4. The measurement noise is bounded, that is,
δi ∈ [δi,min, δi,max].

The aggregate state measurement is denoted by xm(t),
and then, x(t) = xm(t) + δ, where δ ∈ ∆ := [δmin, δmax]
is the aggregated measurement noise.

2.3 The state estimation
We deﬁne a set of states [xa(t), xb(t)], called the state
estimation, that provides a lower and upper bound of the
exact state, that is, x(t) ∈ [xa(t), xb(t)] for all t. At t = 0,
the state estimation is deﬁned as xa(0) = xm(0) + δmin
and xb(0) = xm(0) + δmax, so that x(0) ∈ [xa(0), xb(0)]
because of (2) and Assumption 4. Given the intial state
estimation [xa(0), xb(0)] and an input signal u(·), the state
estimation [xa(t, u(·), xa(0)), xb(t, u(·), xb(0))] at time t
is deﬁned as follows: for j ∈ C,
j (t, uj(·), xa
xa
min

xj(t, uj(·), dj(·), xj(0)),

j (0)) :=

j(t, uj(·), xb
xb

j(0)) :=

dj (·)∈Dj ,xj (0)
∈[xa
j (0)]

j (0),xb

max

dj (·)∈Dj ,xj (0)
∈[xa
j (0)]

j (0),xb

xj(t, uj(·), dj(·), xj(0)).

(3)

For γ ∈ ¯C,
xa
γ(t) :=

xb
γ(t) :=

min

wγ (·)∈Wγ ,dγ (·)∈Dγ ,
xγ (0)∈[xa
γ (0)]

γ (0),xb

max

wγ (·)∈Wγ ,dγ (·)∈Dγ ,
xγ (0)∈[xa
γ (0)]

γ (0),xb

xγ(t, wγ(·), dγ(·), xγ(0)),

xγ(t, wγ(·), dγ(·), xγ(0)).

(4)
by
[xa(t), xb(t)]

denoted

state

The
is
[xa(t, u(·), xa(0)), xb(t, u(·), xb(0))]
or
if the omitted arguments are not necessary.

estimation

By these deﬁnitions, the state estimation guarantees that
given an initial state estimation [xa(0), xb(0)] and an input
signal u(·),

x(t, u(·),w(·), d(·), x(0))

∈ [xa(t, u(·), xa(0)), xb(t, u(·), xb(0))],

(5)

position

the
deﬁne

Notice that xa

j(t, uj(·), xb

for all t for any w(·) ∈ W and d(·) ∈ D for any x(0) ∈
[xa(0), xb(0)].

j (t, uj(·), xa
inequalities
the

j (0)) and xb
j(0))
satisfy
1. We
in Assumption
can
by
estimation,
[ya(t, u(·), xa(0)), yb(t, u(·), xb(0)))]
letting
i (t),·) for all i ∈ C ∪ ¯C.
xa
i (t) = (ya
Throughout this paper, we use ‘·’ in a vector if specifying
the entry is not important. The position estimation also
inherits the order-preserving property from y(t). Later in
Section 4.2, this estimation can be updated using the state
measurement.

i (t),·) and xb

denoted
by

i (t) = (yb

Prepared using sagej.cls

3 Problem Statement
Let us deﬁne an intersection collision. Since an intersection
is modeled as a single conﬂict area, we consider a collision
occurs if at least two vehicles are simultaneously inside
the intersection. The output conﬁgurations corresponding
to collisions belong to the Bad set, denoted by B ⊂ Y . The
Bad set is deﬁned as follows:
B := {y ∈ Y : yi ∈ (αi, βi) and yj ∈ (αj, βj)

for some i (cid:54)= j such that i ∈ C ∪ ¯C and j ∈ C}.

Throughout this paper, we assume that uncontrolled vehicles
do not crash among themselves. This assumption enables
us to focus on preventing collisions in which at least one
controlled vehicle is involved.

A supervisor runs in discrete time with a time step
τ. At
time kτ where k is a nonnegative integer, a
desire ∈ U and a state xm(kτ ) ∈ X are
desired input uk
measured. Then, a state estimation [xa(kτ ), xb(kτ )] is
updated to satisfy x(kτ ) ∈ [xa(kτ ), xb(kτ )] ⊆ [xm(kτ ) +
δmin, xm(kτ ) + δmax]. The desired input uk
desire is a vector
of current inputs of controlled vehicles’ drivers at time kτ.
As illustrated in Figure 2, we deﬁne desired input signals
desire(·) ∈ U on time [kτ, (k + 1)τ ) and uk,∞
desire(·) ∈ U
uk
on time [kτ,∞) such that

desire(t) = uk

desire(t) = uk,∞
uk
Also, we deﬁne a safe input signal uk,∞
such that

desire for t ∈ [kτ, (k + 1)τ ).
(6)
saf e(·) on time [kτ,∞)

(7)

Let uk

The supervisor s([xa(kτ ), xb(kτ )], uk

∀w(·) ∈ W, d(·) ∈ D, x(kτ ) ∈ [xa(kτ ), xb(kτ )],
y(t, uk,∞
saf e(·) be uk,∞

saf e(·), w(·), d(·), x(kτ )) /∈ B for all t.

saf e(·) restricted to time [kτ, (k + 1)τ ).
desire) is designed
according to the following problem, which is illustrated in
Figure 3.
Problem 1. (Supervisor-design). Design a supervisor
desire) such that for any w(·), d(·),
s([xa(kτ ), xb(kτ )], uk
and x(kτ ) ∈ [xa(kτ ), xb(kτ )], it returns

uk

desire(·)
saf e(·)
uk

desire(·) : for all t ≥ 0
desire(·), w(·), d(·), x(kτ )) /∈ B

if ∃uk,∞
y(t, uk,∞
otherwise,

and it is non-blocking, that is, if s([xa((k − 1)τ ), xb((k −
desire ∈ U, we have
1)τ )], uk−1
s([xa(kτ ), xb(kτ )], uk

desire) (cid:54)= ∅, then for any uk

desire) (cid:54)= ∅.

The supervisor in Problem 1 is least restrictive in the sense
that overrides are activated only when the desired input of
controlled vehicles’ drivers would lead to collisions at some

Supervisors for Intersection Collision Avoidance

5

Figure 2. uk,∞
input signal that makes the system avoid the Bad set as in (7).

desire(·) is an artiﬁcially constructed signal that equals to uk

desire for time [kτ, (k + 1)τ ) as in (6). uk,∞

saf e(·) is an safe

Figure 3. Illustration of the supervisor. At time kτ, the supervisor takes the desired input of controlled vehicles’ drivers uk
desire and
desire(·) that prevents all the vehicles from entering the Bad
the state estimation [xa(kτ ), xb(kτ )]. Depending on the existence of uk,∞
set for all t for any w(·) ∈ W, d(·) ∈ D, and x(kτ ) ∈ [xa(kτ ), xb(kτ )], the supervisor either allows the drivers to travel with their
desired input uk

desire(·) or overrides them with the safe input uk

saf e(·).

future times. To distinguish between safe and unsafe inputs,
the supervisor needs to verify that the state reached using
the desired input is compatible with a safe evolution of the
system. This introduces the following problem.
Problem 2. (Veriﬁcation). Given an initial state estimation
[xa(0), xb(0)], determine if there exists an input signal u(·)
that guarantees y(t, u(·), w(·), d(·), x(0)) /∈ B for all t ≥ 0
for any w(·) ∈ W, d(·) ∈ D, and x(0) ∈ [xa(0), xb(0)].

By solving Problem 2, the supervisor determines if an
override is necessary. If the desired input leads to a set
of states at which Problem 2 returns no, the supervisor
overrides controlled vehicles with a safe input signal. The
two above problems are solved exactly in the next section,
and approximately in Section 5.

4 Exact solutions
In this section, we provide the solutions of the veriﬁcation
problem (Problem 2) and the supervisor-design problem
(Problem 1). To solve Problem 2, we formulate an
Inserted Idle-Time scheduling problem, which is solved
straightforwardly, and prove that this problem is equivalent
to Problem 2. We then propose a solution to Problem 1.

4.1 Inserted Idle-Time scheduling problem
Problem 2 can be translated into a scheduling problem,
considering the intersection as a resource that all vehicles
must share. The schedule represents a sequence of the times

Prepared using sagej.cls

at which each controlled vehicle enters an intersection, and
the idle-times represent the sets of times during which an
intersection is potentially occupied by uncontrolled vehicles.
This analogy is characterized mathematically using the
concept of decision problem equivalence.
Deﬁnition 1. (Cormen et al. (2009)) Consider two decision
problems A and B. The input to a particular problem is
called an instance of that problem. Then, A is reducible
to B if there is a procedure that transforms any instance α
of A into some instance β of B in polynomial time, and
the answer for α is “yes”, denoted by α ∈ A, if and only if
the answer for β is “yes”, denoted by β ∈ B. We say A is
equivalent to B if and only if A is reducible to B and B is
reducible to A.

An

instance

I

of

Problem

2

is
S :=

described
where
(F, X, Y,U,W,D,C, ¯C, α1, . . . , αn, β1, . . . , βn).

([xa(0), xb(0)], S)

by

To formulate the IIT scheduling problem, we deﬁne

scheduling parameters.
Deﬁnition
2. Given
estimation
[xa(0), xb(0)],
release times Rj, deadlines Dj, and
process times Pj(Tj) are deﬁned for controlled vehicles.
For j ∈ C, if yb

initial

state

j (0) < αj,

an

Rj := min

uj (·)∈Uj
Dj := max
uj (·)∈Uj

{t ≥ 0 : yb
{t ≥ 0 : yb

j (t, uj(·), xb
j (t, uj(·), xb

j(0)) = αj},
j(0)) = αj}.

yesnosupervisorfor any                                and                                      ?Does                 exist such that for all6

Journal Title XX(X)

Figure 4. Scheduling parameters in Deﬁnition 2. Referring to Figure 1, (αj, βj) is the location of an intersection along the route of
vehicle j.

Given a real number Tj > 0,

for all j ∈ C and γ ∈ ¯C,

Pj(Tj) := min

{t − Tj ≥ 0 :

uj (·)∈Uj
i (t, uj(·), xa
ya

j (0)) = βj
with constraint yb

j (0) ≥ αj,

j (Tj, uj(·), xb

j(0)) = αj}.
then Rj = 0, Dj = 0, and Pj(Tj) =
If yb
j (0) ≥ βj,
minuj (·)∈Uj{t : ya
j (t, uj(·), xa
then set Rj = 0, Dj = 0, and Pj(Tj) = 0. If the constraint
is not satisﬁed, set Pj(Tj) = ∞.
For γ ∈ ¯C, if yb

Idle-times ( ¯Rγ, ¯Pγ) are deﬁned for uncontrolled vehicles.

j (0)) = βj}. If ya

γ(0) < αγ,
¯Rγ := {t ≥ 0 : yb
¯Pγ := {t ≥ 0 : ya

γ(t) = αγ},
γ(t) = βγ}.
γ(0) ≥ αγ, set ¯Rγ = 0 and ¯Pγ = {t : ya

γ(t) = βγ}. If

If yb
γ(0) ≥ βγ, set ¯Rγ = 0 and ¯Pγ = 0.
ya
In this deﬁnition, release time Rj is the earliest that
controlled vehicle j can enter an intersection while deadline
Dj is the latest. Given that controlled vehicle j enters the
intersection no earlier than time Tj, process time Pj(Tj) is
the earliest that it can cross the intersection. Uncontrolled
vehicle γ enters and exits the intersection within the idle-
time ( ¯Rγ, ¯Pγ) regardless of its driver-input and disturbance
signals. These parameters are illustrated in Figure 4.

The Inserted Idle-time (IIT) scheduling problem is

formulated as follows.
Problem 3. (IIT scheduling). Given an initial state
estimation [xa(0), xb(0)], determine whether there exists a
schedule T = (T1, . . . , Tnc) ∈ Rnc
+ such that for all j ∈ C,
Rj ≤ Tj ≤ Dj,
(8)

for all i (cid:54)= j ∈ C,

(Ti, Ti + Pi(Ti)) ∩ (Tj, Tj + Pj(Tj)) = ∅,

(9)

Prepared using sagej.cls

(Tj, Tj + Pj(Tj)) ∩ ( ¯Rγ, ¯Pγ) = ∅.

(10)

j (Tj, uj(·), xb

j(0)) = αj and ya

Notice that Tj and Pj(Tj) are deﬁned such that
for some uj(·), yb
j (Tj +
Pj(Tj), uj(·), xa
j (0)) = βj. Condition (8) represents the
constraint
induced on the schedule by the bounded
input signals. By condition (9), the times during which
controlled vehicles i and j occupy the intersection for any
disturbance do not overlap. This implies that a collision
between controlled vehicles i and j is averted. Similarly,
condition (10) implies that vehicle j does not occupy
the intersection during the idle-time, thereby preventing
a collision between controlled vehicle j and uncontrolled
vehicle γ. Thus, a schedule satisfying the above conditions is
related to an input signal that can prevent any future collision.
This is the essence of the proof of the following theorem.
Theorem 1. Problem 2 and Problem 3 are equivalent.

Proof. By Deﬁnition 1, we need to show two things:
Problem 2 is reducible to Problem 3, and Problem 3
is reducible to Problem 2. Notice that an instance I of
Problem 3 is also described by ([xa(0), xb(0)], S), which
is the same as an instance of Problem 2. Thus,
the
transformation between the instances of these problems takes
constant time. Now, the following relation is left to prove
the equivalence.

I ∈ Problem 2 ⇔ I ∈ Problem 3.

is

an

input

signal

(⇒) Given an initial state estimation [xa(0), xb(0)],
˜u(·) ∈ U
that
there
y(t, ˜u(·), w(·), d(·), x(0)) /∈ B for all t for any w(·) ∈ W
and d(·) ∈ D for any x(0) ∈ [xa(0), xb(0)].
Using ˜uj(·) for j ∈ C, which denotes the j-th element
of ˜u(·), let ˜Tj be the time at which yb
j(0)) = αj
j (0) ≥ αj, set ˜Tj = 0. This satisﬁes the
if yb
constraint of Pj( ˜Tj) in Deﬁnition 2. Let ˜Tj + ˜Pj( ˜Tj) be the

j (t, ˜uj(·), xb

j (0) < αj. If yb

such

timedistancetimedistanceSupervisors for Intersection Collision Avoidance

7

j (t, ˜uj(·), xa

j (t, ˜uj(·), xb

i (t, ˜ui(·), xa

j (0)) = βj. Set ˜Pj( ˜Tj) = 0 if

i (0)) ≥ βi. Because ya

time at which ya
j (0) ≥ βj.
ya
By the deﬁnitions of Rj and Dj, condition (8) is satisﬁed.
Suppose without loss of generality, ˜Ti ≤ ˜Tj. At t = ˜Tj,
j(0)) = αj. Since ˜ui(·) and ˜uj(·)
we have yb
guarantee that at most one vehicle is inside an intersection,
we must have ya
j (t) is
non-decreasing in time, ˜Ti + ˜Pi( ˜Ti) ≤ t. By the deﬁnition
of Pi( ˜Ti), we have ˜Ti + Pi( ˜Ti) ≤ ˜Ti + ˜Pi( ˜Ti) ≤ t = ˜Tj,
which concludes ( ˜Ti, ˜Ti + Pi( ˜Ti)) ∩ ( ˜Tj, ˜Tj + Pj( ˜Tj)) =
∅ (condition (9)).
to avoid the Bad set, vehicle γ ∈ ¯C is
inside an intersection during [ ˜Tj, ˜Tj + ˜P ( ˜Tj)] for
not
any wγ(·) ∈ Wγ, dγ(·) ∈ Dγ, and xγ(0) ∈ [xa
γ(0)].
γ( ¯Pγ) = βγ by Deﬁnition 2, we
Since yb
have ( ˜Tj, ˜Tj + ˜Pj( ˜Tj)) ∩ ( ¯Rγ, ¯Pγ) = ∅. By the deﬁnition
of Pj( ˜Tj), we have ( ˜Tj, ˜Tj + Pj( ˜Tj)) ⊂ ( ˜Tj, ˜Tj + ˜Pj( ˜Tj)).
Thus, ( ˜Tj, ˜Tj + Pj( ˜Tj)) ∩ ( ¯Rγ, ¯Pγ) = ∅. (condition (10)).
This proves that there exists the schedule ˜T that satisﬁes

γ( ¯Rγ) = αγ and ya

In order

γ(0), xb

j ( ˜Tj, ˜uj(·), xb

conditions (8), (9), and (10).
(⇐) Given an initial state estimation [xa(0), xb(0)], there
exists a schedule ˜T ∈ Rnc that satisﬁes the conditions of
Problem 3.

For j ∈ C, deﬁne ˜uj(·) such that yb

j (0) < αj. If yb

i (t, ˜ui(·), xa

j (0) ≥ αj and ya

j ( ˜Tj + Pj( ˜Tj), ˜uj(·), xa

j (0)) = βj.
j (t, uj(·), xa

j(0)) =
j (0) ≤ βj, deﬁne
αj if yb
˜uj(·) such that ya
If
j (0) > βj, we do not consider vehicle j because it has
ya
already crossed the intersection. Since ya
j (0))
depends continuously on uj(·) ∈ Uj and Uj
is path
connected by Assumption 3, condition (8) implies that such
an input signal exists, i.e., ˜uj(·) ∈ Uj.
Consider ˜ui(·) and ˜uj(·) for i (cid:54)= j ∈ C where ˜Ti ≤
˜Tj. Condition (9) says ˜Ti + Pi( ˜Ti) ≤ ˜Tj. At time t ∈
i (0)) ≥ βi and
[ ˜Ti + Pi( ˜Ti), ˜Tj], we have ya
j (t, ˜uj(·), xb
j(0)) ≤ αj. Thus, for any disturbance and
yb
initial condition, vehicle j enters the intersection after
vehicle i leaves it.

γ ∈ ¯C,
condition
˜Tj + Pj( ˜Tj) ≤ ¯Rγ.

j ∈ C
and
¯Pγ ≤ Tj or
j (t, ˜uj(·), xb
yb

implies
For
(10)
either
In the ﬁrst
case, at any time t ∈ [ ¯Pγ, Tj], we have ya
γ(t) ≥ βγ
j(0)) ≤ αj
any
for
and
so
wγ(·) ∈ Wγ, dγ(·) ∈ Dγ, xγ(0) ∈ [xa
and
for any dj(·) ∈ Dj, xj(0) ∈ [xa
j(0)], after vehicle
j (0), xb
γ exits the intersection, vehicle j enters it.
In the
second case, at any time t ∈ [ ˜Tj + Pj( ˜Tj), ¯Rγ], we have
j (t, ˜uj(·), xa
γ(t) ≤ αγ. This means
ya
after vehicle j exits the intersection for any dj(·) ∈ Dj
and xj(0) ∈ [xa
j(0)], vehicle γ enters it for any
wγ(·) ∈ Wγ, dγ(·) ∈ Dγ, and xγ(0) ∈ [xa
γ(0)].
input signal ˜u(·) which prevents entering the Bad set.

Therefore, the schedule ˜T ensures that there exists an

j (0)) ≥ βj and yb

that
γ(0), xb

j (0), xb

γ(0), xb

γ(0)]

Prepared using sagej.cls

We now provide an algorithm that solves Problem 3,
which, in turn, solves Problem 2 by Theorem 1. This
algorithm contains two procedures. The ﬁrst procedure,
SCHEDULING, generates a schedule T given a sequence
π such that Tπi ≤ Tπj if i < j, and evaluates whether T
satisﬁes conditions (8)-(10). Here, πi denotes the i-th entry
of π and Tπi the πi-entry of T. The second procedure,
EXACT, inspects all possible sequences until a sequence
with a feasible schedule is found. If a feasible schedule is
found, the answer of Problem 2 is yes, and otherwise, the
answer is no.
Algorithm 1 focuses on vehicles before an intersection.
The set of such vehicles is denoted by M := {j ∈
C : yb
j (0) < αj for j ∈
j (0) < αj}. For simplicity, let yb
{1, . . . ,|M|} and yb
j (0) ≥ αj for j ∈ {|M| + 1, . . . , nc}.
Let P be a set of all permutations of M. Its cardinality
is (|M|)! = 1 × 2 × . . . × |M|. Let π ∈ R|M| be a vector
in P. Let ¯π ∈ Rn¯c be a vector of γ ∈ ¯C in an increasing
order of ¯Rγ, that is, ¯R¯πj ≤ ¯R¯πj(cid:48) for j ≤ j(cid:48). Let π0,j and ¯πj
denote the j-th entry of π0 and ¯π, respectively.

Algorithm 1 Exact Solution of Problem 3
1: procedure SCHEDULING(π0, [xa(0), xb(0)], S)
2:

for all j ∈ C do calculate Rj, Dj
for all γ ∈ ¯C do calculate ¯Rγ, ¯Pγ

3:
4: M = {j ∈ C : yb
5:
6:
7:
8:
9:
10:

j (0) < αj} and ¯M = C \ M
Tj = 0 ∀ j ∈ ¯M and Pmax = maxj∈ ¯M Pj(Tj)
π = (π0,j : π0,j ∈ M for j = 1 to |π0|)
for i = 1 to |M| do
if i = 1 then Tπ1 = max(Rπ1, Pmax)
else if i ≥ 2 then

for j = 1 to n¯c do

Tπi = max(Rπi, Tπi−1 + Pπi−1(Tπi−1))
if Tπi ≥ ¯R¯πj then

Tπi = max(Tπi, ¯P¯πj )

else if Tπi + Pπi (Tπi) > ¯R¯πj then

Tπi = ¯P¯πj

11:
12:
13:
14:
15:

16:

22:
23:
24:

25:

if Tj ≤ Dj for all j ∈ C then return (T, yes)
return (∅, no)

17:
18: procedure EXACT([xa(0), xb(0)], S)
19:
20: M = {j ∈ C : yb
21:

if [ya(0), yb(0)] ∩ B (cid:54)= ∅ then return (∅, no)
j (0) < αj} and ¯M = C \ M

if |M| = 0 then return (∅, yes)
for all π ∈ P do

(T, ans) = SCHEDULING(π, [xa(0), xb(0)], S)
if ans = yes then return (T, yes)

return (∅, no)

Procedure SCHEDULING in Algorithm 1 works as follows.
In lines 2-3, the scheduling parameters in Deﬁnition 2 are

8

Journal Title XX(X)

Figure 5. Schematic of the supervisor at time kτ. Using the state measurement xm(kτ ) and the previous step’s state prediction
Xpred(uk−1
desired input uk
desire and returns either uk
answer is no, the state prediction Xpred(uk
non-blocking property of the supervisor. At each step, a safe input signal uk+1
stored for a possible use at the next step.

out (·)), the state estimation is corrected to [xa(kτ ), xb(kτ )]. The supervisor takes [xa(kτ ), xb(kτ )] and the current
saf e(·) depending on the answer of the veriﬁcation problem. When the
desire(·) or uk
saf e(·)) guarantees the existence of a feasible schedule T2, thereby ensuring the
saf e(·) is generated using a feasible schedule and

computed given an initial state estimation. In lines 4 and 5,
j (0) ≥ αj, Tj = 0 because Rj = Dj = 0 and Pmax is
if yb
the time at which all vehicles j ∈ ¯M exit the intersection.
The input argument π0 is the vector of the indexes of all
vehicles controlled by the supervisor. The assignment at
line 6 extracts from π0 the sub-vector π of vehicles which
have not yet reached the intersection. The schedule needs
only be computed for the sub-vector π.

In a given sequence π, vehicle πi−1 crosses the
intersection earlier than vehicle πi. Given this sequence π,
procedure SCHEDULING ﬁnds the earliest possible schedule.
In the for loop of lines 11-15, uncontrolled vehicle ¯πj is
considered. If line 12 is true, then line 13 ensures that
Tπi ≥ ¯P¯πj so that condition (10) is satisﬁed. Otherwise, if
line 14 is true, meaning that Tπi < ¯R¯πj < Tπi + Pπi(Tπi ),
then Tπi is delayed to ¯P¯πj in line 15 so that condition (10)
becomes satisﬁed. The schedule Tπi takes ¯P¯πj , which is the
earliest possible value. Otherwise, Tπi + Pπi(Tπi) ≤ ¯R¯πj
so that condition (10) is guaranteed. Lastly, in line 16, the
right inequality of condition (8) is checked. If line 16 is true,
this procedure returns a feasible schedule and answer yes. If
Tj > Dj for some j, since the schedule T is constructed so
that it is the earliest possible value, there cannot be another
schedule ˜T such that ˜Tj ≤ Dj. Thus, no feasible schedule
can be found in this sequence π, and the procedure returns
no.

Procedure EXACT in Algorithm 1 solves Problem 3 by
inspecting all permutations in P until a feasible schedule
is found as noted in lines 22-24. In line 19, if a given
initial position estimation is already inside the Bad set,
j (0) ≥ αj for all
the procedure returns no. In line 21, if yb
j ∈ C, then it returns yes since all controlled vehicles have
entered the intersection. If no feasible schedule is found after

evaluating all permutations in P, an empty set and answer
no are returned in line 25.

The running time of procedure EXACT is determined
by the for loops of lines 22-24. For the worst case, all
permutations in P must be evaluated. As the number of
controlled vehicles increases, the computation time increases
exponentially. Indeed, a scheduling problem is known
to be NP-hard (Colombo and Del Vecchio (2012)). To
avoid this computational complexity issue, we devise an
approximate algorithm to solve the IIT scheduling problem
with the guarantee of a quantiﬁed approximation bound. This
approximate algorithm is provided in Section 5.1.

4.2 Exact supervisor
In this section, we solve Problem 1 by providing an
algorithm implementing the exact supervisor.

The schematic of a supervisor at time kτ is illustrated in
Figure 5. The state prediction computed at the previous
out (·) is the
out (·)) is known, where uk−1
step Xpred(uk−1
output that the supervisor returns at the previous step,
out (·) for time
that is, controlled vehicles traveled with uk−1
[(k − 1)τ, kτ ). Also, the state measurement xm(kτ ) is
received. These state prediction and measurement are used
to update the state estimation [xa(kτ ), xb(kτ )]. This state
estimation and the desired input uk
desire are the inputs to
the supervisor and used to predict the state at the next
desire(·)). Given this state
time step, denoted by Xpred(uk
prediction, the veriﬁcation problem is solved. If the answer
is yes, the supervisor allows the controlled vehicles to
travel with the desired input for time [kτ, (k + 1)τ ). A
saf e(·) is generated using a feasible
safe input signal uk+1
schedule T1 and stored for a possible use at the next
saf e(·)
time step. If the answer is no, a safe input signal uk

Prepared using sagej.cls

supervisoryesnostoreCorrection ofstate estimation(eq. (12))VerificationSafe inputgenerator (eq. (13))State prediction using                (eqs. (9), (10))State predictionusing                  (eqs. (9), (10))Supervisors for Intersection Collision Avoidance

9

desire(·) or uk

stored at the previous step is used to override the controlled
vehicles. It will be proved in this section that the state
saf e(·)) always has a feasible schedule
prediction Xpred(uk
saf e(·)) ∈ Problem 2. A safe input
T2, that is, Xpred(uk
saf e(·) is generated using T2 and stored. The
signal uk+1
saf e(·), and the state
out(·) is either uk
output uk
out(·)) will be used at the next step to
prediction Xpred(uk
correct the state estimation with a new state measurement.
In the last section, we presented Algorithm 1 that
solves the veriﬁcation problem. This section describes
the remaining components: state prediction, correction of
the state estimation, and a safe input generator. Also, an
algorithm to implement the supervisor is presented with the
proof that this supervisor is the solution of Problem 1.

4.2.1 State prediction. Using the dynamic model (1),
this function predicts the state reached at the next time
step with a given input signal starting from a set of states.
Suppose that at time kτ, we have the state estimation
[xa(kτ ), xb(kτ )] and the input uk(·) ∈ U deﬁned on time
[kτ, (k + 1)τ ). The state prediction Xpred(uk(·)) =
[min Xpred(uk(·)), max Xpred(uk(·))] ⊂ X
is
the next
step.
a
time
i (·)) =
Its
set
by Xpred,i(uk
i (·)), max Xpred,i(uk
i (·))].
state
[min Xpred,i(uk
prediction is deﬁned as follows: for j ∈ C,

set of possible
is

states
at
denoted

The

i-th

min Xpred,j(uk

max Xpred,j(uk

j (·)) = min
dj (·)∈Dj
j (·)) = max
dj (·)∈Dj

xj(τ, uk

xj(τ, uk

j (·), dj(·), xa
j (·), dj(·), xb

j (kτ )),

j(kτ )).
(11)

For γ ∈ ¯C,

min Xpred,γ = min
wγ (·)∈Wγ ,
dγ (·)∈Dγ
max Xpred,γ = max
wγ (·)∈Wγ ,
dγ (·)∈Dγ

xγ(τ, wγ(·), dγ(·), xa

γ(kτ )),

xγ(τ, wγ(·), dγ(·), xb

γ(kτ )).

(12)
By deﬁnition, min Xpred(uk(·)) is the smallest state
propagated from xa(kτ ) for time τ with the input uk(·)
for any disturbance and any driver-input of uncontrolled
vehicles, and max Xpred(uk(·)) is the largest.
desire(·)), S) in Algorithm 1
determines the existence of an input signal uk+1,∞
(·)
that satisﬁes y(t, uk+1,∞
(·), w(·), d(·), x((k + 1)τ )) /∈ B
for all t for any w(·) and d(·) for any x((k + 1)τ ) ∈
Xpred(uk

desire). If we deﬁne uk,∞

Notice that EXACT(Xpred(uk

saf e

saf e

desire(·) as
for t ∈ [kτ, (k + 1)τ ),
for t ∈ [(k + 1)τ,∞),

(cid:40)

uk,∞
desire(t) =

desire

uk
uk+1,∞

saf e

(t)

Prepared using sagej.cls

then y(t, uk,∞
w(·) and d(·) for any x(kτ ) ∈ [xa(kτ ), xb(kτ )].

desire(·), w(·), d(·), x(kτ )) /∈ B for all t for any

4.2.2 Correction of the state estimation. Once a new
state measurement is received, this function restricts the state
estimation so that it is compatible with the state measurement
and the state prediction computed at the previous step.
out (·) at time (k − 1)τ.
Suppose the supervisor returns uk−1
Then, at time kτ, we have x(kτ ) ∈ Xpred(uk−1
out (·)) by
deﬁnitions (11) and (12). Also, a new state measurement
xm(kτ ) is received, which implies x(kτ ) ∈ [xm(kτ ) +
δmin, xm(kτ ) + δmax]. Thus, we make a correction of
the state estimation [xa(kτ ), xb(kτ )] at time kτ as the
intersection of these two intervals. That is,
xa(kτ ) = max(min Xpred(uk−1
xb(kτ ) = min(max Xpred(uk−1

out (·)), xm(kτ ) + δmin),
out (·)), xm(kτ ) + δmax).
(14)
this correction still guarantees x(kτ ) ∈
Notice that
[xa(kτ ), xb(kτ )]. The supervisor takes this corrected state
estimation as an input as shown in Figure 5.

4.2.3 Safe input generator. Given a feasible schedule,
this function generates a corresponding safe input signal.
This is possible because the existence of a feasible schedule
implies the existence of a safe input signal by Theorem 1.
We deﬁne a safe input generator σ(Xpred(uk(·)), T) to
compute uk+1,∞
(·), where T is the schedule returned by
EXACT(Xpred(uk(·)), S). For j ∈ C, if Tj > 0,

saf e

j (·)), Tj) := uk+1,∞

saf e,j (·)

σj(Xpred,j(uk
∈ {uj(·) ∈ Uj :

j (Tj + Pj(Tj), uj(·), min Xpred,j(uk
ya
j (Tj, uj(·), max Xpred,j(uk

and yb

j (·))) = βj
j (·))) = αj},
(15)

is

j (·)), Tj)
If Tj = 0,

where σj(Xpred,j(uk
j-th entry of
σ(Xpred(uk(·)), T).
saf e,j (t) =
t ∈ [(k + 1)τ,∞). The safe input signal
uj,max for
uk+1,∞
saf e,j (·) makes controlled vehicle j enter the intersection
no earlier that Tj and exit it no later than Tj + Pj(Tj).

then let uk+1,∞

the

If EXACT(Xpred(uk

desire), S) ﬁnds a feasible schedule
saf e(·),
T, the supervisor computes a safe input signal uk+1
which is uk+1,∞
(t) restricted to t ∈ [(k + 1)τ, (k + 2)τ ).
The supervisor stores this safe input signal for a possible use
at the next time step.

saf e

(13)

4.2.4 Solution of Problem 1 The supervisor is imple-
mented in procedure SUPERVISOR in Algorithm 2.

10

Journal Title XX(X)

4:

5:

for

and

desire)

[xa(t, uk
∅ then

desire(·)), T1)
(·) = σ(Xpred(uk
for

Algorithm 2 Implementation of the supervisor
1: procedure SUPERVISOR([xa(kτ ), xb(kτ )], uk
desire(·)), S)
(T1, ans) = EXACT(Xpred(uk
2:
t ∈ [0, τ ), B ∩
if
all
ans = yes
3:
desire(·), xa(kτ )), xb(t, uk
desire(·), xb(kτ ))] =
uk+1,∞
saf e
saf e(·) = uk+1,∞
uk+1
desire(·)
return uk
saf e(·)), S)
(T2,·) = EXACT(Xpred(uk
uk+1,∞
saf e(·)), T2)
(·) = σ(Xpred(uk
saf e
saf e(·) = uk+1,∞
uk+1
for
return uk

t ∈ [(k + 1)τ, (k +

t ∈ [(k + 1)τ, (k +

6:
7:
8:

else

2)τ )

2)τ )

saf e

saf e

(t)

(t)

10:

11:

9:

saf e(·)

desire) (cid:54)= ∅.

To initiate the procedure, it is assumed that initial
state estimation [xa(0), xb(0)] and initial desired input
desire do not cause collisions at any future time. That
u0
desire), S) must return yes so that
is, EXACT(Xpred(u0
SUPERVISOR([xa(0), xb(0)], u0
Theorem 2. Procedure SUPERVISOR in Algorithm 2
implements the supervisor s designed in Problem 1.
desire(·) in line 6
Proof. Procedure SUPERVISOR returns uk
if ans1 is yes. This implies that there exists uk+1,∞
(·),
which in turn, implies by (13) that there exists uk,∞
desire(·)
that satisﬁes y(t, uk,∞
desire(·), w(·), d(·), x(kτ )) /∈ B for all
t for any w(·) and d(·) for any x(kτ ) ∈ [xa(kτ ), xb(kτ )].
saf e(·) in line 11. This structure
Otherwise, it returns uk
corresponds to the supervisor design in Problem 1.

saf e

the base case,

saf e(·) is well-deﬁned. We say u1,∞

We prove the non-blocking property by mathematical
induction on time step k. For
it
is assumed that SUPERVISOR([xa(0), xb(0)], u0
desire) =
out(·) (cid:54)= ∅ where u0
out(·) is deﬁned on time [0, τ ),
u0
and u1,∞
saf e(·) is well-
deﬁned if
there exists a schedule T that deﬁnes
u1,∞
saf e(·) as σ(Xpred(u0
t =
(k − 1)τ, we have SUPERVISOR([xa((k − 1)τ ), xb((k −
out (·) (cid:54)= ∅ and uk,∞
saf e(·) is well-deﬁned.
1)τ )], uk−1
That is, there exists uk,∞
saf e(·) that for all t ≥ 0 for any w(·)
and d(·),

desire(·)), T). Suppose at

desire) = uk−1

∀x(kτ ) ∈Xpred(uk−1

out (·)),

y(t, uk,∞

saf e(·), w(·), d(·), x(kτ )) /∈ B.

(16)

Then, at t = kτ, we need to show that uk
what uk

desire is applied, and uk+1,∞

(·) is well-deﬁned.
In Algorithm 2, SUPERVISOR([xa(kτ ), xb(kτ )], uk
desire(·) in line 6 or uk

out(·) either uk

assigns uk

saf e

desire)
saf e(·)

out(·) (cid:54)= ∅ no matter

Prepared using sagej.cls

saf e

(·) = σ(Xpred(uk

out(·) (cid:54)= ∅. In the former
in line 11. In either case, uk
case, ans = yes and T1 exists, which implies by
Theorem 1 that there exists an input signal guaranteeing
the avoidance of the Bad set for any uncertainty. Thus,
uk+1,∞
desire), T1) is well-deﬁned on
time [(k + 1)τ,∞).
In the latter case, we consider
saf e(·)
EXACT(Xpred(uk
restricted to time [kτ, (k + 1)τ ). If let uk+1,∞
(·) be
uk,∞
saf e(·) restricted to time [(k + 1)τ,∞), we can rewrite
(16) as
∀x((k + 1)τ ) ∈ [xa(τ, uk

saf e(·)), S). Here, uk

saf e(·) is uk,∞

saf e

y(t, uk+1,∞

saf e

(·),w(·), d(·), x((k + 1)τ )) /∈ B.

xb(τ, uk

[xa(kτ ), xb(kτ )] ⊆ Xpred(uk−1

saf e(·), min Xpred(uk−1

out (·))),
saf e(·), max Xpred(uk−1

out (·)))],
(17)
out (·)),
saf e(·)), which denotes
saf e(·), xb(kτ ))], satisﬁes
out (·))),
out (·)))],
(18)

saf e(·), min Xpred(uk−1
saf e(·), max Xpred(uk−1

(14),

Since
by
the state prediction Xpred(uk
saf e(·), xa(kτ )), xb(τ, uk
[xa(τ, uk
saf e(·)) ⊆ [xa(τ, uk

Xpred(uk

xb(τ, uk

due to the order-preserving property with respect to an initial
state in Assumption 1. Thus, (17) is still satisﬁed for any
x((k + 1)τ ) ∈ Xpred(uk
saf e(·)). That is, T2 in line 8 exists,
and uk+1,∞

(·) = σ(Xpred(uk

saf e), T2) is well-deﬁned.

saf e

Therefore, the supervisor is non-blocking.

5 Approximate solutions
5.1 Efﬁcient Veriﬁcation
While scheduling problems on a single machine with
arbitrary release times, deadlines, and process times are
known to be NP-hard, Garey et al. (1981) proved that the
complexity can be reduced to O(n log n) if process times
of all jobs are identical. This was done using “forbidden
regions” and the “earliest deadline scheduling (EDD)”
rule. Forbidden regions are time intervals during which
no feasible job is allowed to start, and can be computed
in O(n log n) time. Once forbidden regions are computed,
EDD can be used to solve the scheduling problem in
O(n log n) time.

We design Algorithm 3 by modifying Garey’s result
to handle inserted idle-times. We deﬁne initial forbidden
regions F0 to account for the idle-times and set them as
inputs of Algorithm 3. In Garey’s result, forbidden regions
are initially declared empty and not taken as inputs.

In the procedure in Algorithm 3, rj, dj, and tj denote
the j-th entry of r, d, and t, respectively, and F0,γ the γ-th
interval of F0 so that F0 = ∪γF0,γ. Critical time c is the

Supervisors for Intersection Collision Avoidance

11

latest time at which a job can start at each iteration. A set A
contains jobs that have not been scheduled but are ready to
be scheduled at time s, which means their release times are
smaller than or equal to s. A set B contains all jobs that have
not been yet scheduled. Initially, B = {1, . . . ,|r|} where |r|
is the cardinality of r.

Algorithm 3 Modiﬁed version of the result of Garey et al.
(1981)
1: procedure POLYNOMIAL(r, d, F0)
2:

Let σ be a vector of indexes in an increasing order of
for i = |r| to 1 do (cid:46) Forbidden Region Declaration

r and F = F0.

The proof of Lemma 1 is provided in Appendix B.
To use Algorithm 3, we assign a time interval of equal
length to cross the intersection to all vehicles, and formulate
a relaxed IIT scheduling problem. The identical process time
θmax is deﬁned as follows:

θmax := max

j∈C max

Rj≤Tj≤Dj

Pj(Tj).

(22)

Here, θmax is the maximum time that any controlled vehicle
spends crossing an intersection, so that θmax ≥ Pj(Tj)
for all j ∈ C for any Tj ∈ [Rj, Dj]. In other words, all
controlled vehicles are guaranteed to cross the intersection
within θmax.

By replacing Pj(Tj) in Problem 3 with θmax, the relaxed

IIT scheduling problem is formulated as follows.

Problem 5. (Relaxed IIT scheduling). Given an initial state
estimation [xa(0), xb(0)], determine whether there exists a
schedule T = (T1, . . . , Tnc) ∈ Rnc
+ such that for all j ∈ C,
Rj ≤ Tj ≤ Dj,
(23)

for all i (cid:54)= j ∈ C if Ti, Tj > 0,

(Ti, Ti + θmax) ∩ (Tj, Tj + θmax) = ∅,

(24)

for all j ∈ C and γ ∈ ¯C if Tj > 0,

(Tj, Tj + θmax) ∩ ( ¯Rγ, ¯Pγ) = ∅.

(25)

If Tj = 0, (0, Pj(0)) replaces (Tj, Tj + θmax) in condi-
tions (24) and (25).

The following algorithm solves

this problem by
employing POLYNOMIAL. This is an exact solution for
Problem 5 by Lemma 1. At line 7, we call 0 the zero vector
in Rnc.

3:

Algorithm 4 Exact Solution of Problem 5
1: procedure RELAXEDEXACT([xa(0), xb(0)], S)
2:

if [ya(0), yb(0)] ∩ B (cid:54)= ∅ then return (∅,∅, no)
for all j ∈ C do calculate Rj, Dj, θmax
for all γ ∈ ¯C do calculate ¯Rγ, ¯Pγ

4:
5:
6: M = {j ∈ C : yb
7:

Fγ = (max( ¯Rγ/θmax − 1, 0), ¯Pγ/θmax)
j (0) < αj} and ¯M = C \ M

if |M| = 0 then return (∅, 0, yes)
Tj = 0 for all j ∈ ¯M and Pmax = maxj∈ ¯M Pj(Tj)
for all j ∈ M do

rj = max(Rj, Pmax)/θmax and dj = Dj/θmax

(t, π∗, ans) = POLYNOMIAL(r, d, F)
if ans = yes then Tj = tjθmax,∀j ∈ M
return (T, π∗, yes)
else return (∅, π∗, no)

8:
9:
10:

11:
12:
13:
14:

3:
4:
5:
6:

7:

8:
9:

10:

11:

12:

13:
14:

15:
16:

17:

18:
19:
20:
21:

for j ∈ {j : dj ≥ dσi} do

if cj undeﬁned then cj = dj
else cj = cj − 1
if cj ∈ Fγ for some γ then cj = inf Fγ
if σi = 1 or rσi−1 < rσi then
c = min{cj : cj deﬁned}

if c < rσi then ans = no
if rσi ≤ c < rσi + 1 then F = F ∪ (c − 1, rσi)
(cid:46) Schedule

s = 0,A = ∅,B = {1, . . . ,|r|}
while B (cid:54)= ∅ do

Generation

if s ∈ Fγ for some γ then s = sup Fγ
if A = ∅ then j = arg minj∈B rj and tj = rj
else j = arg minj∈A dj and tj = s
s = s + 1, B = B \ {j} and A = {k ∈ B : rk ≥

s}

π∗ = a vector of indexes in an increasing order of t
if ans = no then
else return (t, π∗, yes)

return (∅, π∗, no)

In the following lemma, we prove that procedure
POLYNOMIAL in Algorithm 3 solves the IIT scheduling
problem with unit process times. This problem is formulated
as follows.

Problem 4. Given r, d, ¯r, ¯p, determine the existence of a
schedule t satisfying

for all j,
for all i (cid:54)= j,
for all j and γ,

tj ∈ [rj, dj],
(ti, ti + 1) ∩ (tj, tj + 1) = ∅,
(tj, tj + 1) ∩ (¯rγ, ¯pγ) = ∅,

(19)
(20)
(21)

where (¯rγ, ¯pγ) denotes the γ-th inserted idle-time.

Lemma 1. Procedure POLYNOMIAL in Algorithm 3 solves
the IIT scheduling problem with unit process times and ﬁnds
a feasible schedule if exists.

Prepared using sagej.cls

12

Journal Title XX(X)

In this procedure, all parameters are normalized by θmax
because procedure POLYNOMIAL assumes unit process
times. In line 5, the idle-time ( ¯Rγ, ¯Pγ) is translated into
an initial set of forbidden regions Fγ so that condition (25)
is equivalent to tj /∈ Fγ. If tj ∈ Fγ, then Tj ∈ (max( ¯Rγ −
θmax, 0), ¯Pγ) so that either Tj ∈ ( ¯Rγ, ¯Pγ) or Tj + θmax ∈
( ¯Rγ, ¯Pγ).

The running time of procedure RELAXEDEXACT is
dominated by POLYNOMIAL in line 11, which has an
asymptotic running time of O(n2

By exploiting procedure RELAXEDEXACT in Algorithm 4,
we design a new procedure, called APPROX, that solves
Problem 2 within an approximation bound. This procedure
schedules vehicles according to a sequence returned by
procedure RELAXEDEXACT, thereby inheriting computational
efﬁciency. This sequence is denoted by π∗ in the following
algorithm.

c).

Algorithm 5 Approximate Solution of Problem 3
1: procedure APPROX([xa(0), xb(0)], S)
2:

if [ya(0), yb(0)] ∩ B (cid:54)= ∅ then return (∅, no)
j (0) ≥ αj for all j ∈ C then return (∅, yes)
if yb
(·, π∗,·) = RELAXEDEXACT([xa(0), xb(0)], S)
(T, ans) = SCHEDULING(π∗, [xa(0), xb(0)], S)

3:

4:
5:

Procedure APPROX in Algorithm 5 trades exactness for
computational efﬁciency. We will prove that procedure
APPROX is more conservative than procedure EXACT, that
is, there exists an instance I = ([xa(0), xb(0)], S) such that
APPROX(I) returns no while EXACT(I) returns yes. In
order to quantify the degree of conservatism, we prove
two theorems. The ﬁrst theorem states that if procedure
APPROX returns yes, then there exists an input signal to
avoid the Bad set. In the second theorem, if procedure
APPROX returns no, then there does not exist an input
signal to avoid an inﬂated Bad set, which accounts for the
conservatism.
Theorem 3.
then ([xa(0), xb(0)], S) ∈ Problem 2.
Proof. By Theorem 1, we only need to show that
([xa(0), xb(0)], S) ∈ Problem 3. Notice that procedure
APPROX of Algorithm 5 returns yes in the case of line 3.
In this case, ([xa(0), xb(0)], S) ∈ Problem 3 since all
vehicles have already crossed the intersection. The procedure
also returns yes when procedure SCHEDULING given a
sequence π∗ returns yes in line 5. Since π∗ ∈ P, where
P is a set of all permutations, and π∗ yields a feasible
schedule, we know EXACT([xa(0), xb(0)], S) returns yes.
Thus, ([xa(0), xb(0)], S) ∈ Problem 3.

If APPROX([xa(0), xb(0)], S) = (T, yes),

However, the converse of Theorem 3 is not true. That
is, for some instances such that ([xa(0), xb(0)], S) ∈

Prepared using sagej.cls

Problem 2, procedure APPROX can return no. To consider
these instances, we introduce an inﬂated Bad set.

j (Tj + Pj(Tj)) = βj

j (Tj) = αj and ya

The IIT scheduling problem ﬁnds a schedule satisfying
for j ∈ C. In
j (Tj) = αj and ya
yb
contrast, the relaxed IIT scheduling problem ﬁnds a schedule
j (Tj + θmax) ≥ βj. Given
satisfying yb
that the farthest distance that controlled vehicle j can
travel during θmax is θmaxvj,max, we deﬁne an “inﬂated”
intersection (αj, ˆβj) such that ˆβj := αj + θmaxvj,max.
Notice that βj ≤ ˆβj. Because the process times are only
deﬁned for controlled vehicles, ˆβγ = βγ for γ ∈ ¯C. Thus,
inﬂated Bad set ˆB is deﬁned as follows:

ˆB := {y ∈ Y : yi ∈ (αi, ˆβi) and yj ∈ (αj, ˆβj)

for some i (cid:54)= j such that i ∈ C ∪ ¯C and j ∈ C}.

(26)

By replacing Bad set B in Problem 2 with inﬂated Bad
set ˆB, we can formulate the relaxed veriﬁcation problem.
The following theorem is a key result that shows the
approximation bound of procedure APPROX.
Lemma
and
then Tj ≤ ¯Tj for all j ∈ C.
Lemma 3.
RELAXEDEXACT([xa(0), xb(0)], S) = (∅, π∗, no).

If APPROX([xa(0), xb(0)], S) = (T, yes),
RELAXEDEXACT([xa(0), xb(0)], S) = ( ¯T, π∗, yes),

If APPROX([xa(0), xb(0)], S) = (∅, no), then

2.

The proofs of Lemmas 2 and 3 can be found in Appendix

B.
If APPROX([xa(0), xb(0)], S) = (∅, no),
Theorem 4.
then there is no input signal u(·) that guarantees
y(t, u(·), w(·), d(·), x(0)) /∈ ˆB for all
t ≥ 0 for any
w(·) ∈ W, d(·) ∈ D, and x(0) ∈ [xa(0), xb(0)].
Proof. By Lemma 3, APPROX([xa(0), xb(0)], S) = (∅, no)
means that RELAXEDEXACT returns no. Thus, we will prove
that if there is no schedule satisfying conditions (23)-(25),
there is no input signal to avoid the inﬂated Bad set for any
uncertainty. For ease of proof, we prove the contrapositive
statement. That is, assume that there is an input signal
˜u(·) ∈ U such that y(t, ˜u(·), w(·), d(·), x(0)) /∈ ˆB for all
t for any w(·) ∈ W, d(·) ∈ D, and x(0) ∈ [xa(0), xb(0)].
Then, there exists schedule ˜T satisfying conditions (23)-
(25). This proof is similar to the ﬁrst part of the proof of
Theorem 1.

0
j (0)) = ˆβj

j ( ˜Tj, ˜uj(·), xb
and
j (0) < ˆβj,
ya

For all j ∈ C, deﬁne ˜Tj as yb
j(0)) = αj
if
j (0) < αj,
as
yb
j ( ˜Kj, ˜uj(·), xa
ya
0
otherwise. For i (cid:54)= j ∈ C, since yi(t, ˜ui(·), di(·), xi(0))
and yj(t, ˜uj(·), dj(·), xj(0)) avoid the inﬂated Bad
any d(·) ∈ D and x(0) ∈ [xa(0), xb(0)],
set
( ˜Ti, ˜Ki) ∩ ( ˜Tj, ˜Kj) = ∅. Since the inﬂated intersection

otherwise,
if

˜Kj
and

and

for

Supervisors for Intersection Collision Avoidance

13

Algorithm 6 Implementation of se
1: procedure EFFSUPERVISOR([xa(kτ ), xb(kτ )], uk
desire(·)), S)
(T1, ans1) = APPROX(Xpred(uk
2:
if ans1 = yes and for all t ∈ [0, τ ), B ∩ [xa(t, uk
3:
4:
5:

desire)
desire(·), xa(kτ )), xb(t, uk
πk = a vector of indexes in the increasing order of nonzero entries of T1
uk+1,∞
saf e
saf e(·) = uk+1,∞
uk+1
desire(·)
return uk

(t) for t ∈ [(k + 1)τ, (k + 2)τ )

(·) = σ(Xpred(uk

desire(·)), T1)

saf e

desire(·), xb(kτ ))] = ∅ then

6:
7:
8:
9:
10:
11:

12:
13:

14:
15:

else

(T2, ans2) = APPROX(Xpred(uk
if ans2 = no then

saf e(·)), S)

(T2, ans3) = SCHEDULING(πk−1, Xpred(uk

saf e(·)), S)

(·) = σ(Xpred(uk

πk = a vector of indexes in the increasing order of nonzero entries of T2
uk+1,∞
saf e
saf e(·) = uk+1,∞
uk+1
return uk

(t) for t ∈ [(k + 1)τ, (k + 2)τ )

saf e(·)), T2)

saf e

saf e(·)

for

all
t.

in

have

non-decreasing

implies
ya
j (t)

˜Tj + θmax ≤ ˜Kj
is

takes account of the maximum driving distance during
j ( ˜Tj + θmax, ˜uj(·), xa(0)) ≤ ˆβj.
θmax, we
ya
j ∈ C
This
because
Thus,
( ˜Ti, ˜Ti + θmax) ∩ ( ˜Tj, ˜Tj + θmax) = ∅ (condition (24)).
For γ ∈ ¯C, deﬁne ( ¯Rγ, ¯Pγ) as in Deﬁnition 2. Then, for
any wγ(·) ∈ Wγ, dγ(·) ∈ Dγ, and xγ(0) ∈ [xa
γ(0)],
uncontrolled vehicle γ enters the intersection no earlier
than ¯Rγ and exits it no later than ¯Pγ. In order for ˜uj(·)
to guarantee that yj(t, ˜uj(·), dj(·), xj(0)) and yγ(t) never
meet inside the intersection for any uncertainty, ( ˜Tj, ˜Kj) ∩
( ¯Rγ, ¯Pγ) = ∅. Since ˜Tj + θmax ≤ ˜Kj, we have ( ˜Tj, ˜Tj +
θmax) ∩ ( ¯Rγ, ¯Pγ) = ∅ (condition (25)).

γ(0), xb

Condition (23) is satisﬁed by the deﬁnitions of Rj and

Dj.

In summary, Theorem 3 states that

if procedure
APPROX returns yes, there exists an input signal to avoid
the Bad set B for any uncertainty. As stated in Theorem 4,
if the procedure returns no, there does not exist an input
signal to avoid the inﬂated Bad set ˆB for any uncertainty.
Thus, the difference between B and ˆB is a measure of the
approximation bound of procedure APPROX.

5.2 Efﬁcient supervisor
In order for a supervisor to run in real time, the veriﬁcation
problem must be solved within the time step τ. However,
if a large number of controlled vehicles is considered,
the problem becomes intractable. Thus, we employ the
results in Section 5.1 to design efﬁcient supervisors. The
simplest solution would be to implement a supervisor

Prepared using sagej.cls

ˆs([xa(kτ ), xb(kτ )], uk

uk

desire(·)
saf e(·)
uk

ˆs =

desire) deﬁned as follows:
desire(·) : for all t ≥ 0
desire(·), w(·), d(·), x(kτ )) /∈ ˆB

if ∃uk,∞
y(t, uk,∞
otherwise.

The only difference from the exact supervisor s is that the
Bad set B is replaced by the inﬂated Bad set ˆB.

Instead of implementing ˆs, we consider a procedure
implementing another supervisor, se, by using procedure
APPROX to verify whether or not to override drivers. We call
this procedure EFFSUPERVISOR in Algorithm 6.

Notice that this procedure stores the feasible sequence of
vehicles crossing the intersection at every time step (lines 4
and 12). This is because when the sequence considered in
line 9 does not yield a feasible schedule, the previous step’s
sequence πk−1 can be used to generate one. This is where
in procedure SCHEDULING in Algorithm 1, |π0| can be
different from |π|, where π0 = πk−1 and π ∈ R|M|. This
is because M is a set of vehicles that have not entered an
intersection at the current step, whereas πk−1 is a sequence
of vehicles that had not entered an intersection at the
previous step.

The fact that the previous step’s sequence leads to a
feasible schedule ensures the non-blocking property of
the supervisor and is proved in the next theorem. Bruni
et al. (2013) proposed an efﬁcient supervisor considering
measurement errors and unmodeled dynamics with all
vehicles controlled. Their supervisor cannot ﬁnd a feasible
schedule at every step and thus uses the previous schedule
until a new feasible schedule is found. This ignores the
correction of the state estimation during the open-loop
control, thereby being more conservative than our efﬁcient

14

Journal Title XX(X)

supervisor, which updates the schedule based on the most
current state estimation.

Procedure EFFSUPERVISOR takes polynomial computa-
tion time, and guarantees avoiding the Bad set B because
such a safe input exists if procedure APPROX returns yes by
Theorem 3. Most importantly, we will prove in the following
theorem that se is less restrictive than ˆs, in the sense that ˆs
overrides controlled vehicles more frequently than se.

Theorem 5. The supervisor se is less restrictive than ˆs:
saf e(·),
if EFFSUPERVISOR([xa(kτ ), xb(kτ )], uk
desire) = uk
saf e(·). Moreover, se
then ˆs([xa(kτ ), xb(kτ )], uk
is non-blocking.

desire) = uk

Proof. EFFSUPERVISOR([xa(kτ ), xb(kτ )], uk
desire) =
desire(·)), S) returns no.
saf e(·) when APPROX(Xpred(uk
uk
By Theorem 4, there is no input signal uk,∞
desire(·) ∈ U
that can prevent entering the inﬂated Bad set for some
saf e(·).
uncertainties. Thus, ˆs(Xpred(uk
This proves that se is less restrictive than ˆs.

desire), S) returns uk

desire) = u0
out(·) is deﬁned on time [0, τ ), and u1,∞

The non-blocking property is proved by mathematical
induction on time step k. For the base case, it is assumed
out(·) (cid:54)=
that EFFSUPERVISOR([xa(0), xb(0)], u0
∅ where u0
saf e(·) is
well-deﬁned, that is, there exists a schedule T that deﬁnes
u1,∞
saf e(·) as σ(Xpred(u0
desire(·)), T). Suppose at t = (k −
1)τ, we have EFFSUPERVISOR([xa((k − 1)τ ), xb((k −
saf e(·) is well-deﬁned,
1)τ )], uk−1
desire) = uk−1
which satisﬁes y(t, uk,∞
saf e(·), w(·), d(·), x(kτ )) /∈ B for
out (·)).
any w(·) ∈ W, d(·) ∈ D, and x(kτ ) ∈ Xpred(uk−1
out(·) (cid:54)= ∅, and uk+1,∞
(·) is
Now, we need to prove that uk
well-deﬁned.

out (·) (cid:54)= ∅ and uk,∞

saf e

saf e

saf e(·).

out(·) = uk,∞

out(·) = ∅ because uk

In Algorithm 6, if ans1 = yes in line 2 or ans2 = yes in
line 9, by Theorem 3, there exists an input signal that makes
the vehicle trajectories avoid entering the Bad set. Thus,
uk+1,∞
(·) is well-deﬁned on time [(k + 1)τ,∞) in lines 5
desire(·) or
and 13. Also, uk
out(·) = uk
uk
Suppose that ans1 = no and ans2 = no. Then, given
πk−1, we need to prove that ans3 = yes and T2 exists
in line 11. Notice that πk−1 is a vector of indexed in
the increasing order of the nonzero entries of a feasible
schedule Tk−1 of the previous step. That
the
out (·)), S) =
previous step, SCHEDULING(πk−1, Xpred(uk−1
(Tk−1, yes). We will show that the existence of Tk−1
implies that of T2.
saf e(·) restricted to time [(k +
saf e(·) restricted to time [kτ, (k +

(·) be uk,∞
saf e(·) be uk,∞

Let uk+1,∞
1)τ,∞) and uk

is, at

saf e

Prepared using sagej.cls

≤ {t : yb
:= ˜Tj + τ.

j

:= {t : yb

1)τ ). Then, the j-th entry of Tk−1 is as follows:
saf e,j(·), max Xpred,j(uk−1
T k−1
= {t : yb

j (t, uk,∞
saf e,j (·),
saf e,j(·), max Xpred,j(uk−1
saf e,j (·), xb(τ, uk

j (t, uk+1,∞
xb(τ, uk
j (t, uk+1,∞

out,j(·))) = αj} + τ
saf e,j(·), xb(kτ ))) = αj} + τ

out,j(·))) = αj}

j

j

j

j

)

is

to

[xa

due

inequality

j (kτ ), xb

) is as follows:

out,j(·))) = βj}

(27)
j(kτ )] ⊆
The
out,j(·)) by (14) and the order-preserving
Xpred,j(uk−1
property in Assumption 1. Similarly, its process time
T k−1
j + P k−1
T k−1
j + P k−1
:= {t : ya
= {t : ya

(T k−1
(T k−1
j (t, uk,∞
saf e,j(·), min Xpred,j(uk−1
j (t, uk+1,∞
saf e,j (·),
saf e,j(·), min Xpred,j(uk−1
xa(τ, uk
j (t, uk+1,∞
≥ {t : ya
saf e,j (·), xa(τ, uk
:= ˜Tj + ˜Pj( ˜Tj) + τ.
For γ ∈ ¯C, let ( ¯Rk−1
Xpred(uk−1
We now show that the schedule ˜T := ( ˜Tj : j ∈ C) is a fea-
saf e(·)), S).
sible schedule of SCHEDULING(πk−1, Xpred(uk
The release time and deadline of this procedure for j ∈ C is
by deﬁnition,

out,j(·))) = βj} + τ
saf e,j(·), xa(kτ ))) = βj} + τ

) denote the idle-time given

out (·)).

, ¯P k−1

(28)

γ

γ

saf e,j(·))) = αj},
saf e,j(·))) = αj}.

j

i

i

i

i

j

j

, T k−1

, T k−1

+ P k−1

Rj = min

uj (·)∈Uj
Dj = max
uj (·)∈Uj

j (t, uj(·), max Xpred,j(uk
j (t, uj(·), max Xpred,j(uk

{t : yb
{t : yb
saf e(·), xb(kτ )) = max Xpred(uk
j + P k−1

Since Tk−1 is feasible, (T k−1

)) − τ,
, T k−1
( ˜Tj, ˜Tj + ˜Pj( ˜Tj)) ∩ ( ˜Tj, ˜Ti +

saf e(·)) in
)) ∩
(T k−1
)) = ∅ for i (cid:54)= j ∈ C. Because

Since xb(τ, uk
(11), we have ˜Tj ∈ [Rj, Dj].
(T k−1
(T k−1
of (27) and (28),
( ˜Tj, ˜Tj + ˜Pj( ˜Tj)) ⊆ (T k−1
for
˜Pi( ˜Ti)) = ∅.
the idle-time of SCHEDULING(πk−1, Xpred(uk
denoted by ( ¯Rγ, ¯Pγ) becomes a subset of ( ¯Rk−1
)) ∩ ( ¯Rk−1
τ. Since (T k−1
∅, we have ( ˜Tj, ˜Tj + ˜Pj( ˜Tj)) ∩ ( ¯Rγ, ¯Pγ) = ∅.
line 11 of Algorithm 6. Since T2 = ˜T exists, uk+1,∞
is well-deﬁned.

j ∈ C. Thus,
Similarly for γ ∈ ¯C,

Thus, ˜T is feasible, thereby implying ans3 = yes in
(·)

to see that
saf e(·)), S)
) −
, ¯P k−1
, ¯P k−1
) =

j + P k−1

j + P k−1

is not difﬁcult

, T k−1

(T k−1

(T k−1

all

saf e

it

γ

γ

γ

γ

j

j

j

j

j

j

Therefore, the supervisor is non-blocking.

Supervisors for Intersection Collision Avoidance

15

(a)

(b)

Figure 6. Simulation of the exact supervisor s in (a) and the efﬁcient supervisor se in (b). The dotted lines at distance 0 and 5
represent the location of the intersection. The solid black lines and the dotted red lines are the exact trajectories of the controlled
and uncontrolled vehicles, respectively, and the shading around the lines represent the position estimation. The blue boxes on the
bottom are the time steps at which the supervisor overrides the controlled vehicles. The initial exact state is y(0) =(-42, -50, -55,
-60, -60, -65) and v(0) =(10, 9, 8, 8, 10, 8).

In summary, the efﬁcient supervisors ˆs and se are more
restrictive than the exact supervisor s, and ˆs is more
restrictive than se by Theorem 5.

6 Simulations
In this section, we present simulation results of the exact and
efﬁcient supervisors, s and se, in two scenarios by running
Algorithms 2 and 6. These are implemented using MATLAB
on a personal computer with an 3.10 GHz Intel Core i7-
3770s processor with 8 GB RAM.
With the dynamic states xj = (yj, vj) and xγ = (yγ, vγ)
for j ∈ C and γ ∈ ¯C, the vehicle dynamics considered in the
simulation are as follows:

˙yj = vj + dy,j,

min(0, uj − bv2
uj − bv2
j + dv,j

max(0, uj − bv2
max(0, wγ − bv2

min(0, wγ − bv2
wγ − bv2
γ + dv,γ

˙vj =

and

˙vγ =

˙yγ = vγ + dy,γ,

j + dv,j)
j + dv,j)

γ + dv,γ)
γ + dv,γ)

if (vj = vj,min),
if (vj = vj,max),
otherwise,

if (vγ = vγ,min),
if (vγ = vγ,max),
otherwise,

a

drag

is
are

and
where
b = 0.001
representing
dy,j, dy,γ, dv,i, dv,γ
unmodeled dynamics bounded by −0.05 and 0.05. The
speeds vj, vγ are bounded by vj,min = vγ,min = 1.39 and
vj,max = vγ,max = 13.9, the input uj by uj,min = −2.5

disturbances

coefﬁcient,

Prepared using sagej.cls

and

and uj,max = 2.5,
by
wγ,min = −0.5 and wγ,max = 0.5. In the simulation,
the disturbances and the driver-inputs of uncontrolled
vehicles are randomly chosen within their bounds.

driver-input wγ

the

At each time step τ = 0.1, the supervisors determine
whether there are impending collisions at an intersection
located at (αi, βi) = (0, 5) for all i ∈ C ∪ ¯C. The states of
all vehicles are measured subject to noises, δy,i ∈ [−3, 3]
and δv,i ∈ [−0.05, 0.05]. For the sake of simplicity, in the
j,desire = 1 for all vehicles at all times.
simulation, we let uk
In the ﬁrst scenario, four controlled and two uncontrolled
vehicles are approaching an intersection as in Figure 6,
which illustrates the position trajectories of the vehicles
in time.

The simulation result of the exact supervisor s is shown
in Figure 6a, and that of the efﬁcient supervisor se is shown
in Figure 6b. Though we said in Section 5.2 that se is more
conservative than s – in the sense that given the same initial
condition, s evaluates more inputs to ﬁnd one guaranteeing
avoiding the Bad set than se – comparison of the override
time steps (blue boxes) in Figures 6a and 6b indicates that
se does not override the drivers more than s. It takes 0.067 s
and 0.011 s per iteration to execute s (Algorithm 2) and se
(Algorithm 6), respectively, in the worst case. This validates
that the computation of the efﬁcient supervisor is faster
than that of the exact supervisor. In both simulations, the
intersection at distance (0, 5) is occupied by one vehicle at a
time.

The second scenario considers twelve controlled and two
uncontrolled vehicles. Due to the large number of controlled
vehicles involved, the exact supervisor cannot solve the
veriﬁcation problem within one time step. Thus, the only

time0246810121416distance-60-50-40-30-20-10010controlled vehiclesuncontrolled vehiclesposition estimationstime steps of overridetime0246810121416distance-60-50-40-30-20-1001016

Journal Title XX(X)

The cars used for this experiment are each built onto a
Tamiya scaled RC car chassis equipped with a DC motor.
A micro-controller (Acroname Moto 1.0) is used to control
the steering servo and the motor through two separate PWM
channels. An on-board computer (Mini-ITX running Fedora)
runs the C programs, which provide the functionalities
required to communicate with the centralized supervisor and
to control the micro-controller. The system is powered by
two batteries (Tenergy Li-Ion 14.8 V 4400 mAh) connected
to a capacitor (Aluminium Electrolytic Capacitor 12000 uF
25 V) through a power relay (Omron G5SB). A power
ampliﬁer (Acroname 3 A Back EMF H-bridge) connected
to the batteries through a switch provides necessary power
to the motor.
During the experiment, three cars follow distinct paths
intersecting at a single point on a 6 m × 6 m testbed as
shown in Figure 8b. Each path is stored as sequential points
on the coordinate system illustrated in the ﬁgure. Cars 1
and 2 are controlled by the exact supervisor when necessary,
while car 3 is not controllable. We program cars 1 and 2
to maintain constant motor input, which corresponds to the
desired input, while car 3 is driven by a human operator.

Each car has access to its own wheel speed through a
quadrature encoder mounted on the rear axle. The position
and direction of the cars are measured by an over-head vision
system, which comprises six cameras on the ceiling and three
computers processing images taken by the cameras. Each
car is identiﬁed by a symbol attached to its roof as shown in
Figure 8a. The measurement of the speeds, positions, and
directions of all cars are collected by an external computer
via a wireless connection of the 802.11b standard using
UDP/IP. Then, the computer distributes these measurements
to the controlled cars, together with other information such
as the desired inputs of the controlled vehicles and model
parameters discussed in the next section.

7.2 Car dynamics model

Figure 7. Simulation of the efﬁcient supervisor se. The initial
exact state is y(0) =(-25, -30, -35, -40, -45, -50, -55, -60, -65,
-65, -70, -75, -80, -85) and v(0) =(6,9, 9, 8, 8, 8, 8, 8, 8, 9.5, 8,
8, 8, 8).

option to resolve conﬂict in this scenario is to implement
the efﬁcient supervisor (Algorithm 6). As shown in Figure 7,
the efﬁcient supervisor assists the vehicles to prevent any
collision at the intersection. In the worst case, it takes 0.033 s
per iteration.

7 Experiments
In this section, we describe the experimental validation of
the exact supervisor on an intersection testbed. First, we
introduce the laboratory apparatus. Then, we describe the
dynamic model of the RC cars used in the experiment and
the techniques adopted to reduce disturbances. The results
of the experiment are provided at the end of this section.

7.1 Experimental setup

(a)

(b)

Figure 8. (a) The RC cars used in the experiment. The camera
system detects their symbols to identify each car and measure
its position. (b) The paths of the cars on the testbed. Cars 1
and 2 are controlled by the supervisor while car 3 is not. A car
is considered to be occupying the intersection when its position
is within the shaded circle.

Figure 9. Block diagram of the RC car model. The model
includes the measurement disturbances δy,i and δv,i on the car
position and speed, respectively.

A block diagram in Figure 9 represents the car dynamics.
In this section, we design a compensating input to reduce
the effects of the disturbances dproj,i, dpower,i, dslope,i, and
dsteer,i.

Prepared using sagej.cls

time051015202530distance-60-50-40-30-20-10010O123Supervisors for Intersection Collision Avoidance

17

Before compensating for the disturbances, the dynamics
of the RC cars are as follows: for car i ∈ C ∪ ¯C where
C = {1, 2} and ¯C = {3},

˙yi = vi + dproj,i,
˙vi = aivi + bi + fiui + dpower,i + dslope,i + dsteer,i

(29)

where yi is the longitudinal position of car i along the
path, vi is its wheel speed, and ui is the motor input
with model parameters ai, bi, and fi. The disturbances
dproj,i, dpower,i, dslope,i, and dsteer,i are explained below
and compensated to reduce their effects.

(b)

(a)
Figure 10. Cases when dproj,i (cid:54)= 0. Imperfect path following
contributes to the discrepancy between the longitudinal speed
˙yi and the wheel speed vi.

Notice that vi is the car’s wheel speed while ˙yi is the
projected speed on the longitudinal path of car i. It is possible
that ˙yi (cid:54)= vi when the car does not follow its path exactly,
and this discrepancy is represented by the term dproj,i.
Figure 10 shows two cases in which ˙yi (cid:54)= vi. In Figure
10a, the direction of car i differs from the tangent of the
longitudinal path (black line) so that vi (cid:54)= ˙yi. In Figure 10b,
two cars follow the same path with the same wheel speed v
but with slight deviation from the path, causing ˙yi > v > ˙yj.
includes three different
disturbances on the acceleration. The disturbance dpower,i
describes the ﬁrst-order dynamic behavior empirically
observed in the motor as a consequence of the power
connection. By running the cars in a circle with constant
motor input for several minutes, we can model dpower,i =
gie−t/hiu(cid:48)
i, where gi is the gain and hi the time constant.
The car-speciﬁc parameters gi and hi are estimated by
analyzing the collected data using the least square method
(see Rizzi (2014) for the data).

This dynamic model

(29)

The disturbance dslope,i is introduced to model the slope
of the testbed, which is not completely ﬂat and has non-
negligible effects on the car speed. The disturbance dsteer,i
takes into account the fact that the steering and motor
dynamics are coupled (Verma et al. (2008)). Since the
testbed slope and the steering input are approximately the
same at the same point of the path, we estimate these two

Prepared using sagej.cls

disturbances as a path-dependent function dpath,i(y) :=
dsteer,i(y) + dslope,i(y). This function is different for each
path and estimated by running the car multiple times and
curve ﬁtting of the obtained data.

Eliminating the effects of these disturbances is critical
because otherwise it is difﬁcult to initiate Algorithm 2 with a
feasible initial condition, especially in a spatially constrained
environment, such as a laboratory testbed. To this end, we
introduce a compensating term ci(t, yi) to the motor input so
that ui = u(cid:48)
i is the input signal returned
by the supervisor for car i. By employing the model and
estimation of the disturbances explained above, we obtain
the following compensating input:
ci(t, yi) = − gie−t/hiu(cid:48)

i + ci(t, yi), where u(cid:48)

i + dpath,i(yi)

gie−t/hi + fi

.

This, in turn, simpliﬁes (29) as ˙yi = vi + dproj,i and ˙vi =
aivi + bi + fiu(cid:48)
i. Eventually with the compensation, we
consider the following car dynamics in the experiment. For
i ∈ C ∪ ¯C,

˙yi = vi + dy,i,

max(0, aivi + bi + fiu(cid:48)

min(0, aivi + bi + fiu(cid:48)
aivi + bi + fiu(cid:48)
i + dv,i

˙vi =

i + dv,i)
i + dv,i)

if (vi = vi,min),
if (vi = vi,max),
otherwise,

where dv,i represents an error from the compensation and
an unpredicted source of disturbance.

7.3 Results
The on-board computers on cars 1 and 2 run Algorithm 2.
Since the same algorithm is run with the same measurement
updated every τ = 0.1s, the outputs are the same, thereby
working as centralized control.
The parameters are as follows: a =(-0.53, -0.30, -
0.43) s−1, b =(-84.68, -66.43, -49.64) cm/s2, g =(0.99,
0.44, 0.95), and h =(9.17, 6.84, 5.95) s. The gain fi(t)
for all i is a time-varying parameter, estimated at every
time step. The bounds of the speed are vmin =(10.5, 10.5,
13) cm/s and vmax =(17, 16.5, 15) cm/s, and those of
the motor input (PWM) are umin = (105, 105, 130) and
umax =(170,165,150). The bounds of the measurement
noises are empirically chosen by ignoring long tails as
δy,i,min = -25 cm, δy,i,max = 25 cm, δv,i,min = -25 cm/s,
and δv,i,max = 16 cm/s for all i. The bounds of the
experimental disturbance are dy,min =(-5, -3, -3) cm/s,
dy,max =(3, 4, 3) cm/s, dv,min =(-4, -2, -3) cm/s2, and
dv,max =(2, 3, 2.5) cm/s2.

Figure 11 depicts two experimental results obtained
by implementing the exact supervisor. The intersection is
located at (0, 65) cm for all cars. The intersection is an
area containing the point at which the paths intersect, as in
Figure 8b.

ji18

Journal Title XX(X)

(a)

(b)

Figure 11. The results of implementing the exact supervisor (see also Extension 1). The intersection is represented by the dotted
lines located at (0, 65) cm. The solid black lines represent the position measurement of the controlled cars, cars 1 and 2, and the
dotted red line represents the position measurement of the uncontrolled car, car 3. These ﬁgures demonstrate that the cars are not
inside the intersection at the same time.

In Figure 11a, in picture 1, the uncontrolled car (dotted
red circle) approaches the intersection earlier than the other
cars. The supervisor overrides the controlled cars (solid blue
circles) to decelerate them until their desired inputs do not
cause conﬂict. In picture 2, the conﬂict is resolved, and
one controlled car crosses the intersection alone without
overrides. In Figure 11b, in picture 1, one controlled car
approaches the intersection ﬁrst. The supervisor lets this car
accelerate and the other controlled car decelerate so that the
uncontrolled car safely crosses the intersection, as shown
in picture 2. Notice that the upper bound of the last car’s
position enters the intersection right after the lower bound
of the uncontrolled car’s position has exited, indicating that
the override was applied because it is deemed necessary to
avoid the collision. In both cases, intersection collisions are
averted.

Figure 12 depicts 509 trajectories (semitransparent black
lines) near the Bad set (red blocks). The trajectories are
indicated in blue when the supervisor intervenes. From
the 2D projections (ﬁgures on the right-hand side), we can
conﬁrm that none of the trajectories enters the Bad set. Since
cars 1 and 2 are programmed to maintain constant speeds
and car 3 does not change its speed quickly, the trajectories
in the projections should be straight lines without overrides.
We can see that the supervisor overrides cars 1 and 2 when
the trajectories would enter the Bad set if the trajectories
were linear. We observed in 15 trajectories that the cars were
forced to stop before the Bad set because the supervisor
could not ﬁnd a safe input. This was because we had to
truncate the tails of the distributions of disturbances, and
thus the state measurement and the state estimation can

sometimes be incompatible. This truncation is necessary
in the conﬁned laboratory because otherwise a feasible
initial condition may not always exist. The existence of a
feasible initial condition is a necessary condition to initiate
procedure SUPERVISOR in Algorithm 2.

8 Conclusions
We have designed exact and efﬁcient supervisors that
override controlled vehicles when collisions are imminent.
The sources of uncertainty, such as measurement errors,
unmodeled dynamics, and the presence of uncontrolled
vehicles are taken into account
in the design of the
supervisors. The exact supervisor determines the existence
of safe inputs (veriﬁcation problem) by solving the Inserted
Idle-Time (IIT) scheduling problem, which is proven to yield
equivalent answers to the veriﬁcation problem. To address
the computational complexity issue, we also design the
efﬁcient supervisor that solves the IIT scheduling problem
with a quantiﬁed approximation bound. The simulation
results show that the efﬁcient supervisor prevents collisions
without substantial conservatism, compared to the exact one.
The experiment using RC cars on an intersection testbed
validated that collisions at an intersection are successfully
averted by the exact supervisor.

Although this paper deals only with decision problems to
focus on safety, there is no barrier to incorporate objective
functions to address other issues such as fuel consumption
or trafﬁc congestion. The intersection considered in this
paper is modeled as a single conﬂict area so that vehicles
are required to occupy the intersection one at a time. This

Prepared using sagej.cls

time (s)05101520distance (cm)-700-600-500-400-300-200-100010021time (s)05101520distance (cm)-700-600-500-400-300-200-100010012Supervisors for Intersection Collision Avoidance

19

assumption may make the system very conservative in that,
for example, two vehicles turning right on different lanes
are geometrically unable to collide while the supervisors
do not let them inside the intersection at the same time. We
are currently investigating the design of supervisors with
a more general intersection model, which includes multi-
conﬂict points. The result with simple ﬁrst-order vehicle
dynamics can be found in Ahn and Del Vecchio (2016, To
appear). Other remaining issues include preventing rear-
end collisions (Colombo and Del Vecchio (2014)) and
considering unknown routes of vehicles.

Funding
This work was in part supported by NSF Award #1239182.
Alessandro Colombo was in part supported by grant AD14VARI02
- Sottomisura B.

References

Ahn H, Colombo A and Del Vecchio D (2014) Supervisory
control for intersection collision avoidance in the presence
of uncontrolled vehicles. In: American Control Conference
(ACC). pp. 867–873.

Ahn H and Del Vecchio D (2016, To appear) Semi-autonomous
intersection collision avoidance through job-shop scheduling.
In: the 19th ACM international conference on Hybrid Systems:
Computation and Control.

Ahn H, Rizzi A, Colombo A and Del Vecchio D (2015)
Experimental testing of a semi-autonomous multi-vehicle
collision avoidance algorithm at an intersection testbed. In:
IEEE/RSJ International Conference on Intelligent Robots and
Systems (IROS). pp. 4834–4839.

Alonso-Ayuso A, Escudero L and Martn-Campo F (2011) Collision
Avoidance in Air Trafﬁc Management: A Mixed-Integer Linear
IEEE Transactions on Intelligent
Optimization Approach.
Transportation Systems 12(1): 47–57.

Borrelli F, Subramanian D, Raghunathan A and Biegler L (2006)
MILP and NLP Techniques for centralized trajectory planning
In: American Control
of multiple unmanned air vehicles.
Conference.

Bruni L, Colombo A and Del Vecchio D (2013) Robust multi-agent
collision avoidance through scheduling. In: IEEE Conference
on Decision and Control (CDC). pp. 3944–3950.

Cassandras CG and Lafortune S (eds.) (2008) Introduction to

Discrete Event Systems. Boston, MA: Springer US.

Colombo A and Del Vecchio D (2012) Efﬁcient algorithms
In: the 15th ACM
for collision avoidance at intersections.
international conference on Hybrid Systems: Computation and
Control. pp. 145–154.

Colombo A and Del Vecchio D (2014) Least Restrictive Super-
visors for Intersection Collision Avoidance: A Scheduling
IEEE Transactions on Automatic Control DOI:
Approach.
10.1109/TAC.2014.2381453.

Prepared using sagej.cls

Cormen TH, Leiserson CE, Rivest RL and Stein C (2009)
Introduction to Algorithms. 3rd edition edition. Cambridge:
The MIT Press. ISBN 9780262033848.

Garey MR, Johnson DS, Simons BB and Tarjan RE (1981)
Scheduling UnitTime tasks with arbitrary release times and
deadlines. SIAM Journal on Computing 10: 256–269.

Gillula JH, Hoffmann GM, Huang H, Vitus MP and Tomlin CJ
(2011) Applications of hybrid reachability analysis to robotic
aerial vehicles. The International Journal of Robotics Research
30(3): 335–354.

Hafner M, Cunningham D, Caminiti L and Del Vecchio D
(2013) Cooperative Collision Avoidance at Intersections:
Algorithms and Experiments. IEEE Transactions on Intelligent
Transportation Systems 14(3): 1162–1175.

Hafner MR and Del Vecchio D (2011) Computational tools for the
safety control of a class of piecewise continuous systems with
imperfect information on a partial order. SIAM Journal on
Control and Optimization 49: 2463–2493.

Hoffmann G and Tomlin C (2008) Decentralized cooperative
collision avoidance for acceleration constrained vehicles. In:
IEEE Conference on Decision and Control (CDC). pp. 4357–
4363.

Kamal M, Imura J, Hayakawa T, Ohata A and Aihara K (2014) A
Vehicle-Intersection Coordination Scheme for Smooth Flows
of Trafﬁc Without Using Trafﬁc Lights. IEEE Transactions on
Intelligent Transportation Systems DOI:10.1109/TITS.2014.
2354380.

Kowshik H, Caveney D and Kumar P (2011) Provable systemwide
IEEE Transactions on

safety in intelligent intersections.
Vehicular Technology 60: 804–818.

Lee J and Park B (2012) Development and evaluation of a
cooperative vehicle intersection control algorithm under the
IEEE Transactions on
connected vehicles environment.
Intelligent Transportation Systems 13: 81–90.

Maimone M, Cheng Y and Matthies L (2007) Two years of Visual
Odometry on the Mars Exploration Rovers. Journal of Field
Robotics 24(3): 169–186. DOI:10.1002/rob.20184.

Mastellone S, Stipanovi DM, Graunke CR, Intlekofer KA
and Spong MW (2008) Formation Control and Collision
Avoidance for Multi-agent Non-holonomic Systems: Theory
and Experiments. The International Journal of Robotics
Research 27(1): 107–126.

Pallottino L, Feron E and Bicchi A (2002) Conﬂict resolution
problems for air trafﬁc management systems solved with
mixed integer programming. IEEE Transactions on Intelligent
Transportation Systems 3(1): 3–11.

Peng J and Akella S (2005a) Coordinating Multiple Double
Integrator Robots on a Roadmap: Convexity and Global
Optimality. In: IEEE International Conference on Robotics
and Automation (ICRA). pp. 2751–2758.

Peng J and Akella S (2005b) Coordinating Multiple Robots
with Kinodynamic Constraints Along Speciﬁed Paths. The

20

Journal Title XX(X)

International Journal of Robotics Research 24(4): 295–310.
Richards A, Schouwenaars T, How JP and Feron E (2002)
Spacecraft Trajectory Planning with Avoidance Constraints
Journal of
Using Mixed-Integer Linear Programming.
Guidance, Control, and Dynamics 25(4): 755–764.

Rizzi A (2014) Analysis and optimization of an experi-
mental apparatus to test active safety systems in vehi-
cles.
URL https://www.politesi.polimi.it/
handle/10589/92232.

Smith RN, Chao Y, Li PP, Caron DA, Jones BH and Sukhatme
GS (2010) Planning and Implementing Trajectories for
Autonomous Underwater Vehicles to Track Evolving Ocean
Processes Based on Predictions from a Regional Ocean Model.
The International Journal of Robotics Research 29(12): 1475–
1497.

Verma R, Del Vecchio D and Fathy H (2008) Development of a
Scaled Vehicle With Longitudinal Dynamics of an HMMWV
for an ITS Testbed. IEEE/ASME Transactions on Mechatronics
13(1): 46–57. DOI:10.1109/TMECH.2008.915820.

Wu J, Abbas-Turki A and ElMoudni A (2012) Cooperative driving:
an ant colony system for autonomous intersection management.
Applied Intelligence 37: 207–222.

Wurman PR, D’Andrea R and Mountz M (2008) Coordinating Hun-
dreds of Cooperative, Autonomous Vehicles in Warehouses.
AI Magazine 29(1): 9–19.

Appendix A: Index to Multimedia
Extensions

Extension Media type Description
1

Video

This video contains experi-
ments of the exact supervisor
presented in Section 7.

Appendix B
We provide the proofs of Lemmas 1-3 in this section.
Lemma 1. Procedure POLYNOMIAL in Algorithm 3 solves
the IIT scheduling problem with unit process times and ﬁnds
a feasible schedule if exists.

Proof. To account for inserted idle-times, we deﬁne an
initial set of forbidden regions as F0,γ = (¯rγ − 1, ¯pγ) for
all γ. If tj /∈ F0,γ for some j, then we have (tj, tj + 1) ∩
(¯rγ, ¯pγ) = ∅, thereby satisfying condition (21).

Forbidden Region Declaration in lines 3-11 of procedure
POLYNOMIAL solves Problem 4. The key idea is critical time
c, which is the latest start time of job σi. If job σi starts later
than critical time c, at least one of the subsequent jobs cannot
be scheduled before its deadline. That is, if a job cannot
start before the critical time (line 10), there is no schedule
satisfying conditions (19)-(21). Otherwise, there will be a

Prepared using sagej.cls

schedule satisfying all the conditions. This relation between
critical time and the existence of a feasible schedule was
proved in Garey et al. (1981) with initially empty forbidden
regions. Since initially non-empty forbidden regions do not
affect the fact that critical time is the latest start time, this
analysis of critical time can determine the existence of a
schedule with non-empty initial forbidden regions.

With the forbidden regions declared, the EDD rule ﬁnds a
schedule in lines 12-17. Time s is assigned to each job as a
schedule. In line 14, s avoids the forbidden regions so that
condition (21) is satisﬁed. If there is no ready job (line 15),
a job with the minimum release time among unscheduled
jobs is scheduled, and otherwise (line 16), a job with the
earliest deadline among ready jobs is scheduled. After a job
is scheduled, line 17 updates s to s + 1 so that condition (20)
is satisﬁed. This schedule cannot satisfy condition (19) if
ans has been no in line 10. Otherwise, this schedule satisﬁes
conditions (19)-(21).

≤ ¯Tπ∗

Lemma 2. If APPROX([xa(0), xb(0)], S) = (T, yes), and
RELAXEDEXACT([xa(0), xb(0)], S) = ( ¯T, π∗, yes),
then
Tj ≤ ¯Tj for all j ∈ C.
Proof. We will show by induction on j that Tπ∗
for
j ∈ M. Notice that Ti = ¯Ti = 0 for all i ∈ ¯M. The
all π∗
schedule T is generated by procedure SCHEDULING in
Algorithm 1. For the base case, Tπ∗
, Pmax)
in line 8 of Algorithm 1. Since ¯Tπ∗
1 is a feasible solution
of Problem 5 by Lemma 1, it satisﬁes Rπ∗
1 from
condition (23) and (0, Pi(0)) ∩ ( ¯Tπ∗
+ θmax) = ∅ for
all i ∈ ¯M from condition (24). Thus, max(Rπ∗
, Pmax) =
. Then, for j = k,
Tπ∗
we need to show that Tπ∗

1 . Now, suppose Tπ∗
≤ ¯Tπ∗

= max(Rπ∗
≤ ¯Tπ∗

, ¯Tπ∗
≤ ¯Tπ∗

≤ ¯Tπ∗

k−1

k−1

.

1

1

1

1

1

1

1

j

j

k

.

k

k

k

k

k

k

k

k−1

k

k−1

k−1

k

k−1

k

k

k

k−1

k−1

k−1

k−1

k−1

k−1

(Tπ∗

, Tπ∗

= Tπ∗

= Rπ∗

If Tπ∗

and Pπ∗

≤ ¯Tπ∗

= max(Rπ∗

≥ ¯Rγ or Tπ∗

, we have Tπ∗

In line 10 of Algorithm 1, Tπ∗

(Tπ∗
≤ ¯Tπ∗
k−1
satisﬁes condition (24), ¯Tπ∗

)).
satisﬁes condition (23). If Tπ∗
), we have Tπ∗
(Tπ∗

+
≤ ¯Tπ∗
k
+
≤ ¯Tπ∗
+ θmax because
) ≤ θmax by (22). Since
+ θmax ≤ ¯Tπ∗
. There-
. In lines 13 and 15 of Algorithm 1, the
= ¯Pγ for some γ ∈ ¯C
satisﬁes
+ θmax > ¯Rγ, then
≤

Pπ∗
k−1
because ¯Tπ∗
Pπ∗
Tπ∗
¯Tπ∗
fore, Tπ∗
schedule can increase so that Tπ∗
if Tπ∗
condition (25), if ¯Tπ∗
it must be ¯Tπ∗
¯Tπ∗
Lemma 3. If APPROX([xa(0), xb(0)], S) = (∅, no), then
RELAXEDEXACT([xa(0), xb(0)], S) = (∅, π∗, no).
Proof. In Algorithm 5, procedure APPROX returns
[ya(0), yb(0)] ∩ B (cid:54)= ∅ in line 2 or procedure
no if
SCHEDULING with π∗ returns no in line 5. In the former
case, procedure RELAXEDEXACT also returns no as in line 2

≥ ¯Pγ. Therefore, in either case, Tπ∗

≥ ¯Rγ or ¯Tπ∗

) > ¯Rγ. Since ¯Tπ∗

+ Pπ∗

(Tπ∗

k

k

k

k

k

k

k

k

k

k

k

k

Supervisors for Intersection Collision Avoidance

21

j ∈ C. By Lemma 2, we have ¯Tπ∗

for
of Algorithm 4. The latter case implies that Tπ∗
> Dπ∗
≥ Tπ∗
some π∗
if a feasible
solution ¯T of Problem 5 exists. Such a schedule cannot be
feasible because ¯Tπ∗
, which does not satisfy
condition (23). Thus, procedure RELAXEDEXACT returns
(∅, π∗, no).

> Dπ∗

≥ Tπ∗

j

j

j

j

j

j

j

Prepared using sagej.cls

22

Journal Title XX(X)

Figure 12. Trajectories (semitransparent black lines) in the output space. There are 509 trajectories, which are indicated in blue
when the supervisor intervenes. The three ﬁgures on the right-hand side are the 2D projections. These conﬁrm that all of the
trajectories avoid the Bad set.

Prepared using sagej.cls

