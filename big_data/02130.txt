6
1
0
2

 
r
a

M
7

 

 
 
]
E
S
.
s
c
[
 
 

1
v
0
3
1
2
0

.

3
0
6
1
:
v
i
X
r
a

From Design Contracts to Component

Requirements Veriﬁcation

Jing (Janet) Liu, John D. Backes, Darren Cofer, and Andrew Gacek

Advanced Technology Center, Rockwell Collins

{jing.liu,john.backes,darren.cofer,andrew.gacek}@rockwellcollins.com

Abstract. During the development and veriﬁcation of complex airborne
systems, a variety of languages and development environments are used
for diﬀerent levels of the system hierarchy. As a result, there may be
manual steps to translate requirements between these diﬀerent envi-
ronments. This paper presents a tool-supported export technique that
translates high-level requirements from the software architecture model-
ing environment into property observers that can be used for veriﬁcation
in the software component environment. This allows eﬃcient veriﬁcation
that the component designs comply with their high-level requirements.
It also provides an automated tool chain supporting formal veriﬁcation
from system requirements down to low-level software requirements that
is consistent with certiﬁcation guidance for avionics systems. The ef-
fectiveness of the technique has been evaluated and demonstrated on a
medical infusion pump and an aircraft wheel braking system.

Keywords: design contracts, speciﬁcation model, design model, AGREE,
Simulink, requirements-based veriﬁcation, certiﬁcation

1

Introduction

As part of the software development process for complex avionics systems, sys-
tem requirements are iteratively decomposed, allocated, and reﬁned to lower
level requirements for software and hardware components. Diﬀerent veriﬁcation
processes are used to provide evidence that these components satisfy their re-
quirements. The focus of all development and veriﬁcation activities in the avion-
ics domain is to ensure that a system meets its requirements and contains no
unintended functionality.

Requirements at diﬀerent levels of the system hierarchy may be speciﬁed us-
ing diﬀerent languages and development environments. Even when formal meth-
ods tools are used to verify requirements, there may be manual steps to translate
requirements between these diﬀerent environments. The work presented in this
paper attempts to close the gap between veriﬁcation at the system level and the
component level.

We present a tool-supported technique that translates formal speciﬁcations
from a system-level reasoning framework into observers of requirements for soft-
ware components. The observers that the tool produces can be veriﬁed using

a model checker specialized to the software component development language.
Our work closes the gap between high-level requirements captured with the soft-
ware architecture and low-level requirements for component implementation.
This ensures consistency of the veriﬁcation results and improves productivity
and accuracy through the use of automation to eliminate manual steps. Fur-
thermore, making these property observers available during the design process
supports early veriﬁcation of the software components.

In previous work, we have developed a compositional analysis environment
[1,2] based on the Architecture Analysis and Design Language (AADL) [3].
AADL can be used to model both the hardware and software aspects of the
system, but in this work we have limited our attention to the software archi-
tecture. In our compositional analysis approach, the AADL model is augmented
with assume-guarantee contracts to capture both system-level behaviors and the
behaviors of the software components.

In the present work, we link the component contracts to their implementa-
tions in Simulink [4], a framework developed by MathWorks and integrated with
MATLAB. Simulink provides a graphical programming environment for model-
ing, simulation, code generation, testing, and formal analysis. It is widely used in
the avionics industry. By automatically translating formal contracts for software
component behavior into speciﬁcations that can be checked in the Simulink en-
vironment, we now support a complete top-to-bottom development process with
formal veriﬁcation of all requirements. Furthermore, the design of our approach
is suﬃciently general that it can be adapted to support other software develop-
ment environments and languages.

Since our objective is the production of high-assurance software for avionics,
we must be cognizant of how this approach will ﬁt into a certiﬁcation context.
As we will show, our approach has been designed to be consistent with new
certiﬁcation guidance related to the use of formal methods and model-based
development processes.

The rest of the paper is organized as follows. Section 2 provides background
information related to the development and analysis environment, including cer-
tiﬁcation considerations. Section 3 describes the contract translation process in
detail. Section 4 evaluates the techniques in an avionics system case study and
a medical device system case study. Section 5 describes related work. Finally,
Section 6 presents concluding remarks.

2 Preliminaries

In this section, we describe the overall design ﬂow and introduce some termi-
nology associated with the certiﬁcation context. We also describe the system
architecture modeling environment and the software component modeling envi-
ronment that we are using.

2.1 Design Flow from Architecture to Component

One of our goals is to transition the tools we have developed into use by the
system and software engineers who develop avionics products. Therefore, we
need to understand how the tools and the models they produce will ﬁt into the
certiﬁcation process.

Certiﬁcation guidance for software in commercial aircraft is found in DO-
178C, Software Considerations in Airborne Systems and Equipment Certiﬁcation
[5]. The process described in DO-178C is essentially a waterfall model in which
system requirements are allocated to hardware and software, becoming high-level
requirements for each. High-level requirements are reﬁned to become a software
design, consisting of software architecture and low-level requirements from which
individual software components can be developed.

DO-178C is accompanied by several supplement documents which provide
guidance for the use of speciﬁc technologies, including formal methods (DO-333
[6]) and model-based development (DO-331 [7]). DO-333 describes how software
life-cycle artifacts such as high and low-level requirements can be expressed as
formal properties and how formal analysis tools can be used to satisfy many
certiﬁcation objectives. DO-331 provides guidance on how software life-cycle ar-
tifacts expressed as diﬀerent types of models ﬁt into the certiﬁcation process.
A case study showing how diﬀerent formal methods can be used to satisfy cer-
tiﬁcation objectives is found in [8], including a model-based example that uses
Simulink [4] and Simulink Design Veriﬁer [9].

DO-331 describes the relationships between models at the system and soft-
ware levels, and distinguishes between speciﬁcation models and design models. A
speciﬁcation model represents high-level requirements that provide an abstract
representation of functional, performance, interface, or safety characteristics of
software components. Speciﬁcation models do not deﬁne software design details
or prescribe a speciﬁc software implementation or architecture. Design models
prescribe software component internal data structures, data ﬂow, and/or control
ﬂow. They may include low-level requirements or architecture, and may be used
to produce source code directly.

Figure 1 provides an overview of our proposed design ﬂow, connecting it
to the terminology used in a DO-178C process. On the left side of Figure 1,
system requirements allocated to software (generally in textual form) are reﬁned
to a collection of high-level software requirements and used to construct an
architecture model in AADL. This process is described in more detail in the next
section. The AADL model is a design model (in DO-331 terminology) because it
contains information such as data ﬂows, message types, and execution rates and
priorities, that will be used to produce source code and conﬁgure the operating
system. High-level requirements associated with each level of the architecture
and software components represented in the architecture are captured into formal
properties. We use the Assume Guarantee Reasoning Environment (AGREE) [1]
to represent these properties as design contracts, and compositional veriﬁcation
is used to show that contracts (requirements) at each level satisfy the contract
of the level above.

Fig. 1. Architecture to Component Design Flow

On the right side of the ﬁgure, software components are implemented and
veriﬁed. Simulink models describe the detailed behaviors and are used to gen-
erate source code for each component. They are therefore considered low-level
requirements and also design models (in DO-331 terms). High-level requirements
for each component are represented as speciﬁcation models (in DO-331 terms).
These models are observers that produce a true output whenever their corre-
sponding property (speciﬁed over the component inputs and outputs) is true. A
model checker such as the one provided by Simulink Design Veriﬁer can be used
to show that the design model satisﬁed the high-level requirements deﬁned by
the speciﬁcation model.

Clearly there is a gap between the methods, tools, and models of the soft-
ware architecture and those for the software components. In the past, high-level
requirements for the software components have been manually captured as ob-
servers in Simulink before they can be used for veriﬁcation [10]. The manual
process may be error-prone, and it it can be diﬃcult and costly to keep the mod-
els in sync. The work we describe in this paper bridges this gap by automating
the translation of high-level requirements associated with the architecture model
into Simulink observers that can be veriﬁed in the Simulink environment.

2.2 Architecture Description and Design Contracts

The Architectural Analysis and Design Language (AADL) [3] is a architecture
modeling language for embedded, real-time, distributed systems. It was approved
as an SAE Standard in 2004, and its standardization committee has active par-
ticipation from many academic and industrial partners in the aerospace industry.
It provides the constructs needed to model both hardware and software in em-

Software ArchitectureSoftware ComponentsAADL (Design model)High Level RequirementsSimulink observer(Specification model)Low Level RequirementsSimulink model(Design model)System Requirements allocated to softwareSource CodeAGREE contract(Formal property)AGREE contract(Formal property)High Level RequirementsAGREE contract(Formal property)TranslationVerificationbedded systems such as threads, processes, processors, buses, and memory. It is
suﬃciently formal for our purposes, and is extensible through the use of language
annexes that can initiate calls to separately developed analysis tools.

The Assume Guarantee Reasoning Environment (AGREE) [1] is a language
and tool for compositional veriﬁcation of AADL models. It is implemented as an
AADL annex that allows AADL models to be annotated with assume-guarantee
behavioral contracts. A contract contains a set of assumptions about the com-
ponent’s inputs and a set of guarantees about the component’s outputs. The
assumptions and guarantees may also contain predicates that reason about how
the state of a component evolves over time.

AGREE uses a syntax similar to Lustre [11] to express a contract’s assump-
tions and guarantees. AGREE translates an AADL model and its contract an-
notations into Lustre and then queries a user-selected model checker to perform
veriﬁcation. The goal of the analysis is to prove that each component’s contract
is satisﬁed by the interaction of its direct subcomponents as described by their
respective contracts. Veriﬁcation is performed at each layer of the architecture
hierarchy and details of lower level components are abstracted away during veri-
ﬁcation of higher level component contracts. This compositional approach allows
large systems to be analyzed eﬃciently.

Component contracts at the lowest level of the architecture are assumed to be
true by AGREE. Veriﬁcation of these component contracts must be performed
outside of the AADL/AGREE environment. In a traditional software develop-
ment process, components will be developed to meet the high-level requirements
corresponding to these contracts and veriﬁed by testing or code review. However,
there are two problems with this approach:

1. Veriﬁcation methodologies like test and code review are not exhaustive. Er-
rors in these activities can cause the compositional veriﬁcation that AGREE
performs to be incorrect.

2. Manual translation of an AGREE contract into a property for veriﬁcation

at the component level can be time-consuming and error-prone.

Our solution to these problems is to automatically translate AGREE con-
tracts of software components into expressions in the development language of
the component software. A formal veriﬁcation tool that reasons about artifacts
expressed in this language can then be used to verify that the contracts hold.
The remainder of the paper describes this solution in detail.

2.3 Component Requirements and Veriﬁcation

The following tools and features are used to capture component level require-
ments and perform veriﬁcation.

Simulink.

Simulink [4], developed by MathWorks and integrated with
MATLAB, provides a graphical programming environment for modeling, sim-
ulation, code generation, testing, and analysis. It is widely used in the Avionics
industry. It is used to capture low-level component design models and require-
ments.

Simulink Design Veriﬁer. The Simulink Design Veriﬁer (SLDV) tool [9],
is a model checker for the Simulink environment. SLDV can verify properties
expressed with MATLAB functions, Simulink blocks, or Stateﬂow diagrams. The
ﬁrst is a textual language while the last two are graphical.

Simulink observer. A Simulink observer is a component in a Simulink
model which observes the behavior of another component and computes a Boolean
value indicating if the latter component is satisfying its requirements. A Simulink
observer along with the component it observes can be veriﬁed using SLDV to
show that the component under observation always satisﬁes its requirements.
Using DO-331 terminology, the Simulink observer is a speciﬁcation model that
captures high-level requirements, while the component it observes is a design
model that captures low-level requirements. Our tool generates Simulink ob-
servers using a MATLAB function block which encapsulates a MATLAB func-
tion. A MATLAB function consists of statements written in the MATLAB script-
ing language, an imperative, dynamically typed language. In addition to a main
function, a MATLAB function block can contain other local functions deﬁned
in the same block. Unlike the other graphical language alternatives, the textual
representation of a MATLAB function makes the export easier to control and
maintain.

3 Detailed Approach

This section details our approach for automatically constructing a speciﬁcation
model from high level requirements.

3.1 Export Scheme Overview

The requirements used to generate each speciﬁcation model come directly from a
component contract speciﬁed in AGREE. Each speciﬁcation model is a Simulink
observer implemented as a MATLAB function. The observer’s interface is gen-
erated from the component’s features described in the AADL model.

Table 1 provides a summary of the constructs that appear in an AGREE
contract and their mapping in MATLAB. The speciﬁcation model generation
process is divided into two major steps, as depicted in Figure 2:

1. The tool produces an intermediate speciﬁcation in Lustre. The Lustre lan-
guage [11] is a synchronous dataﬂow language for modeling reactive sys-
tems, with formalisms similar to temporal logics [12]. The AGREE grammar
and the Lustre grammar are very similar. This makes Lustre well suited as
a common intermediate language to feed into diﬀerent formal analysis or
translation engines. A number of common translation steps are performed
to create this intermediate format. For example, variable assignments are
put into data-ﬂow order, all function calls are inlined, and nested temporal
expressions are decoupled.

Table 1. Mapping between AGREE and MATLAB Constructs

AGREE Constructs
Component contract1

MATLAB Constructs

Simulink observer

Component inputs and outputs1

Inputs to the Simulink observer2

Assume statement

Proof assumption

assume “B input range” : Input < 20

sldv.assume(Input < 20)

Guarantee statement

guarantee “B output range” :

Output < Input + 15

Equation statement

Proof objective

sldv.prove(Output < (Input + 15))

Assignments

eq Active : bool = not Sync.Active

Active = not(Sync.Active)

If-then-else expression

Generated local function

if Error then false else Active

AGREE basic data types

int
real
bool

ifFunction(Error , false, Active)
MATLAB built-in data types2

(u)int8, (u)int16, (u)int32

single, double

boolean

Record types (on inputs and outputs)

Simulink bus objects

AGREE operators
-, not, <>, and, or

+, −, ∗, /, >, <, >=, <=

mod operator

= (equal operator)

div (integer divide operator)

⇒
→
pre

MATLAB operators or function calls

-, ∼, ∼=, &&, (cid:107)

+, −, ∗, /, >, <, >=, <=

mod function

isequal function3

/ with operands typecast to integer types

generated local impliesFunction
generated local arrowFunction 4

persistent variable for the operand4

1 This information comes from the component type in AADL.
2 Data size selection based on user input (Section 3.3).
3 Use isequal function rather than == to apply to structure types
4 The translation for → and pre operators need persistent variables (Section 3.2).

Fig. 2. Implementation Scheme

2. From the intermediate Lustre a MATLAB function is produced. The MAT-
LAB function is speciﬁed by an abstract syntax tree (AST). This allows for
structured, easily extendable export. MATLAB speciﬁc features introduced
in this translation include constructing valid MATLAB identiﬁers with no
duplications and turning local structures in the intermediate output into
local variables to eliminate any dynamically allocated structures.

3.2 Translation for Temporal Constructs

There are two types of temporal constructs used in AGREE:
– The inﬁx → operator evaluates to the left-hand side expression in the model’s
initial state, otherwise it evaluates to the right-hand side expression. For
example, the expression true → false is true in the initial state and false
forever after.

– The preﬁx pre operator, e.g., pre(Current Mode), evaluates to the value of

its given expression in the model’s previous state.

The above temporal constructs are typically used in combination. Any oc-
currence of a pre operator must be on the right hand side of an arrow expression.
For example, the expression x = (pre(x) + 1) is not well formed, but the expres-
sion x = (0 → pre(x) + 1) is well formed. Multiple pre operators can be nested
as long as there is a → guarding each use of the operator. However, nested uses
of pre are translated out of the intermediate Lustre format.

AGREE Program AGREE ASTLustre ASTMATLAB Function ASTMATLAB Function Outputsystem top_level  features    Input: in data port Base_Types::Float;    Output: out data port Base_Types::Float;      annex agree {**         assume "System input range" : Input <= 10.0;        guarantee "System output range" : Output < 50.0;      **};end top_level;node top_level_Impl_Instance(  Input : real; Output : real) returns ();var  __GUARANTEE0 : bool;let  __GUARANTEE0 = (Output < 50.0);  assert (Input <= 10.0);  --%PROPERTY __GUARANTEE0;tel;function check_top_level_Impl_Instance(Input, Output)  GUARANTEE0 = (Output < double(50.0));  sldv.assume((Input <= 10.0))  sldv.prove(GUARANTEE0)endTo represent temporal constructs, the Simulink observer needs to diﬀerentiate
the behavior at the initial state from the other states. It also needs to remember
variable values from the previous call to the function. We make use of persistent
variables to record the previous state of the function’s variables across multiple
calls.

A single persistent Boolean variable, ﬁrst time, is used to indicate whether or
not the function has been called previously. Additionally, a persistent variable is
created for each unique pre expression1. We refer to these variables as the “pre
variables.” The persistent variables used to model the → and pre operations
appear in the following contexts in the Simulink observer:

1. Declaration. Each of these persistent variables is declared at the beginning
of the function. MATLAB is dynamically typed, so the type of these variables
is determined during their initialization.

2. Initialization. The initialization of a persistent variable occurs immedi-
ately after its declaration. The built-in function “isempty” is used to deter-
mine whether or not the observer has been executed previously. For example,
this is how the ﬁrst time variable is initialized:

if isemtpy(ﬁrst time)

ﬁrst time = true;

end

The pre variables are initialized to the default value for their type (e.g., true
for booleans, 0 for integers, and 0 for ﬂoating points). Because all occurrences
of pre operators are guarded by → operators, this initial value is never used.
This initialization takes place for the sole purpose of allowing the MATLAB
code generator to function properly.

3. Use. Each of these persistent variables is used in place of its corresponding

pre expression.

4. Update. Before the observer function returns, all of the pre variables are
updated to the current value of their expression. For example, the persistent
variable for the expression pre(x) is updated to the value of x. This ensures
that the next time the function is called the pre variables hold the value of
their expression from the previous state. The ﬁrst time variable is always
set to false before the observer function returns.

3.3 Translation for Data Types

Here we note diﬀerences between the data types of AGREE and MATLAB.

Constants. Any constant numbers (integers or ﬂoats) that appear in a
MATLAB function are assumed to be double precision ﬂoating point numbers.
Therefore, explicit typecasts are needed when translating constants from the
AGREE speciﬁcations.

1 For example, if the term pre(x) appears multiple times in the AGREE contract, we

only create a single persistent variable for this expression

Arbitrary Data Size vs. Fixed Data Size. AGREE assumes that inte-
ger and real valued variables have arbitrary size. However, MATLAB’s primitive
data types for integers are of bounded size (integers are represented by 8-bit, 16-
bit, 32-bit, or 64-bit 2’s complement numbers). Similarly, MATLAB uses ﬂoating
point arithmetic to represent non-integers. Integer valued variables in AGREE
are translated to ﬁxed size integers in MATLAB. Similarly, real valued vari-
ables in AGREE are translated to ﬂoating point variables in MATLAB. The
size/precision of the translated variables can be changed easily by users.

This mismatch in types can cause diﬀerences in semantics for some contracts
described in AGREE and their corresponding Simulink observers. Moreover, we
note that SLDV interprets ﬂoating point variables as real variables as well. So it
suﬀers from the same mismatch in semantics for ﬂoating point vs. real numbers.
In the future we plan to allow users to specify bit-vector types in AGREE.

3.4 Workﬂow

We have implemented the export scheme as an extension to AGREE, available
at [13]. The export process has the following steps:

1. Select Data Types. Users may select one of the MATLAB supported
integer types (i.e., (u)int8, (u)int16, (u)int32, (u)int64) to represent integers
in AGREE and one of the MATLAB supported ﬂoating point types (i.e.,
single, double) to represent reals in AGREE.

2. Export Design Contracts. For any component with an AGREE con-
tract, the user can invoke the tool to translate the contract into a MATLAB
function.

3. Update Simulink Model. A script ﬁle provided by the toolset auto-
matically packages the MATLAB function generated above as a MATLAB
function block and connects the function block to the inputs and outputs
of the component’s Simulink model. The augmented Simulink model is the
veriﬁcation model for the component that contains both a design model and
a speciﬁcation model that observes the design model.

4. Invoke Simulink Design Veriﬁer (SLDV). Users can invoke SLDV on
the veriﬁcation model generated in the above step. SLDV checks to see if all
properties in the MATLAB function are true, and provides counterexamples
for the ones that are falsiﬁed.

4 Case Studies

In this section, we evaluate and demonstrate the eﬀectiveness of the export
techniques in two case studies: 1) an avionics braking and steering control unit
and 2) a medical infusion pump. The workﬂow was tested with the latest version
of the AGREE toolset and MATLAB Release 2015b.

As our export tool has not yet been qualiﬁed [14], for each case study, the
speciﬁcation model generated by the tool is manually reviewed against the orig-
inal contracts and design information in AGREE and AADL to assess if the
high-level requirements have been maintained.

4.1 Avionics Braking and Steering Control Unit

Overview. The avionics Braking and Steering Control Unit (BSCU) is a
computer located in an aircraft’s Wheel Braking System (WBS), controlling
the “Normal braking, Autobrake, Nose Wheel Steering Aid and Antiskid func-
tions” [15]. The speciﬁcation of the BSCU came from prior veriﬁcation eﬀorts [15]
based on the report of an Airbus A-320 accident which occurred on May 21,
1998 [16]. In that accident, both the normal and alternate braking systems
failed on landing. The loss of the normal braking system was caused by logic
disagreement in the BSCU.

The BSCU system consists of two functionally identical channels, with only
one channel being active at a time. When a fault is detected in the active chan-
nel, the standby channel becomes active if it is not faulty. Each channel contains
a command function unit (COM component) and a monitor function unit (MON
component). Both the COM and MON components compute the braking pres-
sure to be applied based on their braking mode. Their outputs are compared at
the MON function unit, and a fault will be logged when there is a disagreement
between the outputs.

The COM and MON units operate in four braking modes: MANUAL, LO,
MED, MAX. In MANUAL mode, the computed breaking pressure is mainly
determined by the pressure on the brake pedal applied by the pilot. Other modes
are Autobrake modes selected when pilot presses one of the LO, MED, or MAX
buttons on the AUTO BRK panel, providing low, medium, and maximum levels
of deceleration. Each unit starts in the MANUAL mode, and can transition to
another mode when the associated button is pressed once; pressing the same
button again transitions the unit back to MANUAL mode.

For this speciﬁc case study, the system architecture was previously modeled
in AADL, and the design contracts between the components were speciﬁed in
AGREE. Prior work [15] has found a disagreement in detecting a button push
between the COM and MON component and ﬁxed it by updating the design
contracts in the architecture model.

For this case study, we created Simulink models for the COM and MON
components. This was a manual design process to interpret the high-level re-
quirements into a design model. The behaviors of the COM and MON models
were intended to satisfy all AGREE contracts for the COM and MON compo-
nents in AADL.

For each component, we exported the design contract to a Simulink observer
and connected it to the corresponding Simulink model. The augmented model
encompassed both the design models and the speciﬁcation model for the com-
ponent. We ran Simulink Design Veriﬁer (SLDV) on the augmented model to
discover which properties were validated and which were not. For the falsiﬁed
properties, SLDV produced a counterexample.

Results and Findings. Two types of falsiﬁed properties were found during
the veriﬁcation process. The ﬁrst type was caused by a discrepancy on the be-
havior of the initial step. The second type was due to a discrepancy on the value
of a global parameter used to indicate if the component is currently in an active

channel. In both cases, the Simulink design model failed to interpret the speciﬁc
design detail as presented in AGREE. Such discrepancies were missed from the
ﬁrst round of manual review of the models. After updating the Simulink model
to match the design contracts, all properties speciﬁed in the Simulink observer
were veriﬁed.

Investigation of the counterexamples was carried out by comparing the values
of the intermediate signals computed in the model and in the Simulink observer
during the simulation of the counterexamples. Having the speciﬁcation model
and design model co-located in the same environment allowed the simulation to
compare their values during runtime.

The veriﬁcation results demonstrate the beneﬁt of using formal veriﬁcation
over manual review or simulation/testing, as it reasons about all execution paths
and identiﬁes design ﬂaws that can be missed by other methods.

Automatically exporting AGREE contracts to Simulink observers allows fast
turn-around in veriﬁcation. The veriﬁcation of the Simulink design model can
be conducted as soon as the model is created. This supports early and frequent
veriﬁcation starting from the design phase. It also reduces errors that are easily
introduced from manual interpretations, especially for large components with
complex contracts.

4.2 Generic Patient Controlled Analgesic Infusion Software

Overview. The Generic Patient Controlled Analgesic (GPCA) infusion pump
system [10] is a medical cyber-physical system “used for controlled delivery of
liquid drugs into a patient’s body according to a physician’s prescription (the
set of instructions that governs infusion rates for a medication).” [10]. It allows
patients to administer a controlled amount of drug (typically a pain medication)
themselves. It consists of four main components: Alarm, Infusion, Mode, and
Logging. They are used to monitor the exceptional conditions and notify the
clinician, determine the ﬂow of drug, manage the mode, and log the status of
the system. Detailed information on GPCA requirements can be found in [17].
The workﬂow for this case study was similar to the BSCU case study, except
that the Simulink design models for the components, as well as the Simulink
observer for the properties of the design models, had been manually created in
prior work [17]. In this case study, we reused the design model created for each
component, and we replaced the existing (manually created) Simulink observers
with the ones generated by our tool from the corresponding AGREE contracts.
The updated models were then veriﬁed using Simulink Design Veriﬁer and the
veriﬁcation results from both models were compared.

Results and Findings. For both the manual and auto version of the
Simulink observer, the veriﬁcation results identiﬁed falsiﬁed properties due to the
design model not behaving as expected. The veriﬁcation time between the two
versions were comparable (within 10 seconds). Some properties were undecided
after reaching the maximum analysis time (set at 1200 seconds) for both versions.
Although the manually created versions of the Simulink observers are still a

work in progress, we can make the following observations:

1. The manual properties tended to address the simpler, more straightforward
contracts in AGREE, and they often missed modeling the temporal con-
structs from AGREE (i.e.,pre and → operators). Automation now allows us
to easily translate even the complex contracts.

2. The manual properties tended to lag behind the AGREE contract updates,
resulting in diﬀerent veriﬁcation results between the manual and automated
versions for the same AGREE contract. Automation makes it easy to keep
all the models synchronized.

3. The manual properties used Simulink unit delays outside of the MATLAB
function to interpret the pre operator, a translation that preserves the mean-
ing but is not easy to automate.

4. The manual properties selected signals from bus elements outside of the
MATLAB function, while the auto translated properties did bus element
selection inside the MATLAB function. The latter is a design choice that is
easier to automate and maintain.

We found the beneﬁts of automatically connecting the created Simulink ob-
server to the design model through a counterexample. In this counterexample,
one input port to the design model and the Simulink observer was a duplicate
(diﬀerent port numbers and treated as diﬀerent ports) instead of a replicate
(same port number and treated as the same port). This made the observer not a
synchronous one, and yielded diﬀerent veriﬁcation results from the version that
had the Simulink observer auto connected.

We also found design details introduced in the Simulink model that did not
conform to the interface design in AGREE. For example, for an input port of
record type in AGREE, its counterpart in Simulink (of Simulink bus type) had
additional elements and elements with diﬀerent names. While it is understand-
able that the design model may introduce new details needed for the component,
any new design details that aﬀect the interface should be synchronized with the
AGREE model.

5 Related Work

The idea of auto generating test cases from higher level requirements has been
the subject of intensive study in both the academia and industry [18,19,20]. Cre-
ating properties for formal veriﬁcation from higher level requirements, has been
performed manually [21,10], through patterns [22], and automatically [23,24].
The unique contribution of our work is a method for automatically exporting
high-level requirements from a system-level reasoning framework as property
observers in a component-level modeling framework. This enables formal veriﬁ-
cation of the component requirements as they are developed, bridging the gap
between system-level and component-level reasoning. The compositional reason-
ing framework OCRA [25] has similar goals as AGREE. Both frameworks reason
hierarchically about a system of components with connections and contracts.
However, as far as we know, there are no tools to translate OCRA contracts to
observers in speciﬁcation languages commonly used in the avionics industry.

6 Conclusions

In this paper we have described a method for translating design contracts for
components in an AADL software architecture model into speciﬁcation models
that can be veriﬁed at the component level. We have provided tool support for ex-
port as Simulink observers that can be veriﬁed using the Simulink Design Veriﬁer.
Moreover, our approach is suﬃciently general that other component development
environments could be easily targeted. This approach is built upon the AGREE
compositional analysis framework that allows veriﬁcation of requirements during
architecture development, prior to software component implementation. Apply-
ing the technique on an avionics system and a medical device system has shown
that the design contracts from the architecture model were faithfully exported,
and saved time and reduced errors compared to the manual eﬀort. Our approach
also allowed veriﬁcation to proceed in parallel with software development.

Possible future work includes qualifying the export tool in accordance with
avionics certiﬁcation guidelines [14] and enhancing the usability of the tool by
supporting automatic re-veriﬁcation when design contracts are updated.

Acknowledgments. This work was funded by NASA under contract
NNA13AA21C (Compositional Veriﬁcation of Flight Critical Systems). We would
like to thank Chad Van Fleet, Anitha Murugesan, and Mike Whalen for their
valuable feedback during this work.

References

1. Cofer, D., Gacek, A., Miller, S., Whalen, M.W., LaValley, B., Sha, L.: Com-
positional veriﬁcation of architectural models.
In: Proceedings of the 4th In-
ternational Conference on NASA Formal Methods. NFM’12, Berlin, Heidelberg,
Springer-Verlag (2012) 126–140

2. Whalen, M.W., Gacek, A., Cofer, D.D., Murugesan, A., Heimdahl, M.P.E.,
Rayadurgam, S.: Your ”what” is my ”how”: Iteration and hierarchy in system
design. IEEE Software 30 (2013) 54–60

3. Feiler, P.H., Gluch, D.P.: Model-Based Engineering with AADL: An Introduction
to the SAE Architecture Analysis & Design Language. 1st edn. Addison-Wesley
Professional (2012)

4. MathWorks: Simulink (2016) http://www.mathworks.com/products/simulink/.
5. RTCA DO-178C: Software Considerations in Airborne Systems and Equipment

Certiﬁcation, Washington, DC. (2011)

6. RTCA DO-333: Formal Methods Supplement to DO-178C and DO-278A, Wash-

ington, DC. (2011)

7. RTCA DO-331: Model-Based Development and Veriﬁcation Supplement to DO-

178C and DO-278A, Washington, DC. (2011)

8. Cofer, D., Miller, S.P.: Formal methods case studies for do-333, nasa contractor

report nasa/cr-2014-218244 (2014)

9. MathWorks: Simulink (2016) http://www.mathworks.com/products/sldesignveriﬁer/.

10. Murugesan, A., Whalen, M.W., Rayadurgam, S., Heimdahl, M.P.: Compositional
In: ACM Int’l Conf. on High Integrity

veriﬁcation of a medical device system.
Language Technology (HILT) 2013, ACM (2013)

11. Halbwachs, N., Caspi, P., Raymond, P., Pilaud, D.: The synchronous dataﬂow
programming language LUSTRE. In: Proceedings of the IEEE. (1991) 1305–1320
12. Huth, M., Ryan, M.: Logic in Computer Science: modelling and reasoning about

systems (second edition). Cambridge University Press (2004)

13. Backes, J., et al.: AGREE toolset (2016) http://loonwerks.com/tools/agree.html.
14. RTCA DO-330: Software Tool Qualiﬁcation Considerations, Washington, DC.

(2011)

15. Miller, S.P., Bhattacharyya, S., Tinelli, C., Smolka, S., Sticksel, C., Meng, B.,
Yang, J.: Formal veriﬁcation of quasi-synchronous systems (2015) Final Technical
Report delivered Air Force Research Laboratory.

16. Accident, C.A., Incident Investigation Commission (CIAIAC), S.: Technical report:
Accident occurred on 21may 1998 to aircraft airbus a-320-21 registration g-ukll at
ibiza airport, balearic islands (1998)

17. CriSys Group: Generic patient controlled analgesia infusion pump project (2016)

http://crisys.cs.umn.edu/gpca.shtml.

18. Wang, C., Pastore, F., Goknil, A., Briand, L., Iqbal, Z.: Automatic generation
In: Proceedings of the 2015
of system test cases from use case speciﬁcations.
International Symposium on Software Testing and Analysis. ISSTA 2015, New
York, NY, USA, ACM (2015) 385–396

19. Ibrahim, R., Saringat, M., Ibrahim, N., Ismail, N.: An automatic tool for gener-
ating test cases from the system’s requirements. In: Computer and Information
Technology, 2007. CIT 2007. 7th IEEE International Conference on. (2007) 861–
866

20. Escalona, M.J., Gutierrez, J.J., Mej´ıas, M., Arag´on, G., Ramos, I., Torres, J.,
Dom´ınguez, F.J.: An overview on test generation from functional requirements. J.
Syst. Softw. 84 (2011) 1379–1393

21. Miller, S.P., Tribble, A.C., Whalen, M.W., Heimdahl, M.P.E.: Proving the shalls:
Int. J. Softw. Tools

Early validation of requirements through formal methods.
Technol. Transf. 8 (2006) 303–319

22. Bozzano, M., Cimatti, A., Katoen, J., Katsaros, P., Mokos, K., Nguyen, V.Y.,
Noll, T., Postma, B., Roveri, M.: Spacecraft early design validation using formal
methods. Rel. Eng. & Sys. Safety 132 (2014) 20–35

23. Silva, W., Bezerra, E., Winterholer, M., Lettnin, D.: Automatic property gener-
ation for formal veriﬁcation applied to hdl-based design of an on-board computer
for space applications. In: Test Workshop (LATW), 2013 14th Latin American.
(2013) 1–6

24. Soeken, M., Kuhne, U., Freibothe, M., Fe, G., Drechsler, R.: Automatic property
generation for the formal veriﬁcation of bus bridges. In: Design and Diagnostics of
Electronic Circuits Systems (DDECS), 2011 IEEE 14th International Symposium
on. (2011) 417–422

25. Cimatti, A., Tonetta, S.: Contracts-reﬁnement proof system for component-based
embedded systems. Science of Computer Programming 97, Part 3 (2015) 333–348

