Static and Dynamic Feature Selection in Morphosyntactic Analyzers

Bernd Bohnet♠ Miguel Ballesteros♦♣ Ryan McDonald♠ Joakim Nivre♥

♠Google Inc. London, United Kingdom.

♦NLP Group, Pompeu Fabra University, Barcelona, Spain

♣School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
♥Uppsala University. Department of Linguistics and Philology. Uppsala, Sweden

{bohnetbd,ryanmcd}@google.com, miguel.ballesteros@upf.edu, joakim.nivre@lingfil.uu.se

6
1
0
2

 
r
a

 

M
1
2

 
 
]
L
C
.
s
c
[
 
 

1
v
3
0
5
6
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

We study the use of greedy feature selec-
tion methods for morphosyntactic tagging
under a number of different conditions.
We compare a static ordering of features
to a dynamic ordering based on mutual
information statistics, and we apply the
techniques to standalone taggers as well as
joint systems for tagging and parsing. Ex-
periments on ﬁve languages show that fea-
ture selection can result in more compact
models as well as higher accuracy under
all conditions, but also that a dynamic or-
dering works better than a static ordering
and that joint systems beneﬁt more than
standalone taggers. We also show that
the same techniques can be used to select
which morphosyntactic categories to pre-
dict in order to maximize syntactic accu-
racy in a joint system. Our ﬁnal results
represent a substantial improvement of the
state of the art for several languages, while
at the same time reducing both the number
of features and the running time by up to
80% in some cases.

1 Introduction

Morphosyntactic tagging, whether limited to basic
part-of-speech tags or using rich morphosyntactic
features, is a fundamental task in natural language
processing, used in a variety of applications from
machine translation (Habash and Sadat, 2006) to
information extraction (Banko et al., 2007). In ad-
dition, tagging can be the ﬁrst step of a syntac-
tic analysis, providing a shallow, non-hierarchical
representation of syntactic structure.

two different paradigms:

Morphosyntactic taggers tend to belong to
one of
standalone
Standalone tag-
taggers or
gers use narrow contextual
representations,
typically an n-gram window of ﬁxed size.

taggers.

joint

tags

parsing

results,

taggers,

In dependency

To achieve state-of-the-art
they em-
ploy sophisticated optimization techniques in
combination with rich feature representations
(Brants, 2000;
Toutanova and Manning, 2000;
Gim´enez and M`arquez, 2004;
M¨uller et al., 2013).
Joint
on the
combine morphosyntactic
other hand,
tag-
ging with deeper syntactic processing.
The
most common case is parsers
that predict
constituency structures
jointly with part-of-
speech
(Charniak and Johnson, 2005;
Petrov et al., 2006) or richer word morphology
Goldberg and Tsarfaty (2008).
parsing,

pipeline models
recent
have traditionally been the norm, but
tagging and
studies have shown that
dependency
accuracy
can
of both (Lee et al., 2011; Hatori et al., 2011;
Bohnet and Nivre, 2012;
Bohnet et al., 2013).
Unfortunately, joint models typically increase the
search space, making them more cumbersome
than their pipeline equivalents. For instance, in the
joint morphosyntactic transition-based parser of
Bohnet et al. (2013), the number of parser actions
increases linearly by the size of the part-of-speech
and/or morphological
For some
languages this can be quite large. For example,
M¨uller et al. (2013) report morphological tag sets
of size 1,000 or more.

joint
improve

label sets.

The promise of joint tagging and parsing is
that by trading-off surface morphosyntactic pre-
dictions with longer distance dependency predic-
tions, accuracy can be improved. However, it
is unlikely that every decision will beneﬁt from
this trade-off. Local n-gram context is sufﬁcient
for many tagging decisions, and parsing decisions
likely only beneﬁt from morphological attributes
that correlate with syntactic functions, like case,
or those that constrain agreement, like gender or
number. At the same time, while standalone mor-
phosyntactic taggers require large feature sets in
order to make accurate predictions,
it may be

the case that fewer features are needed in a joint
model, where these predictions are made in tan-
dem with dependency decisions of larger scope.
This naturally raises the question as to whether
we can advantageously optimize feature sets at the
tagger and parser levels in joint parsing systems to
alleviate their inherent complexity.

We investigate this question in the con-
the joint morphosyntactic parser of
text of
Bohnet et al. (2013), focusing on optimizing and
compressing feature sets via greedy feature se-
lection techniques, and explicitly contrasting joint
systems with standalone taggers. The main ﬁnd-
ings emerging from our investigations are:

• Feature selection works for standalone tag-
gers but is more effective in a joint system.
This holds for model size as well as tagging
accuracy (and parsing accuracy as a result).

• Dynamic feature selection strategies that take
feature redundancy into account often lead
to more compact models than static selection
strategies with little loss in accuracy.

• Similar selection techniques can also reduce
the set of morphological attributes to be pre-
dicted jointly with parsing, reducing the size
of the output space at no cost in accuracy.

The key to all our ﬁndings is that these techniques
simultaneously compress model size and/or de-
crease the search space while increasing the un-
derlying accuracy of tagging and parsing, even
surpassing the state of the art in a variety of
languages. With respect to the former, we ob-
serve empirical speed-ups upwards of 5x. With
respect to the latter, we show that the resulting
morphosyntactic taggers consistently beat state-
of-the-art taggers across a number of languages.

2 Related Work

Since morphosyntactc tagging interacts with other
tasks such as word segmentation and syntactic
parsing, there has been an increasing interest in
joint models that integrate tagging with these other
tasks. This line of work includes joint tagging and
segmentation
word
(Zhang and Clark, 2008a),
tagging and named entity recognition
joint
tagging
(M´ora and Vincze, 2012),
and
parsing
Li et al., 2011;
Bohnet and Nivre, 2012;
Hatori et al., 2011;

(Lee et al., 2011;

joint

Bohnet et al., 2013), and even joint word segmen-
tation, tagging and parsing (Hatori et al., 2012).
These studies often show improved accuracy from
joint inference in one or all of the tasks involved.
Feature selection has been a staple of statisti-
cal NLP since its beginnings, notably selection
via frequency cut-offs in part-of-speech tagging
(Ratnaparkhi, 1996). Since then efforts have been
made to tie feature selection with model optimiza-
tion. For instance, McCallum and Li (2003) used
greedy forward selection with respect to model
log-likelihood to select features for named entity
recognition. Sparse priors, such as L1 regular-
ization, are a common feature selection technique
that trades off feature sparsity with the model’s
objective (Gao et al., 2007). Martins et al. (2011)
extended such sparse regularization techniques to
allow a model to deselect entire feature templates,
potentially saving entire blocks of feature extrac-
tion computation. However, current systems still
tend to employ millions of features without se-
lection, relying primarily on model regulariza-
tion to combat overﬁtting.
Selection of mor-
phological attributes has been carried out previ-
ously in Ballesteros (2013) and selection of fea-
tures under similar constraints was carried out by
Ballesteros and Bohnet (2014).

3 Feature Selection

The feature selection methods we investigate can
all be viewed as greedy forward selection, shown
in Figure 1. This paradigm starts from an empty
set and considers features one by one. In each iter-
ation, a model is generated from a training set and
tested on a development set relative to some accu-
racy metric of interest. The feature under consid-
eration is added if it increases this metric beyond
some threshold and discarded otherwise.

This strategy is similar to the one implemented
in MaltOptimizer (Ballesteros and Nivre, 2014).
It differs from classic forward feature selection
(Della Pietra et al., 1997) in that it does not test all
features in parallel, but instead relies on an order-
ing of features as input. This is primarily for ef-
ﬁciency, as training models in parallel for a large
number of feature templates is cumbersome.

The set of features, F , can be deﬁned as fully in-
stantiated input features, e.g., sufﬁx=ing, or as fea-
ture templates, e.g., preﬁx, sufﬁx, form, etc. Here
we always focus on the latter. By reducing the
number of feature templates, we are more likely to

Let F = {F1, . . . , Fn} be the full set of features,
let M (X) be the evaluation metric for feature set X,
let Order(F ) be an ordering function over a feature set F ,
and let ∆ be the threshold.

1 B ← 0
2 X ← ∅
3 while |F | 6= 0
Order(F )
4
if M (X ∪ {F0}) + ∆ > B then
5
6
7
8
9

B ← M (X ∪ {F0})
X ← X ∪ {F0}

F ← F − {F0}

return X

Figure 1: Algorithm for forward feature selection.

positively affect the runtime of feature extraction,
as many computations can simply be removed.

3.1 Static Feature Ordering

Our feature selection algorithm assumes a given
order of the features to be evaluated against the
objective function. One simple strategy is for a hu-
man to provide a static ordering on features, that is
ﬁxed for traversal. This means that we are testing
feature templates in a predeﬁned order and keep-
ing those that improve the accuracy. Those that
do not are discarded and never visited again. In
Figure 1, this means that the Order(F ) function
is ﬁxed throughout the procedure. In our experi-
ments, this ﬁxed order is the same as in Table 1.

3.2 Dynamic Feature Ordering

In text categorization,
static feature selection
based on correlation statistics is a popular tech-
nique (Yang and Pedersen, 1997).
The typical
strategy in such ofﬂine selectors is to rank each
feature by its correlation to the output space, and
to select the top K features. This strategy is often
called max relevance, since it aims to optimize the
features based solely to their predictive power.

Unfortunately, the n best features selected by
these algorithms might not provide the best result
(Peng et al., 2005). Redundancy among the fea-
tures is the primary reason for this, and Peng et
al. develop the minimal redundancy maximal rel-
evance (MRMR) technique to address this prob-
lem. The MRMR method tries to keep the redun-
dancy minimal among the features. The approach
is based on mutual information to compute the rel-
evance of features and the redundancy of a feature
in relation to a set of already selected features.

The mutual information of two discrete random

variables X and Y is deﬁned as follows

I(X; Y ) = P

x∈X

P

y∈Y

p(x, y)log2

p(x,y)

p(x)p(y)

Max relevance selects the feature set X that maxi-
mizes the mutual information of feature templates
Xi ∈ X and the output classes c ∈ C.

max D(X, C), D(X, C) =

1
|X| X

Xi∈X

I(Xi; C).

To account for cases when features are highly re-
dundant, and thus would not change much the dis-
criminative power of a classiﬁer, the following cri-
terion can be added to minimize mutual informa-
tion between selected feature templates:

min R(X), R(X) =

1
|X 2| X

Xi,Xj ∈X

I(Xi; Xj)

Minimal redundancy maximal relevance (MRMR)
combines both objectives:

max Φ(D, R), Φ = D(X, C) − R(X)

For the greedy feature selection method outlined
Figure 1, we can use the MRMR criteria to deﬁne
the Order(F ) function. This leads to a dynamic
feature selection technique as we update the order
of features considered dynamically at each itera-
tion, taking into account redundancy amongst al-
ready selected features.

as

greedy

This technique can be seen in the same
summarization
document
light
(Carbonell and Goldstein, 1998),
sen-
tences are selected for a summary if they are both
relevant and minimally redundant with sentences
previously selected.

where

4 Morphosyntactic Tagging

In this section, we describe the two systems for
morphosyntactic tagging we use to compare fea-
ture selection techniques.

4.1 Standalone Tagger
The ﬁrst tagger is a standalone SVM tagger, whose
training regime is shown in Figure 2. The tag-
ger iterates up to k times (typically twice) over
a sentence from left to right (line 2). This iter-
ation is performed to allow the ﬁnal assignment
of tags to beneﬁt from tag features on both sides
of the target token. For each token of the sen-
tence, the tagger initializes an n-best list and ex-
tracts features for the token in question (line 4-
7).
In the innermost loop (line 9-11), the algo-

// for each token in sentence x
for t ← 1 .. length(x)

// iterate k times over each sentence
for j ← 1 .. k

x ∈ X is a sentence and wdim(P ) are weight vectors
TAG(x, wdim(P ))
1
2
3
4
5
6
7
8
9
10
11
12

nbest[t] ← []
// extract the features for token t
ft ← f (x, t, nbest)
// for each part-of-speech tag p
for each p ∈ P

score ← wp · ft
nbest[t] ←INSERT-PAIR (nbest[t], (p, score))

return nbest

Figure 2: Algorithm for standalone tagger

rithm computes the score for each morphosyntac-
tic tag and inserts a pair consisting of the mor-
phosyntactic tag and its score into the n-best list.
The algorithm returns a two dimensional array,
where the ﬁrst dimension contains the tokens and
the second dimension contains the sorted lists of
tag-score pairs. The tagger is trained online us-
ing MIRA (Crammer et al., 2006). When evalu-
ating this system as a standalone tagger, we se-
lect the 1-best tag. This can be viewed as a
multi-pass version of standard SVM-based tag-
ging (M`arquez and Gim´enez, 2004).

4.2

Joint Dependency-Based Tagger

tagger-parser

follows the design of
The joint
Bohnet et al. (2013), who augment
an arc-
standard transition-based dependency parser with
the capability to select a part-of-speech tag and/or
morphological tag for each input word from an
n-best list of tags for that word. The tag selection
is carried out when an input word is shifted onto
the stack. Only the k highest-scoring tokens from
each n-best list are considered, and only tags
whose score is at most α below the score of the
best tag.
In all experiments of this paper, we
set k to 2 and α to 0.25. The tagger-parser uses
beam search to ﬁnd the highest scoring combined
tagging and dependency tree. When pruning
the beam, it ﬁrst extracts the 40 highest scoring
distinct dependency trees and then up to 8 variants
that differ only with respect to the tagging, a
technique that was found by Bohnet et al. (2013)
to give a good balance between tagging and pars-
ing ambiguity in the beam. The tagger-parser is
trained using the same online learning algorithm
as the standalone tagger. When evaluating this
system as a part-of-speech tagger, we consider
only the ﬁnally selected tag sequence in the
dependency tree output by the parser.

5 Part-of-Speech Tagging Experiments

To simplify matters, we start by investigating fea-
ture selection for part-of-speech taggers, both in
the context of standalone and joint systems. The
main hypotheses we are testing is whether fea-
ture selection techniques are more powerful in
joint morphosyntactic systems as opposed to stan-
dalone taggers. That is, the resulting models are
both more compact and accurate. Additionally, we
wish to empirically compare the impact of static
versus dynamic feature selection techniques.

5.1 Data Sets
We experiment with corpora from ﬁve different
languages: Chinese, English, German, Hungarian
and Russian.
For Chinese, we use the Penn
Chinese Treebank 5.1 (CTB5), converted with
the head-ﬁnding rules, conversion tools and with
the same split as in Zhang and Clark (2008b).1
For English, we use the WSJ section of the
Penn Treebank, converted with the head-ﬁnding
rules of Yamada and Matsumoto (2003) and the
labeling rules of Nivre (2006).2
For German,
we use the Tiger Treebank (Brants et al., 2002)
in the improved dependency conversion by
Seeker and Kuhn (2012).
For Hungarian,
the Szeged Dependency Treebank
we use
(Farkas et al., 2012).
For Russian we use the
SynTagRus Treebank (Boguslavsky et al., 2000;
Boguslavsky et al., 2002).

5.2 Feature Templates
Table 1 presents the feature templates that we em-
ployed in our experiments (second column). The
name of the functor indicates the purpose of the
feature template. For instance, the functor form
deﬁnes the word form. The argument speciﬁes the
location of the token, for instance, form(w+1) de-
notes the token to the right of the current token w.
When more than one argument is given, the
functor is applied to each deﬁned position and the
results are concatenated. Thus, form(w,w+1) ex-
pands to form(w)+form(w+1). The functor formlc
denotes the form with all letters converted to low-
ercase and lem denotes the lemma of a word. The
functors sufﬁx1, sufﬁx2,... and preﬁx1,... denote
sufﬁxes and preﬁxes of length 1, 2, ..., 5. The suf-
ﬁx1+uc, ... functors concatenates a sufﬁx with a

1Training: 001–815, 1001–1136. Development: 886–

931, 1148–1151. Test: 816–885, 1137–1147.

2Training: 02-21. Development: 24. Test: 23.

value that indicates uppercase or lowercase word.
The functors pos and mor denote part-of-speech
tags and morphological tags, respectively. The
tags to the right of the current position are avail-
able as features in the second iteration of the stan-
dalone tagger as well as in the ﬁnal resolution
stage in the joint system. Patterns of the form ci
denote the ith character. Finally, the functor num-
ber denotes a sequence of numbers, with optional
periods and commas.

5.3 Main Results

In our experiments we make a division of the train-
ing corpora into 80% for training and 20% for de-
velopment. Therefore, in each iteration a model is
trained over 80% of the training corpus and tested
on 20%.3 For feature selection, if the outcome of
the newly trained model is better than the best re-
sult so far, then the feature is added to the fea-
ture model; otherwise, it is not. A model has
to show improvement of at least 0.02 on part-of-
speech tagging accuracy to count as better.4

Table 1 (columns under Part-of-Speech) shows
the features that the algorithms selected for each
language and each system, and Table 2 shows the
performance on the development set. We primar-
ily report part-of-speech tagging accuracy (POS),
but also report unlabeled (UAS) and labeled (LAS)
attachment scores (Buchholz and Marsi, 2006) to
show the effect of improved taggers on parsing
quality. Additionally, Table 2 contains the num-
ber of features selected (#).

The ﬁrst conclusion to draw is that the feature
selection algorithms work for both standalone and
joint systems. The number of features selected
is drastically reduced. The dynamic MRMR fea-
ture selection technique for the joint system com-
presses the model by as much as 78%. This im-
plies faster inference (smaller dot products and
less feature extraction) and a smaller memory
footprint. In general, joint systems compress more

3There is also a held-out test set for evaluation, which is

the standard test set provided and depicted in Section 5.1.

4All the experiments were carried out on a CPU Intel
Xeon 3.4 Ghz with 6 cores. Since the feature selection ex-
periments require us to train a large number of parsing and/or
tagging models, we needed to ﬁnd a realistic training setup
that gives us a sufﬁcient accuracy level while maintaining a
reasonable speed. After some preliminary experiments, we
selected a beam size of 8 and 12 training iterations for the fea-
ture selection experiments while the ﬁnal models are tested
with a beam size of 40 and 25 training iterations. The size k
of the second beam for alternative tag sequences is kept at 8
for all experiments and the threshold α at 0.25.

over their standalone counterpart, by about 20%.
Furthermore, the dynamic technique tends to have
slightly more compression.

the joint

superior

in general

The accuracies of

tagger-parser
to the ones ob-
are
tained by the standalone tagger, as noted by
Bohnet and Nivre (2012).
In terms of tagging
accuracy, static selection works slightly better for
Chinese, German and Hungarian while dynamic
MRMR works best
for English and Russian
(Table 2). Moreover, the standalone tagger selects
several feature templates that requires iterating
over the sentence, such as pos(w+1), pos(w+2),
whereas the feature templates selected by the joint
system contain signiﬁcantly fewer of these fea-
tures. This shows that a joint system is less reliant
on context features to resolve many ambiguities
that previously needed a wider context. This
is almost certainly due to the global contextual
information pushed to the tagger via parsing
decisions. As a consequence, the preprocessing
tagger can be simpliﬁed and we need to conduct
only one iteration over the sentence while main-
taining the same accuracy level. Interestingly, the
dynamic MRMR technique tends to select less
form features, which have the largest number of
realizable values and thus model parameters.

Table 3 compares the performance of our two
taggers with two state-of-the-art taggers. Except
for English, the joint tagger consistently outper-
forms the Stanford tagger and MarMot: for Chi-
nese by 0.3, for German by 0.38, for Hungarian
by 0.25 and for Russian by 0.75. Table 4 com-
pares the resulting parsing accuracies to state-of-
the-art dependency parsers for English and Chi-
nese, showing that the results are in line with or
higher than the state of the art.

6 Morphological Tagging Experiments

The joint morphology and syntactic inference re-
quires the selection of morphological attributes
(case, number, etc.) and the selection of features to
predict the morphological attributes. In past work
on joint morphosyntactic parsing, all morpholog-
ical attributes are predicted jointly with syntactic
dependencies (Bohnet et al., 2013). However, this
could lead to unnecessary complexity as only a
subset of the attributes are likely to inﬂuence pars-
ing decisions, and vice versa.

In this section we investigate whether feature
selection methods can also be used to reduce the

Standalone

Joint

Part-of-Speech

Morphology

Standalone

Joint

static

static

dynamic

static

dynamic
Ch En Ge Hu Ru Ch En Ge Hu Ru Ch En Ge Hu Ru Ch En Ge Hu Ru Ge Hu Ru Ge Hu Ru Ge Hu Ru Ge Hu Ru

dynamic

dynamic

static

21 24 23 23 23

19 24 21 24 17

19 16 19 15 21

20 15 21 18

9

44 24 31

29 15 24

27 18 21

32 12 16

22.8
69%

21
71%

17.8
76%

16.6
78%

31
58%

22.6
69%

22
70%

20
73%

Id Feature Name
form
1
formlc
2
preﬁx1
3
preﬁx2
4
preﬁx3
5
preﬁx4
6
7
preﬁx5
13 sufﬁx1
14 sufﬁx2
15 sufﬁx3
16 sufﬁx4
17 sufﬁx5
18 sufﬁx2+uc
19 sufﬁx3+uc
20 sufﬁx4+uc
21 sufﬁx5+uc
22 uppercase
23 c2c3c4
24 c3c4c5
25 c4c5c6
26 c2c3c4c5
27 c3c4c5c6
28 form(w,w+1)
29 form(w+1)
30 preﬁx1(w+1)
31 sufﬁx1(w+1)
32 suff2+pref1(w+1)
33 suff2+suff1(w+1)
34 sufﬁx2(w+1)
35 preﬁx2(w+1)
36 suff2+pref2(w+1)
37 sufﬁx2(w,xw+1)
41 form(w+1,w+2)
42 form(w+2)
43 form(w+2,w+3)
44 length(w)
45 lemma(w)
46 number
47 lemmas(w-1,w+1)
48 form(w-1)
49 lemma(w-1 )
50 form(w-2)
51 form(w-3,w-2)
52 form(w-1,w)
53 form(w-2,w-1,w)
54 form(w-1,w,w+1)
55 form(w,w+1,w+2)
56 sufﬁx2(w-1)
57 sufﬁx2(w-1,w-2)
59 sufﬁx2(w-2)
60 sufﬁx2(w-3)
61 sufﬁx2(w+1)
64 sufﬁx2(w+2)
67 pos(w+1,w+2)
68 pos(w+1)
69 pos(w-1)
70 pos(w-1,w+1)
71 pos(w-2)
72 pos(w-1,w-2)
73 form(w-1,w-2)
74 form(w-1,w-1)
75 pos(w-3)
76 morph(w+1,w+2)
77 morph(w+1)
78 morph(w-1)
79 morph(w-1,w+1)
80 morph(w-2)
81 morph(w-1,w-2)
82 fo.(w-1)+mo.(w-2)
83 morph(w-2,w-3)
84 pos(w)
85 pos(w,w-1)
86 pos(w,w+1)
87 pos(w-2,w-1,w)
88 pos(w,w+1,w+2)
89 pos(w-1,w,w+1)
#
#

total
average
reduction

Table 1: Selected features for the standalone tagger and the joint tagger-parser with a threshold of 0.02
for the experiments of Section 5 (part-of-speech tagging) and Section 6 (morphological tagging). Some
of the features are not shown because they have not been selected. A ﬁlled box means selected, while an
empty one means not selected.

Pipeline

Joint

POS LAS UAS # POS LAS UAS #

Chinese

none 94.14 78.98 81.77 74 94.34 79.33 82.21 74
static 94.26 79.06 81.96 20 94.57 79.75 82.54 19
dynamic 94.06 79.26 82.21 23 94.49 79.68 82.54 20

English

none 97.18 90.78 91.97 74 96.99 90.92 92.06 74
static 96.98 90.56 91.77 23 96.99 91.05 92.20 16
dynamic 97.05 90.69 91.97 23 97.13 90.78 91.95 15

German

none 97.79 91.33 93.33 74 98.14 91.64 93.60 74
static 97.77 91.70 93.71 25 98.20 91.83 93.83 19
dynamic 97.60 91.40 93.60 22 97.91 91.74 93.73 22

Hungarian

none 97.89 87.89 90.44 74 98.00 88.11 90.59 74
static 97.87 88.01 90.54 23 98.01 88.25 90.78 23
dynamic 97.85 87.80 90.36 24 98.00 88.16 90.65 18

Russian

none 98.62 87.45 92.58 74 98.79 87.69 92.83 74
static 98.70 87.41 92.62 23 98.85 87.61 92.86 21
dynamic 98.69 87.69 92.92 17 98.87 87.61 92.86 9

Table 2: Tagging and parsing accuracy scores on
the dev set without feature selection (none), with
static and with dynamic MRMR greedy feature se-
lection.

Ch

En

Ge

Hu

Ru
POS POS POS POS POS
93.75 97.44 97.51 97.55 98.16
Stanford
MarMot
93.84 97.43 97.57 97.63 98.18
Standalone 94.04 97.33 97.56 97.69 98.73
94.14 97.42 97.95 97.88 98.93
Joint

Table 3: State-of-the-art comparison for tagging
on the test set.

set of morphological attributes that are predicted
as part of a joint system.
For instance, con-
sider a language that has the following attributes:
case, gender, number, animacy. And let us say
that language does not have gender agreement.
Then likely only case and number will be use-
ful in a joint system, and the gender and animacy
attributes can be predicted independently. This
could substantially improve the speed of the joint
model – on top of standard feature selection – as
the size of the morphosyntactic tag set will be re-
duced signiﬁcantly.

6.1 Data Sets
We use the data sets listed in subsection 5.1 for the
languages that provide morphological annotation,
which are German, Hungarian and Russian.

6.2 Main Results: Attribute Selection
For the selection of morphological attributes (e.g.
case, number, tense), we explore a simple method

System

Chinese

POS LAS UAS #

Li et al. (2011) 93.08
Hatori et al. (2012) 93.94

80.55
81.20
Bohnet and Nivre (2012) 93.24 77.91 81.42

joint-static 94.14 78.77 81.91 20

English
McDonald et al. (2005)
McDonald and Pereira (2006)
Huang and Sagae (2010)
Koo and Collins (2010)
Zhang and Nivre (2011)
Martins et al. (2010)

90.9
91.5
92.1
93.04
92.9
93.26
Bohnet and Nivre (2012) 97.33 92.44 93.38
93.50
93.16
93.5
93.79

Zhang et al. (2013)
Koo et al. (2008) †
Carreras et al. (2008) †
Suzuki et al. (2009) †

joint-dynamic 97.42 92.50 93.50 15

Table 4: State of the art comparison for parsing on
the test set. Results marked with a dagger† are not
directly comparable as additional data was used.

that departs slightly from those in Section 3. In
particular, we do not run greedy forward selection.
Instead, we compute accuracy improvements for
each attribute ofﬂine. We then independently se-
lect attributes based on these values. Our initial
design was a greedy forward attribute selection,
but we found experimentally that independent at-
tribute selection worked best.

We run 10-fold cross-validation experiments on
the training set where 90% of training set is used
for training and 10% for testing. Here we simply
test for each attribute independently whether its in-
clusion in a joint morphosyntactic parsing system
increases parsing accuracy (LAS/UAS) by a statis-
tically signiﬁcant amount. If it does, then it is in-
cluded. We applied cross validation to obtain more
reliable results than with the development sets as
some improvements where small, e.g., gender and
number in German are within the range of the stan-
dard deviation results on the development set. We
use parsing accuracy as we are primarily testing
whether a subset of attributes can be used in place
of the full set in joint morphosyntactic parsing.

Even though this method only tests an at-
tribute’s contribution independently of other at-
tributes, we found experimentally that this was
never a problem. For instance, in German, with-
out any morphologic attribute, we get a baseline
of 89.18 LAS; when we include the attribute case,
we get 89.45 LAS; and when we include number,
we get 89.32 LAS. When we include both case and
number, we get 89.60 LAS.

German

Cross Valid. Exp.

attribute LAS UAS stat. sig. Sel.

none 89.2 91.8 –
case 89.5 91.9 yes∗∗∗

gender 89.2 91.8 no
number 89.3 91.9 yes∗∗∗

mode 89.2 91.8 no
person 89.2 91.8 no
tense 89.2 91.8 no

Hungarian
Cross Valid. Exp.

attribute LAS UAS stat. sig. Sel.

none 84.5 88.3 –
case 85.7 89.0 yes∗∗∗∗

degree 84.6 88.4 yes∗
number 84.7 88.5 yes∗∗

mode 84.6 88.4 no

person P 84.6 88.7 yes∗
person 85.0 88.9 yes∗∗
subpos 85.4 88.9 yes∗∗∗

tense 84.6 88.4 yes∗

Russian

Cross Valid. Exp.

attribute LAS UAS stat. sig. Sel.

none 79.4 88.2

act 80.4 89.1 yes∗∗∗∗
anim 79.8 88.3 yes∗∗∗∗
aspect 79.4 88.2 no

case 80.9 89.3 yes∗∗∗∗

degree 79.4 88.2 no
gender 80.1 88.6 yes∗∗∗∗
mode 80.0 88.7 yes∗∗∗
number 82.2 88.6 yes∗∗∗∗
passive 79.6 88.2 yes∗
tense 79.8 88.4 yes∗∗
typo 79.4 88.1 no

Table 5: Morphological attribute selection.

Pipeline

Joint

MOR LAS UAS # MOR LAS UAS #

German

none 93.07 91.69 93.66 83 94.21 91.69 93.65 83
static 92.65 91.70 93.75 44 94.17 91.56 93.54 27
dynamic 92.89 91.61 93.62 29 94.01 91.72 93.72 32

Hungarian

none 97.10 88.00 90.49 83 97.22 88.02 90.51 83
static 97.11 87.98 90.43 24 97.23 88.06 90.49 18
dynamic 96.90 87.92 90.38 15 97.22 87.97 90.43 12

Russian

none 93.41 87.36 92.58 83 95.78 87.54 92.79 83
static 95.37 87.50 92.80 31 95.39 87.58 92.85 21
dynamic 95.31 87.53 92.74 24 95.74 87.59 92.86 16

Table 6: Morphological and syntactic accuracy
scores on the dev set without feature selection
(none), with greedy forward feature selection
(static) and with Minimum Redundancy Maxi-
mum Relevance (dynamic).

Table 5 shows which attributes were selected.
We include an attribute when the cross-validation
experiment shows an improvement of at least 0.1
with a statistical signiﬁcance of 0.01 or better (in-
dicated in the table by **). Some borderline cases
remain such as for Russian passive where we ob-
served an accuracy gain of 0.2 but only a low sta-
tistical signiﬁcance.

6.3 Main Results: Feature Selection
Having ﬁxed the set of attributes to be predicted
jointly with the parser, we can turn our attention
to optimizing the feature sets for morphosyntactic
tagging. To this end, we again consider greedy for-
ward selection with the static and dynamic strate-
gies. Table 1 shows the selected features for the
different languages where the grey boxes again

System

POS MOR LAS UAS

German

Seeker and Kuhn (2013)

91.50 93.48
joint-static-static 97.97 94.20 91.88 93.81

Hungarian

87.2 90.1
Farkas et al. (2012)
Bohnet et al. (2013) 97.80 96.4† 88.9 91.3
joint-static-static 97.85 96.97 88.85 91.32

Russian

Boguslavsky et al. (2011)

86.0 90.0
Bohnet et al. (2013) 98.50 94.4† 87.6 92.8
joint-dynamic-dynamic 98.90 95.62 87.86 92.95

Table 7: State of the art comparison on the test
set. Results marked with a dagger† are not com-
parable since they use different morphological at-
tribute bundels.

mean that the feature was selected. Table 6 shows
the performance on the development set. For Ger-
man, the full template set performs best but only
0.04 better than static selection which performs
nearly as well while reducing the template set by
68%. For Hungarian, all sets perform similarly
while dynamic selection needs 86% less features.
The top performing feature set for Russian is dy-
namic selection in a joint system which needs 81%
less features. We observe again that dynamic se-
lection tends to select less feature templates com-
pared to static selection, but here both the full set
of features and the set selected by static selection
appear to have better accuracy on average.

The feature selection methods obtain signiﬁcant
speed-ups for the joint system. On the develop-
ment sets we observed a speedup from 0.015 to
0.003 sec/sentence for Hungarian, from 0.014 to
0.004 sec/sentence for German, and from 0.015 to
0.006 sec/sentence for Russian. This represents a
reduction in running time between 50 and 80%.

Table 7 compares our system to other state-of-
the-art morphosyntactic parsers. We can see that
on average the accuracies of our attribute/feature
selection models are competitive or above the
state-of-the art. The key result is that state of the
art accuracy can be achieved with much leaner and
faster models.

7 Conclusions

There are several methodological lessons to learn
from this paper. First, feature selection is gener-
ally useful as it leads to fewer features and faster
tagging while maintaining state-of-the-art results.
Second, feature selection is even more effective

for joint tagging-parsing, where it leads to even
better results and smaller feature sets.
In some
cases, the number of feature templates is reduced
by up to 80% with a correponding reduction in
running time. Third, dynamic feature selection
strategies (Peng et al., 2005) lead to more com-
pact models than static feature selection, without
signiﬁcantly impacting accuracy. Finally, similar
methods can be applied to morphological attribute
selection leading to even leaner and faster models.

Acknowledgement

Miguel Ballesteros is supported by the European
Commission under the contract numbers FP7-ICT-
610411 (project MULTISENSOR) and H2020-
RIA-645012 (project KRISTINA)

References

[Ballesteros and Bohnet2014] Miguel Ballesteros and
Bernd Bohnet. 2014. Automatic feature selection
for agenda-based dependency parsing. In Proceed-
ings of the 25th International Conference on Com-
putational Linguistics (COLING).

[Ballesteros and Nivre2014] Miguel Ballesteros

and
Joakim Nivre.
2014. MaltOptimizer: Fast and
Effective Parser Optimization. Natural Language
Engineering.

[Ballesteros2013] Miguel Ballesteros.

2013. Effec-
tive morphological feature selection with maltopti-
mizer at the spmrl 2013 shared task.
In Proceed-
ings of the Fourth Workshop on Statistical Parsing
of Morphologically-Rich Languages, pages 53–60.

[Banko et al.2007] Michele Banko, Michael J Ca-
farella, Stephen Soderland, Matthew Broadhead,
and Oren Etzioni. 2007. Open information extrac-
tion for the web. In IJCAI, volume 7, pages 2670–
2676.

[Boguslavsky et al.2000] Igor Boguslavsky, Svetlana
Grigorieva, Nikolai Grigoriev, Leonid Kreidlin, and
Nadezhda Frid. 2000. Dependency treebank for
Russian: Concept, tools, types of information.
In
COLING, pages 987–991.

[Boguslavsky et al.2002] Igor

Boguslavsky,

Ivan
Chardin, Svetlana Grigorieva, Nikolai Grigoriev,
Leonid Iomdin, Leonid Kreidlin, and Nadezhda
Frid. 2002. Development of a dependency treebank
for Russian and its possible applications in NLP. In
LREC, pages 852–856.

[Boguslavsky et al.2011] Igor Boguslavsky, Leonid
Iomdin, Victor Sizov, Leonid Tsinman, and Vadim
Petrochenkov.
Rule-based dependency
parser reﬁned by empirical and corpus statistics.
In Proceedings of the International Conference on
Dependency Linguistics, pages 318–327.

2011.

[Bohnet and Nivre2012] Bernd Bohnet and Joakim
Nivre. 2012. A transition-based system for joint
part-of-speech tagging and labeled non-projective
dependency parsing.
In EMNLP-CoNLL, pages
1455–1465.

[Bohnet et al.2013] Bernd Bohnet, Joakim Nivre, Igor
Boguslavsky, Richard Farkas, Filip Ginter, and Jan
Hajia.
Joint morphological and syntac-
tic analysis for richly inﬂected languages. TACL,
1:415–428.

2013.

[Brants et al.2002] Sabine Brants, Stefanie Dipper, Sil-
via Hansen, Wolfgang Lezius, and George Smith.
2002. TIGER treebank.
In Proceedings of the
1st Workshop on Treebanks and Linguistic Theories
(TLT), pages 24–42.

[Brants2000] Thorsten Brants. 2000. TnT – a statistical

part-of-speech tagger. In ANLP.

[Buchholz and Marsi2006] Sabine Buchholz and Erwin
Marsi. 2006. CoNLL-X shared task on multilingual
dependency parsing. In CoNLL, pages 149–164.

[Carbonell and Goldstein1998] Jaime Carbonell and
Jade Goldstein. 1998. The use of mmr, diversity-
based reranking for reordering documents and pro-
ducing summaries. In Proceedings of the 21st an-
nual international ACM SIGIR conference on Re-
search and development in information retrieval,
pages 335–336. ACM.

[Carreras et al.2008] Xavier Carreras, Michael Collins,
and Terry Koo. 2008. Tag, dynamic programming,
and the perceptron for efﬁcient, feature-rich parsing.
In CoNLL, pages 9–16.

[Charniak and Johnson2005] Eugene Charniak

and
Mark Johnson. 2005. Coarse-to-ﬁne n-best parsing
and MaxEnt discriminative reranking.
In ACL,
pages 173–180.

[Crammer et al.2006] Koby Crammer, Ofer Dekel,
Joseph Keshet, Shai Shalev-Shwartz, and Yoram
2006. Online passive-aggressive algo-
Singer.
rithms.
Journal of Machine Learning Research,
7:551–585.

[Della Pietra et al.1997] Stephen Della Pietra, Vincent
Della Pietra, and John Lafferty. 1997. Inducing fea-
tures of random ﬁelds. IEEE Transactions on Pat-
tern Analysis and Machine Intelligence, 19.

[Farkas et al.2012] Rich´ard Farkas, Veronika Vincze,
and Helmut Schmid. 2012. Dependency parsing
of hungarian: Baseline results and challenges.
In
EACL, pages 55–65.

[Gao et al.2007] Jianfeng Gao, Galen Andrew, Mark
Johnson, and Kristina Toutanova. 2007. A com-
parative study of parameter estimation methods for
statistical natural language processing. In ACL, vol-
ume 45, page 824.

[Gim´enez and M`arquez2004] Jes´us Gim´enez and Llu´ıs
M`arquez. 2004. SVMTool: A general POS tag-
ger generator based on support vector machines. In
LREC.

[Goldberg and Tsarfaty2008] Yoav Goldberg and Reut
Tsarfaty. 2008. A single generative model for joint
morphological segmentation and syntactic parsing.
In ACL, pages 371–379.

[Habash and Sadat2006] Nizar Habash and Fatiha Sa-
dat. 2006. Arabic preprocessing schemes for statis-
tical machine translation. In NAACL-06.

[Hatori et al.2011] Jun Hatori, Takuya Matsuzaki,
Yusuke Miyao, and Jun’ichi Tsujii. 2011.
Incre-
mental joint pos tagging and dependency parsing in
chinese. In IJCNLP, pages 1216–1224.

[Hatori et al.2012] Jun Hatori, Takuya Matsuzaki,
Yusuke Miyao, and Jun’ichi Tsujii. 2012.
Incre-
mental joint approach to word segmentation, pos
tagging, and dependency parsing in chinese.
In
ACL, pages 1045–1053.

[Huang and Sagae2010] Liang Huang and Kenji Sagae.
2010. Dynamic programming for linear-time incre-
mental parsing. In ACL, pages 1077–1086.

[Koo and Collins2010] Terry Koo and Michael Collins.
2010. Efﬁcient third-order dependency parsers. In
ACL, pages 1–11.

[Koo et al.2008] Terry Koo, Xavier Carreras,

and
Michael Collins. 2008. Simple semi-supervised de-
pendency parsing. In ACL, pages 595–603.

[Lee et al.2011] John Lee,

Jason Naradowsky, and
David A. Smith. 2011. A discriminative model for
joint morphological disambiguation and dependency
parsing. In ACL, pages 885–894.

[Li et al.2011] Zhenghua Li, Min Zhang, Wanxiang
Che, Ting Liu, Wenliang Chen, and Haizhou Li.
2011. Joint models for chinese pos tagging and de-
pendency parsing. In Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP), pages 1180–1191.

[M`arquez and Gim´enez2004] L

M`arquez

and
2004. A general pos tagger gen-

J Gim´enez.
erator based on support vector machines. JMLR.

[Martins et al.2010] Andre Martins, Noah Smith, Eric
Xing, Pedro Aguiar, and Mario Figueiredo. 2010.
Turbo parsers: Dependency parsing by approximate
variational inference. In EMNLP, pages 34–44.

[Martins et al.2011] Andr´e FT Martins, Noah A Smith,
Pedro MQ Aguiar, and M´ario AT Figueiredo. 2011.
Structured sparsity in structured prediction.
In
EMNLP, pages 1500–1511. Association for Compu-
tational Linguistics.

[McCallum and Li2003] Andrew McCallum and Wei
Li. 2003. Early results for named entity recogni-
tion with conditional random ﬁelds, feature induc-
tion and web-enhanced lexicons. In Proceedings of
the seventh conference on Natural language learn-
ing at HLT-NAACL 2003-Volume 4, pages 188–191.
Association for Computational Linguistics.

[McDonald and Pereira2006] Ryan McDonald and Fer-
nando Pereira. 2006. Online learning of approxi-
mate dependency parsing algorithms.
In Proceed-
ings of the 11th Conference of the European Chap-
ter of the Association for Computational Linguistics
(EACL), pages 81–88.

[McDonald et al.2005] Ryan McDonald, Koby Cram-
mer, and Fernando Pereira. 2005. Online large-
margin training of dependency parsers.
In ACL,
pages 91–98.

[M´ora and Vincze2012] Gy¨orgy M´ora and Veronika
Joint part-of-speech tagging and
Vincze. 2012.
named entity recognition using factor graphs.
In
Petr Sojka, Ales Hork, Ivan Kopecek, and Karel
Pala, editors, Text, Speech and Dialogue, volume
7499 of Lecture Notes in Computer Science, pages
232–239. Springer.

[M¨uller et al.2013] Thomas M¨uller, Helmut Schmid,
and Hinrich Sch¨utze. 2013. Efﬁcient higher-order
crfs for morphological tagging. In In Proceedings
of EMNLP.

[Nivre2006] Joakim Nivre. 2006.

dency Parsing. Springer.

Inductive Depen-

[Peng et al.2005] Hanchuan Peng, Fuhui Long, and
Chris Ding.
2005. Feature Selection Based on
Mutual Information: Criteria of Max-Dependency,
Max-Relevance, and Min-Redundancy.
In IEEE
Transactions On Pattern Analysis And Machine In-
telligence, pages 1226–1238.

[Petrov et al.2006] Slav Petrov, Leon Barrett, Romain
Thibaux, and Dan Klein. 2006. Learning accurate,
compact, and interpretable tree annotation. In ACL,
pages 433–440.

[Ratnaparkhi1996] Adwait Ratnaparkhi. 1996. A max-
In EMNLP,

imum entropy part-of-speech tagger.
pages 133–142.

[Seeker and Kuhn2012] Wolfgang Seeker and Jonas
Kuhn. 2012. Making ellipses explicit in depen-
dency conversion for a german treebank. In LREC,
pages 3132–3139.

[Seeker and Kuhn2013] Wolfgang Seeker and Jonas
Kuhn. 2013. Morphological and syntactic case in
statistical dependency parsing. Computational Lin-
guistics, 39:23–55.

[Suzuki et al.2009] Jun Suzuki, Hideki Isozaki, Xavier
Carreras, and Michael Collins. 2009. An empiri-
cal study of semi-supervised structured conditional
models for dependency parsing. In EMNLP, pages

551–560, Singapore, August. Association for Com-
putational Linguistics.

[Toutanova and Manning2000] Kristina Toutanova and
Christopher D. Manning.
2000. Enriching the
knowledge sources used in a maximum entropy part-
of-speech tagger. In 2000 Joint SIGDAT Conference
on Empirical Methods in Natural Language Pro-
cessing and Very Large Corpora, pages 63–70.

[Yamada and Matsumoto2003] Hiroyasu Yamada and
Yuji Matsumoto. 2003. Statistical dependency anal-
ysis with support vector machines. In Proceedings
of the 8th International Workshop on Parsing Tech-
nologies (IWPT), pages 195–206.

[Yang and Pedersen1997] Yiming Yang and Jan O Ped-
ersen. 1997. A comparative study on feature se-
lection in text categorization. In ICML, volume 97,
pages 412–420.

[Zhang and Clark2008a] Yue Zhang and Stephen Clark.
2008a. Joint word segmentation and POS tagging
using a single perceptron. In ACL, pages 888–896.

[Zhang and Clark2008b] Yue Zhang and Stephen Clark.
2008b. A tale of two parsers: Investigating and com-
bining graph-based and transition-based dependency
parsing. In EMNLP, pages 562–571.

[Zhang and Nivre2011] Yue Zhang and Joakim Nivre.
2011. Transition-based parsing with rich non-local
features. In ACL.

[Zhang et al.2013] Hao Zhang, Liang Huang, Kai Zhao,
and Ryan McDonald. 2013. Online learning for in-
exact hypergraph search.
In EMNLP, pages 908–
913, Seattle, Washington, USA, October. Associa-
tion for Computational Linguistics.

