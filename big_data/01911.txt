6
1
0
2

 
r
a

M
7

 

 
 
]

M
D
.
s
c
[
 
 

1
v
1
1
9
1
0

.

3
0
6
1
:
v
i
X
r
a

Hanabi is NP-complete, Even for Cheaters who
Look at Their Cards
Jean-Francois Baﬃer1,2, Man-Kwun Chiu1,2, Yago Diez3, Matias
Korman3, Valia Mitsou4, André van Renssen1,2, Marcel
Roeloﬀzen1,2, and Yushi Uno5

1 National Institute of Informatics (NII), Tokyo, Japan.

{jf_baffier,chiumk,andre,marcel}@nii.ac.jp
JST, ERATO, Kawarabayashi Large Graph Project.

2
3 Tohoku University, Sendai, Japan.
{yago,mati}@dais.is.tohoku.ac.jp
SZTAKI, Hungarian Academy of Sciences.
vmitsou@sztaki.hu

4

5 Department of Mathematics and Information Sciences, Graduate School of

Science, Osaka Prefecture University.
uno@mi.s.osakafu-u.ac.jp

Abstract

This paper studies a cooperative card game called Hanabi from an algorithmic combinatorial
game theory viewpoint. The aim of the game is to play cards from 1 to n in increasing order
(this has to be done independently in c diﬀerent colors). Cards are drawn from a deck one by
one. Drawn cards are either immediately played, discarded or stored for future use (overall each
player can store up to h cards).

We introduce a simpliﬁed mathematical model of a single-player version of the game, and show
several complexity results: the game is intractable in a general setting, but becomes tractable
(and even linear) in some interesting restricted cases (i.e., for small values of h and c).

1998 ACM Subject Classiﬁcation F.2.2, G.2, F.1.2.

Keywords and phrases algorithmic combinatorial game theory, sorting.

Digital Object Identiﬁer 10.4230/LIPIcs.xxx.yyy.p

1

Introduction

When studying mathematical puzzles or games, mathematicians and computer scientists are
often interested in winning strategies, designing computer programs that play as well (or
even better than) humans. The computational complexity ﬁeld studies the computational
complexity of the games. That is, how hard it is to obtain a solution to a puzzle or to
decide the winner or loser of a game [5, 8, 9]. Another interest is to design algorithms to
obtain solutions. Some games and puzzles of interest include for example Nim, Hex, Sudoku,
Tetris, Go. Recently, this ﬁeld has been called ‘algorithmic combinatorial game theory’ [9] to
distinguish it from games arising from other ﬁelds, especially classical economic game theory.
In this paper we study a cooperative card game called Hanabi. Designed by Antoine
Bauza and published in 2010, the game has received several tabletop game awards (including
the prestigious Spiel des Jahres in 2013 [6]). In the game the players simulate a ﬁreworks
© Jean Francois Baﬃer, Man-Kwun Chiu, Yago Diez, Matias Korman, Valia Mitsou, André van

Renssen, Marcel Roeloﬀzen, and Yushi Uno;

licensed under Creative Commons License CC-BY

Conference title on which this volume is based on.
Editors: Billy Editor and Bill Editors; pp. 1–17

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

2

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

show1, playing cards of diﬀerent colors in increasing order.

In this paper we study this game from the viewpoint of algorithmic combinatorial game
theory. We ﬁrst propose mathematical models of a single-player variant of Hanabi, and
then analyze their computational complexities. We show that even a single-player Hanabi is
computationally intractable in general, while the problem becomes easy under very tight
constraints.

1.1 Rules of the Game
Hanabi is a multi-player, imperfect-information cooperative game. This game is played with
a deck of ﬁfty cards, where each card has a number (from 1 to 5) and a suit (or a color) out of
ﬁve colors (red, yellow, green, blue and white). There are ten cards of each suit. The values
of the cards are 1, 1, 1, 2, 2, 3, 3, 4, 4, and 5, respectively. That is, there are two copies of
each card except for the lowest and highest card of each color (that appear three and one
time, respectively). Players must cooperate to play the cards from 1 to 5 in increasing order
for all suits independently.

One of the most distinctive features of the game is that players cannot see their own cards
while playing: each player holds his cards so that they can be seen by other players (but
not himself). A player can do one of the following actions in each turn: play a card, discard
a card from his hand to draw a new one, or give a hint to another player on what type of
cards he or she is holding in hand. A second characteristic of this game is that each player
can hold only a small number cards in hand (4 or 5 depending on the number of players)
drawn at random from the deck. Whenever no card is playable, a player may discard a card
and draw a new one from the deck. See Appendix A for the exact rules of the Hanabi game,
or [1, 2] for more information on the game.

1.2 Related Work
There is an extensive amount of research that studies the complexity of tabletop and card
games. In virtually all games, the total description complexity of the problem is bounded by
a constant, thus they can be solved in constant time by an exhaustive search approach.

Thus, the literature focuses on the extensions of those games in which the complexity is
not constant. For example, it is known that determining the winner in chess on an n × n
board needs exponential time [7]. If the playing board can be any graph, Pandemic (a popular
tabletop game in which players try to prevent a virus from spreading) is NP-complete [10].
A somehow more surprising result is that determining the winner in Settlers of Catan is also
an NP-complete problem, even after the game has ended [4].

When considering card games, the complexity is often expressed as a function of the
number of cards in the deck. The popular trading card game Magic: The Gathering is Turing
complete [3]. That is, it can simulate a Turing machine (and in particular, it can simulate
any other tabletop or card game).

To the best of our knowledge, the only research that considered algorithmic aspects of
Hanabi is by Osawa [11]. The main focus of this paper is the design of strategies so that
players can collectively play as many cards as possible. Three heuristics are introduced, the
best of which performs almost as well as experienced human players in their experiments.

1 the word hanabi means ﬁreworks in Japanese

J.-F. Baﬃer et. al.

1.3 Model and Deﬁnitions

3

Motivated by this game, we study the complexity of Hanabi from the viewpoint of algorithmic
combinatorial game theory. We show that the game is diﬃcult, even if we forego the hidden
information feature of the game. To this end, we introduce a simpliﬁed mathematical model
of a single-player version of this game. We assume that the player has complete information
of the cards; the player knows which cards are being held in his hand as well as the exact
order in which cards will be drawn from the deck.

We represent a card of Hanabi with an ordered pair (ai, ki), where ai ∈ {1, . . . , n} and
ki ∈ {1, . . . , c}. The term ai is referred to as the value of the card and ki as its color. The
whole deck of cards is then a sequence σ of N cards. That is, σ = ((a1, k1), . . . , (aN , kN)).
The hand size h is the maximum number of cards that the player can hold in hand at any
point during the game. The multiplicity r of cards in a card sequence σ is the maximum
number of times that any card appears in σ.

In a game, the player scans the cards in the order ﬁxed by σ in a streaming fashion.
When scanning a card we consider three options: play, discard or store the card. If a card is
discarded, it is gone and can never be used afterwards. If instead we store the card, it is
saved and can be accessed afterwards (remember that at any instant of time the maximum
number of cards that can be stored is h). Cards can be played only in increasing order for
each color independently. That is, we can play card (ai, ki) if and only if the last card of
color ki that was played was (ai − 1, ki) (or ai = 1 and no card of color ki has been played).
After a card has been played we can also play any cards we may have stored in hand in
the same manner. The objective of the game is to play all cards from 1 to n in all c colors.
Whenever this happens we say that the sequence of play/discard/store is a winning play
sequence.

Thus, a problem instance of the Solitaire Hanabi (or Hanabi for short) consists of a
hand size h ∈ N and a card sequence σ of N cards (where each card is an ordered pair of a
value and a color out of n numbers and c colors, and no card appears more than r times).
The aim is to determine whether or not there is a winning play sequence for σ that never
stores more than h cards in hand.

1.4 Results and Organization
In this paper, we study computational complexity and algorithmic aspects of Hanabi with
respect to parameters N, n, c, r and h. Unfortunately the problem is NP-complete, even if
we ﬁx some parameters to be small constants. Speciﬁcally, in Section 5 we show that the
problem is NP-complete even if we restrict ourselves to the case in which h = 2 and r = 2.
Given the negative results, we focus on the design of algorithms for particular cases. For
those cases, our aim is to design algorithms whose running time is linear in N (the total
number of cards in the sequence), but we allow slightly larger running times as a function of
n, k, and r (the total number of values, colors and multiplicity, respectively).

In Section 2 we give a straightforward O(N) algorithm for the case in which r = 1 (that
is, no card is repeated in σ). This approach is afterwards extended for c = 1 (and unbounded
r) in Section 3. In Section 4 we give an algorithm for the general problem. Note that the
algorithm runs in exponential time (expected for an NP-complete problem), but the running
time reduces to O(N) whenever c and n are constants. The exact running times of all
algorithms introduced in this paper are summarized in Table 1.

4

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

Table 1 Summary of the diﬀerent results presented in this paper, where N, n, c, r and h are
the number of cards, the number of values, the number of colors, multiplicity, and the hand size,
respectively.

Case Studied

Approach Used

Observations

Running Time
O(N) = O(cn)
O(N + n log h)

r = 1
c = 1

General Case
h = 2, r = 2

Greedy
Lazy

Lemma 1 in Sec. 2
Theorem 4 in Sec. 3
Dynamic Programming O(N hchnh+c−1) Theorem 6 in Sec. 4
Theorem 7 in Sec. 5

NP-complete

2 Unique Appearance
As a warm-up, we consider the case in which each card appears only once (i.e., r = 1). In
this case we have exactly one card for each value and each color. Thus, N = cn and the
input sequence σ is a permutation of the values from 1 to n in the c colors.

Since each card appears only once, we cannot discard any card in the winning play
sequence. In the following, we show that the natural greedy strategy is essentially the best
we can do: play a card as soon as it is found (if possible). If not, store it in hand until it can
be afterwards played.
The game rules state that we cannot play a card (ai, ki) until all the cards from 1 to
ai − 1 of color ki have been played. Thus, we associate an interval to each card that indicates
for how long that card must be held in hand. For any card (ai, ki), let fi be the largest index
of the cards of color ki whose value is at most ai (i.e., fi = maxj≤N{j : kj = ki, aj ≤ ai}).
Note that we could have i = fi, but this only happens when all cards of value smaller than
ai appear before card (ai, ki). Otherwise, we must have fi > i, and card (ai, ki) cannot be
played until we have reached card (afi, kfi).
We associate each index i to the interval [i, fi]. Let I be the collection of all nonempty such
intervals. Let w be the maximum number of intervals that overlap (i.e., w = maxj≤N |{[i, fi] ∈
I : j ∈ [i, fi]}|).
(cid:73) Lemma 1. There is a solution to any Hanabi problem instance with r = 1 and hand size
h if and only if w ≤ h. Moreover, a play sequence can be found in O(N) time.
Proof. Intuitively speaking, any interval [i, j] ∈ I represents the need of storing card (ai, ki)
until we have reached card (aj, kj). Thus, if two (or more) intervals overlap, then the
corresponding cards must be stored simultaneously. By deﬁnition of w, when processing the
input sequence at some point in time we must store more than h cards, which in particular
implies that no winning play sequence exists.
In order to complete the proof we show that the greedy play strategy works whenever
w ≤ h. The key observation is that, for any index i we can play card (ai, ki) as soon as we
have reached the fi-th card. Indeed, by deﬁnition of fi all cards of the same color whose
value is ai or less have already appeared (and have been either stored or played). Thus, we
can simply play the remaining cards (including (ai, ki)) in increasing order.
Overall, each card is stored only within its interval. By hypothesis, we have w ≤ h, thus
we never have to store more than our allowed hand size. Furthermore, no card is discarded in
the play sequence, which in particular implies that the greedy approach will give a winning
play sequence with hand size h.
Regarding running time, it suﬃces to show that each element of σ can be treated in
constant time. For the purpose, we need a data structure that allows insertions into H and
membership queries in constant time. The simplest data structure that allows this is a hash

J.-F. Baﬃer et. al.

5

table. Since we have at most h elements (out of a universe of size cn) it is easy to have
buckets whose expected size is constant.

The only drawback of hash tables is that the algorithm is randomized (and the bounds
on the running time are expected). If we want a deterministic worst case algorithm, we
can instead represent H with a c × n bit matrix and an integer denoting the number of
elements currently stored. With either data structure it is straightforward to see that
insertions, removals, and membership queries take constant time, thus the algorithm takes
(cid:74)
O(N) = O(cn) time as claimed.

Lazy Strategy for One Color

3
We now study the case in which all cards belong to the same suit (i.e., c = 1). Note that we
make no assumptions on the multiplicity or any other parameters. Unlike the last section in
which we considered a greedy approach, here we describe a lazy approach that plays cards at
the last possible moment.
We start with an observation that allows us to detect how important a card is. For any
i ≤ N, we say that the i-th card (whose value is ai) is useless if there exist w1, . . . , wh+1 ∈ N
such that:
(i) ai < w1 < ··· < wh+1 ≤ n
(ii) ∀j ∈ {i + 1, . . . , N} it holds that aj 6∈ {w1, . . . , wh+1}

That is, there exist h + 1 values that are higher than ai none of which appears after the
i-th card in σ. Observe that, for example, no card of value n − h or higher can be useless
(since the wi values cannot exist) and that the last card is useless if and only if aN < n − h.
(cid:73) Observation 2. Useless cards are never played in a winning play sequence.
Proof. Assume, for the sake of contradiction, that there exists a winning play sequence that
plays some useless card whose index is i. Since we play cards in increasing order, no card of
value equal to or bigger than ai can have been played at the time in which the i-th card is
scanned. By deﬁnition of useless, the remaining sequence does not have more cards of values
w1, . . . , wh+1. Thus, in order to complete the game to a winning sequence, these h + 1 cards
(cid:74)
must all have been stored, but this is not possible with a hand size of h.

Our algorithm starts with a ﬁltering phase that removes all useless cards from σ. The
main diﬃculty of this phase is that the removal of some useless cards from σ may create
further useless cards, and so on. In order to avoid having to scan the input several times
we use two vectors and a max-heap as follows: for each index i ≤ N, we store the index
of the previous occurrence of the same card in a vector P (or −∞ if none exists). That is,
P[i] = −∞ if and only if aj 6= ai for all j < i. Otherwise, we have P[i] = i0 (for some i0 < i),
ai = ai0, and aj 6= ai for all j ∈ {i0 + 1, . . . , i − 1}. We also use a vector L such that, for
each index i ≤ n stores the last non-useless card of value i (since initially no card has been
detected as useless, the value L[i] is initialized to the index of the last card with value i in σ).
Finally, we use a max-heap HP of h + 1 elements initialized with values L[n − h], . . . , L[n].
Now, starting with i = n − (h + 1) down to 1 we look for all useless copies of value i. The
invariant of the algorithm is that for any j > i, all useless cards of value j have been removed
from σ and that vector L[j] stores the index of the last non-useless card of value j. The
heap HP contains the smallest h + 1 values among L[j], . . . , L[n] (and since it is a max-heap
we can access in constant time its largest value). These values will be the smallest possible
candidate values for the witnesses w1, . . . , wh+1 (properly speaking, HP stores indices, but

6

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

the values can be extracted in constant time). The invariants are satisﬁed for i = n − (h + 1)
directly by the way in which L and HP is initialized.
Any card of value i whose index is higher than the top of the heap is useless and can be
removed from σ (the indices in the heap HP act as witnesses). Starting from L[i], we remove
all useless cards of value i from σ until we ﬁnd a card of value i whose index is smaller than
the top of the heap. If no card of value i remains we stop the whole process and return that
the problem instance has no solution. Otherwise, we have found the last non-useless card of
value i. We update the value of L[i] since we have just found the last non-useless card of
that value. Finally, we must update the heap HP. As observed above, the value of L[i] must
be smaller than the largest value of HP (otherwise it would be a useless card). Thus, we
remove the highest element of the heap, and insert L[i] instead. Once this process is done,
we proceed to the next value of i. Let σ0 be the result of ﬁltering σ with the above algorithm.
(cid:73) Lemma 3. The ﬁltering phase removes only useless cards from σ. Moreover, this process
runs in O(N + n log h) time, and σ0 contains no useless cards.
Proof. Each time we remove a card from σ, the associated h + 1 witnesses w1, . . . wh+1 are
present in HP, thus the ﬁrst claim follows. The fact that no more useless cards remain
follows from the fact that we always store the smallest possible witness values.

Now we bound the running time. The heap is initialited with h + 1 elements, and during
the whole depurating phase O(n) elements are pushed. Hence, this part takes O(n log h)
time. Vector P and L can be initialized by scanning σ once. During the iterative phase
we can access the last occurrence of any value by using vector L. Once a card is removed,
we can update the last occurrence using P. Thus, we spend constant time per card that is
(cid:74)
removed from σ (hence, overall O(N) time).

Now we describe the algorithm for our lazy strategy. The play sequence is very simple:
we ignore all cards except when a card is the last one of that value present in σ0. For those
cards, we play them (if possible) or store them (otherwise). Whenever we play a card, we
play as many cards as possible (out of the ones we had stored).

Essentially, there are two possible outcomes after the ﬁltering phase. It may happen that
all cards of some value were detected as useless. In this case, none of those cards may be
played and thus the Hanabi problem instance has no solution. Otherwise, we claim that our
lazy strategy will yield a winning play sequence.
(cid:73) Theorem 4. We can solve a Hanabi problem instance for the case in which all cards have
the same color (i.e., c = 1) in O(N + n log h) time.
Proof. It suﬃces to show that our lazy strategy will always give a winning play sequence,
assuming that the ﬁltered sequence contains at least a card of each value. Our algorithm
considers exactly one card of each value from 1 to n. The card will be immediately played
(if possible) or stored until we can play it afterwards. Thus, the only problem we might
encounter would be the need to store more than h cards at some instant of time.

However, this cannot happen: assume, for the sake of contradiction, that at some instant
of time we need to store a card (whose index is j) and we already have stored cards of values
ai1 , . . . , aih. By construction of the strategy, there cannot be more copies of cards with value
ai1 , . . . , aih or aj in the remaining portion of σ0. Let p be the number of cards that we have
played at that instant of time. Remember that we never store a card that is playable, thus
p + 1 6∈ {aj, ai1, . . . , aih}. In particular, the last card of value p + 1 must be present in the
remaining portion of σ0. However, that card is useless (the values {aj, ai1 , . . . , aih} act as
witnesses), which gives a contradiction.

J.-F. Baﬃer et. al.

7

Thus, we conclude that the lazy strategy will never need to store more than h cards at
any instant of time, and it will yield a winning play sequence. Finally, observe that the
sequence itself can be reconstructed, since vector L stores the last non-useless occurrence of
(cid:74)
each value.

4

General Case Algorithm

In this section we study the general problem setting. Recall that this problem is NP-complete,
even if the hand size is small (see details in Section 5), hence we cannot expect an algorithm
that runs in polynomial-time. In the following, we give an algorithm that runs in polynomial
time provided that both h and c are ﬁxed constants (or exponential otherwise).

We solve the problem using a dynamic programming approach. Speciﬁcally, we build a

table DP[s,H, p1, . . . , pc−1] indexed by the following c + 1 parameters:

s (≤ N) represents the number of cards from the sequence σ that we allow to scan.
H is the set of cards that we require to store in hand after card (as, ks) has been processed.
We might have no requirements on what needs to be in hand, in which case we simply
set H = ∅.
p1, . . . , pc−1 (≤ n) encode how many cards we require to play in the ﬁrst c − 1 colors,
respectively.
The entry of the table DP[s,H, p1, . . . , pc−1] is a positive number equal to the maximum
number of cards of the c-th color that we can play among all play sequences that preserve
the above constraints. Whenever such a sequence is not feasible (i.e., we cannot play the
required cards in some color or store the cards of H), we simply set that position of the table
to −∞.

For example, if c = 3, the entry of table DP[42,{(15, 1), (10, 2)}, 10, 4] = 6 should be
interpreted as There is a play sequence that, after scanning through the 42 cards of σ has
played exactly 10 cards of the ﬁrst color, 4 of the second, 6 of the third, and has stored cards
(15, 1) and (10, 2) in hand. Moreover, there is no play sequence that, after scanning the ﬁrst
42 cards, plays 10, 4, and 7 cards of the three colors (respectively) and ends up with cards
(15, 1) and (10, 2) in hand.

When s is a small number we can ﬁnd the solution of an entry by brute force (try all
possibilities of discarding, storing or playing the ﬁrst s cards). This takes constant time since
the problem has constant description complexity. Similarly, we have DP[s,H, p1, . . . , pc−1] =
−∞ whenever |H| > h (because we need to store more than h cards in hand). In the following
we show how to compute the table DP for the remaining cases. For this purpose, we deﬁne
three auxiliary values D, S, and P (which stand for Discard, Store, and Play) as follows:2

D = DP[s − 1,H, p1, . . . , pc−1]

(−∞

S =

if |H| ≥ h
DP[s − 1,H \ {(as, ks)}, p1, . . . , pc−1] otherwise

2 Note that, strictly speaking, these terms depend on the parameters s,H, p1, . . . , pc−1. Thus, a better
notation would be Ps,H,p1,...,pc−1, Ss,H,p1,...,pc−1, and Ds,H,p1,...,pc−1. Since the subindices are clear
from the context, we remove them for ease of reading.

8

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

and

P =



−∞
DP[s − 1,H ∪ {(as+1, ks), . . . , (ps, ks)},

p1, . . . , pc−1] ≥ as−1}

p1, . . . , pks−1, as−1, pks+1, . . . , pc−1]

maxt∈{0,...,h}{as+t: DP[s − 1,H ∪ {(as+1, c), . . . , (as+t, c)},

if ks < c, as > pks

if ks < c, as ≤ pks

if ks = c

These auxiliary values allow us to compute an entry of the table eﬃciently.

(cid:73) Lemma 5. DP[s,H, p1, . . . , pc−1] = max{P,S,D}.
Proof. Assume that DP[s,H, p1, . . . , pc−1] is a positive number (i.e., it is feasible to satisfy
all constraints). Consider any play sequence that realises it, we distinguish three cases
depending on what the play sequence does with card (as, ks):

(as, ks) is discarded When the last card is discarded, the entry of the table is the same
as if we only allow the scanning of s − 1 cards. Thus, DP[s,H, p1, . . . , pc−1] = DP[s −
1,H, p1, . . . , pc−1] = D.
(as, ks) is stored Since this card is the last one that we are allowed to scan for the entry
of the table that we are computing, storing (as, ks) only makes sense if (as, ks) 6∈ H.
Moreover, this operation is only possible if we do not exceed the hand size limit. That
is, we have DP[s,H, p1, . . . , pc−1] = DP[s − 1,H \ {(as, ks)}, p1, . . . , pc−1] if |H| < h
(otherwise it should be −∞). This coincides with the deﬁnition of S.
(as, ks) is played In this case we claim that DP[s,H, p1, . . . , pc−1] = P. In order to prove
this we give an intuitive deﬁnition of P. We consider three subcases depending on the
color and value of card (as, ks).

ks < c and as > pks Recall we only need to play up to card pks in color ks (and this
card is of higher value). In particular, the card need not be played in the play sequence.
We set P = −∞ to make sure that this case is not considered by our algorithm.
ks < c and as ≤ pks Consider only color ks: we are required to play pks cards and in
order to do that we must speciﬁcally use card (as, ks). In order to do so, we must have
played the ﬁrst as − 1 cards of this color in advance, and must have the cards from
as + 1 to pks in hand. All constraints for other colors are unaﬀected. Thus, we have
DP[s,H, p1, . . . , pc−1] = DP[s − 1,H ∪ {(as + 1, ks), . . . , (ps, ks)}, p1, . . . , pks−1, as −
1, pks+1, . . . , pc−1] = P as claimed.

ks = c This case is similar to the previous one. In this case we focus on color c (= ks):
as before, we need card (as, ks) to be playable when we reach this card. This constraint
is realised by restricting to entries of the table that allow to play at least as − 1 cards
of color c (i.e., DS[·] ≥ as − 1).
Recall that our aim is to play as many cards of color c as possible. Thus, if we want
to play t additional cards after (as, c) but are not allowed to scan more cards of the
input, those t cards must have been previously stored. Thus, we are interested in the
largest value of t so that cards of values as + 1, . . . , as + t of color c can be stored in
hand while making sure that all constraints are satisﬁed.
Note that t can be as small as zero (i.e., when we do not store additional cards) and
at most h (since we cannot store more than h cards at any instant of time), giving
DP[s,H, p1, . . . , pc−1] = P as claimed.

J.-F. Baﬃer et. al.

9

Thus, when DP[s,H, p1, . . . , pc−1] is a positive number, we have equality from the
fact that we query feasible moves (thus DP[s,H, p1, . . . , pc−1] ≥ max{P,S,D}) and ex-
haustiveness (since we try all options, the largest of them must satisfy max{P,S,D} ≥
DP[s,H, p1, . . . , pc−1]). Similarly, if an entry of DP is unbounded, its associated values P,
S and D will also be unbounded (since a bounded number would be a witness of a winning
(cid:74)
play sequence).
(cid:73) Theorem 6. We can solve a Hanabi problem instance in O(N hchnh+c−1) time using
O(N chnh+c−1) space.
Proof. By deﬁnition, there is a solution to the Hanabi problem instance if and only if its
associate table satisﬁes DP[N,∅, n . . . , n] = n. Each entry of the table is solved by querying
entries that have a smaller value in the ﬁrst parameter, so we can compute the whole table
in increasing order.
Recall that, entries of the table for which the associated set H has more than h elements
the answer is trivially −∞ (since we cannot store that many cards). Thus, table DP will
We now bound the time needed to compute a single entry of the table (say, DP[s,H, p1, . . . ,
pc−1]). First notice that we can compute P and S with a constant number of queries to the
table. Each query makes at most one insertion or removal into H. Such insertions can be
handled in constant time (see the proof of Lemma 1), thus overall they are computed in
constant time.
In order to compute P, we may have to do O(h) queries onto the DP table and insert
O(h) elements into H. Since each of these operations take constant time, we need O(h) time
(cid:74)
to compute a single entry (and O(N chnh+c−1h) for the whole table as claimed).

(cid:0)nc
(cid:1) × nc−1 ∈ O(N chnh+c−1) nontrivial entries.

have N ×P

i≤h

i

Remark In principle, the DP table only returns whether or not the instance is feasible.
We note that, we can also ﬁnd a winning play sequence with the usual backtracking techniques.

5 NP-Hardness (Multiple Colors, Multiple Appearances)
In this section we prove hardness of the general Hanabi problem. As mentioned in the
introduction, the problem is NP-complete even if h and r are small constants.
(cid:73) Theorem 7. The Hanabi problem is NP-complete for r = 2 and for any h ≥ 2.
We prove the statement for h = 2 and then show how to generalize it for larger h. Our
reduction is from 3-SAT. Given a 3-SAT problem instance with v variables x1, . . . , xv and
m clauses W1, . . . , Wm, we construct a Hanabi sequence σ with 2v + 1 colors, n = 6m + 2,
r = 2, h = 2 (and thus N ≤ 2(2v + 1)(6m + 2)).

Before discussing the proof, we provide a birds-eye view of the reduction. The generated
sequence will have a variable gadget Vi for each variable xi and a clause gadget Cj for each
clause Wj.
In the ﬁrst phase of the game, the variable assigning phase, the player scans through the
variable gadgets Vi, i ≤ v. The variable gadget Vi associated to the i-th variable will have
cards of colors 2i − 1 and 2i. After we have scanned through gadget Vi, the best we can do
is play at most 5 cards of one color, and 1 from the other one. We assign a truth value to a
variable depending on which of the two colors we played ﬁve cards. By repeating this in all
variable gadgets we obtain a truth assignment.
In the next phase, the clause satisfaction phase, the player scans through the clause
gadgets Cj, j ≤ m. The clause gadget Cj corresponding to clause Wj is constructed in a way

10

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

2
d

2 2 1 3 4 5 1 3 4 5
1 2 1 1 1 1 2 2 2 2

2 2 1 3 4 5 1 3 4 5
3 4 3 3 3 3 4 4 4 4

2 2 1 3 4 5 1 3 4 5
5 6 5 5 5 5 6 6 6 6

1
d

Figure 1 Sequence σ1 for a SAT instance with three variables. The upper row represents the
numbers of the cards whereas the lower one represents the color of each card. Note that the dummy
cards to reduce hand size are also added (color “d” stands for dummy color).

that when we scan through it we can play ﬁve additional cards (of all colors) if and only if
the truth assignment satisﬁes the clause Wj. Thus, only when all clauses are satisﬁed the
Hanabi instance will have a solution.

As will be shown afterwards, it will be useful to temporarily reduce the amount of cards
that can be stored in hand (or even make it zero). This can be enforced with an additional
dummy color 2v + 1. Indeed, assume that when scanning a portion λ of the input we want
to make sure that hand size is one (for simplicity, we also assume that no card of the dummy
color appears in the whole sequence). Then, it suﬃces to add cards (2, 2v + 1) and (1, 2v + 1)
before and after λ, respectively. Since card (2, 2v + 1) appears exactly once, then its unique
appearance must be stored until card (1, 2v + 1) is found. Thus, only one additional card
can be stored while scanning λ. We call this gadget the hand reduction gadget.

Similarly, we can enforce independence between two gadgets by adding cards (4, 2v +
1), (5, 2v + 1), and (3, 2v + 1) between them. If cards (4, 2v + 1) and (5, 2v + 1) appear exactly
once in the sequence, they must be stored until the card (3, 2v + 1) is scanned (at which point
all three cards can be played). Since our hand size is two, this essentially makes sure that no
card can be stored between gadgets. Note that this trick can be done arbitrarily many times
provided that each time we use higher numbers of the dummy color (and each card appears
only once in the whole sequence). We call this operation the hand dump gadget. Note that
the gadgets are used to simulate a reduction in the hand size, but h remains constant. The
temporary reduction is created by forcing some cards to be stored during a portion of the
play sequence.
Let us ﬁrst consider the variable assigning phase. We ﬁrst describe the variable gadget.
For any i ≤ v, variable gadget Vi is deﬁned as the sequence Vi = 2, 2, 1, 3, 4, 5, 1, 3, 4, 5, where
overlined values are cards of color 2i, whereas the other cards have color 2i − 1. The ﬁrst
part of the Hanabi problem instance σ simply consists of the concatenation of all gadgets
V1, . . . , Vv, adding card (2, 2v + 1) in the very beginning and card (1, 2v + 1) in the very end
of the sequence, as to form a hand reduction gadget (see Figure 1). We call this sequence σ1.
(cid:73) Lemma 8. There is no valid play sequence of σ1 that can play cards of value 2 of colors
2i − 1, 2i and the dummy color 2v + 1. This statement holds for all i ≤ v.
Proof. Assume, for the sake of contradiction, that there exists some i ≤ v and a sequence
of plays for which we can play the three cards. In order to play card (2, 2v + 1) we need
to store it in the very beginning of the game enforcing the hand reduction gadget for the
duration of the variable assigning phace, thus temporarily reducing the hand-size to one.
Further notice that each card appears exactly once in σ1 (that is, the multiplicity of this
part is equal to 1), and that the cards of color 2i − 1 and 2i only appear in gadget Vi. More
importantly, the value 2 in both colors appears before the value 1 in the respective colors. In
particular, both must be stored before they are played. However, this is impossible, since we
(cid:74)
have decreased the hand size through the hand reduction gadget.

From now on, for simplicity in the description, we only consider play sequences that play
all the cards in the dummy color (recall that these cards appear exactly once. If any of them

J.-F. Baﬃer et. al.

11

4 5 3
d d d

10 11 9
d d d

z

C1

}|
}|

C2

3 3 3
1 4 5

2 4 5 6
1 1 1 1

2 4 5 6
4 4 4 4

8 8 8
1 3 6

7 9 10 11
1 1 1 1

7 9 10 11
3 3 3 3

{

2 4 5 6
5 5 5 5

{

7 9 10 11
6 6 6 6

z

6 7 8 9 10
1,4, and 5

5 6 7 8 9 10 2 3 4
2, 3, and 6

7 8 6
d d d

11 12 13 14 15

1,3, and 6

10 11 12 13 14 15 7 8 9
2, 4, and 5

13 14 12
d d d

Figure 2 Sequence σ2 for a SAT instance with three variables x1, x2, x3 and two clauses W1 =
(x1 ∨ ¬x2 ∨ x3), W2 = (x1 ∨ x2 ∨ ¬x3). Colors 1, 4, 5 are associated to W1 and colors 1, 3, 6 are
associated to W2. The upper row represents the numbers of the cards whereas the lower one the
color of each card. Note that the dummy cards to obtain independence between/inside gadgets are
also added (color “d” stands for dummy color).

is not played the resulting sequence of moves cannot be completed). Similarly, we assume
cards are played as soon as possible. In particular, if the card that is currently being scanned
is playable, then it will be immediately played. We can make this assumption because holding
it in hand is never beneﬁcial. We call these two conditions the smart play assumption.
Thus, the best we can do after scanning through all variable gadgets is to play ﬁve cards
of either color 2i − 1 or 2i (and only one card of the other color). This choice is independent
for all i ≤ v, hence we associate a truth assignment to a play sequence as follows: we say
that variable xi is set to true if, after σ1 has been scanned, the card (5, 2i − 1) has been
played, false if (5, 2i) has been played. For well-deﬁnement purposes, if neither (5, 2i − 1) or
(5, 2i) we simply consider the variable as unassigned (and say that an unassigned variable
never satisﬁes a clause). This deﬁnition is just used for deﬁnement purposes since, as we will
see later, no variable will be unassigned in a play sequence that plays all cards.

Let us now move on to the clause satisfaction phase by ﬁrst describing the clause gadget
Cj for clause Wj. We associate three colors to a clause. Speciﬁcally, we associate Wj with
color 2i − 1 if xi appears positive in Wj. If xi appears in negated form, we associate Wj
with color 2i instead. Since each clause contains three literals, it will be associated to three
distinct colors.
Let oj = 5(j − 1). Intuitively speaking, oj indicates how many cards of each color can be
played (we call this the oﬀset). Our invariant is that for all i ≤ v and j ≤ m, before scanning
through the clause gadget associated to Wj, there is a play sequence that plays up to oj + 1
cards in color 2i − 1 and oj + 5 in color 2i (or the reverse) and no play sequence can exceed
those values in any color. Observe that the invariant is satisﬁed for j = 1 by Lemma 8.

The clause gadget Cj is deﬁned as follows: we ﬁrst add the sequence oj + 6, oj +
7, oj + 8, oj + 9, oj + 10 for the three colors associated to Wj. Then we append the sequence
oj+5, oj+6, oj+7, oj+8, oj+9, oj+10, oj+2, oj+3, oj+4 in all other colors (except the dummy
color). After this we add three cards of the dummy color forming a hand dump gadget. Finally,
we add the sequence oj+3, oj + 3, oj + 3, oj+2, oj+4, oj+5, oj+6, oj + 2, oj + 4, oj + 5, oj + 6,
oj + 2, oj + 4, oj + 5, oj + 6 in the three colors associated to Wj (as before, the single and
double overline on the numbers is used to distinguish between the three colors). See Figure 2.
Let σ2 be the result of concatenating all clause gadgets in order, where before each Cj we
add three cards of the dummy color forming a hand dump gadget so as to make sure that no
card from one gadget can be saved to the next one (see Figure 3). Further let σ0 = σ1 ◦ σ2.
We must show that, when scanning a clause gadget that is satisﬁed, we can play ﬁve cards of
all colors. We start by showing that this is possible for the easy colors (i.e., colors for which
we played ﬁve cards in σ1 or those that are not associated to Wj).

12

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

σ1

4

5

3

C1

10

11

9

C2

. . .

6m − 2

6m − 1

6m − 3 Cm

Figure 3 Overall picture of the reduction. All cards depicted have dummy color (and are only

used to obtain independence between gadgets).

(cid:73) Lemma 9. Let k ≤ 2v be a color for which before processing clause gadget Cj we have
played up to oj + 5 cards of color k (for some j ≤ m) or a color not associated to Wj for
which we have played up to oj + 1 cards of color k. Then, we can play up to ﬁve more cards
of color k when processing the clause gadget Cj. Moreover no play sequence can play more
than ﬁve cards of that color.
Proof. Recall that there are hand dumps between diﬀerent gadgets. Thus, any cards that is
played while processing Cj must appear in Cj.

The case in which we played up to the value oj + 5 of a color is easy, since Cj contains
the sequence oj + 6, oj + 7, oj + 8, oj + 9, oj + 10 in consecutive fashion in all colors. Thus,
the ﬁve cards can be played without having to store anything in hand. Also note that a sixth
card cannot be played since oj + 11 is not present in any color in Cj.

The case in which we played up to oj + 1 of a color not associated to Wj is similar. In
this case, the cards of color k appear in the following order: oj + 5, oj + 6, oj + 7, oj + 8, oj +
9, oj + 10, oj + 2, oj + 3, oj + 4. It is straightforward to verify that if we are only allowed to
(cid:74)
store two cards we can play at most ﬁve cards.

The remaining case is that a color k is associated to Wj and only oj + 1 cards have
been played. Recall that, by the way in which we associated variable assignments and play
sequences, this corresponds to the case that the assignment of variable xdk/2e does not satisfy
the clause Wj. We now show that ﬁve cards of color k will be playable if and only if at least
one of the other two variables satisﬁes the clause.
(cid:73) Lemma 10. Let Cj be the clause gadget associated to Wj (for some j ≤ m). We can play
ﬁve cards in each of the three colors associated to Wj if and only if we have played card of
value oj + 2 in at least one of the three associated colors before Wj is processed. Moreover,
we can never play more than ﬁve cards in the three colors associated to Wj.
Proof. The proof is similar to the Lemma 9. By construction of our gadget, we ﬁrst ﬁnd
the sequence oj + 6, oj + 7, oj + 8, oj + 9, oj + 10 in all three colors associated to Wj. These
cards are unplayable if we have only played up to oj + 1, so the best we can do is to store
them. However, before we ﬁnd the smaller numbers of the same color, there is a hand dump
gadget. Thus none of these cards will be playable for colors in which, before Cj is processed,
we have only played cards of value at most oj + 1.

The only other cards of the associated color that are present in the gadget form
the sequence oj + 3, oj + 3, oj + 3, oj + 2, oj + 4, oj + 5, oj + 6, oj + 2, oj + 4, oj + 5, oj + 6,
oj + 2, oj + 4, oj + 5, oj + 6. Again, because of the hand dump gadget before and after this
sequence, no other cards can be played.

Consider the case in which we have played only up to oj + 1 of the three colors before
processing Cj (or equivalently, the variable assignment does not satisfy clause Wj). The ﬁrst
three cards we ﬁnd have the number oj + 3 in the three colors. None is currently playable,
thus ideally we would like to store them. Due to the limitations on our hand size, we can only
store two of the three cards. In particular, from the color whose card oj + 3 was discarded
we will only be able to play one card. Note that for this situation to happen it is crucial that
in none of the three colors we have played up to card oj + 5. When this condition is not
satisﬁed in at least one color we can make sure that ﬁve cards in all colors are played. (cid:74)

J.-F. Baﬃer et. al.

13

From the above results we know that by the time we scan through σ0 we can play at least
up to value om + 6 (in half of the colors we can play up to value om + 10) if and only if the
variable assignment created during the variable assignment phase satisﬁed all clauses. For
the dummy color, we used one hand size reduction gadget and two hand dump gadgets per
clause, thus 6m + 2 cards will have been played. We pad σ0 with values om + 6 to 6m + 2 in
increasing order in all colors (except the dummy color). Let σ be the resulting sequence.
(cid:73) Theorem 11. There is a valid solution of Hanabi for σ and h = 2 if and only if the
associated problem instance of 3-SAT is satisﬁable.
Proof. If the associated problem instance of 3-SAT is satisﬁable, there exists a truth
assignment satisfying all clauses, by Lemmas 8, 9 and 10, we can play all colors up to the
card 6m + 2 from σ. If the associated problem instance of 3-SAT is not satisﬁable, for any
truth assignment, there exists one or more clauses that are not satisﬁed. Let j be the index
of the ﬁrst clause that is not satisﬁed by the truth assignment. By Lemma 10, we will not be
able to play card oj + 3 in one of the three colors associated to Cj. Since the smallest number
of the next gadgets is oj + 7, no more cards can be played in that color. In particular, there
(cid:74)
cannot be a solution for this Hanabi problem instance.

Our reduction can be constructed in polynomial time and no card is repeated more than
twice. Further observe that we can use a hand reduction gadget in order to reduce the hand
size from any h > 2 down to 2. This completes the proof of Theorem 7.

Conclusions

6
In this paper we provided the ﬁrst algorithmic results on the complexity of the Hanabi game,
even if we forego with the hidden information issues. We provided linear time algorithms
for the cases where cards appear only once (r = 1) and when all cards have the same color
(c = 1). We showed that the game is already NP-hard when the hand-size is a small constant
(h ≥ 2) and cards appears at most twice (r = 2). Last, we gave an algorithm for the general
case running in time exponential in h and c, but polynomial in all other parameters.

Several questions regarding the complexity of the game remain unanswered. For example,
is the game still NP-complete if we bound the number of colors instead of the hand-size?
Also, can we obtain linear-time algorithms for the case where h and c are small constants (for
example when h = 1 and/or c = 2)? Furthermore, as the problem is very rich in parameters,
it would be fruitful to study it from a parameterized complexity point of view. Last, in our
paper we only looked into a solitaire version of the game. It would be interesting to extend
the model to more than one collaborating players.

References

1 Antoine Bauza. Hanabi. http://www.antoinebauza.fr/?tag=hanabi.
2 BoardGameGeek. https://boardgamegeek.com/boardgame/98778/hanabi.
3 Alex Churchill. Magic: The gathering is Turing complete. Unpublished manuscript avail-

able at http://www.toothycat.net/~hologram/Turing/index.html.
Erik D. Demaine. Personal communication.
Erik D. Demaine and Robert A. Hearn. Playing games with algorithms: Algorithmic
combinatorial game theory.
In Michael H. Albert and Richard J. Nowakowski, editors,
Games of No Chance 3, volume 56 of Mathematical Sciences Research Institute Publications,
pages 3–56. Cambridge University Press, 2009.
Spiel des Jahres award. http://www.spieldesjahres.de/en/hanabi.

4
5

6

14

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

7 Aviezri S. Fraenkel and David Lichtenstein. Computing a perfect strategy for n x n chess

requires time exponential in n. J. Comb. Theory, Ser. A, 31(2):199–214, 1981.

8 Martin Gardner. Mathematical Games: The Entire Collection of His Scientiﬁc American

Columns. The Mathematical Association of America, 2005.

9 Robert Hearn and Erik D. Demaine. Games, Puzzles, and Computation. A. K. Peters,

2009.

10 Kenichiro Nakai and Yasuhiko Takenaga. NP-completeness of Pandemic. Journal of In-

formation Processing, 20(3):723–726, 2012.

11 Hirotaka Osawa. Solving Hanabi: Estimating hands by opponent’s actions in cooperative
game with incomplete information. In AAAI workshop: Computer Poker and Imperfect
Information, pages 37–43, 2015.

15

J.-F. Baﬃer et. al.

A

The Rules of Hanabi

In this appendix we introduce the oﬃcial rules of Hanabi [1].

Game Material
50 ﬁreworks cards in ﬁve colors (red, yellow, green, blue, white):

10 cards per color with the values 1, 1, 1, 2, 2, 3, 3, 4, 4, 5,
5 colorful ﬁreworks cards with values of 1, 2, 3, 4, 5,
8 Clock (Note) tokens (+ 1 spare),
3 Storm (Fuse) tokens.

Aim of the Game
Hanabi is a cooperative game, meaning all players play together as a team. The players have
to play the ﬁreworks cards sorted by colors and numbers. However, they cannot see their
own hand cards, and so everyone needs the advice of his fellow players. The more cards the
players play correctly, the more points they receive when the game ends.

The Game
The oldest player is appointed ﬁrst player and sets the tokens in the play area. The eight Clock
tokens are placed white-side-up. The three Storm tokens are placed lightning-side-down.

Now the ﬁreworks cards are shuﬄed. Depending on the number of players involved, each

player receives the following hand:

With 2 or 3 players: 5 cards in hand,
With 4 or 5 players: 4 cards in hand.

Important: For the basic game, the colorful ﬁreworks cards and the spare Clock token(s) are
not needed. They only come in to use for the advanced game.
Important: Unlike other card games, players may not see their own hand! The players take
their hand cards so that the back is facing the player. The fronts can only be seen by the
other players. The remaining cards are placed face down in the draw pile in the middle of
the table. The ﬁrst player starts.

Game Play
Play proceeds clockwise. On a player’s turn, he must perform exactly one of the following:

A. Give a hint or
B. Discard a card or
C. Play a card.

The player has to choose an action. A player may not pass!
Important: Players are not allowed to give hints or suggestions on other players’ turns!

A. Give a hint
To give a hint one Clock token must be ﬂipped from its white side to its black side. If there
are no Clock tokens white-side-up then a player may not choose the Give a hint action. Now
the player gives a teammate a hint. He has one of two options:

16

Hanabi is NP-complete, Even for Cheaters who Look at Their Cards

1. Color Hint. The player chooses a color and indicates to his/her teammate which of their
hand cards match the chosen color by pointing at the cards. Important: The player
must indicate all cards of that color in their teammate’s hand! Example: “You have two
yellow cards, here and here.” Indicating that a player has no cards of a particular color is
allowed! Example: “You have no blue cards.”

2. Value Hint. The player chooses a number value and gives a teammate a hint in the exact
same fashion as a Color Hint. Example: “You have a 5, here.” Example: “You have no
Twos.”

B. Discard a card
To discard a card one Clock token must be ﬂipped from its black side to its white side. If
there are no Clock tokens black-side-up then a player may not choose the Discard a card
action. Now the player discards one card from their hand (without looking at the fronts of
their hand cards) and discards it face-up in the discard pile near the draw deck. The player
then draws another card into their hand in the same fashion as their original card hands,
never looking at the front.

C. Play a card
By playing out cards the ﬁreworks are created in the middle of the table. The player takes
one card from his hand and places it face up in the middle of the table. Two things can
happen:
1. The card can be played correctly. The player places the card face up so that it extends

a current ﬁrework or starts a new ﬁrework.

2. The card cannot be played correctly. The gods are angry with this error and send a
ﬂash from the sky. The player turns a Storm tile lightning-side-up. The incorrect card is
discarded to the discard pile near the draw deck.

In either case, the player then draws another card into their hand in the same fashion as
their original card hands, never looking at the front.

The Fireworks
The ﬁreworks will be in the middle of the table and are designed in ﬁve diﬀerent colors. For
each color an ascending series with numerical values from 1 to 5 is formed. A ﬁrework must
start with the number 1 and each card played to a ﬁrework must increment the previously
played card by one. A ﬁrework may not contain more than one card of each value.

Bonus
When a player completes a ﬁrework by correctly playing a 5 card then the players receive a
bonus. One Clock token is turned from black side to white side up. If all tokens are already
white-side-up then no bonus is received. Play then passes to the next player (clockwise).

Ending the Game
The game can end in three ways:

1. The third Storm token is turned lightning-side-up. The gods deliver their wrath in the
form of a storm that puts an end to the ﬁreworks. The game ends immediately, and the
players earn zero points.

J.-F. Baﬃer et. al.

17

2. The players complete all ﬁve ﬁreworks correctly. The game ends immediately, and the

players celebrate their spectacular victory with the maximum score of 25 points.

3. If a player draws the last card from the draw deck, the game is almost over. Each
player—Including the player who drew the last card—gets one last turn. Note: Cards
cannot be drawn in this last round.
Finally, the ﬁreworks will be counted. For this, each ﬁrework earns the players a score
equal to the highest value card in its color series. The quality of the ﬁreworks display
according to the rating scale of the “International Association of Pyrotechnics” is:

0–5: Oh dear! The crowd booed.
6–10: Poor! Hardly applaused.
11–15: OK! The viewers have seen better.
16–20: Good! The audience is pleased.
21–24: Very good! The audience is enthusiastic!
25: Legendary! The audience will never forget this show!

Important Notes and Tips

Players may rearrange their hand cards and change their orientation to help themselves
remember the information they received. Players may not ever look at the front of their
own cards until they play them.
The discard pile may always be searched for information.
Hanabi is based on communication—and non-communication—between the Players. If
one interprets the rules strictly then players may not, except for the announcements of
the current player, talk to each other. Ultimately, each group should decide by its own
measure what communication is permitted communication. Play so that you have fun!

