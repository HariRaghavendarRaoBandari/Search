6
1
0
2

 
r
a

 

M
6
1
 
 
]

.

C
O
h
t
a
m

[
 
 

1
v
6
9
9
4
0

.

3
0
6
1
:
v
i
X
r
a

Relaxed Connected Dominating Set Problem

with Application to Secure Power Network Design

Kin Cheong Sou and Jie Lu

Abstract— This paper investigates a combinatorial optimiza-
tion problem motived from a secure power network design
application in [D´an and Sandberg 2010]. Two equivalent graph
optimization formulations are derived. One of the formulations
is a relaxed version of the connected dominating set problem,
and hence the considered problem is referred to as relaxed
connected dominating set (RCDS) problem. The RCDS problem
is shown to be NP-hard, even for planar graphs. A mixed
integer linear programming formulation is presented. In ad-
dition, for planar graphs a ﬁxed parameter polynomial time
solution methodology based on sphere-cut decomposition and
dynamic programming is presented. The computation cost of
the sphere-cut decomposition based approach grows linearly
with problem instance size, provided that the branchwidth of
the underlying graph is ﬁxed and small. A case study with IEEE
benchmark power networks veriﬁes that small branchwidth are
not uncommon in practice. The case study also indicates that
the proposed methods show promise in computation efﬁciency.

I. INTRODUCTION

Our society depends heavily on the proper operation
of network systems including intelligent transport systems,
electric power distribution and transmission systems etc.
These systems are supervised and controlled through Super-
visory Control And Data Acquisition (SCADA) systems. For
instance, in the electric power transmission grid, SCADA
systems collect measurements through remote terminal units
(RTUs) and send them to the state estimator to estimate
the system states. The estimated states are used for subse-
quent operations such as contingency analysis (for system
health monitoring) and optimal power ﬂow dispatch (for
control). Any malfunctioning of these operations can lead
to signiﬁcant social and economical consequences such as
the northeast US blackout of 2003.

Because of its importance,

the SCADA measurement
system has been the subject of extensive studies. Recently, an
important measurement system related research topic which
has attracted a lot of attention is cyber-physical security. One
of the purposes of cyber-physical security studies is to ana-
lyze various types of data attacks and their consequences on
the system (e.g., [1]–[7]). Another important research direc-
tion, which is the focus of this paper, is security-guarateeing
system design. A typical design objective is to seek the
minimum cost strategic placement of protection resources
(e.g., encryption devices, secure phasor measurement units)
so that, according to the chosen attack and defense model,
no data attack in the system is possible (e.g., [2], [4], [7]).
The security-guaranteeing system design problem is also
closely related to the problem of observability-guaranteeing
system design in power systems (e.g., [8], [9]). Because of

the combinatorial feature, the protection placement problems
are typically partially addressed, without obtaining solutions
with optimality guarantee. For example, [2], [4], [7] consider
various types of heuristic algorithms for protection place-
ment, aiming to minimize the protection cost. Reference [6]
provides a suboptimal (in economic sense) strategy for some
given possible attack scenarios. Instead, this paper reports
an exact solution methodology, with optimality guarantee,
to a nontrivial system protection placement problem ﬁrst
described in [2]. The design problem, to be described in
Section II, seeks a minimum cost strategy to encrypt the
measurement communications in a power network, in order
to prevent stealth data attack of the form in [1]. Reference [2]
points out that the design problem is related to a dominating
set problem, and proposes a heuristic suboptimal solution
algorithm based on the observation. While the analysis in
[2] is performed in a linear algebra setting involving matrix
rank calculations, this paper investigates the problem from a
graph perspective and formulates two equivalent graph opti-
mization formulations characterizing the problem. We prove
that the design problem is NP-hard (even when restricted
to planar graphs). In addition, we derive a mixed integer
linear programming formulation of the problem that is easy
to implement (with three sets of constraints) and reasonably
efﬁcient to solve (e.g., CPLEX solves an instance with 300
vertices in less than one second on a personal computer). To
enable the design with very large-scale systems we develop
a ﬁxed parameter polynomial time design algorithm, which
is a two-step procedure based on sphere-cut decomposition
[10] and dynamic programming. This approach provides an
exact solution to the design problem when the underlying
graph is planar, and provides a (reasonably tight) upper
bound in general. The main advantage of the proposed
approach is computation efﬁciency in practice. In addition,
the computation cost grows linearly with problem instance
size (i.e., number of edges), provided that a graph structure
parameter called branchwidth [10] is ﬁxed and small. In
practice, it is not uncommon (as indicated by the IEEE power
network benchmarks) that the branchwidth of an application
graph is small, because intuitively branchwidth is a measure
of how closely a graph resembles a tree (branchwidth ≤
2 for trees). The sphere-cut decomposition (resp., branch
decomposition and tree decomposition) approach has been
applied with success to provide ﬁxed parameter polynomial
time algorithms for difﬁcult combinatorial problems (e.g.,
[11], [12]). In fact, [13], a precursor to this paper, applies
the branch decomposition technique to solve the standard
dominating set problem related to the design problem in

this paper. The main difference between the current paper
and [13] is that the exact model for the design problem is
considered here. In addition, the complexity analysis, the
integer programming formulation and the tailored sphere-
cut decomposition based optimization algorithm are reported
for the ﬁrst time. The current paper is also similar to two
previous work in algorithmic computer science/combinatorial
optimization, namely [14], [15]. In particular, reference [14],
which is more related to this paper, describes a sphere-
cut decomposition/dynamic programming algorithm for the
connected dominating set problem. Part of the distinction
of this paper is that we consider a relaxed (and more
general) version of the connected dominating set problem.
As a result, the dynamic programming algorithm needs to
be generalized. Moreover, reference [14] focuses purely on
the theoretical optimization problem, while we formulate the
relaxed connected dominating set problem from application.
Outline: In Section II the secure system design problem is
described. In Section III two equivalent graph optimization
formulations modeling the secure system design problem are
presented. The complexity of the problem is also discussed.
Section IV introduces the two-step ﬁxed parameter polyno-
mial time algorithm for planar graphs. It reviews the ﬁrst step
– sphere-cut decomposition. Section V explains the second
step – dynamic programming to solve the design problem.
The parameterized complexity is brieﬂy discussed in the end
of the section. Section VI presents a numerical case study
on IEEE power network benchmarks. It demonstrates the
practical usefulness of the presented solution approaches.

II. APPLICATION MOTIVATIONS

A power network can be modeled as an undirected graph
where the vertices are buses, and the edges are transmission
lines. Following [2], this paper adopts the DC power ﬂow
model [16] as the measurement model for state estimation. In
the setup of [2], each bus is equipped with a remote terminal
unit (RTU) which can measure all of the following quantities:
(net) active power injection at the bus and active power ﬂows
on the transmission lines incident to the bus. The voltage
phasors at the buses are estimated based on the measurements
from the RTUs.

In power system operations, it is a standard practice to
employ a “bad data detection” scheme to detect possible
anomalies in the measurements. Typically if there is only one
attacked measurement, the detection scheme can detect it.
However, coordinated additive attacks on multiple measure-
ments may evade detection. Additivity means the attacked
measurement is the sum of the original measurement and
a modiﬁcation (i.e., the attack). Reference [1] reports that
the attacks will avoid detection if they can be interpreted
as voltage-phasor-induced active power ﬂows and injections.
That is, detection is avoided if some ﬁctitious voltage phasors
can be associated with the buses such that
(A1) the modiﬁcation to the active power ﬂow on a trans-
mission line is proportional (with appropriate constant)
to the difference of the ﬁctitious voltage phasors at the
incident buses,

(A2) at each bus the modiﬁcation to active power injection
satisﬁes Kirchhoff’s current law with the modiﬁcations
to active power ﬂows on incident transmission lines.

To counter these attacks, [2] considers the scenario in which
buses can be protected by installing encryption devices at
RTUs. The protection rule is as follows:
(P1) if a bus is protected then none of the measurements
related to the bus can be modiﬁed. The related mea-
surements include the active power injection at
the
bus, as well as the active power ﬂows on all incident
transmission lines.

(P2) if a bus is not protected, then the active power injection

measurement at the bus can be modiﬁed.

(P3) if a transmission line is not incident to any protected
bus, then the active power ﬂow measurements on it can
be modiﬁed.

A subset of buses is called a perfect protection set if when
protection is placed in the buses of the set, according to the
protection rule above, there cannot be any detection avoiding
data attack with ﬁctitious voltage phasors satisfying attack
rules (A1) and (A2). In [2], the perfect protection problem
seeks the minimum cardinality perfect protection set.

III. PROBLEM FORMULATIONS AND COMPLEXITY

A. Notations and deﬁnitions

Let (V,E) be a simple undirected graph modeling a power
network, with V being the vertex set and E ⊆ {{u,v} | u ∈
V,v ∈ V } being the edge set. In this paper, we use the
unordered pair {u,v} to denote an (undirected) edge. For
any graph G, we use the symbols V (G) and E(G) to denote
the sets of vertices and edges, respectively. The following
graph concepts are used throughout the paper:
incidence: For a pair v ∈ V and e ∈ E, v and e are incident
to each other if v ∈ e. For any U ⊆ V , an edge e ∈ E
is incident to U if e ∩U 6= /0. For any A ⊆ E, a vertex
v ∈ V is incident to A if v ∈ ∪
e∈A

e.

(edge) induced subgraph: For A ⊆ E,
duced by A is (VA,A) where VA = ∪
e∈A

the subgraph in-
e.

path: A path between i, j ∈ V is a sequence of vertices i =
i0, . . . ,ip = j such that {ik,ik+1} ∈ E for 0 ≤ k ≤ (p −1).
connected component: A connected component is a max-
imal subgraph such that between any two distinct ver-
tices in the subgraph there exists a path between them.
dominating set: A set D ⊆ V is a dominating set of graph
(V,E) if every v ∈ V is either in D or there exists u ∈ D
such that {u,v} ∈ E.

face: For a plane graph G on sphere S

open regions of S
Fig. 2 has four faces, including the outer face).

, the faces of G are
divided by G (e.g., each graph in

A set D ⊆ V is called a (graph) perfect protection set if the
bus set corresponding to D is a perfect protection set for the
power network modeled by (V,E). Accordingly, the (graph)
perfect protection problem seeks a minimum cardinality
perfect protection set.

B. Problem formulations

The following discussions describe two equivalent alterna-
tive deﬁnitions of a (graph) perfect protection set. The two
alternative deﬁnitions lead to two equivalent formulations of
the perfect protection problem with different beneﬁts. The
ﬁrst equivalent deﬁnition is as follows:

Proposition 1: Let graph (V,E) be given. A set D ⊆ V is
a perfect protection set if and only if the subgraph (V,E ′) is
connected, where E ′ ⊆ E is the set of edges incident to D.
Proof: Let V be the set of buses and E be the set of
transmission lines for the power network associated with the
graph (V,E). If {u,v} ∈ E ′, then either bus u, v or both is
protected. According to protection rule (P1) and transmission
line constitutive relation (i.e., attack rule (A1)), the ﬁctitious
voltage phasors at u and v are the same. Therefore, if (V,E ′)
is connected the ﬁctitious voltage phasors at all buses are
the same. In this case, non-zero data attack is impossible.
Conversely, suppose (V,E ′) is not connected. Let (V0,E0) be
a connected component of (V,E ′). Let ˜E = {{u,v} ∈ E | u ∈
V0,v ∈ V \V0}. That is, ˜E connects (V0,E0) with the rest of
the (V,E) if the edges in ˜E were not removed. Note that
˜E * E ′, since otherwise (V0,E0) would not be a (maximal)
connected component in (V,E ′). Hence, if {u,v} ∈ ˜E then
neither bus u nor bus v is protected. By protection rules (P2)
and (P3), the injection measurements at u and v, as well as
the power ﬂow measurement on transmission line {u,v} can
be modiﬁed by the attack. As a result, a detection avoiding
data attack can be constructed as follows: set the ﬁctitious
voltage phasors at all buses in V0 to be one and the ﬁctitious
voltage phasors at all other buses to be zero. Then, for every
{u,v} ∈ ˜E assuming without loss of generality that u ∈ V0
and v /∈ V0, the active power ﬂow attack on transmission line
{u,v} equals the proportional constant in attack rule (A1),
denoted as Huv. In addition, there is Huv units of active
power injection modiﬁcation into u and Huv unit of active
power extraction modiﬁcation from v. At all edges not in ˜E,
the active power ﬂow attacks are zero because the ﬁctitious
voltage phase angle difference is nonzero if and only if the
transmission line is in ˜E. Also, attack rule (A2) can be
satisﬁed by setting the active power injection modiﬁcations
to zero for all buses not incident to ˜E. As a result, the desired
detection avoiding data attack is constructed when (V,E ′) is
not connected.

Remark 1: See Fig. 2 (left graph) for an example of
a perfect protection set (vertices in black) satisfying the
condition in Propostion 1.
(cid:3)
Remark 2: The connected components of (V,E ′) in the
statement of Proposition 1 correspond to observable islands
in the terminology of power network state estimation observ-
ability analysis [16].
(cid:3)
Remark 3: Proposition 1 implies that perfect protection
sets can be found only in connected graphs.
(cid:3)
An alternative equivalent deﬁnition of a perfect protection
set is as follows:

Proposition 2: Let graph (V,E) be given. A set D ⊆ V is
a perfect protection set if and only if D satisﬁes conditions

1) D is a dominating set of (V,E), and

2) For any i ∈ D and j ∈ D, there exists a sequence i =
i0,i1, . . . ,ip = j with {ik,ik+1} ∈ E for 0 ≤ k ≤ (p − 1).
In addition, if 0 ≤ s < t ≤ p is such that is,it ∈ D but
ik /∈ D for all s < k < t, then s = t − 2.

Proof: We denote by C1 the condition that the subgraph
(V,E ′), as deﬁned in Proposition 1, is connected. On the
other hand, we denote by C2 conditions 1) and 2) in Propo-
sition 2. To establish the claim of the statement, it sufﬁces to
show that C1 and C2 are equivalent. First, suppose C1 holds
for D. Suppose D is not a dominating set of (V,E). Then,
there exists v ∈ V such that neither v nor any of its neighbors
is in D. By the deﬁnition of E ′ in Proposition 1, the vertex
v is isolated in (V,E ′). This is a contradiction of C1, and
hence D satisfying C1 must be a dominating set of (V,E).
Further, since by C1 (V,E ′) is connected, for every i, j ∈ D
there is a path in (V,E ′) between i and j. Since every edge
in the path is incident to at least one vertex in D (according
to the deﬁnition of E ′), the sequence of vertices traversed by
the path satisfy part 2) of condition C2. Therefore, C1 implies
C2. Conversely, suppose D does not satisfy C1 (i.e., (V,E ′) is
not connected). Assume further that D is a dominating set of
(V,E) (otherwise part 1) of C2 fails to hold). Let (V0,E0) be
a connected component of (V,E ′) such that V0 ∩ D 6= /0 and
let i denote a vertex in V0 ∩D. Since (V,E ′) is not connected,
V \ V0 6= /0. In addition, D ∩ (V \ V0) 6= /0 since otherwise D
is not dominating. Hence, there exists some j ∈ D ∩ (V \V0).
˜E = {{u,v} ∈ E | u ∈ V0,v ∈ V \ V0}. Then, any path
Let
between i and j must traverse an edge in ˜E. Let {s,t} ∈ ˜E be
a traversed edge, then, according to the analysis in the proof
of Proposition 1, s /∈ D and t /∈ D. As a result, any sequence
i = i0,i1, . . . ,ip = j with {ik,ik+1} ∈ E for 0 ≤ k ≤ (p−1) fails
to satisfy part 2) of C2. Hence, if C1 does not hold for D,
either part 1) or part 2) of C2 must fail to hold. Consequently,
C2 implies C1, and hence C1 and C2 are equivalent.

Remark 4: See Fig. 2 (left graph) for an example of
a perfect protection set (vertices in black) satisfying the
conditions in Propostion 2.
(cid:3)

Remark 5: A connected dominating set Dc (e.g., [17]) is a
dominating set with the additional property that between any
two vertices in Dc there exists a path traversing vertices only
in Dc. Condition 2) in Proposition 2 is a relaxed notion of
connectedness. For D satisfying condition 2), between any
two vertices in D there exists a “relaxed path” such that
between two consecutive members of D along the path there
can be one vertex not in D. This motivates the terminology
“relaxed connected dominating set” (RCDS), for any D ∈ V
satisfying conditions 1) and 2) in Proposition 2.
(cid:3)

Remark 6: For any given graph, we use the symbols
{DS}, {CDS}, {RCDS} to denote the sets of all dominating
sets, connected dominating sets and RCDSs respectively. By
condition 1) in Proposition 2 and Remark 5, it holds that
{CDS} ⊆ {RCDS} ⊆ {DS}. See Fig. 1 for an example. (cid:3)

As a consequence of Proposition 1 and Proposition 2, the
perfect protection problem posed in [2] can be described

#
"

$
"

!
"

%
"

’
"

&
"

Fig. 1: In this example graph, a minimum connected dom-
inating set can be {1,2,3,4}. A minimum RCDS can be
{1,2,4}, while a minimum dominating set can be {1,4}.

equivalently as the following optimization problems:

minimize

D⊆V

|D|

subject to (V,E ′) is connected (cf. Proposition 1).

minimize

D⊆V

|D|

subject to D satisﬁes 1) and 2) in Proposition 2.

(1)

(2)

Problems (1) and (2) are referred to as RCDS problem. In
sequel, we use exclusively the terminology RCDS problem
in place of perfect protection problem.

C. Complexity of the RCDS problem

A proof similar to the one in [18] establishes the NP-

hardness of the RCDS problem.

Proposition 3: The RCDS problem in (2) is NP-hard, even
if the problem is restricted to instances with planar graphs.
Proof: The proof is shown by a reduction from the
planar vertex cover problem whose proof of NP-hardness
can be found in, for example, [19]. Let G = (V,E) be a
planar graph with an arbitrary given embedding, deﬁning an
instance of the planar vertex cover problem. We use symbol
G both for the planar graph and the plane graph given by
the embedding. We assume that G is connected since the
minimum vertex cover of a graph is the union of minimum
vertex covers of the connected components. We construct an
auxiliary bipartite graph G′ = (V ′,U ′,E ′) as follows:

• Vertex set V ′ = V ∪F ′, where F ′ and the set of all faces

of G are one-to-one correspondent.

• Edge set E ′ = E ′

ve ∪ E ′

• Vertex set U ′ = A ∪ F. The sets A and E are one-to-one
correspondent. The set F and the set of all faces of G
are one-to-one correspondent.
v f ∪ E ′

f . For each e = {u,v} ∈ E,
there are two edges {u,e} and {e,v} in E ′
ve. For each
f ∈ F, there is an edge {v, f } ∈ E ′
v f with v ∈ V if and
only if v is incident to the face (of G) corresponding to
f . For each face f of G, there is an edge { f , f ′} ∈ E ′
f ,
with f , f ′ corresponding to the same face.

By construction, G′ is a connected planar graph. The reduc-
tion proof consists of two steps. First, we show that for any
VC ⊆ V being a vertex cover of G, the subgraph of G′ induced
by VC ∪ F is connected. It sufﬁces to show that between
any two vertices f ,g ∈ F there is a path traversing vertices
entirely in VC ∪ F, because all vertices in V has at least one
neighbor in F. We consider the dual graph G∗ of G. The
relevant properties of G∗ are as follows (e.g., [20]):

• each vertex in G∗ corresponds to a face of G (i.e., a

member of F in G′),

• each edge connecting two vertices in G∗ corresponds
to an edge (i.e., a member of A in G′) shared by the
boundaries of the two faces in G,

• G∗ is connected if and only if G is connected.

As a result, for f ,g ∈ F (in G′), there exists a sequence
( f =) f1,e1, f2,e2, . . . ,ep−1, f p(= g) for fk ∈ F and ek ∈ A that
corresponds to a path connecting f and g in G∗. Since VC is a
vertex cover of G, each ek is covered by (at least) one vertex
in VC denoted by vek ∈ VC. Consequently, the sequence ( f =
) f1,ve1, f2,ve2 , . . . ,vep−1, f p(= g) is a walk in G′ traversing
vertices entirely in VC ∪ F. This establishes the claim of the
ﬁrst step (of the reduction proof).

For the second step, we show that from every minimum
RCDS of G′ (minimum RCDS exists because G′ is con-
nected) it is possible to construct a minimum vertex cover
of G. To begin, note that any RCDS must include at least
f ∈ F and f ′ ∈ F ′ associated with each face of
one of
G because the vertices in F ′ must be dominated. Since it
is always more advantageous to contain f
than to contain
f ′, from every minimum RCDS it is always possible to
construct a (possibly different) minimum RCDS that includes
F but not F ′. We refer to this as claim (a). In turn, the
inclusion of F means that the vertices in V are dominated.
To dominate the vertices in A, it is possible that vertices in
A are chosen in a RCDS. However, let D denote a RCDS
such that F ⊂ D and A ∩ D 6= /0, we can construct another
RCDS, denoted D′, such that A ∩ D′ = /0 and D′ satisﬁes
conditions 1) and 2) in Proposition 2 (to be shown shortly).
We construct D′ by replacing each {u,v} ∈ A ∩ D with either
u ∈ V or v ∈ V . By construction D′ satisﬁes condition 1) in
Proposition 2. If {u,v} ∈ D and the subsequence u, {u,v},v is
on some “relaxed path” whose two ends are vertices not in
A (this is to establish condition 2) in Proposition 2), then
the subsequence u, {u,v},v can be replaced with u, fuv,v,
where fuv corresponds to a face with which both u and v
are incident. The new subsequence is valid for the relaxed
(connected) path because F ⊂ D′ (as F ⊂ D). As a result, D′
is also a RCDS and |D′| ≤ |D| (inequality is strict for example
when u ∈ D and it replaces {u,v} ∈ A ∩ D). We refer to this
as claim (b). As a consequence of claims (a) and (b), it is
without loss of generality to search for a minimum RCDS for
G′ with candidates of the form U ∪F, where U ⊆ V . Though
U ∪ F need not be a RCDS for some U ∈ V . However, more
specialization on U can be inferred. By deﬁnition of RCDS,
all vertices in A need to be dominated. Because vertices of
F are not neighbors of vertices in A. The vertices of A must
be dominated by the vertices in U ⊆ V , meaning that U
must be a vertex cover of G. Therefore, if a RCDS is of
the form U ∪ F with U ⊆ V then U = VC for some vertex
cover of G. This is referred to as claim (c). In addition, as
shown in the ﬁrst step of the reduction proof, VC being a
vertex cover of G implies that the subgraph (of G′) induced
by VC ∪ F is connected. This connectedness fact, combined
with claims (a), (b) and (c), leads to the conclusion that the

RCDS problem is equivalent to a restricted version in which
all solution candidates have the form VC ∪ F for VC being
a vertex cover of G. Consequently, the minimum objective
value of the RCDS problem on G′ is |V ⋆
C | + |F|, where |V ⋆
C |
is the cardinality of a minimum vertex cover of G. This
value of the optimal objective value, together with claims
(a), (b) and (c), implies that from any optimal solution to
the RCDS problem on planar graph G′ we can construct a
minimum vertex cover for planar graph G. This concludes
the reduction proof.

D. Integer programming formulation for RCDS problem

For a given graph (V,E), to model the RCDS problem in
(1) as a mixed integer linear program, the following notations
are needed. For each i ∈ V , we denote the neighborhood Ni :=
{ j | {i, j} ∈ E}, and the closed neighborhood ¯Ni := Ni ∪ {i}.
In addition, we designate (arbitrarily) a source vertex s ∈ V .
Then, the mixed integer linear program is as follows:

minimize

x,y

subject to

|V |

i=1

xi
yi j − (cid:229)

y ji = −1, ∀i ∈ V \ {s}

j∈Ni

j∈Ni
yi j + y ji ≤ (|V | − 1)(xi + x j), ∀{i, j} ∈ E
xi ∈ {0,1}, ∀i, yi j ≥ 0, y ji ≥ 0, ∀{i, j} ∈ E

(3)
The decision variables are deﬁned such that i ∈ V is in the
RCDS if and only if xi = 1. The decision variables yi j and
y ji for each {i, j} ∈ E are auxiliary “network ﬂow” variables
along the edges in two possible directions, in order to model
connectedness of the subgraph (V,E ′) (recall that E ′ is the
set of edges incident to the RCDS). The ﬁrst constraint is
ﬂow conservation constraint at all vertices except the source
s. This means that for every i ∈ V \ {s} one unit of ﬂow is
being shipped from s to i. The second constraint, together
with the nonnegativity of the ﬂows in the third constraint,
speciﬁes that an edge {i, j} can be used to ship ﬂows if and
only if at least one of its two ends is chosen in the RCDS.
In other words, an edge has the capacity to show ship ﬂows
if and only if it is in E ′. As a result, the three constraints
together model the requirement that (V,E ′) is connected.

IV. BRANCHWIDTH AND SPHERE-CUT DECOMPOSITION
If the given graph G = (V,E) is planar, the RCDS problem
can be solved in time linear with problem instance size (i.e.,
|E|) when a graph structure parameter called branchwidth (to
be deﬁned shortly) is ﬁxed. The proposed approach, which
resembles but generalizes the ones in [14], [15], consists
of two steps. Firstly, an optimal sphere-cut decomposition
(to be deﬁned) of G is computed. Secondly, a dynamic
programming algorithm, based on the computed sphere-cut
decomposition, solves the RCDS problem.

Given a graph (V,E), a branch-decomposition [10] is a
pair (T,t ) where T is a unrooted binary tree with |E| leaf
vertices, and t
is a bijection from the set of leaf vertices
of T to E. Every non-leaf vertex of T has degree three.
For any e ∈ E(T ),
the subgraph (V (T ),E(T ) \ {e}) has

two connected components denoted T1(e) and T2(e). Let
E1(e) ⊆ E and E2(e) ⊆ E correspond to the leaf vertices of
T1(e) and T2(e), respectively. We deﬁne G1(e), G2(e) to be
the subgraphs of G induced by E1(e) and E2(e) respectively.
For e ∈ E(T ), we deﬁne the middle set, denoted w (e),
to be V (G1(e)) ∩ V (G2(e)). In other words, w (e) := {v ∈
V v ∈ e1,v ∈ e2, for some e1 ∈ E1(e) and e2 ∈ E2(e)}. The
width of branch-decomposition (T,t ) is maxe∈E(T ) |w (e)|.
The branchwidth of (V,E) is the minimum width over all
branch-decompositions of (V,E). A branch-decomposition of
(V,E) is optimal if its width is the branchwidth of the graph.
We further assume that G = (V,E) is planar, with an
arbitrary plane graph drawing on the sphere S = {(x,y,z) ∈
R3 | x2 + y2 + z2 = 1}. Following standard convention, we
do not distinguish the corresponding concepts between the
planar graph and its drawing (e.g., symbol G, vertices,
edges). A noose is a simple closed curve (i.e., homeomorphic
to a circle) on S
that intersects G only at the vertices and
intersects each face of G at most once. A noose O separates S
into two regions. We call a branch-decomposition a sphere-
cut decomposition, if for each e ∈ T , there exists a noose
Oe with its two associated separated regions D 1 and D 2 of S
,
satisfying G1(e) ⊆ D 1 ∪ Oe and G2(e) ⊆ D 2 ∪ Oe. Note that
by deﬁnition of a noose (i.e., intersecting G only at vertices)
and deﬁnition of Oe, it holds that Oe ∩G = w (e). That is, the
noose Oe intersects G exactly in the middle set. Traversing
Oe, either in clockwise or counterclockwise direction, leads
to a cyclic order on w (e).

In general, it is NP-hard to compute the branchwidth of
a graph [21]. However, for planar graphs computing branch-
width is polynomial time [21]. For instance, the ratcatcher
algorithm in [21] computes the branchwidth of a planar graph
(V,E) in O(log2(|V |)(|V | + |E|)2) time. As shown in [15],
given the branchwidth constructing an optimal sphere-cut
decomposition for a planar graph is also polynomial time
(e.g., O(|V |3) in [22]). Further, given an optimal sphere-
cut decomposition (T,t ), a (noose-induced) cyclic order
associated with w (e) for each e ∈ E(T ) can be computed
by a face traversal of (V,E) in O(|E|) time. In sequel, we
assume a cyclic order is available, and it is denoted p (e) for
all e ∈ E(T ). We arbitrarily designate a vertex in w (e) to
be the ﬁrst entry in the cyclic order p (e). With an optimal
sphere-cut decomposition and a cyclic order computed, an
efﬁcient dynamic programming algorithm can be described
in the next section to solve the planar RCDS problem.

V. FIXED PARAMETER POLYNOMIAL TIME DYNAMIC

PROGRAMMING FOR PLANAR RCDS PROBLEM

A. Intuitive introduction

Let H = (U,A) be a graph, D ⊆ U and A′ ⊆ A be the
set of edges incident to D (cf. Proposition 1). We refer a
connected component of (U,A′) to as a relaxed connected
component (of H resulted from D). We use the shorthand
RCC for relaxed connected component. When referring to
a RCC in subsequent discussions, H is typically one of the
G1(e) or G2(e) subgraph resulted from removing an edge
e ∈ E(T ) in sphere-cut decomposition tree T (of the graph

(cid:229)
(cid:229)
B. Rooting sphere-cut decomposition tree
First, we need the following deﬁnitions:

T ′: Let (T,t ) be an optimal branch-decomposition of graph
(V,E). Construct T ′, a rooted tree from T by inserting
two new vertices: (a) vertex z into any edge {u,v} ∈
E(T ), and (b) vertex r (the root vertex) forming an edge
{z,r}. Speciﬁcally, let {u,v} ∈ E(T ), then T ′ =(cid:0)V (T )∪
{z,r}, (E(T ) \ {u,v}) ∪ {{u,z}, {z,v}, {z,r}}(cid:1).
Ge: For each e ∈ E(T ′), a leaf vertex u ∈ V (T ′) is a
descendant of e if the (unique) path from root r to u
traverses e. Let VT ′ (e) denote the subset of leaf vertices
of T ′ that are descendants of e. Then, Ge is deﬁned as
the edge-induced subgraph of (V,E) whose edge set is
t −1(VT ′(e)). Ge is one of the G1(e) and G2(e) in the
discussion on branch decomposition in Section IV.
′: Recall the deﬁnition of middle set w (e) ⊆ V for e ∈ E(T )
in Section IV. We deﬁne a function w
′ : E(T ′) 7→ V
′({u,z}) = w
as follows: let w
′({z,v}) =
w ({u,v}) and w
for all e ∈ E(T ′) \
{{u,z}, {z,v}, {z,r}}. Notice that w
′(e) ⊆ V (Ge) be-
cause all members of w
′(e) are incident to t (VT ′(e)) =
E(Ge), and the subset inclusion can be strict. The vertex
subset w
′(e) can be interpreted as the “boundary” of Ge.
e1, e2: For each edge e ∈ E(T ′) not incident to a leaf vertex
in T ′, let ve ∈ V (T ′) denote the vertex incident to e and
having e on the path from the root r to ve. There are
two other edges incident to ve. Let e1 and e2 denote
these two edges. They are the two children of e.

′({z,r}) = /0, w
′(e) = w (e)

w

Fig. 2: In the two ﬁgures, G1(e) (resp., G2(e)) is the subgraph
induced by solid (resp., dashed) edges. The intersection
vertex set w (e) are shaded. In both ﬁgures, a vertex belongs
to a RCDS candidate if and only if it is colored black. Note
that in both ﬁgures vertices of w (e) have the same colorings
(i.e., all black). However, only the left case corresponds to
a valid RCDS. The right case contains two RCCs (one RCC
is enclosed by a red dotted curve), and hence it does not
constitute a RCDS. The example in the ﬁgure indicates that
when considering the partial problem (especially on G1(e) in
this example), it is not enough to keep only the information
of RCDS membership in w (e). The information regarding
how each RCC meets w (e) is also important.

deﬁning a RCDS problem instance), and D is the set of
RCDS members in the subgraph. The terminology of RCC
stems from the fact that any two vertices in a RCC can be
connected by a “relaxed path” similar to the one in Remark 5.
See Fig. 2, graph on the right side, for an example with two
RCCs (separated by the red dotted curve).

The dynamic programming approach for RCDS problem
is a divide-and-conquer solution strategy. For example, let
(T,t ) be an optimal sphere-cut decomposition of G. In
addition, let e ∈ E(T ) and G1(e) 6= /0, G2(e) 6= /0 be the
two subgraphs of G such that V (G1(e)) ∩V (G2(e)) = w (e).
Instead of solving the RCDS problem on G, we can solve
two smaller partial problems on G1(e) and G2(e), provided
that the solutions of the partial problems match at w (e). The
deﬁnitions of a partial problem, its feasible solutions and
the conditions to match at w (e) will be given in subsequent
discussions. Consider a RCDS in G, which leads to a single
RCC by deﬁnition. However, when restricted inside either
G1(e) or G2(e) the RCDS can result in multiple RCCs in
each of the subgraphs. Each RCC in the subgraphs must
“meet” the intersection w (e), since otherwise it will lead to
the contradiction that the RCDS in G contains more than one
RCC. Consequently, partial problem on G1(e) (resp., G2(e))
must enforce that each RCC in G1(e) (resp., G2(e)) must
meet the intersection w (e). When two RCCs from different
subgraphs meet at some vertex v ∈ w (e), the solutions to the
two partial problems must agree on the RCDS membership
of v. This is part of the “matching” requirement. Moreover,
the information regarding how each RCC meets w (e) is also
important. See Fig. 2 for an illustration. The description for
the minimum necessary information to decouple a partial
problem from another will be given in Section V-C. In the
following discussions, the proposed dynamic programming
procedure will be formally described.

C. Coloring of vertices in middle set

For each e ∈ E(T ′), we color the vertices of w

′(e) ⊆
V in three possible basic colors, in order to encode the
information regarding domination on the boundary of Ge:
Black: represented by 1, meaning that the vertex is in the

RCDS.

White: represented by 0, meaning that the vertex is not in
the RCDS but it is dominated by at least one vertex in
V (Ge) that is in the RCDS.

Grey: represented by ˆ0, meaning that the vertex is not in
the dominating set, and it is not dominated inside Ge.
The symbol c ∈ {0, ˆ0,1}|w
′(e)| denotes a vector (with |w
′(e)|
entries) specifying a basic coloring of all vertices in w
′(e).
The order of entries in c is the same as the cyclic order p (e).
c encodes the information on the RCDS membership of the
vertices in w
′(e), as well as how they are dominated. In
addition, for a speciﬁc basic coloring c, we subdivide every
color 1 with four detailed colors (and every color 0 with four
detailed colors) to encode the information on the number of
RCCs (in Ge) and how the RCCs meet w
′(e) (see Fig. 2 for
a motivation for the need to subdivide the colors, and see
[14], [15] for an explanation for why the detailed coloring
is a sufﬁcient encoding scheme for the information):

• 1[: the vertex is colored black (i.e.,

in RCDS). In
addition, consistent with c there exists a selection of
RCDS members, denoted De, in V (Ge) such that there
exists a RCC resulted from De meeting w
′(e) at multiple

vertices. The vertex in question is ﬁrst vertex met by the
RCC according to cyclic order p (e). We deﬁne a vertex
v ∈ w
′(e) to be met by a RCC if it is a vertex of the
RCC (recall that a RCC is subgraph of Ge).

• 1]: similar to the case in 1[, except that the vertex in

question is the last vertex to be met by a RCC.

• 1∗: similar to the cases in 1[ and 1], except that the
vertex in question is neither the ﬁrst nor the last to be
met by a RCC.

• 1s: similar to the cases of 1[, 1] or 1∗, except that the
′(e) that meets

vertex in question is the only vertex in w
its corresponding RCC.

′(e), as far as the “RCC-meets-w

Analogous to detailed colors 1[, 1], 1∗, 1s, we deﬁne detailed
colors 0[, 0], 0∗, 0s for basic color 0 to encode the same
“RCC-meets-w
′(e)” information. The subdivision is needed
because a white vertex in w
′(e) plays exactly the same role
as a black vertex in w
′(e)”
information is concerned. Note that there is no need to deﬁne
detailed colors for the basic color ˆ0, since the vertex colored
ˆ0 is never part of any RCC (in Ge). We deﬁne the symbol
C := {0[,0],0∗,0s, ˆ0,1[,1],1∗,1s}, and ¯c ∈ C |w
′(e)| as a vector
specifying a detailed coloring for all vertices in w
′(e). The
order of the entries of ¯c is the same as that of c (i.e., the cyclic
order p (e)). The vector ¯c encodes the minimum necessary
information (i.e., dynamic programming state) to decouple
the optimization effort on Ge from the rest of the graph.

D. Partial problems in dynamic programming

To describe the optimization effort on subgraph Ge, we
deﬁne the following notion: for any e ∈ E(T ′), for each ¯c ∈
C |w
′(e)|, we denote Pe( ¯c) to be the partial problem on Ge
parameterized by detailed coloring ¯c. Partial problem Pe( ¯c)
seeks a De ⊆ V (Ge) with minimum cardinality that satisﬁes

• All black vertices in w
• No white vertex in w

′(e) are in De.
′(e) is in De, but a white vertex

must be adjacent to a vertex in De.

• No grey vertex in w

′(e) is in De, and a grey vertex

cannot be adjacent to any vertex in De.

• Each vertex in V (Ge) \w

′(e) is either in De or adjacent

to a vertex in De.

• The number of RCCs in Ge (resulted by De) is the total
number of vertices in w
′(e) with color in 0[, 0s, 1[, or
1s. In addition, the RCCs must satisfy all requirements
imposed by the deﬁnitions of the detailed colors (i.e.,
0[, 0], 0∗, 0s, 1[, 1], 1∗, 1s) at each vertices in w
′(e)
with such colors. For instance, for a vertex colored 1s,
it must be the only vertex in w

′(e) meeting a RCC.

′(e)| 7→ N ∪ ¥

For the partial problem Pe( ¯c), we denote Ae( ¯c) as its optimal
objective value. That
is, we deﬁne the function Ae(·) :
C |w
to be the cardinality of the minimizing
De the ﬁve conditions deﬁning Pe( ¯c) in above, in case such
De exists. If no such De exists, Ae( ¯c) := ¥
. As it will be
explained in Section V-F, we can solve the RCDS problem
if we solve all partial problems Pe(·) for all edges e ∈ E(T ′)
except for the root-incident edge {z,r}. As in the typical
dynamic programming procedure, the partial problems are

solved from ﬁnal stages which correspond to the edges
incident to the leaf-vertices of T ′.

E. Solving partial problems by traversing T ′ from leaves

For all e ∈ E(T ′) incident to a leaf vertex of T ′, Ae(·) is
deﬁned by enumeration. There are two cases: (a) |w
′(e)| = 1,
and (b) |w
′(e)| = 2. For case (a), except for Ae(0s) = 1 and
Ae(1s) = 1, all other values of Ae(·) are set to inﬁnity. For
case (b), except for Ae(0[,1]) = 1, Ae(ˆ0, ˆ0) = 0, Ae(1[,0]) = 1
and Ae(1[,1]) = 2, all other values of Ae(·) are set to inﬁnity.
For e = {z,r}, Ae(·) is not deﬁned because it is not needed for
subsequent calculations. For all other e ∈ E(T ′) not incident
to a leaf vertex of T ′, the solutions to partial problems Pe(·)
are assembled with the solutions to partial solutions Pe1(·)
and Pe2(·) in some appropriate manner, where e1 and e2 are
the two children edges of e. The pseudocode for the assembly
(i.e., dynamic programming recursion) is as follows:

Algorithm 1 (DP recursion):
ce ∈ {0, ˆ0,1}|w

′(e)| do

for all detailed colorings ¯ce ∈ C |w
do

initialize Ae( ¯ce) = ¥

for all basic colorings

′(e)| derived from ce

end for
for all basic colorings (ce1,ce2 ) consistent with ce do
for all detailed colorings ( ¯ce1 , ¯ce2) derived from
(ce1 ,ce2) do

if ¯ce1 and ¯ce2 together leads to a feasible solution
to Pe( ¯ce) for some ¯ce ∈ C |w
update Ae( ¯ce) if proﬁtable

′(e)| then

end if
end for

end for

end for

We explain the following procedures in the pseudocode
above in more detail:
(I) identifying basic coloring pairs (ce1 ,ce2) that are con-

sistent with a given basic coloring ce

(II) listing all detailed colorings ¯cx from a given cx, where

(III) determining if a given pair ( ¯ce1, ¯ce2 ) leads to a feasible

“x” is a wildcard for e, e1 or e2
solution of Pe( ¯ce) for some ¯ce ∈ C |w

′(e)|

(IV) determining ¯ce when the answer in (III) is “yes”
(V) updating Ae( ¯ce)
To describe (I), the following deﬁnitions are needed:

X1 := w
X2 := w
X3 := w
X4 := (w

′(e) \ w
′(e) \ w
′(e) ∩ w
′(e1) ∪ w

′(e2),
′(e1),
′(e1) ∩ w
′(e2)) \ w

′(e2),
′(e).

For a given basic coloring ce (corresponding to w
basic colorings ce1 and ce2, corresponding to w
w
′(e2) respectively, that are consistent with ce satisfy
• For u ∈ X1, ce(u) = ce1(u).
• For u ∈ X2, ce(u) = ce2(u).
• For u ∈ X3, if ce(u) ∈ {ˆ0,1} then ce(u) = ce1 (u) = ce2(u).
If ce(u) = 0 then one of the following three holds: (a)

′(e)), the
′(e1) and

ce1(u) = 0,ce2(u) = ˆ0 or (b) ce1 (u) = ˆ0,ce2 (u) = 0, or
(c) ce1 (u) = ce2(u) = 0.

• For u ∈ X4, exactly one of the four cases must hold:
(a) ce1 (u) = ce2(u) = 1, (b) ce1(u) = 0,ce2(u) = ˆ0, (c)
ce1(u) = ˆ0,ce2 (u) = 0 or (d) ce1(u) = ce2 (u) = 0.

For (II), the rule to derive ¯cek from cek for k = 1,2 follows
exactly the deﬁnition of detailed colors. That is, for every
basic color 0 four detailed colors 0[, 0], 0∗ and 0s are
possible. A similar treatment applies for color 1. For (III), a
pair ( ¯ce1 , ¯ce2 ) can lead to a feasible solution to Pe(·) if and
only if there is no RCC (of members of RCDS) in V (Ge1 )
(resp., V (Ge2 )) meeting w
′(e1) (resp., w
′(e2)) only at X4.
Existence of a RCC meeting only X4 implies the existence
of a RCC in Ge not meeting any vertex in w
′(e). This implies
that there are at least two RCCs in the entire graph G because
vertices in V \V (Ge) (nonempty since e 6= {z,r}) need to be
dominated. This violates that RCDS deﬁnition. Procedure
(IV) can be divided into two steps. First, we determine
how many RCCs (of the RCDS members) in V (Ge) =
V (Ge1 ) ∪V (Ge2), and how these RCCs meet w
′(e). This can
be achieved by computing the connected components of a
bipartite graph with vertex set R1 ∪ R2. R1 (resp., R2) is the
set of RCCs in Ge1 (reps., Ge2). A member (i.e., a RCC) in
R1 is adjacent to a member in R2 if and only if there exists
at least one vertex in X3 ∪ X4 where both RCCs meet. In the
second step of procedure (IV), we encode the information
of how the RCCs in Ge meet w
′(e) in a vector of detailed
coloring ¯ce. For (V) the update rule is
Ae( ¯ce) = minnAe( ¯ce), Ae1( ¯ce1) + Ae2( ¯ce2 ) − #1(X3, ¯ce1)

−#1(X4, ¯ce1)o,

(4)
where #1(X3, ¯ce1 ) denotes the number of vertices in X3
colored 1 by coloring ¯ce1 (note that #1(X3, ¯ce1 ) = #1(X3, ¯ce2)).
Similarly, #1(X4, ¯ce1 ) denotes the number of vertices in X4
colored 1 by coloring ¯ce1 (and also by ¯ce2). By deﬁnition of
′, there is no vertex in exactly one of w
w
′(e1) and
w
′(e2). Hence, X3 and X4, which are disjoint, partition the set
w
′(e1) ∩w
′(e2) = V (Ge1 ) ∩V (Ge2 ). Therefore, in (4) the two
negative terms prevent double-counting of RCDS members
in w
′(e2). In the case where Ae( ¯ce) is updated, the
corresponding pair ( ¯ce1 , ¯ce2) are stored for later use.
F. Obtaining RCDS by traversing T ′ from root

′(e1) ∩ w

′(e), w

For the root-incident edge {z,r}, w

′({z,r}) = /0. Conse-
quently, X1 = X2 = X3 = /0. Let er1 and er2 denote the two
children edges of {z,r}. Then, X4 = w
′(er1) = w
′(er2) since
there is no vertex in exactly one of w
′(er1) or w
′(er2 ). The
cardinality of the minimum RCDS of (V,E) is

Aer1

¯cer1

) − #1(w

),

(5)

, ¯cer2

( ¯cer2

( ¯cer1

) + Aer2

′(er1), ¯cer1

are subjected to two constraints:

min
, ¯cer2
where ¯cer1
1) all u ∈ w
′(er1), exactly one of the four situations applies:
= 1? with “?” being a wildcard for [,
= 1?, ¯cer2
(a) ¯cer1
= ˆ0,
= 0?, ¯cer2
], ∗ or s, (b) ¯cer1
= ˆ0, ¯cer2
= 0?
(d) ¯cer1

= 0?, (c) ¯cer1

= 0?, ¯cer2

2) ( ¯cer1 , ¯cer2 ) leads to exactly one RCC in G
Let D⋆ denote the minimum RCDS to be returned. Then
the members of D⋆ can be decided by a tree traversal
(e.g., depth-ﬁrst) starting from the root: let ¯c⋆
be a
er1
minimizing pair in (5). Subsequently, for each e ∈ E(T ′) such
that ¯c⋆

Ae( ˆc) is known, we handle two cases:
• If e is incident to a leaf vertex then for each u ∈ w

′(e),
e(u) = 1? implies u ∈ D⋆ and u /∈ D⋆ otherwise. If
¯c⋆
|w
′(e)| = 1 and suppose u ∈ w
′(e), then
v ∈ D⋆ if and only if u /∈ D⋆.

′(e) and v /∈ w

e = argmin

, ¯c⋆
er2

ˆc

• If e is not incident to a leaf vertex, then the optimal
e2 for the two children edges e1 and

colorings ¯c⋆
e2 can be read off from (4), with ¯ce ﬁxed as ¯c⋆
e.

e1 and ¯c⋆

The process continues until all edges in T ′ have been visited.

G. Fixed parameter tractability

′(e1)|+|w

The computation effort of the entire dynamic program-
ming procedure for planar RCDS problem is dominated
by the dynamic programming recursion (from leaves of T ′
to root) in Section V-E (i.e., Algorithm 1). In the inner-
most for-loop, the computation cost is dominated by the
computation of the connected components in the bipartite
graph with vertex set R1 ∪ R2. This cost is O((|w
′(e1)| +
|(w
′(e2)|)2) = O(BW2) time (e.g., [23]), where BW is the
branchwidth of graph G. From each basic coloring cex, at
most 4|w
′(ex)| detailed colorings can be derived (e.g., cex =
(1,1, . . . ,1)). Therefore, the innermost for-loop is executed
at most 4|w
′(e2)| = O(42BW) times, for each speciﬁc
pair of basic colorings (ce1 ,ce2). In total,
there are no
more than 3|w
′(e2)| = O(33BW) pairs of basic
colorings (ce1 ,ce2) considered in Algorithm 1. Therefore,
Algorithm 1 requires O(BW233BW42BW ) time for each run.
Since Algorithm 1 is run for each e ∈ E(T ′) between the root
and leaves of T ′ and |E(T ′)| = O(|E|), the total computation
cost for dynamic programming recursion in Section V-E is
O(BW233BW42BW |E|). This is typical complexity result of a
sphere-cut decomposition based algorithm. Computation cost
grows very moderately with problem instance size, provided
that branchwidth is small. The numerical study in Section VI
indicates that small branchwidth is common in practice.

′(e1)|+|w

′(e)|+|w

VI. NUMERICAL CASE STUDY

Graphs from the IEEE power system benchmarks are
considered. The minimum RCDS are computed by solving
integer program (3). To evaluate the proposed sphere-cut de-
composition/dynamic programming based solution approach
(SCD approach for short) for planar graphs, we “planarize”
the benchmark graphs using the algorithm in [13] if neces-
sary. Then we compute the corresponding minimum RCDS
using the SCD approach. The cardinality of the minimum
RCDS on the planarized graph is an upper bound of the
cardinality of the minimum RCDS on the original graph,
because removing edges makes it more difﬁcult both to
satisfy condition 1) and condition 2) in Proposition 2 (i.e.,
the constraints in (2)). As a comparison,
the minimum
dominating sets of the benchmarks are computed to illustrate

the difference between the RCDS problem and the dom-
inating set problem. The computation results are listed in
Table I. In the ﬁfth column, the symbol BWp denotes the
branchwidth of the planarized benchmark graph. In the sixth
column, the symbol |D⋆
SCD| denotes the cardinality of the
minimum RCDS of the planarized benchmark, as returned
by the SCD method. This number is greater than or equal
to the cardinality of the minimum RCDS of the original
graph, which is denoted by |D⋆| in the seventh column.
In the last column, the symbol |DS| denotes the regular
is smaller than or equal to |D⋆|,
domination number. It
because a RCDS is a dominating set with an additional
property (cf. Proposition 2). Table I veriﬁes the fact that
when a graph is planar, the SCD approach computes the exact
minimum RCDS. In cases where planarization is necessary,
the SCD approach computes only a suboptimal solution.

TABLE I: branchwidth and RCDS cardinality

Name
IEEE 9
IEEE 14
IEEE 24
IEEE 30
IEEE 39
IEEE 57
IEEE 118
IEEE 300

|V |
9
14
24
30
39
57
118
300

|E|
9
20
34
41
46
78
179
409

planar

BWp

yes
yes
no
yes
yes
no
yes
no

2
2
3
3
3
4
4
4

|D⋆
SCD|
3
4
8
10
15
20
34
97

|D⋆|
3
4
8
10
15
19
34
93

|DS|
3
4
7
10
13
17
32
87

To compute the minimum RCDS, problem (3) is solved us-
ing IBM CPLEX. To compute the minimum dominating set,
an integer program from [13] is solved using IBM CPLEX.
To compute the branchwidth and sphere-cut decomposition,
we utilize the state-of-the-art implementation by Prof. Gu’s
group [24]. The dynamic programming computations, as de-
scribed in Section V, are implemented in MATLAB (for ease
of implementation). The computations for branchwidth and
branch-decomposition are performed on a Linux machine
with a 3 GHz CPU and 4GB of RAM. All other computations
are performed on a Mac machine with a 2.5 GHz CPU and
8GB of RAM. The computation times for solving the RCDS
problem using the SCD approach and integer programming
(CPLEX) are shown in Table II. In the table, the column
labeled TSCD represents the time to compute the sphere-cut
decomposition (with the code from Gu’s group). The column
labeled TDP represents the time to run dynamic programming
as described in Section V. The column labeled TIP represents
the time to run CPLEX. From the table, it can be seen that the

TABLE II: computation time (sec)

Name
IEEE 9
IEEE 14
IEEE 24
IEEE 30
IEEE 39
IEEE 57
IEEE 118
IEEE 300

|V |
9
14
24
30
39
57
118
300

|E|
9
20
34
41
46
78
179
409

BWp

2
2
3
3
3
4
4
4

TSCD
0.03
0.05
0.13
0.06
0.09
0.12

1
3.4

TDP

0.1498
0.3487
1.2433
1.3262
1.6348
21.4133
19.4139
45.3790

TIP

0.0047
0.0064
0.0546
0.0096
0.0127
0.3217
0.1287
0.6553

computation effort of the SCD approach (computing sphere-
cut decomposition and dynamic programming) is affected
signiﬁcantly by the branchwidth of the graph, while the effort
grows roughly linearly with the problem instance size (i.e.,
|E|). This is consistent with the computation time analyses
in [24] and in Section V-G. However, while the MATLAB
implementation of the dynamic programming has acceptable
efﬁciency (within a minute for all test instances), it is far
from efﬁcient in contrast with the sphere-cut decomposition
implementation and CPLEX. For dynamic programming, a
more advanced implementation using a more appropriate
language (e.g., C instead of MATLAB) is highly desirable.
CPLEX runtime remains reasonable for all the test instances.
In a future study, even larger instances should be tested to
determine the limitation of integer programming approach.

VII. CONCLUSION

This paper is the second installment (the ﬁrst being [13])
of the author’s effort to introduce the machinery of graph
decomposition (in particular, branch decomposition) to sys-
tematically exploit the inherent structure of power networks
in practice, in order to develop solution strategies to solve
hard combinatorial optimization problems relevant to appli-
cations. These two papers demonstrate the ﬂexibility of graph
decomposition/dynamic programming as a methodology to
derive customized algorithms for application problems. The
computation cost of the proposed methodology grows only
linearly with problem instance size, provided that the branch-
width is ﬁxed and small. This is drastically different from
the scalability property of the integer programming approach.
While the computation studies still
indicate considerably
better efﬁciency performance for CPLEX, the graph decom-
position approach (with the author’s amateur implementa-
tion) performs reasonably well in practice. The prospect of
better scalability of the graph decomposition approach calls
for algorithmic developments and implementations in more
professional manners in order to truly demonstrate the power
of the approach. Further, more theoretical development is
desirable. For instance, removing the planarity assumption
can dramatically broaden the scope of applications.

REFERENCES

[1] Y. Liu, M. Reiter, and P. Ning, “False data injection attacks against
state estimation in electric power grids,” in 16th ACM Conference on
Computer and Communication Security, New York, NY, USA, 2009,
pp. 21–32.

[2] G. D´an and H. Sandberg, “Stealth attacks and protection schemes for
state estimators in power systems,” in Smart Grid Communications
(SmartGridComm), 2010 First IEEE International Conference on.
IEEE, 2010, pp. 214–219.

[3] H. Sandberg, A. Teixeira, and K. H. Johansson, “On security indices
for state estimators in power networks,” in First Workshop on Secure
Control Systems (SCS), Stockholm, 2010, 2010.

[4] R. B. Bobba, K. M. Rogers, Q. Wang, H. Khurana, K. Nahrstedt,
and T. J. Overbye, “Detecting false data injection attacks on dc state
estimation,” in Preprints of the First Workshop on Secure Control
Systems, CPSWEEK, vol. 2010, 2010.

[5] O. Kosut, L. Jia, R. J. Thomas, and L. Tong, “Malicious data attacks
on smart grid state estimation: Attack strategies and countermeasures,”
in Smart Grid Communications (SmartGridComm), 2010 First IEEE
International Conference on.

IEEE, 2010, pp. 220–225.

[6] A. Giani, E. Bitar, M. Garcia, M. McQueen, P. Khargonekar, and
K. Poolla, “Smart grid data integrity attacks,” IEEE Transactions on
Smart Grid, vol. 4, no. 3, pp. 1244–1253, Sept 2013.

[7] T. T. Kim and H. V. Poor, “Strategic protection against data injection
attacks on power grids,” Smart Grid, IEEE Transactions on, vol. 2,
no. 2, pp. 326–333, 2011.

[8] F. Aminifar, A. Khodaei, M. Fotuhi-Firuzabad, and M. Shahidehpour,
“Contingency-constrained pmu placement in power networks,” Power
Systems, IEEE Transactions on, vol. 25, no. 1, pp. 516–523, 2010.

[9] S. Chakrabarti, E. Kyriakides, and D. G. Eliades, “Placement of
synchronized measurements for power system observability,” Power
Delivery, IEEE Transactions on, vol. 24, no. 1, pp. 12–19, 2009.

[10] N. Robertson and P. Seymour, “Graph minors. x. obstructions to tree-
decomposition,” Journal of Combinatorial Theory, Series B, vol. 52,
no. 2, pp. 153 – 190, 1991.

[11] W. A. Christian Jr, “Linear-time algorithms for graphs with bounded
branchwidth,” Ph.D. dissertation, Georgia Institute of Technology,
2002.

[12] S. Arnborg, J. Lagergren, and D. Seese, “Easy problems for tree-
decomposable graphs,” Journal of Algorithms, vol. 12, no. 2, pp. 308–
340, 1991.

[13] K. C. Sou, “A branch-decomposition approach to power network de-
sign,” in American Control Conference, July 2016, to appear, preprint
http://arxiv.org/abs/1511.08927.

[14] M. Marzban, Q.-P. Gu, and X. Jia, “New analysis and computational
study for the planar connected dominating set problem,” Journal of
Combinatorial Optimization, pp. 1–28, 2015.

[15] F. Dorn, E. Penninkx, H. L. Bodlaender, and F. V. Fomin, “Efﬁcient
exact algorithms on planar graphs: Exploiting sphere cut decomposi-
tions,” Algorithmica, vol. 58, no. 3, pp. 790–810, 2009.

[16] A. Abur and A. Exp´osito, Power System State Estimation. Marcel

Dekker, Inc., 2004.

[17] D.-Z. Du and P.-J. Wan, Connected Dominating Set: Theory and

Applications. Springer Publishing Company, Incorporated, 2012.

[18] K. White, M. Farber, and W. Pulleyblank, “Steiner trees, connected
domination and strongly chordal graphs,” Networks, vol. 15, no. 1, pp.
109–124, 1985.

[19] M. R. Garey and D. S. Johnson, Computers and intractability. wh

freeman, 2002, vol. 29.

[20] R. Diestel, Graph theory. 2005. Springer, 2005.
[21] P. D. Seymour and R. Thomas, “Call routing and the ratcatcher,”

Combinatorica, vol. 14, no. 2, pp. 217–241, 1994.

[22] Q.-P. Gu and H. Tamaki, “Optimal branch-decomposition of planar
graphs in o (n 3) time,” ACM Transactions on Algorithms (TALG),
vol. 4, no. 3, p. 30, 2008.

[23] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction

to Algorithms, Third Edition, 3rd ed. The MIT Press, 2009.

[24] Z. Bian, Q.-P. Gu, and M. Zhu, “Practical algorithms for branch-
decompositions of planar graphs,” Discrete Applied Mathematics, vol.
199, pp. 156 – 171, 2016.

