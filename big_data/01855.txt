6
1
0
2

 
r
a

M
6

 

 
 
]

G
L
.
s
c
[
 
 

1
v
5
5
8
1
0

.

3
0
6
1
:
v
i
X
r
a

Online Learning to Rank with Feedback at the Top

Sougata Chaudhuri

Ambuj Tewari

University of Michigan, Ann Arbor

University of Michigan, Ann Arbor

Abstract

We consider an online learning to rank set-
ting in which, at each round, an oblivious
adversary generates a list of m documents,
pertaining to a query, and the learner pro-
duces scores to rank the documents. The
adversary then generates a relevance vector
and the learner updates its ranker according
to the feedback received. We consider the
setting where the feedback is restricted to be
the relevance levels of only the top k docu-
ments in the ranked list for k (cid:28) m. However,
the performance of learner is judged based
on the unrevealed full relevance vectors, us-
ing an appropriate learning to rank loss func-
tion. We develop eﬃcient algorithms for well
known losses in the pointwise, pairwise and
listwise families. We also prove that no on-
line algorithm can have sublinear regret, with
top-1 feedback, for any loss that is calibrated
with respect to NDCG. We apply our algo-
rithms on benchmark datasets demonstrating
eﬃcient online learning of a ranking function
from highly restricted feedback.

1

Introduction

In learning to rank for information retrieval, the ob-
jective is to rank lists of documents, pertaining to dif-
ferent queries, so that the documents that are more
relevant to a query are ranked above those that are
less relevant. Most learning to rank methods are based
on supervised batch learning, i.e., rankers are trained
on batch data consisting of instances and labels [Liu,
2011]. The instances are lists of documents, pertain-
ing to diﬀerent queries, and labels are in the form
of relevance vectors. The accuracy of a ranked list,

Appearing in Proceedings of the 19th International Con-
ference on Artiﬁcial Intelligence and Statistics (AISTATS)
2016, Cadiz, Spain. JMLR: W&CP volume 41. Copyright
2016 by the authors.

in comparison to the actual relevance of the docu-
ments, is measured by various ranking measures, such
as NDCG, AP and ERR.

Collecting reliable training data can be expensive and
time consuming. In certain applications, such as de-
ploying a new web app or developing a custom search
engine, collecting large amount of training data might
not be possible at all [Sanderson, 2010]. Moreover,
a ranker trained from batch data might not be able
to satisfy changing user needs and preferences. Re-
cent research has focused on online learning of rank-
ing systems, where a ranker is updated on the ﬂy. One
direction of work deploys models which learn from im-
plicit feedback inferred from user clicks on ranked lists
[Hofmann et al., 2013, Yue and Joachims, 2009]. How-
ever, there are some potential drawbacks in learning
from user clicks. It is possible that the displayed items
might not be clickable, such as in certain mobile apps.
Moreover, a clicked item might not actually be relevant
to the user and there is also the problem of bias to-
wards top ranked items in inferring feedback from user
clicks [Joachims, 2002]. Another direction of work de-
ploys models which learn optimal ranking of a ﬁxed list
of items, for diverse user preferences [Radlinski et al.,
2008, Chaudhuri and Tewari, 2015]. Speciﬁcally, the
latter work assumes that a user generates a full rele-
vance vector for the entire ranked list of items but gives
feedback only on the top ranked item. Motivation for
this feedback model comes from considerations of user
burden constraints (users will feel burdensome to pro-
vide careful feedback on all items) and privacy con-
cerns (users will be unwilling to provide feedback on
all items if they are about sensitive issues such as med-
ical conditions). However, the requirement of having a
ﬁxed set of items to rank severely limits the practical
applicability of this line of work.

Our work extends the work of Chaudhuri and Tewari
[2015], by combining query-level ranking, in an online
manner, with explicit but restricted feedback. We for-
malize the problem as an online game played over T
rounds, between a learner and an oblivious adversary.
At each round, the adversary generates a document
list of length m, pertaining to a query. The learner

Online Learning to Rank with Feedback at the Top

sees the list and produces a real valued score vector
to rank the documents. We assume that the ranking
is generated by sorting the score vector in descending
order of its entries. The adversary then generates a rel-
evance vector but the learner gets to see the relevance
of only the top-k items of the ranked list, where k (cid:28) m
is a small constant, like 1 or 2. The learner’s loss in
each round, based on the learner’s score vector and the
full relevance vector, is measured by some continuous
learning to rank loss function. We focus on continu-
ous surrogates losses, e.g., the cross entropy surrogate
in ListNet [Cao et al., 2007] and hinge surrogate in
RankSVM [Joachims, 2002], instead of discontinuous
ranking measures like NDCG, AP, or ERR because the
latter lead to intractable optimization problems. We
note that the top-k feedback model is distinct from
the full and bandit feedback models since neither the
full relevance vector nor the loss at end of each round
is revealed to the learner. Technically, the problem is
an instance of partial monitoring [Cesa-Bianchi et al.,
2006, Bartok et al., 2014], extended to a setting with
side information (documents list) and an inﬁnite set
of learner’s moves (all real valued score vectors). For
such an extension of partial monitoring there exists
no generic theoretical or algorithmic framework to the
best of our knowledge.

We make two main contributions in this paper. First,
we propose a general, eﬃcient algorithm for online
learning to rank with top-k feedback and show that
it works in conjunction with a number of ranking sur-
rogates. We characterize the minimum feedback re-
quired, i.e., the value of k, for the algorithm to work
with a particular surrogate by formally relating the
feedback mechanism with the structure of the surro-
gates. We then apply our general techniques to three
convex ranking surrogates and one non-convex surro-
gate. The convex surrogates considered are from three
major learning to ranking methods: squared loss from
a pointwise method [Cossock and Zhang, 2008], hinge
loss used in the pairwise RankSVM [Joachims, 2002]
method, and (modiﬁed) cross-entropy surrogate used
in the listwise ListNet [Cao et al., 2007] method. The
non-convex surrogate considered is the SmoothDCG
surrogate [Chapelle and Wu, 2010]. For the three con-
vex surrogates, we establish an O(T 2/3) regret bound.

The convex surrogates we mentioned above are widely
used but are known to fail to be calibrated with re-
spect to NDCG [Ravikumar et al., 2011]. Our sec-
ond contribution is to show that for the entire class of
NDCG calibrated surrogates, no online algorithm can
have sublinear (in T ) regret with top-1 feedback, i.e.,
the minimax regret of an online game for any NDCG
calibrated surrogate is Ω(T ). The proof for this rather
surprising result is non-trivial and relies on exploiting a

connection between the construction of optimal adver-
sary strategies for hopeless ﬁnite action partial moni-
toring games [Piccolboni and Schindelhauer, 2001] and
the structure of NDCG calibrated surrogates. We only
focus on NDCG calibrated surrogates for the impossi-
bility results since no (convex) surrogate can be cal-
ibrated for AP and ERR [Calauzenes et al., 2012].
This impossibility result is not only the ﬁrst of its kind
in online ranking with top-1 feedback but it also the
ﬁrst such result for a natural partial monitoring prob-
lem with side information when the learner’s action
space is inﬁnite. Note, however, that there does exist
work on partial monitoring problems with continuous
learner actions, but without side information [Klein-
berg and Leighton, 2003, Cesa-Bianchi et al., 2006],
and vice versa [Bart´ok and Szepesv´ari, 2012, Gentile
and Orabona, 2014].

We apply our algorithms on benchmark ranking
datasets, demonstrating the ability to eﬃciently learn
a ranking function in an online fashion, from highly
restricted feedback.

2 Preliminaries

In learning to rank, an instance is a matrix X ∈ Rm×d,
consisting of a list of m documents, each represented
as a feature vector in Rd, with each list pertaining to a
single query. The supervision is in form of a relevance
vector R = {0, 1, . . . , n}m, representing relevance of
each document to the query. If n = 1, the relevance
vector is binary graded. For n > 1, relevance vector is
multi-graded. Xi: denotes ith row of X and Ri denotes
ith component of R. The subscript t is exclusively used
to denote time t. Thus, Rt denotes relevance vector
generated at time t and Rt,i denotes ith component
of Rt. We assume feature vectors representing docu-
ments are bounded by RD in (cid:96)2 norm.

i

Documents are ranked by a ranking function. The
prevalent technique is to represent a ranking function
as a scoring function and get ranking by sorting scores
in descending order. A linear scoring function pro-
duces score vector as fw(X) = Xw = sw ∈ Rm,
with w ∈ Rd. Here, sw
represents score of ith doc-
ument (sw points to score s being generated by us-
ing parameter w). We assume that ranking parameter
space is bounded in (cid:96)2 norm, i.e, (cid:107)w(cid:107)2 ≤ U , ∀ w.
πs = argsort(s) is the permutation induced by sort-
ing score vector s in descending order. A permuta-
tion π gives a mapping from ranks to documents and
π−1 gives a mapping from documents to ranks. Thus,
π(i) = j means document j is placed at position i in π
while π−1(i) = j means document i is placed at posi-
tion j. Sm denote the set of m! diﬀerent permutations
of [m] where [m] = {1, 2 . . . , m}.

Sougata Chaudhuri, Ambuj Tewari

1

1

Zk(R)

(cid:80)k

(cid:80)k

log2 (i+1) , Zk(R) = max
π∈Sm

Various ranking measures, like NDCG and AP, judge
the quality of a ranking function, by comparing the
ranked lists produced by the ranking function and the
relevance vector, respectively. Formally, NDCG, cut
oﬀ at k ≤ m for a query with m documents, with rel-
evance vector R and score vector s induced by a rank-
ing function, is deﬁned as follows: NDCGk(s, R) =
i=1 G(Rπs(i))D(i). Shorthand representation
of NDCGk(s, R) is NDCGk. Here, G(r) = 2r − 1,
i=1 G(Rπ(i))D(i).
D(i) =
πs = argsort(s) is the permutation induced by score
vector s in descending order. Since optimization of the
discontinuous ranking measures is an NP-hard prob-
lem, most ranking methods are based on minimizing
surrogate losses, which can be optimized more eﬃ-
ciently. A surrogate φ takes in a score vector s and
relevance vector R and produces a real number, i.e.,
φ : Rm×{0, 1, . . . , n}m (cid:55)→ R. φ(·,·) is said to be convex
if it is convex in its ﬁrst argument, for any value of the
second argument. The ranking surrogates are designed
in such a way that the score vector which minimizes
the surrogate, induces a ranking which minimizes the
target ranking measures.

Xtw = sw
t
parameterized by w.

is the score produced by the linear function

from partial

Relation between feedback and structure of
surrogates: Alg. 1 is our general algorithm for learn-
ing a ranking function, online,
feed-
back. The key step in Alg. 1 is the construction
of the unbiased estimator ˜zt of the surrogate gra-
dient ∇w=wtφ(Xtw, Rt). The information present
is
for the construction process, at end of round t,
the random score vector ˜st (and associated permu-
tation ˜σt) and relevance of top-k items of ˜σt,
i.e.,
{Rt,˜σt(1), . . . , Rt,˜σt(k)}. Let Et [·] be the expectation
to randomization at round t, condi-
operator w.r.t.
tioned on (w1, . . . , wt). Then ˜zt being an unbiased
estimator of gradient of surrogate, w.r.t wt, means the
following: Et [˜zt] = ∇w=wtφ(Xtw, Rt). We note that
conditioned on the past, the score vector swt
t = Xtwt
is deterministic. We start with a general result relat-
ing feedback to the construction of unbiased estimator
of a vector valued function. Let P denote a probabil-
P(σ) = 1. For a
distinct set of indices (j1, j2, . . . , jk) ⊆ [m], we denote
p(ji, j2, . . . , jk) as the the sum of probability of permu-
tations whose ﬁrst k objects match objects (j1, . . . , jk),
in order. Formally,

ity distribution on Sm, i.e, (cid:80)

σ∈Sm

(cid:88)

π∈Sm

3 Problem Setting and Learning to

Rank Algorithm

p(j1, . . . , jk) =

P(π)1(π(1) = j1, . . . , π(k) = jk).

Formal problem setting: We formalize the prob-
lem as a game being played between a learner and an
oblivious adversary over T rounds. The learner’s ac-
tion set is the uncountably inﬁnite set of score vectors
in Rm and the adversary’s action set is all possible
relevance vectors, i.e., (n + 1)m possible vectors. At
round t, the adversary generates a list of documents,
represented by a matrix Xt ∈ Rm×d, pertaining to
a query (the document list is considered as side in-
formation). The learner receives Xt and produces a
score vector ˜st ∈ Rm. The adversary then generates
a relevance vector Rt but only reveals the relevance
of top k ranked documents to the learner, where the
ranked list is produced by sorting ˜st. The learner
uses the feedback to choose its action for the next
round (updates an internal scoring function). The
learner suﬀers a loss as measured in terms of a sur-
rogate φ, i.e, φ(˜st, Rt). Note that since the learner’s
objective is to produce good ranking at every round,
learner’s performance is measured w.r.t. to entire rel-
evance vector Rt whereas it only gets to see just the
top-k entries of Rt. As is standard in online learn-
ing setting, the learner’s performance is measured in

terms of its expected regret: E(cid:104)(cid:80)T

(cid:105) −

t=1 φ(˜st, Rt)

min(cid:107)w(cid:107)2≤U
t=1 φ(Xtw, Rt), where the expectation is
taken w.r.t. to randomization of learner’s strategy and

(cid:80)T

(1)
Lemma 1. Let F : Rm (cid:55)→ Ra be a vector val-
ued function, where m ≥ 1, a ≥ 1. For a ﬁxed
x ∈ Rm,
let k entries of x be observed at ran-
dom. That is,
for a ﬁxed probability distribution
P and some random σ ∼ P(Sm), observed tuple is
{σ, xσ(1), . . . , xσ(k)}. A necessary condition for exis-
tence of an unbiased estimator of F (x), that can be
constructed from {σ, xσ(1), . . . , xσ(k)}, is that it should
be possible to decompose F (x) over k (or less) coordi-
nates of x at a time. That is, F (x) should have the
structure:

F (x) =

hi1,i2,...,i(cid:96)(xi1 , xi2 , . . . , xi(cid:96))

(i1,i2,...,i(cid:96))∈ mP(cid:96)

(2)
where (cid:96) ≤ k, mP(cid:96) is (cid:96) permutations of m and h : R(cid:96) (cid:55)→
Ra (the subscripts in h is used to simply represent dif-
ferent functions). Moreover, when F (x) can be written
in form of Eq 2 , with (cid:96) = k, an unbiased estimator of
F (x), based on {σ, xσ(1), . . . , xσ(k)}, is,

(cid:88)

(cid:80)

g(σ,xσ(1), . . . , xσ(k)) =

(j1,j2,...,jk)∈Sk

(cid:80)

hσ(j1),...,σ(jk)(xσ(j1), . . . , xσ(jk))

(j1,...,jk)∈Sk

p(σ(j1), . . . , σ(jk))

(3)

Online Learning to Rank with Feedback at the Top

2 ), learning parameter η > 0, ranking parameter w1 = 0 ∈ Rd

Algorithm 1 Ranking with Top-k Feedback (RTop-kF)
1: Exploration parameter γ ∈ (0, 1
2: For t = 1 to T
3:
4:
5:
6:

t = Xtwt and get permutation σt = argsort(swt
t )

t ) + γUniform([0, 1]m) (δ is the Dirac Delta function).

Receive Xt (document list pertaining to query qt)
Construct score vector swt
Qt(s) = (1 − γ)δ(s − swt
Sample ˜st ∼ Qt and output the ranked list ˜σt = argsort(˜st)
(Eﬀectively, it means ˜σt is drawn from Pt(σ) = (1 − γ)1(σ = σt) + γ
m! )
Receive relevance feedback on top-k items, i.e., (Rt,˜σt(1), . . . , Rt,˜σt(k))
Suﬀer loss φ(˜st, Rt) (Neither loss nor Rt revealed to learner)
Construct ˜zt, an unbiased estimator of gradient ∇w=wtφ(Xtw, Rt), from top-k feedback.
Update w = wt − η˜zt
wt+1 = min{1, U(cid:107)w(cid:107)2

}w (Projection into Euclidean ball of radius U ).

7:
8:
9:
10:
11:
12: End For

where Sk is the set of k! permutations of [k] and
p(σ(1), . . . , σ(k)) is as in Eq 1 .

Illustrative Examples: We provide simple exam-
ples to concretely illustrate the abstract functions in
Lemma 1. Let F (·) be the identity function, and
x ∈ Rm. Thus, F (x) = x and the function decom-
(cid:80)m
poses over k = 1 coordinate of x as follows: F (x) =
i=1 xiei, where ei ∈ Rm is the standard basis vec-
tor along coordinate i. Hence, hi(xi) = xiei. Based
on top-1 feedback, following is an unbiased estimator
(cid:80)
, where p(σ(1)) =
of F (x): g(σ, xσ(1)) =
P(π)1(π(1) = σ(1)). In another example, let F :
π∈Sm
R3 (cid:55)→ R2 and x ∈ R3. Let F (x) = [x1 + x2; x2 + x3](cid:62).
Then the function decomposes over k = 1 coordi-
nate of x as F (x) = x1e1 + x2(e1 + e2) + x3e2, where
ei ∈ R2. Hence, h1(x1) = x1e1, h2(x2) = x2(e1 + e2)
and h3(x3) = x3e2. An unbiased estimator based on

xσ(1)eσ(1)
p(σ(1))

top-1 feedback is: g(σ, xσ(1)) =

hσ(1)(xσ(1))

p(σ(1))

.

4 Unbiased Estimators of Gradients

of Surrogates

Alg. 1 can be implemented for any ranking surrogate
as long as an unbiased estimator of the gradient can
be constructed from the random feedback. We will use
techniques from online convex optimization to obtain
formal regret guarantees. We will thus construct the
unbiased estimator of four major ranking surrogates.
Three of them are popular convex surrogates, one each
from the three major learning to rank methods, i.e.,
pointwise, pairwise and listwise methods. The fourth
one is a popular non-convex surrogate.

Shorthand notations: We note that by chain rule,
∇w=wtφ(Xtw, Rt) = X(cid:62)
t =
Xtwt. Since Xt is deterministic in our setting, we focus

, Rt), where swt

t ∇swt

φ(swt
t

t

t

φ(swt
t

on unbiased estimators of ∇swt
, Rt) and take a
matrix-vector product with Xt. To reduce notational
clutter in our derivations, we drop w from sw and the
subscript t throughout. Thus, in our derivations, ˜z =
˜zt, X = Xt, s = swt
(and not ˜st), σ = ˜σt (and not
t
σt), R = Rt, ei is standard basis vector in Rm along
coordinate i and p(·) as in Eq. 1 with P = Pt where Pt
is the distribution in round t in Alg. 1.

4.1 Convex Surrogates

Pointwise Method: We will construct the unbiased
estimator of the gradient of squared loss [Cossock and
Zhang, 2006]: φsq(s, R) = (cid:107)s − R(cid:107)2
2. The gradient
∇sφsq(s, R) is 2(s − R) ∈ Rm. As we have already
demonstrated in the example following Lemma 1, we
can construct unbiased estimator of R from top-
1 feedback ({σ, Rσ(1)}). Concretely, the unbiased
estimator is:

˜z = X(cid:62)(cid:18)

2

(cid:18)

(cid:19)(cid:19)

.

s − Rσ(1)eσ(1)
p(σ(1))

i(cid:54)=j=1

i(cid:54)=j=1

(cid:80)
dient is given by ∇sφsvm(s, R) = (cid:80)m
lows: F (R) = Fs(R) = (cid:80)m

Pairwise Method: We will construct the unbi-
ased estimator of the gradient of hinge-like surro-
gate in RankSVM [Joachims, 2002]: φsvm(s, R) =
1(Ri > Rj) max(0, 1 + sj − si). The gra-
1(Ri >
Rj)1(1 + sj > si)(ej − ei) ∈ Rm. Since s is a known
quantity, from Lemma 1, we can construct F (R) as fol-
i(cid:54)=j=1 hs,i,j(Ri, Rj), where
hs,i,j(Ri, Rj) = 1(Ri > Rj)1(1 + sj > si)(ej − ei).
Since Fs(R) is decomposable over 2 coordinates of R
at a time, we can construct an unbiased estima-
tor from top-2 feedback ({σ, Rσ(1), Rσ(2)}). The
unbiased estimator is:
(cid:19)

(cid:62)(cid:18) hs,σ(1),σ(2)(Rσ(1), Rσ(2)) + hs,σ(2),σ(1)(Rσ(2), Rσ(1))

˜z =

X

p(σ(1), σ(2)) + p(σ(2), σ(1))

.

Sougata Chaudhuri, Ambuj Tewari

We note that the unbiased estimator was constructed
from top-2 feedback. The following lemma, in conjunc-
tion with the necessary condition of Lemma 1 shows
that it is the minimum information required to con-
struct the unbiased estimator.

Lemma 2. The gradient of RankSVM surrogate, i.e.,
φsvm(s, R) cannot be decomposed over 1 coordinate of
R at a time.

Listwise Method: Convex surrogates developed for
listwise methods of learning to rank are deﬁned over
the entire score vector and relevance vector. Gradient
of a surrogate cannot usually be decomposed over co-
ordinates of the relevance vector. We will focus on the
cross-entropy surrogate used in the highly cited List-
Net [Cao et al., 2007] ranking algorithm and show how
a very natural modiﬁcation to the surrogate makes its
gradient estimable in our partial feedback setting.

The authors of the ListNet method use a cross-
entropy surrogate on two probability distributions
on permutations,
induced by score and relevance
vector respectively. More formally, the surrogate is
deﬁned as follows1. Deﬁne m maps from Rm to R as:
j=1 exp(vj) for j ∈ [m]. Then, for
score vector s and relevance vector R, φLN(s, R) =
=

Pj(v) = exp(vj)/(cid:80)m
−(cid:80)m
(cid:16)− exp(Ri)
(cid:80)m
(cid:80)m
j=1 exp(Rj ) + exp(si)

and ∇sφLN(s, R)
(cid:80)m

i=1 Pi(R) log Pi(s)

ei. We have

j=1 exp(sj )

(cid:17)

i=1

the following lemma about the gradient of φLN .
surrogate
Lemma 3. The
φLN (s, R) cannot be decomposed over k, for k = 1, 2,
coordinates of R at a time.

gradient of ListNet

In fact, an examination of the proof of the above
lemma reveals that decomposability at any k < m
does not hold for the gradient of LisNet surrogate,
though we only prove it for k = 1, 2 (since feedback
for top k items with k > 2 does not seem practical).
Due to Lemma 1, this means that if we want to run
Alg. 1 under top-k feedback, a modiﬁcation of ListNet
is needed. We now make such a modiﬁcation.

i=1 pi = (cid:80)m
i=1 pi log(pi) −(cid:80)m

We ﬁrst note that the cross-entropy surrogate of List-
Net can be easily obtained from a standard divergence,
viz. Kullback-Liebler divergence. Let p, q ∈ Rm be
i=1 qi = 1).
i=1 pi log(qi) −
i=1 qi. Taking pi = Pi(R) and qi = Pi(s),
∀ i ∈ [m] (where Pi(v) is as deﬁned in φLN) and noting
that φLN(s, R) needs to be minimized w.r.t. s (thus
i=1 pi log(pi) term in KL(p, q)),

2 probability distributions ((cid:80)m
Then KL(p, q) = (cid:80)m
i=1 pi +(cid:80)m
(cid:80)m
we can ignore the (cid:80)m

we get the cross entropy surrogate from KL.

1The ListNet paper actually deﬁnes a family of losses
based on probability models for top r documents, with r ≤
m. We use r = 1 in our deﬁnition since that is the version
implemented in their experimental results.

Our natural modiﬁcation now easily follows by con-
sidering KL divergence for un-normalized vectors (it
should be noted that KL divergence is an instance
of a Bregman divergence). Deﬁne m maps from Rm
j(v) = exp(vj) for j ∈ [m]. Now deﬁne
to R as: P (cid:48)
pi = P (cid:48)
i (s). Then, the modiﬁed surro-
gate is φKL(s, R) is:

i (R) and qi = P (cid:48)

eRi log(esi) − m(cid:88)

m(cid:88)

eRi +

esi,

i=1

i=1

m(cid:88)

i=1

eRi log(eRi) − m(cid:88)
m(cid:80)

i=1

i=1

and

(exp(si) − exp(Ri)) ei is its gradient w.r.t. s.
Note that φKL(s, R) is non-negative and convex in s.
Equating gradient to 0 ∈ Rm, at the minimum point,
si = Ri, ∀ i ∈ [m]. Thus, the sorted order of opti-
mal score vector agrees with sorted order of relevance
vector and it is a valid ranking surrogate.

F (R) = Fs(R) = (cid:80)m

Now, from Lemma 1, we can construct F (R) as follows:
i=1 hs,i(Ri), where hs,i(Ri) =
(exp(si) − exp(Ri)) ei. Since Fs(R) is decomposable
over 1 coordinate of R at a time, we can con-
struct an unbiased estimator from top-1 feed-
back ({σ, Rσ(1)}). The unbiased estimator is:

˜z = X(cid:62)(cid:18) (exp(sσ(1)) − exp(Rσ(1)))eσ(1)

(cid:19)

p(σ(1))

Other Listwise Methods: As we mentioned be-
fore, most listwise convex surrogates will not be suit-
able for Alg. 1 with top-k feedback. For example, the
class of popular listwise surrogates that are developed
from structured prediction perspective [Chapelle et al.,
2007, Yue et al., 2007] cannot have unbiased estimator
of gradients from top-k feedback since they are based
on maps from full relevance vectors to full rankings
and thus cannot be decomposed over k = 1 or 2 coor-
dinates of R. It does not appear they have any natural
modiﬁcation to make them amenable to our approach.

4.1.1 Non-convex Surrogate

We provide an example of a non-convex surrogate
for which Alg. 1 is applicable (however it will not
have any regret guarantees due to non-convexity). We
choose the SmoothDCG surrogate given in [Chapelle
and Wu, 2010], which has been shown to have very
competitive empirical performance.
SmoothDCG,
like ListNet, deﬁnes a family of surrogates, based
on the cut-oﬀ point of DCG (see original paper
[Chapelle and Wu, 2010]
for details). We con-
sider SmoothDCG@1, which is the smooth version
of DCG@1 (i.e., DCG which focuses just on the
The surrogate is deﬁned
top-ranked document).
i=1 G(Ri) exp(si/),
as: φSD(s, R) =

(cid:80)m

(cid:80)m

1

j=1 exp(sj /)

Online Learning to Rank with Feedback at the Top

where  is a (known) smoothing parameter and G(a) =
2a − 1. The gradient of the surrogate is:

hs,i(Ri), hs,i(Ri) =

exp(si/)
j exp(sj(cid:48) /)

1(i=j) − 1


((cid:80)

exp((si + sj)/)

j(cid:48) exp(sj(cid:48) /))2 ]ej

(cid:33)

m(cid:88)

i=1

[∇sφSD(s, R)] =

(cid:32) m(cid:88)

j=1

(cid:80)

[

1


G(Ri)

(cid:80)m

Using Lemma 1, we can write F (R) = Fs(R) =
i=1 hs,i(Ri) where hs,i(Ri) is deﬁned above. Since
Fs(R) is decomposable over 1 coordinate of R at a
time, we can construct an unbiased estimator
from top-1 feedback ({σ, Rσ(1)}), with unbiased es-
timator being:

(cid:19)

(∗)

(cid:62)(cid:18) G(Rσ(1))
m(cid:88)

p(σ(1))

(cid:80)

[

1


j=1

exp(sσ(1)/)
j(cid:48) exp(sj(cid:48) /)

˜z = X

(∗) =

1(σ(1)=j) − 1


((cid:80)

exp((sσ(1) + sj)/)

j(cid:48) exp(sj(cid:48) /))2 ]ej

4.2 Computational Complexity of

Algorithm 1

Three of the four key steps governing the complex-
ity of Alg. 1, i.e., construction of ˜st, ˜σt and sorting
can all be done in O(m log(m)) time. Construction
of estimator is even simpler. The only bottleneck
could have been calculations of p(σ(1)) in squared
loss, (modiﬁed) ListNet loss and SmoothDCG loss,
and p(σ(1), σ(2)) in RankSVM loss, since they involve
sum over permutations. However, they have a com-
pact representation, i.e., p(σ(1)) = 1 − γ + γ
m and
p(σ(1), σ(2)) = 1 − γ +
m(m−1) . The calculations
follow easily due to the nature of Pt (step-6 in algo-
rithm) which put equal weights on all permutations
other than σt.

2γ

4.3 Regret Bounds

The underlying deterministic part of our algorithm is
online gradient descent (OGD) [Zinkevich, 2003]. The
regret of OGD, run with unbiased estimator of gradi-
ent of a convex function, as given in Theorem 3.1 of
[Flaxman et al., 2005], in our problem setting is:

(cid:34) T(cid:88)

t=1

E

(cid:35)

φ(Xtwt, Rt)

φ(Xtw, Rt)+

≤ min
w:(cid:107)w(cid:107)2≤U

(cid:35)

(4)

U 2
2η

+

η
2

E

(cid:107)˜zt(cid:107)2

2

T(cid:88)
(cid:34) T(cid:88)

t=1

t=1

However, from the perspective of the loss φ(˜st, Rt) in-
curred by Alg. 1, at each round t, the RHS above is not
a valid upper bound. The algorithms plays the score
vector suggested by OGD (˜st = Xtwt) with probabil-
ity 1 − γ (exploitation) and plays a randomly selected
score vector (i.e., a draw from the uniform distribution
on [0, 1]m), with probability γ (exploration). Thus,
the expected number of rounds in which the algorithm
does not follow the score suggested by OGD is γT ,
leading to an extra regret2 of order γT . Thus, we
have

(cid:34) T(cid:88)

E

(cid:35)

(cid:34) T(cid:88)

φ(˜st, Rt)

≤ E

t=1

t=1

φ(Xtwt, Rt)

+ O (γT )

(5)

(cid:35)

(cid:107)Xv(cid:107)q
(cid:107)v(cid:107)p

We ﬁrst control Et(cid:107)˜zt(cid:107)2
2, for all convex surrogates con-
sidered in our problem (we remind that ˜zt is the esti-
mator of a gradient of a surrogate, calculated at time t.
In Sec 4.1 , we omitted showing w in sw and index t).
To get bound on Et(cid:107)˜zt(cid:107)2
2, we used the following norm
relation that holds for any matrix X [Bhaskara and
Vijayaraghavan, 2011]: (cid:107)X(cid:107)p→q = sup
, where q
v(cid:54)=0
is the dual exponent of p (i.e., 1
q + 1
p = 1), and the
following lemma derived from it:
Lemma 4. For any 1 ≤ p ≤ ∞, (cid:107)X(cid:62)(cid:107)1→p =
j=1 (cid:107)Xj:(cid:107)p, where Xj: denotes jth row
(cid:107)X(cid:107)q→∞ = maxm
of X and m is the number of rows of matrix.
Lemma 5. For parameter γ in Alg. 1 , RD being the
bound on (cid:96)2 norm of the feature vectors (rows of docu-
ment matrix X), m being the upper bound on number
of documents per query, U being the radius of the Eu-
clidean ball denoting the space of ranking parameters
and Rmax being the maximum possible relevance value
(in practice always ≤ 5), let C φ ∈ {C sq, C svm, C KL}
be polynomial functions of RD, m, U, Rmax, where the
degrees of the polynomials depend on the surrogate
(φsq, φsvm, φKL), with no degree ever greater than
four. Then we have,

(cid:2)(cid:107)˜zt(cid:107)2

2

(cid:3) ≤ C φ

γ

Et

(6)

Plugging Eq. 6 and Eq. 5 in Eq. 4, and optimizing
over η and γ, (which gives η = O(T −2/3) and γ =
O(T −1/3)), we get the ﬁnal regret bound.
Theorem 4.1. For any sequence of instances and la-
bels (Xt, Rt){t∈[T ]}, applying Alg. 1 with top-1 feedback
for φsq and φKL and top-2 feedback for φsvm, will pro-
duce the following bound on the regret for any of the

where ˜zt is unbiased estimator of ∇w=wtφ(Xtw, Rt),
conditioned on past events, η is the learning rate and
the expectation is taken over all randomness in the
algorithm.

2The instantaneous loss suﬀered at each of the explo-
ration round can be maximum of O(1), as long as φ(s, R) is
bounded, ∀ s and ∀ R. This is true because the score space
is (cid:96)2 norm bounded, maximum relevance grade is ﬁnite in
practice and we consider Lipschitz, convex surrogates.

Sougata Chaudhuri, Ambuj Tewari

three surrogates:

(cid:35)

(cid:34) T(cid:88)

t=1

E

φ(˜st, Rt)

− min

w:(cid:107)w(cid:107)2≤U

T(cid:88)

t=1

φ(Xtw, Rt) ≤ C φO

(cid:16)

T 2/3(cid:17)

(7)

where C φ is a surrogate dependent function, as de-
scribed in Lemma 5 , and expectation is taken over un-
derlying randomness of the algorithm, over T rounds.

Discussion:
It is known that online bandit games
are special instances of partial monitoring games. For
bandit online convex optimization problems with Lips-
chitz, convex surrogates, the best regret rate known so
far, that can be achieved by an eﬃcient algorithm, is
√
O(T 3/4) (however, see the work of Bubeck and Eldan
[2015] for a non-constructive O(log4(T )
T ) bound).
Surprisingly, Alg. 1, when applied in a partial moni-
toring setting to the Lipschitz, convex surrogates that
we have listed, achieves a better regret rate than what
is known in the bandit setting. Moreover, as we show
subsequently, for an entire class of Lipschitz convex
surrogates (subclass of NDCG calibrated surrogates),
sub-linear (in T ) regret is not even achievable. Thus,
our work indicates that even within the class of Lips-
chitz, convex surrogates, regret rate achievable is de-
pendent on the structure of surrogates; something that
does not arise in bandit convex optimization.

5

Impossibility of Sublinear Regret
for NDCG Calibrated Surrogates

Learning to rank methods optimize surrogates to learn
a ranking function, even though performance is mea-
sured by target measures like NDCG. This is done be-
cause direct optimization of the measures lead to NP-
hard optimization problems. One of the most desirable
properties of any surrogate is calibration, i.e., the sur-
rogate should be calibrated w.r.t the target [Bartlett
et al., 2006]. Intuitively, it means that a function with
small expected surrogate loss on unseen data should
have small expect target loss on unseen data. We fo-
cus on NDCG calibrated surrogates (both convex and
non-convex) that have been characterized by Raviku-
mar et al. [2011]. We ﬁrst state the necessary and suf-
ﬁcient condition for a surrogate to be calibrated w.r.t
NDCG. For any score vector s and distribution η on
relevance space Y, let ¯φ(s, η) = ER∼ηφ(s, R). More-
over, we deﬁne G(R) = (G(R1), . . . , G(Rm))(cid:62).
Theorem 5.1. [Ravikumar et al., 2011, Thm. 6] A
surrogate φ is NDCG calibrated iﬀ for any distribu-
tion η on relevance space Y, there exists an invertible,
order preserving map g : Rm (cid:55)→ Rm s.t.
the unique
minimizer s∗
φ(η) can be written as
s∗
φ(η) = g

(cid:20) G(R)

(cid:21)(cid:19)

ER∼η

(cid:18)

(8)

.

Zm(R)

(cid:104) G(R)

(cid:105)

that argsort(s∗

φ(η)) ⊆
Informally, Eq. 8 states
argsort(ER∼η
) Ravikumar et al. [2011] give
concrete examples of NDCG calibrated surrogates, in-
cluding how some of the popular surrogates can be
converted into NDCG calibrated ones: e.g., the NDCG
calibrated version of squared loss is (cid:107)s − G(R)

Zm(R)

Zm(R)(cid:107)2
2.

We now state the impossibility result for the class of
NDCG calibrated surrogates with top-1 feedback.

Theorem 5.2. Fix the online learning to rank game
with top-1 feedback and any NDCG calibrated surro-
gate. Then, for every learner’s algorithm, there exists
an adversary strategy s.t. the learner’s expected regret
is Ω(T ).

Note that our result is for top-1 feedback. Minimax re-
gret for the problem setting with top-k feedback, with
k ≥ 2 remains an open question.

Proof. (Sketch) The proof builds on the proof of hope-
less ﬁnite action partial monitoring games given by
Piccolboni and Schindelhauer [2001]. An examina-
tion of their proof of Thm. 3 indicates that for hope-
less games, there have to exist two probability dis-
tributions (over adversary’s actions), which are in-
distinguishable in terms of feedback but the optimal
learner’s actions for the distributions are diﬀerent. We
ﬁrst provide a mathematical explanation as to why
such existence lead to hopeless games. Then, we pro-
vide a characterization of indistinguishable probability
distributions in our problem setting, and then exploit
the characterization of optimal actions for NDCG cal-
ibrated surrogates (Thm. 5.1) to explicitly construct
two such probability distributions. This proves the
result.

We note that the proof of Thm. 3 of Piccolboni and
Schindelhauer [2001] cannot be directly extended to
prove the impossibility result because it relies on con-
structing a connected graph on vertices deﬁned by
neighboring actions of learner.
In our case, due to
the continuous nature of learner’s actions, the graph
will be an empty graph and proof will break down.

6 Empirical Results

Objective: We conducted experiments on benchmark
datasets to demonstrate the performance of ranking
functions that are learnt from partial feedback. As
stated before, though Alg. 1 is designed to minimize
surrogate based regret, the users only care about the
ranking presented to them, and indeed the algorithm
interacts with users only through ranked lists. We
tested the quality of the ranked lists, and hence the
performance of the evolving ranking functions, against

Online Learning to Rank with Feedback at the Top

feedback.
Datasets: We compared the various ranking func-
tions on two large scale commercial datasets. They
were Yahoo’s Learning to Rank Challenge dataset
[Chapelle and Chang, 2011] and a dataset published
by Russian search engine Yandex [IM-2009]. The Ya-
hoo dataset has 19944 unique queries with 5 distinct
relevance levels, while Yandex has 9126 unique queries
with 5 distinct relevance levels.
Setting of experiments: We selected time horizon
T = 250,000 iterations for our experiments (thus, each
algorithm went over each dataset multiple times). All
the online algorithms, other than the fully random
one, involve learning rate η and exploration param-
eter γ (Full information ListNet does not involve γ
and SmoothDCG has an additional smoothing param-
eter ). While obtaining our regret guarantees, we had
established that η = O(T −2/3) and γ = O(T −1/3) and
thus, in our experiments, for each instance of Alg. 1,
T 2/3 and γ = 1
we selected η = 1
T 1/3 . We ﬁxed  = 0.01.
For ListNet, we selected η = 1
T 1/2 , since regret guarat-
nee in OGD is established with η = O(T −1/2). We
plotted average NDCG10 against time, where average
NDCG10 at time t is the cumulative NDCG10 up to
time t, divided by t.
Observations: In both the datasets, ListNet, with
full
information, has highest average NDCG value
throughout. However, Alg. 1, with the convex sur-
rogates, produce competitive performance. In fact, in
the Yahoo dataset, our algorithms, with RankSVM
and KL, are very close to the performance of ListNet.
RanSVM does better than the other surrogates, since
the estimator of RankSVM gradient is constructed
from top-2 feedback, leading to lower variance. KL,
being listwise in nature, does better than squared loss.
Crucially, our algorithms, based on all three convex
surrogates, perform signiﬁcantly better than the purely
random algorithm, and are much closer to full feedback
ListNet in performance, despite being much closer to
the purely random algorithm in terms of feedback. Our
algorithm, with SmoothDCG, on the other hand, pro-
duce poor performance. We believe the reason is the
non-convexity of the surrogate, which leads to the op-
timization procedure possibly getting stuck at a local
minima. In batch setting, such problem is avoided by
an annealing technique that successively reduces . We
are not aware of an analogue in an online setting. Pos-
sible algorithms optimizing non-convex surrogates in
an online manner, which require gradient of the surro-
gate, may be adapted to this partial feedback setting.

References

Peter L Bartlett, Michael I Jordan, and Jon D
classiﬁcation, and risk

Convexity,

McAuliﬀe.

Figure 1: Average NDCG@10 values for diﬀerent al-
gorithms, for Yandex (top) and Yahoo (bottom).
ListNet:NDCG@10 (in cyan) is a full feedback al-
gorithm and Random:NDCG@10 (in red) is no feed-
back algorithm.

the full relevance vectors via NDCG10.
Ranking functions compared: We applied Alg. 1,
with top-1 feedback, on Squared, KL and SmoothDCG
surrogates, and with top-2 feedback, on the RankSVM
surrogate. Since our work is based on a novel feedback
model, the performance of Alg. 1 could not be directly
compared with any published baseline. So, based on the
objective of our work, we selected two diﬀerent rank-
ing methods for comparison. The ﬁrst one is the online
version ListNet ranking algorithm, with full relevance
vector revealed at end of every round. ListNet is not
only one of the most cited ranking algorithms (over 700
citations according to Google Scholar), but also one of
the most validated algorithms [Tax et al., 2015]. We
emphasize that some of the ranking algorithms, which
have shown better empirical performance than List-
Net, are usually based on non-convex surrogates with
complex ranking functions. These algorithms can-
not usually be converted into online algorithms which
learn from streaming data. The second one is a fully
random algorithm which outputs a uniformly at ran-
dom ranking of documents at each round. Eﬀectively,
we are comparing Alg 1, which learns from highly re-
stricted feedback, with an algorithm which learns from
full feedback and another algorithm which receives no

Sougata Chaudhuri, Ambuj Tewari

bounds. Journal of the American Statistical Associ-
ation, 101(473):138–156, 2006.

G´abor Bart´ok and Csaba Szepesv´ari. Partial monitor-
ing with side information. In Algorithmic Learning
Theory, pages 305–319, 2012.

Gabor Bartok et al. Partial monitoring–classiﬁcation,
regret bounds, and algorithms. Mathematics of Op-
erations Research, 39(4):967–997, 2014.

Aditya Bhaskara and Aravindan Vijayaraghavan. Ap-
proximating matrix p-norms. In Proceedings of the
twenty-second annual ACM-SIAM symposium on
Discrete Algorithms, pages 497–511. SIAM, 2011.

S´ebastien Bubeck and Ronen Eldan. Multi-scale ex-
ploration of convex functions and bandit convex op-
timization. arXiv preprint arXiv:1507.06580, 2015.

Cl´ement Calauzenes, Nicolas Usunier, and Patrick
Gallinari. On the (non-) existence of convex, cal-
ibrated surrogate losses for ranking. In Advances in
Neural Information Processing Systems, 2012.

Zhe Cao, Tao Qin, Tie-Yan Liu, Ming-Feng Tsai, and
Hang Li. Learning to rank: from pairwise approach
to listwise approach. In Proceedings of the 24th In-
ternational conference on Machine learning, pages
129–136. ACM, 2007.

Nicolo Cesa-Bianchi, G´abor Lugosi, and Gilles Stoltz.
Regret minimization under partial monitoring.
Mathematics of Operations Research, pages 562–
580, 2006.

Olivier Chapelle and Yi Chang. Yahoo!

learning to
rank challenge overview. Journal of Machine Learn-
ing Research-Proceedings Track, pages 1–24, 2011.

Olivier Chapelle and Mingrui Wu. Gradient descent
optimization of smoothed information retrieval met-
rics. Information retrieval, 13(3):216–235, 2010.

Olivier Chapelle, Quoc Le, and Alex Smola. Large
margin optimization of ranking measures. In NIPS
Workshop: Machine Learning for Web Search, 2007.

Sougata Chaudhuri and Ambuj Tewari. Online rank-
ing with top-1 feedback. In Proceedings of the 18th
International Conference on Artiﬁcial Intelligence
and Statistics, pages 129–137. ACM, 2015.

David Cossock and Tong Zhang. Subset ranking using
regression. In Conference on Learning theory, pages
605–619, 2006.

David Cossock and Tong Zhang. Statistical analysis of
bayes optimal subset ranking. Information Theory,
IEEE Transactions on, 54(11):5140–5154, 2008.

Abraham D Flaxman, Adam Tauman Kalai, and
H Brendan McMahan. Online convex optimization
in the bandit setting.
In Proceedings of the six-
teenth annual ACM-SIAM symposium on Discrete
algorithms, pages 385–394, 2005.

Claudio Gentile and Francesco Orabona. On multil-
abel classiﬁcation and ranking with bandit feedback.
The Journal of Machine Learning Research, 15(1):
2451–2487, 2014.

Katja Hofmann, Shimon Whiteson, and Maarten
de Rijke. Balancing exploration and exploitation
in listwise and pairwise online learning to rank. In-
formation Retrieval, 16(1):63–90, 2013.

IM-2009. http://imat2009.yandex.ru/en/, 2009.

Thorsten Joachims. Optimizing search engines using
clickthrough data. In Proceedings of the 8th ACM
SIGKDD, pages 133–142. ACM, 2002.

Robert Kleinberg and Tom Leighton. The value of
knowing a demand curve: Bounds on regret for on-
line posted-price auctions. In Foundations of Com-
puter Science, 2003, pages 594–605, 2003.

Tie-Yan Liu. Learning to rank for information re-

trieval. Springer Science & Business Media, 2011.

Antonio Piccolboni and Christian Schindelhauer. Dis-
crete prediction games with arbitrary feedback and
loss. In COLT, pages 208–223. Springer, 2001.

Filip Radlinski, Robert Kleinberg, and Thorsten
Joachims. Learning diverse rankings with multi-
armed bandits. In Proceedings of the 25th interna-
tional conference on Machine learning, pages 784–
791. ACM, 2008.

Pradeep Ravikumar, Ambuj Tewari, and Eunho Yang.
On NDCG consistency of listwise ranking methods.
In Proceedings of the 14th International Conference
on Artiﬁcial Intelligence and Statistics, pages 618–
626, 2011.

Mark Sanderson. Test collection based evaluation of
information retrieval systems, volume 13. Now Pub-
lishers Inc, 2010.

Niek Tax, Sander Bockting, and Djoerd Hiemstra. A
cross-benchmark comparison of 87 learning to rank
methods. Information Processing and Management,
pages 757–772, 2015.

Yisong Yue and Thorsten Joachims. Interactively op-
timizing information retrieval systems as a dueling
bandits problem. In Proceedings of the 26th ICML.,
pages 1201–1208. ACM, 2009.

Yisong Yue, Thomas Finley, Filip Radlinski, and
Thorsten Joachims. A support vector method for
optimizing average precision. In Proceedings of ACM
SIGIR, pages 271–278, 2007.

Martin Zinkevich. Online convex programming and
generalized inﬁnitesimal gradient ascent. In Proceed-
ings of the 20th International Conference on Ma-
chine Learning (ICML-03), pages 928–936, 2003.

Online Learning to Rank with Feedback at the Top

7 Supplementary

Proof of Lemma 1: We restate the lemma before giving the proof, for ease of reading:
Lemma 1: Let F : Rm (cid:55)→ Ra be a vector valued function, where m ≥ 1, a ≥ 1. For a ﬁxed x ∈ Rm, let k
entries of x be observed at random. That is, for a ﬁxed probability distribution P and some random σ ∼ P(Sm),
observed tuple is {σ, xσ(1), . . . , xσ(k)}. The necessary condition for existence of an unbiased estimator of F (x),
that can be constructed from {σ, xσ(1), . . . , xσ(k)}, is that it should be possible to decompose F (x) over k (or
less) coordinates of x at a time. That is, F (x) should have the following structure:

(cid:88)

F (x) =

hi1,i2,...,i(cid:96)(xi1, xi2, . . . , xi(cid:96))

(i1,i2,...,i(cid:96))∈ mP(cid:96)

where (cid:96) ≤ k, mP(cid:96) is (cid:96) permutations of m and h : R(cid:96) (cid:55)→ Ra. Moreover, when F (x) can be written in form of Eq 2
, with (cid:96) = k, an unbiased estimator of F (x), based on {σ, xσ(1), . . . , xσ(k)}, is,

g(σ, xσ(1), . . . , xσ(k)) =

(cid:80)

(j1,j2,...,jk)∈Sk

(cid:80)

hσ(j1),...,σ(jk)(xσ(j1), . . . , xσ(jk))

(j1,...,jk)∈Sk

p(σ(j1), . . . , σ(jk))

where Sk is the set of k! permutations of [k] and p(σ(1), . . . , σ(k)) is as in Eq 1 .
Proof. For a ﬁxed x ∈ Rm and probability distribution P, let the random permutation be σ ∼ P(Sm) and the
observed tuple be {σ, xσ(1), . . . , xσ(k)}. Let ˆG = G(σ, xσ(1), . . . , xσ(k)) be an unbiased estimator of F (x) based
on the random observed tuple. Taking expectation, we get:

F (x) = Eσ∼P

P(π)G(π, xπ(1), . . . , xπ(k))

(cid:104) ˆG
(cid:105)

(cid:88)

π∈Sm

=

=

(cid:88)

(cid:88)

(i1,i2,...,ik)∈ mPk

π∈Sm

P(π)1(π(1) = i1, π(2) = i2, . . . , π(k) = ik)G(π, xi1, xi2, . . . , xik )

(cid:88)

π∈Sm

(cid:88)

We note that P(π) ∈ [0, 1] is independent of x for all π ∈ Sm. Then we can use the following construction of
function h(·):

hi1,i2,...,ik (xi1, . . . , xik ) =

P(π)1(π(1) = i1, π(2) = i2, . . . , π(k) = ik)G(π, xi1 , xi2, . . . , xik )

and thus,

F (x) =

(i1,i2,...,ik)∈ mPk

hi1,i2,...,ik (xi1, xi2, . . . , xi)

Hence, we conclude that for existence of an unbiased estimator based on the random observed tuple, it should be
possible to decompose F (x) over k (or less) coordinates of x at a time. The “less than k” coordinates arguement
follows simply by noting that if F (x) can be decomposed over (cid:96) coordinates at a time ((cid:96) < k) and observation
tuple is {σ, xσ(1), . . . , xσ(k))}, then any k − (cid:96) observations can be thrown away and the rest used for construction
of the unbiased estimator.

The construction of the unbiased estimator proceeds as follows:

i=1 hi(xi) and feedback is for top-1 item (k = 1). The unbiased estimator according to Lemma. 1

Let F (x) =(cid:80)m

is:

g(σ, xσ(1)) =

hσ(1)(xσ(1))

p(σ(1))

=

(cid:80)

π

hσ(1)(xσ(1))

P(π)1(π(1) = σ(1))

Taking expectation w.r.t. σ, we get:

Eσ[g(σ, xσ(1))] =

m(cid:88)

i=1

hi(xi)((cid:80)
(cid:80)

π

P(π)1(π(1) = i))

π

P(π)1(π(1) = i)

m(cid:88)

i=1

=

hi(xi) = F (x)

m(cid:80)

i(cid:54)=j=1

Now, let F (x) =

to Lemma. 1 is:

Sougata Chaudhuri, Ambuj Tewari

hi,j(xi, xj) and the feedback is for top-2 item (k = 2). The unbiased estimator according

g(σ, xσ(1), xσ(2)) =

hσ(1),σ(2)(xσ(1), xσ(2)) + hσ(2),σ(1)(xσ(2), xσ(1))

p(σ(1), σ(2)) + p(σ(2), σ(1))

We will use the fact that for any 2 permutations σ1, σ2, which places the same 2 objects in top-2 positions but in
opposite order, estimators based on σ1 (i.e, g(σ1, xσ1(1), xσ1(2))) and σ2 (i.e, g(σ2, xσ2(1), xσ2(2))) have same nu-
merator and denominator. For eg., let σ1(1) = i, σ1(2) = j. Numerator and denominator for g(σ1, xσ1(1), xσ1(2))
are hi,j(xi, xj) + hj,i(xj, xi) and p(i, j) + p(j, i) respectively. Now let σ2(1) = j, σ2(2) = i. Then numerator and
denominator for g(σ2, xσ2(1), xσ2(2)) are hj,i(xj, xi) + hi,j(xi, xj) and p(j, i) + p(i, j) respectively.

Then, taking expectation w.r.t. σ, we get:

Eσg(σ, xσ(1), xσ(2)) =

=

=

(hi,j(xi, xj) + hj,i(xj, xi))p(i, j)

p(i, j) + p(j, i)

(hi,j(xi, xj) + hj,i(xj, xi))(p(i, j) + p(j, i))

p(i, j) + p(j, i)

m(cid:88)

i(cid:54)=j=1

(hi,j(xi, xj) + hj,i(xj, xi)) =

hi,j(xi, xj) = F (x)

This chain of logic can be extended for any k ≥ 3. Explicitly, for general k ≤ m, let S(i1, i2, . . . , ik) denote all
permutations of the set {i1, . . . , ik}. Then, taking expectation of the unbiased estimator will give:

i(cid:54)=j=1

m(cid:88)
m(cid:88)
m(cid:88)

i>j=1

i>j=1

(cid:80)

Eσg(σ, xσ(1), . . . , xσ(k))

(cid:32)

(cid:88)

=

=

=

(cid:32)


(i1,i2,...,ik)∈ mPk

m(cid:88)
m(cid:88)

i1>i2>...>ik=1

i1>i2>...>ik=1

(cid:80)

(cid:80)

(cid:88)

(j1,...,jk)∈S(i1,...,ik)

hj1,...,jk (xj1 , . . . , xjk )

p(i1, . . . , ik)

(j1,...,jk)∈S(i1,...,ik)

p(j1, . . . , jk)

(j1,...,jk)∈S(i1,...,ik)

hj1,...,jk (xj1, . . . , xjk )

(cid:80)

(j1,...,jk)∈S(i1,...,ik)

(j1,...,jk)∈S(i1,...,ik)

p(j1, . . . , jk)

(cid:33)

p(j1, . . . , jk)

(cid:33)

(cid:33)(cid:32)
 =

(cid:80)

(cid:88)

(j1,...,jk)∈S(i1,...,ik)

(i1,i2,...,ik)∈ mPk

hj1,...,jk (xj1 , . . . , xjk )

hi1,i2,...,ik (xi1 , xi2 , . . . , xik ) = F (x)

Note: For k = m, i.e., when the full feedback is received, the unbiased estimator is:

g(σ, xσ(1), . . . , xσ(m)) =

(j1,j2,...,jm)∈Sm

(cid:80)

(cid:80)
(cid:80)

hσ(j1),...,σ(jm)(xσ(j1), . . . , xσ(jm))

(j1,...,jm)∈Sm

p(σ(j1), . . . , σ(jm))

(i1,i2,...,im)∈ mPm

=

hi1,...,im (xi1, . . . , xim)

1

= F (x)

Hence, with full information, the unbiased estimator of F (x) is actually F (x) itself, which is consistent with the
theory of unbiased estimator.

Online Learning to Rank with Feedback at the Top

Proof of Lemma 4:

Proof. The ﬁrst equality is true because

(cid:107)X(cid:62)(cid:107)1→p = sup
v(cid:54)=0

The second is true because

= sup
u(cid:54)=0

sup
v(cid:54)=0

(cid:107)X(cid:62)v(cid:107)p
(cid:107)v(cid:107)1

= sup
v(cid:54)=0

sup
u(cid:54)=0

(cid:104)v, Xu(cid:105)
(cid:107)v(cid:107)1(cid:107)u(cid:107)q

= sup
u(cid:54)=0

(cid:10)X(cid:62)v, u(cid:11)

(cid:107)v(cid:107)1(cid:107)u(cid:107)q
(cid:107)Xu(cid:107)∞
(cid:107)u(cid:107)q

= (cid:107)X(cid:107)q→∞.

(cid:107)X(cid:107)q→∞ = sup
u(cid:54)=0

(cid:107)Xu(cid:107)∞
(cid:107)u(cid:107)q

|(cid:104)Xj:, u(cid:105)|

(cid:107)u(cid:107)q
(cid:107)Xj:(cid:107)p.

m

max
j=1

=

m

max
j=1

= sup
u(cid:54)=0
|(cid:104)Xj:, u(cid:105)|

(cid:107)u(cid:107)q

=

m

max
j=1

sup
u(cid:54)=0

Proof of Lemma 5 : We restate the lemma before giving the proof:

Lemma 5: For parameter γ in Algorithm 1 , RD being the bound on (cid:96)2 norm of the feature vectors (rows
of document matrix X), m being the upper bound on number of documents per query, U being the radius of
the Euclidean ball denoting the space of ranking parameters and Rmax being the maximum possible relevance
value (in practice always ≤ 5), let C φ ∈ {C sq, C svm, C KL} be polynomial functions of RD, m, U, Rmax, where
the degrees of the polynomials depend on the surrogate (φsq, φsvm, φKL). Then we have,

(cid:2)(cid:107)˜zt(cid:107)2(cid:3) ≤ C φ

.

γ

Et

Proof. All our unbiased estimators are of the form X(cid:62)f (s, R, σ). We will actually get a bound on f (s, R, σ) by
using Lemma 4 and p → q norm relation, to equate out X:

(cid:107)˜z(cid:107)2 = (cid:107)X(cid:62)f (s, R, σ)(cid:107)2 ≤ (cid:107)X(cid:62)(cid:107)1→2(cid:107)f (s, R, σ)(cid:107)1

≤ RD(cid:107)f (s, R, σ)(cid:107)1

since RD ≥ maxm
Squared Loss: The unbiased estimator of gradient of squared loss, as given in the main text, is:

j=1 (cid:107)Xj:(cid:107)2.

where p(σ(1)) =(cid:80)

π∈Sm

Now we have:

˜z = X(cid:62)(2(s − Rσ(1)eσ(1)
p(σ(1))

))

P(π)1(π(1) = σ(1)) (P = Pt is the distribution at round t as in Alg. 1 )

(cid:107)s − Rσ(1)eσ(1)
p(σ(1))

(cid:107)1 ≤ mRDU +

Rmax
p(σ(1))

≤ mRDU Rmax

p(σ(1)

Thus, taking expectation w.r.t σ, we get:

Eσ(cid:107)˜z(cid:107)2

2 ≤ m2R4

DU 2R2

max

Eσ

1

p(σ(1))2 = m2R4

DU 2R2

max

m(cid:88)

i=1

p(i)
p2(i)

Now, since p(i) ≥ γ
m

, ∀ i, we get: Eσ(cid:107)˜z(cid:107)2

2 ≤ C sq
γ

, where C sq = m4R4

DU 2R2

max.

RankSVM Surrogate: The unbiased estimator of gradient of the RankSVM surrogate, as given in the main
text, is:

˜z = X(cid:62)(cid:18) hs,σ(1),σ(2)(Rσ(1), Rσ(2)) + hs,σ(2),σ(1)(Rσ(2), Rσ(1))

(cid:19)

p(σ(1), σ(2)) + p(σ(2), σ(1))

where hs,i,j(Ri, Rj) = 1(Ri > Rj)1(1 + sj > si)(ej − ei) and p(σ(1), σ(2)) = (cid:80)

Sougata Chaudhuri, Ambuj Tewari

P(π)1(π(1) = σ(1), π(2) =

π∈Sm

σ(2)) (P = Pt as in Alg. 1)).
Now we have:

(cid:107) hs,σ(1),σ(2)(Rσ(1), Rσ(2)) + hs,σ(2),σ(1)(Rσ(2), Rσ(1))

p(σ(1), σ(2)) + p(σ(2), σ(1))

(cid:107)1 ≤

2

p(σ(1), σ(2)) + p(σ(2), σ(1))

Thus, taking expectation w.r.t σ, we get:

Eσ(cid:107)˜z(cid:107)2

2 ≤ 4R2

D

Eσ

(p(σ(1), σ(2)) + p(σ(2), σ(1)))2 ≤ 4R2

1

D

m(cid:88)

i>j

p(i, j) + p(j, i)

(p(i, j) + p(j, i))2

Now, since p(i, j) ≥ γ

m2 , ∀ i, j, we get: Eσ(cid:107)˜z(cid:107)2

2 ≤ C svm
γ

, where C svm = O(m4R2

D).

KL based Surrogate: The unbiased estimator of gradient of the KL based surrogate, as given in the main
text, is:

where p(σ(1)) =(cid:80)

π∈Sm

Now we have:

˜z = X(cid:62)(cid:18) (exp(sσ(1)) − exp(Rσ(1)))eσ(1)

(cid:19)

p(σ(1))

P(π)1(π(1) = σ(1)) (P = Pt as in Alg. 1) ).

(cid:107) (exp(sσ(1)) − exp(Rσ(1)))eσ(1)

p(σ(1))

(cid:107)1 ≤ exp(RDU )
p(σ(1))

Thus, taking expectation w.r.t σ, we get:

Following the same arguement as in squared loss, we get: Eσ(cid:107)˜z(cid:107)2

, where C KL = m2R2

D exp(2RX U ).

Eσ(cid:107)˜z(cid:107)2

2 ≤ R2

D exp(2RDU )Eσ(

1

p(σ(1))2
2 ≤ C KL
γ

Proof of Lemma 2 :

Proof. Let m = 3. The term associated with the 1st coordinate of R, i.e, R1, in the gradient of RankSVM is:
1(R1 > R2)1(1 + s2 > s1)(e2 − e1) + 1(R2 > R1)1(1 + s1 > s2)(e1 − e2) + 1(R1 > R3)1(1 + s3 > s1)(e3 − e1)
+ 1(R3 > R1)1(1 + s1 > s3)(e1 − e3). Now let s1 = 1, s2 = 0, s3 = 0. Then the term associated becomes:
1(R2 > R1)(e1 − e2) + 1(R3 > R1)(e1 − e3) = (1(R2 > R1) + 1(R3 > R1))e1 − 1(R2 > R1)e2 − 1(R3 > R1)e3.
Now, if the gradient can be decomposed over R1, then the term associated with R1 should only be a function of
R1. More speciﬁcally, (1(R2 > R1) + 1(R3 > R1)) (the non-zero coeﬃcient of e1, in the term associated with
R1) should be a function of only R1. Same for the non-zero coeﬃcients of e2 and e3.

Now assume that the (1(R2 > R1) + 1(R3 > R1)) can be expressed as a function of R1 only. Then the diﬀerence
between the coeﬃcient’s values, for the following two cases: R1 = 0, R2 = 0, R3 = 0 and R1 = 1, R2 = 0, R3 = 0,
would be same as the diﬀerence between the coeﬃcient’s values, for the following two cases: R1 = 0, R2 =
1, R3 = 1 and R1 = 1, R2 = 1, R3 = 1 (Since the diﬀerence would be aﬀected only by change in R1 value). It
can be clearly seen that the change in value between the ﬁrst two cases is: 0 − 0 = 0, while the change in value
bertween the second two cases is: 2 − 0 = 2. Thus, we reach a contradiction.

Proof. The term associated with the 1st coordinate of R,

i.e, R1,

in the gradient of ListNet is =

Proof of Lemma 3 :

(cid:80)m

i=1

(cid:32) − exp(Ri)
(cid:80)m

j=1 exp(Rj)

(cid:80)m

+

(cid:33)

exp(si)
j=1 exp(sj)

ei

Online Learning to Rank with Feedback at the Top

Now, f (R) =

been a function of R1, then

is the non-zero coeﬃcient of e1. Now, if f (R) would have only

exp(si)
j=1 exp(sj)
, ∀ j (cid:54)= i would have been zero. It can be clearly seen this is not the case.

the term associated with R1 and R2,

in the gradient of ListNet

is

same as before,

i.e,

j=1 exp(Rj)

(cid:32) − exp(Ri)
(cid:80)m
(cid:32) − exp(Ri)
(cid:80)m
(cid:80)m
(cid:32) − exp(Ri)
(cid:80)m

j=1 exp(Rj)

+

j=1 exp(Rj)

(cid:80)m

+

∂2f (R)
∂Ri∂Rj

exp(si)
j=1 exp(sj)

(cid:80)m

+

Now,

(cid:80)m

i=1

Now, f (R) =

been a function of R1 and R2, then

is not the case.

(cid:33)

(cid:33)

(cid:33)

ei for both

exp(si)
j=1 exp(sj)
∂3f (R)

∂Ri∂Rj∂R(cid:96)

is the non-zero coeﬃcient of e1. Now, if f (R) would have only

, ∀(cid:96) (cid:54)= i, (cid:96) (cid:54)= j would have been zero. It can be clearly seen this

The same arguement can be extended for any k < m.

Proof of Theorem. 5.2:

Proof. We will ﬁrst ﬁx the setting of the online game. We consider m = 3 and ﬁxed the document matrix
X ∈ R3×3 to be the identity. At each round of the game, the adversary generates the ﬁxed X and the learner
chooses a score vector s ∈ R3. Making the matrix X identity makes the distinction between weight vectors w
and scores s irrelevant since s = Xw = w. We note that allowing the adversary to vary X over the rounds only
makes him more powerful, which can only increase the regret. We also restrict the adversary to choose binary
relevance vectors. Once again, allowing adversary to choose multi-graded relevance vectors only makes it more
powerful. Thus, in this setting, the adversary can now choose among 23 = 8 possible relevance vectors. The
learner’s action set is inﬁnite, i.e., the learner can choose any score vector s = Xw = Rm. The loss function
φ(s, R) is any NDCG calibrated surrogate and feedback is the relevance of top-ranked item at each round, where
ranking is induced by sorted order (descending) of score vector. We will use p to denote randomized adversary
one-short strategies, i.e. distributions over the 8 possible relevance score vectors. Let s∗
ER∼pφ(s, R).
We note that in the deﬁnition of NDCG calibrated surrogates, Ravikumar et al. [2011] assume that the optimal
score vector for each distribution over relevance vectors is unique and we subscribe to that assumption. The
assumption was taken to avoid some boundary conditions.

p = argmins

It remains to specify the choice of U , a bound on the Euclidean norm of the weight vectors (same as score vectors
for us right now) that is used to deﬁne the best loss in hindsight. It never makes sense for the learner to play
anything outside the set ∪ps∗
The paragraph following Lemma 6 of Thm. 3 in Piccolboni and Schindelhauer [2001] gives the main intuition
behind the argument the authors developed to prove hopelessness of ﬁnite action partial monitoring games. To
make our proof self contained, we will explain the intuition in a rigorous way.

p so that we can set U = max{(cid:107)s(cid:107)2 : s ∈ ∪ps∗
p}.

Key insight: Two adversary strategies p, ˜p are said to be indistinguishable from the learner’s feedback per-
spective, if for every action of the learner, the probability distribution over the feedbacks received by learner
is the same for p and ˜p. Now assume that adversary always selects actions according to one of the two such
indistinguishable strategies. Thus, the learner will always play one of s∗
˜p. Then, the
learner incurs a constant (non-zero) regret on any round where adversary plays according to p and learner plays
s∗
p, or if the adversary plays according to ˜p and learner plays s∗
˜p. We show that in such a setting, adversary can
simply play according to (p + ˜p)/2 and the learner suﬀers an expected regret of Ω(T ).
Assume that the adversary selects {R1, . . . , RT} from product distribution ⊗p. Let the number of times the
learner plays s∗
p and s∗
2 respectively, where N p shows the exclusive
It is always true that N p
dependence on p.
2 = T . Moreover, let the expected per round regret be p
when learner plays s∗
˜p , where the expectation is taken over the randomization of adversary. Now, assume that
adversary selects {R1, . . . , RT} from product distribution ⊗˜p. The corresponding notations become N ˜p
1 and N ˜p

˜p be denoted by random variables N p

˜p. Now, let s∗

p and s∗

1 and N p

p (cid:54)= s∗

1 + N p

2

Sougata Chaudhuri, Ambuj Tewari

Table 1: Relevance and probability vectors.

p
˜p

0.0 0.1 0.15 0.05 0.2
0.0 0.3 0.0

0.3 0.2 0.0
0.0 0.15 0.15 0.4 0.0
Rel. R1 R2 R3 R4 R5 R6 R7 R8
1
1
1

1
0
0

0
0
0

0
1
1

0
1
0

0
0
1

1
1
0

1
0
1

E(R1,...,RT )∼⊗pE(s1,...,sT )[Regret((s1, . . . , sT ), (R1, . . . , RT ))] = 0 · E[N p

1 ] + p · E[N p
2 ]

and  ˜p. Then,

and

E(R1,...,RT )∼⊗ ˜pE(s1,...,sT )[Regret((s1, . . . , sT ), (R1, . . . , RT ))] =  ˜p · E[N ˜p

1 ] + 0 · E[N ˜p
2 ]
1 ] = E[N1] and E[N p

1 ] = E[N ˜p
2 ] =
p is played by learner does not depend on

2 ] = E[N ˜p

Since p and ˜p are indistinguishable from perspective of learner, E[N p
E[N2]. That is, the random variable denoting number of times s∗
adversary distribution (same for s∗

˜p.). Using this fact and averaging the two expectations, we get:

E
(R1,...,RT )∼ ⊗p+⊗ ˜p

2

E(s1,...,sT )[Regret((s1, . . . , sT ), (R1, . . . , RT ))] =

·E[N1]+

 ˜p
2

p
2

·E[N2] ≥ min(

p
2

,

 ˜p
2

)·E[N1+N2] = ·T

E(s1,...,sT )[Regret((s1, . . . , sT ), (R1, . . . , RT ))],

E[Regret((s1, . . . , sT ), (R1, . . . , RT ))] ≥ E

2

(R1,...,RT )∼ ⊗p+⊗ ˜p

Since supR1,...,RT
we conclude that for every learner algorithm, adversary has a strategy, s.t. learner suﬀers an expected regret of
Ω(T ).
Now, the thing left to be shown is the existence of two indistinguishable distributions p and ˜p, s.t. s∗
Characterization of indistinguishable strategies in our problem setting: Two adversary’s strategies p
and ˜p will be indistinguishable, in our problem setting, if for every score vector s, the relevances of the top-ranked
item, according to s, are same for relevance vector drawn from p and ˜p. Since relevance vectors are restricted
to be binary, mathematically, it means that ∀s, PR∼p(Rπs(1) = 1) = PR∼ ˜p(Rπs(1) = 1) (actually, we also need
∀s, PR∼p(Rπs(1) = 0) = PR∼ ˜p(Rπs(1) = 0), but due to the binary nature, PR∼p(Rπs(1) = 1) = PR∼ ˜p(Rπs(1) = 1)
=⇒ PR∼p(Rπs(1) = 0) = PR∼ ˜p(Rπs(1) = 0)). Since the equality has to hold ∀s, this implies ∀j ∈ [m],
PR∼p(Rj = 1) = PR∼ ˜p(Rj = 1) (as every item will be ranked at top by some score vector). Hence, ∀j ∈ [m],
ER∼p[Rj] = ER∼ ˜p[Rj] =⇒ ER∼p[R] = ER∼ ˜p[R]. It can be seen clearly that the chain of implications can be
reversed. Hence, ∀s, PR∼p(Rπs(1) = 1) = PR∼ ˜p(Rπs(1) = 1) ⇐⇒ ER∼p[R] = ER∼ ˜p[R].
Explicit adversary strategies: Following from the discussion so far and Theorem 5.1, if we can show existence
of two strategies p and ˜p s.t. ER∼p[R] = ER∼ ˜p[R], but argsort
, we
are done.

(cid:105)(cid:17) (cid:54)= argsort

(cid:16)ER∼ ˜p

(cid:16)ER∼p

(cid:104) G(R)

(cid:104) G(R)

p (cid:54)= s∗
˜p.

(cid:105)(cid:17)

Zm(R)

Zm(R)

8

vectors

possible

relevance

(adversary’s

The
=
(000, 110, 101, 011, 100, 010, 001, 111). Let the two probability vectors be: p = (0.0, 0.1, 0.15, 0.05, 0.2, 0.3, 0.2, 0.0)
and ˜p = (0.0, 0.3, 0.0, 0.0, 0.15, 0.15, 0.4, 0.0). The data is provided in table format in Table. 1.
Under the two distributions, it can be checked that ER∼p[R] = ER∼ ˜p[R] = (0.45, 0.45, 0.4)(cid:62).
However, ER∼p
argsort

(cid:104) G(R)
(cid:105)(cid:17) ∈ {[3, 1, 2](cid:62), [3, 2, 1](cid:62)}.

= (0.3533, 0.3920, 0.3226)(cid:62), but ER∼ ˜p
= [2, 1, 3](cid:62) but argsort

= (0.3339, 0.3339, 0.4000)(cid:62). Hence,

(cid:104) G(R)
(cid:105)
(cid:104) G(R)
(cid:105)(cid:17)

(R1, R2, R3, R4, R5, R6, R7, R8)

(cid:104) G(R)

(cid:16)ER∼ ˜p

(cid:16)ER∼p

actions)

Zm(R)

Zm(R)

(cid:105)

are

Zm(R)

Zm(R)

