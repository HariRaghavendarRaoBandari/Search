6
1
0
2

 
r
a

M
1

 

 
 
]
h
p
-
t
n
a
u
q
[
 
 

1
v
5
9
1
2
0

.

3
0
6
1
:
v
i
X
r
a

Self-guaranteed measurement-based quantum computation

Masahito Hayashi1, 2, ∗ and Michal Hajduˇsek2, †

1Graduate School of Mathematics, Nagoya University, Furocho, Chikusa-ku, Nagoya 464-860, Japan

2Centre for Quantum Technologies, National University of Singapore, 3 Science Drive 2, Singapore 117543

We introduce a new veriﬁcation protocol for measurement-only blind quantum computation where
the client can only perform single-qubit measurements and the server has suﬃcient ability to prepare
a multi-qubit entangled state. Previous such protocols were limited by strong assumptions about
the client’s quantum devices. We remove these assumptions by performing self-testing procedure
to certify the initial entangled state prepared by the server as well as the operation of the client’s
quantum devices. In the case of an honest server and client’s devices, the protocol produces the
correct outcome of the quantum computation. Given a cheating server or malicious quantum devices,
our protocol bounds the probability of the client accepting an incorrect outcome while introducing
only modest overhead in terms of the number of copies of the initial state needed that scales as
O(n4 log n), where n is the size of the initial universal resource.

I.

INTRODUCTION

Quantum computation oﬀers a novel way of process-
ing information and promises solution of some classically
intractable problems ranging from factorization of large
numbers [1] to simulation of quantum systems [2]. How-
ever, as quantum information processing technologies im-
prove and basic operations in physical systems such as
ion traps and superconducting qubits exceed ﬁdelities re-
quired for fault-tolerant quantum computation [3, 4], a
natural question of verifying the output of quantum com-
putation arises. For problems such as factorization, this
does not present an issue as veriﬁcation takes the form
of simple multiplication of numbers. On the other hand,
veriﬁcation of simulation of quantum systems may be as
hard as the original problem itself [5].

Guaranteeing the output of a quantum computation
may seem like a daunting task, particularly when consid-
ered in the context of quantum circuit model [6]. In this
model, the computation takes form of a sequence of local
and multi-local unitary operations applied to the quan-
tum state resulting in a quantum output that is ﬁnally
measured out to yield the classical result of the compu-
tation. In order to verify the correctness of the output it
would appear that one needs to keep track of the entire
dynamics, eﬀectively classically simulating the quantum
computation. This can of course be achieved only for
the smallest of quantum systems due to the exponential
increase in the dimensionality of the Hilbert space with
increasing system size.

Measurement-based model of quantum computation
(MBQC) is equivalent to the quantum circuit model but
uses non-unitary evolution to drive the computation [7].
In this model, the computation begins with preparation
of a universal multi-qubit resource state and proceeds
by local projective measurements on this state that use
up the initial entanglement. In order to implement the

∗ masahito@math.nagoya-u.ac.jp
† cqtmich@nus.edu.sg

desired evolution corresponding to the unitary from the
circuit model, the measurements must be performed in
an adaptive way where future measurement bases depend
on previous measurement outcomes. This imposes a tem-
poral ordering on the measurements.

One of the main diﬀerences between MBQC and the
quantum circuit model is the clear split between prepara-
tion of the initial entangled resource state and the compu-
tation itself. This property suggests a natural approach
to guaranteeing the outcome of the computation by split-
ting the veriﬁcation process into two parts. Firstly, we
have to verify the initial entangled multi-qubit resource
state. Secondly, we must guarantee the correct opera-
tions of the measurement devices that drive the compu-
tation. The initial proposal of MBQC in [7] considered
measurements in the X-Y plane of a qubit’s Bloch sphere
at an arbitrary angle. This is not necessary as measure-
ments at ﬁnite set of angles are suﬃcient to achieve ap-
proximate universality. We consider a particular approx-
imately universal set of measurements given by Pauli ob-
servables X, Y and Z as well as measurements of the
Hadamard observable (X + Y )/√2 [8].

Recent years have seen a number of protocols that ad-
dress the question of veriﬁcation of quantum computa-
tion using MBQC [9–15] and some of these protocols were
also demonstrated experimentally in 4-qubit systems us-
ing photons [16–18]. Veriﬁcation protocols that do not
utilize MBQC were considered in [19, 20] as well as new
non-interactive approaches introduced in [21, 22].

Many of the above protocols rely crucially on the use
of self-testing techniques to guarantee prepared states as
well as to certify the operation of quantum devices. Self-
testing, originally proposed in [23, 24], is a statistical test
that compares measured correlations with the ideal ones
and based on the closeness of these two cases draws con-
clusions whether the real devices behave as instructed
under a particular deﬁnition of equivalence. Self-testing
does not make any strong assumptions about the Hilbert
space structure of the devices or the measurement oper-
ators corresponding to classical outcomes observed. The
only assumption that is made is the usual requirement
that the quantum devices are non-communicating.

Blind quantum computation introduced in [9, 10] is a
protocol for quantum computation where the client (Al-
ice) has limited quantum resources and wishes to delegate
her computation to a server (Bob) who possesses a uni-
versal quantum computer. Particularly she wishes to do
this in such a way that her computation along with its
input and output remain hidden from Bob. Originally,
[9, 10] considered the scenario where Alice had access to
a source of single-qubits that she sent to Bob who entan-
gled these qubits to create the initial resource state and
then performed single-qubit measurements as instructed
by Alice.

We address the question of guaranteeing the outcome
of a quantum computation by considering a speciﬁc ap-
proach to veriﬁcation known as measurement-only blind
quantum computation [11–13]. In this protocol, Bob pre-
pares the universal initial resource state and sends it to
Alice who is limited to single-qubit measurements. In-
spired by techniques developed in [25, 26] we introduce
a self-testing protocol that certiﬁes two-colorable graph
states acting as universal resources for MBQC and Al-
ice’s measurement devices. Crucial component of our ap-
proach is the combination of stabilizer measurements on
the resource prepared by Bob combined with measure-
ments of CHSH-like correlations [27] that lead to self-
testing.

In [12], the authors showed how to guarantee the
graph state using local measurements with trusted de-
vices. Building on this result, we show how to guar-
antee local measurements on an untrusted two-colorable
graph state of a large size. Before presenting the self-
testing protocol for a general two-colorable state of ar-
bitrary size, we consider the task of certifying untrusted
quantum devices with the help of a two-qubit maximally
entangled state. Note that we cannot guarantee the local
measurements without the use of correlations present in
entangled states.

II. SELF-TESTING OF MEASUREMENTS

BASED ON TWO-QUBIT ENTANGLED STATE

As the ﬁrst step, we consider a self-testing protocol
of local measurements on the qubit system H1 when the
untrusted state 1√2
(|0, +i+|1,−i) is prepared in the two-
qubit system H′1 and H′2.
In the rest of our paper we
denote untrusted states and operators with primes, such
as |ψ′i and X′, in order to distinguish them from trusted
states and devices which have no primes. Our protocol
satisﬁes the following requirements related to our self-
testing protocol for two-colorable graph state.

(1-1): We need to identify measurements of X1, Y1, Z1

and (X1 + Y1)/√2 within a constant error ǫ.

(1-2): We measure X′1, Y ′1 , Z′1, A(i)′1, B(i)′1, and C(i)′1
for i = 0, 1 in the system H′1, where A(i)′1 :=
1+(−1)iZ ′
X ′
, and C(i)′1 :=

, B(i)′1 := X ′

1

1+(−1)iY ′

1

√2

√2

2

FIG. 1. Representation of the self-testing procedure for the
state 1
√2 (|0, +i + |1, −i). The source prepares 17m copies of
this state which are then randomly divided into 17 groups.
Each group is then measured as described in (2-3) and (2-
4). There are 9 measurement settings for system H′1 and 3
measurement settings for system H′2. Each group is measured
by one device acting on system H′1 and one device acting on
system H′2.

1 +(−1)iZ ′
Y ′

1

√2

.

(1-3): We measure only X′2, Y ′2 , and Z′2 in the system

H′2.

(1-4): We prepare only O(δ−4) samples for the required
precision level δ, whose deﬁnition will be given lat-
ter.

Requirement (1-1) is needed for universal computation
based on measurement-based quantum computation [8].
Two-colorable graph states can be partitioned into two
subsets of non-adjacent qubits.
In the rest of our pa-
per, we refer to one of these subsets as black qubits while
the other subset is referred to as white qubits. To real-
ize the self-guaranteed MBQC of n-qubit two-colorable
graph state with resource size O(n4 log n), we need the
requirement (1-4). Indeed, McKague et al [25] already
gave a self-testing protocol for the Bell state. However,
their protocol requires much more resources than that in
(1-4).

The self-testing procedure is illustrated in FIG. 1 and

is as follows,

(2-1): We prepare 17m states |Φ′i := 1√2
(|0, +i+|1,−i).
(2-2): We randomly divide 17m blocks into 17 groups,
in which, the 1st - 17th groups are composed of m
blocks.

(2-3): We measure X′1, Z′1, Y ′1, A(0)′1, A(0)′1, A(1)′1,
A(1)′1, B(0)′1, B(0)′1, B(1)′1, B(1)′1, C(0)′1, C(0)′1,
C(1)′1, C(1)′1, X′1, Y ′1 in the system H′1 for the 1st
- 17th groups.

(2-4): We measure Z′2, X′2, Y ′2 , X′2, Z′2, X′2, Z′2, Z′2, Y ′2 ,
Z′2, Y ′2 , Y ′2 , X′2, Y ′2 , X′2, Y ′2 , Z′2 in the system H′2
for the 1st - 17th groups.

(2-5): Based on the above measurements, we check the

following 8 inequalities for 8 average values:

3

Av[X′1Z′2] = 1, Av[Z′1X′2] = 1, Av[Y ′1 Y ′2 ] = 1
Av[A(0)′1(X′2 + Z′2) + A(1)′1(−X′2 + Z′2)] ≥ 2√2 −
Av[B(0)′1(Z′2 + Y ′2 )] ≥
Av[B(1)′1(Z′2 − Y ′2 )] ≥
Av[C(0)′1(Y ′2 + X′2) + C(1)′1(Y ′2 − X′2)] ≥ 2√2 −
Av[X′1Y ′2 + Y ′1Z′2] ≤

√2 −
√2 −

c1
2√m
c1
2√m

c1
2√m

.

c1√m

c1√m

for

example,

Here,
value
Av[A(0)′1(X′2 + Z′2) + A(1)′1(−X′2 + Z′2)]
is
calculated from the outcomes of the 1st - 4th
groups.

average

the

This leads to the following theorem, which will be

shown in Appendix A.

Theorem 1. Given a signiﬁcance level α and a detection
probability β, there exists a pair of positive real numbers
c1 and c2 satisfying the following condition. If we per-
fectly prepare the state 1√2
(|0, +i + |1,−i) and our mea-
surement has no error, the test is passed with probability
β. If the test is passed with the above c1, there exists a
isometry U : H′1 → H1 such that, with signiﬁcance level
α, we can guarantee that

kU X′1U† − X1k ≤ δ
kU Y ′1 U† − Y1k ≤ δ
kU Z′1U† − Z1k ≤ δ
kU B(0)′1U† − B(0)1k ≤ δ,

(1)

(2)

(3)

(4)

where δ := c2
m
level.

1
4

, which is called the required precision

Note that the signiﬁcance level is the maximum passing
probability when one of the conditions in (2-5) does not
hold [28]. This shows how the measurements forming a
approximately universal set for MBQC can be certiﬁed
using a two-qubit state. Now we proceed to extend this
scheme to two-colorable states of arbitrary size.

III. SELF-TESTING OF A TWO-COLORABLE

GRAPH STATE

For a two-colorable graph state |G′i composed of n
qubits, our protocol needs to prepare cm samples of the
state |G′i, where m is O(n4 log n). The constant c de-
pends on the structure of the graph G. To specify it,
we introduce two numbers lB and lW for a two-colorable
graph G. Consider the set SB := {1, . . . , nB} of black
sites and the set SW := {1, . . . , nW} of white sites. We

FIG. 2. Bipartition into black and white vertices with the
black vertices partitioned into four subsets {SB,k}4
k=1. This
partitioning can be constructed as follows. Start by consider-
ing the central black circle and black vertices represented by
triangles and squares. Both triangles have two common neigh-
bors with the central black circle and one common neighbor
with each square. However the two triangles share no com-
mon neighbors with each other. Therefore the two vertices
are in the same subset SB,k but the squares must be in a
diﬀerent subset. We continue to consider vertices represented
by the pentagons and see that each shares a neighbor with
one triangle, one square and the central circle. The only pos-
sible vertices left to consider are the circles in the four corners
of the graph. They do not share any common neighbors with
the central black circle or with each other and are in the same
subset SB,k. This logic can be extended to two-dimensional
lattice graphs of arbitrary size and gives lB ≤ 4.

denote the neighborhood of the site i by Ni. We di-
vide the sites SB into lB subsets SB,1, . . . , SB,lB such
that N (SB,k) ∩ N (SB,j) = ∅ for k 6= j with N (SB,k) :=
∪i∈SB,k Ni. That is, elements of SB,k have no common
neighbors, which is called the non-conﬂict condition. We
choose the number lB as the minimum number satisfying
the non-conﬂict condition. We also deﬁne the number
lW for the white sites in the same way. For example, in
the one-dimensional cluster state, lB ≤ 2.
In the two-
dimensional cluster state, lB ≤ 4, also see FIG. 2. In the
three-dimensional cluster state, lB ≤ 8. Based on this
structure, testing of measurement devices on each site
on SB,k can be reduced to the two-qubit case as follows.

(3-1): We prepare 17m states |G′i.
(3-2): We measure Z′ on all sites of SB \ SB,k for all
copies. Then, we apply Z′ operators on the re-
maining sites to correct applied Z′ operators de-
pendently of the outcomes.

(3-3): For all i ∈ SB,k, we choose a site ji ∈ Ni. Then,
we measure Z′ on all sites of SW \ {ji}i∈SB,k for
all copies. Then, we apply Z′ operators on the
remaining sites to correct applied Z′ operators de-
pendently of the outcomes.

(3-4): Due to the above steps, the resultant state should
be ⊗i∈SB,k|Φ′iiji . Then, we apply the above self-
testing procedure to all of {|Φ′iiji}i∈SB,k .

Since the above protocol veriﬁes the measurement device
on Block color sites in SB,k, we call it B-protocol with
SB,k. We deﬁne W-protocol with SW,k.

Then, choosing c3 to be 2 + 16(lB + lW ), we propose

our self-testing protocol as follows,

(4-1): We prepare c3m + 1 states |G′i.
(4-2): We randomly divide c3m + 1 blocks into c3 + 1
groups. The ﬁrst c3 groups are composed of m
blocks and the ﬁnal group is composed of a single
block. Each block contains n qubits.

(4-3): We measure Z′ on the black sites and X′ on the
white sites for the 1st group and check that the out-
come of X′ measurements is the same as predicted
from the outcomes of Z′ measurements.

(4-4): We repeat the above stabilizer test on the 2nd
group but measure white sites in the Z′ basis and
black sites in X′ basis.

(4-5): We run B-protocol with SB,k for the 3 + 16(k −
1)-th - 2 + 16k-th groups. Notice that the ﬁrst
condition in Step (2-5) has been done in Step (4-
3), we check only 16 remaining conditions in Step
(2-5). We repeat this protocol for k = 1, . . . , lB.

(4-6): We run W-protocol with SB,k for the 3 + 16lW +
16(k − 1)-th - 2 + 16lW + 16k-th groups as Step
(4-5). We repeat this protocol for k = 1, . . . , lW .

In the above protocol, steps (4-3) and (4-4) perform
the stabilizer test given in [12] which certiﬁes the graph
state |Gi. For our self-testing, we need to guarantee local
measurements of X1, Y1, Z1 and (X1 + Y1)/√2 for all
sites.

We need to pass around 16n tests with suﬃciently large
probability because each site requires 16 tests. Hence, we
need to choose c1 to be c4(log n)1/2 so that the passing
probability for each test is β
n , which leads to the following
theorem.

Theorem 2. Given a signiﬁcance level α and a detec-
tion probability β, there exists a pair of positive real num-
bers c2 and c4 satisfying the following condition. If we
perfectly prepare the state |Gi and our measurement has
no error, the test is passed with probability β.
If the
test is passed with the above c4, there exists an isome-
try Ui : H′i → Hi such that, with signiﬁcance level α, we
can guarantee that

kUiX′iU†i − Xik ≤ δ
kUiY ′i U†i − Yik ≤ δ
kUiZ′iU†i − Zik ≤ δ
kUiB(0)′iU†i − B(0)ik ≤ δ
c2
Tr σ(I − P ′1), Tr σ(I − P ′2) ≤
m

(5)

(6)

(7)

(8)

(9)

1

1
4

(log n)

where δ := c2
4 , U := U1 ⊗ ··· ⊗ Un, σ is the
m
resultant state on the ﬁnal group, and P ′1, P ′2 are POVM
elements corresponding to pass of Steps (4-3), (4-4).

4

Here, the conditions (5)–(8) follow from Theorem 1
and the condition (9) follows from the same discussion
for the stabilizer test given in [12].

IV. CERTIFICATION OF COMPUTATION

RESULT

To guarantee the computation result, we need to guar-
antee that our computation operation is very close to
the true operation based on Theorem 2. When {Mi}i is
a POVM realized by an adaptive measurement on each
site from X, Y , and B(0), as shown in Appendix B, The-
orem 2 guarantees that

kU M′iU† − Mik ≤ 3nδ,

(10)

Mi is the ideal POVM. This inequality can be shown by
a modiﬁcation of a virtual unitary protocol composed of
a collection of unitaries on each site controlled by an-
other trusted system [15, Corollary 2]. Thus, as shown
in Appendix C, (9) and (10) lead to

kU σU† − |GihG|k1 ≤ r6nδ +

2c2
m

.

(11)

When M′j is the POVM element of all of outcomes cor-
responding to the correct computation result, we have

|Tr (M′jσ − Mj|GihG|)|
≤|Tr (U M′jU† − Mj)U σU†| + |Tr Mj(U σU† − |GihG|)|
≤3nδ +r6nδ +
(12)

2c2
m

.

Thus, choosing m = O(n4 log n), we can achieve constant
upper bound for the probability of accepting an incorrect
output of the quantum computation.

V. DISCUSSION

The above analysis has been restricted to the case of
two-colorable graph states. In fact, the non-conﬂict can
be relaxed to the case of graph states which are not two-
colarable as follows. Firstly, we remember that our anal-
ysis can be divided into two parts, testing of the mea-
surement basis and testing of the graph state. The ﬁrst
part can be generalized as follows. Assume that we have
k colors. For each color i = 1, . . . , k, we divide the set
of sites with color i into subsets Si,1, . . . , Si,li such that
there is no common neighborhood with non-i color for
each subset Si,j.
In this case, we can generalized the
B-protocol as explained in Appendix D. Then, applying
this generalization to all colors in the protocol, we can
extend the ﬁrst part. To realize the second part, for each
color i, we measure non-i color sites with Z basis and
check whether the outcome of measurement X on the
sites with color i is the same as the predicted one. We

repeat this protocol for all colors. Due to the construc-
tion whose detail is given in the supplementary materials,
we obtain the same analysis as two-colorable case when
the numbers l1, . . . , lk are bounded.

Further, in the two-colorable case, we can relax the
non-conﬂict condition. That is, we can replace the non-
conﬂict condition by a certain liner independence condi-

tion, as explained in Appendices E, F, and G.

We have shown how the output of a quantum compu-
tation can be guaranteed in the context of measurement-
only blind quantum computation. For a computation on
an n-qubit graph state the resources needed to achieve
a constant upper bound for probability of accepting a
wrong outcome scale as O(n4 log n).

5

Appendix A: Bell state

We focus on the observables

We consider the state 1√2

X := |1ih0| + |0ih1|,
Y := i|1ih0| − i|0ih1|, Z := |0ih0| − |1ih1|.
(|0, +i + |1,−i) on the composite system H1 ⊗ H2. We also deﬁne

A(0) :=

B(0) :=

C(0) :=

X + Z
√2
X + Y
√2
Y + Z
√2

, A(1) :=

, B(1) :=

, C(1) :=

X − Z
√2
X − Y
√2
Y − Z
√2

,

,

.

(A1)

(A2)

(A3)

(A4)

Here, instead of the ideal systems H1 and H2, we have the real systems H′1 and H′2. Also, we assume that we can
measure real observables X′1, X′2, Y ′1 , Y ′2 , Z′1, Z′2, A(0)′1, A(1)′1, B(0)′1, B(1)′1, C(0)′1, and C(1)′1. Here, we choose
the real systems H′1 and H′2 suﬃciently large so that our measurements are the projective decompositions of these
observables.

In the following, we prepare the real state |ψ′i on the composite system H′1 ⊗ H′2.

Proposition 1. When

hψ′|A(0)′1X′2 + A(0)′1Z′2 − A(1)′1X′2 + A(1)′1Z′2|ψ′i ≥ 2√2 − ǫ1
hψ′|B(0)′1Z′2 + B(0)′1Y ′2 + B(1)′1Z′2 − B(1)′1Y ′2|ψ′i ≥ 2√2 − ǫ2
hψ′|C(0)′1Y ′2 + C(0)′1X′2 + C(1)′1Y ′2 − C(1)′1X′2|ψ′i ≥ 2√2 − ǫ3,

hψ′|X′1Z′2|ψ′i ≥ 1 − ǫ4
hψ′|Z′1X′2|ψ′i ≥ 1 − ǫ5
hψ′|Y ′1 Y ′2|ψ′i ≥ 1 − ǫ6,
hψ′|B(0)′1(Z′2 + Y ′2 )|ψ′i ≥ 2 − ǫ7,

hψ′|X′1Y ′2 + Y ′1 Z′2|ψ′i ≤ ǫ8,

kU X′1U† − X1k ≤ δ1
kU Y ′1U† − Y1k ≤ δ1
kU Z′1U† − Z1k ≤ δ1
k ≤ δ2,

X1 + Y1√2

kU B(0)′1U† −
j + √2(ǫ

4 + ǫ

1
4

1
2

1
4

(A5)

(A6)

(A7)
(A8)
(A9)
(A10)
(A11)
(A12)

(A13)

(A14)

(A15)

(A16)

there exists a local isometry U : H′1 → H1 such that

where δ1 := P6

j=1 ˆcjǫ

j and δ2 := P8

1
2

j=1 ¯cjǫ

6 ), and ˆcj and ¯cj are constants.

Proof of Theorem 1: Now, using Proposition 1, we show Theorem 1 of the main body as follows. Given a
signiﬁcance level α, there exists a positive number c′′ > 0 satisfying the following. Once all of the conditions in Step
(2-5) are satisﬁed, with the signiﬁcance level α, we can guarantee the conditions (A5)-(A12) with ǫ4, ǫ5, ǫ6 = c′′
m and
ǫ1, ǫ2, ǫ3, ǫ7, ǫ8 = c′′
√m . Therefore, using a suitable isometry U , with the signiﬁcance level α, we can guarantee the
conditions (A13)-(A16) with δ1, δ2 = O(m

4 ), which is the desired argument.

1

To show Proposition 1, we need several lemmas.

Lemma 1. When

hψ′|A(0)′1X′2 + A(0)′1Z′2 − A(1)′1X′2 + A(1)′1Z′2|ψ′i ≥ 2√2 − ǫ1
hψ′|B(0)′1Z′2 + B(0)′1Y ′2 + B(1)′1Z′2 − B(1)′1Y ′2|ψ′i ≥ 2√2 − ǫ2
hψ′|C(0)′1Y ′2 + C(0)′1X′2 + C(1)′1Y ′2 − C(1)′1X′2|ψ′i ≥ 2√2 − ǫ3,

we have

where ǫ′j := 2

5

4 ǫ

1
2

j for j = 1, 2, 3.

Lemma 1 follows from Theorem 2 of [25].

Lemma 2. When

we have

k(X′2Z′2 + Z′2X′2)|ψ′ik ≤ 2ǫ′1
k(X′2Y ′2 + Y ′2 X′2)|ψ′ik ≤ 2ǫ′2
k(Y ′2 Z′2 + Z′2Y ′2 )|ψ′ik ≤ 2ǫ′3,

hψ′|X′1Z′2|ψ′i ≥ 1 − ǫ4
hψ′|Z′1X′2|ψ′i ≥ 1 − ǫ5
hψ′|Y ′1 Y ′2|ψ′i ≥ 1 − ǫ6,

k(X′1 − Z′2)|ψ′ik ≤ ǫ′4
k(Z′1 − X′2)|ψ′ik ≤ ǫ′5
k(Y ′1 − Y ′2 )|ψ′ik ≤ ǫ′6,

6

(A17)

(A18)

(A19)

(A20)
(A21)
(A22)

(A23)
(A24)
(A25)

(A26)
(A27)
(A28)

j for j = 4, 5, 6.

where ǫ′j := 2
Proof: Now, we make the spectral decomposition of X′1Z′2 as X′1Z′2 = P − (I − P ), where P is a projection. (A23)
implies that hψ′|(I − P )|ψ′i ≤ ǫ4
1
2

(P + (I − P ) − (P − (I − P )))|ψ′ik = k(I − P )|ψ′ik

2 . Schwarz inequality yields that

(I − X′1Z′2)|ψ′ik = k

(A29)

1
2

1
2

1
2 ǫ

1
2k(X′1 − Z′2)|ψ′ik = k
≤r ǫ4

= 2

1
2 ǫ

4 .

2

1
2

Similarly, we obtain other inequalities.

Lemma 3. When

we have

where ǫ′7 := q√2ǫ7 + 1

2 ǫ8 + √ǫ4 + √ǫ6.

hψ′|X′1Z′2|ψ′i ≥ 1 − ǫ4
hψ′|Y ′1 Y ′2|ψ′i ≥ 1 − ǫ6,
hψ′|B(0)′1(Z′2 + Y ′2 )|ψ′i ≥ 2 − ǫ7,

hψ′|X′1Y ′2 + Y ′1Z′2|ψ′i ≤ ǫ8,

k(B(0)′1 −

Z′2 + Y ′2√2

)|ψ′ik ≤ ǫ′7

(A30)

(A31)
(A32)
(A33)
(A34)

(A35)

(A36)

Proof:

Since

we have

k(X′1Z′2 − I)|ψ′ik ≤ 2√ǫ4,
k(Y ′1Y ′2 − I)|ψ′ik ≤ 2√ǫ6,

|hψ′|Z′2Y ′2 + Y ′2 Z′2|ψ′i − hψ′|Z′2Y ′1 + Y ′2 X′1|ψ′i|
≤khψ′|Z′2Y ′2kk(I − Y ′1 Y ′2 )|ψ′ik + khψ′|Y ′2 Z′2kk(I − X′1Z′2)|ψ′ik
≤2√ǫ4 + 2√ǫ6,

)|ψ′ik2

Z′2 + Y ′2√2
√2B(0)′1(Z′2 + Y ′2 ) +
2 −
√2B(0)′1(Z′2 + Y ′2 ) +

√2hψ′|B(0)′1(Z′2 + Y ′2 )|ψ′i +
ǫ8 + √ǫ4 + √ǫ6

1
2

ǫ8 + √ǫ4 + √ǫ6.

k(B(0)′1 −

=hψ′|B(0)′1
=2 − hψ′|
≤2 −
≤2 − 2 + √2ǫ7 +
=√2ǫ7 +

1
2

Z′2

2 + Y ′2

2 + Z′2Y ′2 + Y ′2 Z′2

2

|ψ′i

Z′2Y ′2 + Y ′2 Z′2

2

|ψ′i

1

2hψ′|Z′2Y ′1 + Y ′2 X′1|ψ′i + √ǫ4 + √ǫ6

Lemma 4. When

k(X′2Z′2 + Z′2X′2)|ψ′ik ≤ 2ǫ′1,
k(X′2Y ′2 + Y ′2 X′2)|ψ′ik ≤ 2ǫ′2,
k(Y ′2Z′2 + Z′2Y ′2 )|ψ′ik ≤ 2ǫ′3,
k(X′1 − Z′2)|ψ′ik ≤ ǫ′4,
k(Z′1 − X′2)|ψ′ik ≤ ǫ′5,
k(Y ′1 − Y ′2 )|ψ′ik ≤ ǫ′6,
Z′2 + Y ′2√2
)|ψ′ik ≤ ǫ′7,
there exists local isometries Uj : H′j → Hj for j = 1, 2 such that

k(B(0)′1 −

kU|ψ′i − |junki|ψik ≤ δ′1,
kU X′1|ψ′i − X1|junki|ψik ≤ δ′1,
kU Y ′1|ψ′i − Y1|junki|ψik ≤ δ′1,
kU Z′1|ψ′i − Z1|junki|ψik ≤ δ′1,
kU X′2|ψ′i − X2|junki|ψik ≤ δ′1,
kU Y ′2|ψ′i − Y2|junki|ψik ≤ δ′1,
kU Z′2|ψ′i − Z2|junki|ψik ≤ δ′1,
|junki|ψik ≤ δ′2,

X1 + Y1√2

kU B(0)′1|ψ′i −

where δ′1 := P6

j=1 c′jǫ′j and δ′2 := √2δ′1 + ǫ′7 and U := U2U1.

7

(A37)
(A38)

(A39)
(A40)
(A41)

(A42)

(A43)

(A44)

(A45)

(A46)

(A47)

(A48)
(A49)
(A50)
(A51)
(A52)
(A53)

(A54)

(A55)
(A56)
(A57)
(A58)
(A59)
(A60)
(A61)

(A62)

(A63)

Proof: We set the initial state on H1 ⊗ H2 to be |0, +i. Deﬁne U1 := (|0ih0| + X′1|1ih1|)H1(|0ih0| + Z′1|1ih1|)H1 and
U2 := (|0ih0| + Z′2|1ih1|)H2(|0ih0| + X′2|1ih1|)H2, where H := |+ih0| + |−ih1| = |0ih+| + |1ih−|.

Hence, we have

8

=

U|ψ′i
1
((I + Z′1)(I + X′2)|ψ′i|0+i + Z′2(I + Z′1)(I − X′2)|ψ′i|0−i
4
+ X′1(I − Z′1)(I + X′2)|ψ′i|1+i + X′1Z′2(I − Z′1)(I − X′2)|ψ′i|1−i).

When |junki :=

√2
4 (I + Z′1)(I + X′2)|ψ′i, we have

=

U|ψ′i − |junki|ψi
1
(Z′2(I + Z′1)(I − X′2)|ψ′i|0−i + X′1(I − Z′1)(I + X′2)|ψ′i|1+i
4
+ (X′1Z′2(I − Z′1)(I − X′2)|ψ′i − (I + Z′1)(I + X′2)|ψ′i)|1−i).

kZ′2(I + Z′1)(I − X′2)|ψ′i|0−ik
=kZ′2(I + Z′1)(I − Z′1)|ψ′i|0−ik + kZ′2(I + Z′1)(Z′1 − X′2)|ψ′i|0−ik
≤2ǫ′5,
kX′1(I − Z′1)(I + X′2)|ψ′i|1+ik
≤kX′1(I − Z′1)(X′2 − Z′1)|ψ′i|1+ik
≤2ǫ′5.

We have

Since

X′1Z′2(I − Z′1)(I − X′2)|ψ′i
=Z′2(I − X′2)X′1(I − Z′1)|ψ′i = Z′2(I − X′2)X′1(I − X′2)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i
=Z′2(I − X′2)(I − X′2)Z′2|ψ′i + Z′2(I − X′2)(I − X′2)(Z′2 − X′1)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i
=2Z′2(I − X′2)Z′2|ψ′i + 2Z′2(I − X′2)(Z′2 − X′1)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i
=2Z′2Z′2(I + X′2)|ψ′i − 2Z′2(Z′2X′2 + X′2Z′2)|ψ′i + 2Z′2(I − X′2)(Z′2 − X′1)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i
=(I + X′2)2|ψ′i − 2Z′2(Z′2X′2 + X′2Z′2)|ψ′i + 2Z′2(I − X′2)(Z′2 − X′1)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i
=(I + X′2)(I + Z′1)|ψ′i) + (I + X′2)(X′2 − Z′1)|ψ′i − 2Z′2(Z′2X′2 + X′2Z′2)|ψ′i

+ 2Z′2(I − X′2)(Z′2 − X′1)|ψ′i + Z′2(I − X′2)X′1(X′2 − Z′1)|ψ′i

we have

Thus,

k(X′1Z′2(I − Z′1)(I − X′2)|ψ′i − (I + Z′1)(I + X′2)|ψ′i)k
≤(2 + 2)ǫ′5 + 2ǫ′1 + 4ǫ′4.

kU|ψ′i − |junki|ψik
1
(2ǫ′5 + 2ǫ′5 + 4ǫ′5 + 2ǫ′1 + 4ǫ′4) =
4

≤

1
2

(4ǫ′5 + ǫ′1 + 2ǫ′4).

(A64)

(A65)

(A66)

(A67)

(A68)

(A69)

(A70)
(A71)
(A72)
(A73)
(A74)
(A75)

(A76)
(A77)
(A78)
(A79)
(A80)

(A81)
(A82)
(A83)

(A84)
(A85)

(A86)

(A87)

So, we obtain (A55). Inequalities (A56)-(A61) can be shown by using the anti-commutation relation and exchanging
X1, Y1, Z1 and X2, Y2, Z2. The the coeﬃcients cj for δ are given by counting the number of these operations.

Now, we show (A62). We have

|junki|ψik

|junki|ψik
|ψ′ik + kU

X1 + Y1√2
Z2 + Y2√2
Z′2 + Y ′2√2
)|ψ′ik +

kU B(0)′1|ψ′i −
=kU B(0)′1|ψ′i −
≤kU B(0)′1|ψ′i − U
Z′2 + Y ′2√2
=k(B(0)′1 −
≤ǫ′7 + √2δ′1.

Z′2 + Y ′2√2
Z′2√2|ψ′i −

Z2 + Y2√2
|ψ′i −
Z2√2|junki|ψik +

1
√2kU

|junki|ψik

1
√2kU

Y ′2√2|ψ′i −

Y2√2|junki|ψik

So, we obtain (A62).
Lemma 5. The local isometries Uj : H′j → Hj for j = 1, 2 satisfy

kU|ψ′i − |junki|ψik ≤ δ′1,
kU X′1|ψ′i − X1|junki|ψik ≤ δ′1,
kU Y ′1|ψ′i − Y1|junki|ψik ≤ δ′1,
kU Z′1|ψ′i − Z1|junki|ψik ≤ δ′1,
kU X′2|ψ′i − X2|junki|ψik ≤ δ′1,
kU Y ′2|ψ′i − Y2|junki|ψik ≤ δ′1,
kU Z′2|ψ′i − Z2|junki|ψik ≤ δ′1,
|junki|ψik ≤ δ′2,

X1 + Y1√2

kU B(0)′1|ψ′i −

for U := U2U1, we have

kU1X′1U†1 − X1k ≤ 2√2δ′1
kU1Y ′1 U†1 − Y1k ≤ 2√2δ′1
kU1Z′1U†1 − Z1k ≤ 2√2δ′1

X1 + Y1√2

k ≤

√2(δ′1 + δ′2).

Proof:

kU1B(0)′1U†1 −

U1X′1U†1|ψi|junki
=U2U1X′1U†1 U†2|junki|ψi
=U2U1X′1U†1 U†2 U2U1|ψ′i + U2U1X′1U†1 U†2 (|junki|ψi − U2U1|ψ′i)
=U2U1X′1|ψ′i + U2U1X′1U†1 U†2 (|junki|ψi − U2U1|ψ′i)
=X1|ψi|junki + (U2U1X′1|ψ′i − X1|junki|ψi) + U2U1X′1U†1 U†2 (|junki|ψi − U2U1|ψ′i).

Hence, we obtain

which implies that

kU1X′1U†1|ψi − X1|ψik ≤ 2δ′1,

kU1X′1U†1 − X1k ≤ 2√2δ′1.

9

(A88)

(A89)

(A90)

(A91)

(A92)

(A93)
(A94)
(A95)
(A96)
(A97)
(A98)
(A99)

(A100)

(A101)

(A102)

(A103)

(A104)

(A105)

(A106)

(A107)

(A108)

(A109)

(A110)

(A111)

(A112)

So, we obtain (A102). Similarly, we obtain other inequalities.

Proof of Proposition 1: Choose δ1 = 2√2δ′1 and δ2 = √2(δ′1 + δ′2) = √2((1 + √2)δ′1 + ǫ′7). Then, combining these

lemmas, we obtain Proposition 1.

10

Appendix B: Error of POVM element: Proof of Inequality (10)

According to [15], we introduce n ideal trusted systems spanned by |0i,|1i although each untrusted system is
spanned by |1i,| − 1i. Let Uj be the unitary on the trusted system. Let Vj be the unitary controlling the j-th
untrusted system by the trusted system, which is deﬁned as follows.
i=1 such that their eigenvalues
In the main text, s = 3 and {D(i)}i = {X, Y, B(0)}. Then, we assume
2 |kihk|Dj(k), where Dj(k) is one of I and {D(i)}i. According to FIG. 7 of [15], we deﬁne

The operators on the untrusted system are restricted to I and s operators {D(i)}s
are 1 or −1 and kU D(i)U† − D(i)k ≤ δ.
Vj has the form Pk∈Fn
Wj := UjVjWj−1, and W0 = U0 and U := U1 ··· Un.
Proposition 2 ([15, Lemma 6] with modiﬁcation). We have

Proof: We have

kU W ′jU† − Wjk ≤ sjδ.

U W ′j U† − Wj = U U′jU†Vj U W ′j−1U† − UjVj Wj−1
=(U U′jU† − Uj)VjU W ′j−1U† + UjVj(U W ′j−1U† − Wj−1).

Due to induction, it is enough to show

kU U′jU† − Ujk ≤ sδ.

We have

For i, we have

U U′jU† − Uj = U Xk∈Fn
Xi=1 Xk∈Fn

2 :Dj (k)=D(i)

s

=

2

|kihk|Dj(k)′U† − Xk∈Fn
|kihk|(U D′(i)U† − D(i))

2

|kihk|Dj(k)

(B1)

(B2)

(B3)

(B4)

(B5)

(B6)

k Xk∈Fn

2 :Dj (k)=D(i)

|kihk|(U D′(i)U† − D(i))k = k Xk∈Fn

2 :Dj (k)=D(i)

|kihk|k · kU D′(i)U† − D(i)k ≤ δ.

(B7)

So, we have (B4).

Assume that our adaptive measurement is given as follows. Once we obtain the measured outcomes k1, . . . , kj−1,
we measure Dj(k1, . . . , kj−1) on the j-th system. To discuss such an adaptive measurement, we set the initial state
|+i⊗n on the trusted system. Choose Uj as the application of the Hadamard operator H on the j-th trusted system.
Then, we deﬁne

Vj := Xk1,...,kj−1

|k1, . . . , kj−1, 0ihk1, . . . , kj−1, 0| + Dj(k1, . . . , kj−1)|k1, . . . , kj−1, 1ihk1, . . . , kj−1, 1|.

Then, we deﬁne the TP-CP map Λ from the untrusted n-qubit system to the trusted n-qubit system as

where Tr UT expresses the partial trace with respect to the untrusted system. Due to the construction, Λ(ρ) is the
same as the output distribution when the above adaptive measurement is applied.

Λ(ρ) := Tr UT Wnρ ⊗ |+ih+|⊗nW †n,

(B8)

Proposition 3 ([15, Corollary 2] with modiﬁcation). For any state ρ, we have

Hence, when Mi is a POVM element of an adaptive measurement, we have

kU Λ′(U†ρU )U† − Λ(ρ)k1 ≤ 2snδ.

kU M′iU† − Mik ≤ max

ρ

Tr (U M′i U† − Mi)ρ ≤ 2snδ,

(B9)

(B10)

which implies inequality (10) of the main text.
Proof: We have

U W ′jU†(ρ ⊗ |+ih+|⊗n)U W ′j†U† − Wj(ρ ⊗ |+ih+|⊗n)W †j
=(U W ′jU† − Wj)(ρ ⊗ |+ih+|⊗n)U W ′j†U† + Wj(ρ ⊗ |+ih+|⊗n)(U W ′j†U† − W †j ).

Also, we have

k(U W ′jU† − Wj)(ρ ⊗ |+ih+|⊗n)U W ′j†U†k1
≤k(U W ′jU† − Wj)kk(ρ ⊗ |+ih+|⊗n)U W ′j†U†k1 = k(U W ′jU† − Wj)k ≤ snδ,
kWj(ρ ⊗ |+ih+|⊗n)(U W ′j†U† − W †j )k1
≤kWj(ρ ⊗ |+ih+|⊗n)k1k(U W ′j†U† − W †j )k
=k(U W ′j†U† − W †j )k ≤ snδ.

Combining (B12), (B14), and (B17), we have

kU Λ′(U†ρU )U† − Λ(ρ)k1 ≤ kU W ′jU†(ρ ⊗ |+ih+|⊗n)U W ′j†U† − Wj (ρ ⊗ |+ih+|⊗n)W †j k1 ≤ 2snδ,

11

(B11)

(B12)

(B13)

(B14)

(B15)

(B16)

(B17)

(B18)

where the ﬁrst inequality follows from the information processing inequality with respect to the trace of the untrusted
system. Hence, we obtain (B9) with s = 3.

Appendix C: Error in the initial state: Proof of inequality (11)

In this section, we show a slightly stronger inequality than inequality (11) of main text:

kU σU† − |GihG|k2

1 ≤ 4nδ +

2c2
m

(C1)

by assuming Inequalities (5)–(9) in Theorem 2.

Now, we have the relation

kU σU† − |GihG|k2

1

(a)

≤ 1 − TrhG|U σU†|Gi = Tr (I − |GihG|)U σU†

(b)

≤ Tr (I − P1)U σU† + Tr (I − P2)U σU†,

(C2)

where (a) follows from the relation between the trace norm and the ﬁdelity [29, (6.106)] and (b) follows from the
inequality I − |GihG| ≤ (I − P1) + (I − P2).
Z. So, we have

We can apply (B10) with s = 2 to Pi because Pi is a POVM element of an adaptive measurement based on X and

|Tr (U (I − P ′i )U† − (I − Pi))U σU†| = |Tr (U P ′i U† − Pi)U σU†| ≤ kU P ′1U† − Pik ≤ 2nδ.

Thus, Inequality (9) in Theorem 2 implies

Tr (I − Pi)U σU† = Tr ((I − Pi) − U (I − P ′i )U†)U σU† + Tr (I − P ′i )σ ≤ 2nδ +

c2
m

.

(C3)

(C4)

The combination of (C2) and (C4) yields (C1).

Appendix D: Self testing with multi-colorable graph

Now, we give a protocol for k-colorable graph state as follows. For each color i = 1, . . . , k, we divide the set Si
of sites with color i into subsets Si,1, . . . , Si,li such that there is no common neighborhood with non-i color for each
subset Si,j. Then, as a generalization of B-protocol, we propose the i-protocol with the subset Si,j as follows.

(3-1): We prepare 17m states |G′i.

(3-2): We measure Z′ on all sites of Si \ Si,j for all copies. Then, we apply Z′ operators on the remaining sites to

correct applied Z′ operators dependently of the outcomes.

(3-3): For all a ∈ Si,j, we choose a site ba ∈ Na. Then, we measure Z′ on all sites of SW \ {ba}a∈Si,j for all copies.
Then, we apply Z′ operators on the remaining sites to correct applied Z′ operators dependently of the outcomes.
(3-4): Due to the above steps, the resultant state should be ⊗a∈Si,j|Φ′iaba . Then, we apply the above self-testing

procedure to all of {|Φ′iaba}a∈Si,j .

The above protocol veriﬁes the measurement device on sites with i-th color. Then, applying this generalization to all
colors in the protocol, we can extend the ﬁrst part.

12

To realize the second part, for each color i, we measure non-i color sites with Z basis and check whether the
outcome of measurement X on the sites with color i is the same as the predicted one. Then, we denote the projection
i=1 Qi = |GihG| because only the state |Gi
can pass all of these tests. Thus, applying this test for all colors, we can test whether the state is the desired graph
state.

corresponding to the passing event for this test by Qi. Hence, we have Qk
Then, choosing c3 to be 16(k +Pk
(4-1): We prepare c3m + 1 states |G′i.
(4-2): We randomly divide c3m + 1 blocks into k + c3 + 1 groups. The ﬁrst c3 groups are composed of m blocks and

i=1 li), we propose our self-testing protocol as follows,

the ﬁnal group is composed of a single block. Each block contains n qubits.

(4-3): For the ﬁrst k groups, we apply the following test. For the i-th group, we measure Z′ on the sites with
non-i color and X′ on the sites with i-th color, and check that the outcome of X′ measurements is the same as
predicted from the outcomes of Z′ measurements.

(4-4): We run the i-protocol with Si,j for the k + 16(Pi−1

i′=1 li′) + 16j-th groups.
Notice that the ﬁrst condition in Step (2-5) has been done in Step (4-3), we check only 16 remaining conditions
in Step (2-5). We repeat this protocol for j = 1, . . . , li and i = 1, . . . , k.

i′=1 li′ ) + 16(j − 1) + 1-th -k + 16(Pi−1

When we employ the above protocol for k-colorable case, the diﬀerence from the 2-colorable case is only the number

of samples. we have the same analysis for the certiﬁcation of computation result as the 2-colorable case.

Appendix E: Relaxation of the non-conﬂict condition for two-colorable graph

Now, we relax our condition for two-colorable graph. We deﬁne a nB × nW binary symmetric matrix A = (ai,j )
called the graph matrix such that ai,j is 1 when the site i and j is connected, and it is zero otherwise. Generally,
this matrix A is not full rank. We divide the sites SB = {1, . . . , nB} into LB subsets TB,1, . . . , TB,LB such that the
rank of the restricted matrix A to sites in TB,k is |TB,k|, i.e., row vectors of A whose index belong to TB,k are linearly
independent. We choose the number LB as the minimum number satisfying this condition. We have that LB < lB
which means that even when lB is not bounded, there is a possibility that LB is. We also deﬁne the number LW for
the white sites in the same way.

We can deﬁne B-protocol even for TB,k. To get the intuition for extended B-protocol for TB,k, we choose a suitable
coordinate conversion acting only on the white sites so that the graph matrix on TB,k is the identity matrix. Hence,
the problem is reduced to the tensor product of |TB,k| two-qubit states.
In this case, the local measurements of
X, Y , and Z on the new coordinate in the white sites can be realized by a combination of the local measurements
on the original coordinate in the white sites and a linear data processing of their outcomes. Hence, B-protocol for
TB,k is given as our self-testing of measurements based on two-qubit entangled state for all sites of TB,k. After the
application of this coordinate conversion, it becomes impossible to measure a superposition of X, Y , and Z on the
white qubits. Hence, the requirement (1-3) in main text is essential for this extension. McKague et al [25] already
gave a self-testing protocol for the Bell state. However, their protocol does not satisfy the requirement (1-3) whereas
our self-testing protocol for two-qubits can even be used for the subset TB,k.

Appendix F: General property for two-colorable graph state

To deﬁne extended B-protocol for TB,k, we need several properties for two-colorable graph states. Assume that we
have two colors B and W . We also assume the following, the system B has sites 1, . . . , nB and the system W has
sites 1, . . . , nW .

For an invertible nB × nB matrix C, we deﬁne the unitary operator UC,Z,B as

UC,Z,B := Xz∈F

nB
2

|CziB Bhz|.

13

(F1)

Using the X basis states |xiX,B and the Y basis states |yiY,B, we deﬁne the unitary operators UC,X,B and UC,Y,B as
(F2)

UC,X,B := Xx∈F
UC,Y,B := Xy∈F

nB
2

nB
2

|CxiX,B X,Bhx|

|CyiY,B Y,Bhy|.

(F3)

(F4)

(F5)

(F6)

(F7)

(F8)

(F9)

(F10)

(F11)

(F12)

(F13)

(F14)

(F15)

Also, we deﬁne the vector 1 := (1, . . . , 1).

Similarly, we can deﬁne UD,X,W , UD,Y,W , and UD,Z,W for an invertible nW × nW matrix D.

Lemma 6. Then, for an invertible matrix C, we have the relation

When (C−1)T 1 = 1, we have the relation

UC,X,B = U(C−1)T ,Z,B,

UC,Z,B = U(C−1)T ,Y,B,

Notice that the condition (C−1)T 1 = 1 is equivalent to CT 1 = 1 because (C−1)T = (CT )−1.

Proof: We have

nB
2

nB
2

nB
2

=

=

1

1

1

UC,X,B|ziB
2nB /2 Xx∈F
=
2nB /2 Xx∈F
2nB /2 Xx′∈F
which implies (F4). Notice that |yiY,B = 1
UC,Z,B|ziB
2nB/2 Xz ′∈F
2nB/2 Xz∈F
2nB/2 Xz∈F
2nB/2 Xz∈F
2nB/2 Xz∈F

nB
2

nB
2

nB
2

nB
2

1

1

1

1

=

=

=

=

=

1

(−1)x′·z|xiB

|CxiX,B X,Bhx| Xx′∈F
(−1)x·z|CxiX,B

nB
2

(−1)C−1x′·z|x′iX,B = |(C−1)T ziB,

2nB /2 Pz(−1)y·zi1·z|ziZ,B. Then,

(−1)y·zi1·z|ziZ,B

nB
2

|Cz′iZ,B Z,Bhz′|Xz
(−1)y·zi1·z|CziX,B

(−1)y·C−1zi1·C−1z|ziX,B

(−1)(C−1)T y·C−1zi(C−1)T 1·z|ziX,B

(−1)(C−1)T y·C−1zi1·z|ziX,B.

Next, given the graph state |Gi, we deﬁne the nB × nW matrix A = (ai,j) as follows. When the site j of W is

connected to the site i of B, ai,j is 1. Otherwise, ai,j is zero. Then, we have

14

|G; Ai =

1

2nW /2 Xz∈F

nW
2

|AziX,B|ziW .

Then, when we measure W with the Z basis and obtain the outcome z, we obtain Az with the X measurement on
B. Then, we have

|G; Ai =

because any vector z′ ∈ FnB

2

satisﬁes

1

2nB /2 Xz∈F

nB
2

|ziX,B|AT ziW

Bhz′|Gi
1
2nB /2 Xx∈F
2nB /2 (−1)Az·z ′

nB
2

1

X,Bhx|(−1)x·z ′
2nW /2 Xz∈F

1

nW
2

1

2nB /2|AT z′iX,W .

=

=

=

|AziX,B|ziW

1

2nW /2 Xz∈F
|ziW

nW
2

We also have

UC,X,B|G; Ai = |G; CAi,
UD−1,Z,W|G; Ai = |G; ADi,

(F16)

(F17)

(F18)

(F19)

(F20)

(F21)
(F22)

Now, we denote the outcome on B with the basis X by XB. We denote the outcome on B with the basis Z by ZB.
We denote the outcome on B with the basis Y by YB. We denote the outcome on W with the basis X by XW . We
denote the outcome on W with the basis Z by ZW . We denote the outcome on Y with the basis Y by YW . Then, we
have the relations

XB = AZW , Z T

BA = X T
W .

(F23)

Appendix G: Extended B-protocol

In this section, we give the extended B-protocol for TB,j with m rounds, which checks the measurement on the

black sites.

Let k be the rank of the matrix A. Let k′ be the cardinality of TB,j. Adding k− k′ elements from {1, . . . , nB}\ TB,j
are linear independent and the cardinality of ˆSB,j is k. Without

to TB,j, we deﬁne the set ˆSB,j such that {ai}i∈ ˆSB,j
loss of generality, we assume that TB,j = {1, . . . , k′} and ˆSB,j = {1, . . . , k}.

So, there exists an invertible nW × nW matrix D such that AD has the following form.

A = (cid:18) Ik 0

∗ 0 (cid:19) D.

(G1)

We deﬁne ˆA := AD−1.

Eq. (G1) does not depend on the choice of the 1-st ...,nW -th row vectors of D. So, we choose an invertible matrix

D satisfying (G1) such that DT 1 = 1. So, we have

XB = (cid:18) Ik 0

∗ 0 (cid:19) DZW = (cid:18) Ik 0

∗ 0 (cid:19) ˆZW ,

(G2)

where ˆZW := DZW . Hence, UD,Z,W|G; Ai = |G; AD−1i = |G; ˆAi.

Now, we introduce another nW sites 1, . . . , nW on the side W by applying UD,Z,W . We denote the measurement

outcomes on these sites by ˆXW,j , ˆYW,j, ˆZW,j, which satisﬁes

ˆZW,j = (DZW )j,

ˆXW,j = (DT −1

XW )j,

ˆYW,j = (DT −1

YW )j.

(G3)

Now, we assume that the true state is UD,Z,W|G; Ai = |G; AD−1i = |G; ˆAi. Once we observe ZB,k+1, . . . , ZB,nB ,

the resultant state is

15

⊗k

i=1

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

|G; Iki = ⊗k

i=1X

nB
j=k+1 ˆaj,iZB,j

P
B,i

|G; Iki

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

|G; Iki = ⊗k

i=1

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

XB,i′ ˆZW,i′|G; Iki = ⊗k

i=1

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB

|G; Iki = (−1)P
= (−1)P
|G; Iki = (−1)P
= (−1)P

nB

j=k+1 ˆaj,i′ ZB,j ⊗k
j=k+1 ˆaj,i′ ZB,j ⊗k
j=k+1 ˆaj,i′ ZB,j ⊗k
j=k+1 ˆaj,i′ ZB,j ⊗k

nB

nB

i=1

i=1

i=1

i=1

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

nB
j=k+1 ˆaj,iZB,j

ˆZ

P
W,i

ZB,i′ ˆXW,i′|G; Iki
|G; Iki,
YB,i′ ˆYW,i′|G; Iki
|G; Iki,

(G4)

|G; Iki,

(G5)

(G6)

(G7)

(G8)

(G9)

Since

XB,i′ ˆZW,i′ ⊗k

i=1

ZB,i′ ˆXW,i′ ⊗k

i=1

YB,i′ ˆYW,i′ ⊗k

i=1

we have

XB,i = ˆZW,i, ZB,i = ˆXW,i +

nB

Xj=k+1

ˆaj,iZB,j,

YB,i = ˆYW,i +

nB

Xj=k+1

ˆaj,iZB,j

(G10)

for i = 1, . . . , k, where ˆaj,i is the matrix entries of A. That is, we have

XB,i = (DZW )i, ZB,i = (DT −1

XW )i +

nB

Xj=k+1

ˆaj,iZB,j,

YB,i = (DT −1

YW )i +

nB

Xj=k+1

ˆaj,iZB,j.

(G11)

Based on these relations, we deﬁne

AB,i(0) :=

AB,i(1) :=

BB,i(0) :=

BB,i(1) :=

CB,i(0) :=

CB,i(1) :=

X

z=(zk+1,...,znB )∈F

X

z=(zk+1,...,znB )∈F

X

z=(zk+1,...,znB )∈F

z=(zk+1,...,znB )∈F

z=(zk+1,...,znB )∈F

X
X
X

z=(zk+1,...,znB )∈F

nB

Ai(

Xj=k+1

ˆaj,izj) ⊗ |zihz|

Ai(1 +

nB

Xj=k+1

ˆaj,izj) ⊗ |zihz|

nB

Bi(

Xj=k+1

ˆaj,izj) ⊗ |zihz|

nB

Bi(1 +

(−1)P

ˆaj,izj) ⊗ |zihz|

Xj=k+1
j=k+1 ˆaj,izj Ci(0) ⊗ |zihz|

nB

nB

(−1)P

j=k+1 ˆaj,izj Ci(1) ⊗ |zihz|.

nB −k
2

nB −k
2

nB −k
2

nB −k
2

nB −k
2

nB −k
2

(G12)

(G13)

(G14)

(G15)

(G16)

(G17)

B-Protocol with m rounds.

B1: The CHSH test: We measure T ′B,i,1 := ˆX′W,iAB,i(0)′ + ˆZ′W,iAB,i(0)′− ˆX′W,iAB,i(0)′+ ˆZ′W,iAB,i(1)′ for i = 1, . . . , k′.

We repeat them m times. We denote the observed sample mean by TB,i,1.

B2: The CHSH test: We measure T ′B,i,2 := ˆZ′W,iBB,i(0)′ + ˆY ′W,iBB,i(0)′ + ˆZ′W,iBB,i(1)′− ˆY ′W,iBB,i(1)′ for i = 1, . . . , k′.

We repeat them m times. We denote the observed sample mean by TB,i,2.

B3: The CHSH test: We measure T ′B,i,3 := ˆY ′W,iCB,i(0)′ + ˆX′W,iCB,i(0)′ + ˆY ′W,iCB,i(1)′− ˆX′W,iCB,i(1)′ for i = 1, . . . , k′.

We repeat them m times. We denote the observed sample mean by TB,i,3.

16

B4: Test: We measure T ′B,i,4 := Y ′B,i

deﬁne the random variable TB,i,4 to be 1 when it is passed. Otherwise, we deﬁne it to be 0.

ˆY ′W,i for i = 1, . . . , k′. We repeat them m times. We check that they are −1. We

B5: Test: We measure T ′B,i,5 := X′B,i

ˆZ′W,i for i = 1, . . . , k′. We repeat them m times. We check that they are 1. We

deﬁne the random variable TB,i,5 to be 1 when it is passed. Otherwise, we deﬁne it to be 0.

B6: Test: We measure T ′B,i,6 := Z′B,i

ˆX′W,i for i = 1, . . . , k′. We repeat them m times. We check that they are 1. We

deﬁne the random variable TB,i,6 to be 1 when it is passed. Otherwise, we deﬁne it to be 0.

B7: We measure T ′B,i,7 := ˆZ′W,iBB,i(0)′ + ˆY ′W,iBB,i(0)′ for i = 1, . . . , k′. We repeat them m times. We denote the

observed sample mean by TB,i,7.

B8: We measure T ′B,i,8 := X′B,i

sample mean by TB,i,8.

ˆY ′W,i + Y ′B,i

ˆZ′W,i for i = 1, . . . , k′. We repeat them m times. We denote the observed

Since Steps B5 and B6 have been done by Steps (3-3) and (3-4) of the main protocol, we do not need this step.
B7 has been already done during B2. Hence, totally, we need (4 + 4 + 4 + 1 + 2)m = 15m samples for B-protocol for
TB,j.

Similarly, we can deﬁne W-protocol.

[1] P. W. Shor, in Foundations of Computer Science, 1994 Proceedings., 35th Annual Symposium on (IEEE, 1994) pp. 124–134.
[2] S. Lloyd, Science 273, 1173 (1996).
[3] T. P. Harty, D. T. C. Allcock, C. J. Ballance, L. Guidoni, H. A. Janacek, N. M. Linke, D. N. Stacey, and D. M. Lucas,

Phys. Rev. Lett. 113, 220501 (2014).

[4] R. Barends, J. Kelly, A. Megrant, A. Veitia, D. Sank, E. Jeﬀrey, T. C. White, J. Mutus, A. G. Fowler, B. Campbell,
Y. Chen, Z. Chen, B. Chiaro, A. Dunsworth, C. Neill, P. O’Malley, P. Roushan, A. Vainsencher, J. Wenner, A. N.
Korotkov, A. N. Clelan, and J. A. Martinis, Nature 508, 500 (2014).

[5] S. Aaronson, in Proceedings of the forty-second ACM symposium on Theory of computing (ACM, 2010) pp. 141–150.
[6] M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information (Cambridge University Press, 2000).
[7] R. Raussendorf and H. J. Briegel, Phys. Rev. Lett. 86, 5188 (2001).
[8] V. Danos and E. Kasheﬁ, in Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL

2005), Vol. 170 (2007) pp. 95–100.

[9] A. Broadbent, J. F. Fitzsimons, and E. Kasheﬁ, in Foundations of Computer Science, 2009. FOCS’09. 50th Annual IEEE

Symposium on (IEEE, 2009) pp. 517–526.

[10] J. F. Fitzsimons and E. Kasheﬁ, “Unconditionally veriﬁable blind computation,” (2012), arXiv:quant-ph/1203.5217.
[11] T. Morimae and K. Fujii, Phys. Rev. A 87, 050301 (2013).
[12] M. Hayashi and T. Morimae, Phys. Rev. Lett. 115, 220502 (2015).
[13] T. Morimae, Phys. Rev. A 89, 060302 (2014).
[14] M. Hajduˇsek, C. A. P´erez-Delgado, and J. F. Fitzsimons, (2015), arXiv:quant-ph/1502.02563.
[15] M. McKague, “Interactive proofs for BQP via self-tested graph states,” (2013), arXiv:quant-ph/1309.5675.
[16] S. Barz, E. Kasheﬁ, A. Broadbent, J. F. Fitzsimons, A. Zeilinger, and P. Walther, Science 335, 303 (2012).
[17] S. Barz, J. F. Fitzsimons, E. Kasheﬁ, and P. Walther, Nature Physics 9, 727 (2013).
[18] C. Greganti, M.-C. Roehsner, S. Barz, T. Morimae, and P. Walther, New J. Phys. 18, 013020 (2016).
[19] B. W. Reichardt, F. Unger, and U. Vazirani, Nature 496, 456 (2013).
[20] A. Gheorghiu, E. Kasheﬁ, and P. Wallden, New J. Phys. 17, 083040 (2015).
[21] J. F. Fitzsimons and M. Hajduˇsek, “Post hoc veriﬁcation of quantum computation,” (2015), arXiv:quant-ph/1512.04375.
[22] D. Hangleiter, M. Kliesch, M. Schwarz, and J. Eisert, “Direct certiﬁcation of a class of quantum simulations,” (2016),

arXiv:quant-ph/1602.00703.

[23] D. Mayers and A. Yao, in Foundations of Computer Science, 1998. Proceedings. 39th Annual Symposium on (IEEE, 1998)

pp. 503–509.

[24] D. Mayers and A. Yao, Quantum Inf. Comput. 4, 273 (2004).
[25] M. McKague, T. H. Yang, and V. Scarani, J. Phys. A: Math. Theor. 45, 455304 (2012).
[26] M. McKague, “Self-testing graph states,” in Theory of Quantum Computation, Communication, and Cryptography: 6th

Conference, TQC 2011 (Springer Berlin Heidelberg, 2014) pp. 104–120.

[27] J. F. Clauser, M. A. Horne, A. Shimony, and R. A. Holt, Phys. Rev. Lett. 23, 880 (1969).
[28] E. L. Lehmann and J. P. Romano, Testing Statistical Hypotheses (Springer-VerlagNew York, 2008).
[29] M. Hayashi, S. Ishizaka, A. Kawachi, G. Kimura, and T. Ogawa, Introduction to Quantum Information (Springer-Verlag

Berlin Heidelberg, 2008).

17

