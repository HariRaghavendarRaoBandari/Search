6
1
0
2

 
r
a

 

M
7
1

 
 
]

C
D
.
s
c
[
 
 

1
v
9
5
4
5
0

.

3
0
6
1
:
v
i
X
r
a

Counting in Practical Anonymous Dynamic

Networks is Polynomial

Maitri Chakraborty1, Alessia Milani2, and Miguel A. Mosteiro1

1 Kean University, Union, NJ, USA,

{chakrabm,mmosteir}@kean.edu

2 LABRI, University of Bordeaux, INP, Talence, France,

milani@labri.fr

Abstract. Anonymous Dynamic Networks is a harsh computational en-
vironment due to changing topology and lack of identiﬁers. Computing
the size of the network, a problem known as Counting, is particularly
challenging because messages received cannot be tagged to a speciﬁc
sender. Previous works on Counting in Anonymous Dynamic Networks
do not provide enough guarantees to be used in practice. Indeed, they
either compute only an upper bound on the network size that may be as
bad as exponential, or guarantee only double-exponential running time,
or do not terminate, or guarantee only eventual termination without
running-time guarantees. Faster experimental protocols do not guaran-
tee the correct count.
Recently, we presented the ﬁrst Counting protocol that computes the
exact count with exponential running-time guarantees. The protocol re-
quires the presence of one leader node and knowledge of any upper bound
∆ on the maximum number of neighbors that any node will ever have.
In the present work, we complement the latter theoretical study evalu-
ating the performance of such protocol in practice. We tested a variety
of network topologies that may appear in practice, including extremal
cases such as trees, paths, and continuously changing topologies. We
also tested networks that temporarily are not connected. Our simula-
tions showed that the protocol is polynomial for all the inputs tested,
paving the way to use it in practical applications where topology changes
are predictable. The simulations also provided insight on the impact of
topology changes on information dissemination.
To the best of our knowledge, this is the ﬁrst experimental study that
shows the possibility of computing the exact count in polynomial time in
a variety of Anonymous Dynamic Networks that are worse than expected
in practice.

Keywords: anonymous dynamic networks, counting, time-varying graphs.

We thank David Joiner for assisting us in using the Kean Terascale Cluster (KTC)
for our simulations.

1

Introduction

Recently, a restrictive Anonymous Dynamic Network model where node iden-
tiﬁers are not available and topology changes frequently has attracted a lot of
attention. With respect to topology changes, the Anonymous Dynamic Network
model is well motivated by mobility and unreliable communication environments.
With respect to node identiﬁers, although they are usually available in present
networks (or labels3 are deﬁned at startup), in future massive networks it may
be necessary or at least convenient to avoid them to facilitate mass production.
In particular, the seemingly simple problem of Counting the number of nodes
is challenging in Anonymous Dynamic Networks. Indeed, when two nodes com-
municate, it is not known whether they have communicated previously or not,
which makes diﬃcult to count. However, Counting is a fundamental problem in
distributed computing because the network size is used to decide termination of
protocols.

The literature on Counting in Anonymous Dynamic Networks (cf. [5–7, 12,
13]) focuses on distributed protocols for broadcast networks in slotted-time sce-
narios, assuming adversarially that topology may change completely all the time.
Fruitful results obtained so far showed that Counting is feasible in Anonymous
Dynamic Networks, paving the way to understand the cost of anonymity in Dy-
namic Networks, but it is still not known whether those protocols are practical.
Indeed, the protocol in [12] computes only an upper bound on the network size
that may be as bad as exponential. The protocols in [5] compute the exact count,
but one guarantees only double-exponential running time and the other, called
unconscious, does not terminate. Another protocol [6] is shown to have eventual
termination, but without running-time guarantees.

On the practical side, in [7] the unconscious protocol [5] is augmented with
a termination heuristic that allows the leader to decide when to stop. They
show experimentally that the algorithm converges to a decision in a number
of rounds that is linear in the size of the system. Unfortunately, it ensures a
correct count only on dense graphs. In the worst case this approach could yield
an arbitrarily wrong estimate, yielding a wrong overall count (“... however, the
error rate becomes high when we consider sparse and extremely disconnected
graph instances or regular topologies.” [7]).

Recently, we presented the ﬁrst Counting protocol that computes the exact
count with exponential running-time guarantees in [13]. The protocol, called
Incremental Counting, achieves a speedup over its predecessors by trying
candidate sizes incrementally. The analysis of Incremental Counting in [13]
also exposed the bottleneck for further speedup. Indeed, Incremental Count-
ing and previous protocols include a collection phase where nodes disseminate
some value in a gossip-based fashion. Under adversarial topology changes, the
best theoretical upper bound known for such collection is exponential, whereas
the only lower bound known is the trivial lower bound for dissemination, i.e.
the dynamic diameter. Moreover, even restricting to gossip-based protocols, it

3 Throughout, we use “identiﬁers” or “labels” indistinctively.

is not known if there exist adversarial topologies such that collection requires
exponential time. Thus, whether the protocol performs better than exponential
in practice is an important question.

In the present work, we complement the theoretical study in [13] evaluat-
ing thoroughly the performance of Incremental Counting in practice. We
tested a variety of network topologies that may appear in practice, including
random, best case, and worst case. In particular, we tested (1) tree topologies
carefully drawn uniformly at random from the equivalence classes deﬁned by
isomorphisms, (2) star topologies, and (3) path topologies. The simulations pa-
rameters include the size of the network n, an upper bound on the number
of neighboring nodes ∆, and the period of time without topology changes T ,
including the extremal cases when topology changes continuously and a static
topology. We also tested (4) dynamic networks with random graph topologies
that may be disconnected, which are relevant given that previous works [7] do
not guarantee the correct answer under disconnection.

It should be noticed that, for the purpose of dissemination in this model, tree
inputs are intuitively worse than graphs, the worst case being a path. In that
sense, our experimental evaluation is more challenging for the algorithm than
previous works [7] where the inputs considered were various versions of random
graphs that are unlikely to be trees.

For all the topologies and parameter combinations evaluated, Incremen-
tal Counting has proven to be polynomial in our simulations. These results
motivate the application of Incremental Counting to practical Anonymous
Dynamic Networks. Indeed, our simulations show that, for the inputs tested,
∆n4 is a loose upper bound on the running time of Incremental Counting.
Hence, for applications where the input behavior is similar (and again we em-
phasize that we have used inputs that are bad for Incremental Counting),
the collection phase of Incremental Counting may be stopped after ∆k4
iterations, where k is the size estimate, to obtain a protocol that can be used in
practice (refer to [13] for details).

Our simulations also provide insight on the impact of network dynamics in
the dissemination of information by gossip-based protocols. Indeed, our results
showed that, on average, network changes speed up the computation, as long
as those changes are uniform throughout the network. That is, highly dynamic
topologies help rather than being a challenge as in worst-case theoretical analy-
ses.

The rest of the paper is organized as follows. After formally deﬁning the
model and the problem in Section 2, we detail the changes introduced into In-
cremental Counting to run our simulations in Section 3. The input topologies
tested and the simulation platform used are presented in Sections 4 and 5. Fi-
nally, we discuss the results obtained and our conclusions in Section 6. Beyond
the overview of previous work on Counting included above and the references
therein, other related work may be found in a survey on Dynamic Networks and
Time-varying Graphs by Casteigts et al. [3].

2 The Anonymous Dynamic Network Model and the

Counting Problem

The Anonymous Dynamic Network model is deﬁned as follows. We consider a
network composed by a set V of n nodes. For reference, we deﬁne node labels
{1, 2, . . . , n}. However, nodes do not have identiﬁers or labels that may be used
in the computation. That is, nodes cannot be distinguished, except for one node ℓ
that is called the leader. As shown in [12], Counting is not solvable in Anonymous
Networks without the presence of a leader, even if the topology does not change.
If a given pair of nodes i, j ∈ V is able to communicate directly, we say that
there is a link among them, and we say that i and j are neighbors.

The communication proceeds in synchronous rounds through broadcast in
symmetric links. That is, at each round, a node i broadcasts a message to its
neighbors and simultaneously receives the messages broadcast in the same round
by all its neighbors. Then, each node makes some local computation (if any).

As customary in the Anonymous Dynamic Networks literature, we assume
that the time taken by computations is negligible with respect to communication.
Thus, to evaluate performance, we count the number of communication rounds
to complete the computation.

The set of links among nodes at round r is denoted as E(r). For any given
node i, we denote the set of neighbors of i at round r as N (i, E(r)). If the
particular round is clear from context we will refer to the set of neighbors simply
as N (i, E) or N (i) indistinctively. We assume that there is an upper bound on
the size of the neighborhood of any node that is known to all nodes. That is, there
is a value ∆ ≤ n − 1 that may be used by the protocol such that, for any round
r and any node i ∈ V , it is N (i, E(r)) ≤ ∆. Indeed, ∆ is used in Incremental
Counting as described in Section 3. Other than the upper bound ∆, nodes do
not have any other information of the network topology and/or dynamics. Thus,
Incremental Counting does not use any other information.

Previous work [5, 13] also assume knowledge of this upper bound on the
neighborhood. This is because it was conjectured in [12] that any non-trivial
computation is impossible without knowledge of some network characteristics.
This conjecture has been recently disproved [4]. On the other hand, the algorithm
used to prove the result has exponential time and space complexity.

The set of links is dynamic. That is, they may change from one round to
another. In [5, 12, 13], Counting protocols have been analyzed assuming that in
each round a new set of links may be chosen adversarially, as long as the network
is connected.This model was presented in [10] as 1-interval connectivity model.
Our simulations showed that if a new set of links is chosen uniformly at random
for each round, the dissemination of information towards the leader is indeed
faster than if changes are less frequent. Hence, for our simulations we generalize
the connectivity model assumed in [5,12,13] as follows. We say that the network
is T -stable if, after a topology change, the set of links does not change for at
least T rounds. More formally, for any pair of rounds ri, rj such that 0 < ri < rj ,
E(ri) 6= E(rj ), and for any ri ≤ rk < rj it is E(ri) = E(rk), then rj − ri ≥ T . In

contrast, in T -interval connected networks it is assumed that for any sequence
of T rounds, there is a stable set of links spanning all nodes.

Notice that for connected networks both models are the same for T = 1, but
for T > 1 on tree topologies (most of our inputs), T -stable networks restrict
less the adversary than T -interval connectivity networks. Indeed, if the topology
is always a tree, which is a worst case scenario for dissemination, T -interval
connectivity enforces a static network, whereas T -stability allows to change the
tree every T rounds. In this work, we study T -stable networks and we evaluate
a range of values for T , from T = 1 up to a static network.

We complete the section with the deﬁnition of the problem in [13]: “An
algorithm is said to solve the Counting problem if whenever it is executed in
a Dynamic Network comprising n nodes, all nodes eventually terminate and
output n.”

3

Incremental Counting Protocol Simulator

Incremental Counting [13] is a distributed protocol that relies on the pres-
ence of a leader node. Thus, the protocol includes algorithms for the leader and
non-leader nodes. Both algorithms are composed by a sequence of synchronous
iterations. In each iteration the candidate size is incremented and checked to
decide whether it is correct or not.

Each of the iterations in Incremental Counting is divided in three phases:
collection, veriﬁcation, and notiﬁcation. In the collection phase, nodes are ini-
tially assigned a unit value, called energy. Then, iteratively nodes disseminate
a fraction of their energy towards the leader. The collection phase terminates
when the leader has collected enough energy to know that if the current guess
of the system size is correct, then there is no node in the system with residual
energy greater than a given threshold. In the veriﬁcation phase, nodes inform the
leader whether some node has energy above the threshold, which would mean
that the candidate size is wrong. Should the candidate size be correct, in the
last phase all nodes are notiﬁed that the computation is complete. Each of these
phases is composed by a ﬁxed number of communication rounds so that the
synchronization of the distributed computation is given. The number of rounds
of each phase is a function of the candidate size.

Incremental Counting runs for a ﬁxed number of rounds for each phase.
Given that the upper bound on the number of rounds needed for each phase
proved in [13] is exponential, a simulation of Incremental Counting as in [13]
would yield exponential time. The purpose of our simulations in the present work
is to evaluate whether such upper bound is loose in practice. So, rather than run-
ning each phase for a ﬁxed number of communication rounds, we do it until a
condition suited for each phase is violated (cf. Algorithm 1), and we count the
number of communication rounds to complete the computation. Consequently,
our simulator is necessarily centralized to check such condition, but again, these
changes are introduced to obtain experimentally a tighter upper bound on prac-
tical inputs, rather than to provide a practical implementation of Incremental

Counting. As explained before, a practical distributed Incremental Count-
ing protocol must be implemented as in [13], that is, executing each phase for
a ﬁxed number of rounds, but our simulations provide a polynomial bound on
that number.

In the following paragraphs, we provide further details on the changes applied
to each phase of Incremental Counting, and how each phase is implemented
in our simulator.

During the collection phase of Incremental Counting non-leader nodes
are initially assigned a unit of energy, which is later disseminated towards the
leader using a gossip-based approach [1, 8, 9]. That is, each non-leader node re-
peatedly shares a fraction of its energy with each neighbor. Given that the leader
keeps all the energy received, it eventually collects most of the energy in the sys-
tem. In the original Incremental Counting protocol, for each candidate size
k, the number of rounds for sharing energy is ﬁxed to a function τ (k) that has
not be proven to be sub-exponential in the worst case. Thus, to evaluate whether
in practice a polynomial number of rounds is enough, in our simulations we it-
erate the energy transfer until the conditions needed for the veriﬁcation phase
are met. (Refer to Lines 4 to 9 in Algorithm 1.) That is, until the leader has
collected an amount of energy such that, if its guess is correct, non-leader nodes
have transferred almost all their energy, i.e. all non-leader nodes have residual
energy smaller than or equal to 1/k1.01.

In the Anonymous Dynamic Network model communication is carried out in
rounds. In each round, every node receives from each neighboring node simulta-
neously. To simulate this exchange in the collection phase we follow the approach
used to analyze gossip-based protocols [1,8,9]. That is, the energy sharing process
is simulated by a multiplication of the vector of energies by a matrix of fractions
shared. More precisely, we maintain a vector er = (cid:0)er1, er2, . . . , ern(cid:1) of energies,
where eri is the energy of node i at the beginning of round r. Additionally, for
each input graph with set of links E(r), we deﬁne a matrix F(E(r)) = (cid:0)fij(cid:1),
where fij is the fraction of energy of node j that node i receives. We will refer to
this matrix as F(E) when the round number is clear from context. For example,
for a complete graph with set of links E where node 1 is the leader it is

F(E) =





1

1

2∆

1
0 1 − n−1
2∆
0
0
...

2∆

2∆

...

1

1 − n−1
2∆

1

2∆

1

2∆

1

2∆

...

. . .
. . .
. . .
2∆ . . .
. . .





(1)

1 − n−1

1

2∆

1

2∆

1

2∆

...

Then, the energy of nodes is iteratively computed as er+1 = F · er
the matrix F has to be changed each time the input graph changes.

T . Notice that

During the veriﬁcation phase of Incremental Counting non-leader nodes
disseminate towards the leader the value of the maximum energy held by any
non-leader node. If the residual energy of some node is greater than the above
threshold, the current candidate size is deemed incorrect by the leader. To guar-
antee that the leader receives from all nodes, all non-leader nodes iteratively

broadcast and update the maximum energy heard, starting from their own. This
phase does not tolerate disconnection of the network, since then some nodes
might not be heard by the end of the loop. To evaluate disconnected topologies,
in our simulations we continue the iteration until the leader has received from
all nodes. (Refer to Lines 10 to 24 in Algorithm 1.)

If the candidate size was found to be correct in the veriﬁcation phase, a halt-
ing message is broadcast throughout the network in the notiﬁcation phase. To
synchronize the computation, the notiﬁcation phase of Incremental Count-
ing runs for a ﬁxed number of rounds, independently of whether the current
candidate size is correct or not. As with the veriﬁcation phase, the notiﬁcation
phase does not tolerate disconnection of the network. To evaluate disconnected
topologies, in our simulations we continue the iteration also for the notiﬁcation
phase, in this case until all nodes receive from the leader. (Refer to Lines 25
to 37 in Algorithm 1.)

To handle disconnection, the approach followed in the latter two phases is
centralized. Nevertheless, the running times obtained are not better than in
Incremental Counting, since the veriﬁcation and notiﬁcation phases run for
at least the same number of rounds.

In our simulations the synchronization and bookkeeping are centralized rather
than distributed, and nodes are assigned labels for reference. Nevertheless, the
running times obtained may be used to ﬁx the number of rounds needed to run
the protocol distributedly in a practical Anonymous Dynamic Network, should
the input behavior be known.

4

Input Topologies

To thoroughly evaluate the performance of Incremental Counting, we have
produced diﬀerent topologies that may appear in practice. The parameters of our
simulations include the size of the network n, the upper bound on the number
of neighbors ∆, and the period of stable topology T .

We evaluate random tree topologies rooted at the leader node, drawn uni-
formly as described below. As extremal cases of a tree topology, we also evaluated
a star rooted at the leader node and a path where the leader is the end point.
We also consider Erdos-Renyi random graphs, for which we additionally param-
eterize the probability p that any given pair of nodes are neighbors. Although
graphs have better conductance than the trees underlying them, and conse-
quently graphs achieve convergence faster for gossip-based protocols [15], we
evaluate the latter inputs for consistency with previous works. Random graphs
may be disconnected, but in our simulator Incremental Counting has been
modiﬁed to handle disconnected components. (Refer to Section 3 for details.)

We evaluated the performance of Incremental Counting for all values
of n ∈ [3, 75], and T ∈ {1, 10, 20, 40, 80, 160, 320, 640, 1280, ∞}, where T = ∞
corresponds to a static network. For the star and path topologies, we permute the
labels every T rounds, since no other change is possible given that the topology
is ﬁxed. On the other hand, for random trees and random graphs, we produce a

Algorithm 1: Centralized simulation of leader and non-leader nodes run-
ning Incremental Counting [13] on T -stable topologies. V is the set of
nodes and E is the set of links. Node 1 is the leader node. The other node
labels are used for reference only, but not used to make decisions. N (i, E)
is the set of neighbors of node i according to E. F(E) is the matrix of
fractions shared according to E (cf. Equation 1).

1 k ← 1, IsCorrect ← false, r ← 1, E ← new set of links
2 while ¬IsCorrect do
3

k ← k + 1, IsCorrect ← true

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

Collection Phase:

(cid:0)e1, e2, e3, . . . , en(cid:1) ← (cid:0)0, 1, 1, . . . , 1(cid:1)
while e1 < k − 1 − 1/k1.01 do

// vector of energies

(cid:0)e1, e2, . . . , en(cid:1) ← F(E) · (cid:0)e1, e2, . . . , en(cid:1)T
if r ≡ 0 mod T then E ← new set of links
r ← r + 1

// broadcast simulation

Veriﬁcation Phase:

if e1 > k − 1 then IsCorrect ← false
(cid:0)e′
for 1 + ⌈k/(1 − 1/k1.01)⌉ iterations do

3, . . . , e′

1, e′

2, e′

n(cid:1) ← (cid:0)0, e2, e3 . . . , en(cid:1) // vector of max energy heard

1, e′

2, . . . , e′

i ← maxj∈N(i,E)∪{i} e′

for each i do e′′
(cid:0)e′
if r ≡ 0 mod T then E ← new set of links
r ← r + 1

2 , . . . , e′′
n(cid:1)

n(cid:1) ← (cid:0)e′′

1 , e′′

j

// broadcast simulation

// for Gn,p input only:
while not all nodes “heard” by leader do
i ← maxj∈N(i,E)∪{i} e′

for each i do e′′
(cid:0)e′
if r ≡ 0 mod T then E ← new set of links
r ← r + 1
1 > 1/k1.01 then IsCorrect ← false

2 , . . . , e′′
n(cid:1)

n(cid:1) ← (cid:0)e′′

2, . . . , e′

1 , e′′

if e′

1, e′

j

// broadcast simulation

Notiﬁcation Phase:

// vector of

(cid:0)h1, h2, h3, . . . , hn(cid:1) ← (cid:0)IsCorrect, false, false, . . . , false(cid:1)
halt flags
for k iterations do
for each i do h′
(cid:0)h1, h2, . . . , hn(cid:1) ← (cid:0)h′
if r ≡ 0 mod T then E ← new set of links
r ← r + 1

i ← Wj∈N(i,E) hj
2, . . . , h′

1, h′

n(cid:1)

// broadcast simulation

// for Gn,p input only:
while ¬(h1 ⇒ Vi∈V hi) do

for each i do h′
(cid:0)h1, h2, . . . , hn(cid:1) ← (cid:0)h′
if r ≡ 0 mod T then E ← new set of links
r ← r + 1

i ← Wj∈N(i,E) hj
2, . . . , h′

1, h′

n(cid:1)

// broadcast simulation

38 output k

whole new network every T rounds, since the topology is less restricted (trees)
or it is not restricted at all (graphs). For stars and random graphs, we ﬁxed the
degree upper bound ∆ = n − 1. For the former because that is the maximum
degree and for the latter to guarantee a uniform draw. For random trees and
paths we used ∆ = 2i, for all values of i > 0 such that 2i ≤ n − 1. For random
graphs we evaluated p ∈ {0.1, 0.2, 0.3, 0.4, 0.5}. All our results where computed
as the average over 100 executions of the protocol.

To produce our random rooted unlabeled trees we used the algorithm RAN-
RUT presented in [14], which was proved to provide a uniform distribution on
the equivalence classes deﬁned by isomorphisms. The tree so obtained may have
maximum degree larger than ∆. When that is the case, we prune the tree moving
subtrees downwards until all nodes have at most ∆ neighbors. This procedure
increases (or does not change) the longest path to the leader, which increases (or
does not change) the running time of Incremental Counting. Thus, with re-
spect to a uniform distribution on rooted unlabeled trees of maximum degree ∆,
our input distribution is biased “against” Incremental Counting providing
stronger guarantees.

In contrast, topologies obtained connecting pairs of nodes stochastically until
the graph is connected, usually have relatively low diameter, which may speed up
the energy transfer. Algorithm 2 summarizes the rooted tree network generator
used in our simulations.

Algorithm 2: Random tree generator algorithm. Auxiliary functions in
Algorithm 3.

1 Function GENTREE(n, ∆)
2

t ← SIZES(n) // Compute number of unlabeled rooted trees of size

1, 2, . . . , n.

p ← DISTRIB(t, n) // Compute distributions on subtrees for each n.
tree ← RANRUT(p, n) // Choose an unlabeled rooted tree uniformly at

random.

PRUNE (tree, ∆) // Move subtrees downwards until max degree of tree

is ∆.

return tree

3

4

5

6

5 Simulation Platform

We developed our own simulator and input generator implementing Algorithms 1
and 2 in Java 8. The simulations were carried out on a cluster facility at Kean
University known as Puma. Puma is a 130 node, 1040 core Dell cluster running
Red Hat Enterprise Linux and Rocks+ 4.3. Each node has 2 quad core 2.6 GHz
Xeon processors, 16GB RAM, and 350GB local storage, and are connected with
Gigabit ethernet.

Algorithm 3: Auxiliary functions for Algorithm 2. Refer to [14] for details
on SIZES, DISTRIB, and RANRUT.

1 Function SIZES(n)
2

Let t[1 . . . n] be a new array
t[1] ← 1, t[2] ← 1
for i = 3 to n do
// ti ← P∞
t[i] ← 0
for j = 1 to n do

j=1 P∞

dti−jd td

d=1

i−1

3

4

5

6

7

8

9

13

14

15

16

17

18

21

22

23

24

25

26

27

for d = 1 to n do

if jd < i then t[i] ← t[i] + d · t[i − jd] · t[d]

t[i] ← t[i]/(i − 1)

10

return t

11 Function DISTRIB(t, n)
12

Let p[1 . . . n][1 . . . n][1 . . . n] be a new 3D array
for k = 3 to n do

for j = 1 to n do

for d = 1 to n do

if jd < k then p[k][j][d] ← d · t[k − jd] · t[d]/((k − 1) · t[k])
else p[k][j][d] ← 0

return p

19 Function RANRUT(p, n)
20

if n ≤ 2 then tree ←new tree of size n
else

with probability distribution p[n][j][d] draw a pair (j, d)
tree ← RANRUT(p, n − jd)
for j times do

tree′ ← RANRUT(p, d)
attach tree′ to the root of tree

return tree

28 Procedure PRUNE(tree, ∆)
29

while root of tree has more than ∆ neighbors do

30

31

32

33

detach the rightmost subtree tree’ from the root of tree
ATTACH (tree, tree′, ∆)

foreach subtree tree’ of the root of tree do

PRUNE (tree′, ∆)

34 Procedure ATTACH(tree, tree′, ∆)

35

36

37

38

39

if root of tree has less than ∆ neighbors then

attach tree′ to the root of tree

else

choose a subtree tree” of the root of tree uniformly at random
ATTACH (tree′′, tree′, ∆)

Notice that our simulator is centralized. That is, rather than using the cluster
to simulate the communication among nodes, we simply run various instances of
the simulator in parallel to speedup our experiments. Using the cluster to sim-
ulate the communication among nodes would not have provided any additional
insight, given that in the Anonymous Dynamic Network model communication
is reliable and our protocol is deterministic.

6 Discussion

For all the topologies and parameter combinations evaluated, Incremental
Counting has proved to be polynomial. We plot here only a subset of our re-
sults for succinctness. Consider for instance Figure 1, where we plot the number
of rounds to complete the computation (log scale) as a function of the network
size, for various values of degree upper bound ∆, interval of stability T , and prob-
ability p of being connected in the random graph. We also plot the function ∆n4
to contrast the growth of such polynomial function with the results obtained. It
can be seen that all our results indicate a rate of growth asymptotically smaller
than ∆n4. (The upper bound could be tightened but we choose a loose one for
clarity.) For small network sizes, random graphs introduce additional delays due
to disconnection, but as the network scales the dynamic topology overcomes the
eﬀect of disconnections.

For the tree and path topologies the degree upper bound ∆ was checked
for various values. The performance of the protocol with respect to ∆ for those
inputs is illustrated in Figure 2. For paths, the running time increases with ∆.
This is expected given that, although nodes change positions, the topology is
always a path. ∆ is an upper bound, hence it may be increased, but the only
impact is a reduction on the fraction of energy shared with neighbors (see Algo-
rithm 1). Such reduction applies to the energy transfered towards the leader as
well as away from the leader. Nevertheless, the balance yields a slower dissem-
ination towards the leader in the collection phase. The same behavior can be
observed for the tree topology. This is somewhat surprising because we would
expect a larger ∆ to yield a shallower random tree. However, the impact of a
smaller fraction of energy shared dominates. Notice also in Figure 2 that these
observations apply whether the topology changes frequently or not.

Figure 3 shows the performance of the protocol for random graph inputs.
As expected, when the probability p of any given pair of nodes being connected
is low, the time needed to complete the computation grows drastically if the
network does not change frequently, because some nodes cannot reach the leader.
Indeed, even for 10-stable networks the performance when p = 0.1 is much worse
than for higher values of p when the network is likely to be connected. But if we
consider less-dynamic networks, such as 320-stable, the performance for p = 0.1
is much worse than others even for small networks.

Figure 4 illustrates the performance for diﬀerent intervals of stability and
representative cases of each type of input. It can be observed that when the net-
work is highly dynamic (10-stable) the random tree and random graph produce

Tree topology, average of 20 runs

Path topology, average of 20 runs

∆n4
T = 10
T = 1280
T = ∞

∆n4
T = 10
T = 1280
T = ∞

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

1e+10
1e+09
1e+08
1e+07
1e+06
100000
10000
1000
100
10
1

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

1e+10
1e+09
1e+08
1e+07
1e+06
100000
10000
1000
100
10
1

10

∆

0 10 20 30 40 50 60 70 80

Network size

100

10

∆

0 10 20 30 40 50 60 70 80

Network size

100

Star topology, ∆ = n − 1, average of 20 runs

G(n, p) topology, ∆ = n − 1, T = 160, average of 20 runs

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

1e+10

1e+09

1e+08

1e+07

1e+06

100000

10000

1000

100

10

∆n4
T = ∞

0

10

20

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

1e+10

1e+09

1e+08

1e+07

1e+06

100000

10000

1000

100

10

∆n4
p = 0.1
p = 0.2
p = 0.3
p = 0.4
p = 0.5

0

10

20

60

70

80

40

30
Network size

50

60

70

80

40

30
Network size

50

Fig. 1. Incremental Counting time performance compared with a polynomial func-
tion.

similar results. To understand why, consider for instance n = 25. Changing the
topology every 10 rounds yields a network where, on average over the roughly
8000 rounds, every pair of nodes is connected. The diﬀerence between tree and
graph becomes bigger as the topology changes less frequently, when the impact
of the lower conductance of the tree becomes dominant.

For static random trees, we can observe also in Figure 4 that the running
times varied signiﬁcantly from one network size to another. This is due to the
particular trees that happened to be drawn, which sometimes have better con-
ductance than others. The random graph was not evaluated for static networks
since permanent disconnection would stop the protocol from completing the com-
putation. On the other hand, for the star input the only dynamics introduced
was a permutation of labels, which are not used by Incremental Counting
and therefore has no impact on the running time. Thus, we illustrate the results
only in the static topology plots. As expected, a star yields the fastest running
time since all nodes are connected to the leader.

Finally, Figure 4 shows also the performance on a path input. Given that the
topology is ﬁxed to a path, as with the star topology, the only dynamics intro-
duced is a permutation of labels. Then, as expected, the running time increases
signiﬁcantly as the network changes less frequently. The reason being that in a

Tree topology, average of 20 runs

Path topology, average of 20 runs

T = 10

T = 10

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

400000
350000
300000
250000
200000
150000
100000
50000
0
80
70

60

50

40

30

20

10 20 30 40 50 60 70

∆

10

0

0

Network size

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

800000
700000
600000
500000
400000
300000
200000
100000
0
80
70

60

50

40

30

20

10 20 30 40 50 60 70

∆

10

0

0

Network size

Tree topology, average of 20 runs

Path topology, average of 20 runs

T = 1280

T = 1280

s
d
n
u
o
r

1e+06
900000
800000
700000
600000
500000
400000
300000
200000
100000
0
-100000
80

n
o
i
t
a
c
i
n
u
m
m
o
C

70

60

50

40

30

20

10 20 30 40 50 60 70

∆

10

0

0

Network size

2.5e+06

2e+06

1.5e+06

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

1e+06

500000

0
80
70

60

50

40

30

20

10 20 30 40 50 60 70

∆

10

0

0

Network size

Fig. 2. Incremental Counting time performance vs. degree upper bound.

path where most of the nodes do not change much their distance to the leader,
the fraction of energy received by the leader in each round from distant nodes
is inverse exponential on that distance.

In summary, our simulations have shown that Incremental Counting
runs in polynomial time for all the networks evaluated. The set of inputs tested
comprise average topologies likely to appear in practice as well as extremal cases.
Our simulations showed the static path to have the worse time performance
among all inputs tested. (For illustration, see in Figure 5 the case of a path with
∆ = 4 for various values of T .) Intuition on why Incremental Counting would
be polynomial in static paths can be obtained as follows. To bound the collection
time, consider the inverse gossip-based process of computing the average starting
with the leader having energy n and all other nodes 0. This process can be
modeled as a Markov chain, whose convergence time bounds the time to compute
the average (hence, the collection time). It is known [11] that the convergence
time of such Markov chain can be bounded by the mixing time of a random walk
on the same graph, which in turn has been proven [2] to be at most quadratic on
the number of nodes for paths. However, the question of whether a static path
is a worst case for Counting in some model of Anonymous Dynamic Network
remains open.

As a byproduct, our simulations provided insight on the impact of network
dynamics in the dissemination of information by gossip-based protocols. Indeed,
our results showed that on average network changes speed-up convergence. That
is, as long as the eﬀect is uniform throughout the network, highly dynamic

T = 10, average of 20 runs

T = 320, average of 20 runs

G(n, 0.1)
G(n, 0.2)
G(n, 0.3)
G(n, 0.4)
G(n, 0.5)

140000

120000

100000

80000

60000

40000

20000

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

0

0

10

20

40

30
Network size

50

G(n, 0.1)
G(n, 0.2)
G(n, 0.3)
G(n, 0.4)
G(n, 0.5)

160000

140000

120000

100000

80000

60000

40000

20000

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

60

70

80

0

0

10

20

40

30
Network size

50

60

70

80

Fig. 3. Incremental Counting time performance on random graphs for diﬀerent
intervals of stability.

topologies help rather than being a challenge as in a worst-case theoretical anal-
ysis.

7 Conclusions and Open Problems

The problem of Counting in Anonymous Dynamic Networks is challenging be-
cause lack of identiﬁers and changing topology make diﬃcult to decide if a
new message has been received before from the same node. Counting proto-
cols [5, 6, 13] overcome this challenge checking candidate sizes iteratively until
the correct size is obtained. However, the worst-case convergence time of the
gossip-based process used in those protocols has been bounded only exponen-
tially, yielding only exponential guarantees for Incremental Counting [13].
The situation is even worse in other works where a huge overestimate (proved
in [12]) is initially used as the candidate size, yielding a double-exponential pro-
tocol [5]. Other Counting protocols do not terminate [5], or terminate but do
not provide running-time guarantees [6], or compute only an exponential upper
bound on the network size [12]. Other heuristic protocols do not guarantee that
the computation is correct [7].

The main goal of this work was to show that in practice Incremental
Counting may compute the size of Anonymous Dynamic Networks in a poly-
nomial number of rounds of communication, obtaining always the correct result.
Additionally, the extensive simulations carried out provided very interesting ob-
servations about the impact of topology and dynamics in performance, as de-
tailed in Section 6. To the best of our knowledge, this is the ﬁrst experimental
study of the practical time complexity of a Counting protocol that computes the
exact count in Anonymous Dynamic Networks.

Open problems left for future work include further validating the conclusions
in this work by simulating Incremental Counting using real traces, taken
for instance from cellular networks, or by carrying out experiments in real net-
works. Also, once the network size is known, studying more complex problems

T = 10, average of 20 runs

T = 160, average of 20 runs

tree ∆ = 8
path ∆ = 8
G(n, 0.2)

100000

90000

80000

70000

60000

50000

40000

30000

20000

10000

0

0

10

20

40

30
Network size

50

60

70

80

T = 1280, average of 20 runs

tree ∆ = 8
path ∆ = 8
G(n, 0.2)

100000

90000

80000

70000

60000

50000

40000

30000

20000

10000

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

tree ∆ = 8
path ∆ = 8
G(n, 0.2)

100000

90000

80000

70000

60000

50000

40000

30000

20000

10000

0

0

10

20

40

30
Network size

50

60

70

80

Static topology, average of 20 runs

tree ∆ = 8
path ∆ = 8
star ∆ = n − 1

100000

90000

80000

70000

60000

50000

40000

30000

20000

10000

0

0

10

20

40

30
Network size

50

60

70

80

0

0

10

20

40

30
Network size

50

60

70

80

Fig. 4. Incremental Counting time performance for diﬀerent intervals of stability.

in Anonymous Dynamic Networks is the natural next step. On the theoretical
side, proving a polynomial upper bound on the time for counting remains an
enticing open question.

References

1. Almeida, P.S., Baquero, C., Farach-Colton, M., Jesus, P., Mosteiro, M.A.: Fault-
tolerant aggregation: Flow-updating meets mass-distribution. In: Proceedings of
the 15th International Conference on Principles of Distributed Systems. Lecture
Notes in Computer Science, vol. 7109, pp. 513–527. Springer (2011)

2. Beveridge, A., Wang, M.: Exact mixing times for random walks on trees. Graphs

and Combinatorics 29(4), 757–772 (2013)

3. Casteigts, A., Flocchini, P., Quattrociocchi, W., Santoro, N.: Time-varying graphs
and dynamic networks. International Journal of Parallel, Emergent and Distributed
Systems 27(5), 387–408 (2012)

4. Di Luna, G.A., Baldoni, R.: Non trivial computations in anonymous dynamic
networks. In: Proceedings of the 19th International Conference on Principles of
Distributed Systems. Leibniz International Proceedings in Informatics (2015), to
appear.

5. Di Luna, G.A., Baldoni, R., Bonomi, S., Chatzigiannakis, I.: Conscious and uncon-
scious counting on anonymous dynamic networks. In: Proceedings of the 15th In-
ternational Conference on Distributed Computing and Networking. Lecture Notes
in Computer Science, vol. 8314, pp. 257–271. Springer Berlin Heidelberg (2014)

Path topology, average of 20 runs, ∆ = 4

static
T = 1280
T = 160
T = 10

100000

90000

80000

70000

60000

50000

40000

30000

20000

10000

s
d
n
u
o
r

n
o
i
t
a
c
i
n
u
m
m
o
C

0

0

10

20

40

30
Network size

50

60

70

80

Fig. 5. Incremental Counting time performance for a path topology.

6. Di Luna, G.A., Baldoni, R., Bonomi, S., Chatzigiannakis, I.: Counting in anony-
mous dynamic networks under worst-case adversary. In: Proceedings of the 34th
International Conference on Distributed Computing Systems. pp. 338–347. IEEE
(2014)

7. Di Luna, G.A., Bonomi, S., Chatzigiannakis, I., Baldoni, R.: Counting in anony-
mous dynamic networks: An experimental perspective. In: Proceedings of the 9th
International Symposium on Algorithms and Experiments for Sensor Systems,
Wireless Networks and Distributed Robotics. Lecture Notes in Computer Science,
vol. 8243, pp. 139–154. Springer Berlin Heidelberg (2014)

8. Fern´andez Anta, A., Mosteiro, M.A., Thraves, C.: An early-stopping protocol for
computing aggregate functions in sensor networks. J. Parallel Distrib. Comput.
73(2), 111–121 (2013), http://dx.doi.org/10.1016/j.jpdc.2012.09.013

9. Kempe, D., Dobra, A., Gehrke, J.: Gossip-based computation of aggregate informa-
tion. In: Proc. of the 44th IEEE Ann. Symp. on Foundations of Computer Science.
pp. 482–491 (2003)

10. Kuhn, F., Lynch, N., Oshman, R.: Distributed computation in dynamic networks.
In: Proceedings of the 42nd ACM Symposium on Theory of Computing. pp. 513–
522. ACM (2010)

11. Levin, D.A., Peres, Y., Wilmer, E.L.: Markov chains and mixing times. American

Mathematical Soc. (2009)

12. Michail, O., Chatzigiannakis, I., Spirakis, P.G.: Naming and counting in anonymous
unknown dynamic networks. In: Stabilization, Safety, and Security of Distributed
Systems, pp. 281–295. Springer (2013)

13. Milani, A., Mosteiro, M.A.: A faster counting protocol for anonymous dynamic
networks. In: Proceedings of the 19th International Conference on Principles of
Distributed Systems. Leibniz International Proceedings in Informatics (2015), to
appear.

14. Nijenhuis, A., Wilf, H.S.: Combinatorial Algorithms for Computers and Calcula-

tors: 2d Ed. Academic Press (1978)

15. Sinclair, A., Jerrum, M.: Approximate counting, uniform generation and rapidly

mixing markov chains. Information and Computation 82(1), 93–133 (1989)

