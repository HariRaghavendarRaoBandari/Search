6
1
0
2

 
r
a

 

M
6
1

 
 
]

O
L
.
s
c
[
 
 

1
v
4
1
2
5
0

.

3
0
6
1
:
v
i
X
r
a

Chair for Theoretical Computer Science (Informatik 8)
Friedrich-Alexander University Erlangen-N¨urnberg, Germany
mail@stefan-milius.eu

tadeusz.litak@fau.de

Guard Your Daggers and Traces: Properties of

Guarded (Co-)recursion

invited to a special issue of Fundamenta Informaticae (FiCS’13)

Stefan Milius

Tadeusz Litak

March 17, 2016

Motivated by the recent interest in models of guarded (co-)recursion, we study
their equational properties. We formulate axioms for guarded ﬁxpoint operators
generalizing the axioms of iteration theories of Bloom and ´Esik. Models of these
axioms include both standard (e.g., cpo-based) models of iteration theories and
models of guarded recursion such as complete metric spaces or the topos of trees
studied by Birkedal et al. We show that the standard result on the satisfaction
of all Conway axioms by a unique dagger operation generalizes to the guarded
setting. We also introduce the notion of guarded trace operator on a category,
and we prove that guarded trace and guarded ﬁxpoint operators are in one-to-one
correspondence. Our results are intended as ﬁrst steps leading, hopefully, towards
future description of classifying theories for guarded recursion.

1. Introduction

Our ability to describe concisely potentially inﬁnite computations or inﬁnite behaviour of
systems relies on recursion, corecursion and iteration. Most programming languages and
speciﬁcation formalisms include a ﬁxpoint operator. In order to give semantics to such oper-
ators one usually considers either

• models based on complete partial orders where ﬁxpoint operators are interpreted by

least ﬁxpoints using the Kleene-Knaster-Tarski theorem or

• models based on complete metric spaces and unique ﬁxpoints via Banach’s theorem or
• term models where unique ﬁxpoints arise by unfolding speciﬁcations syntactically.

In the last of these cases, one only considers guarded (co-)recursive deﬁnitions; see e.g. Mil-
ner’s solution theorem for CCS [27] or Elgot’s iterative theories [13]. Thus, the ﬁxpoint
operator becomes a partial operator deﬁned only on a special class of maps. For a concrete
example, consider complete metric spaces which form a category with all non-expansive maps
as morphisms, but unique ﬁxpoints are taken only of contractive maps.

1

Recently, there has been a wave of interest in expressing guardedness by a new type con-
structor (cid:73), a kind of “later” modality, which allows to make the ﬁxpoint operator total
[29, 30, 3, 6, 22, 21, 8, 7, 4, 23]. For example, in the case of complete metric spaces, (cid:73) can
be an endofunctor scaling the metric of any given space by a ﬁxed factor 0 < r < 1 so that
non-expansive maps of type (cid:73)X → X are precisely r-contractive ones. This allows to deﬁne
a guarded (parametrized) ﬁxpoint operator on the model that assigns to every morphism
e : (cid:73)X × Y → X a morphism e† : Y → X. Languages with a guarded ﬁxpoint operator
can be also interpreted in the “topos of trees”, i.e., presheaves on ωop [8] or, more generally,
sheaves on complete Heyting algebras with a well-founded basis [12, 8]. Note that by using (cid:73),
guarded recursion becomes a generalization of standard recursion (since (cid:73) can be the identity
functor) rather than a specialization as in previous approaches.

This paper initiates the study of the essential properties of such operators. Iteration the-
ories [9] are known to axiomatize equalities of unguarded ﬁxpoint terms in models based on
complete partial orders (see also [31]). We make here the ﬁrst steps towards similar complete-
ness results in the guarded setting.

We begin with formalizing the notion of a guarded ﬁxpoint operator on a cartesian category.
We discuss a number of models, including not only all those mentioned above, but also some
not mentioned so far in the context of (cid:73)-guarded (co-)recursion. In fact, we consider the
inclusion of examples such as the lifting functor on CPO and, more broadly, let-ccc’s with
a ﬁxpoint object [11] (see Examples 2.4.(6)–(7) and Theorem 3.6) or completely iterative
monads (Section 2.2) a pleasant by-product of our work and a potentially fruitful connection
for future research.
In Section 3, we formulate (cid:73)-guarded generalizations of standard axioms of Conway and
iteration theories (see, e.g., [9, 31]) and prove their soundness. In particular, models with
unique guarded ﬁxpoint operators satisfy all our axioms (Theorem 3.4). Without the assump-
tion of uniqueness, some problems appear (notably, Open Problems 3.8, 3.16 and 3.17) and
generalizations of several known derivations, like that of the Bekiˇc identity from the Con-
way axioms (Proposition 3.10) require some ingenuity. We believe these are positive signs:
sticking (cid:73) in “all the right places” cannot always be done on autopilot and subtle aspects
of (co)-recursion invisible to the unguarded eye come to light, even on the purely equational
level. For natural examples, however, most properties in question seem to hold even without
requiring uniqueness, as witnessed, e.g., by Theorems 3.6 and 3.7.

Hasegawa [18] proved that giving a parametrized ﬁxpoint operator on a cartesian category
is equivalent to giving a traced cartesian structure [20] on that category.1 In Section 4, we
introduce a natural notion of a guarded trace operator on a category, and we prove in Theo-
rem 4.5 that guarded traces and guarded ﬁxpoint operators are in one-to-one correspondence.
This extends to an isomorphism between the (2-)categories of guarded traced cartesian cate-
gories and guarded Conway categories (Corollary 4.10). Just like in the unguarded case, the
notion of trace would make sense in a general monoidal setting (Remarks 4.1 and 4.3). We
leave this as an exciting avenue for future research.

Finally, Section 5 concludes and discusses further work.
A few words are due on diﬀerences with a previously published extended abstract of this
paper [26]. We obviously provide full proof details of all results. We also discuss additional
equational properties of guarded ﬁxpoint operators in Sections 3.1 and 3.2. Moreover, The-
orem 3.6 concerning let-ccc’s is new and so is, e.g., Example 2.8 (the last provided by Aleˇs

1Cartesian here refers to the monoidal product being the ordinary categorical product.

2

Bizjak).

We decided to move some more technical proofs to an appendix in order to make the paper

more readable.

1.1. Notational Conventions

π(cid:96)

πr

A × B

We assume familiarity with basic notions of category theory. We denote the product of two
/B and ∆ : A → A × A denotes the diagonal. For every functor
objects by A
F we write can = (cid:104)F π(cid:96), F πr(cid:105) : F (A × B) → F A × F B for the canonical morphism. We
denote the terminal object in a cartesian category as 1 and the unique morphism for each
X as ! : X → 1. Wherever convenient, we use freely other standard conventions such as
identifying X and 1 × X or dropping subscripts of natural transformations if they are clear
from the context.

CPO denotes the category of complete partial orders (cpo’s), i.e. partially ordered sets
(possibly without a least element) having joins of ω-chains. The morphisms of CPO are
Scott-continuous maps, i.e. maps preserving joins of ω-chains. CPO⊥ is the full subcategory
of CPO given by all cpo’s with a least element ⊥. We will also consider the category CMS of
complete 1-bounded metric spaces and non-expansive maps, i.e. maps f : X → Y such that
for all x, y ∈ X, dY (f x, f y) ≤ dX (x, y); see Krishnaswami and Benton [22, 21] or Birkedal et
al. [8, Section 5] and references therein.
Instead of writing “the following square commutes” or “the following diagram commutes”,
we write (cid:9) in the middle of the diagram in question. We also use objects to denote their
identity morphisms. Finally, we sometimes write X = Y to indicate that two objects in a
category are isomorphic.

2. Guarded Fixpoint Operators

In this section we deﬁne the notion of a guarded ﬁxpoint operator on a cartesian category and
present an extensive list of examples. Some of these examples like the lifting functor (−)⊥
on CPO (see Example 2.4.6) or completely iterative monads (see Section 2.2) do not seem to
have been considered as instances of the guarded setting before. We also discuss in detail the
connection with models of guarded ﬁxpoint terms of Birkedal et al. [8], see Proposition 2.7.

2.1. Deﬁnition and Examples of Guarded Fixpoint Operators
Assumption 2.1. We assume throughout the rest of the paper that (C, (cid:73)) is a pair consisting
of a category C with ﬁnite products (also known as a cartesian category) and a pointed
endofunctor (cid:73) : C → C, i.e. we have a natural transformation p : Id → (cid:73). The endofunctor (cid:73)
is called delay or the “later” modality.

Remark 2.2. In references like Birkedal et al.
[8, 7], much more is assumed about both the
underlying category and the delay endofunctor. Modelling simply-typed lambda calculus
requires cartesian closure. Dependent types require additional conditions like being a type-
theoretic ﬁbration category (see, e.g., [7, Deﬁnition IV.1]).
In such a case, one also wants
to impose some limit-preservation or at least ﬁnite-limit-preservation condition on the delay
endofunctor [8, Deﬁnition 6.1]—e.g., to ensure the transfer of the guarded ﬁxpoint operator
to slices. We do not impose any of those restrictions because we do not need them in our

3

o
o
/
derivations. For more on the connection with the setting of Birkedal et al. [8], see Proposition
2.7 below.
Deﬁnition 2.3. A guarded ﬁxpoint operator on (C, (cid:73)) is a family of operations

such that for every f : (cid:73)X × Y → X,

†X,Y : C((cid:73)X × Y, X) → C(Y, X)

Y
(cid:104)f†,Y (cid:105)

X × Y

f†

(cid:9)

X

f

/ (cid:73)X × Y

pX×Y

(2.1)

where (as usual) we drop the subscripts and write f† : Y → X in lieu of †X,Y (f ). We call the
triple (C, (cid:73),†) a guarded ﬁxpoint category.
Moreover, (C, (cid:73),†) is called a unique guarded ﬁxpoint category if for every f : (cid:73)X×Y → X,
f† is the unique morphism satisfying (2.1). In this case, we can just write a pair (C, (cid:73)) instead
of a triple (C, (cid:73),†).

If one does not require that f† is the unique solution of (2.1), one usually assumes that †
satisﬁes further properties. For example, Simpson and Plotkin [31] require that a parametrized
ﬁxpoint operator † is natural in Y in the base deﬁnition. We will come to the study of
properties of † such as naturality in Section 3. Let us begin with a list of examples. Note
that in most cases, we do not explicitly mention the action of (cid:73) on morphisms whenever it
is canonical; for Example (5), it is given in Appendix A.
Examples 2.4. (1) Taking as (cid:73) the identity functor on C and pX the identity on X we arrive
at the special case of categories with an ordinary ﬁxpoint operator C(X×Y, X) → C(Y, X)
(see e.g. Hasegawa [18, 19] or Simpson and Plotkin [31]). Concrete examples are: the
category CPO⊥ with its usual least ﬁxpoint operator or (the dual of) any iteration theory
of Bloom and ´Esik [9].

(2) Taking (cid:73) to be the constant functor (cid:73)X = 1 and pX = ! : X → 1, a trivial guarded

ﬁxpoint operator is given by the family of identity maps on the hom-sets C(Y, X).

(3) Take C to be CMS, r ∈ (0, 1), (cid:73)r : CMS → CMS to be the endofunctor keeping the carrier
of the space and multiplying all distances by r, and pX : X → (cid:73)rX to be the obvious
“contracted identity” mapping. Note that a non-expansive mapping f : (cid:73)rX → X is
the same as an r-contractive endomap, i.e. an endomap satisfying d(f x, f y) ≤ r · d(x, y)
for every x, y ∈ X. An application of Banach’s unique ﬁxpoint theorem yields a guarded
ﬁxpoint operator: for every f : (cid:73)rX × Y → X we consider the map

Φf : CMS(Y, X) → CMS(Y, X),

Φf (m) = f · (pX × Y ) · (cid:104)m, Y (cid:105);

notice that CMS(Y, X) is a complete metric space with the sup-metric

dY,X (m, n) = sup
y∈Y

{dX (my, ny)}.

Using that non-expansive maps are closed under composition, product and pairing, it
is easy to show that Φf is an r-contractive map, and so its ﬁxpoint is the unique non-
expansive map f† : Y → X satisfying (2.1).

4

/
/


/
O
O
(4) Let A be a category with ﬁnite products and C be the presheaf category presh(ω,A) =
Aωop of ωop-chains in A. The delay functor is given by (cid:73)X(0) = 1 and (cid:73)X(n + 1) = X(n)
for n ≥ 0, whereas pX is given by (pX )0 = ! : X(0) → 1 and (pX )n+1 = X(n + 1 ≥ n) :
X(n+1) → X(n). For every f : (cid:73)X×Y → X there is a unique f† : Y → X satisfying (2.1)
given by f

†
0 = f0 : Y (0) → X(0) and

†
f
n+1 = (Y (n + 1)

(cid:104)f

†
n·Y (n+1≥n),Y (n+1)(cid:105)

/X(n) × Y (n + 1)

fn+1 /

/X(n + 1)).

Notice that for A = Set, C is the “topos of trees” of Birkedal et al.
The next example generalizes this one.

[8].

(5) Assume W = (W,≤) is a well-founded poset, i.e, contains no inﬁnite descending chains.
As usual we write x < y whenever x ≤ y and x (cid:54)= y. Furthermore, let D be a (small)
complete category and C = presh(W,D), i.e., C = D(W,>). Deﬁne (cid:73)X(w) to be the
limit of the diagram whose nodes are X(v) for v < w and whose arrows are restriction
morphisms: (cid:73)X(w) = limv<w X(v). As restriction mappings from X(w) itself form a
cone on that diagram, a natural pX : X → (cid:73)X is given by the universal property of the
limits. Note that for any minimal element r ∈ W , we have that ((cid:73)X)(r) is the terminal
object 1 of D. The †-operation on f : (cid:73)X × Y → X is deﬁned by induction on (W,≤):
assuming that f

†
v is already deﬁned for all v < w let

f†
w = (Y (w)

(cid:104)k,Y (w)(cid:105)

/(cid:73)X(w) × Y (w)

fw /

/X(w)),

where k : Y (w) → (cid:73)X(w) is the morphism uniquely induced by the cone

Y (w>v)

Y (w)

†
v

f

/Y (v)

/X(v)

for every v < w.

This includes the case of a minimal element r for which the above deﬁnition yields f
fr : Y (r) = 1 × Y (r) → X(r).
One can prove that f† is a unique morphism of presheaves satisfying (2.1); more details
can be found in Appendix A. This result generalizes Birkedal et al. [8, Theorem 2.4].

†
r =

Regarding the examples given by Birkedal et al. [8], see also Proposition 2.7 below, which
also establishes that a let-ccc with a ﬁxpoint object with (cid:73) and † just deﬁned forms a
guarded ﬁxpoint category.

(6) Let (cid:73) be the lifting functor (−)⊥ on CPO, i.e. for any cpo X, X⊥ is the cpo with a newly
added least element and the natural transformation pX : X → X⊥ is the embedding of
X into X⊥. Taking least ﬁxpoints yields a guarded ﬁxpoint operator. To see this notice
that the hom-sets CPO(X, Y ) are cpos with the pointwise order: f ≤ g iﬀ f (x) ≤ g(x)
for all x ∈ X. Now any continuous f : X⊥ × Y → X gives rise to a continuous map Φf
on CPO(Y, X⊥):

Φf : CPO(Y, X⊥) → CPO(Y, X⊥),

Φf (m) = pX · f · (cid:104)m, Y (cid:105).
/X⊥ × Y

f

Using the least ﬁxpoint s of Φf deﬁne f† = (Y
/X ). As s = Φf (s), one
can easily show f† satisﬁes (2.1). Just as Example (5) was more general than (4), the
present example is also known to be an instance of a more general situation:

(cid:104)s,Y (cid:105)

5

/
/
/
/
/
/
(7) Crole and Pitts [11, 10] deﬁne a let-ccc with a ﬁxpoint object as a tuple

(C, T, η, µ, s, T Ω σ−→ Ω, 1 ω−→ Ω),

where

• C is a cartesian closed category,
• (T, η, µ, s) is a strong monad on C, i.e. a monad together with a strength viz. a
family of morphisms sA,B : A× T B → T (A× B) natural in A and B and compatible
with the monad structure in the obvious way,

• σ : T Ω → Ω is an initial algebra for the functor T and
• ω is the equalizer of σ · ηΩ and identity on Ω (i.e., the unique ﬁxpoint of σ · ηΩ) .

Recall from Crole and Pitts [10, 11] (and cf. Manes [24]) that a strong monad can be
∗
speciﬁed by an object assignment T , a family of morphisms ηA and an operation (−)
:
C(A × B, T C) → C(A × T B, T C) satisfying the following laws:
(a) for any f : A × B → T C, we have f∗ · (A × ηB) = f ;
(b) (ηB · πr)
∗
(c) given f : A → A(cid:48) and g : A(cid:48) × B → T C we have (g · (f × B))
∗
(d) given f : A × B → T C and g : A × C → T D we have (g∗ · (cid:104)π(cid:96), f(cid:105))
The initiality of Ω and cartesian closedness of C yield that for any f : C × T A → A there
exists a unique morphism it(f ) : C × Ω → A such that

= πr : A × T B → T B;

= g∗ · (f × T B);

∗

= g∗ · (cid:104)π(cid:96), f∗(cid:105).

C × Ω
C×σ
C × T Ω

it(f )

(cid:9)

(cid:104)π(cid:96),(η·it(f ))∗(cid:105)

A

f

/ C × T A

(2.2)

Now set (cid:73) = T and for any f : Y × T X → X deﬁne2 f† = it(f )· (Y × ω). To see that this
∗
example covers the preceding one, follow [11] and set T = (−)⊥, ηX = pX , (−)
the strict
extension (i.e. with f∗(a,⊥) = ⊥) and Ω = {0 (cid:64) 1 (cid:64) ··· (cid:64) (cid:62)}. We return to let-ccc’s in
Theorem 3.6 below.

Remark 2.5. If we replaced initiality of Ω in Example 2.4.(7) by the (parametrized) universal
property (2.2) of Ω we could drop cartesian closure of C and simply assume C to be a category
with products; cf. Crole and Pitts [11, Lemma 2.2] and an explict claim therein: if one simply
has a category with ﬁnite products and a strong monad, the deﬁnition of ﬁxpoint object should
be strengthened to a parametrised form. See also Proposition 2.7 below for an analogous
discussion.

Birkedal et al.

[8] provide a general setting for topos-theoretic examples like 2.4.(4)
and 2.4.(5) (the latter restricted to the case of Set-presheaves) by deﬁning a notion of a
model of guarded recursive terms and showing that sheaves over complete Heyting algebras
with a well-founded basis proposed by Di Gianantonio and Miculan [12] are instances of this
notion. The diﬀerence between Deﬁnition 6.1 in [8] and our Deﬁnition 2.3 is that in the
2Note that to be consistent with [11] we put (cid:73)X in the right-hand product component of the domain of f .

6

/
/
O
O
/
O
O
former a) the delay endofunctor (cid:73) is also assumed to preserve ﬁnite limits, in particular ﬁnite
products. On other hand b) our equality (2.1) is only postulated in the case where Y is the
terminal object, i.e., only a non-parametrized ﬁxpoint identity is assumed but c) the dagger
in this less general version of (2.1) is assumed to be unique. Now, one can show that as-
sumptions a) and c) imply our parametrized identity (2.1) whenever the underlying category
is cartesian closed, in particular whenever C is a topos. Let us state both the deﬁnition and
the result formally:
Deﬁnition 2.6. A weak model of guarded ﬁxpoint terms is a triple (C, (cid:73),‡), where

• (C, (cid:73)) satisfy our general Assumption 2.1,
• (cid:73) preserves ﬁnite products with can−1

isomorphism,

X,Y : (cid:73)X × (cid:73)Y → (cid:73)(X × Y ) as the witnessing

• ‡ is a family of operations ‡X : C((cid:73)X, X) → C(1, X) such that for every f : (cid:73)X → X,

f‡ is a unique morphism for which

f‡

(cid:9)

1

f‡

X pX

X

f

/ (cid:73)X

(2.3)

A model of guarded ﬁxpoint terms [8] is a weak model in which in addition C has ﬁnite

limits (not just products) and (cid:73) preserves them.
Proposition 2.7. If (C, (cid:73),‡) is a weak model of guarded ﬁxpoint terms and C is cartesian
closed with

curryX

Y,Z : C(X × Y, Z) → C(X, ZY ),

then the operator †X,Y : C((cid:73)X × Y, X) → C(Y, X) deﬁned as

(cid:18)(cid:104)

(cid:16)

f† = evalY,X ·

curry

(cid:73)(X Y )
Y,X

f · (cid:104)(cid:73)evalY,X · can−1

is a unique guarded ﬁxpoint operator on (C, (cid:73)).
Proof. Take f : (cid:73)X × Y → X. For notational simplicity, let

and

evalY,Z : ZY × Y → Z,

X Y ,Y · ((cid:73)(X Y ) × pY ), πr(cid:105)(cid:17)(cid:105)‡ × Y

(cid:19)

g = f · (cid:104)(cid:73)evalY,X · can−1

so that f† = evalY,X · ((cid:98)g‡ × Y ). We need to show (2.1) for f† deﬁned this way, i.e., commu-

X Y ,Y · ((cid:73)(X Y ) × pY ), πr(cid:105)

(cid:73)(X Y )
Y,X (g)

tativity of the outside of the diagram below:

and (cid:98)g = curry

(cid:98)g‡×Y

(cid:9) by (2.3)
p×Y

Y = 1 × Y
(cid:98)g‡×Y
X Y × Y

(cid:104)eval,πr(cid:105)

X × Y

X Y × Y
(cid:98)g×Y
(cid:73)(X Y ) × Y

(cid:104)p,πr(cid:105)

(cid:9) by pointedness

(cid:9) by ccc

eval

g

(cid:104)(cid:73)(X Y )×p,πr(cid:105)

/ (cid:73)(X Y ) × (cid:73)Y × Y
(cid:104)(?),(cid:9)(cid:105)
can−1×Y
(cid:73)(X Y × Y ) × Y

X

f

(cid:9) by def. of g

(cid:73)eval×Y

(cid:73)X × Y

p×Y

7

/
/


/
O
O
/
/


/
/
/
/


,
,
2
2
O
O
/


/
/
O
O
O
O
Thus, we need to show the left-hand product component (?) of the inner triangle commutes.
We postcompose both sides with the isomorphism can : (cid:73)(X Y × Y ) → (cid:73)(X Y ) × (cid:73)Y and
obtain

can · pX Y ×Y = (cid:104)(cid:73)π(cid:96), (cid:73)πr(cid:105) · pX Y ×Y = (cid:104)pX Y · π(cid:96), pY · πr(cid:105) = pX Y × pY ,

where the middle equation holds by the naturality of p.
s = f · (pX × Y ) · (cid:104)s, Y (cid:105). Let c = curry1

It remains to prove that f† is the unique solution of (2.1). Suppose that s : Y → X satisﬁes
Y,X (s) : 1 → X Y . We show that (2.3) holds with f‡

replaced by c, i.e. that c =(cid:98)g · pX Y · c. Equivalently, we show
In order to see this ﬁrst modify the above diagram by replacing (cid:98)g‡ in the upper left-hand

evalY,X · (c × Y ) = evalY,X · ((cid:98)g × Y ) · (pX Y × Y ) · (c × Y ).

square by c. Notice that our desired equation corresponds to the (modiﬁed) upper left-hand
square postcomposed with evalY,X , i.e., the right-hand morphism of the upper edge. Since
evalY,X · (c × Y ) = s, the outside of the modiﬁed diagram commutes by hypothesis. Thus,
since all other parts commute as indicated we obtain the desired equation. This implies that

c =(cid:98)g‡, by the uniqueness of the latter. Hence

s = evalY,X · (c × Y ) = evalY,X · ((cid:98)g‡ × Y ) = f†,

which completes the proof.

Proposition 2.7 cannot be reversed: Example 2.4.(6) is a guarded ﬁxpoint category, but
(−)⊥ clearly fails to preserve even ﬁnite products and hence it does not yield a model of
guarded recursive terms.

Example 2.8. A counterexample kindly provided by Aleˇs Bizjak shows that Proposition
2.7 does not hold without the assumption that C is cartesian closed: there are examples of
models of guarded recursive terms which are not guarded ﬁxpoint categories. In fact, the
adjective “guarded” can be removed altogether from the previous sentence: C in the Bizjak
counterexample is the category of groups and (cid:73) = IdC. Initial and ﬁnal objects coincide in
C, which entails two things: 1) cartesian closure fails and 2) there is exactly one canonical
choice for ‡ possible; f‡ : 1 → X is the unique morphism from the zero object for every group
endomorphism f : (cid:73)X = X → X. However, picking X to be any non-trivial abelian group
shows there is no way of deﬁning †X,X . It is enough to consider h : (cid:73)X × X = X × X → X as
being simply the group operation +: Equation (2.1) then yields h†(x) + x = h†(x) for every
x ∈ X and using inverses one has x = 0 contradicting nontriviality of X.

However, to apply Proposition 2.7, it is enough that (C, (cid:73),‡) is a full subcategory of a
cartesian closed model of guarded recursive terms such that, moreover, the inclusion functor
preserves products and (cid:73).

Example 2.9. Monads provide perhaps the most natural and well-known examples of pointed
endofunctors. Among delay endofunctors in Example 2.4, (1), (2), (6) and (7) happen to be
monads. In (3), i.e. the CMS example, the type (cid:73)(cid:73)A → (cid:73)A is still inhabited (by any constant
mapping), but one can easily show that monad laws cannot hold whatever candidate for
monad multiplication is postulated. In the remaining (i.e., topos-theoretic) examples, monad
laws fail more dramatically: (cid:73)(cid:73)A → (cid:73)A is not even always inhabited.

8

Section 2.2 below discusses a class of examples of guarded ﬁxpoint categories with unique
dagger, where the delay endofunctor arises from (a module for) a monad. Later on, in Example
2.15 and Theorem 3.6, we will return to Examples 2.4.(6)–(7): we will see that while they do
not possess uniqueness, they do enjoy other properties introduced in Section 3 below.

2.2. Completely Iterative Theories

In this subsection we will explain how categories with guarded ﬁxpoint operator capture
a classical setting in which guarded recursive deﬁnitions are studied—Elgot’s (completely)
iterative theories [13, 14]. The connection to guarded ﬁxpoint operators is most easily seen if
we consider monads in lieu of Lawvere theories, and so we follow the presentation of completely
iterative monads by Milius [25]. First we recall details of their motivating example: inﬁnite
trees on a signature Σ, i.e. a sequence (Σn)n<ω of sets of operation symbols with prescribed
arity n. A Σ-tree t on a set X of generators is a rooted and ordered (ﬁnite or inﬁnite) tree
whose nodes with n > 0 children are labelled by n-ary operation symbols from Σ and a leaf
is labelled by a constant symbol from Σ0 or by a generator from X. One considers systems
of mutually recursive equations of the form

xi ≈ ti((cid:126)x, (cid:126)y)

i ∈ I,

where X = {xi | i ∈ I} is a set of recursion variables and each ti is a Σ-tree on X + Y
with Y a set of parameters (i.e. generators that do not occur on the left-hand side of a
recursive equation). A system of recursive equations is guarded if none of the trees ti is only
a recursion variable x ∈ X. Every guarded system has a unique solution, which assigns to
†
†
every recursion variable xi ∈ X a Σ-tree t
i ((cid:126)y) on Y such that t
i ((cid:126)y) = ti[σ], where σ is the
†
substitution replacing each xj by t
j((cid:126)y). For a concrete example, let Σ consist of a binary
operation symbol ∗ and a constant symbol c, i.e. Σ0 = {c}, Σ2 = {∗} and Σn = ∅ else. Then
the following system

x1 ≈ x2 ∗ y1

x2 ≈ (x1 ∗ y2) ∗ c,

where y1 and y2 are parameters, has the following unique solution:

∗

y2

c

∗

y1

∗

c

∗

∗

y2

∗

y1

†
1 =

t

∗

c

∗

y2

∗

∗

y1

y1

c

and

†
2 =
t

∗

y2

∗

y1

∗

∗

c

For any set X, let TΣ(X) be the set of Σ-trees on X. It has been realized by Badouel [5]

that TΣ is the object part of a monad. A system of equations is then nothing but a map

f : X → TΣ(X + Y ),

9

and a solution is a map f† : X → TΣY such that
f†

X

f

(cid:9)

TΣY

µY

TΣ(X + Y )

TΣ[f†,ηY ]

/ TΣTΣY

where η and µ are the unit and multiplication of the monad TΣ, respectively.

It is clear that the notion of equation and solution can be formulated for every monad S.
However, the notion of guardedness requires one to speak about non-variables in S. This is
enabled by Elgot’s notion of ideal theory [13], which for a ﬁnitary monad on Set is equivalent
to the notion recalled in the following deﬁnition. We assume for the rest of this subsection
that A is a category with ﬁnite coproducts such that coproduct injections are monomorphic.
Deﬁnition 2.10 ([1]). An ideal monad on A is a six-tuple (S, η, µ, S(cid:48), σ, µ(cid:48)) consisting of a
monad (S, η, µ) on A, a subfunctor σ : S(cid:48) (cid:44)→ S and a natural transformation µ(cid:48) : S(cid:48)S → S(cid:48)
such that
(1) S = S(cid:48) + Id with coproduct injections σ and η, and
(2) µ restricts to µ(cid:48) along σ, i.e.,

S(cid:48)S

σS

SS

S(cid:48)

σ

/ S

(2.4)

µ(cid:48)

(cid:9)

µ

The subfunctor S(cid:48) of an ideal monad S allows us to formulate the notion of a guarded
equation system abstractly; this leads to the notion of completely iterative theory of Elgot et
al. [14] for which we here present the formulation with monads from Milius [25]:
Deﬁnition 2.11. Let (S, η, µ, S(cid:48), σ, µ(cid:48)) be an ideal monad on A.

1. An equation morphism is a morphism f : X → S(X + Y ) in A, where X is an object

(“of variables”) and Y is an object (“of parameters”).
2. A solution of f is a morphism f† : X → SY such that

X

f

f†

(cid:9)

S(X + Y )

S[f†,ηY ]

SY

µY

/ SSY

(2.5)

3. The equation morphism f is called guarded if it factors through the summand S(cid:48)(X +

Y ) + Y of S(X + Y ) = S(cid:48)(X + Y ) + X + Y :

X

f

S(X + Y )

(cid:9)

[σX+Y ,ηX+Y ·inr]

S(cid:48)(X + Y ) + Y

(2.6)

10

/
/


/
O
O
/
/




/
/
/


/
O
O
/
/
(
(
O
O
4. The given ideal monad is called completely iterative if every guarded equation morphism

has a unique solution.

Examples 2.12. We only brieﬂy mention two examples of completely iterative monads. More
can be found in literature [1, 25, 2].

(1) The monad TΣ of Σ-trees is a completely iterative monad.
(2) A more general example is given by parametrized ﬁnal coalgebras. Let H : A → A be an
endofunctor such that for every object X of A a ﬁnal coalgebra T X for H(−) + X exists.
Then T is the object assignment of a completely iterative monad; in fact, T is the free
completely iterative monad on H (see [25]).

We will now explain how a completely iterative monad S yields a guarded ﬁxpoint category.
Namely, let us show that the dual of its Kleisli category C = (AS)op is equipped with a guarded
ﬁxpoint operator. First, since AS has coproducts given by the coproducts in A, we see that
C has products. Next we need to obtain the endofunctor (cid:73) on C. This will be given as the
dual of an extension of the subfunctor S(cid:48) : A → A of S to the Kleisli category AS. Indeed, it
is well-known that to have an extension of S(cid:48) to AS is equivalent to having a distributive law
of the functor S(cid:48) over the monad S (see Mulry [28]).

One easily veriﬁes that the natural transformation S(cid:48)S

/SS(cid:48) satisﬁes the two
required laws and thus yields a distributive law. The corresponding extension of S(cid:48) maps X
to S(cid:48)X and a morphism X → SY of AS to
S(cid:48)f−−→ S(cid:48)SY

ηS(cid:48)Y−−−→ SS(cid:48)Y.

µ(cid:48)
Y−−→ S(cid:48)Y

S(cid:48)X

µ(cid:48)

/S(cid:48) ηS(cid:48)

Moreover, the endofunctor (cid:73)op = S(cid:48) on AS is copointed, i.e. we have a natural transfor-
mation p from S(cid:48) to Id : AS → AS; indeed, its components at X are given by the coproduct
injections σX : S(cid:48)X → SX, and it is not diﬃcult to verify that this is a natural transformation;
thus, (cid:73) is a pointed endofunctor on C.
Now observe that C((cid:73)X × Y, X) is just A(X, S(S(cid:48)X + Y )). We are ready to describe the
guarded ﬁxpoint operator on C.
Construction 2.13. For any morphism f : X → S(S(cid:48)X + Y ) form the following morphism

f = (X

f

/S(S(cid:48)X + Y )

S(σX +ηY )

/S(SX + SY ) Scan /

/SS(X + Y )

µX+Y /

/S(X + Y )),

where can = [Sinl, Sinr] : SX + SY → S(X + Y ). We shall verify that f is a guarded equation
morphism for S which allows deﬁning f† : X → SY as the unique solution of f .
Proposition 2.14. For every f , f† from Construction 2.13 is the unique morphism satisfying
(2.1).
Proof. We ﬁrst verify that f† is well-deﬁned, i.e. f is guarded with the following factor f 0:

X

f 0

S(cid:48)(X + Y ) + Y

f

S(S(cid:48)X + Y )

[σ,η]−1

Y

(cid:48) i n l] +

(cid:48) , S
[ µ

S(cid:48)S(X + Y ) + S(cid:48)X + Y

n

a

(cid:48) c
S

Y

/ S(cid:48)(S(cid:48)X + Y ) + S(cid:48)X + Y
(cid:48) X
S
S(cid:48)(SX + SY ) + S(cid:48)X + Y

S(cid:48)(σ+η)+S(cid:48)X+Y

+

+

11

/
/
/
/
/
/


/


o
o
o
o
Notice that both f and f 0 start with f . Thus, in order to prove f = [σX+Y , ηX+Y · inr] · f 0
(see (2.6)) we can remove f . Then it suﬃces to prove that the two remaining morphisms are
equal when precomposed with the isomorphism [σ, η] : S(cid:48)(S(cid:48)X +Y )+S(cid:48)X +Y → S(S(cid:48)X +Y ),
i.e. we verify

[σX+Y , ηX+Y · inr] · ([µ(cid:48)

X+Y , S(cid:48)inl] + Y ) · (S(cid:48)can + S(cid:48)X + Y ) · (S(cid:48)(σX + ηY ) + S(cid:48)X + Y )

= µX+Y · Scan · S(σX + ηY ) · [σS(cid:48)X+Y , ηS(cid:48)X+Y ].

We consider the two coproduct components separately and compute for the left-hand com-
ponent

σX+Y · µ(cid:48)

X+Y · S(cid:48)can · S(cid:48)(σX + ηY )

(2.4)

= µX+Y · σS(X+Y ) · S(cid:48)can · S(cid:48)(σX + ηY )
= µX+Y · Scan · S(σX + ηY ) · σS(cid:48)X+Y ,

where the second step uses naturality of σ twice; for the right-hand component we obtain
µX+Y · Scan · S(σX + ηY ) · ηS(cid:48)X+Y = µX+Y · ηS(X+Y ) · can · (σX + ηY )

(cid:124)

(cid:123)(cid:122)

(cid:125)

·(σX + ηY )

=can

= [Sinl, Sinr]
= [Sinl · σX , Sinr · ηY ]
= [σX+Y · S(cid:48)inl, ηX+Y · inr]
= [σX+Y , ηX+Y · inr] · (S(cid:48)inl + Y ).

(by nat. of η)
(since µ · ηS = id)

(by nat. of σ and η)

This ﬁnishes the proof of guardedness of f .

Now observe that (2.1) can equivalently be expressed in A (using C = (AS)op) as the outside

square of the following diagram

X

f

(cid:9)

S(S(cid:48)X + Y )

f†

f

cf. (2.5)

SY
µ

SSY

S[f†,ηY ]

S(σ+η)

/ S(SX + SY )

/ SS(X + Y ) µX+Y

/ S(X + Y )

Scan

This outside commutes iﬀ the upper right-hand triangle commutes iﬀ f† is a solution of f .
Since the latter exists uniquely we see that f† is the desired unique morphism satisfying (2.1).

Examples 2.15. Several items in Examples 2.4 are unique guarded ﬁxpoint categories; this
holds for Examples 2.4.(2)–(5), and also for the example of completely iterative monads in
Section 2.2. However, Example 2.4.(6) is not a unique guarded ﬁxpoint category:
for let
X = {0, 1} be the two-chain, Y = 1 the one element cpo and f : X⊥ = X⊥ × Y → X be the
map with f (0) = f (⊥) = 0 and f (1) = 1. Then both 0 : 1 → X and 1 : 1 → X make (2.1)
commutative.

3. Properties of Guarded Fixpoint Operators

In this section, we study properties of guarded ﬁxpoint operators. Except for uniformity,
these properties are purely equational. They are generalizing analogous properties of Bloom

12

/
/


,
,
O
O
/
/
/
O
O
and ´Esik’s iteration theories [9]; more precisely, they would collapse to the original, unguarded
counterparts when (cid:73) is instantiated to the identity endofunctor as in Example 2.4.(1). Just
like these original counterparts, they are all satisﬁed whenever the operator assigns a unique
ﬁxpoint (Theorem 3.4), but this is not a necessary condition for them to hold, as witnessed
by Theorems 3.6 and 3.7 concerning Examples 2.4.(6)–(7). However, the standard notion
of dinaturality turns out to behave surprisingly enough in the guarded setting to merit a
separate Subsection 3.2. As a prerequisite, we also discuss the so-called Bekiˇc identity in
Section 3.1.

Deﬁnition 3.1. We deﬁne the following possible properties of a guarded ﬁxpoint category
(C, (cid:73),†):
(1) Fixpoint Identity (†). For every f : (cid:73)X × Y → X, (2.1) holds. This is built into the
deﬁnition of guarded ﬁxpoint categories and only mentioned here again for the sake of
completeness.

(2) Parameter Identity (P). For every f : (cid:73)X × Y → X and every h : Z → Y ,

Z h /

/Y

f†

/X = ((cid:73)X × Z

(cid:73)X×h /

/(cid:73)X × Y

f

/X )†.

(3) (Simpliﬁed) Composition Identity (C). Given f : (cid:73)X × Y → Z and g : Z → X,

((cid:73)X × Y

f

/Z

g

/X )† = (Y

(f·((cid:73)g×Y ))†

g

/Z

/X ).

(4) Double Dagger Identity (††). For every f : (cid:73)X × (cid:73)X × Y → X,

f††

/X ) = ((cid:73)X × Y

∆×Y /

/(cid:73)X × (cid:73)X × Y

f

/X )†.

(Y

(5) Uniformity (U). Given f : (cid:73)X × Y → X, g : (cid:73)X(cid:48) × Y → X(cid:48) and h : X → X(cid:48),

(cid:73)X × Y
(cid:73)h×Y
(cid:73)X(cid:48) × Y

(cid:9)

f

g

X

h

/ X(cid:48)

=⇒

Y

f†

g†

(cid:9)

X

h

X(cid:48)

We call the ﬁrst four properties (1)–(4) the Conway axioms.

Notice that the Conway axioms are equational properties while (5) is quasiequational, i.e.,

an implication between equations.
Next we shall show that in the presence of certain of the above properties the natural
transformation p : Id → (cid:73) is a derived structure. Let (C, (cid:73)) be equipped with an operator
† not necessarily satisfying (2.1). For every object X of C deﬁne qX : X → (cid:73)X as follows:
consider

fX = ((cid:73)((cid:73)X × X) × X

(cid:73)πr×X /

/(cid:73)X × X )

and form

qX = (X

†
X /

f

/(cid:73)X × X

π(cid:96)

/(cid:73)X ).

13

/
/
/
/
/
/
/
/
/
/




/


9
9
%
%
/
Lemma 3.2.

1. If † satisﬁes the parameter identity and uniformity, then q : Id → (cid:73) is a natural trans-

formation.

2. If † satisﬁes the ﬁxpoint identity, then qX = pX for all X.

Proof. 1. For every morphism h : X → Y we have the following diagram:

X

h

Y

†
X

f

†
Y

f

(fY ·((cid:73)((cid:73)Y ×Y )×h))†

qX
(cid:9)

(cid:73)X × X
(cid:73)h×h
/ (cid:73)Y × Y
(cid:9)
qY

π(cid:96)

(cid:9)

π(cid:96)

(cid:73)X
(cid:73)h
/ (cid:73)YO

Of the left-hand square, the lower left-hand triangle commutes by the parameter identity and
the upper right-hand triangle by uniformity since we have

(cid:73)((cid:73)X × X) × X

(cid:73)((cid:73)h×h)×X

(cid:73)((cid:73)h×h)×h
(cid:73)((cid:73)Y × Y ) × X (cid:73)((cid:73)Y ×Y )×h

(cid:9)

fX =
(cid:73)πr×X

(cid:9)

(cid:73)((cid:73)Y × Y ) × Y

(cid:73)πr×Y
fY =

/ (cid:73)X × X
(cid:73)h×h
(cid:73)Y × Y

2. Notice ﬁrst that from the ﬁxpoint identity for f

πr · f

†
X

†
X we have:
(†)
†
X , X(cid:105)
= πr · fX · (p(cid:73)X×X × X) · (cid:104)f
= πr · ((cid:73)πr × X) · (p(cid:73)X×X × X) · (cid:104)f
= idX

†
X , X(cid:105)

Then we consider the following diagram:

X

∆

†
X

f

X × X

p×X

(cid:73)X × X

p×X
(cid:73)πr×X
(cid:9)
/ (cid:73)((cid:73)X × X) × X

(cid:9)

†
X ,X(cid:105)
(cid:104)f
(cid:73)X × X × X

πr×X

(nat. of p)

†
X = π(cid:96) · (pX × X) · ∆ = pX .

Since its outside commutes by the ﬁxpoint identity so does the upper inner triangle. It follows
that we have qX = π(cid:96) · f
Deﬁnition 3.3. A guarded ﬁxpoint category (C, (cid:73),†) satisfying the Conway axioms (i.e.
ﬁxpoint, parameter, composition and double dagger identities) is called a guarded Conway
category.
If in addition uniformity is satisﬁed, we call (C, (cid:73),†) a uniform guarded Conway category.

14

/
/


*
*
/
/






/
/
O


*
*
/


/
/
/
/
/
/


)
)
5
5
6
6
/
O
O
Note that an example of a guarded ﬁxpoint category that is not a guarded Conway category
and an example of a guarded Conway category that is not a uniform guarded Conway category
exist already in the realm of iteration theories of Bloom and ´Esik (cf. Examples 2.4.1). See
´Esik [15], Model 2 and Section 3, respectively.
Theorem 3.4. A unique guarded ﬁxpoint category (C, (cid:73)) is a uniform guarded Conway cat-
egory.
Proof. We shall prove that † satisﬁes the Conway axioms and uniformity.
(1) The ﬁxpoint identity for † is satisﬁed by deﬁnition of a unique guarded ﬁxpoint category.
(2) Parameter identity. Given f : (cid:73)X × Y → X and h : Z → Y we have

Z

(cid:104)f†·h,Z(cid:105)

h

(cid:9)

Y
(cid:104)f†,Y (cid:105)

X × Y

X×h

X × Z

pX×Z

f†

(cid:9) by (†)

pX×Y
(cid:9)

/ X

f

(cid:73)X × Y

(cid:73)X×h
/ (cid:73)X × Z

Thus, f† · h ﬁts square (2.1) for f · ((cid:73)X × h), and thus we have the desired equation by the
uniqueness of (f · ((cid:73)X × h))†.

(3) Composition Identity. Let f and g be as in the deﬁnition of the identity. Then we have

(f·((cid:73)g×Y ))†

Y

Z

f

(cid:104)(f·((cid:73)g×Y ))†,Y (cid:105)

(cid:9) by (†)

(cid:73)X × Y
(cid:73)g×Y
(cid:73)Z × Y

pZ×Y
(cid:9) by nat. of p

pX×Y

Z × Y
g×Y
X × Y

g

(cid:9)

f

(cid:9)

/ X

g

Z

f

(cid:73)g×Y

/ (cid:73)X × Y

Since the outside commutes we obtain the desired equation by the unicity of (g · f )†.

(4) Double Dagger Identity. Let f : (cid:73)X × (cid:73)X × Y → X. Then we have

Y

f††

(cid:9) by (†)

(cid:73)X × Y

f†

(cid:9) by (†)

X

f

(cid:104)f†,(cid:73)X×Y (cid:105)

(cid:104)(∗),(cid:9),(cid:9)(cid:105)
X × (cid:73)X × Y

((X×pX )·∆)×Y

pX×Y

15

(cid:104)f††,Y (cid:105)

pX×Y

X × Y

pX×(cid:73)X×Y

(cid:9)

(cid:73)X × (cid:73)X × Y

∆×Y
/ (cid:73)X × Y



/
/


/
/
/
O
O
7
7
/
O
O
/
/


/
O
O
/
/
O
O
/
/


O
O
(
(
/
O
O
/
/


4
4


/
/
O
O
5
5
5
5
/
O
O
We do not claim that part (∗) commutes, but it commutes when precomposed with (cid:104)f††, Y (cid:105).
This is because the lower passage yields simply f†† and the upper passage yields f† · (pX ×
Y ) · (cid:104)f††, Y (cid:105), which is equal to f†† by the ﬁxpoint identity. We conclude that the outside of
the diagram commutes and so we obtain the desired equality by the unicity of (f · (∆× Y ))†.

(5) Uniformity. Let f , g and h be as in the deﬁnition of uniformity. Then we have

Y

f†

(cid:104)f†,Y (cid:105)

(cid:9) by (†)

(cid:104)h·f†,Y (cid:105)

(cid:9)

X × Y

X

f

(cid:73)X × Y

h×Y

X(cid:48) × Y

pX×Y

(cid:9) by nat. of p

pX(cid:48)×Y

X(cid:48)

g

h

(cid:9)

(cid:73)h×Y

/ (cid:73)X(cid:48) × Y

Since the outside commutes we obtain h · f† = g† by unicity of g†.
Example 3.5. Coming back to Example 2.15 we see that the unique † in Examples 2.4.(2)–
(5 and the one for the example of completely iterative monads in Section 2.2 satisfy all the
properties in Deﬁnition 3.1. But Example 2.15 also entails that for let-ccc’s with ﬁxpoint
objects of Example 2.4.(7) one cannot hope for uniqueness. So how about all the properties
of Deﬁnition 3.1?
Theorem 3.6. Let (C, T, η, µ, s, T Ω σ−→ Ω, 1 ω−→ Ω) be a let-ccc with a ﬁxpoint object, let
(cid:73) = T and for any f : Y × T X → X deﬁne f† = it(f ) · (Y × ω), as in Example 2.4.(7).
Then (cid:73) satisﬁes all properties introduced in Deﬁnition 3.1, except, possibly, the double dagger
identity (††).

We will see in Theorem 3.7 below that for the special case where C = CPO and T = (−)⊥

(see Example 2.4.(6)) more can be shown.
∗
Proof. Recall ﬁrst the 4 axioms (a)–(d) of the operation (−)
observe that the action of T on a morphism g : Z = 1 × Z → X is deﬁned by

from Example 2.4.(7). Further

T g = (ηX · g)

∗

: T Z = 1 × T Z → T X.

(3.1)
Notice that axioms (a) and (d) imply for f : B → T C and g : C → T D (i.e. the special case
for A = 1) the usual extension laws of Manes [24, Deﬁnition 2.13]:
= g∗ · f∗.

(3.2)
Finally, recall that for let-ccc’s we write T = (cid:73) on the right-hand side of product compo-
The ﬁxpoint identity (†). Take f : Y × T X → X. Then:

f∗ · ηB = f

∗
(g∗ · f )

nents.

and

Y = Y × 1
Y ×ω
(cid:9)

(cid:104)π(cid:96),f†(cid:105)

(cid:104)π(cid:96),it(f )(cid:105)

Y × X

f†
(cid:9)

Y ×ω

(cid:9) by def. of ω
Y × Ω

Y ×η

(cid:9) by axiom (a)

Y × Ω
Y ×σ
Y × T Ω

it(f )

/ X

(cid:9) by (2.2)

f

(cid:104)π(cid:96),(η·it(f ))∗(cid:105)

/ Y × T X

Y ×η

16

/
/


'
'
/
/
/
/
w
w
O
O
(
(
/
O
O
/
/
&
&


/


/
/
x
x
&
&
O
O
/
O
O
The parameter identity (P). Take f : Y ×T X → X and h : Z → Y , and deﬁne g = f·(h×T X).
Then

(f·(h×T X))†

Z = Z × 1

h=h×1

Z×ω

(cid:9)

Z×ω

(cid:9) by def. of ω
Z×η

Z × Ω

h×Ω

Y = Y × 1

Y ×ω

(cid:104)(cid:9),(∗)(cid:105)

(cid:104)(cid:9),(∗∗)(cid:105)

(cid:9) by (2.2)
(cid:104)π(cid:96),(ηX·it(g))∗(cid:105)

/ Z × Ω
Z×σ
Z × T Ω
h×T Ω
Y × T Ω (cid:104)π(cid:96),(ηX·it(f ))∗(cid:105)
Y ×σ
Y × Ω

(cid:9) by (2.2)

it(g)

Z × T X
h×T X
Y × T X

it(f )

(cid:9)

(cid:9)

(cid:9)

g

f

X

The part (∗) by itself does not need to commute, but it does when precomposed with ω. The
task reduces then to showing (∗∗), viz. the equation

(ηX · it(f ))

∗ · (h × T Ω) = (ηX · it(f · (h × T X)))
∗

.

f†

By axiom (c), this reduces to showing

(ηX · it(f ) · (h × Ω))

∗

∗
= (ηX · it(f · (h × T X)))

.

To show this it is suﬃcient to prove

it(f ) · (h × Ω) = it(f · (h × T X)).

A proof of this relies on it(−) being the unique morphism satisfying a suitable instance of
(2.2):

h×Ω

(cid:9)

h×T Ω

Z × Ω

Z×σ

Z × T Ω

Y × Ω
Y ×σ
Y × T Ω

it(f )

(cid:9) by (2.2)

X

f

(cid:104)π(cid:96),(η·it(f ))∗(cid:105)

/ Y × T X
h×T X
Z × T X

(cid:104)(cid:9),((cid:63))(cid:105)

(cid:104)π(cid:96),(η·it(f )·(h×Ω))∗(cid:105)

and we get ((cid:63)) by axiom (c) again.

Composition Identity (C). Assume f : Y × T X → Z and g : Z → X. We want to show:

it(g · f ) · (Y × ω) = g · it(f · (Y × T g)) · (Y × ω).

For this, it is enough to show

it(g · f ) = g · it(f · (Y × T g)).

17

)
)




/
 
 
/
/
#
#


/
/
O
O


(
(
/
/


/
/
/
/
O
O
6
6
/
/
/
/
O
O
/
O
O
O
O
5
5
/
/
O
O
We again use the fact that it(−) is the unique morphism satisfying a suitable instance of (2.2),
which in this case is:

Y × Ω

it(f·(Y ×T g))

/ Z
f·(Y ×T g)

Y ×σ

(cid:9) by (2.2)

Y × T Z

(cid:104)π(cid:96),(η·it(f·(Y ×T g)))∗(cid:105)

(cid:104)(cid:9),(∗)(cid:105)

g

(cid:9)
Y ×T g

/ X

g

Z

f

Y × T X

(cid:104)π(cid:96),(η·g·it(f·(Y ×T g)))∗(cid:105)

= (ηX · g)

∗ ·(cid:0)ηZ · it(f · (Y × T g))(cid:1)∗
∗ · ηZ · it(f · (Y × T g))(cid:1)∗

= (cid:0)(ηX · g)
= (cid:0)ηX · g · it(f · (Y × T g))(cid:1)∗

by (3.1)
by (3.2)
by (3.2).

Y × T Ω

For part (∗) we compute

T g ·(cid:0)ηZ · it(f · (Y × T g))(cid:1)∗

Uniformity (U). Assume f : Y × T X → X, g : Y × T X(cid:48) → X(cid:48) and h : X → X(cid:48) are such
that h · f = g · (Y × T h) holds. Our goal is to show h · f† = g†, for which it is suﬃcient to
show it(g) = h · it(f ). Once again, we rely on initiality property (2.2), i.e., we need to show:

Y × Ω

it(f )

X

h

Y ×σ

Y × T Ω

(cid:9) by (2.2)

(cid:9) by assumption

f

Y × T X
(cid:104)(cid:9),(∗)(cid:105)

(cid:104)π(cid:96),(η·it(f ))∗(cid:105)

Y ×T h

(cid:104)π(cid:96),(η·h·it(f ))∗(cid:105)

Y × T X(cid:48)

X(cid:48)

g

For (∗) we reason as follows:

∗
T h · (ηX · it(f ))

= (ηX(cid:48) · h)
= ((ηX(cid:48) · h)
∗
= (ηX(cid:48) · h · it(f ))

∗ · (ηX · it(f ))
∗
∗
∗ · ηX · it(f ))

by (3.1)
by (3.2)
by (3.2).

Theorem 3.7. The category CPO with (cid:73) = (−)⊥ and the dagger given by least ﬁxpoint as
in Example 2.4.(6) satisﬁes all the properties of Deﬁnition 3.1.
Proof. In the light of Theorem 3.6, we only need to show (††). We use the notation of
In addition, for any f : X⊥ × Y → X, we deﬁne continuous functions
Example 2.4.(6).
sn : Y → X⊥, n ∈ N as

so that the least ﬁxpoint of Φf is s =(cid:70)

s0 = λy.⊥,

n∈N sn.

sn+1 = Φf (sn)

Now suppose we are given f : X⊥ × X⊥ × Y → X. To prove (††) we will ﬁrst show that the

least ﬁxpoints s of Φf† and s(cid:48) of Φf·(∆×Y ) coincide, i.e. we prove (a) s (cid:118) s(cid:48) and (b) s(cid:48) (cid:118) s.

18

/
/
O
O
)
)
O
O
O
O
5
5
/
/
O
O
/
/
/
/
O
O
(
(
6
6
O
O
/
/
O
O
For (a), it suﬃces to show that s(cid:48) is a preﬁxpoint of Φf†, i.e.

pX · f† · (cid:104)s(cid:48), Y (cid:105) (cid:118) s(cid:48).

To see this let s(cid:48)(cid:48) be the least ﬁxpoint of Φf . We will prove that

s(cid:48)(cid:48) · (cid:104)s(cid:48), Y (cid:105) = s(cid:48).

by showing the two inequalities below by induction on n:

n · (cid:104)s(cid:48), Y (cid:105) (cid:118) s(cid:48)
s(cid:48)(cid:48)

and

n (cid:118) s(cid:48)(cid:48) · (cid:104)s(cid:48), Y (cid:105).
s(cid:48)

Note that the left-hand inequalities above already imply (3.3) using that

pX · f† = pX · f · (cid:104)s(cid:48)(cid:48), Y (cid:105) = Φf (s(cid:48)(cid:48)) = s(cid:48)(cid:48).

(3.3)

(3.4)

(3.5)

The right-hand inequalities in (3.5) will be used at the end of our proof.

For the induction proofs the base cases are obvious: ⊥·(cid:104)s(cid:48), Y (cid:105) = ⊥ (cid:118) s(cid:48) and ⊥ (cid:118) s(cid:48)(cid:48)·(cid:104)s(cid:48), Y (cid:105).

For the induction steps we obtain
n+1 · (cid:104)s(cid:48), Y (cid:105) = pX · f · (cid:104)s(cid:48)(cid:48)
s(cid:48)(cid:48)

n, X⊥ × Y (cid:105) · (cid:104)s(cid:48), Y (cid:105)
(cid:118) pX · f · (cid:104)s(cid:48), X⊥ × Y (cid:105) · (cid:104)s(cid:48), Y (cid:105)
= pX · f · (cid:104)s(cid:48), s(cid:48), Y (cid:105)
= pX · f · (∆ × Y ) · (cid:104)s(cid:48), Y (cid:105)
= s(cid:48)

n+1 = Φf (s(cid:48)(cid:48)
n)

since s(cid:48)(cid:48)
by induction hypothesis

since s(cid:48) = Φf·(∆×Y )(s(cid:48))

and

n+1 = pX · f · (∆ × Y ) · (cid:104)s(cid:48)
s(cid:48)

n, Y (cid:105)
= pX · f · (cid:104)s(cid:48)
(cid:118) pX · f · (cid:104)s(cid:48)(cid:48) · (cid:104)s(cid:48), Y (cid:105), s(cid:48), Y (cid:105)
= pX · f · (cid:104)s(cid:48)(cid:48), X⊥ × Y (cid:105) · (cid:104)s(cid:48), Y (cid:105)
= s(cid:48)(cid:48) · (cid:104)s(cid:48), Y (cid:105)

n, s(cid:48)

n, Y (cid:105)

n+1 = Φf·(∆×Y )(s(cid:48)
n)

since s(cid:48)
by induction hypothesis and s(cid:48)
since s(cid:48)(cid:48) = Φf (s(cid:48)(cid:48)).

n (cid:118) s(cid:48)

For inequality (b) we prove by induction on n that sn (cid:118) s(cid:48) holds for all n. The base case
n (cid:118) s. Then we consider the

is again trivial: ⊥ (cid:118) s(cid:48). For the induction step suppose that s(cid:48)
following diagram

s(cid:48)

n+1

(cid:118)
s

(cid:9) since s = Φf† (s)

f†
(cid:104)f†,X⊥×Y (cid:105)

X⊥

pX

X

(cid:9) by (†)

Y
(cid:118)

(cid:104)s,Y (cid:105)

(cid:104)s(cid:48)
n,Y (cid:105)
X⊥ × Y

∆×Y

(cid:104)(∗),(cid:9),(cid:9)(cid:105)

X × X⊥ × Y

X⊥ × X⊥ × Y

pX×X⊥×Y

f

n) and (∗) commutes when extended by (cid:104)s, Y (cid:105)
Its outside commutes since s(cid:48)
since s is a ﬁxpoint of Φf†. The equalities in the diagram together with the inequality obtained

n+1 = Φf·(∆×Y )(s(cid:48)

19

-
-
1
1




/
/
(
(


O
O
v
v
O
O
from the induction hypothesis in the upper left-hand corner yield the desired inequality in
the top row.

We are now ready to prove the desired equality f†† = (f · (∆ × Y ))†:

f†† = f† · (cid:104)s, Y (cid:105)

= f · (cid:104)s(cid:48)(cid:48), Y (cid:105) · (cid:104)s, Y (cid:105)
= f · (cid:104)s(cid:48)(cid:48), Y (cid:105) · (cid:104)s(cid:48), Y (cid:105)
= f · (cid:104)s(cid:48), s(cid:48), Y (cid:105)
= f · (∆ × Y ) · (cid:104)s(cid:48), Y (cid:105)
= (f · (∆ × Y )†

by def. of f††
by def. of f†
since s = s(cid:48)
by (3.4)
by def. of (−)†

This completes the proof.

Open Problem 3.8. Do let-ccc’s with ﬁxpoint objects with the dagger deﬁned as in Exam-
ple 2.4.(7) satisfy the double dagger property (††)?

We do not see how an argument using two inequalities as in (a) and (b) as well as in (3.5)
generalizes to let-ccc’s. However, as the ﬂagship Example 2.4.(6) satisﬁes (††), we believe
that a counterexample might be intricate.

3.1. The Bekiˇc Identity

We generalize here the known fact that the double dagger identity can be replaced by the Bekiˇc
identity (also known as the pairing identity) among axioms of unguarded Conway theories
(see, e.g., [32], [9, Ch. 6.2, 6.8–6.9], [16], [19, Ch. 7.1] and references therein). We will make
use of this in our discussion of another property, dinaturality, in Section 3.2 and also in the
discussion of trace operators in Section 4.

Deﬁnition 3.9. We introduce the following possible property of a guarded ﬁxpoint category
(C, (cid:73),†):
Bekiˇc identity (Bˇc). For any f : (cid:73)X × (cid:73)Y × A → X and g : (cid:73)X × (cid:73)Y × A → Y ,

can×A /

/(cid:73)X × (cid:73)Y × A

(cid:104)f,g(cid:105)

/X × Y(cid:1)†

where

(cid:0)(cid:73)(X × Y ) × A
eR =(cid:0)(cid:73)Y × A
eL =(cid:0)(cid:73)X × A

(cid:104)pX·f†,(cid:73)Y ×A(cid:105)

†
(cid:73)X×(cid:104)pY ·e
R,A(cid:105)

/(cid:73)X × (cid:73)Y × A
/(cid:73)X × (cid:73)Y × A

g

f

†
†
R(cid:105),
= (cid:104)e
L, e

/Y(cid:1),
/X(cid:1).

Proposition 3.10. The Bekiˇc identity holds in each guarded Conway category (C, (cid:73),†).
Proof. First observe that can = ((cid:73)π(cid:96) × (cid:73)πr) · ∆:
(cid:73)(X×Y )

(cid:73)(X × Y )

(cid:73)(∆)

(cid:73)((X × Y ) × (X × Y ))

(cid:73)(π(cid:96)×πr)

(cid:73)(X × Y )

∆

(cid:9)

can

(cid:9)

can

(cid:73)(X × Y ) × (cid:73)(X × Y ) (cid:73)π(cid:96)×(cid:73)πr

/ (cid:73)X × (cid:73)Y

20

/
/
/
/
/
/
/
*
*
/
/






/
Next we compute:

((cid:104)f, g(cid:105) · (can × A))† = ((cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)πr × A) · (∆ × A))†

(††)
= ((cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)πr × A))††
= ((cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)Y × A) · ((cid:73)(X × Y ) × (cid:73)πr × A))††
= (((cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)Y × A))† · ((cid:73)πr × A))†

(P )

Now let h = (cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)Y × A) : (cid:73)(X × Y ) × (cid:73)Y × A → X × Y . Then we have

π(cid:96) · h† = π(cid:96) · ((cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)Y × A))†

(C)

= (π(cid:96) · (cid:104)f, g(cid:105))†
= f†.

And we have

(cid:104)h†,(cid:73)Y ×A(cid:105)

(cid:73)Y ×A

(cid:104)f†,(cid:73)Y ×A(cid:105)

X×Y ×((cid:73)Y ×A)
(cid:9)

π(cid:96)×(cid:73)Y ×A
X×(cid:73)Y ×A

h†

(cid:9) by (†)
p×((cid:73)Y ×A)
(cid:9) by nat. of p

p×(cid:73)Y ×A

(cid:73)(X×Y )×(cid:73)Y ×A

(cid:73)π(cid:96)×(cid:73)Y ×A
/ (cid:73)X×(cid:73)Y ×A

(cid:9)

h

g

X×Y

πr

/ Y

(3.6)

Plugging h into our ﬁrst computation above we obtain

πr · ((cid:104)f, g(cid:105) · (can × A))† = πr · (h† · ((cid:73)πr × A))†

(3.6)

(C)

= (πr · h†)†
= (g · (pX × (cid:73)Y × A) · (cid:104)f†, (cid:73)Y × A(cid:105))†
= (g · (cid:104)pX · f†, (cid:73)Y × A(cid:105))†
= e

†
R.

Let z = (cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)πr × A). We saw previously that ((cid:104)f, g(cid:105) · (can × A))† = z††; thus

we have

π(cid:96) · ((cid:104)f, g(cid:105) · (can × A))† = π(cid:96) · z††

(†)
= π(cid:96) · z† · (pX×Y × A) · (cid:104)z††, A(cid:105)
= π(cid:96) · z† · (cid:104)pX×Y · z††, A(cid:105)

= π(cid:96) ·(cid:0)z · ((cid:73)(X × Y ) × (cid:104)pX×Y · z††, A(cid:105))(cid:1)†

(P )

(∗)

Substitute the deﬁnition of z and use that

to obtain that (∗) is equal to

†
(cid:73)πr · pX×Y · z†† = pY · πr · z†† = pY · πr · ((cid:104)f, g(cid:105) · (can × A))† = pY · e
R

π(cid:96) ·(cid:0)(cid:104)f, g(cid:105) · ((cid:73)π(cid:96) × (cid:73)πr × A) · ((cid:73)(X × Y ) × (cid:104)pX×Y · z††, A(cid:105))(cid:1)†

†
= π(cid:96) · ((cid:104)f, g(cid:105) · ((cid:73)X × (cid:104)pY · e
R, A(cid:105)) · ((cid:73)π(cid:96) × A))†
†
= (π(cid:96) · (cid:104)f, g(cid:105)
R, A(cid:105)))†
·((cid:73)X × (cid:104)pY · e

(C)

(cid:124)

(cid:123)(cid:122)

=f

(cid:125)

†
= e
L.

This completes the proof.

21

/
/
)
)


/
/
/
/






/
/
Remark 3.11. Notice that the Bekiˇc identity can also be formulated without mentioning eL.
In fact, by the parameter identity we have

†
L = (A

e

(cid:104)pY ·e

†
R,A(cid:105)

/(cid:73)Y × A

f†

/X ).

(3.7)

Proposition 3.10 states the Bekiˇc identity can be derived from Conway laws. But it can
be also postulated directly as an axiom replacing (††). This is a guarded counterpart of
Proposition 5.3.15 in Bloom and ´Esik [9]:
Proposition 3.12. Each guarded ﬁxpoint category (C, (cid:73),†) satisfying the ﬁxpoint, parameter,
composition and Bekiˇc identities is a guarded Conway category.
Proof. We must derive (††) from the identities listed in the statement. Given f : (cid:73)X ×(cid:73)X ×
A → X we apply the Bekiˇc identity to obtain

where
By the ﬁxpoint identity we have eR = f†. Thus, we obtain

eR = f · (cid:104)pX · f†, (cid:73)X × A(cid:105)

†
†
((cid:104)f, f(cid:105) · (can × A))† = (cid:104)e
R(cid:105),
L, e
†
eL = f · ((cid:73)X × (cid:104)pX · e
R, A(cid:105)).

and

†
f†† = e
R

(Bˇc)

· (f · (can × A) · ((cid:73)(∆X ) × A))†

(C)

= πr · ((cid:104)f, f(cid:105) · (can × A))†
= πr · (∆X · f · (can × A))†
= πr · ∆X
= (f · (∆(cid:73)X × A))†,

(cid:124) (cid:123)(cid:122) (cid:125)

=idX

where the last equation follows from

can · (cid:73)(∆X ) = (cid:104)(cid:73)π(cid:96), (cid:73)πr(cid:105) · (cid:73)(∆X ) = (cid:104)(cid:73)(idX ), (cid:73)(idX )(cid:105) = (cid:104)id(cid:73)X , id(cid:73)X(cid:105) = ∆(cid:73)X .

This completes the proof.

3.2. Dinaturality

Finally, we discuss a property that is essentially a parametrized version of the composition
In fact, Bloom and ´Esik [9] use the very name composition identity in this con-
identity.
text, calling the unguarded counterpart of our earlier (C) the simpliﬁed composition identity
instead. As it turns out, this property and its variants are not easy to understand in the
guarded setting, leaving us with Open Problems 3.16 and 3.17. But ﬁrst, let us state basic
notions and facts.

Deﬁnition 3.13. We introduce the following possible property of a guarded ﬁxpoint category
(C, (cid:73),†):
Dinaturality (D). For every f : (cid:73)X × A → Y and g : (cid:73)Y × A → X,

((cid:73)X × A

(cid:104)pY ·f,πr(cid:105)

/(cid:73)Y × A

g

/X )† = A

(cid:104)pY ·h†,A(cid:105)

/(cid:73)Y × A

g

/X,

where h = ((cid:73)Y × A

(cid:104)pX·g,πr(cid:105)

/(cid:73)X × A

f

/Y ).

22

/
/
/
/
/
/
/
/
For unguarded ﬁxpoint operators, it is well-known that the four Conway axioms are equiv-
alent to dinaturality, the parameter and double dagger identities (D, P, ††), in other words,
dinaturality can replace the ﬁxpoint and composition identities (see, e.g., [32], [9, Ch. 6.2,
6.8–6.9], [16], [19, Ch. 7.1] and references therein). Proposition 3.15 below shows that we can
derive dinaturality from the Conway axioms at the price of extra assumptions on (cid:73). However,
no extra assumptions are needed for:
Proposition 3.14. Dinaturality holds in each unique guarded ﬁxpoint category (C, (cid:73)).

Proof. Given f , g and h as in the deﬁnition of dinaturality, we only need to prove that
g ·(cid:104)pY · h†, A(cid:105) : A → X satisﬁes the ﬁxpoint identity (2.1) w.r.t. g ·(cid:104)pY · f, πr(cid:105) : (cid:73)X × A → X.
Consider the diagram below:

A
(cid:104)pY ·h†,A,A(cid:105)

(cid:104)pY ·h†,A(cid:105)
(cid:9)
(cid:73)Y × A × A

(cid:73)Y ×∆

(cid:104)pY ·h†,A(cid:105)
(cid:104)h†,A(cid:105)
(cid:73)Y × A

(cid:9)

g×A
X × A

(cid:73)Y × A
pY ×A

Y × A

(cid:9)

(cid:104)(∗),(cid:9)(cid:105)

(cid:104)pX·g,πr(cid:105)

pX×A

g

(cid:9)

pY ×A /
(cid:104)f,πr(cid:105)

X

g

/ (cid:73)Y × A
(cid:9)
/ (cid:73)X × A

(cid:104)pY ·f,πr(cid:105)

For (∗), recall h = f · (cid:104)pX · g, πr(cid:105) and then apply the ﬁxpoint identity.
Proposition 3.15. Dinaturality holds in each guarded Conway category (C, (cid:73),†) such that
(cid:73) preserves products and is well-pointed (i.e. we have (cid:73)p = p(cid:73)).

Proof. We prove this property from the ﬁxpoint, composition and Bekiˇc identities. Given
f : (cid:73)X × A → Y and g : (cid:73)Y × A → X, let k = (cid:104)pY · f, πr(cid:105). By (C), we have

(g · k)† = (A

(k·((cid:73)g×A))†

/(cid:73)Y × A

g

/X ).

Thus, in order to complete the proof it suﬃces to show that

(cid:104)pY · h†, A(cid:105) = ((cid:73)((cid:73)Y × A) × A

/(cid:73)Y × A)†.
Since (cid:73) preserves products, we have can−1 : (cid:73)(cid:73)Y × (cid:73)A → (cid:73)((cid:73)Y × A). Now let

/(cid:73)X × A

k

(cid:73)g×A /

m = pY · f · ((cid:73)g × A) · (can−1 × A) : (cid:73)(cid:73)Y × (cid:73)A × A → (cid:73)Y,
n = πr : (cid:73)(cid:73)Y × (cid:73)A × A → A.

Then we clearly have (cid:104)m, n(cid:105) · (can × A) = k · ((cid:73)g × A). Now we apply the Bekiˇc identity to
obtain

†
†
((cid:104)m, n(cid:105) · (can × A))† = (cid:104)e
R(cid:105) : A → (cid:73)Y × A,
L, e

where

eR

eL

by def

= n · (cid:104)p(cid:73)Y · m†, (cid:73)A × A(cid:105) = πr : (cid:73)A × A → A
†
R, A(cid:105)) : (cid:73)(cid:73)Y × A → (cid:73)Y.
= m · ((cid:73)(cid:73)Y × (cid:104)pA · e

by def

23



/
/
+
+
(
(
/
/


o
o
+
+
O
O
O
O
/
O
O
g
g
/
/
/
Using eR = πr we see that e

†
Thus we obtain e
L

†
R

(†)
= eR · (pA × A) · (cid:104)e

eL = pY · f · ((cid:73)g × A) · (can−1 × A)

(cid:124)
= pY ·(cid:0)f · ((cid:73)g × A) · (can−1 × A) · ((cid:73)(cid:73)Y × (cid:104)pA, A(cid:105)) · ((cid:73)pY × A)(cid:1)†

†
R, A(cid:105) = idA. So we have
(cid:125)
·((cid:73)(cid:73)Y × (cid:104)pA, A(cid:105)).

(cid:123)(cid:122)

(C)

m

= pY · (f · (cid:104)pX · g, πr(cid:105))†,

f (cid:46) g =(cid:0)(cid:73)Y × A
(cid:0)(cid:73)X × A

where the second equation is derived as follows: it is suﬃcient to prove that the two morphisms
inside † after removal of f are equal, and for this one considers the product components of
(cid:73)X × A (their codomain) separately. The right-hand component is obviously πr and the
left-hand one follows from
pX · g

(cid:73)g · p(cid:73)Y ×A = (cid:73)g · can−1 · ((cid:73)pY × pA),

(nat. of p)

=

where the second equation is derived using well-pointedness of (cid:73): can · p(cid:73)Y ×A = p(cid:73)Y × pA =
(cid:73)pY × pA.
Open Problem 3.16. Do (D, P, ††) imply the ﬁxpoint and simpliﬁed composition identities?
Further inspection reveals a curious asymmetry here. Under the assumption that (cid:73) pre-
serves products one can formulate two related versions of dinaturality where the given mor-
phisms only contain one (cid:73). For these properties we use for given f : (cid:73)X × A → Y and
g : Y × A → X the morphism

(cid:73)Y ×(cid:104)pA,A(cid:105)

/(cid:73)Y × (cid:73)A × A

can−1×A /

/(cid:73)(Y × A) × A

(cid:73)g×A /

/(cid:73)X × A

f

/Y(cid:1).

Property (D1). Given f : (cid:73)X × A → Y and g : Y × A → X we have

/Y × A
Property (D2). Given f : X × A → Y and g : (cid:73)Y × A → X we have

/Y × A

g

(cid:104)(f (cid:46) g)†,A(cid:105)

(cid:104)f,πr(cid:105)

/X(cid:1)†

=(cid:0)A

/X(cid:1).

g

where h =(cid:0)(cid:73)Y × A

(cid:104)g,πr(cid:105)

/X × A

f

/Y(cid:1).

(g (cid:46) f )† = g · (cid:104)pY · h†, A(cid:105),

Whenever (cid:73) is moreover well-pointed, each of (D1) and (D2) implies (D). One also readily
proves, by adapting the proofs for unguarded operators, that (D1) implies the simpliﬁed
composition identity (C) and that (D2) implies the ﬁxpoint identity (†). Conversely, the
Conway axioms imply the ﬁrst version of dinaturality (D1). For the sake of brevity we leave
the details to the reader. What defeats us at the moment is:

Open Problem 3.17.

• Do the Conway axioms imply (D2)?
• Does (D1) imply (D2)?

24

/
/
/
/
/
/
/
/
4. Guarded Trace Operators
In the special case of Example 2.4.(1), i.e., (cid:73) being the identity functor, it is well-known that
a ﬁxpoint operator satisfying the Conway axioms is equivalent to a trace operator w.r.t. the
product on C [18, 19]. In this section we present a similar result for a generalized notion of a
guarded trace operator on (C, (cid:73)).
Remark 4.1. Recall that Joyal, Street and Verity [20] introduced the unguarded notion of
a trace operator for (symmetric) monoidal categories. The applicability to non-cartesian
tensor products is in fact one of main reasons of its popularity. Our generalization can also be
formulated in the symmetric monoidal setting, see Remark 4.3 below. However, Theorems 4.5
and 4.7, the main results in this section, do not make any use of this added generality. Hence,
we keep the Assumption 2.1 like in the remainder of the paper.
Deﬁnition 4.2. A (cartesian) guarded trace operator on (C, (cid:73)) is a natural family of opera-
tions

A,B : C((cid:73)X × A, X × B) → C(A, B)
TrX

subject to the following three conditions:

1. Vanishing. (V1) For every f : (cid:73)1 × A → B ∼= 1 × B we have

A,B(f ) = (A ∼= 1 × A
Tr1

/(cid:73)1 × A
(V2) For every f : (cid:73)X × (cid:73)Y × A → X × Y × B we have
can×A /

p1×A /

A,B(TrX(cid:73)Y ×A,Y ×B(f )) = TrX×Y
TrY

A,B ((cid:73)(X × Y ) × A

f

/B ).

/(cid:73)X × (cid:73)Y × A

f /

/X × Y × B ).

2. Superposing (S). For every f : (cid:73)X × A → X × B we have
A,B(f ) × C.

A×C,B×C(f × C) = TrX
TrX

3. Yanking (Y). Consider the canonical isomorphism c : (cid:73)X × X → X × (cid:73)X. Then we

have

TrX

X,(cid:73)X (c) = (X

pX /

/(cid:73)X ).

If Tr is a (cartesian) guarded trace operator on (C, (cid:73)), (C, (cid:73), Tr) is called a guarded traced

(cartesian) category.

Of course, when (cid:73) is taken to be the identity on C as in Example 2.4.(1), our notion of
guarded trace specializes to the notion of an ordinary trace operator (w.r.t. product) of Joyal,
Street and Verity. In addition, the naturality of Tr can equivalently be expressed by three
more axioms, just like in the unguarded case:

4. Left-tightening (Lt). Given f : (cid:73)X × A → X × B and g : A(cid:48) → A we have

A(cid:48),B((cid:73)X × A(cid:48)
TrX

(cid:73)X×g

/(cid:73)X × A

f

/X × B ) = (A(cid:48)

g

/A

TrX

A,B(f )

/B ).

25

/
/
/
/
/
5. Right-tightening (Rt). Given f : (cid:73)X × A → X × B and g : B → B(cid:48) we have

A,B(cid:48)((cid:73)X × A
TrX

/B
6. Sliding (Sl). Given f : (cid:73)X × A → X(cid:48) × B and g : X(cid:48) → X we have

f

/X × B

X×g /

/X × B(cid:48) ) = (A

TrX

A,B(f )

g

/B(cid:48) ).

g×B /

(cid:73)g×A /

f

/X(cid:48) × B

A,B((cid:73)X(cid:48) × A

/X × B ) = TrX(cid:48)

A,B((cid:73)X × A
TrX

/X(cid:48) × B ).
Remark 4.3. The generalization for a symmetric monoidal category (C,⊗, I, c) equipped with
a pointed endofunctor (cid:73) : C → C requires the assumption that (cid:73) is comonoidal, i.e., equipped
with a morphism mI : (cid:73)I → I and a natural transformation mX,Y : (cid:73)(X ⊗ Y ) → (cid:73)X ⊗ (cid:73)Y
satisfying the usual coherence conditions. In fact, in the formulation of Vanishing (V2) we
used that in every category the product × is comonoidal via mX,Y = can.
Construction 4.4.

1. Let (C, (cid:73), Tr) be a guarded traced category. Deﬁne a guarded

/(cid:73)X × A

f

ﬁxpoint operator †Tr : C((cid:73)X × A, X) → C(A, X) by

f†Tr = TrX

A,X ((cid:73)X × A

(cid:104)f,f(cid:105)

/X × X ) : A → X.

2. Conversely, suppose (C, (cid:73),†) is a guarded ﬁxpoint category. Deﬁne Tr†X

A, X × B) → C(A, B) by setting for every f : (cid:73)X × A → X × B

A,B : C((cid:73)X ×

Tr†X

A,B(f ) = (A

(cid:104)(π(cid:96)·f )†,A(cid:105)

/X × A

pX×A

/(cid:73)X × A

f

/X × B

πr

/B ).

Theorem 4.5.

1. Whenever (C, (cid:73), Tr) is a guarded traced category, (C, (cid:73),†Tr) is a guarded

Conway category. Furthermore, Tr†Tr is the original operator Tr.

2. Whenever (C, (cid:73),†) is a guarded Conway category, (C, (cid:73), Tr†) is guarded traced. Fur-

thermore, †Tr† is the original operator †.

The proof details are similar to the unguarded case in Hasegawa [19]. As the derivation of
the guarded version of the Bekiˇc identity in Proposition 3.10 has already shown, it is not a
completely automatic adaptation. We give a complete proof in Appendix B below.

The process requires some creativity at times.
Hasegawa related uniformity of trace to uniformity of dagger and we can do the same
in the guarded setup. Recall that in iteration theories uniformity (called functorial dagger
implication) plays an important role. On the one hand, this quasiequation implies the so-
called commutative identities, an inﬁnite set of equational axioms that are added to the
Conway axioms in order to yield a complete axiomatization of ﬁxpoint operators in domains.
On the other hand, most examples of iteration theories actually satisfy uniformity, and so
uniformity gives a convenient suﬃcient condition to verify that a given Conway theory is
actually an iteration theory.
Deﬁnition 4.6. A guarded trace operator Tr is called uniform if for every f : (cid:73)X × A →
X × B, f(cid:48) : (cid:73)X(cid:48) × A → X(cid:48) × B and h : X → X(cid:48),

(cid:73)X × A
(cid:73)h×A
(cid:73)X(cid:48) × A

X × B
h×B
/ X(cid:48) × B

f

(cid:9)

f(cid:48)

=⇒

26

A,B(f ) = TrX(cid:48)

A,B(f(cid:48)) : A → B.

TrX

/
/
/
/
/
/
/
/
/
/
/
/




/
A uniform guarded traced category is a guarded traced category (C, (cid:73), Tr) where Tr is uniform.
1. Whenever (C, (cid:73), Tr) is a uniform guarded traced category, (C, (cid:73),†Tr) is

Theorem 4.7.

a uniform guarded Conway category.

2. Whenever (C, (cid:73),†) is a uniform guarded Conway category, (C, (cid:73), Tr†) is a uniform

guarded traced category.

The proof is in Appendix C.

Remark 4.8. Actually, Hasegawa proved a slightly stronger statement concerning uniformity
than what we stated in Theorem 4.7; he showed that a Conway operator is uniform w.r.t. any
ﬁxed morphism h : X → X(cid:48) (i.e. satisﬁes uniformity just for h) iﬀ the corresponding trace
operator is uniform w.r.t. this morphism h. The proof is somewhat more complicated and in
our guarded setting we leave this as an exercise to the reader.

Finally, let us note that the bijective correspondence between guarded Conway opera-
tors and guarded trace operators established in Theorem 4.5 yields an isomorphism of the
(2-)categories of (small) guarded Conway categories and guarded traced (cartesian) categories.
The corresponding notions of morphisms are, of course, as expected:

Deﬁnition 4.9.

1. F : (C, (cid:73)C,†) → (D, (cid:73)D,‡) is a morphism of guarded Conway cate-

gories whenever F : C → D is a ﬁnite-product-preserving functor satisfying

C (cid:73)C
(cid:9)

F

D (cid:73)D

C

F

/ D

and pD

F X = F (pC

X ) : F X → (cid:73)DF X = F ((cid:73)CX),

(4.1)

and preserving dagger, i.e., for every f : (cid:73)X × A → X we have

F (f†) = ((cid:73)DF X × F A ∼= F ((cid:73)CX × A)

F f /

/F X )‡.

2. A morphism F : (C, (cid:73)C, TrC) → (D, (cid:73)D, TrD) of guarded traced categories is a ﬁnite-
product-preserving F : C → D satisfying (4.1) above and preserving the trace operation:
for every f : (cid:73)CX × A → X × B in C we have
F (Tr XC A,B(f )) = Tr F XD F A,F B((cid:73)DF X × F A ∼= F ((cid:73)CX × A)

/F (X × B) ∼= F X × F B ).

F f /

Corollary 4.10. The (2-)categories of guarded Conway categories and of guarded traced
(cartesian) categories are isomorphic.

The proof is in Appendix D.

5. Conclusions and Future Work

We have made the ﬁrst steps in the study of equational properties of guarded ﬁxpoint opera-
tors popular in the recent literature [29, 30, 3, 6, 8, 22, 21, 8, 4, 23]. We began with an extensive
list of examples, including some not discussed so far as instances of delay endofunctors—e.g.,

27

/
/




/
Example 2.4.(6) or completely iterative theories in Section 2.2. Furthermore, we formulated
the four Conway axioms and the uniformity property in analogy to their unguarded counter-
parts and we showed their soundness w.r.t. the models discussed in Section 2. In particular,
Theorem 3.4 proved that our axioms hold in all categories with a unique guarded dagger. In
Theorem 4.5, we have a generalization of a result by Hasegawa for ordinary ﬁxpoint operators:
we proved that to give a (uniform) guarded ﬁxpoint operator satisfying the Conway axioms
is equivalent to giving a (uniform) guarded trace operator on the same category.

Our paper can be considered as a work in progress report. The long-term goal is to arrive
at completeness results similar to the ones for iteration theories. We do not claim that the
axioms we presented are complete. In the unguarded setting, completeness is obtained by
adding to the Conway axioms an inﬁnite set of equational axioms called the commutative
identities
[9, 31]. We did not consider those here, but we considered the quasi-equational
property of uniformity which implies the commutative identities and is satisﬁed in most models
of interest. Only further research can show whether this property can ensure completeness in
the guarded setup or one needs to postulate stronger ones.
Let us recall Open Problem 3.8 regarding soundness of (††) in the general setting of Crole
and Pitts [10, 11] and intriguingly complex status of guarded dinaturality leading to Open
Problems 3.16 and 3.17.

It would also be interesting to study further examples of guarded traced monoidal categories
which are not ordinary traced monoidal categories and which do not arise from guarded
Conway categories. We have obtained some such examples but more work is needed to
develop a full-blown theory. We postpone a detailed discussion to future work.

Acknowledgements We would like to thank the anonymous referees whose comments have
helped to improve the presentation of our paper. Thanks are also due to Aleˇs Bizjak for
providing us with Example 2.8. Besides, we would like to acknowledge an inspiring discussion
with Erwin R. Catesbeiana on (un-)productive (non-)termination. Finally, we have to credit
in general William and Arthur for their very insistence on modal undertones in modern
modelling of this major phenomenon (cf. [3, 17]).

References

[1] Aczel, P., Ad´amek, J., Milius, S., Velebil, J.: Inﬁnite Trees and Completely Iterative

Theories: A Coalgebraic View, Theoret. Comput. Sci., 300, 2003, 1–45.

[2] Ad´amek, J., Milius, S.: Terminal Coalgebras and Free Iterative Theories, Inform. and

Comput., 204, 2006, 1139–1172.

[3] Appel, A. W., Melli`es, P.-A., Richards, C. D., Vouillon, J.: A very modal model of a
modern, major, general type system, POPL (M. Hofmann, M. Felleisen, Eds.), ACM,
2007, ISBN 1-59593-575-4.

[4] Atkey, R., McBride, C.: Productive Coprogramming with Guarded Recursion, Proceed-
ings of the 18th ACM SIGPLAN International Conference on Functional Programming,
ICFP ’13, ACM, New York, NY, USA, 2013, ISBN 978-1-4503-2326-0.

[5] Badouel, E.: Terms and inﬁnite trees as monads over a signature, Lecture Notes Com-

put. Sci., 351, 1989, 89–103.

28

[6] Benton, N., Tabareau, N.: Compiling functional types to relational speciﬁcations for
low level imperative code, TLDI (A. Kennedy, A. Ahmed, Eds.), ACM, 2009, ISBN
978-1-60558-420-1.

[7] Birkedal, L., Møgelberg, R. E.: Intensional Type Theory with Guarded Recursive Types

qua Fixed Points on Universes, Proceedings of LICS, 2013.

[8] Birkedal, L., Møgelberg, R. E., Schwinghammer, J., Støvring, K.: First Steps in Synthetic
Guarded Domain Theory: Step-Indexing in the Topos of Trees, Logical Methods in
Computer Science, 8(4:1), 2012, 1–45.

[9] Bloom, S. L., ´Esik, Z.: Iteration Theories: the equational logic of iterative processes,

EATCS Monographs on Theoretical Computer Science, Springer, 1993.

[10] Crole, R. L.: Programming Metalogics with a Fixpoint Type, Ph.D. Thesis, Computer

Laboratory, University of Cambridge, 1991.

[11] Crole, R. L., Pitts, A. M.: New Foundations for Fixpoint Computations: FIX-

Hyperdoctrines and FIX-Logic, Inform. and Comput., 98(2), 1992, 171–210.

[12] Di Gianantonio, P., Miculan, M.: Unifying Recursive and Co-recursive Deﬁnitions in
Sheaf Categories,
in: Foundations of Software Science and Computation Structures
(I. Walukiewicz, Ed.), vol. 2987 of Lecture Notes in Computer Science, Springer Berlin
/ Heidelberg, 2004, ISBN 978-3-540-21298-0, 136–150, 10.1007/978-3-540-24727-2 11.

[13] Elgot, C. C.: Monadic Computation and Iterative Algebraic Theories, Logic Colloquium
’73 (H. E. Rose, J. C. Sheperdson, Eds.), 80, North-Holland Publishers, Amsterdam,
1975.

[14] Elgot, C. C., Bloom, S. L., Tindell, R.: On the algebraic structure of rooted trees,

J. Comput. System Sci., 16, 1978, 362–399.

[15] ´Esik, Z.: Independence of the Equational Axioms for Iteration Theories, J. Comput. Sys-

tem Sci., 36, 1988, 66–76.

[16] ´Esik, Z.: Fixed Point Theory, in: Handbook of Weighted Automata (M. Droste, W. Kuich,
H. Vogler, Eds.), Monographs in Theoretical Computer Science. An EATCS Series,
Springer Berlin Heidelberg, 2009, ISBN 978-3-642-01491-8, 29–65.

[17] Gilbert, W. S., Sullivan, A.: The Pirates of Penzance, or The Slave of Duty, 1879.

[18] Hasegawa, M.: Recursion from Cyclic Sharing: Traced Monoidal Categories and Models
of Cyclic Lambda Calculi, Proc. 3rd International Conference on Typed Lambda Calculi
and Applications, 1210, Springer-Verlag, 1997.

[19] Hasegawa, M.: Models of Sharing Graphs: A Categorical Semantics of let and letrec,

Distinguished Dissertation Series, Springer, 1999.

[20] Joyal, A., Street, R., Verity, D.: Traced Monoidal Categories, Math. Proc. Cambridge

Philos. Soc., 119(3), 1996, 447–468.

[21] Krishnaswami, N. R., Benton, N.: A semantic model for graphical user interfaces, ICFP
(M. M. T. Chakravarty, Z. Hu, O. Danvy, Eds.), ACM, 2011, ISBN 978-1-4503-0865-6.

29

[22] Krishnaswami, N. R., Benton, N.: Ultrametric Semantics of Reactive Programs, LICS,

IEEE Computer Society, IEEE Computer Society, 2011, ISBN 978-0-7695-4412-0.

[23] Litak, T.: Constructive modalities with provability smack, in: Leo Esakia on duality in
modal and intuitionistic logics (G. Bezhanishvili, Ed.), vol. 4 of Outstanding Contribu-
tions to Logic, Springer, 2014, 179–208.

[24] Manes, E. G.: Handbook of Algebra, vol. 3, chapter Monads of Sets, Elsevier, 2003,

67–153.

[25] Milius, S.: Completely Iterative Algebras and Completely Iterative Monads, Inform. and

Comput., 196, 2005, 1–41.

[26] Milius, S., Litak, T.: Guard Your Daggers and Traces: On The Equational Properties of
Guarded (Co-)recursion, Proc. Fixed Points in Computer Science (FICS’13) (D. Baelde,
A. Carayol, Eds.), Electron. Proc. Theoret. Comput. Sci., 2013.

[27] Milner, R.: Communication and Concurrency, International Series in Computer Science,

Prentice Hall, 1989.

[28] Mulry, P. S.: Lifting Theorems for Kleisli Categories, Proc. Mathematical Foundations
of Programming Semantics (MFPS’93) (S. Brookes, M. Main, A. Melton, M. Mislove,
D. Schmidt, Eds.), 802, Springer, 1994.

[29] Nakano, H.: A Modality for Recursion, LICS, IEEE Computer Society, 2000,

ISBN

0-7695-0725-5.

[30] Nakano, H.: Fixed-Point Logic with the Approximation Modality and Its Kripke Com-
pleteness, TACS (N. Kobayashi, B. C. Pierce, Eds.), 2215, Springer, 2001, ISBN 3-540-
42736-8.

[31] Simpson, A., Plotkin, G. D.: Complete axioms for categorical ﬁxed-point operators,
Proc. 15th Symposium on Logic in Computer Science (LICS’00), IEEE Computer Society,
2000.

[32] Stefanescu, G.: On Flowchart Theories. I. The Deterministic Case, J. Comput. Syst.

Sci., 35(2), 1987, 163–191.

A. Details for Example 2.4.(5)
First observe that (cid:73)X is clearly a presheaf: for every w(cid:48) ≤ w there exists a canonical morphism
(cid:73)X(w) = limv<w X(v) → limv<w(cid:48) X(v) = (cid:73)X(w(cid:48)) induced by the universal property of the
limit in the codomain; the functoriality easily follows from the uniqueness.
Next we deﬁne (cid:73) on a morphism f : X → Y componentwise: for every w, ((cid:73)f )w is the

unique morphism such that the following equations hold:

πv · ((cid:73)f )w = fv · πv,

(v < w),

where πv : X(w) = limv<w X(v) → X(v) denotes the limit projection. To see that ((cid:73)f )w
is natural in w it suﬃces to show that for any w > w(cid:48) the corresponding naturality square

30

commutes when extended by the projection π(cid:48)

v : (cid:73)Y (w(cid:48)) → Y (v) for every v < w(cid:48):
((cid:73)f )w

(cid:73)Y (w)

(cid:73)X(w)

πv

(cid:73)X(w>w(cid:48))

(cid:9)
π(cid:48)
(cid:73)X(w(cid:48))

v

X(v)

(cid:9)
fv /

(cid:9)

Y (v)

πv

(cid:9)
π(cid:48)

v

(cid:73)Y (w>w(cid:48))

((cid:73)f )w(cid:48)

(cid:73)Y (w(cid:48))

†
w is well-deﬁned and that f† is a morphism of C, i.e., f

A routine calculation then shows that (cid:73) : C → C is functorial.
The point p : Id → (cid:73) is given componentwise as the unique morphism (pX )w : X(w) →
(cid:73)X(w) such that πv · (pX )w = X(w > v) for all v < w. Two easy routine calculations using
the deﬁnitions of (cid:73)X and (cid:73) on morphisms, respectively, show that each component pX is
natural in w and that p is natural in X.
Let us now turn to the guarded ﬁxpoint operator †. We ﬁrst prove simultaneously that
†
w is natural in w. This is done
each f
by induction on (W,≤) (note that we do not have to distinguish the base case and induction
†
step here). Fix any w ∈ W and assume that f
v is well-deﬁned for any v < w and that the
†
v holds for any v(cid:48) < v which are smaller
naturality condition f
than w. (Note that for a minimal w ∈ W this holds trivially.) The latter naturality condition
†
implies the cone property for f
w is well-
deﬁned. We proceed to showing the naturality condition for any w > w(cid:48) using the following
diagram (with k(cid:48) induced by the cone f

†
v · Y (w > v) inducing k : Y (w) → (cid:73)X(w) so that f

†
v(cid:48) · Y (v > v(cid:48)) = X(v > v(cid:48)) · f

†
v · Y (w(cid:48) > v)):

(cid:104)k,Y (w)(cid:105)

Y (w)

Y (w>w(cid:48))

(cid:104)(∗),(cid:9)(cid:105)

Y (w(cid:48)) (cid:104)k(cid:48),Y (w(cid:48))(cid:105)

(cid:73)X(w) × Y (w)
(cid:73)X(w>w(cid:48))×Y (w>w(cid:48))
/ (cid:73)X(w(cid:48)) × Y (w(cid:48))

†
f
w
(cid:9)

(cid:9)
†
w(cid:48)

f

fw

(cid:9)

fw(cid:48)

X(w)

X(w>w(cid:48))

/ X(w(cid:48))

(Note that (cid:104)(∗), (cid:9)(cid:105) indicates that the right-hand product component of that part obviously
commutes and the left-hand part, called (∗) is considered further.) Part (∗) is seen commu-
tative by extending it with the limit projection πv : Y (w(cid:48)) → Y (v) for every v < w(cid:48) and
performing a routine calculation. (Note again that this covers the cases where w or w(cid:48) are
minimal and consequently k and k(cid:48), respectively, are the unique morphisms with codomain
1.)
We are ready to verify the commutativity of (2.1). This is done componentwise by induction
on (W,≤). Assume that for a given w all components of (2.1) at v < w commute. Then we
obtain for the w-component of f† the following diagram (where k is again induced by the cone
†
v · Y (w > v) and h by the cone fv · ((pX )v × Y (v))· (πv × Y (w > v)) : (cid:73)X(w)× Y (w) → X(v)
f

31

/
/


%
%


y
y
/
/
/
9
9
e
e


/
/
/
/






/
/
O
O
Y (v)

f

†
v

Y (w>v)

Y (w)

(cid:9)

k

πv

(cid:73)X(w)

X(v)

fv

(cid:104)f

†
v ,Y (v)(cid:105)

(cid:9)

X(v) × Y (v)

(i)

(cid:104)k,Y (w)(cid:105)
(cid:73)X(w) × Y (w)
πv×Y (w>v)

h

(pX )v×Y (v)

(cid:9)

/ (cid:73)X(v) × Y (v)

for all v < w):

†
f
w
(cid:9)

(cid:73)X(w) × Y (w)

(cid:104)k,Y (w)(cid:105)

Y (w)

(cid:104)(i),(cid:9)(cid:105)
(cid:104)k,Y (w),Y (w)(cid:105)
(cid:73)X(w) × Y (w) × Y (w)

h×Y (w)

(cid:104)(ii),(cid:9)(cid:105)

fw

X(w)

(cid:9)

fw

fw×Y (w)
X(w) × Y (w)

(pX )w×Y (w)

/ (cid:73)X(w) × Y (w)

Note that we are done if w is minimal since (cid:73)X(w) = 1 is the terminal object. Otherwise
for part (i) we extend with the limit projection πv for every v < w to obtain the following
diagram (its outside commutes by the induction hypothesis, hence, so does part (i) extended
by πv):

For part (ii) observe ﬁrst that (pX )v · πv = (cid:73)X(w > v); indeed, this follows by routine
calculation extending both sides by the limit projection πu : (cid:73)X(v) → X(u) for every u < v.
Now we obtain the commutativity of part (ii) by extending it with every limit projection πv:

(cid:73)X(w) × Y (w)

(cid:73)

X

(

w

h

πv×Y (w>v)

(cid:73)X(w)

(cid:9)
)×

X(v) × Y (v)

(cid:9)

πv

>

v

fw

(cid:9)

(nat. of f )

X(w)

Y

(

w

>

v

)

(pX )v×Y (v)
fv

(cid:73)X(v) × Y (v)

(cid:9)

X(w>v)

(def. of p)

(pX )w

/ X(v)

πv

/ (cid:73)X(w)

It remains to prove that f† is unique such that (2.1) commutes. Suppose that s : Y → X
is such that s = f · (pX × Y )·(cid:104)s, Y (cid:105). Then we prove that f† = s componentwise by induction
†
on (W,≤). Assume that sv = f
v holds for all v < w. This implies that k is the morphism
induced by the cone sv · Y (w > v) = X(w > v) · sw : Y (w) → X(v). Hence, for all v < w we
have

πv · k = X(w > v) · sw = πv · (pX )w · sw

32

/
/


/
/


4
4


/
O
O


/
/
h
h
/
/


7
7
v
v
7
7
/
O
O
/
/


"
"
)
)




/
3
3
/
O
O
from which we conclude that k = (pX )w · sw. (In the special case where w is minimal this
equation holds since it is an equation between morphisms with codomain (cid:73)X(w) = 1.) Thus,
we obtain

†
w = fw · (cid:104)k, Y (w)(cid:105)
f

= fw · (cid:104)(pX )w · sw, Y (w)(cid:105)
= sw

†
w)

(def. of f
(since k = (pX )w · sw)
(since s = f ·(pX ×Y )·(cid:104)s, Y (cid:105)).

This completes the proof.

B. Proof of Theorem 4.5

The proof of Theorem 4.5 proceeds in three steps:
1. We show that †Tr deﬁned in Construction 4.4.1 is a guarded trace operator.
2. We show that Tr† deﬁned in Construction 4.4.2 satisﬁes the Conway axioms.
3. We show that the two constructions are mutually inverse, i.e. †T r† = † and Tr†Tr = Tr.

In the ﬁrst two sections we shall drop the subscripts and only write Tr and † in lieu of Tr†
and †Tr, respectively. The proof is an adaptation of Hasegawa’s proof for ordinary traces and
ﬁxpoint operators in [19].

B.1. From trace to dagger
We will now prove that the †-operation deﬁned in Construction 4.4.1 satisﬁes the Conway
axioms. But before we need an analogue of the ﬁxpoint identity for traces:
Lemma B.1. For every f : (cid:73)X × A → X × B we form

(cid:0)(cid:73)X × A

h = TrX

A,X

f

/X × B

π(cid:96)

/X ∆ /

/X × X(cid:1).

Then we have

A,B(f ) =(cid:0)A

TrX

(cid:104)h,A(cid:105)

/X × A

pX×A /

/(cid:73)X × A

f

/X × B

πr

/B(cid:1).

Proof. Let c : (cid:73)X × X → X × (cid:73)X denote the canonical isomorphism swapping components.
Observe that we have

c · (pX × X) · ∆X = c · (cid:104)pX , X(cid:105) = (cid:104)X, pX(cid:105) = (X × pX ) · ∆X

and

(X × c) · (c × X) · ((cid:73)X × ∆X ) = (∆X × (cid:73)X) · c.

(B.1)

(B.2)

33

/
/
/
/
/
Now we compute

pX · h = pX · TrX

A,X (∆X · π(cid:96) · f )

by def. of h

(Rt)
= TrX
(B.1)
= TrX
(Y )
= TrX
(S)
= TrX
(Lt)
= TrX
(Rt)
= TrX
(B.2)
= TrX
= TrX×X
(V 2)
(Sl)
= TrX
= TrX

X,(cid:73)X (c) × X) · ∆X · π(cid:96) · f )
X×X,(cid:73)X×X (c × X) · ∆X · π(cid:96) · f )

A,(cid:73)X ((X × pX ) · ∆X · π(cid:96) · f )
A,(cid:73)X (c · (pX × X) · ∆X · π(cid:96) · f )
A,(cid:73)X (c · (TrX
A,(cid:73)X (c · TrX
A,(cid:73)X (c · TrX(cid:73)X×A,(cid:73)X×X ((c × X) · ((cid:73)X × (∆X · π(cid:96) · f ))))
A,(cid:73)X (TrX(cid:73)X×A,X×(cid:73)X ((X × c) · (c × X) · ((cid:73)X × (∆X · π(cid:96) · f ))))
A,(cid:73)X (TrX(cid:73)X×A,X×(cid:73)X ((∆X × (cid:73)X) · c · ((cid:73)X × (π(cid:96) · f ))))
A,(cid:73)X ((∆X × (cid:73)X) · c · ((cid:73)X × (π(cid:96) · f )) · (can × A))
A,(cid:73)X (c · ((cid:73)X × (π(cid:96) · f )) · (can × A) · ((cid:73)(∆X ) × A))
A,(cid:73)X (c · ((cid:73)X × (π(cid:96) · f )) · (∆(cid:73)X × A))

Using this we can ﬁnish the proof:
πr · f · (cid:104)pX · h, A(cid:105) = πr · f · ((pX · h) × A) · ∆A

(S)

= πr · f · TrX
= πr · f · TrX

(Lt)

A×A,(cid:73)X×A((c × A) · ((cid:73)X × (π(cid:96) · f ) × A) · (∆(cid:73)X × A × A)) · ∆A
(cid:125)
A,(cid:73)X×A((c × A) · ((cid:73)X × (π(cid:96) · f ) × A) · (∆(cid:73)X × A × A) · ((cid:73)X × ∆A)

(cid:123)(cid:122)
=∆(cid:73)X×∆A
A,B((X × (πr · f )) · (c × A) · ((cid:73)X × (π(cid:96) · f ) × A) · (∆(cid:73)X × ∆A))
A,B((cid:104)π(cid:96) · f, πr · f(cid:105))
A,B(f ),

(cid:124)

)

(Rt)
= TrX
= TrX
= TrX

which completes the proof of the lemma.

We now verify the Conway axioms for the †-operation from Construction 4.4.1.
(1) Fixpoint identity. Given f : (cid:73)X × A → X we apply Lemma B.1 to (cid:104)f, f(cid:105); then

h = TrX

A,X (∆X · π(cid:96) · (cid:104)f, f(cid:105)) = TrX

A,X ((cid:104)f, f(cid:105)) = f†

and therefore we have

f† = TrX

A,X(cid:104)f, f(cid:105)

by def. of †
= πr · (cid:104)f, f(cid:105) · (pX × A) · (cid:104)h, A(cid:105) by Lemma B.1
= f · (pX × A) · (cid:104)f†, A(cid:105)
since h = f†.

(2) Parameter identity. Let f : (cid:73)X × A → X and h : A(cid:48) → A. Then we have
(f · ((cid:73)X × h))† = TrX
= TrX
(Lt)
= TrX
= f† · h

A(cid:48),X ((cid:104)f · ((cid:73)X × h), f · ((cid:73)X × h)(cid:105)) by def. of †
A(cid:48),X ((cid:104)f, f(cid:105) · ((cid:73)X × h))
A,X ((cid:104)f, f(cid:105)) · h

by def. of †.

34

(3) Composition identity. Given f : (cid:73)X × A → Y and g : Y → X we compute

by def. of †

A,X ((cid:104)g · f, g · f(cid:105))
A,X ((X × g) · (cid:104)g · f, f(cid:105))

(g · f )† = TrX
= TrX
= g · TrX
(Rt)
= g · TrX
= g · TrY
= g · TrY
= g · (f · ((cid:73)g × A))†

(Sl)

A,Y ((cid:104)g · f, f(cid:105))
A,Y ((g × X) · (cid:104)f, f(cid:105))
A,Y ((cid:104)f, f(cid:105) · ((cid:73)g × A))
A,Y ((cid:104)f · ((cid:73)g × A), f · ((cid:73)g × A)(cid:105))

by def. of †.
(4) Double dagger identity. Given f : (cid:73)X × (cid:73)X × A → X we have
by def. of †
by def. of †

f†† = TrX
= TrX
(Rt)
= TrX
= TrX×X
(V 2)
= TrX×X
(Sl)
= TrX

A,X ((cid:104)f†, f†(cid:105))
A,X (∆X · TrX(cid:73)X×A,X ((cid:104)f, f(cid:105)))
A,X (TrX(cid:73)X×A,X×X ((X × ∆X ) · (cid:104)f, f(cid:105)))
A,X ((cid:104)f, f, f(cid:105) · (can × A))
A,X ((∆X × X) · (cid:104)f, f(cid:105) · (can × A))
(cid:123)(cid:122)
(cid:125)
A,X ((cid:104)f, f(cid:105) · (can × A) · ((cid:73)(∆X ) × A)
A,X ((cid:104)f · (∆(cid:73)X × A), f · (∆(cid:73)X × A))

=∆(cid:73)X×A

(cid:124)

)

= TrX
= (f · (∆(cid:73)X × A))†

by def. of †.

B.2. From dagger to trace

We prove that the operation Tr deﬁned in Construction 4.4.2 satisﬁes all the axioms of a
guarded trace operator. Again we start with a technical lemma.
Lemma B.2. Let f : (cid:73)X × A → X × B and deﬁne

h = ((cid:73)(X × B) × A

(cid:73)π(cid:96)×A /

/(cid:73)X × A

f

/X × B ).

Then we have

A,B(f ) = (A h†
TrX

/X × B

πr

/B ).

Proof. Notice ﬁrst that by the simpliﬁed composition identity we have π(cid:96) · h† = (π(cid:96) · f )†. This
implies that

(cid:104)(π(cid:96)·f )†,A(cid:105)

(cid:9)
π(cid:96)×A

X × A

A

(cid:104)h†,A(cid:105)
X × B × A

h†

(cid:9) by (†)

X × B

h

(cid:73)(X × B) × A

pX×B×A
(cid:9) by nat. of p

(cid:9)
(cid:73)π(cid:96)×A

f

pX×A

/ (cid:73)X × A

The result follows by postcomposing with πr; by the deﬁnition of Tr we have

A,B(f ) = πr · f · (pX × A) · (cid:104)(π(cid:96) · f )†, A(cid:105) = πr · h†.
TrX

35

/
/
/
/
/




/
/
v
v
O
O
)
)
/
o
o
We now verify the properties of a guarded trace for Tr.
(1) Vanishing (V1). For any f : (cid:73)1 × A → B the deﬁnition of Tr1

A,B(f ) yields f · (p1 × A);
for if we consider B as the product 1 × B we see that both π(cid:96) · f : (cid:73)1 × A → 1 and its
dagger (π(cid:96) · f )† : A → 1 are unique morphisms, which implies that (cid:104)(π(cid:96) · f )†, A(cid:105) : A → 1 × A
is the canonical isomorphism A ∼= 1 × A, and πr : 1 × B → B is the canonical isomorphism
1 × B ∼= B.
(2) Vanishing (V2). Given f : (cid:73)X × (cid:73)Y × A → X × Y × B we form F = π(cid:96) · f :
(cid:73)X × (cid:73)Y × A → X and G = πm · f : (cid:73)X × (cid:73)Y × A → Y , where πm : X × Y × B → B
denotes the middle product projection. Then by the Bekiˇc identity (see Proposition 3.10) we
†
†
have ((cid:104)F, G(cid:105)· (can× A))† = (cid:104)e
R(cid:105) for appropriate eL : (cid:73)X × A → X and eR : (cid:73)Y × A → Y .
L, e
From the following diagram we see that π(cid:96) · TrX(cid:73)Y ×A,Y ×B(f ) = eR:

(cid:73)Y × A

(cid:104)F †,(cid:73)Y ×A(cid:105)

/ X × (cid:73)Y × A

TrX (f )

(cid:9)
pX×Y ×A /
/ (cid:73)X × (cid:73)Y × A
(cid:9)

eR

f

X × Y × B

(cid:9)

G

πr

πm

Y × B
(cid:9)

π(cid:96)

Y/

By the naturality of p we have

pX × pY = (X × Y

pX×Y /

/(cid:73)(X × Y )

can

/(cid:73)X × (cid:73)Y ).

(B.3)

Now we obtain

A,B(TrX(cid:73)Y ×A,Y ×B(f )) = πr · TrX (f ) · (pY × A) · (cid:104)e
(cid:124)
TrY

†
R, A(cid:105)

(cid:123)(cid:122)
(cid:125)
†
R, A(cid:105)
= πr · f · (pX × (cid:73)Y × A) · (cid:104)F †, (cid:73)Y × A(cid:105) · (pY × A) · (cid:104)e
†
†
R, A(cid:105)
R, A(cid:105), pY · e
= πr · f · (pX × (cid:73)Y × A) · (cid:104)F † · (cid:104)pY · e
†
†
R, A(cid:105)
L, pY · e
= πr · f · (pX × (cid:73)Y × A) · (cid:104)e
†
†
R, A(cid:105)
= πr · f · (pX × pY × A) · (cid:104)e
L, e
†
†
R, A(cid:105)
= πr · f · (can × A) · (pX×Y × A) · (cid:104)e
L, e

(3.7)

(B.3)

A,B (f ·(can×A)) now follows from the deﬁnition of Tr, the fact that (cid:104)e

That this is TrX×Y
((cid:104)F, G(cid:105)·(can×A))† holds by the Bekiˇc identity and since (cid:104)F, G(cid:105) = π(cid:48)
X × Y .
(3) Superposing. Let f : (cid:73)X × A → X × B and denote by π(cid:48)
(cid:96) : X × B × C → X the projections. Notice ﬁrst that we have
π(cid:48)
/(cid:73)X × A

(cid:96) · (f × C))† = (cid:0)(cid:73)X × A × C

(π(cid:48)

f

= (cid:0)A × C

(P )

π(cid:96)

/A

(cid:73)X×π(cid:96)
(π(cid:96)·f )†

/X(cid:1).

(cid:96)·f where π(cid:48)

†
†
R(cid:105) =
L, e
(cid:96) : X×Y ×A →
r : X × B × C → B × C and

/X(cid:1)†

/X × B

π(cid:96)

Using this we obtain

A×C,B×C(f × C)
TrX

def= π(cid:48)

(cid:124)
r · (f × C) · (pX × A × C) · (cid:104)(π(cid:48)

= (cid:0)πr · f · (pX × A) · (cid:104)(π(cid:96) · f )†, A(cid:105)(cid:1) × C

(cid:125)
(cid:96) · (f × C))†, A × C(cid:105)
=(cid:104)(π(cid:96)·f )†,A(cid:105)×C

(cid:123)(cid:122)

def= TrX

A,B(f ) × C.

36

/
/
/
+
+
/
/
'
'




/
/
/
/
/
/
/
(4) Yanking. Consider c : (cid:73)X × X → X × (cid:73)X. Then by deﬁnition we have

X,(cid:73)X (c) = πr · c · (pX × X) · (cid:104)(π(cid:96) · c)†, X(cid:105).
TrX

Thus, we are done if we show that (π(cid:96) · c)† is the identity on X, which easily follows from the
ﬁxpoint identity:

(π(cid:96) · c)† (†)

= π(cid:96) · c · (pX × X) · (cid:104)(π(cid:96) · c)†, X(cid:105) = πr · (pX × X) · (cid:104)(π(cid:96) · c)†, X(cid:105) = X.

(5) Left tightening. Let f : (cid:73)X × A → X × B and g : A(cid:48) → A. By the parameter identity

we have

Then we have

A(cid:48),B(f · ((cid:73)X × g))
TrX

(π(cid:96) · f · ((cid:73)X × g))† = (π(cid:96) · f )† · g.

(B.4)

(B.4)

def= πr · f · ((cid:73)X × g) · (pX × A(cid:48)) · (cid:104)(π(cid:96) · f · ((cid:73)X × g))†, A(cid:48)(cid:105)
= πr · f · ((cid:73)X × g) · (pX × A(cid:48)) · (cid:104)(π(cid:96) · f )† · g, A(cid:48)(cid:105)
= πr · f · (pX × A) · (cid:104)(π(cid:96) · f )†, A(cid:105) · g
def= TrX

A,B(f ) · g.

(6) Right tightening. Let f : (cid:73)X × A → X × B and g : B → B(cid:48). We compute

A,B(cid:48)((X × g) · f )
TrX

def= πr · (X × g)

·f · (pX × A) · (cid:104)(π(cid:96) · (X × g)

·f )†, A(cid:105)

(cid:124)

(cid:123)(cid:122)

(cid:125)

=g·πr
def= g · TrX
A,B(f ).

(cid:124)

(cid:123)(cid:122)

=π(cid:96)

(cid:125)

(7) Sliding. Let f : (cid:73)X × A → X(cid:48) × B and g : X(cid:48) → X. Notice ﬁrst that we have

(π(cid:96) · (g × B) · f )† = (g · (π(cid:96) · f ))† (C)

= g · (π(cid:96) · f · ((cid:73)g × A))†.

(B.5)

Then we obtain

A,B((g × B) · f )
TrX

(cid:124)

(cid:123)(cid:122)

=πr

(cid:125)

def= πr · (g × B)

·f · (pX × A) · (cid:104)(π(cid:96) · (g × B) · f )†, A(cid:105)

(B.5)

(cid:124)

= πr · f · (pX × A) · (cid:104)g · (π(cid:96) · f · ((cid:73)g × A))†, A(cid:105)
= πr · f · (pX × A) · (g × A)
=((cid:73)g×A)·(pX(cid:48)×A)

(cid:123)(cid:122)
A,B(f · ((cid:73)g × A)).

def= TrX(cid:48)

·(cid:104)(π(cid:96) · f · ((cid:73)g × A))†, A(cid:105)

(cid:125)

B.3. Mutual inverses
From dagger to trace and back. We show that †Tr† = †. For any f : (cid:73)X × A → X we
compute

†Tr†(f ) def= (Tr†)X

(cid:123)(cid:122)
(cid:125)
A,X ((cid:104)f, f(cid:105)) def= πr · (cid:104)f, f(cid:105)

(cid:124)

=f

·(pX × A) · (cid:104)(π(cid:96) · (cid:104)f, f(cid:105))†, A(cid:105)

(†)
= f†.

(cid:124)

(cid:123)(cid:122)

=(cid:104)f†,A(cid:105)

(cid:125)

37

From trace to dagger and back. We show that Tr†Tr = Tr. Let f : (cid:73)X × A → X × B. Then
we have by the deﬁnition of †Tr
(π(cid:96) · f )†Tr def= TrX

(B.6)

Using Lemma B.1, this allows us to conclude

A,X ((cid:104)π(cid:96) · f, π(cid:96) · f(cid:105)) = TrX
A,X (∆X · π(cid:96) · f ) =: h.
(cid:123)(cid:122)

(cid:125)
A,B(f ) def= πr · f · (pX × A) · (cid:104)(π(cid:96) · f )†Tr, A(cid:105)

Lem. B.1= TrX

(cid:124)

A,B(f ).

=(cid:104)h,A(cid:105)

(Tr†Tr)X

C. Proof of Theorem 4.7
1. From trace to dagger. Let f , f(cid:48) and h form the commutative square on the left below:

(cid:73)X × A
(cid:73)h×A
(cid:73)X(cid:48) × A

f

(cid:9)

f(cid:48)

X

h

/ X(cid:48)

(cid:73)X × A
(cid:73)h×A
(cid:73)X(cid:48) × A

(cid:104)f,f(cid:105)

X × X

(cid:9)

(cid:104)f(cid:48),f(cid:48)(cid:105)

X×h /
/ X × X(cid:48)
(cid:9)
h×X(cid:48)
X(cid:48) × X(cid:48)

h×h

Then the diagram on the right above commutes, too, and thus, by uniformity of Tr we have

A,X(cid:48)((X × h) · (cid:104)f, f(cid:105)) = TrX(cid:48)
TrX
A,X(cid:104)f, f(cid:105) (Rt)

A,X(cid:48)(cid:104)f(cid:48), f(cid:48)(cid:105).
A,X(cid:48)((X×h)·(cid:104)f, f(cid:105))

= TrX

Thus, we obtain: h·f† def= h·TrX

A,X(cid:48)(cid:104)f(cid:48), f(cid:48)(cid:105) def= (f(cid:48))†.
2. From dagger to trace. Let f , f(cid:48) and h form the commutative square on the left below:

= TrX(cid:48)

(C.1)

(C.1)

(cid:73)X × A
(cid:73)h×A
(cid:73)X(cid:48) × A

X × B
h×B
/ X(cid:48) × B

f

(cid:9)

f(cid:48)

(cid:73)(X × B) × A

(cid:73)π(cid:96)×A /

(cid:73)(h×B)×A
(cid:73)(X(cid:48) × B) × A (cid:73)π(cid:96)×A

(cid:9)

(cid:73)X × A
(cid:73)h×A
/ (cid:73)X(cid:48) × A

X × B
h×B
/ X(cid:48) × B

f

(cid:9)

f(cid:48)

Then the diagram on the right above commutes, too, and thus, by uniformity of † we have

(h × B) · (f · ((cid:73)π(cid:96) × A))† = (f(cid:48) · ((cid:73)π(cid:96) × A))†

(C.2)

Using Lemma B.2 we now compute:

TrX(cid:48)

A,B(f(cid:48)) Lem. B.2=

(C.2)
=

πr · (f(cid:48) · ((cid:73)π(cid:96) × A))†
πr · (h × B)

·(f · ((cid:73)π(cid:96) × A))†

(cid:124)

(cid:123)(cid:122)

=πr

(cid:125)

Lem. B.2=

TrX

A,B(f ).

38

/
/




/
/
/


%
%


/
/
/
/




/
/


/
/




/
/
D. Proof of Corollary 4.10
1. Let F : (C, (cid:73)C, TrC) → (D, (cid:73)D, TrD) be a morphism of guarded traced categories. We show
that F preserves †Tr as deﬁned in Construction 4.4.1. Let f : (cid:73)X × A → X in C. Then we
have (dropping subscripts of † and Tr)

F (f†) = F (TrX(cid:104)f, f(cid:105))
= TrF X (F(cid:104)f, f(cid:105))
= TrF X(cid:104)F f, F f(cid:105)
= (F f )†

(by deﬁnition of †)
(F trace preserving)
(F ﬁnite product preserving)
(by deﬁnition of †).

2. Let F : (C, (cid:73)C,†) → (D, (cid:73)D,‡) be a morphism of guarded Conway categories. We show
that F preserves Tr† as deﬁned in Construction 4.4.2. Let f : (cid:73)CX × A → X × B in C. Then
we have (again we drop all subscripts of Tr and †)

F (TrX (f )) = F(cid:0)πr · (f · ((cid:73)Cπ(cid:96) × A))†(cid:1)
= F πr ·(cid:0)F f · F ((cid:73)Cπ(cid:96) × A)(cid:1)‡

= πr · (F f · (F ((cid:73)Cπ(cid:96)) × F A))‡
= πr · (F f · ((cid:73)D F π(cid:96)
×F A))‡

(cid:124)(cid:123)(cid:122)(cid:125)

=π(cid:96)

(by Lemma B.2)
(F dagger preserving)
(F ﬁnite product preserving)
(by (4.1))

(by Lemma B.2).

= TrF X (F f )

This completes the proof.

39

