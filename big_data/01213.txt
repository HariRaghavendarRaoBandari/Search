6
1
0
2

 
r
a

M
3

 

 
 
]
T
I
.
s
c
[
 
 

1
v
3
1
2
1
0

.

3
0
6
1
:
v
i
X
r
a

Optimal Rebuilding of Multiple Erasures in

1

MDS Codes

Zhiying Wang, Itzhak Tamo, and Jehoshua Bruck

Abstract

MDS (maximum distance separable) array codes are widely used in storage systems due to their computationally efﬁcient
encoding and decoding procedures. An MDS code with r redundancy nodes can correct any r node erasures by accessing (reading)
all the remaining information in the surviving nodes. However, in practice, e erasures is a more likely failure event, for 1 ≤ e < r.
Hence, a natural question is how much information do we need to access in order to rebuild e storage nodes? We deﬁne the
rebuilding ratio as the fraction of remaining information accessed during the rebuilding of e erasures. In our previous work we
constructed MDS codes, called zigzag codes, that achieve the optimal rebuilding ratio of 1/r for the rebuilding of any systematic
node when e = 1, however, all the information needs to be accessed for the rebuilding of the parity node erasure.

The (normalized) repair bandwidth is deﬁned as the fraction of information transmitted from the remaining nodes during the
rebuilding process. For codes that are not necessarily MDS, Dimakis et al. proposed the regenerating codes framework where any
r erasures can be corrected by accessing some of the remaining information, and any e = 1 erasure can be rebuilt from some
subsets of surviving nodes with optimal repair bandwidth.

In this work, we study three questions on rebuilding of codes: (i) We show a fundamental trade-off between the storage size
of the node and the repair bandwidth similar to the regenerating codes framework, and show that zigzag codes achieve the optimal
rebuilding ratio of e/r for MDS codes, for any 1 ≤ e ≤ r. (ii) We construct systematic codes that achieve optimal rebuilding ratio
of 1/r, for any systematic or parity node erasure. (iii) We present error correction algorithms for zigzag codes, and in particular
demonstrate how these codes can be corrected beyond their minimum Hamming distances.

I. INTRODUCTION

MDS (maximum distance separable) array codes are a family of erasure-correcting codes used extensively as the basis for
RAID storage systems and has been proposed for coding in distributed storage systems. An array code consists of a 2D array
where each column can be considered as a storage node. We will use the term column and node interchangeably. An entry
in the 2D array is referred to as an element. A code with r parity (redundancy) nodes is MDS if and only if it can recover
from any r erasures. EVENODD [3] and RDP [8] are examples of MDS array codes with two redundancies. In this paper, we
only consider systematic codes, namely, the information is stored exclusively in the ﬁrst k nodes, and the parities are stored
exclusively in the last r nodes.

In order to correct r erasures, it is obvious that one has to access (or read) the information in all the surviving nodes.
However, in practice it is more likely to encounter e erasures rather than r erasures, for 1 ≤ e < r. So a natural questions is:
How much information do we need to access when rebuilding e erasures? Do we have to access all the surviving information?
We deﬁne the rebuilding ratio as the ratio of accessed information to the remaining information in case of e erasures.

For example, it is easy to check that for the code in Figure 1, if any two columns are erased, we can still recover all the
information, namely, it is an MDS code. Here all elements are in ﬁnite ﬁeld F3. Now suppose column C1 is erased, it can be
rebuilt by accessing only the elements from rows 0, 1 and columns C0, C2, P0, P1 as follows:

a0,1 = r0 − a0,0 − a0,2 = 2a0,0 + 2a0,2 + r0
a1,1 = 2a1,0 + 2a1,2 + r1
a2,1 = 2a0,0 + 2a1,2 + z0
a3,1 = 2a1,0 + a0,2 + z1

Hence, by accessing only 8 out of 16 remaining elements, i.e., only half of the remaining information, the erased node can
be rebuilt. Similarly, if column C0 or C2 is erased, only half elements need to be accessed. However, if column P0 or P1 is
erased, one has to access all elements in column C0, C1, C2, a total of 12 elements, in order to rebuild. Details on this code
will be discussed in Section II.

The problem of rebuilding information in distributed storage systems has attracted considerable interest in recent years. In
the pioneering work [9], a related problem called repair bandwidth was proposed. The paradigm there is that one can access
the entire information and perform computations within each node, and the question is how much information is transmitted
from some subset of the surviving nodes, called the helper nodes, for rebuilding e = 1 erasure. Moreover, a code is required
to reconstruct the entire information from any r erasures, however it is not necessarily MDS, in the sense that the amount of

Z. Wang is with Center for Pervasive Communications and Computing, University of California, Irvine, Irvine, CA, USA (email: zhiying@uci.edu).
I. Tamo is with Department of Electrical Engineering - Systems, Tel Aviv University, Tel Aviv, Israel (email: tamo@post.tau.ac.il).
J. Bruck are with Department of Electrical Engineering, California Institute of Technology, Pasadena, CA, USA (email: zhiying, bruck@caltech.edu).
The material of the paper was partially presented at the Allerton Conference on Communication, Control, and Computing, 2011 [19].

2

C0
a0,0
a1,0
a2,0
a3,0

C1
a0,1
a1,1
a2,1
a3,1

C2
a0,2
a1,2
a2,2
a3,2

0
1
2
3

P0

P1

r0 = a0,0 + a0,1 + a0,2
r1 = a1,0 + a1,1 + a1,2
r2 = a2,0 + a2,1 + a2,2
r3 = a3,0 + a3,1 + a3,2

z0 = a0,0 + a2,1 + a1,2
z1 = a1,0 + a3,1 + 2a0,2
z2 = a2,0 + 2a0,1 + 2a3,2
z3 = a3,0 + 2a1,1 + a2,2

Figure 1. An MDS array code with three systematic and two parity nodes. All the elements are in ﬁnite ﬁeld F3. The ﬁrst parity column P0 is the row sum
and the second parity column P1 is generated by the zigzags.

redundant information can be more than the storage size of r nodes. A lower bound on the repair bandwidth was given in
[9]. When a single erasure occurs and all the remaining nodes are accessible, the lower bound for the repair bandwidth of an
MDS code is 1/r. It is clear that a lower bound on the repair bandwidth also implies a lower bound on the rebuilding ratio.
The MDS codes with optimal repair bandwidth are termed minimum storage regenerating codes in [9].

A number of codes were designed to achieve the repair bandwidth or rebuilding ratio lower bound for e = 1 erasure in
MDS codes, where all the remaining nodes are helper nodes. When the number of parity nodes is larger than that of the
systematic nodes, namely, r > k, explicit code constructions were given in [16], [17]. For all cases, [7] achieved the lower
bound asymptotically through interference alignment techniques. References [5], [18] presented explicit constructions of high-
rate (k > r) MDS array codes that achieve the lower bound 1/r on the rebuilding ratio. Also in [12] a similar code with 2
parities was proposed, which has optimal repair bandwidth. Afterwards, [1], [6], [14], [20] constructed high-rate codes that
achieve optimal repair bandwidth ( [6], [20]) or optimal rebuilding ratio ( [1], [14]), where an important consideration was to
increase the code dimension, k, for a given column length.

Let us now move from rebuilding a single erasure to multiple erasures. Consider the following example. Suppose that we
have an MDS code with 3 parity nodes. If we have a single erasure, we have codes that achieve the optimal rebuilding ratio
of 1/3. What happens if we have two erasures? What is the rebuilding ratio in this case? We restrict ourselves to systematic
node erasures, whose rebuilding is critical in practice. This is because systematic nodes contain the most frequently requested
information from users and requires faster rebuilding than parity nodes. The ﬁrst result of this paper is that zigzag codes [18]
can achieve the optimal rebuilding ratio of 2/3. In general, if we have r parity nodes and e erasures happen, 1 ≤ e ≤ r, in our
ﬁrst result of the paper we will prove that the lower bound of repair bandwidth normalized by the size of the remaining array
is e/r, and so is the rebuilding ratio. In addition, zigzag codes achieve this lower bound for any e systematic node erasures,
1 ≤ e ≤ r.

In our settings, multiple erasures are simultaneously rebuilt from information in the remaining nodes. It should be noted that
our model is different from the distributed repair problem, where the recovery of each node is done separately [9], and multiple
erasures simply leads to a smaller number of helper nodes for every single node repair. Also it is different from cooperative
recovery schemes [11], where a failed node ﬁrst separately communicate with surviving nodes, and then communicate with
each other.

Going back to the single erasure problem, we notice that the majority of the code constructions for high-rate codes [1], [5],
[6], [12], [18], [20] consider the rebuilding of a systematic node. Reference [14] addresses the rebuilding of any node erasure,
but the code construction is described in a non-systematic fashion. The second result of this paper is a systematic MDS array
code construction, such that any node erasure has optimal rebuilding ratio.

We would like to point out here that the constructed code achieves optimal rebuilding ratio at the cost of update complexity.
An MDS code with r parities is called optimal update if each information element is contained in exactly r parity elements.
If we update the value of an information element, we only need to change the value of r parity elements. And this is the
minimum number of changes required for an MDS code. For example, in Figure 1 the information element a0,1 is contained
in only r = 2 parity elements: r0, z2. While the construction in [18] is optimal update, the constructed code of the second
result is not. In fact, each information element is contained in 2r − 1 parity elements.

Finally, in the conventional error model, storage device failures correspond to an erasure or an error of an entire node.
Therefore, array codes are usually designed to correct such entire node failures, and the previous work on the rebuilding
problem in the literature has focused on recovering from entire node erasures. An exception is partial MDS codes [4] and
sector-disk codes [13] for RAID systems, which consider the erasure pattern of entire node erasure together with single element
erasure. The model in [4], [13] is that an element in the 2D array is a sector in a disk, then by the fault tolerance mechanism
in the disks, an element erasure can be detected. Therefore, the code needs to tolerate node and element erasures. On the other
hand, for SSD storage media where symbols can be accessed individually, one can view each element as a single symbol.
Then we have the fault type where single element can be erroneous. In other words, we may encounter only a few errors in a
column as well as entire node erasures.

For an MDS array code with two parities, the minimum Hamming distance is 3. Therefore, it is not possible to correct a
node erasure and a node error at the same time. However, since zigzag code has a very long column length, it is interesting
to understand whether it is capable of correcting a node erasure and some element errors. In the third result of this paper, we
show that zigzag code can be a good candidate for correcting node erasures and element errors at the same time. Moreover,

3

we show how to correct an entire node error for zigzag codes.

The main contributions of this paper are summarized as follows.
• We establish the lower bound of the rebuilding ratio of e/r for e erasures and r parities. More generally, we show
the fundamental tradeoff between the storage cost and repair bandwidth for e erasures similar to the regenerating codes
framework.

• We show an optimal rebuilding algorithm for zigzag codes that achieves the rebuilding ratio of e/r for e systematic

erasures.

• We develop techniques to rebuild zigzag codes (in the generalized sense deﬁned in Section III), such that a subset of helper
nodes access the optimal e/r fraction of element, and the remaining helper nodes access the entire node information.
Based on this technique we present an example code with r = 2 and close to optimal rebuilding ratio, while the code
dimension k is quadratic compared to the previous zigzag code.

• A surprising observation is proved: there exists a threshold e∗ for an MDS code with r parities, 1 ≤ e∗ ≤ r, such that
when e erasures occur, e∗ ≤ e ≤ r, the code can be rebuilt optimally, when e satisﬁes 1 ≤ e ≤ e∗, the code does not
have optimal rebuilding ratio.

• We give an explicit construction of a family of MDS array codes with r parity nodes, that achieves the lower bound
1/r for rebuilding any systematic or parity node. The rebuilding of a single erasure has an efﬁcient implementation as
computations within nodes are not required. Moreover, our codes have simple encoding and decoding procedures - when
r = 2 and r = 3, the codes require ﬁnite ﬁeld sizes of 3 and 4, respectively.

• An algorithm for the zigzag code with r = 2 is devised that corrects a single node erasure and an element error. Correcting
such fault scenarios demonstrates the potential of zigzag codes to correct beyond its minimum Hamming distance. Besides,
an algorithm for correcting a node error is developed for zigzag code with any r parities.

The rest of the paper is organized as follows. Section II introduces the rebuilding problem for MDS array codes and reviews
the zigzag code construction [18]. In Section III we develop rebuilding algorithm for multiple erasures in general zigzag codes
and speciﬁcally show that the rebuilding ratio of e/r is a fundamental lower bound and is also achievable by certain zigzag
codes. Section IV constructs the codes with optimal rebuilding ratio for both systematic and parity codes. The problem of
correcting errors in zigzag codes is shown in Section V. Finally, the paper is summarized in Section VI.

II. PROBLEM SETTINGS AND ZIGZAG CODES

Notations: In the rest of the paper, we are going to use [i, j] to denote {i, i + 1, . . . , j} and [i] to denote {1, 2, . . . , i}, for
integers i ≤ j. For a matrix A, AT denotes the transpose of A. For two binary vectors v = (v1, . . . , vm), u = (u1, . . . , um),
the inner product is v · u = ∑m

i=1 viui mod 2. For two permutations f , g, denote their composition by f g or f ◦ g.

In this section we formally deﬁne the rebuilding ratio problem and review the zigzag code construction in [18], which was
shown to have optimal rebuilding for a single systematic node erasure. We then show that the construction can be made an
MDS code, in fact, this will be the basis for proving that our newly proposed construction described in Section IV is also an
MDS code.

A. Problem Settings

We ﬁrst deﬁne the framework of a systematic (n, k) MDS array code, which can tolerate r arbitrary node erasures. Here
n, k, r = n − k are the total length, the dimension, and the number of parities of the code. Let M be the size of the information
to be stored. We assume that each systematic node stores p = M
k of the information and corresponds to columns [0, k − 1].
Let A = (ai,j) be an information array of size p × k. We add r parity columns to this array, such that from any k columns,
we can recover the entire information. A column is also called a node, and an entry is called an element. The elements in a
column or the rows are indexed {0, 1, . . . , p − 1}.

For a given MDS code with parameters k, r, we study the rebuilding of e node erasures in the average case, for e ≤ r.
Suppose the possible erasures are from a set of nodes S. If S is the set of all k + r nodes, we consider the rebuilding of an
arbitrary set of erasures. If S is only the set of k systematic nodes, we consider only the rebuilding of systematic erasures.
Let E ⊆ S be a subset of e erased nodes. The the total number of remaining elements after the erasures of E is p(n − e).
Denote by A(E), T(E) be the minimum number of accessed and transmitted elements to rebuild these erasures, respectively.
We deﬁne the rebuilding ratio of a code for e erasures in set S as the fraction of accessed elements for rebuilding:

∑E⊆S,|E|=e A(E)

(|S|

e )p(n − e)

.

Similarly, generalizing the deﬁnition of [9], we deﬁne the (normalized) repair bandwidth as the fraction of transmitted
information for rebuilding:

∑E⊆S,|E|=e T(E)

(|S|

e )p(n − e)

.

When the context is clear, we will not mention which set S is in use. It is easy to see that the repair bandwidth is a lower bound
on the rebuilding ratio, because a transmitted symbol can be a function of many accessed symbols. But obviously optimal
rebuilding ratio is a more desirable property because it minimizes storage I/O and system cost. Therefore for achievable results
of the paper, we focus on optimal rebuilding ratio. We will study repair bandwidth lower bound for multiple erasures in Section
III.

An MDS code is said to be optimal update if each information element is protected by exactly r parity elements. Such

codes requires the smallest number of element updates when a single information element needs to be updated.

B. Zigzag Codes

4

Next, we review zigzag codes in [18]. In [18], it was shown that if the code has optimal update, then each parity node
k−1 for the l-th
j (i) = t.

corresponds to k permutations acting on [0, p − 1]. More speciﬁcally, suppose the permutations are f l
parity, l ∈ [0, r − 1]. Then the t-th element in this parity node is a linear combination of all elements ai,j such that f l
The set of information elements contained in this linear combination is called a zigzag set, denoted by Zl
t.

Because the ordering of the elements in each node can be arbitrary, we can assume that the ﬁrst parity node is always a
linear combination of each row (corresponding to identity permutations). If we write a permutation in the vector notation, we
have

1, . . . , f l

0, f l

0 = f 0
f 0

1 = · · · = f 0

k−1 = (0, 1, . . . , p − 1).

Figure 1 is an example of such codes. The ﬁrst parity P0 corresponds to identity permutations, or sum of each row. The second
parity P1 corresponds to the permutations

f 1
0 = (0, 1, 2, 3),
f 1
1 = (2, 3, 0, 1),
f 1
2 = (1, 0, 3, 2).

t, consider for instance, t = 0, l = 1. Since f 1

To obtain a zigzag set Zl
Z1
0 = {a0,0, a2,1, a1,2}, and z0 is a linear combination of these elements.
Consider the rebuilding of systematic nodes in Figure 1. In order to rebuild column C1, we access the zigzag sets A =
{Z0
0 , Z0
1}, corresponding to parities {r0, r1}, {z0, z1}. Observe that the surviving elements in A and in B are
both {a0,0, a1,0, a0,2, a1,2}, which are identical and thus have maximal intersection. As a result, only 1/2 of the elements are
accessed. Besides, the coefﬁcients over F3 in the parity linear combinations guarantee that any two nodes are sufﬁcient to
recover all the information, hence the code is MDS.

2 (1) = 0, the zigzag set

1 (2) = 0, f 1

0 (0) = 0, f 1

1}, B = {Z1

0 , Z1

Now we revisit the set of good permutations such that the accessed zigzag sets have maximum intersection from [18]. We
form permutations based on r-ary vectors. Let e1, e2, . . . , em be the standard vector basis of Zm
r . Let e0 be the zero vector. We
will use x to represent both an integer in [0, rm − 1] and its r-ary expansion (the r-ary vector of length m). It will be clear
from the context which meaning is used. All the calculations are done over Zr. Construction 1 is a general setup and Theorem
1 is a special example which achieves optimal rebuilding ratio for systematic nodes. We refer to the former the general zigzag
code, and the latter the optimal zigzag code throughout the paper.
Construction 1 (General zigzag code [18].) Lettheinformationarraybe A = (ai,j) withsize rm × k forsomeintegers k, m.
Let T = {v0, ..., vk−1} ⊆ Zm

r beasubsetofvectorsofsize k,whereforeach v = (v1, ..., vm) ∈ T,

gcd(v1, ..., vm, r) = 1,

(1)
v : [0, rm − 1] →
v(x) = x + lv, where by abuse of notation we use x ∈ [0, rm − 1] both to represent the integer and its r-
j for vj ∈ T. For
j (i) = t}.Duringrebuildingofsystematicnode i,the

where gcd isthegreatestcommondivisor.Forany l, 0 ≤ l ≤ r − 1,and v ∈ T wedeﬁnethepermutation f l
[0, rm − 1] by f l
ary representation, and all the calculations are done over Zr. For simplicity denote the permutation f l
vj
t ∈ [0, rm − 1],wedeﬁnethezigzagsetinparitynode l as Zl
elementsinrows Xl

i = {x ∈ [0, rm − 1] : x · vi = r − l} arerebuiltbyparitynodel, l ∈ [0, r − 1].

t = {ai,j : f l

as f l

For example, for m = 2, r = 3, x = 4, l = 2, v = (0, 1),

f 2
(0,1)(4) = 4 + 2(0, 1) = (1, 1) + (0, 2) = (1, 0) = 3.
(0,1) in a vector notation is (2, 0, 1, 5, 3, 4, 8, 6, 7). From (1) we get that for any i ∈ [0, k − 1]
i | = rm−1 and it is only 1/r of the remaining elements. The following theorem was given in [18] and

One can check that the permutation f 2
and l ∈ [0, r − 1], |Xl
shows that in a special case the set X0
i
Theorem 1 [Optimalzigzagcode[18].]Lettheset of k = m + 1 vectorsbe T = {e0, . . . , em} inConstruction 1.Forthezero
vectore0,modifyXl
0 tobe{x ∈ [0, rm − 1] : x · (1, 1, . . . , 1) = l}.Thenthecodehasoptimalrebuildingratio1/r forrebuilding
anysystematicnode.

is sufﬁcient to rebuild node i, for any i ∈ [0, k − 1].

5

f 2
0
0
1
2
3
4
5
6
7
8

f 2
1
6
7
8
0
1
2
3
4
5

f 2
2
2
0
1
5
3
4
8
6
7

f 1
0
0
1
2
3
4
5
6
7
8

f 1
1
3
4
5
6
7
8
0
1
2

f 1
2
1
2
0
4
5
3
7
8
6

P0

P1

P2

c2a0,0 + a3,1 + a1,2
c2a1,0 + a4,1 + ca2,2
c2a2,0 + a5,1 + ca0,2
c2a3,0 + ca6,1 + ca4,2
c2a4,0 + ca7,1 + ca5,2
c2a5,0 + ca8,1 + a3,2
c2a6,0 + ca0,1 + ca7,2
c2a7,0 + ca1,1 + a8,2
c2a8,0 + ca2,1 + ca6,2
Figure 2. A (6, 3) MDS array code with optimal rebuilding ratio 1/3. The ﬁrst parity P0 corresponds to the row sums, and the corresponding identity
permutations are omitted. The parities P1, P2 are generated by the permutations f 1
i respectively, i = 0, 1, 2. The elements are from F4, and c is a primitive
element of F4.

ca0,0 + a6,1 + a2,2
ca1,0 + a7,1 + ca0,2
ca2,0 + a8,1 + a1,2
ca3,0 + ca0,1 + ca5,2
ca4,0 + ca1,1 + a3,2
ca5,0 + ca2,1 + a4,2
ca6,0 + a3,1 + a8,2
ca7,0 + a4,1 + a6,2
ca8,0 + a5,1 + ca7,2

a0,0 + a0,1 + a0,2
a1,0 + a1,1 + a1,2
a2,0 + a2,1 + a2,2
a3,0 + a3,1 + a3,2
a4,0 + a4,1 + a4,2
a5,0 + a5,1 + a5,2
a6,0 + a6,1 + a6,2
a7,0 + a7,1 + a7,2
a8,0 + a8,1 + a8,2

i , f 2

C0
a0,0
a1,0
a2,0
a3,0
a4,0
a5,0
a6,0
a7,0
a8,0

C1
a0,1
a1,1
a2,1
a3,1
a4,1
a5,1
a6,1
a7,1
a8,1

C2
a0,2
a1,2
a2,2
a3,2
a4,2
a5,2
a6,2
a7,2
a8,2

Figure 1 is an example of Theorem 1 with k = 3, r = 2, m = 2. As mentioned before, only 1/2 of the information is

accessed in order to rebuild C1. The accessed elements are in rows X0

1 = {x ∈ [0, 3] : x · e1 = 0} = {0, 1}.

Figure 2 shows an example with 3 systematic nodes and 3 parity nodes constructed by Theorem 1 with k = 3, r = 2, m = 2.
The code has an optimal rebuilding ratio of 1/3. For instance, if column C1 is erased, accessing rows {0, 1, 2} in the remaining
nodes will be sufﬁcient for rebuilding.

C. MDS Property of Zigzag Codes

Next, we show that by assigning the coefﬁcients in the parities properly, we can make the code MDS. Our proof techniques
are similar to [18], which showed the MDS property for zigzag code with r = 2, and speciﬁc coefﬁcient assignments for the
optimal zigzag code with r = 2, 3.

Let Pj be the permutation matrix corresponding to fj = f 1

j , and denote by Pj(i, l) its (i, l)-th entry. Then Pj(i, l) = 1 if
l + vj = i, and Pj(i, l) = 0 otherwise. Recall that f 1
is the permutation associated with parity 1 and systematic node j. Next
j
we change the coefﬁcients of the code so that it is MDS, namely, we modify Pj(i, l) = 1 to some other non-zero value in F.
When r = 2, 3, assign to the optimal zigzag code for j ≥ 1

j
t=0 et = 0, l + ej = i,
j
t=0 et 6= 0, l + ej = i,

(2)

Here c is a primitive element in F3, F4, for r = 2, 3, respectively. Notice that when r = 2, this assignment is equivalent to
the code construction in [18], and when r = 3 it is identical to [18]. For the general zigzag code, assign

One can see that in all cases, Ps
j

is a generalized permutation matrix corresponding to f s
j .

Let the generator matrix of the code be

c,

if l · ∑
if l · ∑

1,
0, o.w.

Pj(i, l) =

Pj(i, l) =(λj,

0,

if l + vj = i,
o.w.

G =





I

...

I
· · ·
I
· · · P1
...
· · · Pr−1
k−1

k−1

I
P1
0
...
Pr−1
0



.

(k+r)×k

(3)

(4)

Here each sub-matrix is of size rm × rm. Let the information be arranged as a row vector a = (a0, a1, . . . , ak−1) of length
rmk and the codeword be arranged as b = (b0, b1, . . . , bn−1) of length rmn, where each ai or bi corresponding to node i is a
vector of length rm. Then we compute the codeword as

We say that matrix Pt

j is the encoding matrix for systematic node j and parity node t.

b = Ga.

Remark: In general, suppose Aj,t is the encoding matrix for systematic node j and parity node t. We can view every parity
element as an equation. Then the (i, l)-th entry in the matrix corresponds to the coefﬁcient for the i-th element (or equation)
in parity t, and the l-th element (or variable) in systematic node j.

For example, the coefﬁcients in Figure 1 is assigned according to (2), with

6

P1 =


0
0
2
0

0 1
0 0
0 0
2 0

0
1
0
0




, P2 =


0
2
0
0

1 0
0 0
0 0
0 1

0
0
2
0

.




The following theorem shows that using the above assignments the code can be MDS.

Theorem 2 (i)Construction1 canbemadeanMDScodeforalargeenoughﬁniteﬁeld.
(ii)Whenr = 2, 3,ﬁeldofsize 3 and4 issufﬁcienttomaketheoptimalzigzagcodeinTheorem1 MDS.

Proof: Part (i): An MDS code means that it can recover any r erasures. Suppose t systematic nodes and r − t parity nodes
are erased, 1 ≤ t ≤ r. Thus suppose we delete from G in (4) the systematic rows {j1, j2, . . . , jt} and the remaining parity
nodes are {i1, i2, . . . , it}. Then the following t × t block matrix should be invertible:

G′ =


Pi1
j1
...
Pit
j1

· · · Pi1
jt
...
· · · Pit
jt




.

(5)

Its determinant det(G′) is a polynomial with indeterminates λj1 , . . . , λjt. All terms in the polynomial have highest degree
with non-zero coefﬁcient 1 or −1. So det(G′) is a non-zero
rm(i1 + · · · + it). One term with highest degree is ∏t
polynomial. Up to now we only showed one possible case of erasures. For any r erasures, we can ﬁnd the corresponding
det(G′) as a non-zero polynomial. The product of all these polynomials is again a non-zero polynomial. Hence by [2] for a
large enough ﬁeld there exist assignments of {λj} such that the evaluation of the polynomial is not 0. Then for any case of r
erasures, the corresponding matrix G′ is invertible, and the code is MDS.

s=1 λisrm

js

Part (ii) was shown in [18] for the assignment in (2).
Remark: If the non-zero elements in Pj are assigned to be different indeterminates, say, Pj(i, l) = λj,i,l if l + vj = i, and
Pj(i, l) = 0 otherwise. Then the above proof still works and in particular, every determinant det(G′) is a non-zero polynomial.

III. REBUILDING MULTIPLE ERASURES

In this section, we discuss the rebuilding of e erasures, 1 ≤ e ≤ r. In order to simplify some of the results we will assume
that r is a prime and the calculations are done over Fr. Note that all the result can be generalized with minor changes for an
arbitrary integer r and the ring Zr.

We will ﬁrst prove the lower bound for rebuilding ratio and repair bandwidth. Then we show a construction achieving the

lower bound for systematic nodes. At last we show some

A. Lower Bounds

We ﬁrst show that the rebuilding ratio for zigzag codes is at least e/r. Then we show that this lower bound is a special

case for a more general class of codes.
Theorem 3 Considerazigzagcodewith r paritynodes.Inanerasureof 1 ≤ e ≤ r systematicnodes,therebuildingratioisat
least e
r.
Proof: Let the information array be of size p × k. From one zigzag set corresponding to some parity, we get one linear
equation corresponding to the erased elements. Thus in order to recover the e · p elements in the systematic nodes we need to
use at least ep zigzag sets from the r parities. By the pigeonhole principle there is at least one parity node, such that at least
ep/r of its zigzag sets are used. Hence each remaining systematic node has to access its elements that are contained in these
zigzag sets. Therefore each systematic node accesses at least ep/r of its information elements, which is a portion of e
r .
Since we use at least ep zigzag sets, we use at least ep elements in the r parity nodes, which is again a portion of e
r . Hence

the overall rebuilding ratio is at least e
r .

Next, we study the repair bandwidth, namely, the amount of information needed to transmit in order to rebuild e nodes for
a general code (not necessary MDS, systematic, or optimal update). More precisely, we study exact-repair codes that satisfy
the following two properties: (i) Reconstruction: any k nodes can rebuild the total information. (ii) Exact repair: if e nodes are
erased, they can be recovered exactly by transmitting information from the remaining nodes. The total amount of information is
denoted by M, and assume the n nodes are indexed by {1, 2, . . . , n}. For e erasures, 1 ≤ e ≤ r, denote by α, de, βe the amount
of information stored in each node, the number of helper nodes to repair the erased nodes, and the amount of information

7

transmitted by each of the helper nodes, respectively. Assume that de ≥ e. We want to derive the trade-off between these
parameters for an exact-repair code.

The above deﬁnitions are extensions of the single-erasure exact-repair codes in [15]. The following results give a lower

bound of the repair bandwidth for e erasures, and the proof is a generalization of [15].

To prove the main lower bound result, let us bound the conditional entropy of two nodes. We ﬁrst deﬁne some random
variables corresponding to the stored and transmitted information. For subsets A, B ⊆ [n], let WA be the information stored
in nodes A, and SB
Lemma 4 Let B ⊆ [n] beasubsetofnodesofsize e,thenforanarbitrarysetofnodes A, |A| ≤ de,suchthat B ∩ A = ∅,

A be the information transmitted from nodes A to nodes B in the rebuilding.

Proof: If nodes B are erased, consider the case of having nodes A and nodes C as helper nodes, |C| = de − |A|. Then

the exact repair condition requires

H(WB|WA) ≤ min{|B|α, (de − |A|)βe}.

0 = H(WB|SB
= H(WB|SB
≥ H(WB|SB
≥ H(WB|SB
≥ H(WB|WA) − (d − |A|)βe.
Moreover, it is clear that H(WB|WA) ≤ H(WB) ≤ |B|α and the result follows.
Theorem 5 Anyexact-repaircodewithﬁlesizeM mustsatisfythatforany1 ≤ e ≤ r,

A, SB
C)
A) − I(WB, SB
A) − H(SB
C)
A) − (d − |A|)βe

C|SB
A)

where s = k mod e, 0 ≤ s < e.MoreoverforanMDScode,if e ≤ k,

M ≤ sα +

⌊ k
e ⌋−1
∑
i=0

min{eα, (de − ie − s)βe}

k(de − k + e)
Proof: The ﬁle can be reconstructed from any set of k nodes, hence

βe ≥

eM

.

M = H(W[k])

= H(W[s]) +

≤ sα +

⌊ k
e ⌋−1
∑
i=0

⌊ k
e ⌋−1
∑
i=0

H(W[ie+s+1,(i+1)e+s]|W[ie+s])

min{eα, (de − ie − s)βe}.

In an MDS code α = M
be at least M−sα
= e M
⌊ k
e ⌋

k , hence in order to satisfy the inequality any summand of the form min{eα, (de − ie − s)βe} must
k , which occurs if and only if (de − (⌊ k

e ⌋ − 1)e − s)βe ≥ eM

k . Hence we get

βe ≥

eM

k(de − k + e)

.

And the proof is completed.

Therefore, the lower bound of the normalized repair bandwidth for an MDS code (not necessarily optimal update) with

de = n − e is

eM

k(de − k + e)

·

k
M

=

e
r

,

which is the same as the lower bound of the rebuilding ratio in Theorem 3.

8

B. Rebuilding Algorithms

Theorems 3 and 5 provide a lower bound of e/r on the rebuilding ratio in case of e erasures, 1 ≤ e ≤ r. In this subsection
we discuss how to rebuild an MDS array code with optimal update. The ﬁrst main result is Theorem 12, which states that the
optimal zigzag code in Theorem 1 achieves the optimal rebuilding ratio of e/r. In order to prove this optimality result, we
ﬁrst prove necessary and sufﬁcient conditions for optimal rebuilding in Lemmas 6 and 8, based on which we prove sufﬁcient
conditions of optimal rebuilding in Lemmas 9, 11. Correspondingly, Algorithm 1 speciﬁes the rebuilding strategy that satisﬁes
the sufﬁcient conditions. The second main result is that the derived conditions in Lemmas 68 9 and 11 holds for non-optimal
codes as well if we consider the rebuilding ratio incurred at every individual helper node; and Algorithm 1 work for general
zigzag codes as well, and provides a potential trade-off between the code dimension k and the rebuilding ratio, for given r, p.
We start with an example that achieves the optimal rebuilding ratio, which is in fact an instance of the optimal zigzag code

in Theorem 12.
Example 1 Consider the code in Figure 2 with r = 3. When e = 2 and columns C0, C1 are erased, we can access rows
{0, 1, 3, 4, 6, 7} in column C2, P0, rows {1, 2, 4, 5, 7, 8} in column P1, and rows {2, 0, 5, 3, 8, 6} in column P2. One can check
that the accessed elements are sufﬁcient to rebuild the two erased columns, and the rebuilding ratio is 2/3 = e/r. It can be
shownthatsimilar rebuildingcanbedoneforanytwo systematicnodeerasures.Therefore,inthisexamplethelowerboundof
therebuildingratioisachievable.

In the next Lemma, we consider an information array of size p × k and an (n, k) MDS optimal-update code with r = n − k
parity nodes. Each parity node l ∈ [0, r − 1] is constructed from the set of permutations { f l
i } for i ∈ [0, k − 1]. Notice that
in the general case the number of rows p in the array is not necessarily a power of r. From now on, we assume WLOG that
columns [0, e − 1] are erased.
Lemma 6 Below are sufﬁcient and necessary conditionsfor optimal rebuildingratio for e erasures in an MDS optimal-update
code:
Thereexistsaset X ⊆ [0, p − 1] ofsize |X| = ep/r,suchthat

1) Foranyparitynodel, l ∈ [0, r − 1], thegroupGl stabilizes theset X,i.e.,forany g ∈ Gl,

where Gl isgeneratedbythesetofpermutations{ f −l

2) Foranyerasedcolumni ∈ [0, e − 1],

e (X) = [0, p − 1].
3) The ep equations(zigzagsets)deﬁnedbytheset X arelinearlyindependent.

∪r−1
l=0 ( f l

i )−1 f l

g(X) = X,

e ◦ f l

j }k−1
j=e .

(6)

(7)

Proof: In an erasure of e columns, ep elements need rebuilt, hence we need ep equations (zigzags) that contain these
elements. In an optimal rebuilding scheme, each parity node contributes ep/r equations by accessing the values of ep/r of
its zigzag elements. Moreover, the union of the zigzag sets that create these zigzag elements constitutes an e/r portion of
the elements in the surviving systematic nodes. In other words, assume that we access rows X from the surviving columns
[e, k − 1], X ⊆ [0, p − 1], then |X| = ep/r and

f l
j (X) = f l

i (X)

for any parity node l ∈ [0, r − 1] and i, j ∈ [e, k − 1]. Note that it is equivalent that for any parity node l ∈ [0, r − 1] and
surviving systematic node j ∈ [e, k − 1]

f l
j (X) = f l

e (X).

Let Gl be the subgroup of the symmetric group Sp that is generated by the set of permutations { f −l
( f l
the group Gl stabilizes X, i.e., for any f ∈ Gl, f (X) = X.

e =
e. It is easy to see that the previous condition is also equivalent to that for any parity l ∈ [0, r − 1]

e )−1 is the inverse of f l

e ◦ f l

j }k−1

j=e , where f −l

Assuming there is a set X that satisﬁes this condition, we want to rebuild the ep elements from the chosen ep equations, i.e.,
the ep equations with the ep variables being solvable. Firstly we need the condition that each element in the erased column
will appear at least once in the chosen zigzag sets (equations). Parity l ∈ [0, r − 1] accesses its zigzag elements f l
e (X), and
these zigzag sets contain the elements in rows f −l
f l
e (X) of the erased column i ∈ [0, e − 1]. Hence the condition is equivalent
to that for any erased column i ∈ [0, e − 1],

i

∪r−1
l=0( f l

i )−1 f l

e (X) = [0, p − 1].

In addition, we need to make sure that the ep equations are linearly independent, which depends on the coefﬁcients in the
linear combinations that created the zigzag elements.

Next we will interpret these conditions in the special case where the number of rows p = rm, and the permutations are
i (x) = x + lvi for any x ∈ [0, rm − 1]. From here on

r and Construction 1, i.e., f l

generated by T = {v0, v1, . . . , vk−1} ⊆ Fm
we will focus only on the special case with p = rm and r prime.

Corollary 7 Belowaresufﬁcientandnecessaryconditionsforoptimalrebuildingratioin e erasuresforgeneralzigzagcodes:
Thereexistsaset X ⊆ Fm

r ofsize |X| = erm−1,suchthat

1) X isaunionofcosetsofthesubspace

Z = span{ve+1 − ve, . . . , vk−1 − ve}.

2) Foranyerasedcolumni ∈ [0, e − 1],

∪r−1
l=0 (X + l(vi − ve)) = Fm
r .
3) The erm equations(zigzagsets)deﬁnedbytheset X arelinearlyindependent.

Proof: Consider the general zigzag codes of Construction 1. Note that in the case of r a prime

G1 = G2 = ... = Gr−1,

9

(8)

and in that case we simply denote the group as G. Condition 2) follows directly from the deﬁnition of the permutation f l
condition 3) is identical to Lemma 6. We only need to show the following for condition 1):
Deﬁne X ⊆ Fm

r and G as above, then G stabilizes X, if and only if X is a union of cosets of the subspace

i , and

Z = span{ve+1 − ve, . . . , vk−1 − ve}.

(9)

It is easy to check that any coset of Z is stabilized by G, hence if X is a union of cosets it is also a stabilized set. For the
other direction let x, y ∈ Fm
r be two vectors in the same coset of Z, it is enough to show that if x ∈ X then also y ∈ X. Since
y − x ∈ Z there exist α1, ..., αk−1−e ∈ [0, r − 1] such that y − x = ∑k−1−e
αi(ve+i − ve). Since f (X) = X for any f ∈ G we
get that f (x) ∈ X for any x ∈ X and f ∈ G, hence

i=1

y = x + y − x
k−1−e
∑
i=1
−αk−1−e
e

= x +

= f

f

αi(ve+i − ve)

αk−1−e
k−1

... f −α1

e

f α1
e+1(x) ∈ X,

where we used the fact that f

... f −α1
Remark: For any set of vectors S and v, u ∈ S,

αk−1−e
k−1

−αk−1−e
e

f

e

f α1
e+1 ∈ G. So y ∈ X and the result follows.

span{S − v} = span{S − u}.

Here S − v = {vi − v|vi ∈ S}. Hence, the subspace Z deﬁned in the previous theorem does not depend on the choice of the
vector ve. We can equivalently replace ve with any vi, i ∈ [e, k − 1].

The following theorem gives a simple equivalent condition for conditions 1), 2) in Corollary 7.

Lemma 8 Thereexistsaset X ⊆ Fm

r ofsize |X| = erm−1 suchthatconditions1), 2) inCorollary7 aresatisﬁedifandonlyif

vi − ve /∈ Z

(10)

foranyerasedcolumni ∈ [0, e − 1].

l=0(X + l(vi − ve)) = Fm

r , which is a contradiction to X ( Fm

Proof: Assume conditions 1), 2) are satisﬁed. If vi − ve ∈ Z for some erased column i ∈ [0, e − 1] then by condition 2),
X = ∪r−1
r . On the other hand, If (10) is true, then vi − ve can
be viewed as a permutation that acts on the cosets of Z. The number of cosets of Z is rm/|Z| and this permutation (when
it is written in cycle notation) contains rm−1/|Z| cycles, each with length r. For each i ∈ [0, e − 1] choose rm−1/|Z| cosets
of Z, one from each cycle of the permutation vi − ve. In total erm−1/|Z| cosets are chosen for the e erased nodes. Let X be
the union of the cosets that were chosen. It is easy to see that X satisﬁes condition 2). If |X| < erm−1 (Since there might be
cosets that were chosen more than once) add arbitrary (erm−1 − |X|)/|Z| other cosets of Z, and also condition 1) is satisﬁed.

In general, if (10) is not satisﬁed, the code does not have an optimal rebuilding ratio. However we can deﬁne the optimal

subspace as

Z = span{vi − ve}i∈I,

(11)

where we assume w.l.o.g. e ∈ I and I ⊆ [e, k − 1] is a maximal subset of surviving nodes that satisﬁes for any erased node
j ∈ [0, e − 1], vj − ve /∈ Z. Hence from now on we assume that Z is deﬁned by a subset of surviving nodes I. This set of
surviving nodes will have an optimal rebuilding ratio (see Corollary 10), i.e., in the rebuilding of columns [0, e − 1], columns I
will access a portion of e/r of their elements. The following theorem gives a sufﬁcient condition for the erm equations deﬁned
by the set X to be solvable linear equations.

10

Lemma 9 SupposethatthereexistsasubspaceX0 thatcontainstheoptimalsubspaceZ suchthatforanyerasednodei ∈ [0, e − 1]
(12)

X0 ⊕ span{vi − ve} = Fm
r ,

where ⊕ denotesthedirectsumoftwosubspaces,thenoveralargeenoughﬁeld,theset X deﬁnedasanunionofsome e cosets
of X0 satisﬁestheconditionsinCorollary7 andthecorrespondinggeneralzigzagcodeisMDS.

Proof: Condition 1) is trivial. Note that by (12), l(vi − ve) /∈ X0 for any l ∈ [1, r − 1] and i ∈ [0, e − 1], hence
{X0 + l(vi − ve)}l∈[0,r−1] is the set of cosets of X0. Let Xj = X0 + j(vi − ve) be a coset of X0 for some i ∈ [0, e − 1] and
suppose Xj ⊂ X. Now let us check condition 2):

∪r−1
l=0(X + l(vi − ve)) ⊇ ∪r−1
l=0(Xj + l(vi − ve))
= ∪r−1
l=0(X0 + j(vi − ve) + l(vi − ve))
= ∪r−1
l=0(X0 + (j + l)(vi − ve))
= ∪r−1
t=0(X0 + t(vi − ve))
= Fm
r .

(13)
(14)

(13) holds since j + l is computed mod r. So condition 2) is satisﬁed.

Next we prove condition 3) and that the code is MDS. Let every coefﬁcient in the encoding matrices Pi

j (which are generalized
permutation matrices) be an indeterminate. There are erm unknowns and erm equations during the rebuilding of e erasures.
Writing the equations in a matrix form we get AY = b, where A is an erm × erm matrix. Y, b are vectors of length erm, and
Y = (y1, ..., yerm)T is the unknown vector. The matrix A = (ai,j) is deﬁned as ai,j = xi,j if the unknown yj appears in the i-th
equation, otherwise ai,j = 0. Hence we can solve the equations if and only if there is assignment for the indetermediates {xi,j}
in the matrix A such that det(A) 6= 0. By (14), accessing rows corresponding to any coset Xj will give us equations where
each unknown appears exactly once. Since X is a union of e cosets, each unknown appears e times in the equations. Thus
each column in A contains e indeterminates. Moreover, each equation contains one unknown from each erased node, thus any
row in A contains e indeterminates. Then by Hall’s Marriage Theorem [10] we conclude that there exists a permutation f on
the integers [1, erm] such that

erm
∏
i=1

ai, f (i) 6= 0.

Hence the polynomial det(A) when viewed as a symbolic polynomial, is not the zero polynomial, i.e.,

det(A) = ∑

sgn( f )

f ∈Serm

erm
∏
i=1

ai, f (i) 6= 0.

By [2] we conclude that there is an assignment from a ﬁeld large enough for the indeterminates such that det(A) 6= 0, and
the equations are solvable. Note that this proof is for a speciﬁc set of erased nodes. However if (12) is satisﬁed for any set
of e erasures, multiplication of all the nonzero polynomials det(A) derived for any set of erased nodes is again a nonzero
polynomial. To show that the code MDS, we can use the remark after Theorem 2. We multiply the above nonzero polynomial
by det(G′) for all G′ as in (4). Then we again obtain a nonzero polynomial. We conclude that there is an assignment over a
ﬁeld large enough such that any of the matrices A and G′ is invertible, and the result follows.

Suppose the subspace X0 in Lemma 9 exits for a subset of nodes I, we give an upper bound for the rebuilding ratio. Notice

here that the ratio is only calculated for the speciﬁc erasures [0, e − 1] instead of averaging over all erasure cases.
Corollary 10 Lemma9 requiresrebuildingratioatmost

e
r

+

(r − e)(k − |I| − e)

r(k + r − e)

.

Proof: By Lemma 9, the fraction of accessed elements in columns I and the parity columns is e/r of each column.
Moreover, the accessed elements in the rest columns are at most an entire column. Therefore, the rebuilding ratio is at most

e
r (|I| + r) + (k − |I| − e)

k + r − e

=

e
r

+

(r − e)(k − |I| − e)

r(k + r − e)

and the result follows.

Note that as expected when |I| = k − e the rebuilding ratio is optimal, i.e., e/r.
In order to use Lemma 9, we need to ﬁnd a subspace X0 as in (12). The following theorem shows that such a subspace

always exists, moreover it gives an explicit construction of it.

Lemma 11 Suppose 1 ≤ e < r erasuresoccur. Let Z be deﬁned by (11) that satisfy Lemma 8, namely, vi − ve /∈ Z for any
erasednodei ∈ [0, e − 1].Thenthereexists u ⊥ Z suchthatforanyi ∈ [0, e − 1],

u · (vi − ve) 6= 0.
Moreovertheorthogonalsubspace X0 = (u)⊥ satisﬁes (12) inLemma9.

(15)

Proof: First we will show that such vector u exists. Let u1, ...ut be a basis for (Z)⊥, the orthogonal subspace of Z. Any
vector u in (Z)⊥ can be written as u = ∑t
j=1 xjuj for some unknown xj’s. We claim that for any i ∈ [0, e − 1] there exists
j such that uj · (vi − ve) 6= 0. Because otherwise, (Z)⊥ = span{u1, . . . , ut} ⊥ (vi − ve), which means vi − ve ∈ Z and
reaches a contradiction. Thus the number of solutions for (x1, . . . , xt) in the linear equation

11

t
∑
j=1

xjuj · (vi − ve) = 0

is at most rt−1, which equals the number of u such that u · (vi − ve) = 0. Hence by the union bound there are at most ert−1
vectors u in (Z)⊥ such that u · (vi − ve) = 0 for some erased node i ∈ [0, e − 1]. Since |(Z)⊥| = rt > ert−1 there exists u
in (Z)⊥ such that for any erased node i ∈ [0, e − 1],

Deﬁne X0 = (u)⊥, and note that for any erased node i ∈ [0, e − 1], vi − ve /∈ X0, since u · (vi − ve) 6= 0 and X0 is the
orthogonal subspace of u. Moreover, since X0 is a hyperplane we conclude that

u · (vi − ve) 6= 0.

and the result follows.

Lemmas 9 and 11 give us an algorithm to rebuild multiple erasures.

X0 ⊕ span{vi − ve} = Fm
r ,

Algorithm 1 Rebuilding algorithm for a zigzag code satisfying Lemma 9.
1: Find Z by (11) satisfying (10).
2: Find u ⊥ Z satisfying (15). Deﬁne X0 = (u)⊥ and X as a union of e cosets of X0.
3: Access rows f l

e (X) in parity l ∈ [0, r − 1] and all the corresponding information elements.

Remark: By Lemma 9 we know that under a proper selection of coefﬁcients the rebuilding is possible for any e erasures,

1 ≤ e ≤ r, and the code can be made MDS.

In the following we give two examples of rebuilding using this algorithm. The ﬁrst example shows an optimal rebuilding
for any set of e node erasures. As mentioned above, the optimal rebuilding is achieved since (10) is satisﬁed for all surviving
nodes, i.e., I = [e, k − 1].
Example 2 Let T = {v0, v1, . . . , vm} beasetofvectorsthatcontainsanorthonormalbasisof Fm
r togetherwiththezerovector.
Supposecolumns [0, e − 1] areerased.Notethatinthatcase I = [e, m] and Z isdeﬁnedasin (11). Dependingonwhetherthe
zerovectoriserasedornot,wehavetwodifferentcases.When v0 = 0 deﬁne

When ve = 0 deﬁne

u =

m
∑
j=e

vj.

u =

e−1
∑
j=0

vj.

LetX0 = (u)⊥.Itiseasytocheckthatu ⊥ Z andforanyerasedcolumni ∈ [0, e − 1], u · (vi − ve) 6= 0.Noticethat|I| = k − e.
ThereforebyLemma11 andCorollary10,aset X deﬁnedasaunionofanarbitrarye cosetsofX0 satisﬁeshasoptimalrebuilding
ratio e/r.Moreover,itcanbeveriﬁedthatwhen r = 3,thecoefﬁcientsin (2) satisﬁescondition3).Therefore,when r = 3,we
haveanMDScodewith F4 andoptimalrebuildingforall e ≤ 3.

In the case of a single erasure, Example 2 coincides with the rebuilding algorithm in Theorem 1. In the example of Figure
2, we know that the vectors generating the permutations are the standard basis (and thus are orthonormal basis) and the zero
vector. When columns C0, C1 are erased, u = e2 and X0 = (u)⊥ = span{e1} = {0, 3, 6}. Take X as the union of X0 and
its coset {1, 4, 7}, which is the same as Example 1. One can check that each erased element appears exactly 3 times in the
equations and the equations are solvable in F4. Similarly, the equations are solvable for other 2 systematic erasures.

We summarize the result of the above example in the next theorem. In particular, when T is the set of standard basis and

the zero vector as in Theorem 1, we obtain an optimal rebuilding code.

Theorem 12 TheoptimalzigzagcodeisanMDScodewith n = m + r, k = m + 1, p = rm,foranyprimer andpositiveinteger
m,thathasoptimalrebuildingratioof e/r foranysetof e erasures,1 ≤ e ≤ r.

12

In the following example the code has O(m2) columns. The set I does not contain all the surviving systematic nodes, hence

the rebuilding is not optimal but is at most 1
Example 3 Suppose2|m.Let T = {v = (v1, . . . , vm) : kvk1 = 2, vi = 1, vj = 1, forsomei ∈ [1, m/2], j ∈ [m/2 + 1, m] ⊂
Fm
2 be the set of vectorsgeneratingthe code with r = 2 parities, hence the numberof systematic nodes is |T| = k = m2/4.
Supposecolumnw = (w1, . . . , wm), w1 = wm/2+1 = 1 iserased.Deﬁnetheset I = {v ∈ T : v1 = 0}, and

2 + O( 1

m ).

Z = span{vi − ve|i ∈ I}

forsome e ∈ I.Thus |I| = m(m − 2)/4.Itcanbeseenthat Z deﬁnedbytheset I satisﬁes (10),i.e., w − ve /∈ Z sincetheﬁrst
coordinateofavectorin Z isalways0,asopposeto1 forthevectorw − ve.Deﬁne u = (0, 1, ..., 1) and X0 = (u)⊥. Itiseasyto
checkthat u ⊥ Z and u · (w − ve) = 1 6= 0. Hence,theconditionsinLemma11 aresatisﬁedandrebuildingcanbedoneusing
X0.MoreoverbyCorollary10 therebuildingratioisatmost

1
2

+

1
2

(m/2) − 1
(m2/4) + 1

≈

1
2

+

1
m

.

Notethatbypropercoefﬁcientsassignment(similartoConstruction3in[18])wecanuseaﬁeldofsize 5 or 8 toassurethatthe
codeisanMDScode.

C. Minimum Number of Erasures with Optimal Rebuilding

Next we want to point out a surprising phenomena in terms of how many erasures can be optimally rebuilt for a given code.

We say that a set of vectors S satisﬁes property e for e ≥ 1 if for any subset A ⊆ S of size e and any u ∈ A,

u − v /∈ span{w − v : w ∈ S\A},

where v ∈ S\A. Recall that by Lemma 8 any set of vectors that generates a code C and can rebuild optimally any e erasures
should satisfy property e. The following theorem shows that this property is monotonic, i.e., if S satisﬁes property e then it
also satisﬁes property a for any e ≤ a ≤ |S|.
Theorem 13 Let S beasetofvectorsthatsatisﬁespropertye,thenitalsosatisﬁespropertya,forany e ≤ a ≤ |S|.

Proof: Let A ⊆ S, |A| = e + 1 and assume to the contrary that u − v ∈ span{w − v : w ∈ S\A} for some u ∈ A
and v ∈ S\A. |A| ≥ 2 hence there exists x ∈ A\{u}. It is easy to verify that u − v ∈ span{w − v : w ∈ S\A∗}, where
A∗ = A\{x} and |A∗| = e which contradicts the property e for the set S.

Hence, from the previous theorem we conclude that a code C that can rebuild optimally e erasures, is able to rebuild optimally
any number of erasures greater than e as well. However, as pointed out already there are codes with r parities that can not
rebuild optimally from some e < r erasures. Therefore, one might expect to ﬁnd a code C with parameter e∗ ≥ 1 such that it
can rebuild optimally e erasures only when e∗ ≤ e ≤ r. For example, for r = 3, m = 2 let C be the zigzag code constructed
by the vectors {0, e1, e2, e1 + e2}. It was proven in [18] that if an MDS optimal-update code optimally rebuilds any single
erasure, and has p = rm, then

k ≤ m + 1.

(16)

Thus the above code C cannot rebuild one erasure optimally. However, one can check that for any two erased columns, the
conditions in Lemma 9 are satisﬁed hence the code can rebuild optimally for any e = 2 erasures and we conclude that e∗ = 2
for this code.

The phenomena that some codes has a threshold parameter e∗, such that only when the number of erasures e is at least the
threshold e∗ can the code rebuild optimally, is counter intuitive and surprising. This phenomena gives rise to another question.
From (16) a code with optimal rebuilding for single erasure must have k ≤ m + 1. Can k be increased in a code with an
optimal rebuilding of e erasures, e > 1? The previous example answers this question afﬁrmatively and shows a code with
k = 4 = m + 2 can rebuild optimally any e = 2 erasures, but not 1 erasure. The following theorem gives an upper bound for
the maximum systematic columns in a code that rebuilds optimally any e erasures, and it coincides with (16) when e = 1.
Theorem 14 Let C be a zigzag code constructed by Construction 1 using vectors from Fm
erasures,forsome1 ≤ e < r,thenthenumberofsystematiccolumnsk inthecodesatisﬁes

r . If C can rebuild optimally any e

Proof: Consider a code with length k and generated by vectors v0, v1, . . . , vk−1. If these vectors are linearly independent
then k ≤ m and we are done. Otherwise they are dependent. Suppose e columns are erased, 1 ≤ e < r. Let ve be a surviving
column. Consider the set a of vectors: R = {vi − ve : i ∈ [0, k − 1], i 6= e}. We know that the code can rebuild optimally only

k ≤ m + e.

13

if (10) is satisﬁed for all possible e erasures. Thus for any i 6= e, i ∈ [0, k − 1], if column i is erased and column e is not, we
have vi − ve /∈ Z and thus vi − ve 6= 0. So every vector in R is nonzero. Let s be the minimum number of dependent vectors
in R, that is, the minimum number of vectors in R such that they are dependent. For nonzero vectors, we have s ≥ 2. Say
{ve+1 − ve, ve+2 − ve, . . . , ve+s − ve} is a minimum dependent set of vector. Since any m + 1 vectors are dependent in Fm
r ,

s ≤ m + 1.

We are going to show k − e ≤ s − 1. Suppose to the contrary that the number of remaining columns satisﬁes k − e ≥ s
and e erasures occur. When column ve+s is erased and the s columns {ve, ve+1, . . . , ve+s−1} are not, we should be able to
rebuild optimally. However since we chose a dependent set of vectors, ve+s − ve is a linear combination of {ve+1 − ve, ve+2 −
ve, . . . , ve+s−1 − ve}, whose span is contained in Z in (10). Hence (10) is violated and we reach a contradiction. Therefore,

k − e ≤ s − 1 ≤ m.

We know that this upper bound is tight in some cases. For e = 1 we already gave codes with optimal rebuilding of 1 erasure
and k = m + 1 systematic columns in Theorem 1. Moreover, for e = 2 the code constructed by the vectors {0, e1, e2, e1 + e2}
reaches the upper bound with k = 4 systematic columns. It is an open research problem whether this bound is achievable for
any k, m, e.

IV. OPTIMAL REBUILDING FOR ANY NODE

Zigzag code in Theorem 1 has optimal rebuilding for systematic nodes. However, in order to rebuild a parity node, one
has to access all the information elements. In this section we construct MDS codes with optimal rebuilding ratio for a single
systematic or parity node. The code has k = m − 1 systematic nodes, r parities nodes, and rm rows, for any m, r.

We ﬁrst describe the code construction using encoding matrices, and then prove its optimality for rebuilding, and at last

show its MDS property.

A. Code Construction

For i ∈ [0, r − 1], deﬁne Xi as the i-th set of vectors of size rm lexicographically, namely,

Xi = {v ∈ Zm
r

: v · e1 = i}.

X0 is a subgroup of Zm
Pj corresponding to fj can be written as a r × r block matrix:

r . Deﬁne for j ∈ [2, m] a permutation fj(x) = x + ej + e1, x ∈ [0, rm − 1]. So the permutation matrix

Pj =


pj

pj

...

pj




,

(17)

where pj of size rm−1 × rm−1 corresponds to the restricted mapping of fj
7→ Xi+1. In particular, represent integer
l, i ∈ [0, rm−1 − 1] by a r-ary vector of length m by appending a 0 in the ﬁrst coordinate. We can view l, i as vectors in X0.
Then the (i, l)-th entry of pj is 1 if and only if

: Xi

l + ej = i,

for i, l ∈ X0. It is clear that pj is a matrix of order r, i.e., pr
section, the superscript of pj are computed modulo r. For example, pi−i′

j is the identity permutation and pl
denotes pi−i′ mod r

j 6= 1 for any 0 < l < r. In this
, for integers i, i′.

Next we assign coefﬁcients in Pj. In order to ensure MDS property, we modify pj to generalized permutation matrices the

j

j

same way as in zigzag code (2)(3), j ∈ [2, m]. Denote by pj(i, l) the (i, l)-th element of pj. When r = 2, 3,

j
t=2 et = 0, l + ej = i,
j
t=2 et 6= 0, l + ej = i,

(18)

Note here the summation ∑
element in F3, F4, for r = 2, 3, respectively. When r ≥ 4,

j
t=2 et is from t = 2 since we will index the systematic nodes by {2, 3, . . . , m}. Here c is a primitive

if l + ej = i,
o.w.

(19)

c,

if l · ∑
if l · ∑

1,
0, o.w.

pj(i, l) =

pj(i, l) =(λj,

0,

14

(cid:1827)(cid:2868)(cid:3404) 
(cid:1827)(cid:2869)(cid:3404) 

(cid:3)(cid:3)(cid:1835)(cid:3)(cid:3) 
(cid:3)(cid:3)(cid:1868)(cid:3)  (cid:884)(cid:1868) 
(cid:1868) (cid:1835) 
(cid:3)(cid:3)(cid:1868)(cid:3) 

(cid:3)(cid:3)(cid:1835)(cid:3)(cid:3) 
(cid:3)(cid:3)(cid:1868)(cid:3)  (cid:2009)(cid:1868)(cid:2870) 
  (cid:1868)(cid:2870) 
(cid:3)(cid:3)(cid:1868)(cid:3) 
(cid:1868)(cid:2870) (cid:1835) (cid:1868) 
(cid:2009)(cid:1868)(cid:2870) 
(cid:1868) 

(cid:1827)(cid:2868)(cid:3404) 
(cid:1827)(cid:2869)(cid:3404) 
(cid:1827)(cid:2870)(cid:3404) 

(cid:1868) 
(cid:2009)(cid:1868)(cid:2870) 
(cid:1868) 
(cid:1868)(cid:2870) (cid:1835) 

Figure 3.
Parity matrices Ai for r = 2 (left) and r = 3 (right) parities. When the 0th parity node is erased, the 0th row block X0 is accessed from very
surviving node. The underlined elements are computed from the accessed information elements. The remaining unknown terms in A0 are recovered by the
shaded elements from parity nodes.

In the following, we will use block matrices the same as single elements. When referring to row or column indices, we
mean block row or column indices. We refer to pj as a small block, and the corresponding block row or column as a small
block row or column. And Pj is called a big block with big block row or column.

To deﬁne the encoding matrices, we ﬁrst deﬁne some subset of indices Li, for any i ∈ [0, r − 1]:

{i + 1, . . . , i + r−1
2 },
{i + 1, . . . , i + r
2 },
{i + 1, . . . , i + r
2 − 1},

r odd,
r even, 0 ≤ i < r
2 ,
r even, r

2 ≤ i ≤ r − 1,

Li =


where additions and subtractions are modulo r. Deﬁne its complement excluding i as Li = {0, 1, . . . , i − 1, i + 1, . . . , r − 1}\Li.
Note that i′ ∈ Li if and only if i ∈ Li′.
Let us deﬁne the encoding matrix Ai

j for the j-th systematic node and the i-th parity, j ∈ [2, m], i ∈ [0, r − 1]. Let Ai

j(x, y)

be the rm−1 × rm−1 small block in block row x and block column y of the big block Ai

j, x, y ∈ [0, r − 1]. Then

Ai

j(x, y) =

,

p−i+x
j
αpi−x
,
j
pi−x
,
j
0,

y = i, 0 ≤ x ≤ r − 1,
x = y ∈ Li,
x = y ∈ Li,
o.w.




where α 6= 0, 1 is an element of the ﬁnite ﬁeld F. Therefore, for i = 0, j ∈ [2, m], we have

A0

j =

0
1
2
...
r − 2
r − 1





0
I
pj
p2
j
...
pr−2
j
pr−1
j

1

2

· · ·

r − 2

r − 1

αpr−1

j

αpr−2

j

...

p2
j

pj





where α is multiplied to the diagonal in rows L0 = {1, . . . , ⌊ r

2 ⌋}. Moreover, Ai

j is obtained by cyclicly shifting the rows and

15

C2
a0,1
a1,1
a2,1
a3,1
a4,1
a5,1
a6,1
a7,1

0
1
2
3
4
5
6
7

C3
a0,2
a1,2
a2,2
a3,2
a4,2
a5,2
a6,2
a7,2

P0

a0,1 + a0,2
a1,1 + a1,2
a2,1 + a2,2
a3,1 + a3,2

P1

a2,1 + a6,1 + a1,2 + a5,2
a3,1 + a7,1 + 2a0,2 + 2a4,2
2a0,1 + 2a4,1 + 2a3,2 + 2a7,2
2a1,1 + 2a5,1 + a2,2 + a6,2

a2,1 + 2a6,1 + a1,2 + 2a5,2
a3,1 + 2a7,1 + 2a0,2 + a4,2
2a0,1 + a4,1 + 2a3,2 + a7,2
2a1,1 + a5,1 + a2,2 + 2a6,2

a4,1 + a4,2
a5,1 + a5,2
a6,1 + a6,2
a7,1 + a7,2

Figure 4. An MDS array code with two systematic and two parity nodes by Construction 2. The ﬁnite ﬁeld used is F3.

columns of A0

j to the right and bottom by i positions (with possibly one change in a coefﬁcient):

Ai

j =

0
β1 pi
j

0
...
i − 1
i
i + 1
...
r − 1





· · ·

i − 1

i

i + 1

· · ·

r − 1

...

βi−1 pj

pr−i
j
...
pr−1
j
I
pj
...

pr−i−1
j

βi+1 pr−1

j

...

βr−1 pi+1

j

βx =(α,

1,

if x ∈ Li,
if x ∈ Li.

.





where

Construction 2 Letk = m − 1.Supposetheinformationarrayisofsizerm × k,andthesystematicnodesareindexed[2, m],the
paritynodesareindexed[0, r − 1].Lettheﬁrst k nodesbesystematic,andthelastr nodesbeparities.Thegeneratormatrixofthe
codeis

I

A0
2
...
Ar−1





...

I
· · · A0
m
...
· · · Ar−1

m

.





2
Notation: It should be noted that the superscript in Ai
j does not denote power of the matrix, but the superscript in pi
denote the power of pj. Sometimes we will omit the subscript j when it is clear in the context.
Example 4 Forcodeswithtwoandthreeparities,theencodingmatrices Ai areshowninFigure3.Whenr = 2,asﬁniteﬁeld F3
isused,wecantake α = 2 6= 1.Coefﬁcient α = 2 ismultipliedtoonlytheseconddiagonalin A0.Whenr = 3,ﬁniteﬁeld F4 is
usedandwechoosesomeelement α 6= 0, 1, α ∈ F4.Itcanbeseenthat A1, A2 aresimplyshiftedversionsof A0.Anexampleof
acodewithr = 2, m = 3, k = 2,isshowninFigure4.

j does

It can be seen from Construction 2 and Figure 4 that this code is not optimal update. In fact each information element

appears 2r − 1 times in the parities.

B. Optimal Rebuilding for Systematic and Parity Nodes

Next we show that the code in Construction 2 has optimal rebuilding ratio. We ﬁrst make some observations which are the

key in proving the optimality of the rebuilding schemes.
(O1) In small block row i of Ai = Ai

entry. Therefore, for any row l ∈ Xi, the corresponding non-zero element is 1 in column l of Ai.

(O2) In block row i′ of Ai, i′ ∈ Li, there are two non-zero small blocks, pi′−i, pi−i′, corresponding to block columns i, i′,
respectively. Thus for every row (or parity) in this block row i′, there are two non-zero contributing terms. Similarly,

j, there is only one non-zero small block, I, which is in block column i or the diagonal

block row i of A′
Writing these blocks together, we have:

i has two non-zero small blocks, αpi′−i, pi−i′, also corresponding to block columns i, i′, respectively.

16

i′ in Ai
i in Ai′

(cid:18)

i

pi′−i
pi′−i

· · ·
· · ·

i′

αpi−i′
pi−i′

· · ·
· · ·

· · ·

· · · (cid:19).

(20)

Moreover, if we consider row l ∈ Xi′ of Ai and row l + (i − i′)e1 ∈ Xi of Ai′, for i′ ∈ Li, we can see that they
correspond to the the same columns (variables) but linearly independent terms for the parities i, i′:

bxl+(i−i′)(ej+e1) + αcxl−(i−i′)ej
bxl+(i−i′)(ej+e1) + cxl−(i−i′)ej
,

,

where (x0, . . . , x2m) are the elements (variables) in systematic node j, b is the (l − i′e1, l − i′e1 − (i′ − i)ej)-th entry in
pi′−i, and c is the (l − i′e1, l − i′e1 − (i − i′)ej)-th coefﬁcient in pi−i′.

Theorem 15 ThecodeinConstruction 2 hasoptimalrebuildingratio 1/r forrebuildinganynode.Morespeciﬁcally,whenthe
systematicnodeei iserased,i ∈ [2, m],weonlyneedtoaccesselementsYi = {v ∈ Zm
: v · ei = 0}.Whentheparityi iserased,
r
i ∈ [0, r − 1],weonlyneedtoaccesselements Xi = {v ∈ Zm
r

: v · e1 = i}.

Proof: Systematic rebuilding: W.l.o.g. assume that column e2 is erased. Access elements (equations) Y := Y2 = {v ∈
Zm
: v · e2 = 0} from each parity. Let the elements in information node 2 be unknowns (x0, . . . , xrm−1). We treat elements
r
in the remaining systematic columns 3, . . . , m as known constants, and consider each accessed parity element as an equation.
So we will focus on the matrices Ai
2, i ∈ [0, r − 1], which are coefﬁcients of the unknowns in the equation. We will show
that all the unknowns (x0, . . . , xrm−1) in column 2 are solvable from the accessed equations. First notice that Y is a subgroup
of Zm
r can be written as one of the
following three cases:

r , and coset Y − te1 = Y for any t ∈ [0, r − 1]. So one can verify that elements in Zm

r = {l, l − te2, l + t(e2 + e1) : l ∈ Y, t ∈ L0}.
So we need to show that an unknown element indexed by these three cases is solvable.

Zm

For any l ∈ Y, assume l ∈ Y ∩ Xi′ for some i′. First, consider the accessed equation l of parity i′. by (O1) xl is solvable

from equation

xl = f

for some constant f computed from parity and surviving information elements. Next consider the pair of unknowns (xl−te2, xl+t(e1+e2))
with t = i − i′, t ∈ L0, i.e., i′ ∈ Li. We consider accessed equation l ∈ Y ∩ X′
l + (i − i′)e1 ∈ Y ∩ Xi of parity i′. By (O2), we have equations

i of parity i and accessed equation

bxl+t(e2+e1) + αcxl−te2 = g
bxl+t(e2+e1) + cxl−te2 = h

for some coefﬁcients α 6= 0, 1, b, c 6= 0, and constants g, h computed from parity and the surviving elements. These equations
are obviously independent. Hence all unknowns are solvable.

Next we show that only elements in Y are accessed for every surviving node, and thus the rebuilding ratio is 1/r. For any
parity node i, only rows Y are accessed. The accessed elements in systematic node j are indexed by the columns corresponding
to the non-zero entries of Ai
j in rows (equations) Y, j ∈ [3, m], i ∈ [0, r − 1]. For a surviving systematic node j and parity
i, j ∈ [3, m], i ∈ [0, r − 1], we can see from (O1) that any element l ∈ Y ∩ Xi of parity i corresponds to columns (or
j; for i′
accessed systematic element) l of Ai
6= i, from (O2) any element l ∈ Y ∩ Xi′ of parity i corresponds to columns
l + (i − i′)(e1 + ej) and l − (i − i′)ej of Ai
j, both of which belong to Y. Thus only elements Y are accessed from each node.
Parity rebuilding: Since the parities are all symmetric, w.l.o.g. suppose the 0-th parity is erased. Access X0 from each

node. Need to show this is sufﬁcient to recover

[A0

2, . . . , A0

m]C,

where C = [C2, . . . , Cm]T ∈ F(m−1)2m is the vector of systematic elements. In (O2) take i′ = 0, then from a surviving parity
i we can access block row 0 of matrix [Ai

m]C, i ∈ [1, r − 1]:

2, . . . , Ai
2 · · ·

2 · · · p−i

[βpi

βpi

3 · · · p−i

3 · · ·

· · · βpi

m · · · p−i

m · · ·

]C,

where β is

|

Ai
2

{z

}

|

Ai
3

{z
β =(1,

α,

Ai
m

{z

}

}

|

i ∈ L0
i ∈ L0.

Since elements X0 are accessed from the systematic nodes, the 0-th block column in each Ai
j corresponds to the accessed
information elements, and can be subtracted from the parities. They are marked with underlines, and thus we know the value
of:

Multiplying this row by γ = α/β, we get

|

[0 · · · p−i

0 · · · p−i

3 · · ·

· · · 0 · · · p−i

m · · ·

]C,

2 · · ·
Ai
2

{z

}

|

}

|

Ai
m

{z

}

17

Ai
3

{z

Ai
3

{z

A0
3

{z

[0 · · · γp−i

2 · · ·

0 · · · γp−i

3 · · ·

· · · 0 · · · γp−i

m · · ·

]C.

|

Ai
2

{z

|

A0
2

{z

}

|

}

|

}

}

|

|

Ai
m

{z

}

A0
m

{z

}

By adding back elements in X0 of the systematic nodes with appropriate coefﬁcients, we can rebuild the i-th row of A0, for
all 1 ≤ i ≤ r − 1:

[pi

2 · · · γp−i

2 · · ·

3 · · · γp−i
pi

3 · · ·

· · · pi

m · · · γp−i

m · · ·

]C,

where again the underlined elements marks the 0-th block column in each A0

j . The 0-th row in A0 is

[I · · ·

I · · ·

· · · I · · ·

]

|{z}A0

2

|{z}A0

3

|{z}A0

m

and can be rebuilt from elements X0 of the systematic nodes directly. Thus the erased node is rebuilt by accessing elements
X0 in every surviving node, which is a portion of 1/r of the elements.

It can be seen from the above proof that the rebuilding of any single erasure can be easily implemented. If a systematic
node is eared, we only need to solve at most two linear equations at a time, and the computation can be done in parallel. If
a parity is erased the rebuilding is even simpler: we only need to subtract information elements with appropriate coefﬁcients
from the parities. Besides, the rebuilding above is different from Theorem 1, where only one linear equation is solved at a
time.
Example 5 Considerthecodewith2or3paritiesinFigure 3.Whenthe0thparitynodeiserased,onecanaccesselements X0
fromeverysurvivingnode,andthereforetheunderlinedtermsintheparitiesareknown.Hencethesumoftheshadedtermsare
knownfromtheaccessedparityelements.Addingtheshadedtermsandtheunderlinedtermsin A0,wecanrebuildparity0.

For the example of Figure 4, when the systematic node C2 is erased, one can access elements Y2 = {v : v · e2 = 0} =
{0, 1, 4, 5} fromallthesurvivingnodes.Whentheparitynode P0 iserased,onecanaccesselements X0 = {0, 1, 2, 3} fromall
theremainingnodes.Thenitiseasytocheckthatinbothcasesitissufﬁcienttorebuildtheerasedcolumn.

C. MDS Property

Next we show the construction is indeed an MDS code. Recall that we assigned the coefﬁcients in the matrix pj as in
(18). And for r = 2, 3 parities, the assignment is as in (19). We will prove that if the coefﬁcient assignment for the code in
Theorem 1 is MDS, then the code in Construction 2 is also MDS. As a result, we do not need to design new coefﬁcients for
the construction, but simply reuse the encoding matrices (generalized permutation matrices) for the code in Theorem 1. First
we make an observation on the small blocks.
Lemma 16 Thereexistcoefﬁcientsλj asin (18), j ∈ [2, m],suchthatany t × t sub-blockmatrixof

isinvertible,forall t ∈ [1, r].Whenr = 2, 3,theassignmentin (19) satisﬁestheabovecondition.

H′ =


p0
2
...
pr−1
2

· · ·

· · ·

p0
m
...
pr−1
m


k×k

(21)

Proof: Notice that {pi

j}, j ∈ [2, m], i ∈ [0, r − 2], are the encoding matrices of Construction 1 of information array size
rm−1 × m, shortened by deleting columns 0 and 1. Moreover all t × t sub-matrix of (21) being invertible, 1 ≤ t ≤ r is
equivalent to Construction 1 being MDS. Thus by Theorem 2 the lemma holds.

Next we show that Construction 2 is MDS by computing the determinant of the matrices corresponding to different erasure

patterns. Combining the result for the sub-block matrices in Lemma 16, the determinant can be shown to be non-zero.
Theorem 17 There exist coefﬁcients λj as in (18), j ∈ [2, m], such that Construction 2 is MDS. When r = 2, 3, ﬁnite ﬁelds
F3, F4,respectively,sufﬁceforittobeMDS.

18

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

*

Figure 5.
Illustration of the matrix A and its sub-matrices. The ﬁgure shows an example of A with r = 5, t = 3 and I = {0, 2, 3}. Every square represents a
small block matrix. The “*” marks non-zero sub-block matrices, and the other entries are all zero block matrices. The shaded sub-matrix is Ax where x = 1
is an index in ¯I. One can see that in column x of every big block, there is only one non-zero entry.

Proof: Construction 2 being MDS is equivalent to all of the following matrix being invertible:

where each big block Ai
j is of size rm × rm and t ∈ [1, r], I = {i1, . . . , it} ⊆ [0, r − 1], {j1, . . . , jt} ⊆ [2, m]. Let the
complement of I be I = [0, r − 1]\I. We proceed the proof in two steps. At the ﬁrst step, in each big block consider the
small block column x, for some x ∈ I. The only non-zero small blocks in these columns are in small block rows x. See for
example Figure 5. Thus by Laplace expansion det(A) = s det(Ax) det(A ¯x), where s = 1 or −1, Ax is the submatrix of A
with small block rows and columns x in each big block, and A ¯x is the submatrix of A corresponding to the remaining rows
and columns. Moreover,

A =


Ai1
j1
...
Ait
j1

· · · Ai1
jt
...
· · · Ait
jt

,


t×t

jt

...

,




Ax =


...

β1 pi1−x

j1

· · · β1 pi1−x

βt pit−x

j1

· · ·

βt pit−x

jt

where β1, . . . , βt are 1 or α. But by Lemma 16, the above matrix can be made invertible. So we only need to look at the
remaining submatrix A ¯x. Again, we can take out another small block column and row from an index in I from each big block,
and it is invertible by Lemma 16. Continue this process, we are left with only columns and rows of I in each big block.

At the second step, for all i, i′ ∈ I, i′ ∈ Li, consider row i′ in Ai and row i in Ai′. They are shown in (20). One can do a

sequence of elementary row operations and keep the invertibility of the matrix, and get

i′ in Ai
i in Ai′

 

· · ·

· · ·

i
0
pi′−i
j1

i′
· · · pi−i′
· · ·

i′

i
0 · · · pi−i′

· · · · · ·

j1
0 · · · · · · pi′−i

· · ·

jt

jt

· · ·

0 · · · !.

Proceed this for all i, i′ ∈ I, i′ ∈ Li, we are left with block diagonal matrix in each big block. Then similar to the ﬁrst step,
we are only need to consider sub-matrices like Ax, which are invertible by Lemma 16. Thus Construction 2 is MDS.

For example, one can easily check that the code in Figure 4 is able to recover the information from any two nodes. Therefore
it is an MDS code. Theorem 17 implies that once we have an MDS code in Theorem 1, we can use its coefﬁcients and design
a new code by Construction 2. And the new code is guaranteed to be an MDS code.

V. CORRECTING ERRORS

In this section we switch back to the original zigzag codes and consider the problem of correcting errors.
First, we consider the (k + 2, k) zigzag code. Since the code has minimum Hamming distance 3 by the MDS property, if
there is a node erasure and a node error, then one cannot expect to recover the information. However, we will see that zigzag
code can correct if certain subset of the node elements are erroneous. As a result, zigzag code has the capability to correct
element errors beyond the minimum Hamming distance. We will ﬁrst study the scenario where an entire node erasure and a
single element error happen at the same time, and remark on its generalization to correcting a subset of element errors.

Second, we consider the (k + r, k) zigzag code. Since the the minimum Hamming distance is r + 1, one can recover from
2 ⌋ ≥ 1 errors, for r ≥ 2. We will show a simpliﬁed error correcting algorithm for one node error, which is the most

⌊ r+1
common case for node errors.

A. Node Erasure and Element Error

Consider a (k + 2, k) general zigzag code generated by distinct binary vectors T = {v0, v1, . . . , vk−1}. We assume that the
erasure and the error are in different systematic columns, and there is at most a single element error in the systematic part of
the array. The code has two parities and p = 2m rows for some integer m, and the zigzag permutations are fj(x) = x + vj, x ∈
[0, 2m − 1], j ∈ [0, k − 1]. The original and the erroneous information array are denoted by (ai,j), ( ˆai,j), respectively. We use
ri, zi to denote the i-th element in the 0th parity and 1st parity, respectively. Let the coefﬁcients of the 0th parity be all ones,
and let the coefﬁcient of the 1st parity corresponding to ai,j be βi,j, which is non-zero. More speciﬁcally, by Construction 1,
for all i ∈ [0, 2m − 1],

19

ri =

zi =

k−1
∑
j=0

k−1
∑
j=0

ai,j,

β f −1

j

(i),ja f −1

j

(i),j.

We will use the following fact. By computing the determinant of every 2 × 2 sub-matrix of (4), one can show that the zigzag

code is MDS if and only if {betai,j} are non-zero, and

for all r′ = r + vi + vj (A detailed proof can also be found in [18]).

Notation: Let x0, x1, . . . , xp−1 ∈ F. Denote f (x0, x1, . . . , xp−1) = (x f (0), x f (1), . . . , x f (p−1)) for a permutation f on
[0, p − 1]. For two vectors B = (b0, . . . , bp−1), X = (x0, . . . , xp−1) ∈ Fp, denote by B ◦ X = (b0x0, . . . , bp−1xp−1) the
point-wise product.

βr,tβr′,t 6= βr,jβr′,j

(22)

Compute the syndromes S0 = (s0,0, s1,0, . . . , s2m−1,0) and S1 = (s0,1, s1,1, . . . , s2m−1,1):
si,0 ← ∑j6=t ˆai,j − ri,
si,1 ← ∑j6=t β f −1

Algorithm 2 Algorithm to recover from a column erasure and an element error in the (k + 2, k) general zigzag code.
Suppose systematic column t is erased, and there is at most one element error in the remaining systematic array. Denote by
B = (β0,t, β1,t, . . . , β p−1,t) the vector of zigzag coefﬁcients corresponding to column t.
1: for i ∈ [0, 2m − 1] do
2:
3:
4:
5: end for
6: X ← B ◦ S0.
7: Y ← ft(S1).
8: W ← X − Y. Denote W = (w0, . . . , wp−1).
9: if W = 0 then
10:
11: else
12:
13:

There is no element error. Assign column t as −S0.

(i),j − zi.

(i),j ˆa f −1

j

j

Find two rows r, r′ such that wr, wr′ are nonzero.
Find the unique j such that vj = r + r′ + vt. The error is in column j.
if wr
wr′
The error is at row r, and ar,j ← ˆar,j − wr
βr,t
Assign column t as −S0 for all elements except ar,t ← −sr,0 + wr
βr,t

= − βr,t
βr,j

then

.

else

βr′,j
βr′,t

= −

then

if wr
wr′
The error is at row r′, and ar′,j ← ˆar′,j − wr′
βr′,t
Assign column t as −S0 for all elements except ar′,t ← −sr′,0 + wr′
βr′,t

.

14:

15:

16:
17:
18:

19:

20:

end if

21:
22:
23: end if

end if

The procedure to recover 1 node erasure plus 1 element error is described in Algorithm 2. We next show that its correctness.

Theorem 18 Algorithm2 cancorrectanodeerasureandasystematicelementerrorfora (k + 2, k) MDSgeneralzigzagcode.
Proof: Suppose column t is erased and there is an error at column j and row r. Let ˆar,j = ar,j + e. Deﬁne r′ = r + vt + vj.
Suppose X = (x0, . . . , xp−1), Y = (y0, . . . , yp−1) are the vectors in Lines 6, 7, respectively. It is easy to see that xi = yi =

C0

C1

a0,1 + e

a1,1
a2,1
a3,1

C2
a0,2
a1,2
a2,2
a3,2

P0

P1

r0 = a0,0 + a0,1 + a0,2
r1 = a1,0 + a1,1 + a1,2
r2 = a2,0 + a2,1 + a2,2
r3 = a3,0 + a3,1 + a3,2

z0 = a0,0 + a2,1 + a1,2
z1 = a1,0 + a3,1 + 2a0,2
z2 = a2,0 + 2a0,1 + 2a3,2
z3 = a3,0 + 2a1,1 + a2,2

S0

−a0,1 + e

−a1,0
−a2,0
−a3,0

S1

−a0,0
−a1,0

W = S0 − S1

w0 = e
w1 = 0

−a2,0 + 2e w2 = −2e = e

−a3,0

w3 = 0

0
1
2
3

Figure 6. An erroneous array of the (5, 3) zigzag code. There is a node erasure in Column C0 and an element error in Column C1. S0, S1 are the syndromes.

−βi,tai,t except when i = r, r′. Thus the pair r, r′ found in Line 12 is unique. Since the set of binary vectors {v0, v1, . . . , vk−1}
are distinct, we can identify column j given t, r, r′ in Line 13. Moreover,we have

20

Therefore, the difference between X and Y is

xr = −βr,tar,t + βr,te,

yr = −βr,tar,t,

xr′ = −βr′,tar′,t,

yr′ = −βr′,tar′,t + βr,je.

wr = xr − yr = βr,te,

wr′ = xr′ − yr′ = −βr,je.

And we can see that no matter what e is, we always have

Similarly, if the error is at row r′ column j, we will get

wr
wr′

= −

βr,t
βr,j

.

wr
wr′

= −

βr′,j
βr′,t

.

Since the code is MDS, we know that (22) holds. Therefore, we can distinguish between the two cases of an error in row r
and in row r′.
Example 6 ConsiderthecodeinFigure1 generatedby T = {e0 = 0, e1, e2}.SupposeallofColumn C0 iserased.Andsuppose
there is an error in the 0-th element in Column 1. Namely, the erroneous symbol we read is ˆa0,1 = a0,1 + e for some error
e 6= 0 ∈ F3,seeFigure 6.We cansimplycomputethesyndrome,locatethiserror,andrecovertheoriginalarray.Inparticular,
since the erased column corresponds to the zero vector, and all the coefﬁcients in column 0 are ones, X = S0, Y = S1. For
i ∈ [0, 3],wecomputeW,andgetzerosinallplacesexceptrow0 and2,whichsatisfy0 + 2 = (0, 0) + (1, 0) = (1, 0) = e1 + e0.
Therefore,weknowthelocationoftheerrorisincolumn 1 androw 0 or 2.Butsince w0 = w2,weknowtheerrorisin ˆa0,1 (If
w0 = −w2,theerrorisin ˆa2,1).

We make a few remarks about properties and extensions of our algorithm.
• Consider the optimal zigzag code. In practice, when we are conﬁdent that there are no element errors besides the node
erasure, we can use the optimal rebuilding algorithm and access only half of the array to rebuild the failed node. However,
we can also try to rebuild this node by accessing the other half of the array. Thus we will have two recovered version
for the same node. If they are equal to each other, there are no element errors; otherwise, there are element errors. Thus,
we have the ﬂexibility of achieving optimal rebuilding ratio or correcting extra errors.

• When node t is erased and more than one element in column j 6= t and rows R ⊆ [0, q − 1] are erroneous, following the
same techniques as Algorithm 2, it is easy to see that the code is able to correct systematic errors if (i) R ∪ (R + vj) 6=
S ∪ (S + vi) for any set of rows S ⊆ [0, q − 1] and any column i /∈ {j, r}, and (ii) r′ 6= r + vj + vt for any r, r′ ∈ R.
For example, consider the optimal zigzag code in Theorem 1 with m = 3, k = 4, r = 2. If node t = 0 is erased, and
elements in column j = 1 and rows R = {0, 7} are erroneous, then our algorithm in Lines 12, 13 will identify that there
are errors in rows {0, 4, 3, 7}, and only ej = e1 satisﬁes S ∪ (S + vj) = {0, 4, 3, 7} for some S. Then using Lines 14 to
22 we can identify rows R as erroneous and correct them.

• When the code has more than two parities, the zigzag code can again correct element errors exceeding the minimum
Hamming distance. To detect errors, one can either compute the syndromes, or rebuild the erasures multiple times by
accessing different e/r parts of the array, where e is the number of node erasures.

• Finally, it should be noted that if the node erasure or the single error happen in a parity column, then we can not correct

them in the (k + 2, k) code.

21

B. Node Error

Next, we will discuss decoding algorithms of zigzag codes with r parities in case of a column error.
Let C be an (k + r, k) general zigzag code deﬁned by Construction 1. The code has information array size 2m × k. Let the
zigzag permutations be fj, j ∈ [0, k − 1], which are not necessarily distinct. Let the stored information be a0, a1, . . . , ak−1 and
parities be b0, b1, . . . , br−1, where each ai or bj corresponds to a node and is a column vector of length rm. Let the erroneous
nodes be ˆa0, . . . , ˆak−1, ˆb0, . . . , ˆbr−1. Let the encoding matrix corresponding to systematic node i and parity l be Pl
i .

The procedure to correct a column error is shown in Algorithm 3. We ﬁrst compute the syndromes (Line 2), then for a
systematic node error we locate the error position using only syndromes from parity 0 and 1 (Line 10), and at last correct the
error (Line 11).

Notice that the muliplication of the encoding matrix Pl

j in Line 2 is only a permutation and muliplying coefﬁcients. Moreover,
the permutations fi’s only change one bit of the row indeces, if we consider the optimal zigzag code in Theorem 1. Therefore
the algorithm can be easily implemented.

i=0 Pl

i ˆai

There is no error.

Algorithm 3 Decode a node error in the (k + r, k) general zigzag code.
1: for l ∈ [0, r − 1] do
Sl ← ˆbl − ∑k−1
2:
3: end for
4: if Sl = 0 for all l ∈ [0, r − 1] then
5:
6: else
7:
8:
9:
10:
11:
12:
13: end if

Find the unique j ∈ [0, k − 1] such that PjS0 = S1.
aj ← ˆaj + S0.

There is an error in parity l. bl ← ˆbl − Sl.

if Sl 6= 0, for one l then

else

end if

If there is only one error, the above algorithm is guaranteed to ﬁnd the error location and correct it, as the following theorem

states.
Theorem 19 Algorithm3 cancorrectonenodeerrorforanMDSgeneralzigzagcode.

Proof: Suppose there is error in the parity node l, then clearly line 8 recovers it. Suppose there is error in the systematic

column j, and ˆaj = aj + E, for error vector E. Thus the ﬁrst two syndromes are

S0 = −E,

S1 = −PjE = PjS0.

Thus column j will be found in Line 10. Next we show that any other column will not be found in Line 10. Namely, for any
t 6= j, PtS0 6= S1. Since the zigzag code is MDS, it can correct two erasures in nodes j, t. Therefore, the following matrix
should be invertible:

I

(cid:18) I
Pj Pt(cid:19) .

Hence Pj − Pt is invertible. Therefore, −(Pj − Pt)E 6= 0 since E 6= 0, namely, S1 6= PtS0.

VI. SUMMARY

In this paper, we proved a tight information-theoretic lower bound on the rebuilding ratio e/r for e node failures and r
parities, and gave explicit rebuilding algorithms of optimal zigzag codes achieving this bound. We also presented constructions
of MDS array codes that achieve the optimal rebuilding ratio 1/r for an arbitrary node failure. The new codes are constructed
using permutation matrices and improve the efﬁciency of the rebuilding access. Moreover, we considered the correction of
errors, both for an element and for a node, which was not very well studied in erasure coding for distributed storage.

Now we mention a couple of open problems. First, if there are k = m − 1 systematic nodes and r parity nodes, then our
code in Section IV has p = rm rows. Thus, the code dimension k is quite small compared to the number of rows p, which
limits the total number of nodes in the distributed storage network for a given storage size of every node. Given the number

of rows p = 2m, it is theoretically interesting and practically important to study whether it is possible to ﬁnd codes with a
larger k. For example, when r = 2, we know a construction with rm rows and k = m systematic nodes:

22

A0

j =(cid:18) I

pj

0

I(cid:19) , A1

j =(cid:18)I

0

pj

I(cid:19) .

j , A1

Here A0
j are the encoding matrices for systematic node j and parities 0, 1 respectively, and we can take all j ∈ [1, m].
This code has one more information column than Construction 2, and one can show that it achieves optimal rebuilding ratio
as well.

Besides, the zigzag code and the code in Section IV only speciﬁes the ﬁnite ﬁeld sizes when the number of parities is small,
i.e., r = 2, 3. Hence it is useful to study the minimum required ﬁeld sizes of these constructions, and to construct explicit
codes using small ﬁnite ﬁeld sizes.

Finally, the problem of correcting node erasures together with element errors in multiple nodes for codes with r > 2 is

important especially for applications in SSD-based storage systems.

REFERENCES

[1] G. K. Agarwal, B. Sasidharan, and P. Vijay Kumar, “An alternate construction of an access-optimal regenerating code with optimal sub-packetization

level,” in Communications (NCC), 2015 Twenty First National Conference on.

IEEE, 2015, pp. 1–6.

[2] N. Alon, “Combinatorial Nullstellensatz,” Combinatorics Probability and Computing, vol. 8, no. 1–2, pp. 7–29, 1999.
[3] M. Blaum, J. Brady, J. Bruck, and J. Menon, “An efﬁcient scheme for tolerating double disk failures in RAID architectures,” Computers, IEEE Transactions

on, vol. 44, no. 2, pp. 192–202, 1995.

[4] M. Blaum, J. L. Hafner, and S. Hetzler, “Partial-MDS codes and their application to raid type of architectures,” Information Theory, IEEE Transactions

on, vol. 59, no. 7, pp. 4510–4519, 2013.

[5] V. R. Cadambe, C. Huang, and J. Li, “Permutation code: optimal exact-repair of a single failed node in MDS code based distributed storage systems,”

in Information Theory Proceedings (ISIT), 2011 IEEE International Symposium on, 2011.

[6] V. R. Cadambe, C. Huang, J. Li, and S. Mehrotra, “Polynomial length MDS codes with optimal repair in distributed storage systems,” in Proceedings

of 45th Asilomar Conference on Signals Systems and Computing, 2011.

[7] V. R. Cadambe, S. A. Jafar, H. Maleki, K. Ramchandran, and C. Suh, “Asymptotic interference alignment for optimal repair of MDS codes in distributed

storage,” Information Theory, IEEE Transactions on, vol. 59, no. 5, pp. 2974–2987, 2013.

[8] P. Corbett, B. English, A. Goel, T. Grcanac, S. Kleiman, J. Leong, and S. Sankar, “Row-diagonal parity for double disk failure correction,” Proc. of the

3rd USENIX Symposium on File and Storage Technologies (FAST ’04), pp. 1–14, 2004.

[9] A. Dimakis, P. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran, “Network coding for distributed storage systems,” Information Theory, IEEE

Transactions on, vol. 56, no. 9, pp. 4539–4551, 2010.

[10] P. Hall, “On representatives of subsets,” Journal of the London Mathematical Society, vol. 10, no. 1, pp. 26–30, 1935.
[11] Y. Hu, Y. Xu, X. Wang, C. Zhan, and P. Li, “Cooperative recovery of distributed storage systems from multiple losses with network coding,” Selected

Areas in Communications, IEEE Journal on, vol. 28, no. 2, pp. 268–276, 2010.

[12] D. S. Papailiopoulos, A. G. Dimakis, and V. R. Cadambe, “Repair optimal erasure codes through hadamard designs,” Information Theory, IEEE

Transactions on, vol. 59, no. 5, pp. 3021–3037, 2013.

[13] J. S. Plank and M. Blaum, “Sector-disk (sd) erasure codes for mixed failure modes in raid systems,” ACM Transactions on Storage (TOS), vol. 10, no. 1,

p. 4, 2014.

[14] B. Sasidharan, G. K. Agarwal, and P. V. Kumar, “A high-rate MSR code with polynomial sub-packetization level,” in Information Theory (ISIT), 2015

IEEE International Symposium on.

IEEE, 2015, pp. 2051–2055.

[15] N. Shah, K. Rashmi, P. Vijay Kumar, and K. Ramchandran, “Distributed storage codes with repair-by-transfer and nonachievability of interior points on

the storage-bandwidth tradeoff,” Information Theory, IEEE Transactions on, vol. 58, no. 3, pp. 1837–1852, 2012.

[16] N. B. Shah, K. Rashmi, P. V. Kumar, and K. Ramchandran, “Interference alignment in regenerating codes for distributed storage: Necessity and code

constructions,” Information Theory, IEEE Transactions on, vol. 58, no. 4, pp. 2134–2158, 2012.

[17] C. Suh and K. Ramchandran, “Exact-repair MDS code construction using interference alignment,” Information Theory, IEEE Transactions on, vol. 57,

no. 3, pp. 1425–1442, 2011.

[18] I. Tamo, Z. Wang, and J. Bruck, “Zigzag codes: MDS array codes with optimal rebuilding,” Information Theory, IEEE Transactions on, vol. 59, no. 3,

pp. 1597–1616, 2013.

[19] Z. Wang, I. Tamo, and J. Bruck, “On codes for optimal rebuilding access,” in Allerton Conference on Control, Computing, and Communication, 2011.
[20] ——, “Long MDS codes for optimal repair bandwidth,” in Information Theory Proceedings (ISIT), 2012 IEEE International Symposium on, 2012.

