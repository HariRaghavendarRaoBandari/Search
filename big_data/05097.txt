6
1
0
2

 
r
a

 

M
6
1

 
 
]

Y
S
.
s
c
[
 
 

1
v
7
9
0
5
0

.

3
0
6
1
:
v
i
X
r
a

Cooperative Planning for Coupled Multi-Agent Systems under Timed

Temporal Speciﬁcations

Alexandros Nikou, Dimitris Boskos, Jana Tumova and Dimos V. Dimarogonas

Abstract— This paper presents a fully automated procedure
for controller synthesis for multi-agent systems under coupled
constraints. Each agent has dynamics consisting of two terms:
the ﬁrst one models the coupled constraints and the other one
is an additional control input. We aim to design the inputs
so that each agent meets a high-level task speciﬁcation given
in Metric Interval Temporal Logic (MITL). First, we design
a decentralized abstraction that provides a time and space
discretization of the multi-agent system. Second, by utilizing
this abstraction and techniques from formal veriﬁcation, we
provide an algorithm that computes the individual runs prov-
ably satisfying the high-level tasks. The overall approach is
demonstrated in a simulation example.

I. INTRODUCTION

Cooperative control of multi-agent systems has tradition-
ally focused on designing local control laws in order to
achieve tasks such as consensus and formation convergence
([1]–[6]). Over the last few years, the ﬁeld of control of
multi-agent systems with behavior under complex high-
level task speciﬁcations has been gaining signiﬁcant research
attention. In this work, we aim to introduce speciﬁc time
bounds into the tasks, such as “Visit region A within 5 time
units” or “Periodically survey regions A1, A2, A3, avoid
region X and always keep the longest time between two
consecutive visits to A1 below 20 time units”.

The speciﬁcation language that has extensively been used
to express the complex tasks is the Linear Temporal Logic
(LTL) (see, e.g., [7], [8]). LTL has proven a valuable
tool for controller synthesis, because it provides a compact
mathematical formalism for specifying desired behaviors
of a system. There is a rich body of literature containing
algorithms for veriﬁcation and synthesis under temporal logic
speciﬁcations ([9], [10]). A common approach in multi-agent
planning under LTL speciﬁcations is the consideration of a
centralized, global task speciﬁcation for the team of agents
which is then decomposed into local tasks to be accom-
plished by the individual agents (see [11]–[14]). A three-
step hierarchical procedure including abstractions, formal
veriﬁcation and controller synthesis in order to address such
a problem is described in [15], [16].

Time constraints in the system modeling have been in-
cluded e.g., in [17], where a method for automated optimal
planning for a group of agents satisfying a common high-
level mission speciﬁcation was proposed. The mission was

The authors are with the ACCESS Linnaeus Center, School of Electrical
Engineering, KTH Royal Institute of Technology, SE-100 44, Stockholm,
Sweden and with the KTH Centre for Autonomous Systems. Email:
{anikou, boskos, tumova, dimos}@kth.se. This work
was supported by the H2020 ERC Starting Grant BUCOPHSYS,
the
Swedish Research Council (VR) and the Knut och Alice Wallenberg
Foundation.

given in LTL and the goal was to minimize a cost function
that captures the maximum time between successive satis-
faction of a part of the formula. Authors in [18], [19] used a
different approach, representing the motion of each agent in
the environment with a timed automaton. The automata were
composed into a single team automaton and the UPPAAL
veriﬁcation tool ([20]) was utilized for speciﬁcations given
in Computational Tree Logic (CTL). In the same direction,
authors in [21] modeled a multi-robot system with timed au-
tomata and Weighted Transition Systems (WTS) considering
LTL speciﬁcations.

Most of the previous works on multi-agent planning con-
sider temporal properties which treat time in a qualitative
manner. For real applications, a multi-agent team might be
required to perform a speciﬁc task within a certain time
bound, rather than at some arbitrary time in the future, i.e.
in a quantitative manner. Timed speciﬁcations have been
considered in [22]–[26]. However, these works are restricted
to single agent planning and are not extendable to multi-
agent systems in a straightforward way. In [27], the vehicle
routing problem was considered under Metric Temporal
Logic (MTL) speciﬁcations. The approach does not rely
on automata-based approach to veriﬁcation, as it constructs
a set of linear inequalities from MTL speciﬁcation and
consequently solve an Mixed-Integer Linear Programming
(MILP) problem. In our previous work [28] Metric Interval
Temporal Logic (MITL) formulas were introduced in order
to synthesize controllers such that every agent fulﬁlls an
individual speciﬁcation and the team of agents fulﬁll a global
speciﬁcation.

In [28], the abstraction of the dynamics was assumed
to be given and an assumption for upper bounds of the
time that one agent needs to ﬁnish one transition from one
region to another was stated. Furthermore, potential coupled
constraints between the agents were not taken into consid-
eration. In this work, we aim to address the aforementioned
issues. The dynamics of each agent consists of two parts: the
ﬁrst part is a consensus protocol representing the coupling
between the agent and its neighbors, and the second one
is an additional control input which will be exploited for
high-level planning. Hereafter, we call it a free input. A
decentralized abstraction procedure is provided, which leads
to an individual Transition System (TS) for each agent and
provides the connection with the high-level planning. This
abstraction allows us to assign precise time durations to
transitions.

The literature on abstractions of dynamical systems is rich
([29]–[43]). Multi-agent abstractions have been addressed in
[44]–[48]. Motivated by [48], we start from the dynamics

of each agent and we construct a WTS for each agent in an
decentralized manner. We assign to each agent one individual
task given in MITL and we aim to design the free inputs so
that each agent performs the desired task. To the best of the
authors’ knowledge this is the ﬁrst time that a full framework
for multi-agent systems consisting of both constructing an
abstraction and high-level timed temporal logic planning is
considered.

The remainder of the paper is structured as follows. In
Sec. II a description of the necessary mathematical tools, the
notations and the deﬁnitions are given. Sec. III provides the
dynamics of the system and the formal problem statement.
Sec. IV discusses the technical details of the solution. Sec. V
is devoted to a simulation example. Finally, the conclusions
and the future work directions are discussed in Sec. VI.

II. NOTATION AND PRELIMINARIES

A. Notation

We denote by R, Q+, N the set of real, nonnegative
rational and natural numbers including 0, respectively. Let
us also deﬁne T∞ = T ∪ {∞} for a set T ⊆ R. Given a set
S, we denote by |S| its cardinality and by 2S the set of all
its subsets. For a subset S of Rn, we denote by cl(S), int(S)
and ∂S = cl(S)\int(S) its closure, interior and boundary,
respectively. We use the notation kxk for the Euclidean norm
of a vector x ∈ Rn and kAk = max{kAxk : kxk = 1} for
the induced norm of a matrix A ∈ Rm×n. Given a matrix A
we deﬁne by λmax(A) the maximum eigenvalue.

B. Multi-Agent Systems

i , . . . , xn

2 .

Given a vector xi = (x1

Consider a set of agents I = {1, 2, . . . , N} operating
in Rn. The topology of the multi-agent system can be
modeled as a static undirected graph G = (I,E), where
I = {1, . . . , N} is the set of nodes (agents) and E ⊆
{{i, j} : i, j ∈ I, i 6= j} is the set of edges (denoting
a communication capability between the respective agents).
For each agent, the neighbor’s set N (i) is deﬁned as N (i) =
{j1, . . . , jNi} = {j ∈ I : {i, j} ∈ E} where Ni = |N (i)|.
i ) ∈ Rn, the component
operator c(xi, ℓ) = xℓ
i ∈ R, ℓ = 1, . . . , n gives the projection
of xi onto its ℓ-th component (see [49]). Similarly, for the
stack vector x = (x1, . . . , xN ) ∈ RN n the component
operator is deﬁned as c(x, ℓ) = (c(x1, ℓ), . . . , c(xN , ℓ)) ∈
RN , ℓ = 1, . . . , n. By using the component operator, the
norm of a vector x ∈ RN n can be computed as kxk =
(cid:8)Pn
ℓ=1 kc(x, ℓ)k2(cid:9) 1
The Laplacian matrix L(G) ∈ RN×N of a network of
agents is deﬁned as L(G) = D(G)D(G)τ where D(G) is
the N × |E| incidence matrix. The graph Laplacian L(G)
is positive semideﬁnite and symmetric. If we consider an
ordering 0 = λ1(G) ≤ λ2(G) ≤ . . . ≤ λN (G) = λmax(G) of
the eigenvalues of L(G) then we have that λ2(G) > 0 iff G
is connected (see, e.g.,[49]).
We denote by ∆x ∈ R|E|n the stack column vector of the
vectors xi − xj ,{i, j} ∈ E with the edges ordered as in the
case of the incidence matrix. Thus, D(G)τ x = ∆x.

C. Temporal Logics and Automata

An inﬁnite sequence of elements of the set Σ is called
a inﬁnite word over this set and it is denoted by σ =
σ(0)σ(1) . . . The i-th element of a sequence is denoted by
σ(i).
Deﬁnition 1. ([50]) A time sequence τ = τ (0)τ (1)··· is a
inﬁnite sequence of time values τ (j) ∈ T = Q+, satisfying
the following constraints:

• Monotonicity: τ (j) < τ (j + 1) for all j ≥ 0.
• Progress: For every t ∈ T, ∃ j ≥ 1, such that τ (j) > t.
An atomic proposition p is a statement over the problem
variables and parameters that is either True (⊤) or False (⊥)
at a given time instance.

Deﬁnition 2. ([50]) Let AP be a ﬁnite set of atomic proposi-
tions. A timed word w over the set AP is an inﬁnite sequence
w = (w(0), τ (0))(w(1), τ (1))··· where w(0)w(1) . . . is an
inﬁnite word over the set 2AP and τ (0)τ (1) . . . is a time
sequence with τ (j) ∈ T, j ≥ 0.
Deﬁnition 3. A Weighted Transition System (WTS) is a tuple
(S, S0, Act,−→, d, AP, L) where S is a ﬁnite set of states;
S0 ⊆ S is a set of initial states; Act is a set of actions;
−→⊆ S × Act × S is a transition relation; d :−→→ T is
a map that assigns a positive weight to each transition; AP
is a ﬁnite set of atomic propositions; and L : S → 2AP is
a labeling function. For simplicity, the notation s α−→ s′ is
used to denote the fact that (s, α, s′) ∈−→ for s, s′ ∈ S and
α ∈ Act. For every s ∈ S and α ∈ Act we use the notation
Post(s, α) = {s′ ∈ S : (s, α, s′) ∈−→}.
Deﬁnition 4. A timed run of a WTS is an inﬁnite sequence
rt = (r(0), τ (0))(r(1), τ (1)) . . ., such that r(0) ∈ S0, and
for all j ≥ 1, it holds that r(j) ∈ S and (r(j), α(j), r(j +
1)) ∈−→ for a sequence of actions α(1)α(2) . . . with α(j) ∈
Act,∀ j ≥ 1. The time stamps τ (j), j ≥ 0 are inductively
deﬁned as

1) τ (0) = 0.
2) τ (j + 1) = τ (j) + d(r(j), r(j + 1)), ∀ j ≥ 1.

Every timed run rt generates a timed word w(rt) =
(L(r(0)), τ (0)) (L(r(1)), τ (1)) . . . over the set 2AP where
w(j) = L(r(j)), ∀ j ≥ 0 is the subset of atomic propositions
that are true at state r(j) at time τ (j).

D. Metric Interval Temporal Logic and Timed Automata

The syntax of Metric Interval Temporal Logic (MITL) over
a set of atomic propositions AP is deﬁned by the grammar
ϕ := p | ¬ϕ | ϕ1 ∧ ϕ2 |(cid:13)I ϕ | ♦I ϕ | (cid:3)I ϕ | ϕ1 UI ϕ2 (1)
where p ∈ AP, and (cid:13), ♦, (cid:3) and U is the next, fu-
ture, always and until temporal operator, respectively. I ⊆
T is a non-empty time interval in one of the following
forms: [i1, i2], [i1, i2), (i1, i2], (i1, i2), [i1,∞], (i1,∞) where
i1, i2 ∈ T with i1 < i2. MITL can be interpreted either in
continuous or point-wise semantics. We utilize the latter one
and interpret MITL formulas over timed runs such as the
ones produced by a WTS (Def. 4).

a

rt

5.

run

([51],

[52]) Given

=
of a WTS and an MITL
i ≥ 0 (read rt

Deﬁnition
(r(0), τ (0))(r(1), τ (1)) . . .
formula ϕ, we deﬁne (rt, i) |= ϕ, for
satisﬁes ϕ at position i) as follows
(rt, i) |= p ⇔ p ∈ L(r(i))
(rt, i) |= ¬ϕ ⇔ (rt, i) 6|= ϕ
(rt, i) |= ϕ1 ∧ ϕ2 ⇔ (rt, i) |= ϕ1 and (rt, i) |= ϕ2
(rt, i) |= (cid:13)I ϕ ⇔ (rt, i + 1) |= ϕ and τ (i + 1) − τ (i) ∈ I
(rt, i) |= ♦I ϕ ⇔ ∃j, i ≤ j, s.t. (rt, j) |= ϕ, τ (j) − τ (i) ∈ I
(rt, i) |= (cid:3)I ϕ ⇔ ∀j, i ≤ j, τ (j) − τ (i) ∈ I ⇒ (rt, j) |= ϕ
(rt, i) |= ϕ1 UI ϕ2 ⇔ ∃j, i ≤ j, s.t. (rt, j) |= ϕ2,

τ (j) − τ (i) ∈ I and (rt, k) |= ϕ1 for every i ≤ k < j.
Timed B¨uchi Automata (TBA) were introduced in [50] and
in this work, we also partially adopt the notation from [53],
[54]. Let C = {c1, . . . , c|C|} be a ﬁnite set of clocks. The
set of clock constraints Φ(X) is deﬁned by the grammar

φ := ⊤ | ¬φ | φ1 ∧ φ2 | c ⊲⊳ ψ

(2)

where c ∈ C is a clock, ψ ∈ T is a clock constant and
⊲⊳ ∈ {<, >,≥,≤, =}. A clock valuation is a function ν :
C → T that assigns a real value to each clock. A clock ci
has valuation νi for i ∈ {1, . . . ,|C|}, and ν = (ν1, . . . , ν|C|).
We denote by ν |= φ the fact that the valuation ν satisﬁes
the clock constraint φ.

a

is

TBA

6. A

tuple A

Deﬁnition
=
(S, Sinit, C, Inv, E, F, AP,L) where S is a ﬁnite set
of locations; Sinit ⊆ S is the set of initial locations; X is
a ﬁnite set of clocks; Inv : S → Φ(X) is the invariant;
E ⊆ S × Φ(X)× 2X × S gives the set of transitions; F ⊆ S
is a set of accepting locations; AP is a ﬁnite set of atomic
propositions; and L : S → 2AP labels every state with a
subset of atomic propositions.

e−→ (s′, ν′) iff ν |= γ, ν′

A state of A is a pair (s, ν) where s ∈ S and ν satisﬁes
the invariant Inv(s), i.e., ν |= Inv(s). The initial state of
A is (s(0), (0, . . . , 0)), where s(0) ∈ S0. Given two states
(s, ν) and (s′, ν′) and an edge e = (s, γ, R, s′), there exists
a discrete transition (s, ν)
|=
Inv(s′), and R is the reset set, i.e., ν′i = 0 for ci ∈ R and
ν′i = νi for xi /∈ R. Given a δ ∈ T, there exists a time
δ−→ (s′, ν′) iff s = s′, ν′ = ν + δ and ν′ |=
transition (s, ν)
δ−→ e−→ (s′, ν′) if there exists s′′, ν′′
Inv(s). We write (s, ν)
e−→ (s′, ν′).
δ−→ (s′′, ν′′) and (s′′, ν′′)
such that (s, ν)
An inﬁnite run of A starting at state (s(0), ν) is an inﬁnite
δ0−→
sequence of time and discrete transitions (s(0), ν(0))
δ1−→ (s(1)′, ν(1)′) . . ., where
(s(0)′, ν(0)′)
(s(0), ν(0)) is an initial state. This run produces the timed
word w = (L(s(0)), τ (0))(L(s(1)), τ (1)) . . . with τ (0) = 0
and τ (i+1) = τ (i)+δi, ∀ i ≥ 1. The run is called accepting
if s(i) ∈ F for inﬁnitely many times. A timed word is
accepted if there exists an accepting run that produces it.
Any MITL formula ϕ over AP can be algorithmically
translated to a TBA with the alphabet 2AP, such that the

e0−→ (s(1), ν(1))

language of timed words that satisfy ϕ is the language of
timed words produced by the TBA ([55]–[57]).

Example 1. An example of a TBA that accepts all the timed
words that satisfy the formula ϕ = ♦[c1,c2]{green} with
L(s0) = L(s2) = ∅,L(s1) = {green} is depicted in Fig.
1. This formula will be used as reference for the following
examples and simulations.

c ≤ c2

c < c1 ∨ c > c2

c := 0

c ≥ c1 ∧ c ≤ c2

c := 0

c > c2, c := 0

s0

s2

⊤, c := 0

s1

{blue}

⊤, c := 0

Fig. 1: The TBA that accepts the runs that satisfy formula ϕ =
♦[c1 ,c2]{green}

III. PROBLEM FORMULATION

A. System Model
We focus on multi-agent systems with single integrator
dynamics

˙xi = ui, xi ∈ Rn, i ∈ I.

(3)

In particular, we consider that the multi-agent system is
coupled. The decentralized control law consists of two parts;
the ﬁrst part is a consensus protocol representing the coupling
between the agent and its neighbors, and the second one is
an additional control input which will be exploited for high-
level planning and is called free input. Namely,

ui = − Xj∈N (i)

(xi − xj) + vi = fi(xi, xj) + vi ∀ i ∈ I (4)

) ∈ RNin and vi ∈ Rn, i ∈ I are
where xj = (xj1 , . . . , xjNi
the free input terms for each agent. In this work, we assume
that the free inputs are bounded from a term vmax. Namely,
kvi(t)k ≤ vmax, ∀ i ∈ I, t ≥ 0.
is c( ˙x, ℓ) =
−L(G) c(x, ℓ) + c(v, ℓ), ℓ ∈ {1, . . . , n} where x, v ∈ RN n,
obtained by invoking the deﬁnition of the component oper-
ator from Sec. II-B.

An alternative form of

(3) and (4)

B. Speciﬁcation

Loosely speaking, our goal is to control the multi-agent
system subject to (3) and (4) so that each agent’s behavior
obeys a given speciﬁcation. In particular, each agent’s states
are required to belong to a desired subset of Rn within
desired time limits. Formally, for an agent i ∈ I, Rn is a
workspace. Properties of interest are captured through a ﬁnite
set of atomic propositions AP i, i ∈ I, with AP i∩ AP j = ∅,
for all i, j ∈ I, i 6= j. Each state xi ∈ Rn is assigned
the subset of properties Li(xi) ⊆ AP i that hold in there
through the labeling function Li. Let L(xi) =Sj∈I
Lj(xi).
We assume that the equivalence ≡i, such that xi ≡i x′i iff

i

ℓ

}ℓ∈IAP

L(xi) = L(x′i), induces a partition S AP i = {S AP
on
the workspace Rn. Note that for each agent j ∈ I it holds
that S AP j = S AP i and thus, we simplify the notation and
we use S AP = {Sℓ}ℓ∈IAP to denote any agent’s partition.
Deﬁnition 7. Suppose that xi is a trajectory of agent i. A
timed run associated with xi is a ﬁnite or inﬁnite sequence
xi = (r(0), τ (0))(r(1), τ (1))(r(2), τ (2)) . . ., satisfying for
rt
all j ≥ 0 the property that Li(xi(t)) = r(j), for all t ∈
[τ (j), τ (j + 1)), and r(j) 6= r(j + 1).

xi |= ϕi.

Given a MITL formula ϕi over the set of atomic proposi-
tion AP i, we ﬁnally deﬁne the notion of the agent’s behavior
meeting the speciﬁcation ϕi as xi |= ϕi ⇔ rt
C. Problem Statement
Problem 1. Given N agents that are governed by dynamics
as in (3), (4) and N task speciﬁcation formulas ϕ1, . . . , ϕN
expressed in MITL over the respective sets of atomic propo-
sitions AP1, . . . , APN with APi ∩ APj = ∅, ∀i, j ∈ I, the
partition S AP and the labeling functions L1, . . . , LN , assign
control laws to the free inputs v1, . . . , vN such that each
agent fulﬁlls its speciﬁcation, given the bound vmax.

IV. PROPOSED SOLUTION

In this section, we introduce a systematic solution to
Problem 1. Our overall approach builds on abstracting the
system in (3), (4) into a WTS and further the fact that the
timed runs in the i-th WTS project onto the trajectories of
agent i while preserving the satisfaction of the MITL formula
ϕi. We take the following steps:

1) Initially, we prove the boundedness of the relative
position of the agents that in turns guarantees ﬁniteness
of the individual WTSs (Sec. IV-A).

2) We utilize decentralized abstraction techniques for
the multi-agent system, i.e., discretization of both the
workspace and the time such that the motion of each
agent is modeled by a WTS Ti, i ∈ I (Sec. IV-B).
3) In view of the deﬁnition of WTS we deﬁne the
run of each agent such as to be consistent in view
of the coupling constraints with the neighbors. The
computation of the product of each individual WTS
is also required (Sec. IV-C).

4) A ﬁve-step automated procedure for controller synthe-
sis which serves as a solution to Problem 1 is provided
in Sec. IV-D.

The next sections provide the proposed solution in details.

A. Boundedness Analysis
Theorem 1. Consider the multi-agent system (3), (4). As-
sume that the network graph is connected (i.e. λ(G > 0))
and let vi, i ∈ I satisfy kvi(t)k ≤ vmax, ∀ i ∈ I, t ≥ 0.
Furthermore, let a positive constant ¯R > K2vmax where
where K2 = 2√N (N−1)kD(G)τk
> 0 and D(G) is the
network adjacency matrix. Then, for each initial condition
xi(0) ∈ Rn, there exists a time T > 0 such that ∆x ∈
X , ∀t ≥ T , where X = {x ∈ RN n : k∆xk ≤ ¯R}.

λ2
2(G)

Proof. Consider the following candidate Lyapunov function
V : RN n → R
V (x) =

kxi − xjk2 = k∆xk2 > 0.

(5)

1
2

NXi=1 Xj∈N (i)

The time derivative of V along the trajectories of (3), can
be computed as

˙x

∂x

(6)

[−L(G) c(x, k) + c(v, k)](cid:27)

˙V (x) = [∇V (x)]τ
nXk=1(cid:26)c(cid:18) ∂V
, k(cid:19)τ
=
∂x , k) = h ∂V
. By computing the
where c( ∂V
partial derivative of the Lyapunov function with respect to
=Pj∈N (i)(xi − xj), i ∈ I.
vector xi, i ∈ I we get ∂V
By substituting c(cid:0) ∂V
∂x , k(cid:1)τ
= c(x, k)τ L(G), k = 1, ..., n in
(6) we get
{c(x, k)τ L(G) [−L(G) c(x, k) + c(v, k)]}

Niτ

˙V (x) =

∂V
∂xk

. . .

∂xk

∂xi

1

≤ −

nXk=1
nXk=1nc(x, k)τ [L(G)]2 c(x, k))o +
{c(x, k)τ L(G) c(v, k)}(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
nXk=1

For the ﬁrst term of (7) we have that

kL(G) c(x, k)k2 .

For the second term of (7) we have that

nXk=1
nXk=1(cid:8)c(x, k)τ L(G)2 c(x, k))(cid:9) =
(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
{c(x, k)τ L(G) c(ν, k)}(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
nXk=1
{c(x, k)τ D(G) D(G)τ c(ν, k)}(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
=(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
nXk=1
nXk=1
nXk=1

{kc(∆x, k)k kc(ν, k)k} .

= kD(G)τk

≤

{kD(G)τ c(x, k)k kD(G)τk kc(ν, k)k}

By using the Cauchy-Schwarz inequality in (8) we get

(8)

.

(7)

{c(x, k)τ L(G) c(v, k)}(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
nXk=1
≤ kD(G)τk   nXk=1
kc(∆x, k)k2! 1

2   nXk=1

2

kc(v, k)k2! 1
√Nkvk∞

= kD(G)τk k∆xkkvk ≤ kD(G)τk k∆xk

(9)
where kvk∞ = max{kvik : i = 1, . . . , N} = vmax. Thus, by
combining the previous inequalities, (7) is written
kL(G)c(x, k)k2 + √N kD(G)τkk∆xkvmax.

˙V (x) ≤ −

nXk=1

(10)

In order to proceed we need the following Lemma.

Lemma 1. Let x⊥ be the orthogonal complement of a vector
x ∈ RN n in the subspace H = {x ∈ RN n : x1 = . . . =
xN}. Then, the following hold:

kL(G) c(x, k)k ≥ λ2(G) kc(x⊥, k)k, ∀ k ∈ I

kx⊥k ≥

Proof. See [58].

1

p2(N − 1)k∆xk.

(11)

(12)

By exploiting Lemma 1, (10) is written

nXk=1(cid:13)(cid:13)c(x⊥, k)(cid:13)(cid:13)2

+ √N kD(G)τkk∆xkvmax.

˙V ≤ −λ2
2(G)
2(G) kx⊥k2 + √N kD(G)τk k∆xkvmax
= −λ2
2(N − 1)k∆xk2 + √N kD(G)τkk∆xkvmax
λ2
2(G)
≤ −
≤ −K1k∆xk (k∆xk − K2vmax) .
where K1 = λ2
2(G)
2(N−1) > 0. Apparently, we have that V (x) =
k∆xk2 > 0 and ˙V < 0, when k∆xk ≥ ¯R > K2vmax. Thus,
it can be shown that there exists a ﬁnite time T > 0 such
that the trajectories ∆x will enter the compact set X = {x ∈
RN n : k∆xk ≤ ¯R} and remain there for every t ≥ T with
¯R > K2vmax.

(13)

It should be noticed that the relative boundedness of the
agents’ positions guarantees a global bound on the coupling
terms fi(xi, xj), as deﬁned in (4). We will exploit this bound
in order to capture the behavior of the system in X , by a
discrete state WTS, where X is speciﬁed by the bound ¯R in
Theorem 1.

B. Abstraction

We consider now a cell decomposition S = {Sl}l∈I of Rn

according to the following deﬁnition:
Deﬁnition 8. A cell decomposition S = {Sl}l∈I of a set
D ⊆ Rn, where I ⊆ N is a ﬁnite or countable index set, is
a family of uniformly bounded convex and connected sets
Sl, l ∈ I such that int(Sl) ∩ int(Sˆl) 6= ∅ for all l 6= ˆl and
∪l∈ISl = D.
Let also δt be a time step. Through the aforementioned space
and time discretization we aim to capture the reachability
properties of the continuous system (3) in order to create
a WTS of each agent. The WTS will later on serve in the
synthesis of plans that fulﬁll the high-level speciﬁcations and
that map onto the desired free inputs vi, i ∈ I.
Given an index set I and an agent i ∈ I with neighbors
j1, . . . , jNi, we deﬁne the mappings pri : IN → INi+1, ¯pri :
IN → I. The ﬁrst one assigns to each N -tuple l =
(l1, . . . , lN ) ∈ IN the Ni + 1 tuple li = (li, lj1 , . . . , ljNi
) ∈
INi+1 which will be primarily used to denote the indices of
the cells where the agent i and its neighbors belong. The
second one assigns to each N -tuple l = (l1, . . . , lN ) ∈ IN
the position li ∈ I of the agent i, i.e., the cell that the agent i
occupies at the moment. The notation ¯l = (¯l1, . . . , ¯lN ) ∈ IN

is also introduced in order to specify the indices of the cells
where all the N agents belong at a given time instant. We
call ¯l the cell conﬁguration of all the agents.

i

Consider a particular conﬁguration, where agent i occupies
the cell Sli. If there exists a free input for each state in Sli
that navigates the agent i into the cell Sl′
precisely in δt,
regardless of the locations of the agent i’s neighbors within
their current cells, then we enable a transition from li to l′i in
the WTS. This forms the well-possessedness of transitions
and the mathematical derivation can be found in [48]. In
particular, sufﬁcient conditions relating the dynamics of the
multi-agent system, the time step δt and the diameter dmax =
sup{kx − yk : x, y ∈ Sl, l ∈ I} of the cell decomposition
S guarantee the existence of well-posed transitions from
each cell. We remark that once a cell-decomposition of
diameter dmax and a time step δt which guarantee well-posed
transitions have been chosen, it is also possible to chose any
other cell-decomposition with diameter ˆdmax ≤ dmax.
Based on [48], the conditions that the dynamics of the
system should fulﬁll in order to have well-posed abstractions
are the following:
(C1) There
exists M > vmax > 0 such that
kfi(xi, xj)k ≤ M, ∀i ∈ I, x ∈ RN n : ∆x ∈ X and
pri(x) = (xi, xj) by applying the projection operator pri
for I = Rn.

(C2) There exists a Lipschitz constant L1 > 0 such that
kfi(xi, xj ) − fi(xi, yj)k ≤ L1k(xi, xj ) − (xi, yj)k,
∀ i ∈ I, xi, yi ∈ Rn, xj , yj ∈ RNin.

(14)

(C3) There exists a Lipschitz constant L2 > 0 such that
kfi(xi, xj ) − fi(yi, xj )k ≤ L2k(xi, xj) − (yi, xj )k,
∀ i ∈ I, xi, yi ∈ Rn, xj , yj ∈ RNin.

(15)

By checking all the conditions one by one for fi(xi, xj) as
in (4), we have:

(C1) For every i ∈ I,∀ x ∈ RN n : ∆x ∈ X and pri(x) =
(xi, xj ) we have that

(16)

kxi − xjk

− Xj∈N (i)

≤ Xj∈N (i)

kxi − xjk = ∆x ≤ ¯R.

(xi − xj)(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
kfi(xi, xj)k =(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)
≤ X{i,j}∈E
Thus, M = ¯R. We have also that kD(G)τk =
pλmax(D(G)D(G)τ ) = pλmax(G)
and λ2(G) ≤
N−1 min{Ni : i ∈ V} from [59]. For N ≥ 2 it holds that
λ2(G) ≤ N . From Theorem (1) we have that ¯R > K2vmax ⇔
M > K2vmax. It holds that M > vmax since
2√N (N − 1)pλmax(G)
pλ3
2(G)pλ2(G)
2√N (N − 1)
√N 3

2√N (N − 1)kD(G)τk
√N 3 s λmax(G)
2√N (N − 1)
λ2(G) ≥

N

≥

λ2
2(G)

> 1.

K2 =

=

(C2) We have that

kfi(xi,xj) − fi(xi, yj)k

(xi − yj)(cid:13)(cid:13)(cid:13)

Thus, the condition (C3) holds and the Lipschitz constant is

=(cid:13)(cid:13)(cid:13) − Xj∈N (i)
(xi − xj) + Xj∈N (i)
≤pNi k(xi, xj) − (xi, yj)k
≤ max{pNi : i = 1, . . . , N} k(xi, xj) − (xi, yj )k.
L1 = max{√Ni : i = 1, . . . , N} > 0, where the inequality
i=1 αi)2 ≤ ρ (cid:0)Pρ
(Pρ
(C3) By using the same methodology with the proof of
(C2) we conclude that L2 = max{Ni : i = 1, . . . , N} > 0.
We will assume here that the partition S AP is a cell
decomposition in accordance to Def. 8. It is now necessary to
ensure that the cell decomposition S = {Sl}l∈I is compliant
ℓ }l∈IAP , i.e., that
with the cell decomposition S AP = {S AP
∈ S AP and
Sl ∩ S AP
l ∈ I, ℓ ∈ IAP . To that end, we deﬁne:

∈ S ∪ {∅} for each Sl ∈ S, S AP

i(cid:1) is used.

i=1 α2

ℓ

ℓ

ˆS = { ˆSˆl}ˆl∈ˆI = {SAP

ℓ ∩ Sl : ℓ ∈ IAP , l ∈ I}\{∅}.

(17)

It can be seen that ˆS is a cell decomposition and satisﬁes
ˆdmax ≤ dmax. Hence, according to the discussion above, we
have a well-posed abstraction.
Based on the aforementioned abstraction, the WTS from

i

indices of the cell decomposition.
0 ⊆ Si, is a set of initial states.
and its neighbors are located.

Def. 3 is adopted as follows.
Deﬁnition 9. The motion of each agent i ∈ I in the
workspace is modeled by a WTS Ti = (Si, Sinit
, Acti,−→i,
di, APi, ˆLi) where
• Si = ˆI, the set of states of each agent is the set of
• Sinit
• Acti = ˆINi+1, the set of actions representing where i
• For a pair (ˆli, li, ˆl′i) we have that (ˆli, li, ˆl′i) ∈−→i iff
li−→i ˆl′i is well-posed (for well-posed
ˆli = li and li
transitions we refer to [48]), for each ˆli, ˆl′i ∈ Si and
li = (li, lj1 , . . . , ljNi
• di :−→i→ T, is a map that assigns a positive weight
(duration) to each transition. According to the abstrac-
tion that was presented, each transition weight is exactly
equal to δt > 0.

) ∈ ˆINi+1.

• AP i is the set of atomic propositions from Problem 1.
• ˆLi : Si → 2APi is the labeling function obtained in the
expected way from Li, where Li is given in the problem
statement.

C. Runs Consistency

that

Due to the fact

the dynamics of the system has
couplings between the agents, it is necessary to deﬁne timed
runs that can be performed from each individual agent.
Before introducing the deﬁnition of consistent runs, it is
crucial to provide the deﬁnition of the product TS, which

essentially captures the behavior of the coupled multi-agent
system.
Deﬁnition 10. The product TS Tp = (Sp, Sinit
deﬁned as follows

p ,−→p) is

• Sp = ˆIN .
• (s1, . . . , sN ) ∈ Sinit if si ∈ Sinit
• (¯l,¯l′) ∈−→p iff ¯l′i ∈ Posti(¯li, pri(¯l)),∀ i ∈ I,∀ ¯l =
(¯l1, . . . , ¯lN ),¯l′ = (¯l1, . . . , ¯lN ).

for all i ∈ I.

i

The action labels, the weight, the atomic propositions
and the labeling function in Tp are insigniﬁcant and hence,
without loss of generality, we omitted them from the tuple
along with deﬁning the transition relation as −→p⊆ Sp×Sp.
Deﬁnition 11. A timed run
rt
p =
((r1
of Tp induces a set of consistent projected runs

p (0)), τp(0))((r1

p (1)), τp(1)) . . .

p(0), . . . , rN

p(1), . . . , rN

i = (ri

p(0), τp(0))(ri

{rt

p(1), τp(1)) . . . : i ∈ I}

of the WTSs T1, . . . ,TN , respectively.

An example that explains the notation that has been

introduced till now is the following:

S AP

6

S AP

5

j1

15

δt

i

1

j2

δt

δt

S AP
4
22

8

dmax

S AP

1

S AP

S AP
Fig. 2: Timed runs of the agents i, j1, j2
2. Consider
(Fig.

agent

3

2

an

Example
2) moving
to the workspace with N (i) = {1, 2}, SAP =
ℓ }ℓ∈IAP , ˆS = { ˆSˆl}ˆl∈ˆI = {Sl}l∈I = S, IAP =
{SAP
{1, . . . , 6}, ˆI = I = {1, . . . , 28} and atomic propositions
{p1, . . . , p6} = {orange, green, blue yellow, red, grey}.
The red arrows represent both the transitions of
the
i and its neighbors. The dashed lines indicate
agent
the
atomic
propositions we have that Li(14) = {p1}, Li(17) =
{p5}, Li(10) = {p2}, Li(20) = {p4}, Lj1(28) = {p6} =
Lj1 (27), Lj1(24) = {p5}, Lj1(22) = {p4}, Lj2(2) =
{p1}, Lj2(12) = {p2} = Lj2 (5), Lj2(9) = {p3}. Note
also the diameter of the cells ˆdmax = dmax. For the cell
conﬁgurations we have

in the network graph. For

edges

the

Step1 :
Step3 :

li = (17, 27, 13)
lj1 = (27, 17)
lj2 = (13, 17)

li = (20, 22, 9)
lj1 = (22, 20)
lj2 = (9, 20)

li = (14, 28, 2)
lj1 = (28, 14)
lj2 = (2, 14)

li = (10, 24, 5)
lj1 = (24, 10)
lj2 = (5, 10)

Init :
Step2 :

The consistent timed runs are given as

rt
i = (ri(0) = 14, τi(0) = 0)(ri(1) = 17, τi(1) = δt)
(ri(2) = 10, τi(2) = 2δt)(ri(3) = 20, τi(3) = 3δt)
rt
j1 = (rj1 (0) = 28, τj1(0) = 0)(rj1 (1) = 27, τj1 (1) = δt)
(rj1 (2) = 24, τj1(2) = 2δt)(rj1 (3) = 22, τj1(3) = 3δt)
rt
j2 = (rj2 (0) = 2, τj2 (0) = 0)(rj2 (1) = 13, τj2(1) = δt)
(rj2 (2) = 5, τj2 (2) = 2δt)(rj2 (3) = 9, τj2(3) = 3δt).

i |= (ϕi = ♦[0,6]{yellow}) if 3δt ∈
It can be observed that rt
[0, 6], rt
j2 |=
(ϕj2 = ♦[3,9]{blue}) if 3δt ∈ [3, 9]. For δt = 1, all the
agents satisfy their goals.

j1 |= (ϕj1 = ♦[3,10]{red}) if 2δt ∈ [3, 10] and rt

D. Controller Synthesis

The controller synthesis procedure can be summarized to

the following steps

1) N TBAs Ai, i ∈ I that accept all the timed runs satis-
fying the corresponding speciﬁcation formulas ϕi, i ∈
I are constructed.
2) We construct a B¨uchi WTS ˜Ti = Ti ⊗Ai (see Def. 12
below) for every i ∈ I. The accepting runs of ˜Ti are the
individual runs of the Ti that satisfy the corresponding
MITL formula ϕi, i ∈ I.
3) We pick a set of accepting runs {r1, . . . , rN} from
Step 2. We check if they are consistent according to
Def. 11. If this is true then we proceed with Step 5. If
this is not true then we repeat Step 3 with a different
set of accepting runs. However, to ensure convergence
of the procedure, we allow only a predeﬁned number
of repetitions of Step 3; if a consistent set of accepting
runs is not found, we proceed with the less efﬁcient
centralized, yet complete, procedure in Step 4.

i

(Qi, Qinit

i

12.

Given

a WTS
and

, Acti,−→i, di, APi, ˆLi),
=
be
clocks

4) We create the product Tp ⊗ Ap where Ap is the TBA
that accepts all the words that satisfy the formula ϕ =
ϕ1 ∧ . . . ∧ ϕN . If there is no accepting run found in
Tp ⊗ Ap, then Problem 1 has no solution.
5) The abstraction procedure allows to ﬁnd an explicit
feedback law for each transition in Ti. Therefore, an
accepting run in Ti that takes the form of a sequence
of transitions is realized in the system in (3), (4) via
the corresponding sequence of feedback laws.
Ti
a
, Ci, Invi, Ei, Fi, APi,Li)

Deﬁnition
=
(Si, Sinit
TBA
with
Ai
constant
|Ci|
appearing in Ai. Then, we deﬁne their B¨uchi WTS
,gActi,  i,edi, eFi, APi,eLi) as
eTi = Ti ⊗ Ai = (eQi, eQinit
follows:
• eQi ⊆ {(ri, si) ∈ Si × Qi : Li(ri) = Li(si)} × T|Ci|
• eQinit
{z
|
• gActi = Acti.
• (q, Ii, q′) ∈  i iff
◦ q = (r, s, ν1, . . . , ν|C|i) ∈ Qi,
) ∈ Qi,

q′ = (r′, s′, ν′1, . . . , ν′

i × S init

.
i × {0} × . . . × {0}

and let C max

i = Qinit

the

largest

Ci products

∞ .

}

|C|i

i

i

◦ Ii ∈ Acti,
◦ (r, Ii, r′) ∈−→i, and
◦ there exists γ, R, such that (s, γ, R, s′) ∈ Ek,
|C|i |= Ii(s′), and for

ν1, . . . , ν|C|i |= γ, ν′1, . . . , ν′
all i ∈ {1, . . . ,|C|i}

ν′i =

0,
νi + dk(r, r′),

∞,

if xi ∈ R
if xi 6∈ R and
νi + di(r, r′) ≤ C max
otherwise.

i

Then, edi(q, q′) = di(r, r′).
• eFi = {(ri, si, ν1, . . . , ν|C|i) ∈ Qk : si ∈ Fi}.
• eLi(ri, si, ν1, . . . , ν|C|i) = ˆLi(ri).
An accepting timed run of eTi projects onto a timed run of
Ti that satisﬁes the speciﬁcation formula ϕi by construction.

10

Agent 1
Agent 2
Agent 3
Set X
Goal Ag.1
Goal Ag.2
Goal Ag.3

s
i
x
a

y

8

6

4

2

0

-2

-4

-6

-8

-10

-10

-5

0

5

10

Fig. 3: Space discretization, goal regions and reachable sets for each agent
in a time horizon of 11δt steps

x axis

V. SIMULATION RESULTS

For a simulation example, we consider a system of three
agents with xi ∈ R2,
i ∈ I = {1, 2, 3},N (1) =
{2} = N (3),N (2) = {1, 3}. Their dynamics are given
as ˙x1 = x2 − x1 + v1, ˙x2 = x1 + x3 − 2x2 + v2 and
˙x3 = x2 − x3 + v3. The simulation parameters are set to
¯R = 10, M = 20, vmax = 10, L1 = √2, L2 = 2, δt = 0.2.
The workspace [−10, 10]×[−10, 10] ⊆ R2 is partitioned into
cells and the initial agents’ positions are set to (−6, 0), (0, 6)
and (6, 0) respectively. The speciﬁcation formulas are set
to ϕ1 = ♦[0.5,1.7]{green}, ϕ2 = ♦[1.0,1.4]{orange}, ϕ3 =
♦[0.7,1.8]{black} respectively and their corresponding TBAs
are given in Fig. 1. The abstraction presented in this paper,
the reachable cells of each agent as well as the goal regions
are depicted in Fig. 3. It can be observed that not all the indi-
vidual runs satisfy the desired speciﬁcation (namely, not all
the individual agent’s paths reach the goal within the speciﬁc
time bounds). By applying the ﬁve-step controller synthesis
procedure that was presented in Sec. IV, the individual run of

each agent satisfy the formulas ϕ1, ϕ2 and ϕ3 in 6δt, 6δt and
5δt respectively. The simulation is performed in a horizon
of 11δt steps (as the steps that explained in the Example 2).
The product WTS has 45× 104 states. The simulations were
carried out in MATLAB Environment on a desktop with 8
cores, 3.60GHz CPU and 16GB of RAM.

VI. CONCLUSIONS AND FUTURE WORK

We have proposed a systematic method of both abstraction
and controller synthesis in high-level for multi-agent path-
planning problems, in which timed constraints of fulﬁlling
a high-level speciﬁcation are imposed to the system. The
solution involves initially a boundedeness analysis and sec-
ondly WTS, TBAs and B¨uchi WTS generation. The simu-
lation examples showed that the proposed solution scales.
Future work includes further computational improvement
of the abstraction method and more complicated high-level
tasks being imposed to the agents in order to exploit the
expressiveness of MITL formulas.

REFERENCES

[1] W. Ren and R. Beard, “Consensus Seeking in Multi-agent Systems

under Dynamically Changing Interaction Topologies,” TAC, 2005.

[2] R. Olfati-Saber and R. Murray, “Consensus Problems in Networks of

Agents with Switching Topology and Time-Delays,” TAC, 2004.

[3] A. Jadbabaie, J. Kin, and S. Morse, “Coordination of Groups of Mobile

Autonomous Agents Using Nearest Neighbor Rules,” TAC, 2003.

[4] M. Zavlanos and G. J. Pappas, “Distributed connectivity control of

mobile networks,” IEEE Transactions on Robotics, 2008.

[5] H. Tanner, A. Jadbabaie, and G. Pappas, “Flocking in Fixed and
Switching Networks,” IEEE Transactions on Automatic Control, 2007.
[6] G. Shi and K. Johansson, “Robust Consensus for Continuous-Time

Multi-Agent Dynamics,” SIAM, 2013.

[7] S. Loizou and K. Kyriakopoulos, “Automatic Synthesis of Multi-Agent
Motion Tasks Based on LTL Speciﬁcations,” IEEE Conference on
Decision and Control, 2004.

[8] T. Wongpiromsarn, U. Topcu, and R. Murray, “Receding Horizon

Control for Temporal Logic Speciﬁcations,” HSCC, 2010.

[9] M. Guo and D. Dimarogonas, “Multi-Agent Plan Reconﬁguration

Under Local LTL Speciﬁcations,” IJRR, 2015.

[10] S. Karaman and E. Frazzoli, “Linear Temporal Logic Vehicle Routing

with Applications to Multi-UAV Mission Planning,” IJRNC, 2011.

[11] M. Kloetzer and C. Belta, “Automatic Deployment of Distributed
Teams of Robots From Temporal Motion Speciﬁcations,” TRO, 2010.
[12] Y. Chen, X. Ding, A. Stefanescu, and C. Belta, “A Formal Approach
to Deployment of Robotic Teams in an Urban-Like Environment,”
Distributed Autonomous Robotic Systems, pp. 313–327, 2013.

[13] Y. Chen, Ding, X. Chu, A. Stefanescu, and C. Belta, “Formal Approach
to the Deployment of Distributed Robotic Teams,” IEEE TRO, 2012.
[14] M. Kloetzer, X. C. Ding, and C. Belta, “Multi-Robot Deployment from
LTL Speciﬁcations with Reduced Communication,” IEEE CDC, 2011.
[15] A. Bhatia, M. Maly, L. Kavraki, and M. Vardi, “Motion Planning with

Complex Goals,” IEEE Robotics and Automation Magazine, 2011.

[16] H. Kress-Gazit, G. Fainekos, and G. Pappas, “Temporal-Logic-Based

Reactive Mission and Motion Planning,” IEEE TRO, 2009.

[17] A. Ulusoy, S. Smith, X. Ding, C. Belta, and D. Rus, “Optimality
and Robustness in Multi-Robot Path Planning with Temporal Logic
Constraints,” The Int. Jour. of Robotic Research, 2013.

[18] M. Quottrup, T. Bak, and R. Zamanabadi, “Multi-Robot Planning: A

Timed Automata Approach,” IEEE ICRA, 2004.

[19] M. Andersen, R. Jensen, T. Bakand, and M. Quottrup, “Motion
Planning in Multi-Robot Systems Using Timed Automata,” 5th
IFAC/EURON, 2004.

[20] K. Larsen, P. Pettersson, and W. Yi, “UPPAAL in a Nutshell,” IJSTTT,

1997.

[21] A. Ulusoy, S. Smith, X. Ding, C. Belta, and D. Rus, “Optimal Multi -
Robot Path Planning with Temporal Logic Constraints,” IROS, 2011.
[22] J. Liu and P. Prabhakar, “Switching Control of Dynamical Systems

from Metric Temporal Logic Speciﬁcations,” IEEE ICRA, 2014.

[23] V. Raman, A. Donz´e, D. Sadigh, R. Murray, and S. Seshia, “Reactive
Synthesis from Signal Temporal Logic Speciﬁcations,” HSCC, 2015.
[24] Y. Zhou, D. Maity, and J. S. Baras, “Optimal Mission Planner with

Timed Temporal Logic Constraints,” ECC, 2015.

[25] B. Hoxha and G. Fainekos, “Planning in Dynamic Environments

Through Temporal Logic Monitoring,” 2016.

[26] J. Fu and U. Topcu, “Computational Methods for Stochastic Control

with Metric Interval Temporal Logic Speciﬁcations,” CDC, 2015.

[27] S. Karaman and E. Frazzoli, “Vehicle Routing Problem with Metric

Temporal Logic Speciﬁcations,” IEEE CDC, 2008.

[28] A. Nikou, J. Tumova, and D. Dimarogonas, “Cooperative Task Plan-
ning of Multi-Agent Systems Under Timed Temporal Speciﬁcations,”
ACC, 2016.

[29] P. Caines and Y. Wei, “The Hierarchical Lattices of a Finite Machine,”

Systems & Control Letters, vol. 25, pp. 257–263, 1995.

[30] R. Alur, T. Henzinger, G. Lafferriere, and G. Pappas, “Discrete

Abstractions of Hybrid Systems,” 2000.

[31] G. Pappas, “Bisimilar Linear Systems,” Automatica, 2003.
[32] R. Alur, T. Dang, and F. Ivanˇci´c, “Predicate Abstraction for Reacha-

bility Analysis of Hybrid Systems,” ACM TECS, 2006.

[33] C. Belta and V. Kumar, “Abstraction and Control for Groups of

Robots,” IEE Transation on Robotics, 2004.

[34] L. Habets, P. Collins, and V. Schuppen, “Reachability and Control
Synthesis for Piecewise-Afﬁne Hybrid Systems on Simplices,” IEEE
Transactions on Automatic Control, vol. 51, no. 6, pp. 938–948, 2006.
[35] A. Girard and G. Pappas, “Approximation Metrics for Discrete and
Continuous Systems,” IEEE Transactions on Automatic Control, 2007.
[36] G. Pola, A. Girard, and P. Tabuada, “Approximately Bisimilar Sym-

bolic Models for Nonlinear control systems,” Automatica, 2008.

[37] A. Tiwari, “Abstractions for Hybrid Systems,” Formal Methods in

System Design, vol. 32, no. 1, pp. 57–83, 2008.

[38] P. Tabuada, Veriﬁcation and Control of Hybrid Systems: a Symbolic

Approach. Springer Science and Business Media, 2009.

[39] M. Zamani, G. Pola, M. Mazo, and P. Tabuada, “Symbolic Models
for Nonlinear Control Systems without Stability Assumptions,” IEEE
Transactions on Automatic Control, vol. 57, no. 7, 2012.

[40] G. Reißig, “Computing Abstractions of Nonlinear Systems,” IEEE

Transactions on Automatic Control, vol. 56, no. 11, 2011.

[41] E. A. Gol and C. Belta, “Time-Constrained Temporal Logic Control
of Multi-Afﬁne Systems,” Nonlinear Analysis: Hybrid Systems, 2013.
[42] J. J. Liu and N. Ozay, “Abstraction, Discretization, and Robustness in

Temporal Logic Control of Dynamical Systems,” HSCC, 2014.

[43] D. Fan and D. Tarraf, “Finite Uniform Bisimulations for Linear

Systems with Finite Input Alphabets,” IEEE CDC, 2015.

[44] A. Borri, G. Pola, and M. Benedetto, “A Symbolic Spproach to the

Design of Nonlinear Networked Control Systems,” HSCC, 2012.

[45] M. Zamani, M. Mazo, and A. Abate, “Finite Abstractions of Net-

worked Control Systems,” IEEE CDC, 2014.

[46] M. Rungger and M. Zamani, “Compositional Construction of Approx-

imate Abstractions,” HSCC, 2015.

[47] G. Pola, P. Pepe, and M. D. D. Benedetto, “Symbolic Models for

Networks of Control Systems,” IEEE TAC, 2016.

[48] D. Boskos and D. Dimarogonas, “Decentralized Abstractions For
Multi-Agent Systems Under Coupled Constraints,” IEEE CDC, 2015.
[49] M. Mesbahi and M. Egerstedt, “Graph Theoretic Methods in Multia-

gent Networks,” 2010.

[54] S. Tripakis, “Checking Timed Buchi Automata Emptiness on Simula-

tion Graphs,” ACM TCL, vol. 10, no. 3, 2009.

[55] R. Alur, T. Feder, and T. A. Henzinger, “The Beneﬁts of Relaxing

Punctuality,” JASM, 1996.

[56] O. Maler, D. Nickovic, and A. Pnueli, “From MITL to Timed

Automata,” FMATS, pp. 274–289, 2006.

[57] D. Niˇckovi´c and N. Piterman, “From MTL to Deterministic Timed

Automata,” Formal Modeling and Analysis of Timed Systems, 2010.

[58] D. Boskos and D. Dimarogonas, “Robust Connectivity Analysis for

Multi-Agent Systems,” IEEE CDC, 2015.

[59] M. M. Fiedler, “Algebraic connectivity of graphs,” 1973.

[50] R. Alur and D. Dill, “A Theory of Timed Automata,” Theoretical

Computer Science, vol. 126, no. 2, pp. 183–235, 1994.

[51] D. D. Souza and P. Prabhakar, “On the Expressiveness of MTL in the

Pointwise and Continuous Semantics,” IJSTTT, 2007.

[52] J. Ouaknine and J. Worrell, “On the Decidability of Metric Temporal

Logic,” IEEE Symposium on Logic in CS, pp. 188–197, 2005.

[53] P. Bouyer, “From Qualitative to Quantitative Analysis of Timed

Systems,” 2009.

