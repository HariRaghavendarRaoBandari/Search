DRAFT

1

Interlinked Cycles for Index Coding:

Generalizing Cycles and Cliques

Chandra Thapa, Lawrence Ong, and Sarah J. Johnson

6
1
0
2

 

b
e
F
9
2

 

 
 
]
T
I
.
s
c
[
 
 

1
v
2
9
0
0
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

We consider a graphical approach to index coding. While cycles have been shown to provide
coding gain, only disjoint cycles and cliques (a specific type of overlapping cycles) have been exploited
in existing literature. In this paper, we define a more general form of overlapping cycles, called the
interlinked-cycle (IC) structure, that generalizes cycles and cliques. We propose a scheme, called the
interlinked-cycle-cover (ICC) scheme, that leverages IC structures in digraphs to construct scalar linear
index codes. We characterize a class of infinitely many digraphs where our proposed scheme is optimal
over all linear and non-linear index codes. Consequently, for this class of digraphs, we indirectly prove
that scalar linear index codes are optimal. Furthermore, we show that the ICC scheme can outperform
all existing graph-based schemes (including partial-clique-cover and fractional-local-chromatic number
schemes), and a random-coding scheme (namely, composite coding) for certain graphs.

Index Terms

Index coding problem, unicast, linear index codes, interlinked-cycle cover, optimal broadcast rate.

I. INTRODUCTION

On index coding (introduced by Birk and Kol [1] in 1998), a sender broadcasts messages
through a noiseless shared channel to multiple receivers, each knowing some messages a priori,
which are known as side information. Side information occurs frequently in many communication

The authors are with the School of Electrical Engineering and Computer Science, The University of Newcastle, Newcastle,

Australia (email: chandra.thapa@uon.edu.au, lawrence.ong@cantab.net, sarah.johnson@newcastle.edu.au).

This work is supported by the Australian Research Council under grants FT110100195, FT140100219, and DP150100903.
Part of the material in this paper was presented at the IEEE International Symposium on Information Theory, HongKong,

Jun. 14-19, 2015, and at the IEEE Information Theory Workshop, Jeju Island, Korea, Oct. 11-15, 2015.

March 2, 2016

DRAFT

DRAFT

2

networks, e.g., in a web browsers’ cache. Knowing the side information of the receivers, the
sender can send coded symbols, known as an index code, in such a way that all of the receivers
can decode their requested messages using their side information and the received coded symbols.
The aim is to find the shortest (optimal) index code. How to optimally design an index code for
an arbitrary index-coding instance1 is an open problem to date.

In the literature, various approaches have been adopted to solve the index-coding problem.
We broadly classify these approaches into four categories: (i) numerical, (ii) Shannon’s random
coding, (iii) interference alignment, and (iv) graph-based. Numerical approaches include rank
minimization over finite fields [2], [3] (which is NP-hard to compute in general [4]), and
mathematical optimization programming (semi-definite programming [5], linear programming
[6], and integer-linear programming [7]). These approaches do not provide much intuition
on the interaction between the side-information configuration and the index codes. Shannon’s
random coding approaches [8], [9] require infinitely long message packets. Interference-alignment
approaches treat index coding as an interference-alignment problem [10], [11], and construct
index codes via two alignment techniques, namely one-to-one alignment and subspace alignment.
These alignment techniques have no well-defined algorithms to construct index codes for arbitrary
index-coding instances. Graph-based approaches [1], [7], [12]–[20] provide intuition on the side-
information configurations and index codes. These approaches represent index-coding instances
by graphs, and construct index codes as functions of the graphs. These graph-based schemes
provide linear (scalar and vector) index codes. Although linear index codes are not always optimal
[3], [21], they have simpler encoding and decoding processes.

We classify graph-based approaches into two sub-categories: (i) Maximum distance separable
(MDS) code based interference alignment approaches, and (ii) graph structure based approaches.
The MDS code based interference alignment approaches construct index codes by treating
messages not known to a receiver as interference, and aligning all interference with the help
of MDS codes. These approaches include the partial-clique-cover scheme [1] and its fractional
version [7], [12], the local-chromatic-number scheme and its fractional version [13], and the
partitioned-local-chromatic-number scheme and its fractional version [14]. Graph structure based

1An index-coding instance is a specific index-coding problem characterized by the message sets each receiver wants and

knows.

March 2, 2016

DRAFT

DRAFT

3

approaches exploit special graph structures, based on messages known to the receivers that can
provide savings2 on index-coding instances.

It has been shown that no structure in an acyclic graph can provide any savings [2]. Furthermore,
if an arc does not belong to any cycle, then removing it does not change the optimal index
code [17]–[19]. These observations point to the importance of cycles on index coding. In the
literature, only disjoint cycles and cliques, a specific combination of overlapping cycles, have
been exploited so far. More precisely, disjoint cycles in digraphs are exploited by the cycle-cover
scheme [15], [16] and its fractional version [15], and disjoint cliques in digraphs are exploited by
the clique-cover scheme [1] and its fractional version [6]. Overlapping cycles can provide more
savings than disjoint cycles. We take a clique as an example. In a clique, every vertex forms a
cycle with any other vertex, and we see overlapping of cycles at every vertex. If we consider
only disjoint cycles in the clique, we get an index code strictly longer than that by considering
the clique. However, not all forms of overlapping cycles are useful, in the sense that they provide
more savings than considering only disjoint cycles and cliques. In this work, we consider a graph
structure based approach, and propose structures of overlapping cycles that can be exploited
in graphs to provide potentially more savings than the cycle-cover scheme, the clique-cover
scheme, and other existing schemes. The proposed structures are called interlinked-cycle (IC)
structures, and they generalize cycles and cliques. Furthermore, we define a scheme, called the
interlinked-cycle cover (ICC) scheme, that constructs index codes based on IC structures.

A. Our contributions

1) We propose a new index-coding scheme (called the ICC scheme) that generalizes the
clique-cover scheme and the cycle-cover scheme. The new scheme constructs scalar linear
index codes.

2) We characterize a class of digraphs (with infinitely many members) for which the ICC
scheme is optimal (over all linear and non-linear index codes). This means scalar linear
index codes are optimal for this class of digraphs.

3) For a class of digraphs, we prove that the ICC scheme performs at least as well as the
partial-clique-cover scheme. We conjecture that the result is valid in general. Furthermore,

2The number of transmissions saved by transmitting coded symbols (coded messages) rather than transmitting uncoded messages

is called savings of the index code.

March 2, 2016

DRAFT

DRAFT

4

we present a class of digraphs where the additive gap between these two schemes grows
linearly with the number of vertices in the digraph.

4) For a class of digraphs, we prove that the ICC scheme performs at least as well as the
fractional-local-chromatic-number scheme. Moreover, we present a class of digraphs where
the additive gap between these two schemes grows linearly with the number of vertices in
the digraph.

5) We show that the ICC scheme can outperform all of the existing graph-based schemes and

the composite-coding scheme in some examples.

6) We extend the ICC scheme to the fractional-ICC scheme. This modified scheme time-shares
multiple IC structures, and constructs vector linear index codes that can be, for certain
digraphs, shorter than the scalar linear index codes obtained from the ICC scheme.

II. DEFINITIONS AND BACKGROUND

A. Problem formulation

Consider a transmitter that wants to transmit N messages X = {x1, x2, . . . , xN} to N receivers
{1, 2, . . . , N} in a unicast message setting, meaning that each message is requested by only
one receiver, and each receiver requests only one message. Without loss of generality, let each
receiver i request message xi, and possess side information Si ⊆ X \ {xi}. This problem can be
described by a digraph D = (V (D), A(D)), where V (D) = {1, 2, . . . , N}, the set of vertices in
D, represents the N receivers. An arc (i → j) ∈ A(D) exists from vertex i to vertex j if and
only if receiver i has packet xj (requested by receiver j) as its side information. The set of the
side information of a vertex i is Si (cid:44) {xj : j ∈ N +
D (i) is the out-neighborhood
of i in D. Let X and all Si be ordered sets, where the ordering can be arbitrary but fixed.

D (i)}, where N +

Definition 1 (Index code): Suppose xi ∈ {0, 1}t for all i and some integer t ≥ 1, i.e., each
message consists of t bits. Given an index-coding problem modeled by D, an index code (F ,{Gi})
is defined as follows:

1) An encoding function for the source, F : {0, 1}N t → {0, 1}p, which maps X to a p-bit

index for some positive integer p.

2) A decoding function Gi for every receiver i, Gi : {0, 1}p × {0, 1}|Si|t → {0, 1}t, that maps
the received index code F (X) and its side information Si to the requested message xi.

March 2, 2016

DRAFT

DRAFT

5

Definition 2 (Broadcast rate or index codelength): The broadcast rate of an index code (F ,{Gi})

is the number of transmitted bits per received message bits at every user, or equivalently the
number of transmitted coded symbols (each of t bits). This is denoted by (cid:96)(D) (cid:44) p
t , and also
referred as the normalized length of the index code.

Definition 3 (Optimal broadcast rate): The optimal broadcast rate for a given index coding
(cid:96)(D), and the optimal broadcast rate over all t

F

problem D with t-bit messages is βt(D) (cid:44) min
is defined as β(D) (cid:44) inf

βt(D).

t

Definition 4 (Maximum acyclic induced sub-digraph): For a digraph D, an induced acyclic
sub-digraph formed by removing the minimum number of vertices in D, is called a maximum
acyclic induced sub-digraph (MAIS). The order of the MAIS is denoted as MAIS(D).

It has been shown that for any digraph D and any message length of t-bits, MAIS(D) lower

bounds the optimal broadcast rate [2],

MAIS(D) ≤ β(D) ≤ βt(D).

(1)

B. Some existing schemes

In this sub-section, we describe the clique-cover, the cycle-cover and the partial-clique-cover
schemes in detail. These schemes provide some basic intuitions about our proposed ICC scheme.
Definition 5 (Clique): A clique is a sub-digraph where each vertex has an out-going arc to

every other vertex in that sub-digraph.

Definition 6 (Clique-covering number, (cid:96)CL(D)): The clique-covering number is the minimum
number of cliques partitioning a digraph D (over all partitions) such that if each clique is denoted as
∀i V (ρi) = V (D), V (ρi)∩ V (ρj) = ∅, ∀i, j ∈ {1, . . . , (cid:96)CL(D)}

ρi for i ∈ {1, . . . , (cid:96)CL(D)}, then(cid:83)

and i (cid:54)= j (here a vertex is a clique of size one).

The clique-covering number is equal to the chromatic number of the underlying undirected
graph of the complement digraph, i.e., (cid:96)CL(D) = χ(U ¯D), where U ¯D is the underlying undirected
graph of ¯D, ¯D is the complement digraph of D, and χ(D) denotes the chromatic number of D.
Definition 7 (Clique-cover scheme): The clique-cover scheme finds a set of disjoint cliques
that provides the clique-covering number, and constructs an index code in which the coded
symbol for each of the disjoint cliques is the bit-wise XOR of messages requested by all of the
vertices in that clique.

March 2, 2016

DRAFT

DRAFT

6

The clique-cover scheme achieves the following rate:
Proposition 1 (Birk and Kol [1]): The optimal broadcast rate of an index coding instance is

upper bounded by the clique cover number, i.e., β(D) ≤ βt(D) ≤ (cid:96)CL(D), ∀t.

Definition 8 (Path and cycle): A path consists a sequence of distinct (except possibly the first
and last) vertices, say 1, 2, . . . , M, and an arc (i → i + 1) for each consecutive pair of vertices
(i, i + 1) for all i ∈ {1, 2, . . . , M − 1}. We represent a path from the vertex 1 to the vertex M in
a digraph D as P1→M (D) = (cid:104)1, 2, . . . , M(cid:105). Here 1 is the first vertex and M is the last vertex. A
path with the same first and last vertices is a cycle.

Definition 9 (Cycle-covering number, (cid:96)CY(D)): The difference between the total number of
vertices in D and the maximum number of disjoint cycles in D is the cycle-covering number.
Definition 10 (Cycle-cover scheme): The cycle-cover scheme finds a set of disjoint cycles in
D that provides the cycle-covering number, and constructs an index code that has (i) coded
symbols for each disjoint cycle (for a cycle (cid:104)1, 2, . . . , M, 1(cid:105), a set of coded symbols are {x1 ⊕
x2, x2 ⊕ x3, . . . , xM−1 ⊕ xM}), and (ii) uncoded messages which are requested by those vertices
not included in any of the disjoint cycles in D.

The cycle-cover scheme achieves the following rate:
Proposition 2 ( [15], [16]): The optimal broadcast rate of an index-coding problem is upper

bounded by the cycle-covering number, i.e., β(D) ≤ βt(D) ≤ (cid:96)CY(D), ∀t.

Definition 11 (Partial clique): A sub-digraph Di = (V (Di), A(Di)) is a κ(Di)-partial clique,

where κ(Di) = |V (Di)| − δ+(Di) − 1 and δ+(Di) is the minimum out-degree of Di.

(cid:83)

Definition 12 (Partial-clique number, (cid:96)PC(D)): If D1, D2, . . . , Dm, for some positive integer
V (Di) = V (D) and V (Di) ∩ V (Dj) = ∅,
m(cid:88)

m, partition a digraph D such that
∀i, j ∈ {1, 2, . . . , m} and i (cid:54)= j, then

∀i∈{1,2,...,m}

(cid:96)PC[D1, D2, . . . , Dm] =

(κ(Di) + 1),

and the partial-clique number of the digraph is

i=1

(cid:96)PC(D) =

min

D1,D2...,Dm (cid:96)PC[D1, D2 . . . , Dm],

(2)

where the minimum is taken over all partitions.

Definition 13 (Partial-clique-cover scheme): The partial-clique-cover scheme finds a set of
disjoint partial cliques in D that provides the partial-clique number, and constructs an index code

March 2, 2016

DRAFT

DRAFT

7

that has (i) κ(Di) + 1 coded symbols for each disjoint κ(Di)-partial clique with |V (Di)| > 1
(a partial clique uses MDS codes to generate coded symbols), and (ii) an uncoded message for
each disjoint κ(Di)-partial clique with |V (Di)| = 1.

The partial-clique-cover scheme achieves the following rate:
Proposition 3 (Birk and Kol [1]): The optimal broadcast rate of an index coding instance is

upper bounded by the partial-clique number, i.e.,

Remark 1: The partial-clique-cover scheme performs at least as well as the cycle-cover and

β(D) ≤ (cid:96)PC(D).

(3)

the clique-cover schemes, i.e.,

(cid:96)PC(D) ≤ min {(cid:96)CL(D), (cid:96)CY(D)}.

(4)

This is because the partial-clique-cover scheme includes the cycle-cover scheme or the clique-
cover scheme as a special case. By definition, a clique is a 0-partial clique, and a cycle with
n vertices is a (n − 2)-partial clique. Despite the fact that the partial-clique-cover scheme uses
MDS codes, which require sufficiently large message length t in general, to construct index
codes, one can find MDS codes for any cycle and any clique for any t.

Remark 2: The clique-cover, the cycle-cover and the partial-clique-cover schemes provide
scalar linear index codes. We can also construct vector linear index codes by time-sharing all
possible cliques, cycles, partial cliques in their respective schemes, and these are called the
fractional versions of those schemes. The fractional version can strictly decrease the broadcast
rates (over the non-fractional version) for some digraphs, e.g., a 5-cycle [6].

III. MOTIVATING OVERLAPPING CYCLES

We present an example that illustrates the importance of overlapping cycles on index coding.
Consider the digraph D1 in Fig. 1a. In D1, the cycles (cid:104)1, 2, 1(cid:105) and (cid:104)1, 4, 3, 5, 1(cid:105) overlap at vertex
1, and some cycles similarly overlap at vertices 2 and 3. Note that MAIS(D1) = 3 ≤ β(D1).
Index codelengths for D1 by existing graph-based schemes (some schemes require a sufficiently
large t) are depicted in Table I.

Among all existing schemes listed in Table I, only the composite-coding scheme (which
requires infinitely long message length) can achieve β(D1). However, there exists a scalar linear

March 2, 2016

DRAFT

DRAFT

8

Fig. 1. Two digraphs with overlapping cycles, (a) D1, and (b) D2.

(a)

(b)

INDEX CODELENGTHS FOR THE DIGRAPH D1 IN FIG. 1A FROM EXISTING SCHEMES

TABLE I

Schemes

Clique cover [1]

Fractional-clique cover [6]

Cycle cover [15], [16]

Fractional-cycle cover [15]

Partial-clique cover [1]

Fractional-partial-clique cover [12]

Local-chromatic number [13]
Local time sharing [12], bLTS

Asymmetric coding [12], b(RLTS)

Composite coding [8]

Index codelength

4
4
4
3.5
4
3.5
4
3.5
3.5
3

index code of length three, i.e., {x1 ⊕ x2 ⊕ x3, x4 ⊕ x3, x5 ⊕ x1}, which is not found by these
existing index-coding schemes. Later in this paper, we will show how to obtain this code by
considering overlapping cycles.

In some digraphs with overlapping cycles, the optimal broadcast rate can be obtained by the
cycle-cover scheme (which only codes on disjoint cycles). The digraph D2 in Fig. 1b gives
one of these cases, where the optimal broadcast rate β(D2) = 2 is achieved by the cycle-cover
scheme, (cid:96)CY(D2) = 2. For these digraphs, there is no benefit considering overlapping cycles.

This paper explores structures with overlapping cycles having index codes with length strictly
shorter than that obtained from the cycle-cover scheme (possibly other existing schemes as well).
We will identify a class of such structures, and call them IC structures. We will also show that
exploiting IC structures can strictly outperform the composite-coding scheme for some digraphs.

March 2, 2016

DRAFT

123451234DRAFT

9

IV. UNDERSTANDING IC STRUCTURES AND CONSTRUCTION OF INDEX CODES

In this section, we provide an informal description of an IC structure and code construction.

This provides an insight into IC structures.

The main idea behind our definition of an IC structure is the existence of a set of vertices
with the following property: For any pair of vertices in the set, there exists a cycle containing
these two vertices, and no other vertices in the set. We call such a vertex set an inner vertex
set, and its vertices are called inner vertices (see Section V-A for the formal definition). The
remaining vertices that are not inner vertices are called non-inner vertices. Now we illustrate IC
structures with an example. For the digraph in Fig. 1a, {1, 2, 3} is an inner vertex set. This is
because the cycle (cid:104)1, 2, 1(cid:105) includes the vertex pair (1, 2), the cycle (cid:104)2, 3, 2(cid:105) includes the vertex
pair (2, 3), and the cycle (cid:104)1, 4, 3, 5, 1(cid:105) includes the vertex pair (1, 3). Consequently, the vertices
1, 2 and 3 are interlinked by cycles that are not disjoint (e.g., the vertex 1 is in cycles (cid:104)1, 2, 1(cid:105)
and (cid:104)1, 4, 3, 5, 1(cid:105)), and such cycles are called interlinked cycles. In Section V-A, we will formally
define an IC structure to be a sub-digraph consisting of paths among the inner vertices rather
than cycles between different inner vertex pairs. However, the two definitions are linked by the
observation that two vertex-disjoint (except for the end vertices) paths (cid:104)A, . . . , B(cid:105) and (cid:104)B, . . . , A(cid:105)
form a cycle.

The construction of an index code for the IC structure is as follows: (i) One codeword symbol
is formed by the XOR of messages requested by all of the inner vertices (e.g., for the digraph in
Fig. 1a, the vertices 1, 2 and 3 are inner vertices, so one of the coded symbols is x1 ⊕ x2 ⊕ x3),
and (ii) for each of the remaining vertices (non-inner vertices), a codeword symbol is formed
by the XOR of the message requested by the vertex and the messages requested by all of its
out-neighborhood vertices (e.g., for the digraph in Fig. 1a, vertices 4 and 5 are non-inner vertices,
so the corresponding coded symbols are x4 ⊕ x3 and x5 ⊕ x1). Thus the index code for the
digraph in Fig. 1a (which is also an IC structure) is {x1 ⊕ x2 ⊕ x3, x4 ⊕ x3, x5 ⊕ x1}. Now the
decoding process is as follows: Vertex 2 decodes its requested message x2 from the coded symbol
x1 ⊕ x2 ⊕ x3 because it knows x1 and x3 as its side information. Vertices 4 and 5 decode their
requested messages x4 and x5 from the coded symbols x4 ⊕ x3 and x5 ⊕ x1 respectively because
vertex 4 knows x3 as its side information, and vertex 5 knows x1 as its side information. Vertex
1 decodes its requested message x1 from (x1 ⊕ x2 ⊕ x3) ⊕ (x4 ⊕ x3) = x1 ⊕ x2 ⊕ x4 because

March 2, 2016

DRAFT

DRAFT

10

it knows x2 and x4 as its side information. Vertex 3 decode its requested message x3 from
(x1 ⊕ x2 ⊕ x3) ⊕ (x5 ⊕ x1) = x2 ⊕ x5 ⊕ x3 because it knows x2 and x5 as its side information.

V. AN IC STRUCTURE AND CONSTRUCTION OF THE INDEX CODE

In this section, we provide the formal definition of an IC structure and code construction.

A. Definition of an IC structure

In a digraph D, consider a structure having the following property:
• It has an inner vertex set denoted as VI. Without loss of generality, we consider VI =
{1, 2, . . . , K}. The vertices in VI are called inner vertices. For any ordered pair of inner
vertices (i, j) ∈ VI and i (cid:54)= j, there is a path from i to j, and the path does not include any
other vertex in VI except the first and the last vertices.

non-unique. If the union of all selected K trees(cid:83)

Due to the existence of paths between any vertex pair in VI, for each inner vertex i ∈ VI,
we can always find a directed rooted tree in D, denoted by Ti, where inner vertex i is the
root vertex, and all other inner vertices VI \ {i} are the leaves (see Fig. 2a). The trees may be
Ti (see Fig. 2b) satisfies two conditions
(to be defined shortly), we call it an interlinked-cycle structure (denoted as a K-IC sub-digraph:
DK = (V (DK), A(DK)), where |V (DK)| = N and VI = {1, 2, . . . , K}). Now we define a type
of cycle and a type of path.

∀i∈VI

Definition 14 (I-path, I-cycle): A path in which only the first and the last vertices are from
VI, and they are distinct, is a I-path. If the first and the last vertices are the same, then it is a
I-cycle.

The conditions for an IC structure are as follows:

1) Condition 1: There is no I-cycle in DK.
2) Condition 2: For all ordered pairs of inner vertices (i, j), i (cid:54)= j, there is only one I-path

from i to j in DK.

These two conditions are necessary for our code construction described in the following section
(for more discussions, see Examples 2 and 3).

March 2, 2016

DRAFT

DRAFT

11

(a)

(b)

Fig. 2.
(a) Outline of a tree Ti which has the root vertex i ∈ VI, all vertices in VI \ {i} as the leaf vertices, and some or all
vertices in V (D) \ VI (i.e., the non-inner vertex set) as intermediate vertices (between the root and the leaves), and b) outline of
an IC structure, where different trees Ti (shown in different colors) can share intermediate vertices.

B. Construction of an index code for a K-IC structure

We propose the following coded symbols for a K-IC structure DK:
1) A coded symbol obtained by the bitwise XOR (denoted by ⊕) of messages (each of t bits)

requested by all vertices of the inner vertex set VI, i.e.,

xi.

(5)

2) For each non-inner vertex j ∈ {K + 1, K + 2, . . . , N}, a coded symbol obtained by
the bitwise XOR of the message requested by j with the messages requested by its
out-neighborhood vertices, i.e.,

wI (cid:44) K(cid:77)

i=1

(cid:77)

q∈N +
DK

wj (cid:44) xj ⊕

Denote this code constructed for the K-IC structure by W (cid:44) {wI, wj : K + 1 ≤ j ≤ N}. The
total number of coded symbols in W is

xq.

(j)

(6)

(cid:96)(DK) = N − K + 1.

(cid:32)

Remark 3: For a given DK, encoding W requires at most t

K − 1 + (cid:80)

i∈V (DK )\VI |N +

DK

bit-wise XOR operations where t is the number of bits in each message symbol.

March 2, 2016

(7)

(cid:33)

(i)|

DRAFT

iRootVertex1KTii∈{1,2,...,K}Inermediateverticesbelongto⊆V(D)\VILeafVerticesVI\{i}InnerVertices12KVIIntermediatever-ticesofthetreeT1Intermediatever-ticesofthetreeTKIntermediatever-ticesofthetreeT2DRAFT

12

(a)

(b)

Fig. 3.
(a) A digraph D that is also an IC structure along with its trees T1, T2 and T3, (b) a digraph D along with its trees T1,
T2 and T3, has an I-cycle at vertex 2, and (c) a digraph D along with its trees T1, T2, T3 and T4, has two I-paths at vertex 3
from vertex 1.

(c)

Proposition 4: The code W constructed for a K-IC structure is an index code.

Proof: Refer to Appendix A.

The following example illustrates the definition of an IC structure.
Example 1: Consider the digraph D in Fig. 3a where we have identified the inner-vertex set
VI = {1, 2, 3}. For vertices 1, 2 and 3, we can always find the directed rooted trees T1, T2 and
T3. The union of these three trees form a digraph, denoted DK, with the following: (i) There is
no I-cycle for any vertex in VI, and (ii) the vertex 1 has only one I-path to each of the vertices 2
and 3 (i.e., (cid:104)1, 5, 2(cid:105) and (cid:104)1, 6, 3(cid:105)), and so do vertices 2 and 3. Thus DK is a 3-IC structure with
K = 3.

The following examples demonstrate why we impose two conditions, viz., Condition 1 and

Condition 2, for the definition of an IC structure.

Example 2 (Why no I-cycle in DK?): Consider the digraph D in Fig. 3b where we have
identified VI = {1, 2, 3}. The digraph has an I-cycle at vertex 2, i.e., (cid:104)2, 4, 2(cid:105). Suppose that we
consider D to be an IC structure. We construct a code for D from our proposed code construction;
wI = x1 ⊕ x2 ⊕ x3, w4 = x4 ⊕ x2 ⊕ x3 and w5 = x5 ⊕ x2 ⊕ x1. We can verify that vertex 2 with
side information {x1, x4} cannot decode its requested message from the code. This shows that

March 2, 2016

DRAFT

12365415623T1D24613T234512T3123541423T12413T23512T3D1623T1452513T24312T34412T43342156DDRAFT

13

our proposed scheme does not provide an index code for this case. In fact, MAIS(D) = 4, thus
no index code of length three exists for D. Moreover, the cycle-cover scheme is optimal here.

Example 3 (Why only one I-path for any ordered pair of the vertices (i, j) ∈ VI, i (cid:54)= j, is required in DK?):

Consider the digraph D in Fig. 3c where we have identified VI = {1, 2, 3, 4}. The digraph has two
I-paths from vertex 1 to vertex 3, viz., (cid:104)1, 5, 3(cid:105) and (cid:104)1, 6, 3(cid:105). Suppose that we consider D as an IC
structure. We construct a code for D from our proposed code construction; wI = x1⊕x2⊕x3⊕x4,
w5 = x5 ⊕ x3 ⊕ x4 and w6 = x6 ⊕ x2 ⊕ x3. We can verify that vertex 1 with side information
{x5, x6} cannot decode its requested message from the code. This shows that our proposed
scheme does not provide an index code for this case.

VI. MAIN RESULTS

In this section, firstly, we define the interlinked-cycle cover (ICC) scheme. Secondly, we prove
that the proposed ICC scheme includes the cycle-cover scheme and the clique-cover scheme
as special cases. Finally, for a class of digraphs (which includes infinitely many digraphs), we
prove that our proposed scheme is optimal, i.e., it achieves the optimal broadcast rates of those
digraphs.

Definition 15 (ICC scheme): For any digraph D, the ICC scheme finds a set of disjoint IC
structures covering D. It then codes each of these IC structures DK using the code construction
described in Section V-B. Note that when |V (DK)| = 1, we simply send the requested message
uncoded.

Now we present a main result of this paper. It is best expressed in terms of savings, defined

as follows:

Definition 16 (Savings): The number of transmissions saved by transmitting coded symbols
(coded messages) rather than transmitting uncoded messages (i.e., N −(cid:96)(D)), is called the savings
of the index code. It is denoted as S(D).

ψ(cid:80)

i=1

Theorem 1: For any digraph D, an index code of length (cid:96)ICC(D) = N −

(Ki − 1) can be
achieved by the ICC scheme, where (Ki − 1) is the savings in each disjoint Ki-IC structure, and
ψ is the number of disjoint IC structures in D.

Proof: Consider a K-IC structure DK with N(cid:48) number of vertices. It follows from (7) that

the total savings achieved by the ICC scheme is

March 2, 2016

N(cid:48) − (cid:96)ICC(DK) = N(cid:48) − (N(cid:48) − K + 1) = K − 1.

(8)

DRAFT

DRAFT

14

For any digraph D containing ψ disjoint IC structures, a savings of Ki − 1 is obtained in each
DKi (from (8)), where i ∈ {1, . . . , ψ}. Now the summation of savings in all disjoint IC structures

provides the total savings, i.e.,(cid:80)ψ

(cid:80)ψ
i=1(Ki − 1).

i=1(Ki − 1). Hence, (cid:96)ICC(D) = N −

Remark 4 (Complexity issue): IC structures found by the ICC scheme are not unique. So,
finding the best (cid:96)ICC(D) involves optimizing over all choices of disjoint IC structures in D,
and this may require high time complexity. Such complexity can be reduced to some extent in
the following way: We partition the digraph into sub-digraphs taking critical arcs3 [17]–[19]
into account, and then search for IC structures in each of the sub-digraphs. We do not consider
algorithm design in this work.

A. The ICC scheme includes the cycle-cover and the clique-cover schemes as special cases

Theorem 2: The ICC scheme includes the cycle-cover and the clique-cover schemes as special

cases.

Proof: The proof is divided into two parts. In the first part, we prove that the clique-cover
scheme is a special case of the ICC scheme, and in the second part, we prove that the cycle-cover
scheme is a special case of the ICC scheme.

(Part 1) Consider a clique with N ≥ 1 vertices, and without loss of generality, assume that
the vertices are 1, 2, . . . , N. We choose VI = {1, 2, . . . , N} to be an inner vertex set. As there is
exactly one I-path between every ordered pair of vertices, and no I-cycles (indeed no non-inner
vertices at all). The clique is a N-IC structure. Now for the clique, (i) the clique-cover scheme
constructs an index code {x1 ⊕ ··· ⊕ xN} of length one, and (ii) the ICC scheme constructs an
index code {wI = x1 ⊕ ··· ⊕ xN} of length one. The index codes from both of the schemes are
the same. In fact, for any digraph, if we consider the ICC scheme exploiting only N-IC structures
with |VI| = N, i.e., disjoint cliques in digraphs, then this is simply the clique-cover scheme.

(Part 2) Consider a cycle with N ≥ 2 number of vertices, and without loss of generality,
assume that the vertices are 1, 2, . . . , N. Consider VI = {i, j} for any i, j ∈ {1, 2, . . . , N} and
i (cid:54)= j. Vertex i has only one I-path to j and vice versa, and there is no I-cycle. Thus a cycle is a
2-IC structure. Now we choose i = N − 1 and j = N, so VI = {N − 1, N}. For the cycle, (i) the

3An arc in a digraph is said to be critical if the removal of that arc from the digraph strictly increases the optimal broadcast

rate.

March 2, 2016

DRAFT

DRAFT

15

cycle-cover scheme constructs an index code {x1⊕x2, x2 ⊕ x3, . . . , xN−1⊕xN} of length N −1,
and (ii) the ICC scheme constructs an index code {wI, wj : 1 ≤ j ≤ N − 2} of length N − 1,
where wI = xN−1 ⊕ xN and {wj : 1 ≤ j ≤ N − 2} = {x1 ⊕ x2, x2 ⊕ x3, . . . , xN−2 ⊕ xN−1}. The
index codes from both of the schemes are the same. In fact, for any digraph, if we consider the
ICC scheme exploiting only 2-IC structures, i.e., disjoint cycles in digraphs, then this is simply
the cycle-cover scheme.

Corollary 1: The optimal broadcast rate of an index-coding instance, with t-bit messages for
any t ≥ 1, is upper bounded by the index codelength obtained from the ICC scheme, and this
upper bound is at least as tight as the cycle-covering number and the clique-covering number,
i.e.,

β(D) ≤ βt(D) ≤ (cid:96)ICC(D) ≤ min{(cid:96)CL(D), (cid:96)CY(D)}, ∀t.

(9)

Proof: From Theorem 2, the cycle-cover and the clique-cover schemes are special cases of the
ICC scheme, thus (cid:96)ICC(D) ≤ min{(cid:96)CL(D), (cid:96)CY(D)}. From Theorem 1, we have βt(D) ≤ (cid:96)ICC(D),
and from the definition of β(D), we have β(D) ≤ βt(D). Therefore, β(D) ≤ βt(D) ≤ (cid:96)ICC(D) ≤
min{(cid:96)CL(D), (cid:96)CY(D)}. These three schemes are valid for one-bit messages. By concatenating the
index codes, we get (9) for any number of bits.

Remark 5: (cid:96)CL(D) and (cid:96)CY(D) are lower bounded by both (cid:96)ICC(D) (from Corollary 1) and
(cid:96)PC(D) (from (3)). A difference between these two bounds is that the (cid:96)ICC(D) bound is valid for
all t, whereas the (cid:96)PC(D) bound is valid only for sufficiently large t.

B. The ICC scheme is optimal for a class of digraphs

Theorem 3: For messages of any t ≥ 1 bits, if a K-IC structure DK has
• (Case 1) no cycle among the non-inner vertices, or
• (Case 2) M ≥ 1 disjoint cycles among non-inner vertices, and we can group the inner-vertex
set VI into M + 1 subsets such that each of them forms a disjoint IC structure of case 1,
and all of the IC structures are also disjoint from the M cycles among non-inner vertices,
the scalar linear index code given by the ICC scheme is optimal, i.e., (cid:96)ICC(DK) = β(DK) =
βt(DK).

Proof: Refer to Appendix B.

Proposition 5: For messages of any t ≥ 1 bits and all K-IC structures with K ∈ {1, 2, 3}, the
scalar linear index code given by the ICC scheme is optimal, i.e., (cid:96)ICC(DK) = β(DK) = βt(DK).

March 2, 2016

DRAFT

DRAFT

16

Proof: Refer to Appendix C.

For all K-IC structures that we have constructed (including K-IC structures not satisfying
Theorem 3), the scalar linear index code given by the ICC scheme is optimal. We conjecture that
this holds in general.

Conjecture 1: For messages of any t ≥ 1 bits and any K-IC structure DK, the scalar linear

index code given by the ICC scheme is optimal, i.e., (cid:96)ICC(DK) = β(DK) = βt(DK).

VII. COMPARISON WITH EXISTING SCHEMES

In this section, for a class of digraphs (to be defined shortly), we compare the ICC scheme
to the partial-clique-cover scheme, and prove that (cid:96)ICC(D) ≤ (cid:96)PC(D). We conjecture that
(cid:96)ICC(D) ≤ (cid:96)PC(D) is valid in general. Furthermore, we present a family of digraphs where
the additive gap (on the index codelength) between these two schemes grows linearly with
the total number of the vertices in the digraph. Secondly, we show all of the above for the
fractional-local-chromatic-number scheme instead of the partial-clique-cover scheme. Finally,
with the help of some examples, we show that the ICC scheme can outperform all of the existing
graph-based schemes and the composite-coding scheme.

A. The ICC scheme vs. the partial-clique-cover scheme

Considering a digraph D(cid:48) as a κ(D(cid:48))-partial clique, we re-express D(cid:48) in terms of savings in

the following proposition.

Proposition 6: For a κ(D(cid:48))-partial clique, the partial-clique-cover scheme provides savings

equal to the minimum out-degree of D(cid:48), i.e., S(D(cid:48)) = δ+(D(cid:48)).

Proof: Let the total number of vertices in D(cid:48) be n. From the definition of partial cliques,

i.e., Definition 11, we have

δ+(D(cid:48)) = n − (κ(D(cid:48)) + 1) = n − (cid:96)PC(D(cid:48)) = S(D(cid:48)).

(10)

Some partial cliques can be further partitioned into smaller partial cliques such that the sum
of the partial-clique numbers of its partitioned partial cliques equals that of the original partial
clique. This can cause ambiguity while considering partial cliques during our proofs, so we
define the notion of minimal partial clique as follows:

March 2, 2016

DRAFT

DRAFT

17

Definition 17 (Minimal partial clique): A partial clique D(cid:48) is a minimal partial clique if the
savings obtained from D(cid:48) (i.e., δ+(D(cid:48)) from (10)) is always greater than the sum of the savings
in each further partitioned sub-digraphs of D(cid:48) (over all partitions in D(cid:48)), i.e.,

δ+(D(cid:48)) >

max

D(cid:48)1,D(cid:48)2,...,D(cid:48)m{δ+(D(cid:48)1) + δ+(D(cid:48)2), . . . + δ+(D(cid:48)m)},

where m is some integer greater than one, and the maximum is over all partitions D(cid:48)1, D(cid:48)2, . . . , D(cid:48)m
of the minimal partial clique D(cid:48).

Theorem 4: For a class of digraphs, where each digraph D
• gets partitioned into minimal partial cliques (by the partial-clique-cover scheme to ob-
tain the partial-clique number) such that each minimal partial clique D(cid:48) has δ+(D(cid:48)) ∈
{0, 1, 2,|V (D(cid:48))| − 1},

the ICC scheme performs at least as well as the partial-clique-cover scheme, i.e., (cid:96)ICC(D) ≤
(cid:96)PC(D).

Proof: Refer to Appendix D for the proof.

For all digraphs that we have analyzed (including digraphs not considered in Theorem 4), we
have observed (cid:96)ICC(D) ≤ (cid:96)PC(D). For an example, the digraph in Fig. 13b has (cid:96)ICC(D) = (cid:96)PC(D),
and the digraphs in Fig. 1a and Fig. 13a have (cid:96)ICC(D) strictly less than (cid:96)PC(D). We conjecture
that this holds in general.

Conjecture 2: For any digraph D, the ICC scheme performs at least as well as the partial-

clique-cover scheme, i.e., (cid:96)ICC(D) ≤ (cid:96)PC(D).

1) Additive Gap between the ICC scheme and the partial-clique-cover scheme: For an even
2 vertices. Now we define a class of digraphs,

integer K ≥ 2, consider a digraph D with N = 3K
we call Class A, as follows: For each i ∈ {1, 2, . . . , K
2 },
(i) vertex K + i has out-degree d+

D(K + i) = 2, and its out-going arcs go to vertices 2i − 1

and 2i, and

D(2i − 1) = d+

D(2i) = K

(ii) vertices 2i − 1 and 2i have d+

2 in such a way that there are arcs in
both directions between 2i − 1 and 2i, and each of the remaining K
2 − 1 out-going arcs of
2i − 1 and 2i goes to each vertex in {K + 1, K + 2, . . . , 3K/2} \ {K + i} (this vertex set
has K

2 − 1 number of vertices in total).

Without loss of generality, a Class A digraph D is shown in Fig. 4.

Proposition 7: For any digraph D of Class A, we have (cid:96)PC(D) − (cid:96)ICC(D) = N

3 − 1.

March 2, 2016

DRAFT

DRAFT

18

Fig. 4. A digraph belonging to the Class A.

Proof: In a digraph D of the Class A (shown in Fig. 4), minimal partial cliques with
vertex sets {1, 2},{3, 4}, . . . ,{K − 1, K},{K + 1},{K + 2}, . . . ,{N} provides (cid:96)PC(D) = K
(from Proposition 8 in Appendix E). The digraph D is also an IC structure with the inner-vertex
2 + 1 (from Proposition 8 in Appendix E). Thus
set VI = {1, 2, . . . , K} providing (cid:96)ICC(D) = K
(cid:96)PC(D) − (cid:96)ICC(D) = K

2 − 1 = N

3 − 1.

B. The ICC scheme vs. the fractional-local-chromatic-number scheme

Theorem 5: Consider a K-IC structure D. If
1) the minimum out-degree of D, δ+(D) ≤ K − 1, and
2) D has no bi-directional arcs,

then the ICC scheme performs at least as well as the fractional-local-chromatic-number scheme,
i.e., (cid:96)ICC(D) ≤ (cid:96)FLCN(D).

Before presenting the proof, we start with the definition of the local chromatic number, and a

necessary lemma.

Definition 18 (Local chromatic number [13]): The local chromatic number χ(cid:96)(D) of a di-

graph D is

χ(cid:96)(D) := min
c

max

i∈V (D)|{c(u) : u ∈ N +

D (i)}| + 1,

where the minimum is taken over all proper colorings c of D, and c(u) is the color of vertex u
according to the coloring c.
We first prove the following lemma before proving the theorem.

March 2, 2016

DRAFT

K+1N1,2K−1,Ki,jijHere,3,4K+2i,j∈{1,2,...,K}andi6=jDRAFT

19

Lemma 1: For a digraph D with no bi-directional arcs, the local chromatic number of its
complement, i.e., ¯D, is equal to the difference between the total number of vertices (which is
N) and the minimum out-degree of the digraph D, i.e., χ(cid:96)( ¯D) = N − δ+(D).

Proof: Here the underlying undirected graph of ¯D is a complete graph, so any proper
coloring in ¯D yields every vertex with a unique color. Thus the most colorful out-neighborhood
belongs to the vertex with the maximum out-degree. For a vertex v in D (v is also in ¯D), we
have

χ(cid:96)( ¯D) = max

v

d+
¯D(v) + 1.

(11)

We know that the out-degree of a vertex v in D and ¯D is related by the following equation:

d+
¯D(v) = N − 1 − d+

D(v).

(12)

From (12), if the vertex v has the minimum out-degree in D, then it has the maximum out-degree
in ¯D and vice versa, so

max

v

d+
¯D(v) = N − 1 − min

v

d+
D(v) = N − 1 − δ+(D).

From (11) and (13), we get

χ(cid:96)( ¯D) = N − δ+(D).

(13)

(14)

Proof of Theorem 5: The length of the index code from the local chromatic number is

(cid:96)LCN(D) = χ(cid:96)( ¯D) [13]. Since D has no bi-directional arc, thus from Lemma 1,

(cid:96)LCN(D) = χ(cid:96)( ¯D) = N − δ+(D).

(15)

Here the underlying undirected graph of ¯D, i.e., U ¯D is a complete graph, so the fractional
local chromatic number (χf ( ¯D)) and the local chromatic number (χ(cid:96)( ¯D)) is the same, i.e.,
χf ( ¯D) = χ(cid:96)( ¯D). Hence,

(cid:96)LCN(D) = (cid:96)FLCN(D) = N − δ+(D).

(16)

Now considering (7) and (16), we get (cid:96)ICC(D) ≤ (cid:96)FLCN(D) since K − 1 ≥ δ+(D).

As an example, we construct a class of digraphs satisfying Theorem 5.
Example 4: Consider a class of digraphs where each digraph D has an even number of
2 . Furthermore, vertices in D can be grouped into two sets (without

vertices N, and let K = N

March 2, 2016

DRAFT

DRAFT

20

(a)

(b)

Fig. 5.

(a) A 3-IC structure with VI = {1, 2, 3}, and (b) a 4-IC structure with VI = {1, 2, 3, 4}.

loss of generality, let them be {1, 2, . . . , K} and {K + 1, K + 2, . . . , N}) such that for each
i = {1, 2, . . . , K}, vertex K + i has an arc to vertex i, and vertex i has arcs to all {K + 1, K +
2, . . . , N} \ {K + i}. For the digraph D, δ+(D) = 1, and it has no bidirectional arcs. So,
(cid:96)FLCN(D) = N − δ+(D) = N − 1. As D is also a K-IC structure with VI = {1, 2, . . . , K}, we
2 , and the gap
get (cid:96)ICC(D) = N − K + 1 = N
grows linearly with N. Fig. 5a depicts an example digraph belonging to this class with K = 3.

2 + 1. The additive gap, (cid:96)FLCN(D) − (cid:96)ICC(D) = N−4

C. The ICC scheme can outperform existing schemes including the composite-coding scheme

As an example, we present two IC structures satisfying the cases of Theorem 3. The digraphs
(which are IC structures) are shown in Fig. 5a and Fig. 5b. For these digraphs, the optimal
broadcast rate is achieved by the ICC scheme (from Theorem 3), but existing schemes might not
achieve it.

The digraph shown in Fig. 5a is a 3-IC structure, and it is denoted D3. An index code from
the ICC scheme is {x4 ⊕ x1, x5 ⊕ x2, x6 ⊕ x3, x1 ⊕ x2 ⊕ x3}, which is of length (cid:96)ICC(D3) = 4.
From Theorem 3, (cid:96)ICC(D3) = β(D3) = βt(D3) = 4. For D3, the index codelength by existing
schemes are shown in Table II.

The index codelength provided by the aforementioned existing schemes are strictly greater
than (cid:96)ICC(D3) except the composite-coding scheme. There exist digraphs where the ICC scheme
outperforms the composite-coding scheme. For an example, the digraph shown in Fig. 5b is a
4-IC structure, and it is denoted D4. An index code from the ICC scheme is {x1 ⊕ x2 ⊕ x3 ⊕ x4,
x5 ⊕ x2 ⊕ x3, x6 ⊕ x3 ⊕ x4}, which is of length (cid:96)ICC(D4) = 3. From Theorem 3, (cid:96)ICC(D4) =
β(D4) = βt(D4) = 3. For D4, the index codelength provided by the composite-coding scheme is
3.5, which is greater than (cid:96)ICC(D4).

March 2, 2016

DRAFT

123654123456DRAFT

21

INDEX CODELENGTHS FOR THE DIGRAPH D3 IN FIG. 5A FROM EXISTING SCHEMES

TABLE II

Schemes

Clique cover [1]

Fractional-clique cover [6]

Cycle cover [15], [16]

Fractional-cycle cover [15]

Partial-clique cover [1]

Fractional-partial-clique cover [12]

Local chromatic number [13]

Fractional-partitioned local chromatic number [14]

Composite coding [8]

VIII. EXTENSIONS

Index codelength

6
6
5
4.5
5
4.5
5
4.5
4

In this section, firstly, we extend the ICC scheme using time-sharing to code over overlapping
IC structures in a digraph, and to obtain vector linear index codes. Secondly, we extend the
definition of the IC structure in such a way that we can extend the ICC scheme to code on
extended IC structures.

A. Fractional ICC scheme

Let Ds = (V (Ds),{(i, j) ∈ A(D) : i, j ∈ V (Ds)}) denote a sub-digraph induced by a subset

s of the vertices in D = (V (D), A(D)). We define a function

φ(Ds) =

if Ds is a Ks-IC structure,

otherwise.

|V (Ds)|,

 |V (Ds)| − Ks + 1,
minimize(cid:88)
subject to (cid:88)

fs · φ(Ds)

s∈S

s∈S:j∈V (Ds)

fs ∈ [0, 1], s ∈ S.

The index codelength4 from the fractional ICC scheme is represented as (cid:96)FICC(D), and given

by the following linear program:

fs ≥ 1,

for each j ∈ V (D),

(17)

4See the work by Blasiak et al. [6] for the derivation of (timeshared) index codes using the fractional version of a scheme.

March 2, 2016

DRAFT

DRAFT

22

(a)

(b)

Fig. 6.
(a) The digraph with three cliques each of order two, and all vertices of a clique have out-going arcs to all vertices
of another clique such that the three cliques are connected in a cyclic pattern as shown (from the ICC scheme, the digraph
has an index code {x1 ⊕ x2 ⊕ x3 ⊕ x4, x5 ⊕ x1 ⊕ x2, x6} of length (cid:96)ICC(D) = 3), and (b) the same digraph, but with a
super-vertex notation (the super-vertex, denoted by vs, is formed by vertices 5 and 6, and the digraph has an index code
{x1 ⊕ x2 ⊕ x3 ⊕ x4, x5 ⊕ x6 ⊕ x1 ⊕ x2} of length two).

Here S is the power set of V (D). In the fractional ICC scheme, each sub-digraph induced by
the subset s in S is assigned a weight [0, 1] such that the total weight of each message over all
of the subsets it belongs to is at least one. In this scheme, (cid:96)FICC(D) is the minimum sum of
weights. The ICC scheme is a special case of the fractional ICC scheme where fs ∈ {0, 1}, so
β(D) ≤ (cid:96)FICC(D) ≤ (cid:96)ICC(D).

B. Extension of the IC structure

We start with an example that provides an insight to the extension of the IC structure. Consider a
digraph D that has three cliques ρ1, ρ2 and ρ3 each of size two. Let V (ρ1) = {1, 2}, V (ρ2) = {3, 4}
and V (ρ3) = {5, 6} be vertex sets of those three cliques respectively. Furthermore, for the clique
pair (ρ1, ρ2), all vertices in V (ρ1) have out-going arcs to all vertices in V (ρ2), and the result
follows similarly for clique pairs (ρ2, ρ3) and (ρ3, ρ1). This digraph is depicted in Fig. 6a. One
can verify that D is a 4-IC structure with an inner vertex set VI = {1, 2, 3, 4}. We cannot get a
5-IC structure in D. Suppose that we pick VI = {1, 2, 3, 4, 5}, there is no path from vertices 1
and 2 to vertex 5 without passing through the inner vertex 3 or 4. By symmetry, choosing any 5
vertices as an inner vertex set will have the same issue.

Now the ICC scheme gives an index code {x1 ⊕ x2 ⊕ x3 ⊕ x4, x5 ⊕ x1 ⊕ x2, x6} of length
(cid:96)ICC(D) = 3. However, from the coding point of view of an IC structure, vertices 5 and 6 need not
be separated during encoding because they have the same arc sets N +
D (6)\{5} and
N−D (5) \ {6} = N−D (6) \ {5}, and have arcs to each other. This means we can get another index

D (5)\{6} = N +

March 2, 2016

DRAFT

1234561234vsDRAFT

23

code by removing x6, and replacing x5 with x5 ⊕ x6, i.e., {x1 ⊕ x2 ⊕ x3 ⊕ x4, x5 ⊕ x6 ⊕ x1 ⊕ x2}
of length two. Here due to the special connectivity of clique {5, 6}, we have treated it as a
single vertex, and used x5 ⊕ x6 in the code construction. In light of this, we will now extend the
definition of an IC structure to capture cliques with such special configurations. To achieve this
we define a term called a super-vertex.

Definition 19 (Super-vertex): In a digraph D, let Vs be a vertex set where (i) all vertices in
Vs have arcs to each other, i.e., they form a clique, and (ii) every vertex i ∈ Vs has the same
D (i)\ Vs and the same N−D (i)\ Vs. Such a group of vertices (all i ∈ Vs) is called a super-vertex
N +
and denoted as vs.

Now we define extended IC structures and an index-coding scheme for them.
Definition 20 (Extended IC structure): The extended IC (EIC) structure is defined as an IC

structure that allows super-vertices in its non-inner vertex set.

Definition 21 (Extended ICC scheme): For any digraph D, the extended ICC (EICC) scheme
finds a set of disjoint EIC structures covering D. It then codes each of these EIC structures using
the code construction described in the following:

• Each super-vertex (non-inner vertices) is treated as a single vertex during the construction

and the encoding process of the EIC structure.

• We consider the message requested by the super-vertex to be the XOR of all messages

requested by the vertices forming the super-vertex.

• Each of these EIC structures are treated as an IC structure, and an index code is constructed

using the ICC scheme.

Along with super-vertices, and taking their definition into account, one can prove the validity
of the code constructed by the EICC scheme similar to the proof of Proposition 4. Denote the
length of the index code produced by the EICC scheme by (cid:96)EICC(D).

Theorem 6: For a digraph D, the index codelength obtained from the EICC scheme is a better
upper bound to the optimal broadcast rate than the codelength obtained from the ICC scheme,
i.e., β(D) ≤ βt(D) ≤ (cid:96)EICC(D) ≤ (cid:96)ICC(D).

Proof: It follows from the definition of EIC structures that include IC structures as special

cases.

March 2, 2016

DRAFT

DRAFT

24

IX. CONCLUSION

Graph-based approaches have been shown to be useful for index coding, in which cycles
play an important role. Prior to this work, disjoint cycles and disjoint cliques (including the
timeshared version) were used to construct index codes. In this work, we attempted to extend
the role of cycles on index coding. We took a step further and showed the benefits of coding on
interlinked-cycle structures (one form of overlapping cycles). Our proposed scheme generalizes
coding on disjoint cycles and disjoint cliques. By identifying a useful interlinked-cycle structure,
we were able to characterize a class of infinitely many graphs where scalar linear index codes are
optimal. For some classes of digraphs, we proved that the ICC scheme performs at least as well as
some existing schemes such as the partial-clique-cover scheme and the fractional-local-chromatic-
number scheme. Furthermore, for a class of digraphs, we proved that the partial-clique-cover
scheme and the ICC scheme have linearly-growing additive gap in index codelength with the
number of vertices in the digraphs. We proved a similar result for the fractional-local-chromatic-
number scheme and the ICC scheme for another class of digraphs. We extended the ICC scheme,
to allow time-sharing over all possible IC structures in digraphs. We also extended the IC structure
to allow super vertices as its non-inner vertices. However, it remains an open problem to identify
cycles overlapping in other useful ways.

APPENDIX A

PROOF OF PROPOSITION 4

A K-IC structure DK has some properties captured in the following lemmas, which will be
used to prove Proposition 4. Here we consider Ti and Tj as any two distinct directed rooted trees
present in DK with the root vertices i and j respectively.

Lemma 2: For any vertex v ∈ V (Ti) ∩ V (Tj), and v /∈ VI, the set of leaf vertices that fan out

from the common vertex v in each tree is a subset of VI \ {i, j}.

Proof: In a tree Ti (see Fig. 7), for any vertex v ∈ V (Ti) and v /∈ VI, let LTi(v) be a set of
leaf vertices that fan out from vertex v. If vertex j ∈ LTi(v), then there exists a path from v to
j in Ti. However, in Tj, there is a path from j to v. Thus in the sub-digraph5 DK, we obtain
a path from v to j (via Ti) and vice versa (via Tj). As a result, a cycle including non-inner

5As DK =(cid:83)

Ti, a path present in any Ti also present in DK.

∀i∈VI

March 2, 2016

DRAFT

DRAFT

25

Fig. 7. Outline of the directed rooted trees Ti and Tj with root vertices i and j respectively, and a non inner vertex v in
common. Here we have used solid arrow to indicate an arc, and dashed arrow to indicate a path.

vertices and only one inner vertex (i.e., j) exists. This cycle is an I-cycle, and condition 1 (i.e.,
no I-cycle) for DK is violated. Hence, j /∈ LTi(v). In other words, LTi(v) ⊆ VI \{i, j}. Similarly,
LTj (v) ⊆ VI \ {i, j}.

Lemma 3: For any vertex v ∈ V (Ti) ∩ V (Tj), and v /∈ VI, the out-neighborhood of vertex v

is same in both trees, i.e., N +

Ti(v) = N +

Tj (v).

Proof: Here the proof is done by contradiction. Let us suppose that N +

Ti(v) (cid:54)= N +

Tj (v).

For this proof we refer to Fig. 7. This proof has two parts. In the first part, we prove that

LTi(v) = LTj (v), and then prove that N +

Ti(v) = N +

Tj (v) in the second part.

(Part 1) Suppose that LTi(v) (cid:54)= LTj (v). From Lemma 2, LTi(v) is a subset of VI \ {i, j}. Now
pick a vertex c that belongs to VI \ {i, j} such that c ∈ LTi(v) but c /∈ LTj (v) (such c exists
since we suppose that LTi(v) (cid:54)= LTj (v), and we swap the indices i and j if LTi(v) ⊂ LTj (v)). In
tree Ti, there exists a directed path from vertex i, which includes v to the leaf vertex c. Let this
path be Pi→c(Ti). Similarly, in tree Tj, there exists a directed path from vertex j, which doesn’t
include v (since c /∈ LTj (v)), and ends at the leaf vertex c. Let this path be Pj→c(Tj). In the
digraph DK, we can also obtain a directed path from j which passes through v (via Tj), and
ends at the leaf vertex c (via Ti). Let this path be Pj→c(DK). The paths Pj→c(Tj) and Pj→c(DK)
are different, which indicates the existence of multiple I-paths from j to c in DK, this violates
the condition 2 for DK. Consequently, LTi(v) = LTj (v).

March 2, 2016

DRAFT

ivN+Ti(v)LTi(v)⊆VI\{i,j}VI\{i}TiPathArcbdcjvN+Tj(v)LTj(v)⊆VI\{i,j}VI\{j}TjPathArcedcVI\{i,j}DRAFT

26

Ti(v) (cid:54)= N +

Ti(v) but b /∈ N +

(Part 2) Now we pick a vertex b such that, without loss of generality, b ∈ N +

Tj (v)
(such b exists since we assumed that N +
Tj (v), and we swap the indices i and j if
Tj (v)). Furthermore, we have two cases for b, which are (case 1) b ∈ LTi(v), and
N +
Ti(v) ⊂ N +
(case 2) b /∈ LTi(v). Case 1 is addressed in the first part of this proof. On the other hand, for case
2, we pick a leaf vertex d ∈ LTi(b) such that there exists a path (see Fig. 7) that starts from v
followed by b, and ends at d, i.e., (cid:104)v, b, . . . , d(cid:105) exists in Ti. A path (cid:104)j, . . . , v(cid:105) exists in Tj. Thus a
path (cid:104)j, . . . , v, b, . . . , d(cid:105) exists in DK. From the first part of the proof, we have LTi(v) = LTj (v),
so d ∈ LTj (v). Now in Tj, there exists a path from j to d, which includes v followed by a vertex
e such that e ∈ N +
Tj (v)), and the path ends at d, i.e., (cid:104)j, . . . , v, e, . . . , d(cid:105)
which is different from (cid:104)j, . . . , v, b, . . . , d(cid:105). Note that in trees Ti and Tj, only the root and the
leaf vertices are from VI, so multiple I-paths are observed at d from j. This violates condition 2
for DK. Consequently, N +

Tj (v) and e (cid:54)= b (as b /∈ N +

Ti(v) = N +

Tj (v).

Lemma 4: If a vertex v ∈ V (Ti) such that v /∈ VI, then its out-neighborhood is the same in Ti

and in DK, i.e., N +

Ti(v) = N +
DK

(v).

DK =(cid:83)

∀i∈VI

Proof: For any v ∈ V (Ti) from Lemma 3, N +

Ti(v) = N +

Tj (v) for all {j : v ∈ Tj}. Since

Ti, vertex v must have the same out-neighborhood in DK as well.

Proof of Proposition 4: From (6), all j ∈ {K + 1, K + 2, . . . , N} which are non-inner
vertices, can decode their requested messages. This is because the coded symbol wj is the bitwise
XOR of the messages requested by j and its all out-neighborhood vertices, and any j knows
messages requested by all of its out-neighborhood vertices as side information.

For an inner vertex i, rather than analyzing the sub-digraph DK, we will analyze its tree Ti,
and show that it can decode its message from the relevant symbols in W . We are able to consider
only the tree Ti due to the Lemma 4. Now let us take any tree Ti. Assume that it has a height
H where 1 ≤ H ≤ (N − K + 1). The vertices in Ti are at various depths, i.e., {0, 1, 2, . . . , H}
from the root vertex i. The root vertex i has depth zero, and any vertex at depth equal to the
height of the tree is a leaf vertex.

at depth greater than zero, i.e., Zi (cid:44) (cid:76)

Firstly, in Ti, we compute the bitwise XOR among coded symbols of all non-leaf vertices
wj. However, in Ti, the message requested
by a non-leaf vertex, say p, at a depth strictly greater than one, appears exactly twice in
{wj : j ∈ V (Ti) \ VI};

j∈V (Ti)\VI

i) once in wk, where k is parent of p in tree Ti, and

March 2, 2016

DRAFT

DRAFT

27

ii) once in wp. Refer to (20) for mathematical details.

Thus they cancel out each other while computing Zi in the tree Ti. Hence, in the tree Ti, the
resultant expression is the bitwise XOR of

i) messages requested by all non-leaf vertices at depth one, and
ii) messages requested by all leaf vertices at depth strictly greater than one.

Refer to (21) for mathematical details.

Secondly, in Ti, we compute wI ⊕ Zi (refer to (22) for mathematical details) which yields the

bitwise XOR of

i) the messages requested by all non-leaf vertices at depth one, which are out-neighbors of i,
ii) the messages requested by all leaf vertices at depth one, which are also out-neighbors of i,

and

iii) the message requested by i, i.e., xi.

This is because the message requested by each leaf vertex at depth strictly greater than one in
the tree Ti is present in both the resultant terms of Zi and in wI, thereby canceling out itself in
wI ⊕ Zi. Hence, wI ⊕ Zi yields the bitwise XOR of xi and {xj : j ∈ N +
(i)}. As i knows all
(i)} as side-information, any inner vertex i can decode its required message from
{xj : j ∈ N +
wI ⊕ Zi.

DK

DK

The mathematical computations of Zi and wI ⊕ Zi in the tree Ti are as follows:
1) Computing Zi:

(cid:77)
(cid:77)
(cid:77)

j∈V (Ti)\VI

j∈V (Ti)\VI

Zi =

=

=

wj

xj ⊕
xj ⊕

(cid:77)
(cid:77)

q∈N +
DK

(j)

 =

xq

xq ⊕

(cid:77)
(cid:77)

j∈V (Ti)\VI



xq

(cid:77)

q∈N +
Ti

(j)

xj ⊕


xq

j∈V (Ti)\VI

q∈N +
Ti

(j)\VI

q∈N +
Ti

(j)∩VI

= XV (Ti) ⊕ X(cid:48)V (Ti).

Where,

March 2, 2016

(18)

DRAFT

DRAFT

XV (Ti) (cid:44) (cid:76)
(cid:44) (cid:77)

X(cid:48)V (Ti)

j∈V (Ti)\VI

xj ⊕
 (cid:77)

(cid:76)

xq

, and
 =
(cid:77)

xq

q∈N +
Ti

(j)\VI

j∈V (Ti)\VI

q∈N +
Ti

(j)∩VI

q:q∈VI\{i}
& q /∈N +
(i)
Ti

28

(19)

xq.

Here (19) is obtained because each q ∈ VI \ {i} has only one parent in Ti, and we exclude all
q ∈ VI \ {i} whose parent is i, and X(cid:48)V (Ti) is bitwise XOR of messages requested by all of the
leaf vertices not in the out-neighborhood of i. If we expand XV (Ti) as per the group of vertices
according to their depth, we get


xj1 ⊕
(cid:77)

xjH−2⊕
(cid:77)

(i)\VI

j1∈N +
Ti

xq

⊕
(cid:77)

(cid:77)
⊕

(j1)\VI

xq

q∈N +
Ti

j2∈N +
Ti

q∈N +
Ti

(jH−2)\VI

jH−1 ∈
N +
(jH−2)\VI
Ti

(cid:77)


xj2⊕

xjH−1 ⊕

(j1)\VI

q∈N +
Ti

(cid:124)

(cid:77)

q∈N +
Ti

(j2)\VI

(cid:77)
(cid:123)(cid:122)

xq

(cid:125)

(jH−1)\VI
=∅

xq

⊕ . . .⊕


. . .



=

xj.

(20)

XV (Ti) =

(cid:77)
(cid:77)

jH−2 ∈
N +
(jH−3)\VI
Ti

j∈N +
Ti

(i)\VI

Note that the intermediate terms in XV (Ti) cancel out (we have used the same color to indicate
the terms that cancel out each other). Now substituting XV (Ti) of (20) and X(cid:48)V (Ti) of (19) in (18),
we get

(cid:77)

Zi =

xk ⊕

k∈N +
Ti

(i)\VI

 (cid:77)

q:q∈VI\{i}
& q /∈N +
(i)
Ti

 .

xq

(21)

March 2, 2016

DRAFT

DRAFT

2) Computing wI ⊕ Zi:

wI ⊕ Zi = wI ⊕ XV (Ti) ⊕ X(cid:48)V (Ti) = xi ⊕
(cid:77)

 (cid:77)
 (cid:77)

= xi ⊕

= xi ⊕

j:j∈VI\{i}
& j∈N +
(i)
Ti

j:j∈VI\{i}
& j /∈N +
(i)
Ti

xj ⊕

xj ⊕

(cid:77)

j:j∈VI\{i}
& j∈N +
(i)
Ti

k∈N +
Ti

(i)\VI

xj ⊕

j∈VI\{i}

xk⊕

(i)\VI

(cid:77)

k∈N +
Ti

(cid:77)

xk ⊕

k∈N +
Ti

(i)\VI

(cid:77)
 ⊕
 .

xk

xj

xq

(cid:77)
 (cid:77)

q:q∈VI\{i}
& q /∈N +
(i)
Ti

q:q∈VI\{i}
& q /∈N +
(i)
Ti



xq

29

(22)

APPENDIX B

PROOF OF THEOREM 3

We first prove one lemma that will help to prove the optimality of the ICC scheme.
Lemma 5: In an IC structure, any cycle must contain either (i) no inner vertex, or (ii) at least

two inner vertices.

Proof: It follows directly from the property of an IC structure that a cycle cannot be formed

by including only one inner vertex because this type of cycle is an I-cycle.

Proof of Theorem 3: We will show that the MAIS lower bound (1) is tight for all t. We
denote the digraph which is also an IC structure by DK, and consider that it has N vertices.
For K = 1, the digraph contains only one vertex, and MAIS(D1) = 1. For K ≥ 2, we have the
following:

(Case 1) From Lemma 5, any cycle must include at least two inner vertices, or no inner vertex,

thus if we remove K − 1 inner vertices, then the digraph DK becomes acyclic. Thus

From Theorem 1, we get

MAIS(DK) ≥ N − K + 1.

(cid:96)ICC(DK) = N − K + 1.

(23)

(24)

It follows from (1), (23) and (24) that MAIS(DK) = N − K + 1 = (cid:96)ICC(DK). Thus (cid:96)ICC(DK) =
β(DK) = βt(DK) = N − K + 1.

March 2, 2016

DRAFT

DRAFT

30

(Case 2) A DK can be viewed in two ways. The first way is considering the whole DK as a

K-IC structure. The second way is considering induced sub-digraphs of DK which consist of
a) M disjoint cycles together consisting of a total of NA (0 ≤ NA < N − K) non-inner

vertices (if NA = 0 or 1, then M = 0, which is case 1),

b) M + 1 disjoint IC structures each with Ni vertices and Ki inner vertices in such a way
i=1 Ki = K, we consider that each IC structure is also disjoint from all M cycles

that(cid:80)M +1

among non-inner vertices, and

c) total remaining of NB = N − NA −

in M cycles, or the M + 1 IC structures).

(cid:80)M +1

i=1 Ni non-inner vertices (which are not included

Now we will show that both ways of looking at DK are equivalent in the sense of the index
codelength generated from our proposed scheme, and both equal to MAIS(DK). We prefer the
second way of viewing DK for our proof since it is easier to find the MAIS lower bound.

For the partitioned DK (looking at in the second way), the total number of coded symbols is
the summation of the coded symbols for (i) each of the M disjoint cycles (each cycle has saving
equal to one), (ii) each of the M + 1 disjoint IC structures (each of the IC structures has savings
equal to K − 1), and (iii) NB uncoded symbols for the remaining non-inner vertices, i.e.,

M +1(cid:88)

i=1

(Ni − Ki + 1) + NB

(cid:96)(cid:48)
ICC(DK) = (NA − M ) +

= N − K + 1.

(25)

From (24) and (25), (cid:96)ICC(DK) = (cid:96)(cid:48)
same.

ICC(DK), thus from both perspectives the code length is the

the M + 1 IC structures ((cid:80)M +1

Now for DK (looking at in our second way), if we remove one vertex from each of the M
cycles among non-inner vertices (M removal in total), and remove Ki − 1 vertices from each of
i=1 (Ki − 1) = K − M − 1), i.e., total removal of K − 1, then the

digraph becomes acyclic. Thus

MAIS(DK) ≥ (N − K + 1).

(26)

It follows from (1), (25), and (26) that MAIS(DK) = N − K + 1 = (cid:96)ICC(DK). Thus (cid:96)ICC(DK) =
β(DK) = βt(DK) = N − K + 1.

March 2, 2016

DRAFT

DRAFT

31

(a)

(b)

(c)

Fig. 8.
(a) Pa→b(D3) and Pa→c(D3) forming a tree Ta, and the tree branches at vertex vi to go to b and c in D3, (b)
Pa→b(D3) and Pc→b(D3) having some vertices in Vn in common, and these two paths first meet at vertex vj, and (c) Pa→b(D3),
Pa→c(D3) and Pc→b(D3) together in D3. The dashed lines indicated paths.

APPENDIX C

PROOF OF PROPOSITION 5

Proof: Let D3 be a 3-IC structure having an inner-vertex set VI = {a, b, c}. Now we prove
that any non-inner vertices of D3 belonging to an I-path could not contribute to form a cycle
including only non-inner vertices of D3. To show this, we start by picking two inner vertices a
and b, and the I-path Pa→b(D3). We assume that the I-path includes n ≥ 0 non-inner vertices,
i.e., Pa→b(D3) = (cid:104)a, v1, v2, . . . , vn, b(cid:105). Further, let {v1, v2, . . . , vn} be denoted by Vn. If n = 0,
then Vn = ∅ for Pa→b(D3). Now for n ≥ 1, we have the following in D3:

• Pb→a(D3), Pc→a(D3) and Pb→c(D3) cannot contain any vertex in Vn of Pa→b(D3) because

of the following:
1) If Pb→a(D3) or Pc→a(D3) contains any vertex v ∈ Vn, then Pa→v(D3) (part of
Pa→b(D3)) and Pv→a(D3) (part of Pb→a(D3) or Pc→a(D3)) form an I-cycle at a. The
existence of the I-cycle in D3 contradicts the definition of an IC structure.

2) If Pb→c(D3) contains any vertex v ∈ Vn, then Pb→v(D3) (part of Pb→c(D3)) and
Pv→b(D3) (part of Pa→b(D3)) form an I-cycle at b. The existence of the I-cycle in D3
contradicts the definition of an IC structure.

• One can verify that only the remaining I-paths Pa→c(D3) and Pc→b(D3) can contain vertices

in Vn without forming an I-cycle in D3.

Now for Pa→b(D3) and Pa→c(D3), these two I-paths must form a directed rooted tree Ta with
the root vertex a (by the definition of an IC structure). Thus these two I-paths alone could not

March 2, 2016

DRAFT

abcviTaabcvjabcvjviDRAFT

32

form a cycle including only non-inner vertices. Furthermore, if Pa→b(D3) and Pa→c(D3) contain
some common non-inner vertices, then let a vertex vi ∈ Vn, which is in Ta, be the vertex from
where Ta branches to b and c (refer to Fig. 8a).

For Pa→b(D3) and Pc→b(D3), these two I-paths alone could not form a cycle including only

non-inner vertices because of the following:

• If they contain some common non-inner vertices, then let vj ∈ Vn be the first vertex where
Pa→b(D3) and Pc→b(D3) meet each other (refer to Fig. 8b). Considering only these two
I-paths, a cycle including only non-inner vertices can form only if a part of Pc→b(D3)
contributes to form a path from vj to vi ∈ Vn for some i ∈ {1, 2, . . . , j − 1}. This path is
not possible because multiple I-paths would be created from a or c to b in D3 (contradiction
of the definition of an IC structure). In fact, both the I-paths have the same destination,
i.e., b, so there must be only one path from vj to b common in both of them (to avoid any
multiple I-paths).

For Pa→c(D3) and Pc→b(D3), if these I-paths contain a non-inner vertex v in common,
then Pc→v(D3) (part of Pc→b(D3)) and Pv→c(D3) (part of Pa→c(D3)) forms an I-cycle at c
(contradiction to the definition of an IC structure). Thus Pa→c(D3) and Pc→b(D3) cannot contain
any vertex in common except c. Consequently, considering Pa→b(D3), Pa→c(D3) and Pc→b(D3)
(along with assumptions that there are some common non-inner vertices in (i) Pa→b(D3) and
Pa→c(D3), and (ii) Pa→b(D3) and Pc→b(D3)), we end up with the structure as shown in Fig. 8c,
where j > i and i, j ∈ {1, 2, . . . , n}. This structure contradicts one of the necessary conditions6
for any vertex in Vn to contribute to form a cycle including only non-inner vertices in D3. Thus
there is no vertex in Vn to contribute to form a cycle including only non-inner vertices in D3.
Due to symmetry, the result (any non-inner vertices of D3 belonging to Pa→c(D3) could not
contribute to form a cycle including only non-inner vertices of D3) implies similarly for non-inner
vertices belonging to any of the I-paths in D3. Therefore, there is no cycle among the non-inner
vertices in D3.

By Theorem 3, for D3, we get (cid:96)ICC(D3) = β(D3) = βt(D3). The proof is straight forward for

2-IC structure (which is a cycle) and 1-IC structure (which is a single vertex).

6There should be an incoming path to a vertex in Vn (let this vertex be va) and an out-going path from a vertex in Vn (let

this vertex be vb), for some a ≤ b, where a, b ∈ {1, 2, . . . , n}. One can easily verify this necessary condition.

March 2, 2016

DRAFT

DRAFT

33

APPENDIX D

PROOF OF THEOREM 4

In this section, firstly, for every minimal partial clique D(cid:48) with δ+(D(cid:48)) ∈ {0, 1, 2,|V (D(cid:48))|− 1},
we prove that there exists an IC structure within it such that both of the schemes (partial-clique-
cover and ICC) provide the same savings. Secondly, we conjecture that the result is valid in
general (this is the main reason that results the Conjecture 2). The summary is depicted in
Table III. Finally, we prove the theorem.

We prove some lemmas (Lemmas 6, 7 and 8) that capture the properties of the minimal partial

clique D(cid:48).

Lemma 6: A minimal partial clique D(cid:48) with |V (D(cid:48))| ≥ 2 vertices and the minimum out-degree
δ+(D(cid:48)) = 1 is a cycle, and both the partial-clique-cover scheme and the ICC scheme achieve
savings of one.

Proof: The properties of D(cid:48) with |V (D(cid:48))| ≥ 2 and δ+(D(cid:48)) = 1 are as follows: In D(cid:48), (i) as
δ+(D(cid:48)) = 1, the partial-clique-cover scheme provides the savings of one by Proposition 6, (ii)
further partitioning could not provide any savings because it is a minimal-partial-clique, and (iii)
there exists at least a cycle because an acyclic digraph should have a sink vertex (a vertex with
out-degree zero), and that does not exist since δ+(D(cid:48)) = 1. Thus D(cid:48), which is a minimal partial
clique, having all of the above properties is a cycle. From Theorem 2, a cycle is a 2-IC structure,
and the ICC scheme provides savings of one by (7). Note that such D(cid:48) with |V (D(cid:48))| = 2 is also
a clique of order two.

Now we define some terms.
Definition 22 (Out-going arc): An out-going arc of a vertex is the arc that originate from the

vertex and goes to any other vertex.

Definition 23 (Figure-of-eight): Two directed cycles C1 and C2 intersecting at a vertex u such

that V (C1) ∩ V (C2) = {u}, is a figure-of-eight structure at u.

Lemma 7: A minimal partial clique D(cid:48) with |V (D(cid:48))| ≥ 1 vertices and the minimum out-degree
δ+(D(cid:48)) = |V (D(cid:48))| − 1, is a clique of order |V (D(cid:48))|, and D(cid:48) has the savings of |V (D(cid:48))| − 1 from
both the partial-clique-cover scheme and the ICC scheme.

Proof: In D(cid:48), if δ+(D(cid:48)) = |V (D(cid:48))| − 1, then each vertex has an out-going arc to every other
vertex, which is a clique by definition. Thus the partial-clique-cover scheme provides savings of

March 2, 2016

DRAFT

DRAFT

34

PARTIAL CLIQUES AND IC STRUCTURES FROM THE SAVINGS PERSPECTIVE

TABLE III

|V (D(cid:48))| − 1 by Proposition 6. From Theorem 2, a clique is a |V (D(cid:48))|-IC structure, and the ICC
scheme provides savings of |V (D(cid:48))| − 1 by (7).

Lemma 8: In any minimal partial clique D(cid:48) with |V (D(cid:48))| ≥ 3 vertices and δ+(D(cid:48)) = 2, there
exists a 3-IC structure, and D(cid:48) has the savings of two from both the partial-clique-cover scheme
and the ICC scheme.

We first define some terms and prove some lemmas (Lemmas 9, 10, 11 and 12) that will help

to prove the Lemma 8.

Definition 24: A path in the forward direction indicates a path from a vertex i to any vertex j
such that j > i, and a path in the reverse direction indicates a path from a vertex j to any vertex
i such that i < j. For simplicity, we refer a forward path to a path in the forward direction, and
a reverse path to a path in the reverse direction.

Definition 25 (Farthest path): Consider a sequence of vertices labeled in an increasing order
such that there are multiple paths from a vertex i in the sequence to other vertices in the sequence.
Among those paths from i, the path to the vertex with the largest label is called the farthest path
from vertex i. For an example, let 1, 2, . . . , 9 be a sequence of vertices in an increasing order,
and 1 has paths to vertices 3, 5 and 9. The path from from 1 to 9 is the farthest path from 1.

For the remainder of this section, we consider the following:

March 2, 2016

DRAFT

1234567801234|V(D0)|δ+(D0)Savings=0.Savings=2;a3-ICexistsinD0.ProvedConjecturedD0doesn’texistProvedSavings=1;D0isacycle,whichisaspecialcaseofanIC.Savings=δ+(D0);aK-ICwithK=δ+(D0)existsinD0AlloftheshadedregionsrepresentD0withδ+(D0)=|V(D0)|−1=savings;D0isaclique,whichisaspecialcaseofanIC.DRAFT

35

• A minimal partial clique D(cid:48) with |V (D(cid:48))| ≥ 3 number of vertices and δ+(D(cid:48)) = 2 has at
least one cycle by Lemma 9. Without loss of generality, denote the cycle by C, and its
vertices by V (C) = {1, 2, . . . , p}. For simplicity, vertices of C are labeled in an increasing
order as shown in Fig. 10a.
• For a, b ∈ V (C), Pa→b(C) denotes a path from a to b including only vertices and arcs of C,
and P (cid:48)a→b(D(cid:48)) denotes a path from a to b consisting of arcs and vertices outside C except
vertices a and b.

• For the vertices in V (C) (see Fig. 10a), vertex 1 (the first vertex of C) has only forward
paths to other vertices of C (Definition 24), and vertex p (the last vertex of C) has only
reverse paths to other vertices of C (Definition 24). Let i ∈ V (C)\{1, p} be the first vertex
in the vertex sequence that has a reverse path to any vertex in V (C), i.e., there exist a
P (cid:48)i→j(D(cid:48)) such that j ∈ {1, 2 . . . , i − 1} and all vertices in {1, 2 . . . , i − 1} have no reverse
path.

Lemma 9: In a minimal partial clique D(cid:48) with the minimum out-degree δ+(D(cid:48)) = 2, and

|V (D(cid:48))| ≥ 3 vertices;

1) there exists at least one cycle, C, and
2) for a vertex v ∈ V (C), one of its out-going arcs (beside the arc in C) contribute to form a

path that always returns to some vertex in C.
Proof: In D(cid:48) with |V (D(cid:48))| ≥ 3 vertices and δ+(D(cid:48)) = 2, there exists at least one cycle,
denoted C. This is because if any D(cid:48) is acyclic, then it must contain at least one sink vertex,
and there cannot be sink vertices in D(cid:48) since δ+(D(cid:48)) = 2.

Assume that vertices u, v ∈ V (C) such that there is an arc from u to v in C. Now in D(cid:48), u

D(cid:48)(u) ≥ 2, and the next out-going arc of u (other than the arc in C)

has out-degree d+
(i) goes to any vertex in V (C) \ {v}, or
(ii) contributes a path, say Q, which includes at least one vertex outside C.
Consider the terminal vertex of the path Q to be z such that z ∈ V (D(cid:48)) \ V (C). Vertex z cannot
D(cid:48)(z) ≥ 2, and it must contribute to form a path. Since there are no
be a sink vertex because d+
disjoint cycles (all cycles are connected, otherwise any two disjoint cycles in D(cid:48) provides savings
of two and such D(cid:48) is not a minimal partial clique with δ+(D(cid:48)) = 2), z must have a return path
to a vertex in V (C).

March 2, 2016

DRAFT

DRAFT

36

Analyzing D(cid:48) by considering the out-going paths from vertices of C, we get the following

lemmas.

Lemma 10: Any path P (cid:48)k→m(D(cid:48)) for k ∈ {j + 1, j + 2, . . . , i− 1}, m ∈ V (C)\{i} and a path

P (cid:48)i→j(D(cid:48)) are vertex-disjoint.

Proof: We had considered that vertex i of C is the first vertex having a reverse path. Now if
any path P (cid:48)k→m(D(cid:48)) meets path P (cid:48)i→j(D(cid:48)) at some vertices, then there exists a reverse path from
vertex k to j. This is not possible because such k would have been the first vertex in the vertex
sequence that has a reverse path (contradiction).

Lemma 11: Any farthest path from j, P (cid:48)j→k(D(cid:48)), for k ∈ {j + 1, j + 2, . . . , p} and a path

P (cid:48)m→q(D(cid:48)) for m ∈ {j + 1, j + 2, . . . , k − 1}, q ∈ {k + 1, k + 2, . . . , p} are vertex-disjoint.

Proof: If the farthest path from j, P (cid:48)j→k(D(cid:48)), meets any path P (cid:48)m→q(D(cid:48)) at some vertices,
then there exists P (cid:48)j→q(D(cid:48)). This is not possible; otherwise, path P (cid:48)j→q(D(cid:48)) would have been the
farthest path (contradiction).

Lemma 12: If any path P (cid:48)j→k(D(cid:48)) and a path P (cid:48)m→j(D(cid:48)) for any m (cid:54)= k meet at some common

vertices except j, then there exists a figure-of-eight at j.

Proof: If j = k or m = j, then we get a figure-of-eight structure at j. Two closed paths at j
will be (i) P (cid:48)j→j(D(cid:48)), and (ii) C. If j (cid:54)= k (cid:54)= m, then let x be the common vertex which is nearest
to j in these two paths P (cid:48)j→k(D(cid:48)) and P (cid:48)m→j(D(cid:48)). Now we get a figure-of-eight structure at j.
Two closed paths at j will be (i) Pj→x(D(cid:48)) (part of P (cid:48)j→k(D(cid:48))), Px→j(D(cid:48)) (part of P (cid:48)m→j(D(cid:48))),
and (ii) C. These closed paths are vertex-disjoint except j.

Now we prove Lemma 8.

Proof of Lemma 8: The proof is done by the detailed structural analysis of the minimal
partial clique D(cid:48). We divide the proof into two parts: In Part-I, we prove that D(cid:48) has a figure-of-
eight structure (see Definition 23) at a vertex, and in Part-II, we prove there exist a 3-IC structure
within D(cid:48) having a figure-of-eight structure.

(Part-I) Consider the cycle C in D(cid:48) has p ≥ 2 vertices. Now based on C, there are two cases
in D(cid:48), and those are (i) C with p = 2, i.e., C is a clique of size two, and (ii) C with p ≥ 3. We
assume u and v are the two distinct vertices belonging to V (C) in such a way that there exist a
directed arc from u to v. In D(cid:48), d+
D(cid:48)(u) ≥ 2 and the next out-going arc of u goes out of C, and
contributes to form a path, say Q that returns to some vertex in V (C) by Lemma 9.

(Case (i)) The cycle C is a clique of size two. Therefore, the path Q returns to C either at u

March 2, 2016

DRAFT

DRAFT

37

(a)

(b)

(c)

(d)

Fig. 9. The possible cases of out-going arcs for vertex u ∈ V (C). The paths are indicated by dashed lines, and the arcs are
indicated by solid lines.

or v. Now we get a figure-of-eight structure at u if the path returns to u, otherwise it returns
to v. For the latter case, we get a new cycle that includes the path Q (which includes u, some
vertices other than v), vertex v and the arc from v to u (i.e., arc of the cycle C). The new cycle
has more than two vertices, thus this ends up with case (ii).

(Case (ii)) On the basis where path Q returns, we have the following sub-cases: Q returns to
(ii-A) u (see in Fig. 9a) providing a figure-of-eight structure, (ii-B) v (see in Fig. 9b and 9c),
and (ii-C) some vertex w ∈ V (C) \ {u, v} (see in Fig. 9d).

For sub-case (ii-B), we have a vertex x ∈ V (Q) \ V (C) such that there is a direct arc from x
to v. Since there are no disjoint cycles, the next out-going arc of x (besides the arc from x to v)
contributes to form a path to a vertex in V (C). If x has path to u, then we get a figure-of-eight
at u (shown in Fig. 9b), otherwise we have the following:

a) x has a path to some w ∈ V (C) \ {u, v}, so this ends up with sub-case (ii-C) (shown in

Fig. 9d), or

b) x has a path to v, but for this case, we have another path (shown in Fig. 9c) from u to v
(beside the direct arc from u to v, and path including the direct arc from x to v), and in
this path, we can repeat sub-case (ii-B) by considering the predecessor of v in place of x.

Since the number of vertices in D(cid:48) is finite, sub-case (ii-B) either ends up with a figure-of-eight
structure or sub-case (ii-C).

For sub-case (ii-C), note that we have a path Q, which is vertex-disjoint from C except the
first and the last vertices, which starts from any vertex u ∈ V (C) and returns to some vertex
w ∈ V (C) \ {u, v}.

We start analyzing the sub-case (ii-C) in D(cid:48) considering vertices in V (C). For the vertices in

March 2, 2016

DRAFT

uvwuvwxuvwxuvwDRAFT

38

(a)

(b)

(c)

(d)

(f)

(e)

(g)

Fig. 10.
(a) Cycle C and its vertices, (b) figure-of-eight at vertex j with P (cid:48)j→k(D(cid:48)) for k ∈ {i + 1, i + 2, . . . , p}, (c)
figure-of-eight at vertex j with P (cid:48)j→i(D(cid:48)), (d) illustration of path-A and path-B, (e) figure-of-eight at vertex j with path-A,
path-B and P (cid:48)k−1→m(D(cid:48)) for m ∈ {i + 1, i + 2, . . . , p}, (f) figure-of-eight at vertex j with path-A, path-B and P (cid:48)k−1→i(D(cid:48)),
and (g) illustration of updating path-A and path-B. The paths are indicated by dashed lines, and the arcs are indicated by solid
lines.

V (C) (see Fig. 10a), in a sequential order starting from vertex 1, we track their out-going paths
(which may include vertices not in V (C)) to other vertices in V (C). For this sub-case, we know
that there exist a P (cid:48)i→j(D(cid:48)) such that j ∈ {1, 2 . . . , i − 1} and all vertices in {1, 2 . . . , i − 1}
have only forward paths. Now we consider out-going paths from j (the paths are always forward
paths), and get the following subsub-cases:

1) If the farthest path from j is P (cid:48)j→k(D(cid:48)) for some k ∈ {i + 1, i + 2, . . . , p}, then there
exists a figure-of-eight at j. Two closed paths at j will be (i) Pj→i(C), P (cid:48)i→j(D(cid:48)), and (ii)
P (cid:48)j→k(D(cid:48)), Pk→j(C) (refer Fig. 10b). If P (cid:48)j→k(D(cid:48)) and P (cid:48)i→j(D(cid:48)) are vertex-disjoint except
j, then by recalling the definition of Pa→b(C) and P (cid:48)a→b(D(cid:48)) for any a, b ∈ V (C), one
can show that the two closed paths are vertex-disjoint except j. Otherwise, P (cid:48)j→k(D(cid:48)) and
P (cid:48)i→j(D(cid:48)) are not vertex-disjoint except j, and by Lemma 12, one can find a figure-of-eight
at j.

March 2, 2016

DRAFT

12p1jpki1jpii−1m1jkk−1ipPath-BPath-A1jkk−1ipmPath-BPath-A1jkk−1qiPath-BPath-Ai−1p1jkk−1imPath-BPath-Am−1pDRAFT

39

2) If the farthest path from j is P (cid:48)j→k(D(cid:48)) for k = i, then there exists a figure-of-eight at j.
Two closed paths at j will be (i) P (cid:48)j→i(D(cid:48)), P (cid:48)i→j(D(cid:48)), and (ii) Pj→i−1(C), P (cid:48)i−1→m(D(cid:48)) for
m ∈ {i + 1, i + 2, . . . , p} (one of the forward paths of i − 1), Pm→j(C) (refer Fig. 10c).
Using Lemmas 10 and 11, and recalling the definition of Pa→b(C) and P (cid:48)a→b(D(cid:48)) for any
a, b ∈ V (C), one can show that these two closed paths are vertex-disjoint except j.

3) Otherwise, the farthest path from j is P (cid:48)j→k(D(cid:48)) for some k ∈ {j + 2, j + 3, . . . , i − 1}.
Starting from j, we have at least two forward paths to some vertices in V (C) such that
these paths are vertex-disjoint except j. We assume these paths are path-A (the path from j
to k− 1) and path-B (the path from j to k). Paths Pj→k−1(C) and P (cid:48)j→k(D(cid:48)) will be path-A
and path-B respectively (refer Fig. 10d). Now considering the out-going paths from k − 1
into account (the paths are always forward paths), we get the following subsubsub-cases:
(a) If the farthest path from k − 1 is P (cid:48)k−1→m(D(cid:48)) for some m ∈ {i + 1, i + 2, . . . , p},
then there exists a figure-of-eight at j. Two closed paths at j will be (i) path-A,
P (cid:48)k−1→m(D(cid:48)), Pm→j(C), and (ii) path-B, Pk→i(C), P (cid:48)i→j(D(cid:48)) (refer Fig. 10e). Using
Lemmas 10 and 11, and recalling the definition of Pa→b(C) and P (cid:48)a→b(D(cid:48)) for any
a, b ∈ V (C), one can show that these two closed paths are vertex-disjoint except j.
(b) If the farthest path from k − 1 is P (cid:48)k−1→m(D(cid:48)) for m = i, then there exists a figure-
of-eight at j. Two closed paths at j are (i) path-A, P (cid:48)k−1→i(D(cid:48)), P (cid:48)i→j(D(cid:48)), and (ii)
path-B, Pk→i−1(C), P (cid:48)i−1→q(D(cid:48)) for q ∈ {i + 1, i + 2, . . . , p} (one of the forward paths
of i − 1), Pq→j(C) (refer Fig. 10f). If P (cid:48)j→k(D(cid:48)) and P (cid:48)i→j(D(cid:48)) are vertex-disjoint
except j, then by using Lemmas 10 and 11, and recalling the definition of Pa→b(C)
and P (cid:48)a→b(D(cid:48)) for any a, b ∈ V (C), one can show that the two closed paths are
vertex-disjoint except j. Otherwise, P (cid:48)j→k(D(cid:48)) and P (cid:48)i→j(D(cid:48)) are not vertex-disjoint
except j, and by Lemma 12, one can find a figure-of-eight at j.

(c) Otherwise, the farthest path from k − 1 is P (cid:48)k−1→m(D(cid:48)) for some m∈ {k + 1, k + 2,
. . . , i − 1}. The union of path-B and Pk→m−1(C) give new path-A and we update
k − 1 = m − 1. Similarly, the union of path-A and P (cid:48)k−1→m(D(cid:48)) give new path-B
and we update k = m (Refer Fig. 10g). Considering new path-A, new path-B, and
updating k = m, we repeat the subsubsub-cases of subsub-case 3. During this iteration,
if we get subsubsub-case (a) or (b), then there is a figure-of-eight. Otherwise, we

March 2, 2016

DRAFT

DRAFT

40

(a)

(b)

(a) Structure of D(cid:48) with the minimum out-degree two, and (b) rearranging D(cid:48) to get an IC structure. The paths are

Fig. 11.
indicated by dashed lines, and the arcs are indicated by solid lines.

have subsubsub-case (c), where k strictly increase to a value up to i − 1. However,
when k reaches i − 1, we must have either subsubsub-case (a) or (b).

Thus for all cases, D(cid:48) with |V (D(cid:48))| ≥ 3 and δ+(D(cid:48)) = 2 has a figure-of-eight structure at a
vertex.

(Part-II) Without loss of generality, we consider a figure-of-eight structure at vertex u (two

intersecting cycles at u are indicated by red and blue colors in Fig. 11a).

Now for the figure-of-eight structure at u in D(cid:48) (see Fig. 11a), consider a vertex v in a cycle
C1 (indicated in blue color), and a vertex w in another cycle C2 (indicated in red color) in
such a way that both v and w have direct arcs going to u. One of the out-going arcs of v must
contribute to form a path, say Q, returning to a vertex in V (C2) \ {u}. This is because all other
cases are not possible;

• Q cannot return to any vertex in V (C1) \ {u, v}, otherwise a disjoint cycle to C2 will be
created.

• Q can return to u, but for this case, we have another path from v to u (beside path including
direct arc from v to u), and in this path, we can repeat the case by considering the predecessor
of u in place of v. Thus this case ends up with the same consideration as of the cycle C1
with the vertex v having direct arc to the vertex u.

• Q must return to some vertex in V (C1) and V (C2) due to Lemma 9.

Now in a similarly way, one of the out-going arcs of w must also contribute a path to a vertex in
V (C1) other than u. Rearrange D(cid:48) to get the structure in Fig. 11b. Now consider VI = {u, v, w}.
We can see that any vertex in VI has only one I-path each to other two vertices in VI with no
I-cycles. Thus a 3-IC exists in D(cid:48) (for an example, see Fig. 12). Consecutively, the ICC scheme

March 2, 2016

DRAFT

uvwuvwDRAFT

41

(a)

(b)

(c)

(d)

Fig. 12. Vertices in red, blue and green colors are three internal vertices for the 3-IC in each of the cases.

provides savings of two by (7). Again, for D(cid:48), the partial-clique-cover scheme provides savings
of two by Proposition 6.

For all minimal partial cliques that we have analyzed, there exists an (δ+(D(cid:48)) + 1)-IC structure
within each minimal partial clique having the minimum out-degree δ+(D(cid:48)). We conjecture that
this holds in general (the following conjecture is not a part of the proof of the Theorem 4, but
this provides an intuition about the Conjecture 2).

Conjecture 3: For any minimal partial clique D(cid:48), both the partial-clique-cover scheme and the

ICC scheme provides the same savings.

Now we prove Theorem 4.

Proof of Theorem 4: Given a digraph D, if minimal partial cliques, partitioning the digraph
to provide partial-clique number, have δ+(D(cid:48)) ∈ {0, 1, 2,|V (D)|− 1}, then using the ICC scheme
on each of the minimal partial cliques, we achieve (cid:96)PC(D) (by using Lemmas 6, 7 and 8, and
considering zero savings for δ+(D(cid:48)) = 0 from any schemes). The ICC scheme may produce a
shorter index code by considering a different partitioning of the digraph (for an example, see
Fig. 13a and 13b).

Example 5: This example illustrates that for the class of digraphs stated in Theorem 4, the
ICC scheme performs as least as well as the partial-clique-cover scheme. Consider two digraphs
that are depicted in Fig. 13. The digraph in Fig. 13a has more savings from the ICC scheme
than that obtained from the partial-clique-cover scheme, and the digraph in Fig. 13b has equal
savings from both schemes.

March 2, 2016

DRAFT

123456123456123456123456DRAFT

42

(a)

(b)

(a) The digraph, denoted D1, has (cid:96)PC(D1) = 3 (considering possible sub-digraphs with vertex sets; {2, 3, 4} forming
Fig. 13.
a clique, {1} and {5} forming two cliques each with single vertex), but (cid:96)ICC(D1) = 2 (considering sub-digraphs with vertex sets;
{1, 2, 3, 4, 5} forming an IC structure with 1, 2, 3 and 4 as inner vertices), and (b) the digraph, denoted D2, has (cid:96)PC(D2) = 3
(considering possible sub-digraphs with vertex sets; {1, 2} forming a clique, and {3, 4, 5} forming a cycle), and (cid:96)ICC(D2) = 3
(considering sub-digraphs with vertex sets; {1, 2} forming an IC, and {3, 4, 5} forming another IC).

APPENDIX E

Note that K is an even integer greater than 2, N = 3K

2 , and i, j ∈ {1, 2, . . . , K

2 } such that

j (cid:54)= i.

Proposition 8: For any digraph D of the Class A, the index codelength obtained from the
2 + 1 respectively, i.e., (cid:96)PC(D) = K

partial-clique-cover scheme and the ICC scheme are K and K
and (cid:96)ICC(D) = K
Firstly, we prove some lemmas.

2 + 1.

Lemma 13: Any minimal partial clique D(cid:48) in a digraph of the Class A provides savings less

than or equal to two, i.e., S(D(cid:48)) ≤ 2.

Proof: If any minimal partial clique D(cid:48) in D of the Class A includes a vertex K + i for any
2 }, then δ+(D(cid:48)) ≤ 2. This is because the out-degree of any vertex K + i in D is
i ∈ {1, 2, . . . , K
two, i.e., d+
D(K + i) = 2 by construction. Now any minimal partial clique without any vertex in
2 } has δ+(D(cid:48)) ≤ 1. This is because for any vertex in {1, 2, . . . , K}, only
{K + 1, K + 2, . . . , 3K
one out-neighbor is in this set, and the rest are in {K + 1, K + 2, . . . , 3K
2 }. So, any minimal partial
clique in the digraph can have δ+(D(cid:48)) ≤ 2. Now by proposition 6, we know that S(D(cid:48)) = δ+(D(cid:48)).

Lemma 14: A digraph D of the Class A has no minimal partial clique with δ+(D(cid:48)) = 2.

Proof: In D, we try to construct a minimal partial clique D(cid:48) that has δ+(D(cid:48)) = 2 (we do
not need to consider D(cid:48) having δ+(D(cid:48)) > 2 because of Lemma 13) by starting from D(cid:48) with
only one vertex and then adding vertices into its vertex set in such a way that we can obtain

March 2, 2016

DRAFT

1542315423DRAFT

δ+(D(cid:48)) = 2.

43

D(cid:48)(2i − 1) = d+

We start from any vertex K + i for an i ∈ {1, 2, . . . , K

2 } (we will show a similar result if we
start from some vertex i). Let V (D(cid:48)) = {K + i} be the vertex set of D(cid:48). Now we include both
D (K + i) in V (D(cid:48)). If we include
of the two out-neighbor vertices of K + i, i.e., vertices in N +
only one out-neighbor vertex of K + i in V (D(cid:48)), then d+
D(cid:48)(K + i) = 1 resulting δ+(D(cid:48)) = 1.
The new vertex-induced sub-digraph D(cid:48) has V (D(cid:48)) = {K + i, 2i − 1, 2i}, and δ+(D(cid:48)) = 1
because d+
D(cid:48)(2i) = 1. To get a minimum out-degree of two, we must include
2 } \ {i}. By symmetry, it does not make any
another vertex in V (D(cid:48)) from {K + 1, K + 2, . . . , 3K
difference which vertex to add. We arbitrarily choose K + j, for some j ∈ {1, 2, . . . , K
2 } \ {i}.
Now the new vertex-induced sub-digraph D(cid:48) has V (D(cid:48)) = {K + i, 2i − 1, 2i, K + j} for a j.
Here δ+(D(cid:48)) = 0 because d+
D (K + j) in
D(K + j) = 2, and if we include only one of its out-neighbor vertices, then
V (D(cid:48)) because d+
δ+(D(cid:48)) = 1. The new D(cid:48) has V (D(cid:48)) = {K + i, 2i − 1, 2i, K + j, 2j − 1, 2j} and δ+(D(cid:48)) = 2.
Further, including any vertex set in V (D(cid:48)) could not increase δ+(D(cid:48)) because any D(cid:48) must have
δ+(D(cid:48)) = S(D(cid:48)) ≤ 2 (Lemma 13). If we start building D(cid:48) with some m ∈ {1, 2, . . . , K}, we
will end up with a sub-digraph (i) that includes {m, K + i, 2i− 1, 2i, K + j, 2j − 1, 2j} for some
2 } where i (cid:54)= j (cid:54)= m, or (ii) that includes {2i − 1, 2i, K + j, 2j − 1, 2j, K + i}
i, j ∈ {1, 2, . . . , K
for some i, j ∈ {1, 2, . . . , K
2 } where i (cid:54)= j and m = 2i or 2i − 1. Altogether, any minimal
partial clique with δ+(D(cid:48)) = 2 must contain {K + i, 2i − 1, 2i, K + j, 2j − 1, 2j} for some
2 } where i (cid:54)= j. However, D(cid:48) is not the minimal because by simply considering
i, j ∈ {1, 2, . . . , K
two partial cliques among the vertices in D(cid:48), i.e., partial cliques with vertex sets {2i − 1, 2i}
and {2j − 1, 2j}, we get savings of two (one in each).

D(cid:48)(K + j) = 0. We further include all vertices in N +

Proof of Proposition 8: For a minimal partial clique D(cid:48) in D of the Class A, Lemma 13
provides δ+(D(cid:48)) ≤ 2, and Lemma 14 proves that there exists no minimal partial clique with
δ+(D(cid:48)) = 2. Thus the minimal partial cliques in a digraph D of the Class A are only cycles. For
this case, the cycle-cover scheme and the partial-clique-cover scheme for D are the same. Since
2 = K. The minimal
any cycle must include two vertices from {1, 2, . . . , K}, (cid:96)PC(D) ≥ 3K
partial cliques with vertex sets {1, 2},{3, 4}, . . . ,{K−1, K},{K +1},{K +2}, . . . ,{N} provide
(cid:96)PC(D) = K

2 − K

2 + K

2 = K.

Consider a vertex set VI = {1, 2, . . . , K} with K number of vertices. In the digraph D, any
vertex v ∈ VI has only one path each to all other vertices in VI \ {v} such that only the first

March 2, 2016

DRAFT

DRAFT

44

and the last vertices of each of these paths belong to VI (i.e., I-path). Moreover, there is no
I-cycle at any vertex in VI. Thus this forms an IC structure with inner-vertex set VI. Now from
(7), (cid:96)ICC(D) = N − K + 1. Thus (cid:96)ICC(D) = 3 × ( K

2 ) − K + 1 = K

2 + 1.

REFERENCES

[1] Y. Birk and T. Kol, “Informed-source coding-on-demand (ISCOD) over broadcast channels,” in Proc. IEEE INFOCOM,

vol. 3, San Francisco, CA, 1998, pp. 1257–1264.

[2] Z. Bar-Yossef, Y. Birk, T. S. Jayram, and T. Kol, “Index coding with side information,” IEEE Trans. Inf. Theory, vol. 57,

no. 3, pp. 1479–1494, Mar. 2011.

[3] E. Lubetzky and U. Stav, “Nonlinear index coding outperforming the linear optimum,” IEEE Trans. Inf. Theory, vol. 55,

no. 8, pp. 3544 – 3551, Aug. 2009.

[4] R. Peeters, “Orthogonal representaions over finite fields and the chromatic number of graphs,” Combinatorica, vol. 16,

no. 3, pp. 417–431, Sept. 1996.

[5] E. Chlamtac and I. Haviv, “Linear index coding via semidefinite programming,” in Proc. 23rd Annu. ACM-SIAM Symp. on

Discrete Algorithms (SODA), 2012, pp. 406–419.

[6] A. Blasiak, R. D. Kleinberg, and E. Lubetzky, “Broadcasting with side information: Bounding and approximating the

broadcast rate,” IEEE Trans. Inf. Theory, vol. 59, no. 9, pp. 5811–5823, Sept. 2013.

[7] H. Yu and M. Neely, “Duality codes and the integrality gap bound for index coding,” IEEE Trans. Inf. Theory, vol. 60,

no. 11, pp. 7256 – 7268, Sept. 2014.

[8] F. Arbabjolfaei, B. Bandemer, Y.-H. Kim, E. Sasoglu, and L. Wang, “On the capacity region for index coding,” in Proc.

IEEE Int. Symp. Inf. Theory (ISIT), Jul. 2013, pp. 962–966.

[9] S. Unal and A. B. Wagner, “General index coding with side information: Three decoder case,” in Proc. IEEE Int. Symp.

Inf. Theory (ISIT), Jul. 2013, pp. 1137–1141.

[10] H. Maleki, V. R. Cadambe, and S. A. Jafar, “Index coding – An interference alignment perspective,” IEEE Trans. Inf.

Theory, vol. 60, no. 9, pp. 5402 – 5432, Jul. 2014.

[11] S. A. Jafar, “Topological interference management through index coding,” IEEE Trans. Inf. Theory, vol. 60, no. 1, pp. 529

– 568, Oct. 2013.

[12] F. Arbabjolfaei and Y.-H. Kim, “Local time sharing for index coding,” in Proc. IEEE Int. Symp. Inf. Theory (ISIT), Jun.

2014, pp. 286–290.

[13] K. Shanmugam, A. G. Dimakis, and M. Langberg, “Local graph coloring and index coding,” in Proc. IEEE Int. Symp. Inf.

Theory (ISIT), Jul. 2013, pp. 1152–1156.

[14] ——, “Graph theory versus minimum rank for index coding,” in Proc. IEEE Int. Symp. Inf. Theory (ISIT), Jul. 2014, pp.

291 – 295.

[15] M. A. R. Chaudhry, Z. Asad, A. Sprintson, and M. Langberg, “On the complementary index coding problem,” in Proc.

IEEE Int. Symp. Inf. Theory (ISIT), Jul. 2011, pp. 224–248.

[16] M. J. Neely, A. S. Tehrani, and Z. Zhang, “Dynamic index coding for wireless broadcast networks,” IEEE Trans. Inf.

Theory, vol. 59, no. 11, pp. 7525–7540, Nov. 2013.

[17] F. Arbabjolfaei and Y.-H. Kim, “Structural properties of index coding capacity using fractional graph theory,” in Proc.

IEEE Int. Symp. Inf. Theory (ISIT), Jun. 2015, pp. 1034 – 1038.

March 2, 2016

DRAFT

DRAFT

45

[18] ——, “On critical index coding problems,” in Proc. IEEE Inf. Theory Workshop (ITW), Oct. 2015, pp. 9–13.
[19] M. Tahmasbi, A. Shahrasbi, and A. Gohari, “Critical graphs in index coding,” IEEE Journal on Selected Areas in

Communications, vol. 33, no. 2, pp. 225 – 235, Feb. 2015.

[20] L. Ong, “Linear codes are optimal for index-coding instances with five or fewer receivers,” in Proc. IEEE Int. Symp. Inf.

Theory (ISIT), Jun. 2014, pp. 491–495.

[21] S. E. Rouayheb, A. Sprintson, and C. Georghiades, “On the index coding problem and its relation to network coding and

matroid theory,” IEEE Trans. Inf. Theory, vol. 56, no. 7, pp. 3187 – 3195, Jul. 2010.

March 2, 2016

DRAFT

