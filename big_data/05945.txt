6
1
0
2

 
r
a

 

M
8
1

 
 
]
S
D
.
s
c
[
 
 

1
v
5
4
9
5
0

.

3
0
6
1
:
v
i
X
r
a

Parameterized vertex deletion problems for

hereditary graph classes with a block property(cid:63)

Édouard Bonnet, Nick Brettell, O-joung Kwon, and Dániel Marx

Institute for Computer Science and Control, Hungarian Academy of Sciences

(MTA SZTAKI)

edouard.bonnet@dauphine.fr, nbrettell@gmail.com,

ojoungkwon@gmail.com, dmarx@cs.bme.hu

Abstract. For a class of graphs P, the Bounded P-Block Vertex Dele-
tion problem asks, given a graph G on n vertices and positive integers k
and d, whether there is a set S of at most k vertices such that each block of
G−S has at most d vertices and is in P. We show that when P satisﬁes a nat-
ural hereditary property and is recognizable in polynomial time, Bounded
P-Block Vertex Deletion can be solved in time 2O(k log d)nO(1). When
P contains all split graphs, we show that this running time is essentially
optimal unless the Exponential Time Hypothesis fails. On the other hand,
if P consists of only complete graphs, or only cycle graphs and K2, then
Bounded P-Block Vertex Deletion admits a cknO(1)-time algorithm
for some constant c independent of d. We also show that Bounded P-Block
Vertex Deletion admits a kernel with O(k2d7) vertices.

1

Introduction

Vertex deletion problems are formulated as follows: given a graph G and a class
of graphs G, is there a set of at most k vertices whose deletion transforms G into
a graph in G? A graph class G is hereditary if whenever G is in G, every induced
subgraph H of G is also in G. Lewis and Yannakakis [16] proved that for every
non-trivial hereditary graph class decidable in polynomial time, the vertex deletion
problem for this class is NP-complete. On the other hand, a class is hereditary if
and only if it can be characterized by a set of forbidden induced subgraphs F, and
Cai [3] showed that if F is ﬁnite, with each graph in F having at most c vertices,
then there is an O(cknc+1)-time algorithm for the corresponding vertex deletion
problem.

A block of a graph is a maximal connected subgraph not containing a cut vertex.
Every maximal 2-connected subgraph is a block, but a block may just consist of one
or two vertices. We consider vertex deletion problems for hereditary graph classes
where all blocks of a graph in the class satisfy a certain common property. It is
natural to describe such a class by the set of permissible blocks P. For ease of
notation, we do not require that P is itself hereditary, but the resulting class, where
graphs consist of blocks in P, should be. To achieve this, we say that a class of
graphs P is block-hereditary if, whenever G is in P and H is an induced subgraph of
G, every block of H with at least one edge is isomorphic to a graph in P. For a block-
hereditary class of graphs P, we deﬁne ΦP as the class of all graphs whose blocks
with at least one edge are in P. Several well-known graph classes can be deﬁned in
this way. For instance, a forest is a graph in the class Φ{K2}, a cactus graph is a
graph in the class ΦC where C consists of K2 and all cycles, and a complete-block
(cid:63) All authors are supported by ERC Starting Grant PARAMTIGHT (No. 280152).

É. Bonnet, N. Brettell, O. Kwon, D. Marx

2
graph1 is a graph in ΦK where K consists of all complete graphs. We note that C is
not a hereditary class, but it is block-hereditary; this is what motivates our use of
the term.
Let P be a block-hereditary class such that ΦP is a non-trivial hereditary class.
The result of Lewis and Yannakakis [16] implies that the vertex deletion problem
for ΦP is NP-complete. We deﬁne the following parameterized problem for a ﬁxed
block-hereditary class of graphs P.
P-Block Vertex Deletion
Parameter: k
Input: A graph G and a non-negative integer k.
Question: Is there a set S ⊆ V (G) with |S| (cid:54) k such that each block of G − S
with at least one edge is in P?

This problem generalizes the well-studied parameterized problems Vertex Cov-
er, when P = ∅, and Feedback Vertex Set, when P = {K2}. Moreover, if ΦP
can be characterized by a ﬁnite set of forbidden induced subgraphs, then Cai’s ap-
proach [3] can be used to obtain a ﬁxed-parameter tractable (FPT) algorithm that
runs in time 2O(k)nO(1).

In this paper, we are primarily interested in the variant of this problem where,
additionally, the number of vertices in each block is at most d. The value d is a
parameter given in the input.
Bounded P-Block Vertex Deletion
Parameter: d, k
Input: A graph G, a positive integer d, and a non-negative integer k.
Question: Is there a set S ⊆ V (G) with |S| (cid:54) k such that each block of G − S
with at least one edge has at most d vertices and is in P?

We also consider this problem when parameterized only by k. When d = |V (G)|,
this problem is equivalent to P-Block Vertex Deletion, so Bounded P-Block
Vertex Deletion is NP-complete for any P such that ΦP is a non-trivial heredi-
tary class. When d = 1, this problem is equivalent to Vertex Cover. This implies
that the Bounded P-Block Vertex Deletion problem is para-NP-hard when
parameterized only by d.
The Bounded P-Block Vertex Deletion problem is also equivalent to Ver-
tex Cover when P is a class of edgeless graphs. Since Vertex Cover is well
studied, we assume that d (cid:62) 2, and focus on classes that contain a graph with
at least one edge. We call such a class non-degenerate. When P is the class of all
connected graphs with no cut vertices, we refer to Bounded P-Block Vertex
Deletion as Bounded Block VD.

Related Work. The analogue of Bounded Block VD for connected components,
rather than blocks, is known as Component Order Connectivity. For this
problem, the question is whether a given graph G has a set of vertices S of size
at most k such that each connected component of G − S has at most d vertices.
Drange et al. [6] showed that Component Order Connectivity is W [1]-hard
when parameterized by k or by d, but FPT when parameterized by k + d, with an
algorithm running in 2O(k log d)n time.
Clearly, the vertex deletion problem for either cactus graphs, or complete-block
graphs, is a specialization of P-Block Vertex Deletion. A graph is a cactus
graph if and only if it does not contain a subdivision of the diamond [7], the graph
obtained by removing an edge from the complete graph on four vertices. For this
reason, the problem for cactus graphs is known as Diamond Hitting Set. For
block graphs, we call it Complete Block Vertex Deletion. General results
1 A block graph is the usual name in the literature for a graph where each block is a
complete subgraph. However, since we are dealing here with both blocks and block
graphs, to avoid confusion we instead use the term complete-block graph and call the
corresponding vertex deletion problem Complete Block Vertex Deletion.

Vertex deletion problems for graph classes with a block property

3

imply that there is a cknO(1)-time algorithm for Diamond Hitting Set [9,12,14],
but an exact value for c is not forthcoming from these approaches. However, Kolay et
al. [15] obtained a 12knO(1)-time randomized algorithm. For the variant where each
cycle must additionally be odd (that is, P consists of K2 and all odd cycles), there
is a 50knO(1)-time deterministic algorithm due to Misra et al. [18]. For Complete
Block Vertex Deletion, Kim and Kwon [13] showed that there is an algorithm
that runs in 10knO(1) time, and there is a kernel with O(k6) vertices. Agrawal et
al. [1] improved this running time to 4knO(1), and also obtained a kernel with O(k4)
vertices.
When considering a minor-closed class, rather than a hereditary class, the vertex
deletion problem is known as F-minor-free Deletion. Every F-minor-free
Deletion problem has an O(f (k)·n3)-time FPT algorithm [20]. When F is a set of
connected graphs containing at least one planar graph, Fomin et al. [9] showed there
is a deterministic FPT algorithm for this problem running in time 2O(k)·O(n log2 n).
One can observe that the class of all graphs whose blocks have size at most d is closed
under taking minors. Thus, P-Block Vertex Deletion has a single-exponential
FPT algorithm and a polynomial kernel, when P contains all connected graphs with
no cut vertices and at most d vertices. However, it does not tell us anything about
the parameterized complexity of Bounded P-Block Vertex Deletion, which
we consider in this paper.

Our Contribution. The main contribution of this paper is the following:
Theorem 1.1. Let P be a non-degenerate block-hereditary class of graphs that is
recognizable in polynomial time. Then, Bounded P-Block Vertex Deletion
(i) can be solved in 2O(k log d)nO(1) time, and
(ii) admits a kernel with O(k2d7) vertices.

We will show that this running time is essentially optimal when ΦP is the class
of all graphs, unless the Exponential Time Hypothesis (ETH) [11] fails. One may
expect that if the permissible blocks in P have a simpler structure, then the problem
becomes easier. However, we obtain the same lower bound when ΦP contains all split
graphs. Since split graphs are a subclass of chordal graphs, the same can be said
when ΦP contains all chordal graphs.
Theorem 1.2. Let P be a block-hereditary class. If ΦP contains all split graphs,
then Bounded P-Block Vertex Deletion is not solvable in time 2o(k log d),
unless the ETH fails.
Formally, there is no function f (x) = o(x) such that there is a 2f (k log d)nO(1)-time
algorithm for Bounded P-Block Vertex Deletion, unless the ETH fails.
Proposition 1.3. Let P be a block-hereditary class. If ΦP contains all split graphs,
then Bounded P-Block Vertex Deletion is W [1]-hard when parameterized
only by k.

On the other hand, Bounded P-Block Vertex Deletion is FPT when pa-
rameterized only by k if P consists of all complete graphs, or if P consists of K2
and all cycles. We refer to these problems as Bounded Complete Block VD
and Bounded Cactus Graph VD respectively.
Theorem 1.4. Bounded Complete Block VD can be solved in time O∗(10k).

Theorem 1.5. Bounded Cactus Graph VD can be solved in time O∗(26k).

4

É. Bonnet, N. Brettell, O. Kwon, D. Marx

When d = |V (G)|, these become O∗(ck)-time algorithms for Complete Block
Vertex Deletion and Diamond Hitting Set respectively. In particular, the
latter implies that there is a deterministic FPT algorithm that solves Diamond
Hitting Set, running in time O∗(26k).

The paper is structured as follows. In the next section, we give some preliminary
deﬁnitions. In Section 3, we deﬁne P-clusters and P-clusterable graphs, and show
that P-Block Vertex Deletion can be solved in O∗(4k) time for P-clusterable
graphs; in particular, we use this to prove Theorem 1.1(i). In Section 4.1, we show
that, assuming the ETH holds, this running time is essentially tight (Theorem 1.2),
and in Section 4.2 we prove Proposition 1.3. In Section 5, we use iterative compres-
sion to prove Theorems 1.4 and 1.5. Finally, in Section 6, we show that Bounded
P-Block Vertex Deletion admits a polynomial kernel, proving Theorem 1.1(ii).
We also show that smaller kernels can be obtained for Bounded Block VD,
Bounded Complete Block VD, and Bounded Cactus Graph VD.

2 Preliminaries

G, and let NG(S) :=(cid:83)

All graphs considered in this paper are undirected, and have no loops and no parallel
edges. Let G be a graph. We denote by NG(v) the set of neighbors of a vertex v in
v∈S NG(v) \ S for any set of vertices S. For X ⊆ V (G), the
deletion of X from G is the graph obtained by removing X and all edges incident
to a vertex in X, and is denoted G − X. For x ∈ V (G), we simply use G − x to
refer to G − {x}. Let F be a set of graphs; then G is F-free if it has no induced
subgraph isomorphic to a graph in F. For n (cid:62) 1, the complete graph on n vertices
is denoted Kn.

A vertex v of G is a cut vertex if the deletion of v from G increases the number
of connected components. We say G is biconnected if it is connected and has no cut
vertices. A block of G is a maximal biconnected subgraph of G. The graph G is 2-
connected if it is biconnected and |V (G)| (cid:62) 3. In this paper we are frequently dealing
with blocks, so the notion of being biconnected is often more natural than that of
being 2-connected. The block tree of G is a bipartite graph B(G) with bipartition
(B, X), where B is the set of blocks of G, X is the set of cut vertices of G, and a
block B ∈ B and a cut vertex x ∈ X are adjacent in B(G) if and only if B contains
x. A block B of G is a leaf block if B is a leaf of the block tree B(G). Note that a
leaf block has at most one cut vertex.
For u, v ∈ V (G), a uv-path is a path beginning at u and ending at v. For
X ⊆ V (G), an X-path is a path beginning and ending at distinct vertices in X,
with no internal vertices in X. For v ∈ V (G) and X ⊆ V (G), a (v, X)-path is a path
beginning at v, ending at a vertex x ∈ X, and with no internal vertices in X. The
length of a path P , denoted l(P ), is the number of edges in P . A path is non-trivial
if it has length at least two.
Parameterized Complexity. A parameterized problem Q ⊆ Σ∗ × N is ﬁxed-
parameter tractable (FPT ) if there is an algorithm that decides whether (x, k)
belongs to Q in time f (k)·|x|O(1) for some computable function f. Such an algorithm
is called an FPT algorithm. A parameterized problem is said to admit a polynomial
if there is a polynomial time algorithm in |x| + k, called a kernelization
kernel
algorithm, that reduces an input instance into an instance with size bounded by a
polynomial function in k, while preserving the Yes or No answer.

3 Clustering

Agrawal et al. [1] described an eﬃcient FPT algorithm for Complete Block
Vertex Deletion using a two stage approach. Firstly, small forbidden induced

Vertex deletion problems for graph classes with a block property

5

subgraphs are eliminated using a branching algorithm. More speciﬁcally, for each
diamond or cycle of length four, at least one vertex must be removed in a solution,
so there is a branching algorithm that runs in O∗(4k) time. The resulting graph has
the following structural property: any two distinct maximal cliques have at most
one vertex in common. Thus, in the second stage, it remains only to eliminate all
cycles not fully contained in a maximal clique, so the problem can be reduced to an
instance of Weighted Feedback Vertex Set. We generalize this process and
refer to it as “clustering”, where the “clusters”, in the case of Complete Block
Vertex Deletion, are the maximal cliques. We use this to obtain an algorithm
for Bounded P-Block Vertex Deletion in Section 3.2.

3.1 P-clusters
Let P be a block-hereditary class of graphs. We may assume that P contains only
biconnected graphs; otherwise there is some block-hereditary P(cid:48) such that P(cid:48) ⊂ P
and ΦP(cid:48) = ΦP. Let G be a graph. A P-cluster of G is a maximal induced subgraph H
of G with the property that H is isomorphic either to K1 or a graph in P. We say
that G is P-clusterable if for any distinct P-clusters H1 and H2 of G, we have
|V (H1) ∩ V (H2)| (cid:54) 1. For a P-clusterable graph, if v ∈ V (G) is contained in at
least two distinct P-clusters, then v is called an external vertex.
The following property of P-clusters is essential. We say that X ⊆ V (G) hits
a cycle C if X ∩ V (C) (cid:54)= ∅, and a cycle C is contained in a P-cluster of G if
V (C) ⊆ V (H) for some P-cluster H of G.
Lemma 3.1. Let P be a non-degenerate block-hereditary class of graphs, let G be
a graph, and let S ⊆ V (G). Then G − S ∈ ΦP if and only if S hits every cycle not
contained in a P-cluster of G.
Proof. Suppose G−S ∈ ΦP and there exists a cycle C of G−S that is not contained
in a P-cluster of G. As G− S ∈ ΦP and every cycle is biconnected, G[V (C)] is in P.
Thus, there exists a P-cluster of G that contains C as a subgraph; a contradiction.
For the other direction, suppose S hits every cycle not contained in a P-cluster,
and let B be a block of G − S. It is suﬃcient to show that B ∈ P. If B is not
contained in a P-cluster, then there are distinct vertices v1 and v2 in B such that
v1 ∈ V (P1)\ V (P2) and v2 ∈ V (P2)\ V (P1) for distinct P-clusters P1 and P2. Since
K2 ∈ P, we may assume that B is not isomorphic to K2. Thus, as B is biconnected,
there is a cycle containing v1 and v2 in G − S; a contradiction. We deduce that B
(cid:117)(cid:116)
is contained in a P-cluster of G, so B ∈ P.
We now show that P-Block Vertex Deletion can be reduced to Subset
Feedback Vertex Set if the input graph is P-clusterable. The Subset Feed-
back Vertex Set problem can be solved in time O∗(4k) [22].
Subset Feedback Vertex Set
Parameter: k
Input: A graph G, a set X ⊆ V (G), and a non-negative integer k.
Question: Is there a set S ⊆ V (G) with |S| (cid:54) k such that no cycle in G − S
contains a vertex of X?
Proposition 3.2. Let P be a non-degenerate block-hereditary class of graphs rec-
ognizable in polynomial time. Given a P-clusterable graph G together with the set
of P-clusters of G, and a non-negative integer k, there is an O∗(4k)-time algorithm
that determines whether there is a set S ⊆ V (G) with |S| (cid:54) k such that G−S ∈ ΦP.
Proof. By Lemma 3.1, it is suﬃcient to determine whether G contains a set S ⊆
V (G) of size at most k that hits all cycles not contained in a P-cluster. To do this,

6

É. Bonnet, N. Brettell, O. Kwon, D. Marx

we perform a reduction to Subset Feedback Vertex Set. We construct a graph
G(cid:48) from G as follows. Let X ⊆ V (G) be the set of external vertices of G. For each
x ∈ X, let {H1, H2, . . . , Hm} be the set of P-clusters of G that x is contained in,
and introduce m vertices v(x, Hi) for each i ∈ {1, 2, . . . , m}. Then, do the following
for each x ∈ X. Recall that NHi(x) is the set of neighbors of x contained in Hi,
(x) := (NHi(x) \ X) ∪ {v(y, Hi) : y ∈ NHi(x) ∩ X}. Now remove all
and set N(cid:48)
edges incident with x, and, for each i ∈ {1, 2, . . . , m}, make v(x, Hi) adjacent to
(x)∪{x}. This completes the construction of G(cid:48). See Fig. 1 for an
each vertex in N(cid:48)
example of this construction. We claim that (G(cid:48), X, k) is a Yes-instance for Subset
Feedback Vertex Set if and only if G has a set of at most k vertices that hits
every cycle not contained in a P-cluster of G.

Hi

Hi

(a) G

(b) G(cid:48)

Fig. 1: Example construction of G(cid:48) from G, as described in Proposition 3.2.

Let S ⊆ V (G) such that every cycle of G − S is contained in a P-cluster of G.
Towards a contradiction, suppose there is a cycle C(cid:48) of G(cid:48) − S containing at least
one vertex v ∈ X. Note that G can be obtained from G(cid:48) by contracting each edge
incident to a vertex x ∈ X, where the resulting vertex is labeled x. Thus, we can
likewise obtain a cycle C of G − S by contracting each edge of C(cid:48) incident with a
vertex x in X, labeling the resulting vertex x, and relabeling any remaining vertices
not in V (G) by their unique neighbor in G(cid:48) that is a member of X. Suppose v is
adjacent to u and w in C. Then, by the construction of G(cid:48), u ∈ V (H) and w ∈ V (H(cid:48))
for distinct P-clusters H and H(cid:48) of G. Clearly, C is not contained in a P-cluster of
G unless u and w are (not necessarily distinct) external vertices; but this implies
that H and H(cid:48) share at least two vertices u and v, contradicting the fact that G is
P-clusterable. We deduce that no cycle of G(cid:48)−S contains a vertex in X, as required.
Now let S(cid:48) be a solution to Subset Feedback Vertex Set on (G(cid:48), X, k). By
the construction of G(cid:48), each vertex in V (G(cid:48)) \ V (G) is adjacent to precisely one
vertex in X. Let U be the set of vertices in X adjacent to a vertex in S(cid:48) \ V (G)
and set S := (S(cid:48) ∩ V (G)) ∪ U. Then |S| (cid:54) |S(cid:48)| and S ⊆ V (G). We claim that every
cycle of G − S is contained in a P-cluster. Suppose not; let C be a cycle of G − S
not contained in a P-cluster. Note that for each v ∈ V (C) ∩ X, the vertex v and
its neighbors in G(cid:48) are not in S(cid:48). Thus, we obtain a cycle C(cid:48) of G(cid:48) − S(cid:48) from C by
performing one of the two following operations for each vertex v ∈ V (C)∩ X, where
u and w are the two neighbors of v in C:
1. If there is a P-cluster H of G for which {u, v, w} ⊆ V (H), then relabel v in C

with the vertex in V (G(cid:48)) \ V (G) adjacent to {v} ∪ (NG(v) ∩ V (H)).

xH1H2H3H3H2H1xv(x;H3)v(x;H1)v(x;H2)Vertex deletion problems for graph classes with a block property

7
2. Otherwise, for some P-clusters H1 and H2 of G, we have that u ∈ V (H1)\V (H2),
v ∈ V (H1)∩ V (H2), and w ∈ V (H2)\ V (H1). In this case, we subdivide uv and
vw in C, labeling the new vertices v1 and v2 respectively, where vi is the vertex
in V (G(cid:48)) \ V (G) adjacent to {v} ∪ (NG(v) ∩ V (Hi)), for i ∈ {1, 2}.

As C is a cycle of G − S not contained in a P-cluster, at least one vertex x in
V (C) ∩ X has its neighbors in C in distinct P-clusters. By the second operation
above, x ∈ X is a vertex of C(cid:48); a contradiction. We conclude that every cycle of
G − S is contained in a P-cluster.
(cid:117)(cid:116)
By Proposition 3.2, the P-Block Vertex Deletion problem admits an ef-
ﬁcient FPT algorithm provided we can reduce the input to P-clusterable graphs.
In the next section, we show that this is possible for any ﬁnite block-hereditary P
where the permissible blocks in P have at most d vertices. In particular, we use this
to show there is an O∗(2O(k log d))-time algorithm for Bounded P-Block Vertex
Deletion.

3.2 An FPT Algorithm for Bounded P-Block Vertex Deletion
In this section we describe an FPT algorithm for Bounded P-Block Vertex
Deletion using the clustering approach. For positive integers x and y, let Bx,y be
the class of all biconnected graphs with at least x vertices and at most y vertices.
When x > y, Bx,y = ∅.
Lemma 3.3. Let P be a non-degenerate block-hereditary class, and let d (cid:62) 2 be an
integer. If a graph G is Bd+1,2d−2-free and (B2,d \ P)-free, then G is (P ∩ B2,d)-
clusterable.
Proof. Suppose G has distinct (P ∩ B2,d)-clusters H1 and H2 such that |V (H1) ∩
V (H2)| (cid:62) 2. Set G(cid:48) := G[V (H1)∪ V (H2)]. By the maximality of (P ∩B2,d)-clusters,
V (H1)\ V (H2) and V (H2)\ V (H1) are non-empty, so |V (G(cid:48))| (cid:62) 4. The graph G(cid:48)− v
is connected for every v ∈ V (G(cid:48)), so G(cid:48) is 2-connected. Since |V (G(cid:48))| (cid:54) 2d − 2, but
G is Bd+1,2d−2-free, |V (G(cid:48))| (cid:54) d. Hence, by the maximality of (P ∩ B2,d)-clusters,
G(cid:48) /∈ P, which contradicts the fact that G is (B2,d \ P)-free.
(cid:117)(cid:116)
Proposition 3.4. Let d (cid:62) 2 be an integer, and let P be a non-degenerate block-
hereditary class recognizable in polynomial time. There is a polynomial-time algo-
rithm that, given a graph G, either
(i) outputs an induced subgraph of G in B2,d \ P, or
(ii) outputs an induced subgraph of G in Bd+1,2d−2, or
(iii) correctly answers that G is ((B2,d \ P) ∪ Bd+1,2d−2)-free.
Proof. If d (cid:54) 2, then (iii) holds trivially, so we may assume otherwise. We show
that there is a polynomial-time algorithm FindObstruction that ﬁnds an induced
subgraph of G that is either in B2,d\P or in Bd+1,2d−2, if such an induced subgraph
exists. For brevity, we refer to either type of induced subgraph as an obstruction. In
the case that no obstruction exists, then G is (P ∩B2,d)-clusterable, by Lemma 3.3.
First, we give an informal description of FindObstruction (Algorithm 1). We
incrementally construct a biconnected induced subgraph G[X], starting with G[X]
as the shortest cycle of G, by adding the vertices of a non-trivial X-path to X.
If, at any increment, G[X] is an obstruction, then we return G[X]. Otherwise, we
eventually have that G[X] is in B2,d ∩P, but the union of G[X] and any non-trivial
X-path is not in Bd+1,2d−2. Now, if there is a non-trivial X-path that together
with a path in G[X] forms a cycle of length at most 2d − 2, then this cycle is an

8

É. Bonnet, N. Brettell, O. Kwon, D. Marx

Algorithm 1 FindObstruction(G, d)
Input: A graph G and an integer d > 2.
Output: An induced subgraph of G that is either in B2,d \ P or in Bd+1,2d−2; or No,
if no such induced subgraph exists.

1: Set H := ∅.

2: while the shortest cycle in G −(cid:83)

Set G(cid:48) := G −(cid:83)

H∈H E(H).

H∈H E(H) has length at most 2d − 2, do

Let X be the vertex set of the shortest cycle in G(cid:48).
if |X| (cid:62) d + 1 or G[X] /∈ P then

return G[X].

end if
while there is a non-trivial X-path P in G(cid:48) such that |X ∪ V (P )| (cid:54) d, do

(cid:46) G[X] ∈ P and |X| (cid:54) d

Set X := X ∪ V (P ).
if G[X] /∈ P then
return G[X].

3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:

(cid:46) G[X] ∈ P and |X ∪ V (P )| (cid:62) d + 1 for any non-trivial X-path P

end if
end while
if there is a non-trivial X-path P in G(cid:48) such that |X ∪ V (P )| (cid:54) 2d − 2, then
else if for some distinct u, v ∈ X, there is a uv-path P in G[X] and a uv-path P (cid:48)
in G(cid:48) − E(G[X]) with l(P ) + l(P (cid:48)) (cid:54) 2d − 2, then

return G[X ∪ V (P )].

(cid:46) No obstruction meets E(G[X])

return G[V (P ) ∪ V (P (cid:48))].

end if
Add G[X] to H.

17:
18:
19:
20: end while
21: return No.

is not an obstruction.

obstruction, and we return it. Otherwise, no obstruction intersects G[X] in any
edges, so we remove the edges of G[X] from consideration and repeat the process.
Now we prove the correctness of the algorithm. Since P is non-degenerate, K2
Consider an induced subgraph H := G[X] added to H at line 19. As the edges of
H are excluded in future iterations, we will show that these edges do not meet the
edges of any obstruction. That is, we claim that for every Y ⊆ V (G) such that G[Y ]
is an obstruction, E(H) ∩ E(G[Y ]) = ∅. Towards a contradiction, suppose G[Y ] is
an obstruction for some Y ⊆ V (G), and uv ∈ E(H) ∩ E(G[Y ]). Clearly |X| (cid:54) d,
and G[X] ∈ P. Note also that Y (cid:42) X, since |Y | (cid:54) d implies that G[Y ] /∈ P, but
G[X] ∈ P. Since G[Y ] is biconnected and not isomorphic to K2, it has a cycle
subgraph C that contains the edge uv. Let P be a non-trivial X-path in C. Since
there is a path in H of length at most d− 1 between any two distinct vertices in X,
it follows that P has length more than d− 1, otherwise there is a path satisfying the
conditions of line 16. Since |Y | (cid:54) 2d − 2, we deduce that there are no two distinct
X-paths in C. So C is the union of P and a path contained in H. Thus P is a
uv-path satisfying the conditions of line 16; a contradiction. This veriﬁes our claim.
Now we show that if G contains an obstruction, then the algorithm outputs an
obstruction. Suppose that G contains an induced subgraph J ∈ (B2,d\P)∪Bd+1,2d−2.
Since |V (J)| (cid:54) 2d − 2 and J is biconnected, but not isomorphic to K2, it contains
a cycle of length at most 2d − 2. So execution reaches line 2 and, from the previous
paragraph, J is a subgraph of in G(cid:48) as given in line 3. It is clear that the ﬂow
of execution will reach line 6, line 11, line 15, line 17, or line 19. Clearly, a graph
returned at line 6 is an obstruction. A graph returned at either line 11 or line 15 is
2-connected, since it has an obvious open ear decomposition (see, for example, [2,
Theorem 5.8]), and thus is easily seen to be an obstruction. If a graph is returned
at line 17, it is a cycle, and since l(P (cid:48)) (cid:62) d, such a graph is also in Bd+1,2d−2. By

Vertex deletion problems for graph classes with a block property

9

the previous paragraph, if execution reaches line 19, then E(G[X]) does not meet
E(J), so execution will loop, with |E(G(cid:48))| strictly smaller in the following iteration.
Thus, eventually the algorithm will ﬁnd either J, or another obstruction.
It remains to prove that the algorithm runs in polynomial time. We observe that
there will be at most O(m) loops of the outer ‘while’ block, and at most O(m) loops
of the inner ‘while’ block. Finding a shortest cycle, or all shortest X-paths for some
X ⊆ V (G), takes time O(n3) by the Floyd-Warshall algorithm. It follows that the
(cid:117)(cid:116)
algorithm runs in polynomial time.
Lemma 3.5. Let d (cid:62) 2 be an integer, and let P be a non-degenerate block-hereditary
class recognizable in polynomial time. Then there is a polynomial-time algorithm
that, given a ((B2,d \ P) ∪ Bd+1,2d−2)-free graph G, outputs the set of (P ∩ B2,d)-
clusters of G.
Proof. Let P(cid:48) = P ∩ B2,d. By Proposition 3.4, G is P(cid:48)-clusterable. We argue that
the algorithm Cluster (Algorithm 2) meets the requirements of the lemma.

Algorithm 2 Cluster(G)

Input: A (B2,d \ P)-free P(cid:48)-clusterable graph G.
Output: The set H of P(cid:48)-clusters of G.

Set X := X ∪ V (P ).

end while
Add G[X] to H.
Set G(cid:48) := G(cid:48) − E(G[X]).

1: Set H := ∅ and G(cid:48) := G.
2: while the shortest cycle in G(cid:48) has length at most d, do
Let X be the vertex set of the shortest cycle in G(cid:48).
3:
while there is a non-trivial X-path P in G(cid:48) such that |X ∪ V (P )| (cid:54) d, do
4:
5:
6:
7:
8:
9: end while
10: if G(cid:48) is edgeless, then
11:
12: else
13:
14: end if

return H.
return H ∪ {G(cid:48)[{x, y}] : x and y are adjacent in G(cid:48)}.

(cid:46) G[X] ∈ P
(cid:46) G[X] ∈ P
(cid:46) No obstruction meets E(G[X])

It is clear that this algorithm runs in polynomial time. We now prove correctness
of the algorithm. A graph G[X] at line 3 or line 5 is 2-connected, since it has an
obvious open ear decomposition, and in P, since G is (B2,d \ P)-free. By line 7, the
graph G[X] has the property that, for any non-trivial G[X] path P , |X∪V (P )| > d.
So any 2-connected graph containing G[X] as a proper subgraph consists of at least
d + 1 vertices, and hence is not in P(cid:48). This proves that G[X] is indeed a P(cid:48)-cluster.
Since G is P(cid:48)-clusterable, any P(cid:48)-cluster distinct from G[X] does not share any
edges with G[X], so we can safely remove them from consideration, and repeat this
procedure. If G contains no cycles of length at most d, then the only remaining
(cid:117)(cid:116)
biconnected components are isomorphic to K1 or K2.
Theorem 3.6. Let P be a non-degenerate block-hereditary class of graphs recog-
nizable in polynomial time. Then Bounded P-Block Vertex Deletion can be
solved in time 2O(k log d)nO(1).
Proof. We describe a branching algorithm for Bounded P-Block Vertex Dele-
tion on the instance (G, d, k). If G contains an induced subgraph in (B2,d \ P) ∪
Bd+1,2d−2, then any solution S contains at least one vertex of this induced sub-
graph. We ﬁrst run the algorithm of Proposition 3.4, and if it outputs such an

10

É. Bonnet, N. Brettell, O. Kwon, D. Marx

induced subgraph J, then we branch on each vertex v ∈ V (J), recursively applying
the algorithm on (G − v, d, k − 1). Since |V (J)| (cid:54) 2d − 2, there are at most 2d − 2
branches. If one of these branches has a solution S(cid:48), then S(cid:48) ∪ {v} is a solution for
G. Otherwise, if every branch returns No, we return that (G, d, k) is a No-instance.
On the other hand, if there is no such induced subgraph, then G is (P ∩ B2,d)-
clusterable, by Lemma 3.3, and we can ﬁnd the set of all (P ∩ B2,d)-clusters in
polynomial time, by Lemma 3.5. We can now run the O∗(4k)-time algorithm of
Proposition 3.2 and return the result. Thus, an upper bound for the running time
is given by the following recurrence:

1

T (n, k) =

4knO(1)
(2d − 2)T (n − 1, k − 1) + nO(1)

if k = 0 or n = 0,
if ((B2,d \ P) ∪ Bd+1,2d−2)-free,
otherwise.

Hence, we have an algorithm that runs in time O∗(2O(k log d)).

(cid:117)(cid:116)

4 Bounded P-Block Vertex Deletion Lower Bounds
4.1 A Tight Lower Bound

The Exponential-Time Hypothesis (ETH), formulated by Impagliazzo, Paturi, and
Zane [10], implies that n-variable 3-SAT cannot be solved in time 2o(n). We now
argue that the previous algorithm is essentially tight under the ETH.
The k × k Clique problem takes as input an integer k and a graph on k2
vertices, each vertex corresponding to a distinct point of a k by k grid, and asks
for a clique of size k hitting each column of the grid exactly once. Unless the ETH
fails, k×k Clique is not solvable in time 2o(k log k) [17]. However, solving Bounded
P-Block Vertex Deletion in 2o(k log d) time, where P contains all biconnected
split graphs, implies that k × k Clique can be solved in 2o(k log k) time.
Theorem 1.2. Let P be a block-hereditary class. If ΦP contains all split graphs,
then Bounded P-Block Vertex Deletion is not solvable in time 2o(k log d),
unless the ETH fails.
Proof. In [6], the authors show that Component Order Connectivity cannot
be solved in 2o(k log d) time unless the ETH fails. We adapt their reduction from
k × k Clique. We recall that a split graph is a graph whose vertex set can be par-
titioned into two sets, one inducing a clique and the other inducing an independent
set. Let (G, k) be an instance of k × k Clique. Since the edges between vertices
in the same column cannot be involved in a solution, we may assume that each
column induces an independent set. Then (G, k) is a Yes-instance if and only if
G has a k-clique. We build an instance (G(cid:48), d, k(cid:48)) of Bounded P-Block Vertex
Deletion where V (G(cid:48)) = Q ∪ I for Q = V (G) ∪ E1 and I = E2, where E1 and
E2 are two copies of E(G). For each edge e ∈ E(G), we denote by e1 (resp. e2) the
corresponding vertex in E1 (resp. in E2). The set Q induces a clique while I induces
an independent set. For each edge e = uv ∈ E(G), we add three edges ue2, ve2 and
e1e2 in G(cid:48), each between a vertex in Q and a vertex in I. This ends the construc-
tion of G(cid:48). Observe that G(cid:48) is a split graph and the vertices in I all have degree 3.

We set k(cid:48) := k and d := |V (G(cid:48))| − k −(cid:0)k
d (cid:62) k2 − k −(cid:0)k
instance (G(cid:48), d, k(cid:48)). Indeed, for each of the(cid:0)k

(cid:1). Note that |V (G(cid:48))| (cid:62) |V (G)| = k2, so
(cid:1). Without loss of generality we may assume that k (cid:62) 3, and
(cid:1) pairs (i, j) with i < j ∈ [k], the vertex

(cid:1) =(cid:0)k

2

2

hence d (cid:62) 2.
Assume that G admits a k-clique S = {v1, . . . , vk}, and denote vivj by eij.
We claim that S is a solution for Bounded P-Block Vertex Deletion on the

2

2

Vertex deletion problems for graph classes with a block property

11

ij, is a cut vertex. Hence, e2

ij has degree 1 in G(cid:48) − S, so its unique neighbor, e1
ij is
e2
not in the block containing the clique Q \ S. Therefore, the blocks of G(cid:48) − S have
We now assume that there is a set S ⊆ V (G(cid:48)) of at most k vertices such that
all the blocks of G(cid:48) − S have at most d vertices. We call the main block the one
containing Q\ S. The only vertices of G(cid:48) − S that are not in the main block are the
vertices X of I with degree at most 1 in G(cid:48) − S. Since the main block has at most

at most |V (G(cid:48))| − k −(cid:0)k
(cid:1) vertices.
d vertices, there are at least(cid:0)k
the(cid:0)k
(cid:1) edges of a k-clique in G.

(cid:1) vertices in X. This implies that X corresponds to

2

Since |V (G)| = k2, we have that |E(G)| = O(k4). Thus d = O(k4) and log d =
O(log k). Therefore, solving Bounded P-Block Vertex Deletion in 2o(k log d)
time would also solve k × k Clique in time 2o(k log k), contradicting the ETH. (cid:117)(cid:116)

2

2

4.2 W [1]-hardness Parameterized Only by k
We now prove that Bounded P-Block Vertex Deletion is W [1]-hard when
parameterized only by k, if P is a class such that ΦP contains all split graphs. In
particular, this implies that Bounded Block VD is W [1]-hard when parameter-
ized only by k. The reduction is similar to that in Section 4.1, but the reduction is
from Clique, rather than k × k Clique.
Proposition 1.3. Let P be a block-hereditary class. If ΦP contains all split graphs,
then Bounded P-Block Vertex Deletion is W [1]-hard when parameterized
only by k.
Proof. Consider an instance (G, k) of the problem Clique where, given a graph G
and integer k, the question is whether G has a k-clique. Observe that we can perform
the same reduction given in the proof of Theorem 1.2 but from Clique, rather than
k × k Clique. By doing so, we build an instance (G(cid:48), d, k) of Bounded P-Block
Vertex Deletion where G(cid:48) is a split graph, and for which S is a solution for the
instance (G(cid:48), d, k) if and only if S is a k-clique of G. Since the reduction is parameter
preserving, the result then follows from the fact that Clique is W [1]-hard when
(cid:117)(cid:116)
parameterized by the size of the solution [5].
5 O∗(ck)-time Algorithms Using Iterative Compression
We now consider the specializations of Bounded P-Block Vertex Deletion
that we refer to as Bounded Complete Block VD and Bounded Cactus
Graph VD. These problems are “bounded” variants of Complete Block Vertex
Deletion and Diamond Hitting Set, respectively, which are known to admit
cknO(1) ﬁxed-parameter tractable algorithms for some constant c. By Theorem 3.6,
Bounded Complete Block VD and Bounded Cactus Graph VD can be
solved in O∗(2O(k log d)) time. However, the next two theorems show that these
problems are in fact FPT parameterized only by k, and, like their “unbounded”
variants, each has a cknO(1)-time algorithm. The proofs of these results use the
well-known technique of iterative compression [19], which we now brieﬂy recap.

In a nutshell, the idea of iterative compression is to try and build a solution of
size k given a solution of size k + 1. It is typically used for graph problems where
one wants to remove a set S of at most k vertices such that the resulting graph
satisﬁes some property or belongs to some class. We call such a set S a solution or
a deletion set. Say S is a solution of size k + 1 for a problem Π on a graph G that
we want to compress into a solution R of size at most k. We can try out all 2k+1
possible intersections of old and new solutions I = S ∩ R. In each case, we remove
I from G and look for a solution of size at most k − |I| that does not intersect

12

É. Bonnet, N. Brettell, O. Kwon, D. Marx

i=0

i

(cid:0)k+1
(cid:1)ck−i) = O∗((c + 1)k). We can start with a subgraph of G induced by

S \ I. We call Disjoint Π this new problem of ﬁnding a solution of size at most k
that does not intersect a given deletion set S of size up to k + 1. If we can solve
Disjoint Π in time O∗(ck), then the running time of this approach to solve Π is
O∗(Σk+1
any set of k + 1 vertices. Those k + 1 vertices constitute a trivial deletion set. After
one compression step, we obtain a solution of size k. Then, a new vertex is added
to the graph and immediately added to the deletion set. We compress again, and so
on. After a linear number of compressions, we have added all the vertices of G, so
we have a solution for G. For more about iterative compression, we refer the reader
to Cygan et al. [4], or Downey and Fellows [5].

5.1 Bounded Complete Block VD
Theorem 1.4. Bounded Complete Block VD can be solved in time O∗(10k).

Proof. It is suﬃcient to solve Disjoint Bounded Complete Block VD in time
O∗(9k). Let (G, S, d, k) be an instance where S is a deletion set of size k + 1. We
present an algorithm that either ﬁnds a solution R of size at most k not intersecting
S, or establishes that there is no such solution. For convenience, G, S, and R are not
ﬁxed objects; they represent, respectively, the remaining graph, the set of vertices
that we cannot delete, and the solution that is being built, throughout the execution
of the algorithm. Initially, R is empty. For an instance I = (G, S, d, k), we take as a
measure µ(I) = k + cc(S), where cc(S) is the number of connected components of
G[S]. Thus, µ(I) (cid:54) 2k + 1. We say a graph G is a d-complete block graph if every
block of G is a clique of size at most d. We present two reduction rules and three
branching rules that we apply while possible.
Reduction Rule 5.1. If there is a vertex u ∈ V (G) \ S with degree at most 1 in
G, then we remove u from G.

The soundness of this rule is straightforward.
Reduction Rule 5.2. If there is a vertex u ∈ V (G)\ S such that G[S ∪{u}] is not
a d-complete block graph, then remove v from G, put v in R, and decrease k by 1.

This reduction rule is safe since any induced subgraph of a d-complete block graph
is itself a d-complete block graph. Here, an obstruction is a 2-connected induced
subgraph that is not a clique of size at most d. At least one vertex of any obstruction
should be in a solution. We can restate the rule as follows: if a vertex u ∈ V (G) \ S
forms an obstruction with vertices of S, then u is in any solution. We also observe
that if a graph contains no obstruction, then it is a d-complete block graph.
Branching Rule 5.1. If there are distinct vertices u and v in G − S such that
G[S ∪ {u, v}] is not a d-complete block graph, then branch on either removing u
from G, putting u in R, and decreasing k by 1; or removing v from G, putting v in
R, and decreasing k by 1.

This branching rule is exhaustive since at least one of u and v has to be in R, as
G[S ∪ {u, v}] contains an obstruction. In both subinstances µ(I) is decreased by 1,
so the associated branching vector for this rule is (1, 1).
Branching Rule 5.2. If there is a vertex u ∈ V (G) \ S having two neighbors
v, w ∈ S such that v and w are in distinct connected components of G[S], then
branch on either removing u from G, putting u in R, and decreasing k by 1; or
adding u to S.

Vertex deletion problems for graph classes with a block property

13

If u is added to S, then the number of connected components in G[S] decreases by
at least 1. This branching rule is exhaustive and in both cases µ(I) is decreased by
at least 1, so the associated branching vector is (1, 1).
Branching Rule 5.3. Suppose there is an edge uv of G − S such that u has a
neighbor u(cid:48) ∈ S and v has a neighbor v(cid:48) ∈ S, and u(cid:48) and v(cid:48) are in distinct connected
components of G[S]. We branch on three subinstances:

(a) remove u from the graph, put it in R, and decrease k by 1,
(b) remove v from the graph, put it in R, and decrease k by 1, or
(c) put both u and v in the set S.

Again, this branching rule is exhaustive: either u or v is in the solution R, or they
can both be safely put in S. In branch (c), the number of connected components
of G[S] decreases by at least 1. Therefore, the associated branching vector for this
rule is (1, 1, 1).
Applying the two reduction rules and the three branching rules presented above
preserves the property that G − S is a d-complete block graph. The algorithm ﬁrst
applies these rules exhaustively (see Algorithm 3), so we now assume that we can
no longer apply these rules.
Let x be a vertex V (G) \ S and consider its neighborhood in S. We claim that
this neighborhood is either empty, a single vertex, or all the vertices of some block
of G[S]. Suppose x has at least two neighbors y and z in S. Then, since Branching
Rule 5.2 cannot be applied, y and z are in the same connected component of G[S].
Now, if no block of G[S] contains both y and z, then x forms an obstruction with
vertices in S, contradicting the fact that Reduction Rule 5.2 cannot be applied. It
follows that the vertices of the block containing y and z, together with x, form a
clique. Moreover, x has no other neighbors. This proves the claim.
Let C be the vertex set of a leaf block of G − S. We know that C is a clique
of size at most d, and the block G[C] of G − S has at most one cut vertex. If the
block G[C] of G − S has a cut vertex v, let C(cid:48) := C \ {v}; otherwise, let C(cid:48) := C.
We use this notation in all the remaining reduction and branching rules. The next
three rules handle the case where at most one vertex in C has neighbors in S.
Reduction Rule 5.3. If none of the vertices in C(cid:48) have neighbors in S, then re-
move C(cid:48) from G.
If the block G[C] of G − S does not have a cut vertex, then C(cid:48) is a connected
component of G, so we obtain an equivalent instance after removing C(cid:48) from G. If
the block G[C] of G − S has a cut vertex v, then either v is in the solution R, and
C(cid:48) is a clique of size at most d that is a connected component of G − R; or v is in
the d-complete block graph G − R, and G[C] is a leaf block of this graph. In either
case, no vertex in C(cid:48) can be in an obstruction. Each vertex not in any obstruction
can be removed from G without changing the value of k.

The soundness of the next rule follows from a similar argument.

Reduction Rule 5.4. If the block G[C] of G−S does not have a cut vertex, w ∈ C
has at least one neighbor in S, and each vertex in C \ {w} has no neighbor in S,
then put C in S.
Reduction Rule 5.5. If the block G[C] of G − S has a cut vertex, w ∈ C(cid:48) has at
least one neighbor in S, and each vertex in C \ {w} has no neighbor in S, then put
w in S.

In order to show that this rule is sound, we now prove that if R is a solution
containing w, then (R \ {w}) ∪ {v} is also a solution. Since Reduction Rule 5.2

14

É. Bonnet, N. Brettell, O. Kwon, D. Marx

cannot be applied, w together with its neighborhood in S forms a maximal clique
in G, and this clique consists of at most d vertices. Suppose R\{w} is not a solution.
Then G − (R \ {w}) contains some obstruction, and any such obstruction contains
w. Since w is not contained in a clique of size more than d in G, every minimal
obstruction is either a diamond or an induced cycle. Since Branching Rule 5.1
cannot be applied, w is not contained in an induced diamond subgraph of G. But
every induced cycle containing w and not contained in S ∪ {w} must contain v,
which proves the claim.

Now, we consider the case where at least two vertices in C each have at least
one neighbor in S. Let x and y be two such vertices. We claim that x and y have the
same neighborhood in S. Since C is a clique, x and y are adjacent. As Branching
Rule 5.3 does not apply, the neighbors of x and y in S are all in the same component
of G[S]. Now, if the neighborhoods of x and y diﬀer, then G[S ∪{x, y}] contains an
obstruction, so Branching Rule 5.1 can be applied; a contradiction. This proves the
claim.
Thus, C can be partitioned into C1 ∪ C2 where the vertices of C1 all share the
same non-empty neighborhood in S, while the vertices of C2 have no neighbor in
S. The previous three reduction rules handled the case where |C1| (cid:54) 1. We now
handle the case where |C1| (cid:62) 2.
Reduction Rule 5.6. If all the vertices of C have the same non-empty neighbor-
hood A in S (that is, C2 = ∅), then remove any s := max{0,|C(cid:48)| − d + |A|} vertices
of C(cid:48) from G, put them in R, decrease k by s, and put the remaining vertices of C(cid:48)
in S.
Firstly, note that if C contains a cut vertex v and |C ∪ A| (cid:54) d, it is always better to
have v in R rather than a vertex of C(cid:48). So, in this case, we can safely add the vertices
of C(cid:48) to S, and, after doing so, G[S] is still a d-complete block graph. However, when
|C ∪ A| > d, we have to put some vertices of C(cid:48) in R, since C ∪ A is a clique. As
these vertices are twins (that is, they have the same closed neighborhood), it does
not matter which s vertices of C(cid:48) we choose.
In the ﬁnal case, where |C1| (cid:62) 2 and |C2| (cid:62) 1, we use the following branching

rule:
Branching Rule 5.4. Suppose there are at least two vertices of C having the same
non-empty neighborhood in S (that is, |C1| (cid:62) 2) and at least one vertex of S having
no neighbor in S (that is, |C2| (cid:62) 1). We branch on two subinstances:
(a) remove all the vertices of C2 from G, put them in R, and decrease k by |C2|, or
(b) choose any vertex x ∈ C1 ∩ C(cid:48), then remove all the vertices of C1 \ {x}, put

them in R, and decrease k by |C1| − 1.

We now argue that this branching rule is sound. Let x and y be distinct vertices in
C1, and let z be in C2. Then, for any common neighbor t ∈ S of x and y, the set
{t, x, y, z} induces a diamond in G, which is an obstruction. In order to eliminate
all such obstructions, we must remove vertices from G so that either C2 is empty,
as in (a), or |C1| (cid:54) 1, as in (b). In case (b), we can safely pick x ∈ C(cid:48) as the vertex
not added to R since it is always preferable to add a cut vertex of G − S in C to
R, rather than a vertex in C(cid:48). In either subinstance, the measure is decreased by at
least 1, so the associated branching vector is (1, 1).

Once we apply one rule among Reduction Rules 5.3 to 5.6 and Branching
Rule 5.4, we check whether or not the ﬁrst set of rules can be applied again (see
Algorithm 3).
The algorithm ends when G − S is empty, or if k becomes negative, in which
case there is no solution at this node of the branching tree. Indeed, while G− S has
at least one vertex, there is always some rule to apply. When G − S is empty, R is

Vertex deletion problems for graph classes with a block property

15

Algorithm 3 Disjoint-BoundedCompleteBlockVD(G, S, d, k)

Input: A graph G, a subset of vertices S, and two integers d and k.
Output: A set R of size at most k such that R ∩ S = ∅ and G − R is a d-complete
block graph.
1: Set R := ∅.
2: while k (cid:62) 0 and G − S is non-empty do
3:

if Reduction Rules 5.1 and 5.2 or one of Branching Rules 5.1 to 5.3 can be applied
then

Apply one of Reduction Rules 5.3 to 5.6, or Branching Rule 5.4

Apply this rule

else

4:
5:
6:
end if
7:
8: end while
9: if k (cid:62) 0 then
return R.
10:
11: end if

a solution for (G, S, d, k). Each reduction rule can only be applied a linear number
of times since they all remove at least one vertex from G. Thus, the overall running
time is bounded above by the slowest branching, namely the one with the branching
(cid:117)(cid:116)
vector (1, 1, 1), for which the running time is O∗(3µ(I)) = O∗(9k).

5.2 Bounded Cactus Graph VD
Theorem 1.5. Bounded Cactus Graph VD can be solved in time O∗(26k).
Proof. As in the proof of Theorem 1.4, it suﬃces to solve Disjoint Bounded
Cactus Graph VD in time O∗(25k).

For a positive integer d, we say a d-cactus is a graph where each block con-
taining at least two vertices is either a cycle of length at most d or an edge (d-
cactus graphs are a subclass of cactus graphs). Similarly to Disjoint Bounded
Complete Block VD, we take as a measure µ(I) = k + cc(S) for an instance
I = (G, S, d, k), we denote by R the solution that we build, and an obstruction is
a 2-connected induced subgraph that is not a cycle of size at most d. As all the
vertices of S will be in the graph G − R, there can only be a solution to Disjoint
Bounded Cactus Graph VD if G[S] is a d-cactus. Indeed, observe that any in-
duced subgraph of a d-cactus is itself a d-cactus. We now assume that G[S] is a
d-cactus. As S is a solution, G− S is also a d-cactus. We will preserve the property
that the blocks of both G[S] and G[V (G) \ S] are either cycles of length at most d,
or consist of a single edge.

We begin by applying the following four rules while possible. The ﬁrst two
of these are Reduction Rule 5.1 and Branching Rule 5.2. Recall that this latter
branching rule is exhaustive, and its associated branching vector is (1, 1) for the
measure µ.
Reduction Rule 5.7. If there is a vertex u ∈ V (G) \ S such that G[S ∪ {u}] is
not a d-cactus, then remove u from the graph, put u in R, and decrease k by 1.

Again, this rule is sound since any induced subgraph of a d-cactus is a d-cactus.

We deﬁne a red vertex as a vertex of V (G) \ S that has at least one neighbor
in S. We say that two distinct red vertices are consecutive red vertices if they are
both contained in some block of G − S and there is a path between them in which
all the internal vertices have degree 2 in G. Let a and b be vertices that are either
red, or of degree at least 3, or in S, with the additional constraint that a and b are

16

É. Bonnet, N. Brettell, O. Kwon, D. Marx

not both in S. A chain from a to b, or simply a chain, is the set of internal vertices,
all of degree 2, of a path between a and b.

Branching Rule 5.5. Suppose v and w are consecutive red vertices in a block of
G − S, where s ∈ S is a neighbor of v, the vertex t ∈ S is a neighbor of w, and s
and t are in distinct connected components of G[S]. Then, either

(a) remove v from G, put v in R, and decrease k by 1; or
(b) remove w from G, put w in R, and decrease k by 1; or
(c) put {v, w} ∪ P in S, where P is a chain from v to w.
This branching rule is safe since for any solution R(cid:48) that does not contain v nor w
but contains a vertex z of the chain P , the set (R(cid:48) \ {z}) ∪ {v} is also a solution.
As we use this observation several times, we state it as a lemma.
Lemma 5.1. If there is a solution, then there is one that does not contain any
vertex of a chain.

Proof. In any solution, we may replace a vertex in a chain P by the (at least) one
(cid:117)(cid:116)
vertex not in S among the two vertices in the open neighborhood of P .
The branching vector of Branching Rule 5.5 is (1, 1, 1) since in the ﬁrst two cases

k decreases by 1, and in the third cc(S) decreases by 1.

Whenever these four rules cannot be applied, we claim that:

(1) every vertex of V (G) \ S has degree at most 2 in S, and
(2) the neighborhood in S of the set of red vertices in a block is contained in some

connected component of G[S].

Indeed, since Branching Rule 5.2 is not applicable, a vertex w of V (G) \ S has
neighbors in at most one connected component in G[S]. Now, suppose w has at
least three neighbors a, b, and c in the same connected component. Then waP1bw
and wbP2cw, where P1 is an ab-path in G[S] and P2 is a bc-path in G[S], are distinct
cycles that intersect on at least w and b. Hence, Reduction Rule 5.7 applies for w; a
contradiction. Finally, we see that (2) holds because otherwise Branching Rule 5.5
would apply.

Now, we assume that the ﬁrst four rules do not apply (see Algorithm 4).

Branching Rule 5.6. Let u, v, and w be distinct vertices of a block of G − S. If
u and v are consecutive red vertices, and v and w are consecutive red vertices, then
branch on putting either u, or v, or w into the solution R. In each case, remove the
vertex from G and decrease k by 1.

By (2), the neighbors in S of u, v and w are in the same connected component of
G[S]. Therefore, a set consisting of u, v, w, the two chains from u and v and from v
and w, and S induces a graph that contains a subdivision of a diamond, hence is an
obstruction. By Lemma 5.1, we conclude that branching on the three red vertices
u, v, and w is safe. The branching vector is again (1, 1, 1).
We now deal with leaf blocks in G− S that consist of a single edge. We call such

a block a leaf edge.
Reduction Rule 5.8. Suppose uv is a leaf edge in G − S where u is a red vertex
of degree 1 in S, and v is either a cut vertex of G − S or a red vertex of degree 1 in
S. Then, put u in S.
If v is a cut vertex, then this rule is safe by Lemma 5.1 since {u} is a chain.
Otherwise, for any solution R(cid:48) containing u, the set (R(cid:48) \ {u}) ∪ {v} is also a
solution.

Vertex deletion problems for graph classes with a block property

17

Branching Rule 5.7. Suppose uv is a leaf edge in G − S, where u and v are red
vertices, and u has two neighbors in S. Then, branch on putting either u or v into
the solution R. In either case, remove the vertex from G and decrease k by 1.
By (2), G[S ∪ {u, v}] contains an obstruction, so this rule is safe. The branching
vector is (1, 1).

When these rules have been applied exhaustively, we claim that

(3) each block of G − S contains at most two red vertices, and
(4) each leaf edge of G − S has one red vertex, and this vertex is not a cut vertex

of G − S, and has degree 2 in S.

The ﬁrst claim follows immediately from the fact that Branching Rule 5.6 cannot
be applied. Now suppose G − S has a leaf edge consisting of vertices u and v. Since
Reduction Rule 5.1 cannot be applied, u and v are either both red, or one is red
and the other is a cut vertex of G − S. If they are both red, then either Branching
Rule 5.7 can be applied, if u or v has degree at least 2 in S, or Reduction Rule 5.8
can be applied, if u and v both have degree 1 in S; a contradiction. So we may
assume that only u is red, and v is a cut vertex of G − S. In this case, by (1) and
since Reduction Rule 5.8 cannot be applied, u has degree 2 in S.

Now, we apply one of the following three rules, if possible.

Branching Rule 5.8. Suppose u and v are distinct (consecutive) red vertices in
a leaf block that is not an edge. If this leaf block has a cut vertex in G − S distinct
from u and v, denote it by w. We branch on putting either u, or v, or w (if the leaf
block has a cut vertex in G − S distinct from u and v) into the solution R and, in
each case, remove the vertex from G and decrease k by 1.
Again, the graph induced by the union of the vertices of this leaf block and S con-
tains an obstruction since the leaf block is a cycle, and (2) holds. So, by Lemma 5.1,
it is safe to branch on u, or v, or w. The branching vector is (1, 1, 1) (or (1, 1) if the
leaf block does not have a cut vertex in G − S or if w ∈ {u, v}).
Reduction Rule 5.9. Suppose C(cid:48) is the set of vertices of a leaf block of G − S
that are not cut vertices of G − S. If every vertex in C(cid:48) is not red, then remove C(cid:48)
from G. Otherwise, if the leaf block is a connected component of G− S and exactly
one vertex u of C(cid:48) is red, then remove C(cid:48) \ {u} from G.
Reduction Rule 5.10. If there is a leaf block in G − S where the unique red
vertex u is not a cut vertex of G − S and u has only one neighbor in S, then put u
in S.

The soundness of Reduction Rule 5.9 is straightforward. Reduction Rule 5.10 is safe
because in any solution that contains u, we can remove u and add the cut vertex of
the leaf block instead.

We claim that, when none of the previous rules apply,

(5) each leaf block of G − S has one red vertex, and this vertex is not a cut vertex

of G − S, and has degree 2 in S.

Indeed, the claim holds when the leaf block is a leaf edge, by (4). Consider a leaf
block of G − S that is not a leaf edge. It follows from (3) and Branching Rule 5.8
that it contains at most one red vertex. If it contains no red vertices, or the only red
vertex is a cut vertex of G − S, then Reduction Rule 5.9 applies; a contradiction.
So the block has one red vertex, and this vertex is not a cut vertex of G − S, and
has degree at most 2 in S, by (1). Suppose it has degree 1 in S. Since it is not a cut
vertex, Reduction Rule 5.10 applies; a contradiction. So the vertex has degree 2 in
S. This proves (5).

18

É. Bonnet, N. Brettell, O. Kwon, D. Marx

Now, we try the following branching rules where B := B(G − S) is the block
tree of G − S. Suppose B1 is a leaf of B, and, for some h (cid:62) 2, there is a path
B1c1B2c2 ··· Bh−1ch−1Bh such that the vertices c1, B2, c2, . . . , Bh−1, ch−1 have de-
gree 2 in B, the blocks B2, B3, . . . , Bh−1 contain no red vertex, and Bh contains a
red vertex w such that there is a chain P linking w to ch−1. We may assume, by (5),
that B1 has one red vertex v, which is distinct from c1, and v has two neighbors in
some connected component C of G[S].
Branching Rule 5.9. If w has a neighbor in the connected component C, then
branch on putting either v, or w, or ch−1 into the solution R. In each case, remove
the vertex from G and decrease k by 1.

(a) An example of Branching
Rule 5.9, with h = 4. The obstruc-
tion is shown in red (light gray),
and v, c3, and w are the three ver-
tices to branch on.

(b) An example of Branching
Rule 5.12. Either one vertex among
v, x, y, w is in the solution R, or all
the vertices in the boxed region are
not in the solution R.

Fig. 2: Illustrations of Branching Rules 5.9 and 5.12.

To show that this rule is sound, we need a lemma analogous to Lemma 5.1 for a
“chain of blocks”, which we now deﬁne. Let h (cid:62) 3, and let B1, B2, . . . , Bh be a set
of blocks of G− S that, except for B1 and Bh, contain no red vertices, and for each
i ∈ {2, 3, . . . , h − 1}, the block Bi intersects two other blocks in G − S: Bi−1 and
Bi+1. The sequence of blocks B2, B3, . . . , Bh−1 is called a chain of blocks.
Lemma 5.2. If there is a solution, then there is one that does not contain any
vertex of a chain of blocks, except potentially the cut vertex shared by Bh−1 and Bh.
Proof. By hypothesis, Bh shares one cut vertex ch−1 with Bh−1. From any solution
that contains a vertex v in some block in {B2, B3, . . . , Bh−1}, one can obtain a new
(cid:117)(cid:116)
solution by replacing v by ch−1.
Recall that P is a chain from ch−1 to w. The subgraph induced by V (B1) ∪
V (B2)∪···∪V (Bh−1)∪P∪{w}∪V (C) contains an obstruction. So, by a combination
of Lemmas 5.1 and 5.2, we can safely branch on the three vertices v, w and ch−1.
The branching vector is (1, 1, 1).
Branching Rule 5.10. If w has a neighbor in S in a diﬀerent connected compo-
nent than C, then branch on putting either v, or w, or ch−1 into the solution R, or
put V (B1) ∪ V (B2) ∪ ··· ∪ V (Bh−1) ∪ P ∪ {w} in S. In each of the ﬁrst three cases,
we remove the vertex from G and decrease k by 1.

vwSB1B2B3c3B4vwxySVertex deletion problems for graph classes with a block property

19

The correctness of this rule is also based on Lemma 5.2. In the fourth branch, cc(S)
decreases by 1, so the branching vector is (1, 1, 1, 1).
Once again, we assume that none of the previous rules apply. Let B(cid:48) be a con-
nected component of the block tree B of G − S. Assume B(cid:48) has a node that is not
a leaf and let us root B(cid:48) at this node. For a vertex a with two neighbors b and
c, the operation of smoothing a consists of deleting a and adding the edge bc. Let
T be the rooted tree that we obtain by smoothing each vertex of degree 2 that is
not the root (and keeping the same root). We now consider the parent node p of
leaves at the largest depth of T . We assume that p is a block C. If p is a cut vertex,
we get a simpliﬁed version of what follows. As p was not smoothed, it has at least
two children in T , which, by construction, are leaf blocks. We say that two distinct
cut vertices x and y are consecutive cut vertices if they are both contained in some
block of G − S and there is a chain from x to y. We consider two consecutive cut
vertices x and y in C, and let Bx and By be children of p in T such that Bx ··· xC
and By ··· yC are paths of B for which the internal vertices have degree 2. Observe
that we can ﬁnd two consecutive cut vertices in C, since if one of the vertices of the
xy-path in C is red, then either Branching Rule 5.9 or Branching Rule 5.10 would
apply. Let v (resp. w) be the red vertex in Bx (resp. By). Recall that v and w have
two neighbors in S. We branch in the following way:

Branching Rule 5.11. If v and w have their neighbors in S in the same connected
component of G[S], then branch on putting either v, or w, or x, or y into the
solution R. In each case, remove the vertex from G and decrease k by 1.

Branching Rule 5.12. If v and w have their neighbors in S in distinct connected
components of G[S], then branch on putting either v, or w, or x, or y into the
solution R, or put all of them in S together with the chain from x to y and all the
vertices of the blocks in the path from x to Bx in B and in the path from y to By
in B. In each of the ﬁrst four cases, remove the vertex from G and decrease k by 1.

The soundness of these two branching rules is similar to Branching Rules 5.9
and 5.10 and relies on the fact that there is a chain from x to y. Their branch-
ing vectors are (1, 1, 1, 1) and (1, 1, 1, 1, 1) respectively.
Finally, if none of the previous rules apply, the connected components of G − S
contain exactly one red vertex. This implies that each of these connected components
is a single vertex. Therefore, G − S is an independent set and all the vertices of
V (G)\S have exactly two neighbors in S. At this point, we could ﬁnish the algorithm
in polynomial time by observing that the problem is now equivalent to the problem
where, given a set of paths in a forest, the task is to ﬁnd a maximum-sized subset
such that the paths are pairwise edge-disjoint. An alternative is to ﬁnish with the
following simple rule.
Branching Rule 5.13. If v and w are two vertices of V (G) \ S such that G[S ∪
{v, w}] contains an obstruction, then branch on putting either v or w into the
solution R. In either case, remove the vertex from G and decrease k by 1.

The soundness of this rule is straightforward and the branching vector is (1, 1).
When Branching Rule 5.13 cannot be applied, then all the remaining vertices of
V (G) \ S can safely be put in S.
the worst branching vector (1, 1, 1, 1, 1), that is O∗(5µ(I)) = O∗(25k).

The running time of Disjoint Bounded Complete Block VD is given by
(cid:117)(cid:116)

6 Polynomial Kernels

In this section, we prove the following:

20

É. Bonnet, N. Brettell, O. Kwon, D. Marx

Algorithm 4 Disjoint-BoundedCactusGraphVD(G, S, d, k)
Input: A graph G, a subset of vertices S, and two integers d and k.
Output: A set R of size at most k such that R∩ S = ∅ and G− R is a d-cactus graph.

1: Set R := ∅.
2: while k (cid:62) 0 and G − S is non-empty do
3:

if Reduction Rule 5.1, or Branching Rule 5.2, or Reduction Rule 5.7, or Branching
Rule 5.5 can be applied then

Apply it

4:
5:

6:
7:

else if Branching Rule 5.6, or Reduction Rule 5.8, or Branching Rule 5.7 can be
applied then
Apply it

else if Branching Rule 5.8, or Reduction Rule 5.9, or Reduction Rule 5.10 can be
applied then
Apply it

else if Branching Rule 5.9 or Branching Rule 5.10 can be applied then

else if Branching Rule 5.11 or Branching Rule 5.12 can be applied then

Apply it

Apply it

8:
9:
10:
11:
12:
end if
13:
14: end while
15: while Branching Rule 5.13 can be applied do
16:
Apply it
17: end while
18: if k (cid:62) 0 then
return R.
19:
20: end if

Theorem 6.1. Let P be a non-degenerate block-hereditary class of graphs recogniz-
able in polynomial time. Then Bounded P-Block Vertex Deletion admits a
kernel with O(k2d7) vertices.
Recall that, for positive integers x and y, we denote by Bx,y the class of all bi-
connected graphs with at least x vertices and at most y vertices. We ﬁx a block-
hereditary class of graphs P recognizable in polynomial time. The block tree of a
graph can be computed in time O(|V (G)|+|E(G)|) [10]. Thus, one can test whether
a given graph is in ΦP∩B2,d in polynomial time.
Before describing the algorithm, we observe that there is a (2d + 6)-approxima-
tion algorithm for the (unparameterized) minimization version of the Bounded P-
Block Vertex Deletion problem. We ﬁrst run the algorithm of Proposition 3.4.
When we ﬁnd an induced subgraph in (B2,d \ P) ∪ Bd+1,2d−2, instead of branching
on the removal of one of the vertices, we remove all the vertices of the subgraph,
then rerun the algorithm. Hence, we can reduce to a (P ∩ B2,d)-clusterable graph
by removing at most (2d − 2) · OPT vertices. Moreover, we can obtain the set of all
(P ∩ B2,d)-clusters using the algorithm in Lemma 3.5. Arguments in the proof of
Proposition 3.2 and the known 8-approximation algorithm for Subset Feedback
Vertex Set [8] imply that there is a (2d+6)-approximation algorithm for Bound-
ed P-Block Vertex Deletion.

We start with the straightforward reduction rules. Let (G, d, k) be an instance

of Bounded P-Block Vertex Deletion.
Reduction Rule 6.1 (Component rule). If G has a connected component H ∈
ΦP∩B2,d, then remove H.
Reduction Rule 6.2 (Cut vertex rule). Let v be a cut vertex of G such that
G−v contains a connected component H where G[V (H)∪{v}] is a block in P∩B2,d.
Then remove H from G.

Vertex deletion problems for graph classes with a block property

21

Now, we introduce a so-called bypassing rule. We ﬁrst run the (2d + 6)-approxi-
mation algorithm, and if it outputs a solution of more than (2d + 6)k vertices, then
we have a No-instance. Thus, we may assume that the algorithm outputs a solution
of size at most (2d + 6)k. Let us ﬁx such a set U.
Reduction Rule 6.3 (Bypassing rule). Let v1, v2, . . . , vt be a sequence of cut
vertices of G − U with 2 (cid:54) t (cid:54) d + 1, and let B1, . . . , Bt−1 be blocks of G − U such
that
(1) for each i ∈ {1, . . . , t − 1}, Bi is the unique block of G − U containing vi and

vi+1 and no other cut vertices of G − U;

1(cid:54)i(cid:54)t−1 V (Bi)) \ {v1, vt} and U; and

(2) G has no edges between ((cid:83)
(3) |(cid:83)
If(cid:83)
in(cid:83)

1(cid:54)i(cid:54)t−1 V (Bi))| (cid:62) d + 1.

1(cid:54)i(cid:54)t−1 V (Bi)\{v1, . . . , vt} = ∅, then contract v1v2; otherwise, choose a vertex
1(cid:54)i(cid:54)t−1 V (Bi) that is not a cut vertex of G − U, and remove it.

See Fig. 3 for an example application of Reduction Rule 6.3. Note that this rule can
be applied in polynomial time using the block tree of G − U.

→

Fig. 3: An example application of Reduction Rule 6.3 when d = 9.

at most k such that G(cid:48) − S(cid:48) ∈ ΦP∩B2,d. For convenience, let W :=(cid:83)

Lemma 6.2. Reduction Rule 6.3 is safe.
Proof. Let v1v2 ··· vt be an induced path of G− U and let B1, . . . , Bt−1 be blocks of
G− U satisfying the conditions of Reduction Rule 6.3. Let G(cid:48) be the resulting graph
after applying Reduction Rule 6.3. We show that G has a set of vertices S of size
at most k such that G− S ∈ ΦP∩B2,d if and only if G(cid:48) has a set of vertices S(cid:48) of size
1(cid:54)i(cid:54)t−1 V (Bi).
Suppose that G has a set of vertices S of size at most k such that G−S ∈ ΦP∩B2,d.
If |S ∩ W| (cid:62) 1, then G − ((S \ W ) ∪ {v1}) is also a graph in ΦP∩B2,d, as each block
in {B1, B2, . . . , Bt−1} is in P ∩ B2,d. Thus, we may assume that S ∩ W = ∅. Since
|W| (cid:62) d + 1, v1 and vt are not contained in the same block of G − S. It means that
there is no path from v1 to vt in G− S containing no vertices in {v2, . . . , vt−1}, and
thus all vertices in {v1, v2, . . . , vt} become cut vertices of G − S. Hence, all blocks
in {B1, B2, . . . , Bt−1} are in distinct blocks of G− S, and thus G(cid:48) − S is in ΦP∩B2,d.
Now suppose that G(cid:48) has a set of vertices S of size at most k such that G(cid:48) − S ∈
ΦP∩B2,d. When an edge v1v2 is contracted, we label the resulting vertex v1. Similar
to the other direction, if |S∩ W| (cid:62) 1, then we can replace S∩ W with v1. So we may
assume that S ∩ W = ∅. As |V (G(cid:48))∩ W| (cid:62) d and G(cid:48)[V (G(cid:48))∩ W ] is not 2-connected,
v1 and vt cannot be contained in the same block of G(cid:48) − S. Thus, all blocks of G(cid:48)
(cid:117)(cid:116)
on W are distinct blocks of G(cid:48) − S, so G − S ∈ ΦP∩B2,d.
We show that after applying Reduction Rules 6.1 to 6.3, if the reduced graph is
still large, then there is a vertex of large degree. This follows from the fact that the
block tree of G − U has no path of 2d + 2 vertices where the internal vertices have
degree 2 in G − U.
Lemma 6.3. Let (G, d, k) be an instance reduced under Reduction Rules 6.1 to 6.3.
If (G, d, k) is a Yes-instance and |V (G)| (cid:62) 4d(2d + 3)(d + 3)k(cid:96), for some integer (cid:96),
then G contains a vertex of degree at least (cid:96) + 1.

v1v2v3v4v5v6v1v2v3v4v5v622

É. Bonnet, N. Brettell, O. Kwon, D. Marx

We ﬁrst require the following lemma.

Lemma 6.4. Let T be a rooted tree, and let R ⊆ V (T ) with |R| (cid:62) 1. Let R(cid:48) be the
set of all nodes in T that are the least common ancestor of two vertices in R. Then
|R(cid:48)| (cid:54) |R| − 1.
Proof. The proof is by induction on |R|. For each node w, the subtree rooted at w in
T is the subtree of T induced by w and all its descendants. Choose a minimal subtree
T (cid:48) rooted at some z containing all nodes in R. If T (cid:48) contains precisely one node in
R, then it contains no nodes in R(cid:48), by deﬁnition, and therefore |R(cid:48)| = 0 (cid:54) |R| − 1.
So we may assume that |R| (cid:62) 2.
Let z1, . . . , zs be the children of z for which the subtree Ti rooted at zi contains
at least one node in R, where i ∈ {1, . . . , s}. Observe that each subtree Ti satisﬁes
|R ∩ V (Ti)| < |R|, where, in the case that s = 1, this is because z ∈ R by the
minimality of T (cid:48). Hence, by the induction hypothesis, |R(cid:48) ∩ V (Ti)| (cid:54) |R∩ V (Ti)|− 1
for each i ∈ {1, . . . , s}. Thus, if s (cid:62) 2,

|R(cid:48)| (cid:54) 1 +

|R(cid:48) ∩ V (Ti)| (cid:54) 1 +

(|R ∩ V (Ti)| − 1) (cid:54) |R| − 1.

(cid:91)

1(cid:54)i(cid:54)s

(cid:91)

1(cid:54)i(cid:54)s

(cid:117)(cid:116)
Otherwise, s = 1 and z ∈ R, so |R(cid:48)| (cid:54) 1 + (|R ∩ V (T1)| − 1) (cid:54) |R| − 1.
Proof (Proof of Lemma 6.3). Suppose that |V (G)| (cid:62) 4d(2d + 3)(d + 3)k(cid:96) and G
has no vertex of degree at least (cid:96) + 1. Let T be the union of the block trees of
connected components of G − U. We color some of the nodes of T as follows: for
each cut vertex v of G − U, color v red if v has a neighbor in U; and for each block
B of G − U, color B red if B contains a vertex that is not a cut vertex in G − U
and has a neighbor in U. Observe that the number of red nodes in T is at most
2(d + 3)k(cid:96), since |U| (cid:54) 2(d + 3)k. Arbitrarily pick a root node for each block tree.
Now, for every pair of two red vertices, color the least common ancestor in T red.
For all nodes that have not been colored red, color them blue. Let R be the set of
all red nodes in T . Note that |R| (cid:54) 4(d + 3)k(cid:96) by Lemma 6.4.

First, we claim that T has no blue nodes of degree at least 3. Suppose T has a
blue node w of degree at least 3. Then there are at least two connected components
of T −w consisting of descendants of w in T . If one of the connected components has
no red nodes, then this contradicts our assumption that (G, d, k) is reduced under
Reduction Rule 6.2. Thus, all the connected components contain red nodes, so w is
also colored red, by construction.
Now, we claim that the number of connected components of T − R is at most
4(d+3)k(cid:96). We obtain a forest F from T by contracting each maximal monochromatic
subgraph X of T into one node with the same color as the nodes of X. Note also
that all leaf nodes in F are colored red. For each connected component F (cid:48) of F , let
R(cid:48) be the red nodes in F (cid:48) and let B(cid:48) be the blue nodes in F (cid:48), and arbitrarily choose
a root node. Note that there is an injective mapping from B(cid:48) to R(cid:48) that sends a
node to one of its children. It follows that the number of blue nodes is at most the
number of red nodes in F , and thus the number of connected components in T − R
is at most |R| (cid:54) 4(d + 3)k(cid:96).

Note that the number of blocks in G − U is at least |V (G−U )|

, and thus the
. As |V (G)| (cid:62) 4d(2d + 3)(d + 3)k(cid:96), there

d

number of nodes in T is at least |V (G−U )|
is a connected component B of T − R where

d

|V (B)| (cid:62)

|V (G−U )|

d

− |R|

4(d + 3)k(cid:96)

(cid:62) |V (G − U )| − 4d(d + 3)k(cid:96)

4d(d + 3)k(cid:96)

(cid:62) 2d + 2.

However, this blue connected component with 2d + 2 vertices can be reduced by
Reduction Rule 6.3; a contradiction. We conclude that if (G, d, k) is a Yes-instance
and |V (G)| (cid:62) 4d(2d + 3)(d + 3)k(cid:96), then G has a vertex of degree at least (cid:96) + 1. (cid:117)(cid:116)

Vertex deletion problems for graph classes with a block property

23

Now, we discuss a “sunﬂower structure” that allows us to ﬁnd a vertex that can
be safely removed. A similar technique was used in [1,13,21]; there, Gallai’s A-path
Theorem is used to ﬁnd many obstructions whose pairwise intersections are exactly
one vertex; here, we use diﬀerent objects to achieve the same thing.
Let A ⊆ V (G) and let d (cid:62) 2. An (A, d)-tree in G is a tree subgraph of G on
at least d vertices whose leaves are contained in A. Let v be a vertex of G. If there
is an (NG(v), d)-tree T in G − v, then G[V (T ) ∪ {v}] is a 2-connected graph with
at least d + 1 vertices. This implies that if there are k + 1 pairwise vertex-disjoint
(NG(v), d)-trees in G−v, then we can safely remove v, as any solution should contain
v.
We prove that if G does not have any set of k + 1 pairwise vertex-disjoint (A, d)-
trees, then there exists S ⊆ V (G) where the size of S is bounded by a function of
k and d, and every connected component of G − S has fewer than d vertices of A.
Note that G− S may still have some (A, d)-trees, as a path of length d− 1 between
two vertices in A is also an (A, d)-tree.
Proposition 6.5. Let G be a graph, let k and d be positive integers, and let A ⊆
V (G). There is an algorithm that, in time O(d|V (G)|3), ﬁnds either:
(i) k pairwise vertex-disjoint (A, d)-trees in G, or
(ii) a vertex subset S ⊆ V (G) of size at most 2(2k − 1)(d2 − d + 1) such that each

connected component of G − S contains fewer than d vertices of A.
We require the following lemmas.

Lemma 6.6. Let k and d be positive integers with d (cid:62) 3. Let T be a tree with
maximum degree d, and let A ⊆ V (T ). If |A| (cid:62) k(d2 − d + 1), then there is an
algorithm that ﬁnds k pairwise vertex-disjoint (A, d)-trees in T , in time O(k|V (T )|).
Proof. If k = 1, then this is trivial because d (cid:62) 3. We assume that k (cid:62) 2. We choose
a root node of T that is not a leaf. For each node t in T , let w(t) be the number of
descendants of t in A, where t is considered a descendant of itself. We can compute
the value of w(t) for each t ∈ T in time O(|V (T )|).
As |A| (cid:62) k(d2 − d + 1) (cid:62) d, there exists a node t in T with w(t) (cid:62) d. Choose
such a node where w(t1) < d for every child t1 of t. Since T has maximum degree d,
we have w(t) (cid:54) d(d− 1) + 1 = d2 − d + 1. Clearly the subtree rooted at t contains an
(A, d)-tree. Let T (cid:48) be the connected component of T − t containing the parent of t
in T . Then T (cid:48) has at least k(d2 − d + 1)− (d2 − d + 1) (cid:62) (k − 1)(d2 − d + 1) nodes in
A. Repeating the same procedure on T (cid:48), we can ﬁnd k − 1 pairwise vertex-disjoint
(A, d)-trees in T (cid:48). Thus, we can return k pairwise vertex-disjoint (A, d)-trees of T
in time O(k|V (T )|).
(cid:117)(cid:116)
Lemma 6.7. Let T be a tree with no vertices of degree 2. If A is the set of all leaves
of T , then |A| (cid:62) |V (T ) \ A| − 2.
Proof. We note that
– |A| + |V (T ) \ A| = |V (T )| = |E(T )| − 1, and
t∈V (T ) dT (t) = 2|E(T )|.

– |A| + 3|V (T ) \ A| (cid:54)(cid:80)

(cid:117)(cid:116)
Combining the two equations, we have that |A| (cid:62) |V (T ) \ A| − 2, as required.
Proof (Proof of Proposition 6.5). We recursively construct a forest Hi in G such
that each connected component of Hi is an (A, d)-tree whose maximum degree is
at most d, until one of the following holds:

(1) Hi consists of k connected components.

É. Bonnet, N. Brettell, O. Kwon, D. Marx

24
(2) |V (Hi) ∩ A| (cid:62) (2k − 1)(d2 − d + 1).
(3) For the set Si of nodes in Hi having degree other than 2, every connected

component of G − ((V (Hi) ∩ A) ∪ Si) has fewer than d vertices of A.

In cases (1) and (2), we will return k pairwise vertex-disjoint (A, d)-trees, and in
case (3), we will return a set S satisfying (ii).

We start with an empty graph H1. Let Si be the set of all vertices of degree
other than 2 in Hi. For the ith iteration, choose a connected component C of
G − ((V (Hi) ∩ A) ∪ Si) containing at least d vertices of A. If there is no such
connected component, then we ﬁnish the procedure, as (3) holds. So assume that
such a connected component C exists. If V (C) ∩ V (Hi) (cid:54)= ∅, then we choose a
shortest path P from A ∩ V (C) to V (Hi) ∩ V (C), and let Hi+1 := Hi ∪ P . As
vertices in A∩ V (C) are not contained in Hi, |V (Hi+1)∩ A| (cid:62) |V (Hi)∩ A| + 1. Also,
the maximum degree of Hi will not change as P will end with a node of degree 2
in Hi.
Now, assume that V (C) ∩ V (Hi) = ∅. In this case, we ﬁnd an (A, d)-tree in
C that is disjoint from Hi. We choose a vertex s ∈ V (C) ∩ A, and let Q1 be the
graph that consists of s. For each j (cid:62) 2, we recursively ﬁnd a shortest path Pi
from V (Qj−1) to (V (C) ∩ A) \ V (Qj−1) and let Qj := Qj−1 ∪ Pi. It is not hard
to see that Q1 has maximum degree 0, and for all i ∈ {2, . . . , d}, Qi has maximum
degree d. Also, all leaves of Qd are contained in A and |V (Qd)∩ A| = d. Thus, Qd is
an (A, d)-tree. We can compute Qd in time O(d|V (G)|2). We set Hi+1 := Hi ∪ Qd.
As each iteration strictly increases V (Hi)∩A, this algorithm will terminate in at
most |V (G)| iterations. Let H and S be the ﬁnal instances Hi and Si, respectively,
prior to termination.

In case (1), each connected component of H contains an (A, d)-tree, so we can
return k pairwise vertex-disjoint (A, d)-trees.
Suppose we have case (2), so |V (H) ∩ A| (cid:62) (2k − 1)(d2 − d + 1). Let T1, . . . , Th
be the connected components of H. We may assume that h (cid:54) k − 1. Applying the
algorithm of Lemma 6.6 to Tj, for each j ∈ {1, . . . , h}, we can return (cid:98)|V (Tj )∩A|
d2−d+1 (cid:99)
|V (Tj )∩A|
pairwise vertex-disjoint (A, d)-trees in time O(
d2−d+1 |V (Tj)|). Therefore, in this
case, we can output

(cid:18)|V (Tj) ∩ A|

d2 − d + 1

(cid:88)

1(cid:54)j(cid:54)h

(cid:19)

− 1

(cid:62) (2k − 1)(d2 − d + 1) − h(d2 − d + 1)

(cid:62) k

d2 − d + 1

pairwise vertex-disjoint (A, d)-trees in time O(k|V (G)|).
We may now assume that case (3) holds, but case (2) does not, so |V (H)∩ A| <
(2k − 1)(d2 − d + 1). By Lemma 6.7, |S| (cid:54) |V (H) ∩ A| + 2, as all leaves of H are
contained in A. Thus, we have

|(V (H) ∩ A) ∪ S| (cid:54) 2|V (H) ∩ A| + 2 (cid:54) 2(2k − 1)(d2 − d + 1),

and the set (V (H) ∩ A) ∪ S satisﬁes (ii).

The total running time of the algorithm is O(d|V (G)|3).

(cid:117)(cid:116)
Reduction Rule 6.4 (Sunﬂower rule 1). Let v be a vertex of G. If there are
k + 1 pairwise vertex-disjoint (NG(v), d)-trees in G − v, then remove v and reduce
k by 1.

After exhaustively applying Reduction Rule 6.4, we may assume, by Propo-
sition 6.5, that for each v ∈ V (G), there exists Sv ⊆ V (G − v) with |Sv| (cid:54)
2(2k + 1)(d2 − d + 1) such that v has at most d − 1 neighbors in each connected
component of G − (Sv ∪ {v}). In the remainder of this section, we use Sv to denote
such a set for any v ∈ V (G). To ﬁnd many connected components of G− (Sv ∪{v})
where each connected component C has the property that G[V (C)∪{v}] ∈ φP∩B2,d,
we apply the next two reduction rules.

Vertex deletion problems for graph classes with a block property

25

Reduction Rule 6.5 (Disjoint obstructions rule). If there are k +1 connected
components of G−(Sv∪{v}) such that each connected component is not in φP∩B2,d,
then conclude that (G, d, k) is a No-instance.

Reduction Rule 6.6 (Sunﬂower rule 2). If there are k + 1 connected com-
ponents of G − (Sv ∪ {v}) where each connected component C is in φP∩B2,d but
G[V (C) ∪ {v}] /∈ φP∩B2,d, then remove v and decrease k by 1.

We can perform these two rules in polynomial time using the block tree of
G[V (C) ∪ {v}]. Then we may assume that G − (Sv ∪ {v}) contains at most 2k
connected components such that the connected component C satisﬁes G[V (C) ∪
{v}] /∈ φP∩B2,d. Thus, if v has degree at least (cid:96), there are at least (cid:96)−2(2k+1)(d2−d+1)
−
2k connected components of G − (Sv ∪ {v}) such that the connected component C
satisﬁes G[V (C)∪{v}] ∈ φP∩B2,d. As G is reduced under Reduction Rule 6.2, there
is an edge between any such connected component C and Sv. We introduce a ﬁnal
reduction rule, which uses the α-expansion lemma [21].

d−1

α

Lemma 6.8 (α-expansion lemma). Let α be a positive integer, and let F be a
bipartite graph with vertex bipartition (X, Y ) such that |Y | (cid:62) α|X| and every vertex
of Y has at least one neighbor in X. Then there exist non-empty subsets X(cid:48) ⊆ X

and Y (cid:48) ⊆ Y and a function φ : X(cid:48) →(cid:0)Y (cid:48)

(cid:1) such that

– NF (Y (cid:48)) ∩ X = X(cid:48),
– φ(x) ⊆ NF (x) for each x ∈ X(cid:48), and
– the sets in {φ(x) : x ∈ X(cid:48)} are pairwise disjoint.
In addition, such a pair X(cid:48), Y (cid:48) can be computed in time polynomial in α|V (F )|.
Reduction Rule 6.7 (Large degree rule). Let v be a vertex of G. If there is a
set C of connected components of G−(Sv∪{v}) such that |C| (cid:62) 2d(2k+1)(d2−d+1)
and, for each C ∈ C, we have G[V (C) ∪ {v}] ∈ φP∩B2,d, then do the following:
(1) Construct an auxiliary bipartite graph H with bipartition (Sv,C) where w ∈ Sv
v ⊆ Sv obtained by applying Lemma 6.8 to H with
(2) Compute sets C(cid:48) ⊆ C and S(cid:48)
(3) Remove all edges in G between v and each connected component C of C(cid:48).
(4) Add d− 1 internally vertex-disjoint paths of length 2 between v and each vertex

and C ∈ C are adjacent in H if and only if w has a neighbor in C.

α = d.

x ∈ S(cid:48)
v.

(5) Remove all vertices of degree 1 in the resulting graph.

Lemma 6.9. Reduction Rule 6.7 is safe.
Proof. Let C be a set of connected components of G − (Sv ∪ {v}) such that |C| (cid:62)
2d(2k − 1)(d2 − d + 1) and, for C ∈ C, G[V (C) ∪ {v}] ∈ φP∩B2,d. As |Sv| (cid:54) 2(2k −
1)(d2−d+1), Lemma 6.8 implies that we can obtain C(cid:48) ⊆ C, S(cid:48)
v ⊆ Sv and a function

(cid:1) in polynomial time such that

C∈C(cid:48) V (C)) ∩ Sv = S(cid:48)
v,

– φ(x) is a subset of C(cid:48) where each connected component in φ(x) has a neighbor

φ : Sv →(cid:0)C
– NG((cid:83)
– the graphs in {(cid:83)

of x, and

d

C∈φ(x) V (C) : x ∈ X} are pairwise disjoint.

Let G(cid:48) be the resulting graph obtained by applying Reduction Rule 6.7. We prove
that (G, d, k) is a Yes-instance if and only if (G(cid:48), d, k) is a Yes-instance. Let R be
the set of new vertices of degree 2 between v and S(cid:48)
Suppose that G(cid:48) has a vertex set A with |A| (cid:54) k such that G(cid:48)− A ∈ φP∩B2,d. If a
vertex r ∈ R is contained in A and r(cid:48) is a neighbor of r, then G(cid:48) − (A\{r}∪{r(cid:48)}) ∈

v in G(cid:48).

v, we have either v ∈ A or S(cid:48)
C∈C(cid:48) V (C)) ∩ Sv = S(cid:48)

v \ A and A2 := A ∩ ((cid:83)

Let A1 := S(cid:48)

É. Bonnet, N. Brettell, O. Kwon, D. Marx

Since NG((cid:83)
G[V (C)∪{v}] ∈ φP∩B2,d for all C ∈ C(cid:48). Moreover, G−A−((cid:83)

26
φP∩B2,d, as r and all of its twins become vertices of degree 1 in G(cid:48) − (A\{r}∪{r(cid:48)})
and thus they cannot be contained in blocks with at least 3 vertices. As d − 1
distinct paths of length 2 from v to a vertex x ∈ S(cid:48)
v form a block with d + 1
vertices, we may assume that A contains either v or x. Considering all vertices
v ⊆ A. If v ∈ A, then G − A is an induced
in S(cid:48)
subgraph of G(cid:48) − A, and therefore, G − A ∈ φP∩B2,d. Suppose v /∈ A and S(cid:48)
v ⊆ A.
v, v is a cut vertex of G − A, and we know that
C∈C V (C)) is an induced
subgraph of G(cid:48) − A, and thus it is a graph in φP∩B2,d. Therefore, G − A ∈ φP∩B2,d.
For the converse direction, suppose that G has a vertex set A with |A| (cid:54) k such
that G − A ∈ φP∩B2,d. If v ∈ A, then the vertices in R become pendant vertices in
G(cid:48) − A, and thus, G(cid:48) − A ∈ φP∩B2,d. We may assume that v /∈ A.
C∈C(cid:48) V (C)). It is not hard to see that
G − ((A \ A2) ∪ A1) ∈ φP∩B2,d as G[V (C) ∪ {v}] ∈ φP∩B2,d for each C ∈ C(cid:48). We
claim that |A2| (cid:62) |A1|, which implies that there is a vertex set A(cid:48) with |A(cid:48)| (cid:54) |A| (cid:54) k
C∈φ(x) V (C) :
v} are pairwise disjoint, there exists a vertex a in A1 such that φ(a) contains
x ∈ S(cid:48)
no vertex from A2. Then d−1 connected components in φ(a) with the vertices v and
a contains a 2-connected subgraph with at least d + 1 vertices, which contradicts
the assumption that G − A ∈ φP∩B2,d.
(cid:117)(cid:116)
Lemma 6.10. Reduction Rules 6.1 to 6.7 can be applied exhaustively in polynomial
time.

such that G(cid:48)− A(cid:48) ∈ φP∩B2,d. Suppose |A2| < |A1|. Since the sets in {(cid:83)

Proof. It is clear that an application of one of Reduction Rules 6.1 to 6.6 decreases
|V (G)|. We show that |V (G)| + |E(cid:48)| decreases when Reduction Rule 6.7 is applied,
where E(cid:48) is the number of edges of G for which both end vertices have degree at
least 3.
Let (G, d, k) be an instance, and let E(cid:48) be the set of edges where both end
vertices have degree at least 3. First, observe that |V (G)| + |E(cid:48)| is increased by
v| when adding d − 1 disjoint paths of length 2 from v to each vertex of
(d − 1)|S(cid:48)
v. It is suﬃcient to check that for each C ∈ C(cid:48), |V (G)| + |E(cid:48)| is decreased by at
S(cid:48)
v|. If v has a neighbor in C ∈ C(cid:48) that has
least 1, since |C(cid:48)| (cid:62) d|S(cid:48)
degree 3 in G, then this is clear. If a neighbor w of v in C ∈ C(cid:48) has degree 2 in G,
then it becomes a vertex of degree 1 and will be removed when applying Reduction
Rule 6.7. Since every neighbor of v in a connected component of C(cid:48) has degree at
(cid:117)(cid:116)
least 2, this completes the proof.

v| > (d − 1)|S(cid:48)

Proof (Proof of Theorem 6.1). We apply Reduction Rules 6.1 to 6.7 exhaustively.
Note that this takes polynomial time, by Lemma 6.10. Suppose that (G, d, k) is the
reduced instance, and |V (G)| (cid:62) 4dk((cid:96)− 1)(2d + 3)(d + 3) where (cid:96) = 2d2(2k + 1)(d2−
d + 3). Then, by Lemma 6.3, there exists a vertex v of degree at least (cid:96).
By Proposition 6.5, v has at most d− 1 neighbors in each connected component
of G − (Sv ∪ {v}). Since (cid:96) = 2d2(2k + 1)(d2 − d + 3), the subgraph G − (Sv ∪ {v})
contains at least (cid:96)−2(2k+1)(d2−d+1)
(cid:62) 2d(2k + 1)(d2 − d + 3) connected components.
By Reduction Rules 6.5 and 6.6, G−(Sv∪{v}) contains at least 2d(2k+1)(d2−d+1)
connected components such that, for each connected component C, G[V (C)∪{v}] ∈
φP∩B2,d. Then we can apply Reduction Rule 6.7, contradicting our assumption. We
conclude that |V (G)| = O(k2d7).
(cid:117)(cid:116)
One might ask whether the kernel with O(k2d7) vertices can be improved upon.
Regarding the k2 factor, reducing it to linear in k would imply a linear kernel for
Feedback Vertex Set. On the other hand, it is possible to reduce the d7 factor
depending on the block-hereditary class P.

d−1

Vertex deletion problems for graph classes with a block property

27

Theorem 6.11.
– Bounded Block VD admits a kernel with O(k2d6) vertices.
– Bounded Complete Block VD admits a kernel with O(k2d3) vertices.
– Bounded Cactus Graph VD admits a kernel with O(k2d4) vertices.

We prove Theorem 6.11 as three separate results: Theorems 6.13, 6.14 and 6.16.
First, observe that each of the three problems have (2d + 6)-approximation al-
gorithms, by the same argument as for the general problem Bounded P-Block
Vertex Deletion.
Now consider the Bounded Block VD problem. All the reduction rules for
Bounded P-Block Vertex Deletion can be applied with P as the class of all
biconnected graphs. However, Reduction Rule 6.3 can be modiﬁed as follows, in
order to obtain a slightly better kernel. Let (G, d, k) be an instance of Bounded
Block VD, and let U be a solution of size at most (2d + 6)k obtained by the
(2d + 6)-approximation algorithm.

vertices, and

Reduction Rule 6.8 (Bypassing rule 2). Let v1, v2, v3 be a sequence of cut
vertices of G − U, and let B1 and B2 be blocks of G − U such that
(1) for each i ∈ {1, 2}, Bi is the unique block containing vi, vi+1 and no other cut
(2) G has no edges between (V (B1) ∪ V (B2)) \ {v1, v3} and U.
Then remove (V (B1) ∪ V (B2)) \ {v1, v3} and add a clique of size min{d,|V (B1) ∪
V (B2)|} containing v1 and v3.
Lemma 6.12. Reduction Rule 6.8 is safe.
Proof. Let v1v2v3 be an induced path of G−U and let B1 and B2 be blocks of G−U
satisfying the conditions of Reduction Rule 6.8. Let G(cid:48) be the resulting graph after
applying Reduction Rule 6.8. We show that G has a set of vertices S of size at most
k such that G − S ∈ ΦB2,d if and only if G(cid:48) has a set of vertices S(cid:48) of size at most
k such that G(cid:48) − S(cid:48) ∈ ΦB2,d. For convenience, let W := V (B1) ∪ V (B2), and let W (cid:48)
be the new clique added in G(cid:48).
Suppose that G has a set of vertices S of size at most k such that G− S ∈ ΦB2,d.
If |S ∩ W| (cid:62) 1, then G − ((S \ W ) ∪ {v1}) is a graph in ΦB2,d, as B1 and B2 are
in B2,d. Thus, G(cid:48) − ((S \ W ) ∪ {v1}) is also a graph in ΦB2,d. We may now assume
that S ∩ W = ∅. Assume that W is contained in some block B of G − S. In this
case, |W| (cid:54) d − 1 as G[W ] is not 2-connected. Thus, G(cid:48) − S ∈ ΦB2,d, as the block
obtained from B by replacing W with W (cid:48) has the same number of vertices, and all
the other blocks are the same. If W is not contained in some block of G − S, then
every path from v1 to v3 in G − S passes through v2. Thus, v1, v2, and v3 are cut
vertices of G − S. Hence, B1 and B2 are distinct blocks of G − S, and thus G(cid:48) − S
is in ΦB2,d.
Now suppose that G(cid:48) has a set of vertices S of size at most k such that G(cid:48) − S ∈
ΦB2,d. Similar to the other direction, if |S ∩ W| (cid:62) 1, then we can replace S ∩ W with
v1. So we may assume that S ∩ W = ∅. If W (cid:48) is a block of G(cid:48) − S, then v1 and v3
are cut vertices of G(cid:48) − S, and one can easily check that G − S ∈ ΦB2,d. Otherwise,
the clique W (cid:48) is not a block of G(cid:48) − S, that is, it is contained in a bigger block.
Then |W (cid:48)| (cid:54) d − 1 and |W| = |W (cid:48)| (cid:54) d − 1, and thus G − S is also in ΦB2,d.
(cid:117)(cid:116)
Theorem 6.13. Bounded Block VD admits a kernel with O(k2d6) vertices.
Proof. Lemma 6.12 implies that the block tree of G − U has no path of 6 vertices
whose internal vertices have degree 2 in G − U. By modifying Lemma 6.3, we
can show that if (G, d, k) is reduced under Reduction Rules 6.1, 6.2 and 6.8, and

28

É. Bonnet, N. Brettell, O. Kwon, D. Marx

|V (G)| (cid:62) 28d(d + 3)k(cid:96), then G has a vertex of degree at least (cid:96) + 1. Using Reduction
Rules 6.4 to 6.7 and the same argument as in the proof of Theorem 6.1, it follows
that there is a kernel with O(k2d6) vertices.
(cid:117)(cid:116)
Note that we can also use Reduction Rule 6.8 for Bounded Complete Block
VD, since for complete-block graphs, every maximal clique cannot be contained in
a bigger block. But it seems diﬃcult to obtain a similar rule for Bounded Cactus
Graph VD. However, for both problems, we can obtain a smaller kernel by using
diﬀerent objects in Proposition 6.5.

Recall that a graph G is a d-complete block graph if every block of G is a complete
graph with at most d vertices, and a graph G is a d-cactus if it is a cactus graph
and every block has at most d vertices.
Theorem 6.14. Bounded Cactus Graph VD admits a kernel with O(k2d4)
vertices.

Proof. We observe that for a vertex v in a graph G and an (NG(v), 3)-tree T ,
G[V (T ) ∪ {v}] is 2-connected and it is not a cycle. Thus G[V (T ) ∪ {v}] is not a d-
cactus graph, and at least one vertex of V (T )∪{v} should be taken in any solution.
Because of this, we can replace (NG(v), d)-trees with (NG(v), 3)-trees in Reduction
Rule 6.4. By Proposition 6.5, we may assume that for each v ∈ V (G), there exists
Sv ⊆ V (G − v) with |Sv| (cid:54) 14(2k + 1) such that v has at most 2 neighbors in each
connected component of G − (Sv ∪ {v}).

Since (cid:96) = 112(2k + 3), G − (Sv ∪ {v}) contains at least (cid:96)−14(2k+1)

Note that if there are two vertices with three vertex-disjoint paths between them,
then we have a subdivision of the diamond, which is an obstruction for cactus graphs.
Thus, the number of connected components of G−(Sv∪{v}) required for Reduction
Rule 6.7 to be applicable can be changed to (3 + 1) · 14(2k + 1) = 56(2k + 1).
We set (cid:96) := 112(2k + 3). Suppose that (G, d, k) is the reduced instance, and
|V (G)| (cid:62) 4dk((cid:96) − 1)(2d + 3)(d + 3). Then, by Lemma 6.3, there exists a vertex v of
degree at least (cid:96).
(cid:62) 56(2k + 3)
connected components. By Reduction Rules 6.5 and 6.6, G− (Sv ∪{v}) contains at
least 56(2k + 1) connected components such that, for each connected component C,
G[V (C) ∪ {v}] is a d-cactus. Then we can apply Reduction Rule 6.7, contradicting
our assumption. We conclude that |V (G)| = O(k2d3).
(cid:117)(cid:116)
For Bounded Complete Block VD we can use Gallai’s A-path Theorem
instead of Proposition 6.5. The following can be obtained by modifying [13, Propo-
sition 3.1] so that the size of blocks is also taken into account.
Proposition 6.15 ([13]). Let G be a graph and let v ∈ V (G) and let k be a positive
integer. Then, in O(kn3) time, we can ﬁnd either
(i) k +1 obstructions for d-complete block graphs that are pairwise vertex-disjoint,

2

or

(ii) k + 1 obstructions for d-complete block graphs whose pairwise intersections are
(iii) Sv ⊆ V (G) with |Sv| (cid:54) 7k such that G− Sv has no obstruction for d-complete

exactly the vertex v, or

block graphs containing v.

Theorem 6.16. Bounded Complete Block VD admits a kernel with O(k2d3)
vertices.

Proof. We exhaustively reduce using Reduction Rules 6.1, 6.2, 6.8 and 6.4 to 6.7.
Now, applying Proposition 6.15, we can assume that for each v ∈ V (G), there
exists Sv ⊆ V (G − v) with |Sv| (cid:54) 7k such that G − Sv has no obstruction for d-
complete block graphs containing v. But we cannot say anything about the number

Vertex deletion problems for graph classes with a block property

29
of neighbors of v in each connected component of G − Sv after reducing in case (i)
or case (ii). So we ﬁnd a (2d +6)-approximation solution U and let U∗ := U if v /∈ U
and U∗ := U \ {v} otherwise, and add it to Sv. Then G − (Sv ∪ U∗) is a d-complete
block graph and v has at most d − 1 neighbors in each connected component of
G − (Sv ∪ U∗).

Note that if there are two vertices with two vertex-disjoint paths of length at
least 2 between them, then there is an obstruction for d-complete block graphs.
So we can use the 3-expansion lemma as in [13]. Thus, the number of connected
components required for Reduction Rule 6.7 to be applicable can be changed to
3(7k + (2d + 6)k) = 3k(2d + 13).
We set (cid:96) := 3kd(2d + 13). Suppose that (G, d, k) is the reduced instance, and
|V (G)| (cid:62) 28d(d + 3)k(cid:96). By modifying Lemma 6.3, one can show that G has a vertex
of degree at least (cid:96) + 1.
(cid:62)
3k(2d + 13) connected components. So we can reduce the instance using the 3-
(cid:117)(cid:116)
expansion lemma; a contradiction. We conclude that |V (G)| = O(k2d4).

Since (cid:96) = 3kd(2d + 13), G − (Sv ∪ U∗ ∪ {v}) contains at least (cid:96)−k(2d+13)

(d−1)

References

1. Agrawal, A., Kolay, S., Lokshtanov, D.: A faster FPT algorithm and a smaller kernel for
Block Graph Vertex Deletion. In: Proceedings of the 12th Latin American Theoretical
Informatics Symposium (LATIN 2016). Lecture Notes in Computer Science, Springer
(2016)

2. Bondy, J.A., Murty, U.S.R.: Graph theory, Graduate Texts in Mathematics, vol. 244.

Springer, New York (2008)

3. Cai, L.: Fixed-parameter tractability of graph modiﬁcation problems for hereditary

properties. Information Processing Letters 58(4), 171–176 (1996)

4. Cygan, M., Fomin, F.V., Kowalik, L., Lokshtanov, D., Marx, D., Pilipczuk, M.,

Pilipczuk, M., Saurabh, S.: Parameterized Algorithms. Springer (2015)

5. Downey, R.G., Fellows, M.R.: Fundamentals of Parameterized Complexity. Texts in

Computer Science, Springer (2013)

6. Drange, P.G., Dregi, M.S., van ’t Hof, P.: On the computational complexity of vertex
integrity and component order connectivity. In: Algorithms and Computation: 25th
International Symposium, ISAAC 2014, Jeonju, Korea, December 15–17, 2014, Pro-
ceedings. pp. 285–297 (2014)

7. El-Mallah, E.S., Colbourn, C.J.: The complexity of some edge deletion problems. IEEE

Trans. Circuits and Systems 35(3), 354–362 (1988)

vertex set problem. SIAM J. Comput. 30(4), 1231–1252 (2000)

8. Even, G., Naor, J., Zosin, L.: An 8-approximation algorithm for the subset feedback
9. Fomin, F., Lokshtanov, D., Misra, N., Saurabh, S.: Planar F-Deletion: Approximation
and Optimal FPT Algorithms. In: Foundations of Computer Science (FOCS). pp.
470–479 (2012)

10. Hopcroft, J., Tarjan, R.: Algorithm 447: Eﬃcient algorithms for graph manipulation.

Commun. ACM 16(6), 372–378 (1973)

11. Impagliazzo, R., Paturi, R., Zane, F.: Which problems have strongly exponential com-

plexity? J. Comput. System Sci. 63(4), 512–530 (2001)

12. Joret, G., Paul, C., Sau, I., Saurabh, S., Thomassé, S.: Hitting and Harvesting Pump-

kins. SIAM J. Discrete Math. 28(3), 1363–1390 (2014)

13. Kim, E.J., Kwon, O.: A Polynomial Kernel for Block Graph Deletion. In: Husfeldt, T.,
Kanj, I. (eds.) 10th International Symposium on Parameterized and Exact Computa-
tion (IPEC 2015). Leibniz International Proceedings in Informatics (LIPIcs), vol. 43,
pp. 270–281. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany
(2015)

14. Kim, E.J., Langer, A., Paul, C., Reidl, F., Rossmanith, P., Sau, I., Sikdar, S.: Lin-
ear kernels and single-exponential algorithms via protrusion decompositions. In: Au-
tomata, Languages, and Programming - 40th International Colloquium, ICALP 2013,
Riga, Latvia, July 8-12, 2013, Proceedings, Part I. pp. 613–624 (2013)

30

É. Bonnet, N. Brettell, O. Kwon, D. Marx

15. Kolay, S., Lokshtanov, D., Panolan, F., Saurabh, S.: Quick but Odd Growth of Cacti.
In: Husfeldt, T., Kanj, I. (eds.) 10th International Symposium on Parameterized and
Exact Computation (IPEC 2015). pp. 258–269. No. 43, Schloss Dagstuhl–Leibniz-
Zentrum fuer Informatik, Dagstuhl, Germany (2015)

16. Lewis, J.M., Yannakakis, M.: The node-deletion problem for hereditary properties is

NP-complete. J. Comput. Syst. Sci. 20(2), 219–230 (1980)

17. Lokshtanov, D., Marx, D., Saurabh, S.: Slightly superexponential parameterized prob-
lems. In: Proceedings of the Twenty-Second Annual ACM-SIAM Symposium on Dis-
crete Algorithms, SODA 2011, San Francisco, California, USA, January 23-25, 2011.
pp. 760–776 (2011)

18. Misra, P., Raman, V., Ramanujan, M.S., Saurabh, S.: Graph-Theoretic Concepts in
Computer Science: 38th International Workshop, WG 2012, Jerusalem, Israel, June
26-28, 2012, Revised Selected Papers, chap. Parameterized Algorithms for Even Cycle
Transversal, pp. 172–183. Springer Berlin Heidelberg, Berlin, Heidelberg (2012)

19. Reed, B.A., Smith, K., Vetta, A.: Finding odd cycle transversals. Oper. Res. Lett.

20. Robertson, N., Seymour, P.D.: Graph Minors. XIII. The Disjoint Paths Problem. J.

32(4), 299–301 (2004)

Comb. Theory B 63, 65–110 (1995)

21. Thomassé, S.: A quadratic kernel for feedback vertex set. In: Proceedings of the Twen-
tieth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2009, New York,
NY, USA, January 4-6, 2009. pp. 115–119 (2009)

22. Wahlström, M.: Half-integrality, LP-branching and FPT algorithms. In: Proceedings of
the Twenty-Fifth Annual ACM-SIAM Symposium on Discrete Algorithms. pp. 1762–
1781. SIAM (2014)

