Efﬁcient Authentication of Outsourced String Similarity

Search

Boxiang Dong, Wendy Wang
Department of Computer Science
Stevens Institute of Technology

Hoboken, NJ

bdong, hwang4@stevens.edu

6
1
0
2

 
r
a

M
8

 

 
 
]

R
C
.
s
c
[
 
 

1
v
7
2
7
2
0

.

3
0
6
1
:
v
i
X
r
a

ABSTRACT
Cloud computing enables the outsourcing of big data analyt-
ics, where a third-party server is responsible for data storage
and processing. In this paper, we consider the outsourcing
model that provides string similarity search as the service.
In particular, given a similarity search query, the service
provider returns all strings from the outsourced dataset that
are similar to the query string. A major security concern
of the outsourcing paradigm is to authenticate whether the
service provider returns sound and complete search results.
In this paper, we design AutoS 3, an authentication mecha-
nism of outsourced string similarity search. The key idea of
AutoS 3 is that the server returns a veriﬁcation object (V O)
to prove the result correctness. First, we design an authen-
ticated string indexing structure named M B-tree for V O
construction. Second, we design two lightweight authenti-
cation methods named V S 2 and E-V S 2 that can catch the
service provider’s various cheating behaviors with cheap ver-
iﬁcation cost. Moreover, we generalize our solution for top-k
string similarity search. We perform an extensive set of ex-
periment results on real-world datasets to demonstrate the
eﬃciency of our approach.

1.

INTRODUCTION

Big data analytics oﬀers the promise of providing valuable
insights. However, many companies, especially the small-
and medium-sized organizations lack the computational re-
sources, in-house knowledge and experience of big data an-
alytics. A practical solution to this dilemma is outsourcing,
where the data owner outsources the data to a computa-
tional powerful third-party service provider (e.g., the cloud)
for cost-eﬀective solutions of data storage, processing, and
analysis.

In this paper, we consider string similarity search, an im-
portant data analytics operation that have been used in
a broad range of applications, as the outsourced compu-
tations. Generally speaking, the data owner outsources a
string database D to a third-party service provider (server).

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$15.00.

The server provides the storage and processing of similarity
search queries as services. The search queries ask for the
strings in D that are similar to a number of given strings,
where the similarity is measured by a speciﬁc similarity func-
tion and a user-deﬁned threshold.

For all the beneﬁts of outsourcing and cloud computing,
though, the outsourcing paradigm deprives the data owner
of direct control over her data. This poses numerous se-
curity challenges. One of the challenges is that the server
may cheat on the similarity search results. For example, the
server is incentivized to improve its revenue by computing
with less resources (e.g., only search a portion of D) while
charging for more. Therefore, it is important to authenti-
cate whether the service provider has performed the search
faithfully, and returned the correct results to the client. A
naive method is to execute the search queries locally, and
compare the results with the outcome from the server. Ap-
parently this method is prohibitively costly. We aim to de-
sign eﬃcient methods that enable the client to authenticate
that the server returned sound and complete similar strings.
By soundness we mean that the returned strings are indeed
similar. By completeness we mean that all similar strings
are returned.
In this paper, we focus on edit distance, a
commonly-used string similarity function.

Most existing work (e.g.

[3, 15]) solve the authentica-
tion problem for spatial queries in the Euclidean space. To
our best knowledge, ours is the ﬁrst to consider the au-
thentication of outsourced string similarity search.
Intu-
itively, the strings can be mapped to the Euclidean space
via a similarity-preserving embedding function (e.g. [8, 13]).
However, such embedding functions cannot guarantee 100%
precision (i.e., the embedded points of some dissimilar strings
become similar in the Euclidean space). This disables the
direct use of the existing Euclidean distance based authen-
tication approaches on string similarity queries.

In this paper, we design AutoS 3, an Authentication mech-
anism of Outsourced String Similarity Search. The key idea
of AutoS 3 is that besides returning the similar strings, the
server returns a veriﬁcation object (V O) that can prove the
soundness and completeness of returned strings. In particu-
lar, we make the following contributions.

First, we design an authentication tree structure named
MB-tree. MB-tree is constructed by integrating Merkle hash
tree [28], a popularly-used authenticated data structure, with
Bed-tree [33], a compact index for eﬃcient string similarity
search based on edit distance.

Second, we design the basic veriﬁcation method named
V S 2 for the search queries that consist of a single query

string. V S 2 constructs V O from the MB-tree, requiring
to include false hits into V O, where false hits refer to the
strings that are not returned in the result, but are necessary
for the result authentication. We prove that V S 2 is able
to catch the server’s cheating behaviors such as tampered
values, soundness violation, and completeness violation.

A large amounts of false hits can impose a signiﬁcant bur-
den to the client for veriﬁcation. Therefore, our third con-
tribution is the design of the E-V S 2 algorithm that reduces
the VO veriﬁcation cost at the client side. E-V S 2 applies
a similarity-preserving embedding function to map strings
to the Euclidean space in the way that similar strings are
mapped to close Euclidean points. Then V O is constructed
from both the M B-tree and the embedded Euclidean space.
Compared with V S 2, E-V S 2 dramatically saves the veriﬁ-
cation cost by replacing a large amounts of expensive string
edit distance calculation with a small number of cheap Eu-
clidean distance computation.

Fourth, we extend to the authentication of: (1) similarity
search queries that consists of multiple query strings, and
(2) top-k similarity search. We design eﬃcient optimization
methods that reduce veriﬁcation cost for both cases.

Last but not least, we complement the theoretical investi-
gation with a rich set of experiment study on real datasets.
The experiment results demonstrate the eﬃciency of our ap-
It shows that E-V S 2 can save 25% veriﬁcation
proaches.
cost of the V S 2 approach.

The rest of the paper is organized as follows. Sections
2 and 3 discuss the related work and preliminaries. Sec-
tion 4 formally deﬁnes the problem. Section 5 presents our
V S 2 and E-V S 2 approaches for single-string search queries.
Section 6 discusses the authentication of multi-string search
queries. Section 7 extends to top-k similarity search. The
experiment results are shown in Section 8. Section 9 con-
cludes the paper.

2. RELATED WORK

The problem of authentication of outsourced computa-
tions caught much attention from the research community in
recent years. Based on the type of the outsourced data and
the type of queries that are executed on the data, we classify
these techniques into the following types: (1) authentication
of outsourced SQL query evaluation, (2) authentication of
keyword search, and (3) authentication of outsourced spa-
tial query evaluation. None of these work considered string
similarity search queries.
Authentication of outsourced SQL query evaluation.
The issue of providing authenticity for outsourced database
was initially raised in the database-as-a-service (DaS) paradigm
[11]. The aim is to assure the correctness of SQL query
evaluation over the outsourced databases. The proposed so-
lutions include Merkle hash trees [19, 23], signatures on a
chain of paired tuples [25], and authenticated B-tree and
R-tree structures for aggregated queries [21]. The key idea
of these techniques is that the data owner outsources not
only data but also the endorsements of the data being out-
sourced. These endorsements are signed by the data owner
against tampering with by the service provider. For the
cleaning results, the service provider returns both the re-
sults and a proof, called the veriﬁcation object (V O), which
is an auxiliary data structure to store the processing traces
such as index traversals. The client uses the V O, together
with the answers, to reconstruct the endorsements and thus

verify the authenticity of the results. An eﬃcient authen-
tication technique should minimize the size of V O, while
requiring lightweight authentication at the client side.
In
this paper, we follow the same VO-based strategy to design
our authentication method.
Authentication of keyword search. Pang et al. [24] tar-
geted at search engines that perform similarity-based docu-
ment retrieval, and designed a novel authentication mecha-
nism for the search results. The key idea of the authentica-
tion is to build the Merkle hash tree (MHT) on the inverted
index, and use the MHT for V O construction. Though ef-
fective, it has several limitations, e.g., the MHT cannot deal
data updates eﬃciently [10]. To address these limitations,
Goodrich et al.
[10] designed a new model that considered
conjunctive keyword searches as equivalent with a set in-
tersection on the underlying inverted index data structure.
They use the authenticated data structure in [27] to verify
the correctness of set operations.
Authentication of outsourced spatial query evalua-
tion. A number of work investigated the problem of authen-
tication of spatial query evaluation in the location-based ser-
vice model. Yang et al.
[31, 30] integrated an R-tree with
the MHT (which is called Merkle R-tree or MR-tree) for
authenticating multi-dimensional range queries. Yiu et al.
[32] focused on the moving KNN queries that continuously
reports the k nearest neighbors of a moving query point.
They designed the Voronoi MR-tree as the authenticated
data structure for V O construction and authentication. Hu
et al.
[15] also utilized neighborhood information derived
from the Voronoi diagram of the underlying spatial dataset
for authentication. Wu et al. [29] designed a novel authen-
ticated data structure named Merkle-IR-tree (MIR-tree) for
moving top-k spatial keyword (MkSK) queries. MIR-tree
builds a series of digests in each node of the IR-tree [6], in
which each entry summarizes the spatial distances and text
relevance of the entries in its child node.

3. PRELIMINARIES
String similarity function. String similarity search is a
fundamental problem in many research areas, e.g., informa-
tion retrieval, database joins, and more. In the literature,
there are a number of string similarity functions, e.g., Ham-
ming distance, n-grams, and edit distance (See [17] for a
good tutorial.) In this paper, we mainly consider edit dis-
tance, one of the most popular string similarity measurement
that has been used in a wide spectrum of applications. In-
formally, the edit distance of two string values s1 and s2,
denoted as DST (s1, s2), measures the minimum number of
insertion, deletion and substitution operations to transform
s1 to s2. We say two strings s1 and s2 are θ-similar, denoted
as s1 ≈ s2, if DST (s1, s2) ≤ θ, where θ is a user-speciﬁed
similarity threshold. Otherwise, we say s1 and s2 are θ-
dissimilar (denoted as s1 6≈ s2).
Mapping Strings to Euclidean Space. Given two strings
s1 and s2, normally the complexity of computing edit dis-
tance is O(|s1||s2|), where |s1| and |s2| are the lengths of
s1 and s2. One way to reduce the complexity of similarity
measurement is to map the strings into a multi-dimensional
Euclidean space, such that the similar strings are mapped
to close Euclidean points. The main reason of the embed-
ding is that the computation of Euclidean distance is much
cheaper than string edit distance. A few string embedding
techniques (e.g., [8, 16, 13]) exist in the literature. These al-

gorithms have diﬀerent properties in terms of their eﬃciency
and distortion rate (See [12] for a good survey).
In this
paper, we consider an important property named contrac-
tiveness property of the embedding methods, which requires
that for any pair of strings (si, sj) and their embedded Eu-
clidean points (pi, pj), dst(pi, pj) ≤ DST (si, sj), where dst()
and DST () are the distance function in the Euclidean space
and string space respectively. In this paper, we use dst() and
DST () to denote the Euclidean distance and edit distance.
In this paper, we use the SparseMap method [13] for the
string embedding. SparseMap preserves the contractiveness
property. We will show how to leverage the contractiveness
property to improve the performance of veriﬁcation in Sec-
tion 5.2. Note that the embedding methods may introduce
false positives, i.e. the embedding points of dissimilar strings
may become close in the Euclidean space.
Authenticated data structure. To enable the client to
verify the correctness of the query results, the server returns
the results along with some supplementary information that
permits result veriﬁcation. Normally the supplementary in-
formation takes the format of veriﬁcation objects (V Os). In
the literature, VO generation is usually performed by an
authenticated data structure (e.g., [20, 30, 26]). One of the
popular authenticated data structures is Merkle tree [28]. In
particular, a Merkle tree is a tree T in which each leaf node
N stores the digest of a record r: hN = h(r), where h()
is a one-way, collision-resistant hash function (e.g. SHA-1
[22]). For each non-leaf node N of T , it is assigned the value
hN = h(hC1 || . . . ||hCk ), where C1, . . . , Ck are the children
of N . The root signature sig is generated by signing the di-
gest hroot of the root node using the private key of a trusted
party (e.g., the data owner). The VO enables the client to
re-construct the root signature sig.
Bed-Tree for string similarity search. A number of com-
pact data structures (e.g., [1, 2, 18]) are designed to handle
edit distance based similarity measurement. In this paper,
we consider Bed-tree [33] due to its simplicity and eﬃciency.
Bed-tree is a B+-tree based index structure that can handle
arbitrary edit distance thresholds. The tree is built upon
a string ordering scheme which is a mapping function ϕ to
map each string to an integer value. To simplify notation,
we say that s ∈ [si, sj] if ϕ(si) ≤ ϕ(s) ≤ ϕ(sj). Based on
the string ordering, each Bed-tree node N is associated with
a string range [Nb, Ne]. Each leaf node contains f strings
{s1, . . . , sf }, where si ∈ [Nb, Ne], for each i ∈ [1, f ]. Each
intermediate node contains multiple children nodes, where
for each child of N , its range [N ′
e] ⊆ [Nb, Ne], as [Nb, Ne]
is the range of N . We say these strings that stored in the
sub-tree rooted at N as the strings that are covered by N .
We use DSTmin(sq, N ) to denote the minimal edit dis-
tance between a query string sq and any s that is covered
by a Bed-tree node N . A nice property of the Bed-tree is
that, for any string sq and node N , the string ordering ϕ
enables to compute DSTmin(sq, N ) eﬃciently by comput-
ing DST (sq, Nb) and DST (sq, Ne) only, where Nb, Ne refer
to the string range values of N . Then:

b, N ′

Definition 3.1. Given a query string sq and a similar-
ity threshold θ, we say a Bed-tree node N is a candidate if
DSTmin(sq, N ) ≤ θ. Otherwise, N is a non-candidate.
Bed-tree has an important monotone property. Given a node
Ni in the Bed-tree and any child node Nj of Ni, for any
query string sq,
it must be true that DSTmin(sq, Ni) ≤
DSTmin(sq, Nj ). Therefore, for any non-candidate node,

all of its children must be non-candidates. This monotone
property enables early termination of search on the branches
that contain non-candidate nodes.

For any given query string sq, the string similarity search
algorithm starts from the root of the Bed-tree, and itera-
tively visits the candidate nodes, until all candidate nodes
are visited. The algorithm does not visit those non-candidate
nodes as well as their descendants. An important note is
that for each candidate node, some of its covered strings
may still be dissimilar to the query string. Therefore, given
a query string sq and a candidate Bed-tree node N that is
associated with a range [Nb, Ne], it is necessary to compute
DST (sq, s), for each s ∈ [Nb, Ne].

4. PROBLEM FORMULATION

In this section, we describe the authentication problem

that we plan to study in this paper.
System Model. We consider the outsourcing model that
involves three parties - a data owner who possesses a dataset
D that contains n string values, the user (client) who re-
quests for the similarity search on D, and a third-party ser-
vice provider (server) that executes the similarity search on
D. The data owner outsources D to the server. The server
provides storage and similarity search as services. The client
can be the data owner or a trusted party. Given the fact that
the client may not possess D, we require that the availability
of D is not necessary for the authentication procedure.
Similarity search queries. The server accepts similarity
search queries from the clients. We consider the similar-
ity search queries that take the format (S, θ), where S is a
set of query strings, and θ is the similarity threshold. We
consider two types of similarity search search queries: (1)
Single-string similarity search: the query Q contains a sin-
gle search string sq (i.e., S = {sq}). The server returns R
that contains all similar strings of sq in D; and (2) Multi-
string similarity search: Q contains multiple unique search
strings S = {s1, . . . , sℓ}. The server returns the search re-
sults in the format of {{s1, Rs1 }, . . . , {sℓ, Rsℓ }}, where
Rsi (1 ≤ i ≤ ℓ) is the set of similar strings of si in D.

Note that the query strings may not necessarily exist in D.
For each search string sq, we consider two types of similarity
outputs: (1) Un-ranked results: all the similar strings of sq
are returned without any ranking; and (2) Top-k results:
the strings that are of the top-k smallest distances to sq
are returned by their distance to sq in an ascending order.
We consider both un-ranked and top-k ranking cases in the
paper. We assume that the client sends a large number of
similarity search queries to the server.

Our query model can be easily extended to support other
types of string queries, e.g., range queries, KNN queries, and
all-pairs join queries [33] that ﬁnd all similar string pairs in
two given string datasets.
Result correctness. We deﬁne the result correctness for
two diﬀerent types of query outputs.

Un-ranked search results. Given a query string sq,
the un-ranked search result R of sq is correct if and only if
it satisﬁes the following two conditions: (1) soundness: for
any string s′ ∈ R, s′ must reside in D, and sq ≈ s′; and
(2) completeness: for any string s′ ∈ D such that sq ≈ s′,
s′ must be included in R.
In other words, for any string
s′ 6∈ R, it must be true that sq 6≈ s′.

Top-k results. Given a query string sq, let R be the
ranked search result, in which the strings are ranked by their

sig(T ) = sign(hN1 )

N1

pN2 pN3(s1, s12, hN1 )

hN2 = h(h(s1)||h(hN4 ||hN5 )||h(s6))

N2

pN4

pN5(s1, s6, hN2 )

N4

N5

(s1, s3, hN4 )

3
3
1e
1

2
2
1e
1 e

1
1
1e
e
1 e
1
1 = (s1, p1)

e

5
5
1e
1 e

6
6
1e
1

…

N3
(s7, s12, hN3 )

N6

…

N7

…

4
4
1e
e
1 e

(s4, s6, hN5 )

(s7, s9, hN6 ) (s10, s12, hN7 )

hN4 = h(h(s1)||h(h(s1)||h(s2)||h(s3))||h(s3))

Figure 1: An example of MB-tree

distance to sq in an ascending order. We use R[i] (1 ≤ i ≤ k)
to denote the i-th string of R. Then R is correct if it satisﬁes
the following two conditions: (1) soundness: ∀1 ≤ i < j ≤ k,
both R[i] and R[j] must exist in D, and DST (sq, R[i]) ≤
DST (sq, R[j]); and (2) completeness: for any string s′ 6∈ R,
it must be true that DST (sq, s′) ≥ DST (sq, R[k]).
In this paper, we assume that both the
Threat model.
data owner and the client are fully trusted. However, the
third-party server is not fully trusted as it could be compro-
mised by the attacker (either inside or outside). The server
may alter the received dataset D and return any search re-
sult that does not exist in D. It also may tamper with the
search results. For instance, the server may return incom-
plete results that omit some legitimate documents in the
similarity search results [24], or alter the ranking orders of
the top-k results. Note that we do not consider privacy pro-
tection for the user queries. This issue can be addressed
by private information retrieval (PIR) [4] and is beyond the
scope of this paper.
5. SINGLE-STRING SIMILARITY SEARCH
In this section, we consider the single-string similarity
search queries. We ﬁrst present our basic veriﬁcation ap-
proach named V S 2 (Section 5.1). Then we present our E-
V S 2 method with improved veriﬁcation cost (Section 5.2).
5.1 Basic Approach: V S 2

Given the dataset D, the query string sq, and the distance
threshold θ, the server returns all strings that are θ-similar
to sq. Besides the similar strings, the server also returns a
proof of result correctness. In this section, we explain the
details of our basic veriﬁcation method of similarity search
(V S 2). V S 2 consists of three phases: (1) the pre-processing
phase in which the data owner constructs the authenticated
data structure T of the dataset D. Both D and the root
signature sig of T are outsourced to the server; (2) the query
processing phase in which the server executes the similarity
search query on D, and constructs the veriﬁcation object
(V O) of the search results R. The server returns both R
and V O to the client; and (3) veriﬁcation phase in which
the client veriﬁes the correctness of R by leveraging V O.
Next we explain the details of these three phases.
5.1.1 Pre-Processing

In this one-time phase, the data owner constructs the au-
thenticated data structure of the dataset D before outsourc-
ing D to the server. We design a new authenticated data
structure named the Merkle Bed tree (M B-tree). Next, we
explain the details of M B-tree.

The M B-tree is constructed on top of the Bed tree by
assigning the digests to each Bed node. In particular, every
M B-tree node contains a triple (Nb, Ne, hN ), where Nb, Ne
correspond to the string range values associated with N , and

hN is the digest value computed as hN = h(h(Nb)||h(Ne)||h1→f ),
where h1→f = h(hC1 || . . . ||hCf ), with C1, . . . , Cf being the
children of N . If N is a leaf node, then C1, . . . , Cf are the
strings s1, . . . , sf covered by N . Besides the triple, each
M B-tree node contains multiple entries. In particular, for
any leaf node N , assume it covers f strings. Then it con-
tains f entries, each of the format (s, p), where s is a string
that is covered by N , and p is the pointer to the disk block
that stores s. For any intermediate node, assume that it
has f children nodes. Then it contains f entries, each entry
consisting of a pointer to one of its children nodes.

The digests of the M B-tree T can be constructed in the
bottom-up fashion, starting from the leaf nodes. After all
nodes of T are associated with the digest values, the data
owner signs the root with her private key. The signature can
be created by using a public-key cryptosystem (e.g., RSA).
An example of the M B-tree structure is presented in Figure
1. The data owner sends both D and T to the server. The
data owner keeps the root signature of T locally, and sends it
to any client who requests for it for authentication purpose.
Following [5, 19], we assume that each node of the M B-
tree occupies a disk page. For the constructed M B-tree T ,
each entry in the leaf node occupies |s| + |p| space, where
|p| is the size of a pointer, and |s| is the maximum length
of a string value. The triple (Nb, Ne, hN ) takes the space of
2|s| + h, where |h| is the size of a hash value. Therefore, a
leaf node can have f1 = [ P −2|s|−|h|
] entries at most, where P
is the page size. Given n unique strings in the dataset, there
are [ n
] leaf nodes in T . Similarly, for the internal nodes,
f1
each entry takes the space of |p|. Thus each internal node
can have at most f2 = [ P −2|s|−|h|
] entries (i.e., [ P −2|s|−|h|
]
children nodes). Therefore, the height h of T h ≥ logf2 [ n
].
f1
The construction complexity of M B-tree is O(n), where
n is the number of unique strings in D. It is cheaper than
the complexity of pairwise similarity search over D.
5.1.2 V O Construction

|p|+|s|

|p|

|p|

Upon receiving the similarity search query Q(sq, θ) from
the client, the server calculates the edit distance between
all the string pairs and distills the similar pairs. For the
similarity search result R, the server constructs a veriﬁcation
object V O to show that R are both sound and complete.

First, we deﬁne false hits. Given a query string sq and
a similarity threshold θ, the false hits of sq, denoted as F ,
are all the strings that are dissimilar to sq. In other words,
F = {s|s ∈ D, sq 6≈ s}. Intuitively, to verify that R is sound
and complete, the V O includes both similar strings R and
false hits F . Apparently including all false hits may lead to
a large V O, and thus high network communication cost and
the veriﬁcation cost at the client side. Therefore, we aim to
reduce the V O size of F .

Before we explain how to reduce V O size, we ﬁrst deﬁne
C-strings and NC-strings. Apparently, each false hit string is
covered by a leaf node of the M B-tree T . Based on whether
a leaf node in M B-tree is a candidate, the false hits F are
classiﬁed into two types: (1) C-strings: the strings that are
covered by candidate leaf nodes; and (2) N C-strings: the
strings that are covered by non-candidate leaf nodes.

Our key idea to reduce V O size of F is to include rep-
resentatives of NC-strings instead of individual NC-strings.
The representatives of NC-strings take the format of maxi-
mal false hit subtrees (M F s). Formally, given a M B-tree T ,
we say a subtree T N that is rooted at node N is a false hit

subtree if N is a non-candidate node. We say the false hit
subtree T N rooted at N is maximal if the parent of N is a
candidate node. The M F s can root at leaf nodes. Appar-
ently, all strings covered by the M F s must be NC-strings.
And each NC-string must be covered by a M F node. Fur-
thermore, M F s are disjoint (i.e., no two M F s cover the
same string). Therefore, instead of including individual NC-
strings into the V O, we include their M F s. As the number
of M F s is normally much smaller than the number of NC-
strings, this can eﬀectively reduce V O size. We are ready to
deﬁne the V O.

Definition 5.1. Given a dataset D, a query string sq,
let R be the returned similar strings of sq. Let T be the
M B-tree of D, and N C be the strings that are covered by
non-candidate nodes of T . Let M be a set of M F s of N C.
Then the V O of sq consists of: (i) string s, for each s ∈
D − N C; and (ii) a pair (N, h1→f ) for each M F ∈ M that is
rooted at node N , where N is represented as [Nb, Ne], with
[Nb, Ne] the string range associated with N , and h1→f =
h(hC1 || . . . ||hCf ), with C1, . . . , Cf being the children of N .
If N is a leaf node, then C1, . . . , Cf are the strings s1, . . . , sf
covered by N . Furthermore, in V O, a pair of brackets is
added around the strings and/or the pairs that share the
same parent in T .
Intuitively,
in V O, the similar strings and C-strings are
present in the original string format, while NC-strings are
represented by the M F s (i.e., in the format of ([Nb, Ne], hN )).

Example 5.1. Consider the MB-tree T in Figure 1, and
the query string s1. Note that s1 ∈ D (but in general sq may
not be present in D). Assume the similar strings are R =
{s1, s3, s5}. Also assume that node N6 of T is the only non-
candidate node. Then NC-strings are N C = {s7, s8, s9},
and C-strings are {s2, s4, s6, s10, s11, s12}. The set of M F s
M ={N6}. Therefore,

V O(s1) = {(((s1, s2, s3), (s4, s5, s6)), (([s7, s9], h7→9),
.

(s10, s11, s12)))}, where h7→9 = h(h(s7)||h(s8)||h(s9))

For each M F , we do not require that h(Nb) and h(Ne) ap-
pear in V O. However, the server must include both Nb and
Ne in V O. This is to prevent the server to cheat on the
non-candidate nodes by including incorrect [Nb, Ne] in V O.
More details of the robustness of our authentication proce-
dure can be found in Section 5.1.4.
5.1.3 Authentication Phase

For a given query string sq, the server returns {R, V O} to
the client. Before result authentication, the client obtains
the data owner’s public key from a certiﬁcate authority (e.g.,
VeriSign [14]). The client also obtains the hash function, the
root signature sig of the M B-tree, and the string ordering
scheme and the Bed-tree construction procedure from the
data owner. The veriﬁcation procedure consists of three
steps. In Step 1, the client re-constructs the M B-tree from
V O.
In Step 2, the client re-computes the root signature
sig′, and compares sig′ with sig. In Step 3, the client re-
computes the edit distance between sq and a subset of strings
in V O. Next, we explain the details of these steps.
Step 1: Re-construction of M B-tree: First, the client
sorts the strings and string ranges (in the format of [Nb, Ne])
in V O by their mapping values according to the string or-
dering scheme. String s is put ahead the range [Nb, Ne] if
s < Nb. It should return a total order of strings and string

ranges. If there exists any two ranges [Nb, Ne] and [N ′
b, N ′
e]
that overlap, the client concludes that the V O is not correct.
If there exists a string s ∈ R and a range [Nb, Ne] ∈ V O
such that s ∈ [Nb, Ne], the client concludes that R is not
sound, as s indeed is a dissimilar string (i.e., it is included
in a non-candidate node). Second, the client maps each
string s ∈ R to an entry in a leaf node in T , and each pair
([Nb, Ne], hN ) ∈ V O to an internal node in T . The client re-
constructs the parent-children relationships between these
nodes by following the matching brackets () in V O.
Step 2: Re-computation of root signature: After the
M B-tree T is re-constructed, the client computes the root
signature of T . For each string value s, the client calcu-
lates h(s), where h() is the same hash function used by the
data owner for the construction of the M Bed-tree. For each
internal node that corresponds to a pair ([Nb, Ne], h1→f )
in V O, the client computes the hash hN of N as hN =
h(h(Nb)||h(Ne)||h1→f ). Finally, the client re-computes the
hash value of the root node, and rebuilds the root signature
sig′ by signing hroot using the data owner’s public key. The
client then compares sig′ with sig. If sig′ 6= sig, the client
concludes that the server’s results are not correct.
Step 3: Re-computation of necessary edit distance:
First, for each string s ∈ R, the client re-computes the edit
distance DST (sq, s), and veriﬁes whether DST (sq, s) ≤ θ.
If all strings s ∈ R pass the veriﬁcation, then the client
concludes that R is sound. Second, for each C-string s ∈
V O (i.e., those strings appear in V O but not R), the client
veriﬁes whether DST (sq, s) > θ.
If it is not (i.e., s is a
similar string indeed), the client concludes that the server
fails the completeness veriﬁcation. Third, for each range
[Nb, Ne] ∈ V O, the client veriﬁes whether DSTmin(sq, N ) >
θ, where N is the corresponding M B-tree node associated
with the range [Nb, Ne]. If it is not (i.e., node N is indeed
a candidate node), the client concludes that the server fails
the soundness veriﬁcation.

Example 5.2. Consider the M B-tree in Figure 1 as an
example, and the query string s1. Assume the similar strings
R = {s1, s3, s5}. Consider the VO shown in Example 5.1.
The C-strings are C = {s2, s4, s6, s10, s11, s12}. After the
client re-constructs the M B-tree, it re-computes the hash
values of strings R ∪ C. It also computes the digest hN6 =
(h(s7)||h(s9)||h7→9). Then it computes the root signature
sig′ from these hash values. It also performs the following
distance computations: (1) for R = {s1, s3, s5}, compute
the edit distance between s1 and string in R, (2) for C =
{s2, s4, s6, s10, s11, s12}, compute the edit distance between
s1 and any C-string in C, and (3) for the pair ([s7, s9], hN6 ) ∈
V O, compute DSTmin(sq, N6).

5.1.4 Security Analysis

Given a query string sq and a similarity threshold θ, let R
(F , resp.) be the similar strings (false hits, resp.) of sq. An
untrusted server may perform the following cheating behav-
iors the real results R: (1) tampered values: some strings in
R do no exist in the original dataset D; (2) soundness vio-
lation: the server returns R′ = R ∪ F S, where F S ⊆ F ; and
(3) completeness violation: the server returns R′ = R − SS,
where SS ⊆ R.

The tampered values can be easily caught by the authenti-
cation procedure, as the hash values of the tampered strings
are not the same as the original strings. This leads to that
the root signature of M B-tree re-constructed by the client

diﬀeret from the root signature from the data owner. The
client can catch the tampered values by Step 2 of the authen-
tication procedure. Next, we mainly focus on the discussion
of how to catch soundness and completeness violations.
Soundness. The server may deal with the V O construction
of R′ = R ∪ F S in two diﬀerent ways:
Case 1. The server constructs the V O V of the correct result
R, and returns {R′, V } to the client;
Case 2. the server constructs the V O V ′ of R′, and returns
{R′, V ′} to the client. Note that the strings in F S can be
either NC-strings or C-strings. Next, we discuss how to
catch these two types of strings for both Case 1 and 2.

For Case 1, for each NC-string s ∈ F S, s must fall into
a M F -tree node in V . Thus, there must exist an M F -tree
node whose associated string range overlaps with s. The
client can catch s by Step 1 of the authentication procedure.
For each C-string s ∈ F S, s must be treated as a C-string
in V . Thus the client can catch it by computing DST (s, sq)
(i.e., Step 3 of the authentication procedure).

For Case 2, the C-strings in F S will be caught in the
same way as Case 1. Regarding NC-strings in F S, they will
not be included in any MF-tree in V ′. Therefore, the client
cannot catch them by Step 1 of the authentication proce-
dure (as Case 1). However, as these strings are included in
R′, the client still can catch these strings by computing the
edit distance of sq and any string in R′ (i.e., Step 3 of the
authentication procedure).
Completeness. To deal with the V O construction of R′ =
R−SS, we again consider the two cases as for the discussion
of correctness violation. In particular, let V and V ′ be the
V O constructed from the correct result R and the incom-
plete result R′ = R − SS respectively, where SS ⊆ R. We
discuss how to catch these two cases in details.

For Case 1 (i.e., the server returns {R′, V }), any string
s ∈ SS is a C-string. These strings can be caught by re-
computing the edit distance between the query string and
any C-string (i.e., Step 3 of the authentication procedure).
For Case 2 (i.e., the server returns {R′, V ′}), any string
s ∈ SS is either a NC-string or a C-string in V ′. For any
C-string s ∈ SS, it can be caught by re-computing the edit
distance between the query string and the C-strings (i.e.,
Step 3 of the authentication procedure). For any NC-string
s ∈ SS, it must be included into a non-candidate MB-tree
node. We have the following theorem.

Theorem 5.1. Given a query string sq and a non-candidate

node N of range [Nb, Ne], including any string s′ into N such
that s′ ≈ sq must change N to be a candidate node.
The proof is straightforward.
6∈
[Nb, Ne]. Therefore, including s′ into N must change the
range to be either [s′, Ne] or [Nb, s′], depending on whether
s′ < Nb or s′ > Ne. Now it must be true that DSTmin(sq, N ) ≤
θ, as DST (s′, sq) ≤ θ.

It is easy to see that s′

Following Theorem 5.1, for any string s ∈ SS that is
considered a NC-string in V ′, the client can easily catch
it by verifying whether DSTmin(sq, N ) > θ, for any non-
candidate node (i.e., Step 3 of the authentication procedure).
5.2 String Embedding Authentication: E-V S 2
One weakness of V S 2 is that if there exist a signiﬁcant
number of C-strings,
its V O can be of large size. This
may bring expensive network communication cost. Further-
more, since the client needs to compute the edit distance
DST (sq, s) for each C-string s, too many C-strings may in-
cur expensive veriﬁcation cost at the client side too. Our

goal is to shrink V O size with regard to C-strings, so that
both network communication cost and veriﬁcation cost can
be reduced. We observe that although C-strings are not sim-
ilar to the query string, they may be similar to each other.
Therefore, we design E-V S 2, a computation-eﬃcient method
on top of V S 2. The key idea of E-V S 2 is to construct a
set of representatives of C-strings based on their similar-
ity, and only include the representatives of C-strings in V O.
To construct the representatives of C-strings, we ﬁrst apply
a similarity-preserving mapping function on C-strings, and
transform them into the Euclidean space, so that the simi-
lar strings are mapped to the close points in the Euclidean
space. Then C-strings are organized into a small number
of groups called distant bounding hyper-rectangles (DBHs).
DBHs are the representatives of C-strings in V O.
In the
veriﬁcation phase, the client only needs to calculate the Eu-
clidean distance between sq and DBHs. Since the number
of DBHs is much smaller than the number of C-strings, and
Euclidean distance calculation is much faster than that of
edit distance, the veriﬁcation cost of the E-V S 2 approach is
much cheaper than that of V S 2. Next, we explain the de-
tails of the E-V S 2 approach. Similar to the V S 2 approach,
E-V S 2 consists of three phases: (1) the pre-processing phase
at the data owner side; (2) the query processing phase at the
server side; and (3) the veriﬁcation phase at the client side.
Next, we discuss the three phases in details.
5.2.1 Pre-Processing

Before outsourcing the dataset D to the server, similar to
V S 2, the data owner constructs the M B-tree T on D. In ad-
dition, the data owner maps D to the Euclidean space E via
a similarity-preserving embedding function f : D → E de-
note the embedding function. We use SparseMap [13] as the
embedding function due to its contractive property (Section
3). The complexity of the embedding is O(cdn2), where c is
a constant value between 0 and 1, d is the number of dimen-
sions of the Euclidean space, and n is the number of strings
of D. We agree that the complexity of string embedding is
comparable to the complexity of similarity search over D.
This naturally ﬁts into the amortized model for outsourced
computation [9]: the data owner performs a one-time com-
putationally expensive phase (in our case constructing the
embedding space), whose cost is amortized over the authen-
tication of all the future query executions.

The data owner sends D, T and the embedding function
f to the server. The server constructs the embedded space
of D by using the embedding function f . The function f
will also be available to the client for result authentication.
5.2.2 VO Construction

Given the query Q(sq, θ) from the client, the server applies
the embedding function f on sq, and ﬁnds its corresponding
node Pq in the Euclidean space. Then the server ﬁnds the
result set R of sq. To prove the soundness and completeness
of R, the server builds a veriﬁcation object V O. First, sim-
ilar to V S 2, the server searches the M B-tree to build M F s
of NC-strings. For the C-strings, the server constructs a
set of distant bounding hyper-rectangles (DBHs) from their
embedded nodes in the Euclidean space. Before we deﬁne
DBH, ﬁrst, we deﬁne the minimum distance between an Eu-
clidean point and a hyper-rectangle. Given a set of points P
{P1, . . . , Pt} in a d-dimensional Euclidean space, a hyper-
rectangle R(< l1, u1 >, . . . , < ld, ud >) is the minimum
bounding hyper-rectangle (MBH) of P if li = mint
k=1(Pk[i])

and ui = maxt
k=1(Pk[i]), for 1 ≤ i ≤ d, where Pk[i] is
the i-dimensional value of Pk. For any point P and any
hyper-rectangle R(< l1, u1 >, . . . , < ld, ud >), the mini-
mum Euclidean distance between P and R is dstmin(P, R) =

qP1≤i≤d m[i]2, where m[i] = max{li − p[i], 0, p[i] − ui. In-

tuitively, if the node P is inside R, the minimum distance
between P and R is 0. Otherwise, we pick the length of the
shortest path that starts from P to reach R. We have:

Lemma 5.1. Given a point P and a hyper-rectangle R,
for any point P ′ ∈ R, the Euclidean distance dst(P ′, P ) >
dstmin(P, R).

The proof of Lemma 5.1 is trivial. We omit the details due
to the space limit.

Now we are ready to deﬁne distant bounding hyper-rectangles

(DBHs). Given a query string sq, let Pq be its embedded
point in the Euclidean space. For any hyper-rectangle R
in the same space, R is a distant bounding hyper-rectangle
(DBH) of Pq if dstmin(Pq, R) > θ.

Given a DBH R, Lemma 5.1 guarantees that dst(Pq, P ) >
θ for any point P ∈ R. Recalling the contractive property of
the SparseMap method, we have dst(Pi, Pj) ≤ DST (si, sj)
for any string pair si, sj and their embedded points Pi and
Pj . Thus we have the following theorem:

Theorem 5.2. Given a query string sq, let Pq be its em-
bedded point. Then for any string s, s must be dissimilar
to sq if there exists a DBH R of Pq such that P ∈ R, where
P is the embedded point of s.

Based on Theorem 5.2, to prove that the C-strings are dis-
similar to the query string sq, the server can build a num-
ber of DBHs to the embedded Euclidean points of these C-
strings. We must note that not all C-strings can be included
into DBHs. This is because the embedding function may in-
troduce false positives, i.e., there may exist a false hit string
s of sq whose embedded point P becomes close to Pq. Given
a query string sq, we say a C-string s of sq is an FP-string if
dst(P, Pq) ≤ θ, where P and Pq are the embedded Euclidean
points of s and sq. Otherwise (i.e. dst(P, Pq) > θ), we call
s a DBH-string. We have:

Theorem 5.3. Given a query string sq, for any DBH-

string s, its embedded point P must belong to a DBH.

The proof of Theorem 5.3 is straightforward. For any DBH-
string whose embedded point cannot be included into a DBH
with other points, it constructs a hyper-rectangle H that
only consists of one point. Obviously H is a DBH.

Therefore, given a query string sq and a set of C-strings C,
ﬁrst, the server classiﬁes C into FP- and DBH-strings, based
on the Euclidean distance between their embedded points.
Apparently the embedded points of FP-strings cannot be
put into any DBH. Therefore, the server only consider DBH-
strings and tries builds DBHs of DBH-strings. The VO of
DBH-strings will be computed from DBHs. Therefore, in
order to minimize the veriﬁcation cost at the client side, the
server aims to minimize the number of DBHs. Formally,

M DBH Problem: Given a set of DBH-strings {s1, . . . , st},
let P {P1, . . . , Pt} be their embedded points. Construct a
minimum number of DBHs R = {R1, . . . , Rk} such that: (1)
∀Ri, Rj ∈ R, Ri and Rj do not overlap; and (2) ∀Pi ∈ P,
there exists a DBH R ∈ R such that Pi ∈ R.

Next, we present the solution to the M DBH problem.
We ﬁrst present the simple case for a 2-D dimension (i.e.
d = 2). Then we discuss the scenario when d > 2. For both

settings, consider the same input that includes a query point
Pq and set of Euclidean points P {P1, . . . , Pt} which are the
embedded points of a query string sq and its DBH-strings
respectively.
When d = 2. We construct a graph G = (V, E) such that
for each point Pi ∈ P, it corresponds to a vertex vi ∈ V . For
any two vertices vi and vj that correspond to two points Pi
and Pj , there is an edge (vi, vj ) ∈ E if dstmin(Pq, R) > θ,
where R is the MBH of Pi and Pj . We have:

Theorem 5.4. Given the graph G = (V, E) constructed
as above, for any clique C in G, let R be the MBH con-
structed from the points corresponding to the vertice in C.
Then R must be a DBH.
The proof of Theorem 5.4 is in Appendix. Based on Theo-
rem 5.4, the MDBH problem is equivalent to the well-known
clique partition problem, which is to ﬁnd the smallest num-
ber of cliques in a graph such that every vertex in the graph
belongs to exactly one clique. The clique partition problem
is NP-complete. Thus, we design the heuristic solution to
our MDBH problem. Our heuristic algorithm is based on the
concept of maximal cliques. Formally, a clique is maximal
if it cannot include one more adjacent vertex. The maxi-
mal cliques can be constructed in polynomial time [7].
It
is shown that every maximal clique is part of some optimal
clique-partition [7]. Based on this, ﬁnding a minimal num-
ber of cliques is equivalent to ﬁnding a number of maximal
cliques. Thus we construct maximal cliques of G iteratively,
until all the vertices belong to at least one clique.

There is a special case where the M DBH problem can be
solved in polynomial time: when the embedded points of all
DBH-strings lie on a single line, we can construct a minimal
number of DBHs in the complexity of O(ℓ), where ℓ is the
number of DBH-strings. Due to space limit, the details of
DBH construction can be found in Appendix.
When d > 2. Unfortunately, Theorem 5.4 can not be
extended to the case of d > 2. We found an example in
which the MBHs of the pairs (vi, vj ), (vi, vk), and (vj, vk)
are DBHs. However, the MBH of the pair (vi, vj , vk) is not
a DBH, as it includes a point w such that w is not inside
R(vi, vj ), R(vi, vk), and R(vj , vk), but dst(Pq, w) < θ.

To construct the DBHs for the case d > 2, we slightly
modify the clique-based construction algorithm for the case
d = 2. In particular, when we extend a clique C by adding
an adjacent vertex v, we check if the MBH of the extended
clique C ′ = C ∪ {v} is a DBH. If not, we delete the edges
(u, v) from G for all u ∈ C. This step ensures that if we
merge any vertex in U1 to C, the MBH of the newly gener-
ated clique is still a DBH.

For both cases d = 2 and d > 2, the complexity of con-
DS), where nDS is

structing DBHs from DBH-strings is O(n3
the number of DBH-strings.

Now we are ready to describe V O construction by the
E-V S 2 approach. Given a dataset D and a query string
sq, let R and F be the similar strings and false hits of sq
respectively. V S 2 approach groups F into C-strings and NC-
strings. E-V S 2 approach further groups C-strings into FP-
strings and DBH-strings. Then E-V S 2 constructs V O from
R, NC-strings, FP-strings, and DBH-strings. Formally,

Definition 5.2. Given a query string sq, let R be the
returned similar strings of sq. Let NC be the NC-strings,
and DS the DBH-strings. Let T be the M B-tree, M F be
the maximum false hit trees of NC. Let R be the set of DBH
constructed from DBH. Then the V O of sq consists of: (i)

sig(T ) = sign(hN1 )

N1

pN2 pN3(s1, s12, hN1 )

similar string

NC-string

DBH-string
FP-string

N2

pN4

pN5(s1, s6, hN2 )

N3

pN6

pN7

(s7, s12, hN3 )

y-axis

p7

p11

p2

R2

p10

R1

p12

p8

Ɵ

p3

p1

pq

p4

p6

p5

p9

x-axis

N4

e

(s1, s3, hN4 )

3
3
1e
1

2
2
1 e
1e

1
1
e
1e
1 e
1 = (s1, p1)

1

N5

4
4
e
1 e
1e

5
5
1 e
1e

6
6
1e
1

(s4, s6, hN5 )

N6

7
7
e
1 e
1e

8
8
1 e
1e

9
9
1e
1

(s7, s9, hN6 )

N7

10
10
1 e

1e

e
1e

11
11
1 e

12
12
1e
1

(s10, s12, hN7 )

(a) The M B-tree

(b) The embedded Euclidean space

Figure 2: An example of VO construction by E-V S 2 method

string s, for each s ∈ D − N C − DS; (ii) a pair (N, h1→f ) for
each non-leaf M F that is rooted at node N , where N takes
the format of [Nb, Ne], with [Nb, Ne] the string range associ-
ated with N , and h1→f = h(hC1 || . . . ||hCf ), with C1, . . . , Cf
being the children of N ; (iii) R; and (iv) a pair (s, pR) for
each s ∈ DS, where pR is the pointer to the DBH in R
that covers the Euclidean point of s; Furthermore, in V O, a
pair of square bracket is added around the strings pairs that
share the same parent in T .

Example 5.3. To continue with our running example in
Example 5.2, recall that the query string is s1. The similar
strings R = {s1, s3, s5}. The NC-strings N C = {s7, s8, s9}.
The C-strings C = {s2, s4, s6, s10, s11, s12}. Consider the
embedded Euclidean space shown in Figure 2 (b). Appar-
ently s4 is a FP-string as dst(pq, p4) < θ. So the DBH-
strings are {s2, s6, s10, s11, s12}. The DBHs of these DBH-
strings are shown in the rectangles in Figure 2 (b). The V O
of query string sq is
V O(sq) = {(((s1, (s2, pR2 ), s3), (s4, s5, (s6, pR2 ))), ([s7, s9], h7→9),

((s10, pR2 ), (s11, pR1 ), (s12, pR1 ))), {R1, R2}},

where h7→9 = h(h(s7)||h(s8)||h(s9))).
5.2.3 VO-based Authentication

After receiving (R, V O) from the server, the client uses
V O to verify if R is sound and complete. The veriﬁcation
of E-V S 2 consists of four steps. The ﬁrst three steps are
similar to the three steps of the V S 2 approach. The fourth
step is to re-compute a set of Euclidean distance. Next, we
discuss the four steps in details.
Step 1 & 2: these two steps are exactly the same as Step
1 & 2 of V S 2.
Step 3: Re-computing necessary edit distance: Simi-
lar to V S 2, ﬁrst, for each s ∈ R, the client veriﬁes DST (s, sq) ≤
θ. Second, for each range [Nb, Ne] ∈ V O, the client veriﬁes
whether DSTmin(sq, N ) > θ, where N is the corresponding
M B-tree node associated with the range [Nb, Ne]. The only
diﬀerence of the E-V S 2 approach is that for each FP-string
s, the client veriﬁes if DST (sq, s) > θ.
If not, the client
concludes that R is incomplete.
Step 4: Re-computing of necessary Euclidean dis-
tance: Step 3 only veriﬁes the dissimilarity of FP- and NC-
strings. In this step, the client veriﬁes the dissimilarity of
DBH-strings. First, for each pair (s, pR) ∈ V O, the client

checks if Ps ∈ R, where Ps is the embedded point of s, and
R is the DBH that pR points to. If all pairs pass the veriﬁ-
cation, the client ensures that the DBHs in V O covers the
embedded points of all the DBH-strings. Second, for each
DBH R ∈ V O, the client checks if dstmin(Pq, R) > θ.
If
it is not, the client concludes that the returned results are
not correct. Otherwise, third, for each similar string s ∈ R,
the client checks if there exists any DBH that includes Ps,
where Ps is the embedded point of s. If there does, the client
concludes that the results violate soundness.

Note that we do not require to re-compute the edit dis-
tance between any DBH-string and the query string. Instead
we only require the computation of the Euclidean distance
between a set of DBHs and the embedded points of the query
string. Since Euclidean computation is much faster than
that of the edit distance. Therefore E-V S 2 saves much veri-
ﬁcation cost compared with V S 2. More comparison of V S 2
and E-V S 2 can be found in Section 5.3.1.

Example 5.4. Following the running example in Exam-
ple 5.3, after calculating the root signature sig’ from V O and
compares it with the signature sig received from the data
owner, the client performs the following computations: (1)
for R = {s1, s3, s5}, compute the edit distances between s1
and any string in R; (2) for NC-strings N C = {s7, s8, s9},
compute DSTmin(sq, N3); (3) for FP-strings F P = {s4},
compute the edit distance DST (sq, s4); and (4) for DBR-
strings DS = {s2, s6, s10, s11, s12}, compute dstmin(Pq, R1)
and dstmin(Pq, R2). Compared with the V S 2 approach in
Example 5.2, which computes 9 edit distances, E-V S 2 com-
putes 4 edit distances, and 2 Euclidean distances. Recall
that the computation of Euclidean distance is much cheaper
than that of the edit distance.
5.3 Security Analysis

Similar to the security discussion for the V S 2 approach
(Sec. 5.1.4), the server may perform three types of cheating
behaviors, i.e., tampered values, soundness violation, and
completeness violation. E-V S 2 can catch the cheating be-
haviors of tampered values by re-computing the root sig-
nature of M B-tree (i.e., Step 2 of the authentication proce-
dure). Next, we mainly focus on how to catch the correctness
and completeness violation by the E-V S 2 approach.
Soundness. To violate soundess, the server returns R′ =
R∪F S, where F S ⊆ F (i.e., F S is a subset of false hits). We
consider two possible ways that the server constructs V O:

Phase

Measurement

Pre-processing

VO construction

Veriﬁcation

Time
Space
time

V O Size

Time

V S 2
O(n)
O(n)
O(n)

(nR + nC )σS + nM F σM
O((nR + nM F + nC )CEd) O((nR + nM F + nF )CEd + nDBH CEl)

(nR + nF )σS + nM F σM + nDBH σD

E-V S 2
O(cdn2)

O(n)
O(n + n3

DS)

Table 1: Complexity comparison between V S 2 and E-V S 2

( n: # of strings in D; c: a constant in [0, 1]; d: # of dimensions of Euclidean space; σS: the average length of the string;

σM : Avg. size of a M B-tree node; σD: Avg. size of a DBH; nR: # of strings in R; nC: # of C-strings;

nF : # of FP-strings; nDS: # of DBH-strings; nDBH : # of DBHs; nM F : # of M F nodes;

CEd: the complexity of an edit distance computation; CEl: the complexity of Euclidean distance calculation.)

(Case 1.)
the server constructs the V O V of the correct
result R, and returns {R′, V } to the client; and Case 2.) the
server constructs the V O V ′ of R′, and returns {R′, V ′} to
the client. Note that the strings in F S can be NC-strings,
FP-strings, and DBH-strings. Next, we discuss how to catch
these three types of strings for both cases.

For Case 1, for any NC-string s ∈ F S, s can be caught in
the same way as by V S 2 approach (i.e., Step 1 of authen-
tication). For any FP-string s ∈ F S, s can be caught by
re-computing the edit distance DST (s, sq) (i.e., Step 3 of
authentication). For any DBH-string s ∈ F S, let Ps be the
embedded point of s. Since the VO V is constructed from
the correct R and F , there must exist a DBH in V that in-
cludes Ps. Therefore, s can be caught by verifying whether
there exist any DBH that includes the embedded points of
s (Step 4 of the authentication procedure).

For Case 2, the NC-strings and FP-strings in F S can be
caught in the same way as in Case 1. The DBH-strings can-
not be caught by Step 4 now, as: (1) the DBHs constructed
from a subset of DBH-strings are still DBHs, and (2) no
string in F S is included in a DBH in the VO V ′. How-
ever, these DBH-strings are treated as FP-strings (i.e., not
included in any DBH), and thus can be caught by Step 3.
Completeness. To violate the completeness requirements,
the server returns returns R′ = R − SS, where SS ⊆ R. Let
V and V ′ be the VO constructed from R and R′ respectively.
We again consider the two cases as for the discussion of
soundness violation.

For Case 1 (i.e., the server returns {R′, V }), any string
s ∈ SS is a FP-string, as s is not included in R. Then by
calculating DST (s, sq), (i.e., Step 3 of the authentication
procedure), the client discovers that s is indeed similar to
sq and thus catch the incomplete results.

For Case 2 (i.e, the server returns {R′, V ′}), any string s ∈
SS is either a FP-string or a DBH-string. If s is treated as a
FP-string, it can be caught by recomputing of edit distance
(Step 3 of the authentication procedure).
If s is a DBH-
string, then its Euclidean point Ps must be included in a
DBH R. We have the following theorem.

Theorem 5.5. Given a query string sq and a DBH R
(i.e., dstmin(Pq, R) > θ), then for any string s such that
s ≈ sq, adding the embedded point of s to R must change
R to be a non-DBH.
The proof of Theorem 5.5 is straightforward. Let R′ be
the hyper-rectangle after adding Ps to R. It must be true
that dstmin(Pq, R) ≤ dst(Pq, P ) ≤ dst(sq, s) ≤ θ. Then R′
cannot be a DBH.

Following Theorem 5.5, for any string s ∈ SS, includ-
ing its embedded point into any DBH R will change R to
be a non-DBH. Then the client can easily catch it by re-
computing the euclidean distance (Step 4 of veriﬁcation).

5.3.1 V S 2 Versus E-V S 2

In this section, we compare V S 2 and E-V S 2 approaches in
terms of the time and space of the pre-processing, V O con-
struction, and veriﬁcation phases. The comparison results
are summarized in Table 1. Regarding the V O construction
overhead at the server side, as shown in our empirical study,
nDS << n, thus the overhead O(n + n3
DS) of the E-V S 2
approach is comparable to O(n) of the V S 2 approach.

Regarding the VO size, the VO size of the V S 2 approach
is calculated as the sum of two parts: (1) the total size of
the similar strings and C-strings (in string format), and (2)
the size of M F nodes. Note that σM = 2σS + |h|, where |h|
is the size of a hash value. In our experiments, it turned out
that σM /σS ≈ 10. The VO size of the E-V S 2 approach is
calculated as the sum of three parts: (1) the total size of the
similar strings and FP-strings (in string format), (2) the size
of M F nodes, and (3) the size of DBHs. Our experimental
results show that σD >> σS, σM .

Regarding the complexity of veriﬁcation time, note that
nC = nF + nDS, where nC , nF and nDS are the number of
C-strings, FP-strings, and DBH-strings respectively. Usu-
ally, nDBH < nDS as a single DBH can cover the Euclidean
points of a large number of DBH-strings. Also note that CEd
(i.e., complexity of an edit distance computation) is much
more expensive than CEl (i.e, the complexity of Euclidean
distance calculation). Our experiments show that the time
to compute one single edit distance can be 20 times of com-
puting one Euclidean distance. Therefore, compared with
V S 2, E-V S 2 signiﬁcantly reduces the veriﬁcation overhead
at the client side. We admit that it increases the overhead of
pre-processing at the data owner side and the V O construc-
tion at the server side. We argue that, as the pre-processing
phase is a one-time operation, the cost of constructing the
embedding function can be amortized by a large number of
queries from the client.

6. MULTI-STRING SIMILARITY SEARCH
So far we discussed the authentication of single-string sim-
ilarity search queries. To authenticate a multi-string query
Q(S, θ) that contains multiple unique search strings S =
{s1, . . . , sℓ}, a straightforward solution is to create VO for
each string si ∈ S and its similarity result Ri. Apparently
this solution may lead to V O of large sizes in total. Thus,
we aim to reduce the size of VOs. Our V O optimization
method consists of two main strategies: (1) optimization
by triangle inequality; and (2) optimization by overlapping
dissimilar strings.
6.1 Optimization by Triangle Inequality

It is well known that the string edit distance satisﬁes
|DST (si, sk) − DST (sj , sk)| ≤

the triangle inequality, i.e.

DST (si, sj) ≤ DST (si, sk) + DST (sj, sk). Therefore, con-
sider two query strings sq1 and sq2 , assume the the server
has executed the similarity search of sq1 and prepared the
VO of the results. Then consider the authentication of the
search results of string sq2 , for any string s ∈ D such that
DST (s, sq1 ) − DST (sq1 , sq2 ) > θ, there is no need to pre-
pare the proof of s showing that it is a false hit for sq2 . A
straightforward method is to remove s from the M B-tree T
for V O construction for query string sq2 . Now the question
is whether removing s always lead to V O of smaller sizes.
We have the following theorem.

Theorem 6.1. Given a string s and a M B-tree T , let
N ∈ T be the corresponding node of s, and NP be the
parent of N in T . Let C(NP ) be the set of children of P
in T , and N ′
P be the node constructed from C(NP )\N (i.e.,
the children nodes of Np excluding N ). Then if NP is a non-
candidate, it must be true that N ′
P must be a non-candidate.

Let [Nb, Ne] be the range of NP . The proof of Theorem 6.1
considers two possible cases: (1) s 6= Nb and s 6= Ne. Then
removing s will not change Nb and Ne, which results in that
both N ′
p and Np have the same range [Nb, Ne]. (2) s = Nb
or s = Ne. Then removing s from C(NP ) changes the range
of NP to be [N ′
e] ⊆
[Nb, Ne]. Therefore, N ′

e]. Note that it must be true [N ′

P must be a non-candidate.

b, N ′

b, N ′

Based on Theorem 6.1, removing the M B-tree nodes that
correspond to any dissimilar string indeed does not change
the structure of the M B-tree. Therefore, we can optimize
the VO construction procedure by removing those strings
covered by the triangle inequality from the M B-tree.

Another possible optimization by triangle inequality is
that for any two query strings sq1 and sq2 , for any string
s ∈ D such that DST (s, sq1 ) + DST (sq1 , sq2 ) ≤ θ, then the
client does not need to re-compute DST (s, sq2 ) proving that
sj is a similar string in the results. We omit the details due
to the space limit.
6.2 Optimization by Overlapped Dissimilar Strings

Given multiple-string search query, the key optimization
idea is to merge the VOs of individual query strings. This
is motivated by the fact that any two query strings si and
sj may share a number of dissimilar strings. These shared
dissimilar strings can enable to merge the VOs of si and sj .
Note that simply merging all similar strings of si and sj into
one set and constructing M B-tree of the merged set is not
correct, as the resulting M B-tree may deliver non-leaf M F s
that are candidates to both si and sj . Therefore, given two
query strings si and sj such that their false hits overlap, let
N Ci (N Cj, resp.) and DBHi (DBHj, resp.) be the N C-
strings and DBH-strings of si (sj resp.), the server ﬁnds
the overlap of N Ci and N Cj , as well as the overlap between
DBHi and DBHj . Then the server constructs V O that
shares the same data structure on these overlapping strings.
In particular, ﬁrst, given the overlap O1 = N Ci ∩ N Cj, the
server constructs the non-leaf M F s from O1, and include
the constructed M F s in the VOs of both si and sj. Second,
given the overlap O2 = DBHi∩DBHj, the server constructs
the DBHs from O2, and include the constructed DBHs in
the VOs of both si and sj .
7. AUTHENTICATION OF TOP-K RESULTS
In this section, we discuss how to authenticate the top-k
similarity results. Formally, given a query string sq and a

threshold value θ > 0, the query is to ﬁnd the top-k simi-
lar strings of s, which are sorted by their distance to the
query string sq in ascending order.
In other words, the
query returns a set of strings R = {s1, s2, . . . , sk}, where
DST (s, si) ≤ θ and DST (s, si) ≤ DST (s, si+1), ∀i ∈ [1, k −
1]. Let c be the number of strings that are similar to s in
terms of θ. We consider two cases: (1) k = c (i.e., all simi-
lar strings are ranked); and (2) k < c (i.e., only a subset of
similar strings are returned).
k=c. Besides verifying the soundness and completeness of
the returned strings, the authentication procedure checks if
the ranking is correct. Both the soundness and completeness
veriﬁcation can be achieved by our V S 2 or E-V S 2 approach.
A straightforward solution to ranking authentication is to
calculate the pairwise distance DST (sq, s) for any s ∈ R,
re-sort strings in R based on their distances, and compare
the ranking results with R. Since the calculation of pair-
wise distance is required for soundness veriﬁcation (for both
V S 2 and E-V S 2), the authentication can be done by one
additional sorting step.
k<c. Given a query string sq and the top-k similar strings
R = {s1, s2, . . . , sk}, the client needs to verify:

Requirement 1. No returned strings are tampered with,

i.e., ∀si ∈ R, i ∈ [1, k], si ∈ D;

Requirement 2. ∀i ∈ [1, k − 1], DST (si, sq) ≤ θ, and

DST (si, sq) ≤ DST (si+1, sq);

Requirement 3. No genuine top-k results are missing, i.e.,

∀si 6∈ R, DST (si, sq) ≥ DST (sk, sq).

Requirement 1 can be easily veriﬁed by restoring the di-
gests of the root signature of the M B-tree. Requirement 2
can be veriﬁed by two steps: (1) verifying the soundness of
R by either our V S 2 or E-V S 2 approach; (2) re-compute
DST (si, sq) for each si ∈ R, and sort the strings of R by
their distance in an ascending order. Requirement 3 can
be veriﬁed by checking whether for all the false ﬁts in the
VO, their distance to sq is longer than DST (sk, sq). This
is equivalent to checking whether the server returns sound
the complete results with regard to the similarity threshold
θ = DST (sk, sq). Therefore, we can use V S 2 and E-V S 2
approaches to construct VO and do veriﬁcation, by using
the similarity threshold as DST (sk, sq).
8. EXPERIMENTS

In this section, we report the experiment results.

8.1 Experiment Setup
Datasets and queries. We use two real-world datasets
collected by US Census Bureau in 19901: (1) the LastName
dataset that contains 88799 last names. The maximum
length of a name is 13, while the average is 6.83; and (2)
the FemaleName dataset including 4475 actor names. The
maximum length of a name is 11, while the average length is
6.03. We designed ten single-string similarity search queries.
For the following results, we report the average of the ten
queries.
Parameter setup. The parameters include:
(1) string
edit distance threshold θ, (2) dimension d of the embed-
ding space, and (3) the fanout f of M B-tree nodes (i.e., the
number of entries that each node contains). The details of
the parameter settings can be found in Table 2 in Appendix.
We also include the details of the query selectivity in Table
3 in Appendix.

1http://www.census.gov/topics/population/genealogy/data/1990_census

Due to space limits, the details of experimental environ-
ments are in Appendix. For the following discussions, we
use the following notations: (1) n: the number of strings in
the dataset, (2) nR: the number of similar strings, (3) nM F :
the number of M F s, (4) nC : the number of C-strings, (5)
nF : the number of FP-strings, (6) nDBH : the number of
DBHs, and (7) nDS: the number of DBH-strings. We use
σS to indicate the average string size, and σM (σS, resp.) as
the size of M B-tree node (DBH, resp.).

8.2 VO Construction Time

We measure the VO construction time at the server side

by both V S 2 and E-V S 2 methods.
The impact of θ. In Figure 3 (a), we show the VO con-
struction time with regard to diﬀerent θ values. First, we
observe that there is an insigniﬁcant growth of VO construc-
tion time by V S 2 when θ increases. For example, on the
LastName dataset, the time increases from 0.7085 seconds
to 0.7745 seconds when θ changes from 2 to 6. This is be-
cause the number of M F s reduces with the increase of θ. For
example, when θ = 2, nM F = 390, while θ = 6, nM F = 0.
Consequently, V S 2 visits more M B-tree nodes to construct
the VO. However, compared with n, the increase of nM F
is not signiﬁcant. Therefore, the VO construction time of
V S 2 slightly increases with the growth of θ. Second, we
observe the dramatic decrease in VO construction of the E-
V S 2 when θ increases. This is because with the increase of
θ value, nR rises, while nDS reduces sharply (e.g., on Last-
Name dataset, when θ = 2, nR = 136, nDS = 13928; when
θ = 3, nR = 1104, nDS = 3568.6. Since the complexity of
VO construction is cubic to nDS, the total VO construction
time decreases intensively when nDS decreases.
The impact of d. We change the dimension d of the em-
bedding space and observe its impact on VO construction
time. The results are displayed in Figure 3 (b). On both
datasets, d has no eﬀect on V S 2, because V S 2 does not
interact with the embedding space. However, the time per-
formance of E-V S 2 increases with the d value. Intuitively,
larger dimension leads to smaller nF , and thus larger nDS.
As the VO construction time of E-V S 2 is cubic to nDS, the
VO construction time increases when d increases.
The impact of f . For both approaches, we observe that
the VO construction time is stable for various f fanout
values (Figure 3 (c)). This is because the complexity of
VO construction is decided by the number of strings in the
dataset and the number of DBH-strings. Both numbers do
not change by f values.

8.3 VO Size

We measure the size of the VO constructed by the V S 2

and E-V S 2 approaches.
The impact of θ. The results are shown in Figure 4 (a).
The ﬁrst observation is that the VO size of V S 2 with θ value.
Apparently, larger θ values lead to more similar strings (i.e.,
larger nR), fewer M F s (i.e., smaller nM F ), and fewer C-
strings (i.e., smaller nC ). As the VO size is decided by
(nR +nC)σS +nM F σM , where σM /σS ≈ 10, and the increase
of (nR + nC )σS is cancelled out by the decrease of nM F σM ,
the VO size of V S 2 approach stays relatively stable. On
the contrary, for the E-V S 2 approach, since σD >> σS, σM ,
the VO size is dominately decided by nDBH . We observe
that the slight increase of θ values lead to sharp decrease of
nDS and thus nDBH (e.g., when θ = 2, nDBH = 1272; when

θ = 6, nDBH = 5). Thus the VO size decreases signiﬁcantly
for larger θ. When θ ≥ 4, the VO size of E-V S 2 is very close
to that of V S 2.
The impact of d. From the results reported in Figure 4
(b), we observe that VO size of V S 2 is not aﬀected by var-
ious d values. This is straightforward as V S 2 does not rely
on embedding. On the other hand, the VO size of E-V S 2
increases with larger dimension value, since larger dimen-
sion leads to smaller nF , larger nDS, and thus larger nDBH .
Furthermore, when d increases, the average DBH size in-
creases too. These two factors contribute to the growth of
VO size for the E-V S 2.
The impact of f . As shown in Figure 4 (c), the VO size
decreases with the growth of the fanout f . First, for V S 2,
recall that its V O size is calculated as (nR+nC)σS+nM F σM .
When f increases, nR is unchanged. Meanwhile, nC slightly
grows with f (e.g., when f = 10, nC = 86, 216, while when
f = 40, nC = 87, 695). Furthermore, when f increases, nM F
decreases (when f = 10, nM F = 148, while when f = 40,
nM F = 0). Also σM /σS ≈ 10. Therefore, the decrease of
nM F leads to smaller VO size. For E-V S 2, by which the
VO size is measured (nR + nF )σS + nM F σM + nDBH σD,
again nR is unchanged, while nM F decreases for larger f .
However, nF and nDBH keep relatively stable with diﬀerent
f (e.g., when f = 10, nF = 82688, nDBH = 80; when
f = 40, nF = 84108, nDBH = 80). Therefore, the VO size
by E-V S 2 approach decreases with the growth of f .

Another observation is that the VO size of V S 2 is always
larger than that of E-V S 2. This is straightforward as E-
V S 2 has to include DBHs in VO, which contributes to a
substantial portion of VO in terms of its size. Nevertheless,
as nDBH is small in most cases (always smaller than 100),
the additional VO size required by E-V S 2 is not substantial
compared with the total VO size.

8.4 VO Veriﬁcation Time

In this section, we measure the VO veriﬁcation time at
the client side. We split the veriﬁcation into ﬁve compo-
nents: (1) time to verify the similarity of the returned simi-
lar strings (Result Veriﬁcation), (2) time to re-construct the
root signature of MB-tree and verifying NC-strings (MBtree
Veriﬁcation), (3) time to compute edit distance for C-strings
(C-string Veriﬁcation), (4) time to calculate the Euclidean
distance for DBH-strings (DBH-string Veriﬁcation), and (5)
time to compute the edit distance for FP-strings (FP-string
Veriﬁcation). We use the FemaleName dataset and report
these ﬁve components in details.

Before we discuss speciﬁc parameters, an important ob-
servation is that the veriﬁcation time of E-V S 2 can be as
small as 75% of V S 2. This proves that E-V S 2 can save the
veriﬁcation time at the client side signiﬁcantly.
The impact of θ. From Figure 5 (a), we observe that,
ﬁrst, the MBtree Veriﬁcation time keeps stable. This is be-
cause the number of M BHs is small (always smaller than
10). Even though the increase of θ decreases the number of
M BHs, the time to re-construct the root signature does not
increase much. Second, the Result Veriﬁcation time (0.4% -
32% of the total veriﬁcation time) increases sharply with
θ as the number of similar strings increases fast with θ.
For example, when θ = 2, nR = 31, while when θ = 6,
nR = 2385. Third, the C-string Veriﬁcation time decreases
when θ grows, since the number of C-strings drops fast with
the rapid growth of similar strings. For V S 2, there is no

)
d
n
o
c
e
S

l

(
 
e
a
c
s
g
o
L

 

e
m
T

i

)

B
K

(
 

i

e
z
S
O
V

 

 10000

 1000

 100

 10

 1

 0.1

VS2
E-VS2

 2  2.5

 3  3.5

 4  4.5

 5  5.5

 6

Threshold value

)
d
n
o
c
e
S

l

(
 
e
a
c
s
g
o
L

 

e
m
T

i

 1000

 100

VS2
E-VS2

 10

 1

 0.1

 5

 1
0

 1
5

 2
0

 2
5

Embedding Space Dimension

)
d
n
o
c
e
S

l

(
 
e
a
c
s
g
o
L

 

e
m
T

i

 1000

 100

 10

 1

 0.1

VS2
E-VS2

 1
0

 1
5

 2
0

 2
5

 3
0

 3
5

 4
0

Fanout

(a) Various θ (d = 5, f = 10)

(b) Various d (θ = 3, f = 10)

(c) Various f (θ = 3, d = 5)

Figure 3: VO construction time (LastName dataset)

 1200

 1000

 800

 600

 400

 200

 0

VS2
E-VS2

)

B
K

(
 

i

e
z
S
O
V

 

VS2
E-VS2

 1200

 1000

 800

 600

 400

 200

 2  2.5

 3  3.5

 4  4.5

 5  5.5

 6

 0

 5

Threshold value

 1
0

 1
5

 2
0

 2
5

Embedding Space Dimension

)

B
K

(
 

i

e
z
S
O
V

 

 1200

 1000

 800

 600

 400

 200

 0

VS2
E-VS2

 1
0

 1
5

 2
0

 2
5

 3
0

 3
5

 4
0

Fanout

(a) Various θ (d = 5, f = 10)

(b) Various d (θ = 3, f = 10)

(c) Various f (θ = 3, d = 5)

Figure 4: VO size (LastName dataset)

)
d
n
o
c
e
S
(
 
e
m
T

i

  0.045
  0.04
  0.035
  0.03
  0.025
  0.02
  0.015
  0.01
  0.005
  0

FP−string Verification
DBH Verification
C−string Verification
Result Verification
MBtree Verification

S
S
V

S
S
V

S
S
V
E

)
d
n
o
c
e
S
(
 
e
m
T

i

  0.04

  0.035

  0.03

  0.025

  0.02

  0.015

  0.01

  0.005

  0

S
S
V

S
S
V
E

S
S
V

S
S
V
E

S
S
V
E

S
S
V

S
S
V

S
S
V
Threshold value
E

S
S
V
E

FP−string Verification
DBH Verification
C−string Verification
Result Verification
MBtree Verification

S
S
V

S
S
V
E

)
d
n
o
c
e
S
(
 
e
m
T

i

  0.045

  0.04

  0.035

  0.03

  0.025

  0.02

  0.015

  0.01

  0.005

  0

FP−string Verification
DBH Verification
C−string Verification
Result Verification
MBtree Verification

S
S
V
E

S
S
V

S
S
V
E

S
S
V

S
S
V

S
S
V
E

Fanout

S
S
V
E

S
S
V

S
S
V

S
S
V
E

S
S
V

S
S
V
E

S
S
V

S
S
V
E

Embedding Space Dimension

(a) Various θ (d = 5, f = 10)

(b) Various d (θ = 2, f = 10)

(c) Various f (θ = 2, d = 5)

Figure 5: VO veriﬁcation time (FemaleName dataset)

DBH− or F P -string, leading to zero DBH-string and FP-
string Veriﬁcation time. Regarding the E-V S 2 approach,
we only discuss DBH-string Veriﬁcation time and FP-string
Veriﬁcation time, as the other components are the same
as the V S 2 approach. Due to the eﬃcient Euclidean dis-
tance calculation, the DBH-string Veriﬁcation time is very
small (smaller than 0.2% of the total veriﬁcation time). The
FP-string Veriﬁcation time decreases when θ grows, as a
large portion of FP-strings become similar when θ increases.
Overall, the total veriﬁcation time of E−V S 2 increases when
θ changes from 2 to 4, but keeps stable after that. This is
because when θ increases from 2 to 4, nDS drops very fast
(from 1349 to 45). The time saved by verifying the DBHs
thus shrinks. When θ > 4, nDS does not change much (from
45 to 4). Thus the total veriﬁcation time keeps stable.
The impact of d. We only discuss the veriﬁcation time of
E-V S 2 as the veriﬁcation time of V S 2 does not rely on the
dimension of the embedding space. According to the results
shown in Figure 5 (b), for E-V S 2, the total veriﬁcation time
keeps stable with the increase of d. The reason is that the
number of DBH-strings varies little much with the increase
of d. When d = 5, nDS = 1349; when d = 25, nDS =
1357. This shows that E − V S 2 is eﬃcient even for the
high-dimension embedding space.
The impact of f . According to the results shown in Figure
5 (c), larger f value results in shorter veriﬁcation time for
both approaches. The reason is that larger f leads to a
smaller M B-tree, and thus small time to re-compute the

tree’s root signature.
9. CONCLUSION

In this paper, we designed two eﬃcient authentication
methods, namely V S 2 and E-V S 2, for outsourced string sim-
ilarity search. Both V S 2 and E-V S 2 approaches are based
on a novel authentication data structure named M B-tree
that integrates both Bed-tree and Merkle hash tree. The
E-V S 2 approach further applies string embedding methods
to merge dissimilar strings into smaller V O. Experimental
results show that our methods authenticate similarity query
searches eﬃciently. In the future, we will investigate how to
design authentication methods for database with updates.
We also plan to study how to authenticate the correctness
of privacy-preserving string similarity search.

10. APPENDIX

10.1 Proof of Theorem 5.4

We construct a graph G = (V, E) such that for each point
Pi ∈ P, it corresponds to a vertex vi ∈ V . For any two
vertices vi and vj that correspond to two points Pi and Pj,
there is an edge (vi, vj ) ∈ E if dstmin(Pq, R) > θ, where R
is the MBH of Pi and Pj. We have the following theorem:
given the graph G = (V, E) constructed as above, for any
clique C in G, let R be the MBH constructed from the points
corresponding to the vertice in C. Then R must be a DBH.
Proof. We prove it by induction. Let |C| denote the number

vj

vk

P 1

Pi

P 2

P 4

Pj

P 3

RC

R(P ′, P 2) R(P ′, P 3)

P 1

Pi

R(P ′, P 1)

RC

P 2

R(P ′, P 3)

P 4

Pj

P 3

vi

P ′

P ′

(a) Base case

(b) Case 2 of induction

(c) Case 3 of induction

Figure 6: Illustration: Proof of Theorem 5.4

of vertices in the clique. It is trivial to show that the theorem
holds if |C| < 3. Next, we mainly discuss |C| ≥ 3.
Base case. When |C| = 3, let vi, vj and vk denote the ver-
tices in the clique C. Let Rij , Rjk, and Rik be the MBHs
constructed from the pairs (vi, vj), (vj , vk), and (vi, vk) re-
spectively. Let Rijk be the MBH constructed from vi, vj ,
and vk. Apparently Rijk = Rij ∪ Rjk ∪ Rik. Given the fact
that dstmin(p, Rij ) > θ, dstmin(p, Rik) > θ, and dstmin(p, Rjk) >
θ, it must be true that
dstmin(p, Rijk) > θ. Therefore, R must be a DBH.
Induction step. If we add v′ into C, we get a new clique
C ′. Let RC ′ be the MBH constructed from C ′. Next, we
prove that RC ′ is always a DBH. We prove this for three
cases: (1) P ′ ∈ RC , (2) P ′ falls out of the range of RC at
one dimension, and (3) P ′ falls out of the range of RC at
both dimensions.

Case 1. P ′ ∈ RC . This case is trivial as it is easy to see

that RC ′ = RC . So RC ′ must be a DBH.

Case 2. At exactly one dimension, P ′ falls out of RC .
Then it must be true that either P ′[i] < lC
i or P ′[i] > uC
i ,
for either i = 1 or i = 2. Without loss of generality, we deﬁne
the four boundary nodes of RC as P 1, P 2, P 3, and P 4 (as
shown in Figure 6 (b)). Also we assume that P ′[1] ∈ [lC
1 , uC
1 ]
and P ′[2] < lC
1 >
2 >) = RC ∪ R(P ′, P 2) ∪ R(P ′, P 3). Apparently,
, < P ′[2], uC
RC is covered by RC ′ .

2 . It is easy to see that RC ′ = (< lC

1 , uC

Before we prove that RC ′ is a DBH, we present a lemma.

d >) and R2(< l2

Lemma 10.1. Given two rectangles R1(< l1

1 >, . . . , <
d >) in the same
i ≤
i for any i = 1, . . . , d, then dstmin(P, R1) ≥ dstmin(P, R2)

l1
d, u1
Euclidean space, if R1 is covered by R2, i.e. l2
u2
for any point P .

1 >, . . . , < l2

i ≤ u1

d, u2

1, u2

1, u1

i ≤ l1

Lemma 10.1 states that if R1 is covered by R2, for any
point P , its minimum distance to R1 is no less than the
minimum distance to R2.

Next, let’s consider RC ′ that is constructed from adding
the point P ′ to the existing DBH RC . We pick a point
Pi ∈ RC ′ (1 ≤ i ≤ t) s.t. Pi[1] = lC
1 ].
Apparently, R(P ′, P 2) is covered by R(P ′, Pi). Because
there is an edge between v′ and vi in the graph G, it must
be true that dstmin(Pq, R(P ′, Pi)) > θ. Following Lemma

1 and Pi[2] ∈ [lC

1 , uC

10.1, we can infer that dstmin(Pq, R(P ′, P 2)) > θ. Simi-
larly, there must be a point Pj with Pj [1] = uC
1 and Pj [2] ∈
1 ]. Because R(P ′, P 3) is covered by R(P ′, Pj ) and
1 , uC
[lC
dstmin(Pq, R(P ′, Pj)) > θ, we can prove that dstmin(Pq, R(P ′, P 3)) >
θ. Thus, we prove that dstmin(Pq, RC ′ ) > θ and RC ′ is a
DBH.

i or P ′[i] > uC

2 . It is easy to see that RC ′ = (< P ′[1], uC

Case 3. On both dimensions, P ′ falls out of RC . For-
i , for both i = 1, 2.
1 , uC
1 ]
1 >
2 >) = RC ∪ R(P ′, P 1) ∪ R(P ′, P 3). There
2 and Pi[1] ∈
1 ]. In other words, R(P ′, P 1) is covered by R(P ′, Pi).

mally, either p′[i] < lC
Without loss of generality, we assume that P ′[0] ∈ [lC
and P ′[2] < lC
, < P ′[2], uC
must exists a Pi(1 ≤ i ≤ t) s.t. Pi[2] = uC
[lC
1 , uC
As dstmin(Pq, R(P ′, Pi)) > θ, it must be true that dstmin(Pq, R(P ′, P 1)) >
θ. Similar to Case 2, we can prove that dstmin(Pq, R(P ′, P 3)) >
θ based on Pj. Thus, we prove that dstmin(Pq, RC ′ ) > θ and
RC ′ is a DBH.
10.2 Special Case of M DBH Problem

There is a special case where the M DBH problem can
be solved in polynomial time. In particular, when the em-
bedded points of all DBH-strings lie on a single line, we can
construct a minimal number of DBHs in the complexity of
O(ℓ), where ℓ is the number of DBH-strings. Let L be the
line that the embedded points of DBH-strings lie on. We
draw a perpendicular line from Pq to L. Let dst(Pq, L) be
the distance between Pq and L. Depending on the relation-
ship between θ and dst(Pq, L), there are two cases:

Case 1: dst(Pq, L) > θ. We construct the MBH of all the

embedded points of DBH-strings.

Case 2: dst(Pq, L) ≤ θ. The perpendicular line splits all
points of DBH strings into two subsets, PL and PR, where
PL includes the embedded points that are at one side of L,
and PR be the points at the other side. A special case is
that Pq lies on L. For this case, Pq still splits all points on
L into two subsets, PL and PR. It is possible that PL or
PR is empty. For each non-empty PL or PR, we construct a
corresponding MBH.

We have the following theorem.

Theorem 10.1. Proof For Case 1, if dst(Pq, L) > θ, for
any point P located on L, it must be true that dst(Pq, P ) ≥
dst(Pq, L) > θ. For Case 2, if PL is non-empty, then dstmin(Pq, PL) ≥

min{dst(Pq, P )|P ∈ PL} > θ. So PL must be a DBH. The
same reasoning holds for PR.

10.3 Experiments: Experimental environment
We implement both V S 2 and E-V S 2 approaches in C++.
The hash function we use is the SHA256 function from the
OpenSSL library. We execute the experiments on a machine
with 2.5 GHz CPU and 6 GB RAM, running Mac OS X
10.10.
10.4 Experiments: Parameter Settings

Table 2 includes the details of the parameter settings of

our experiments.
10.5 Experiments: Selectivity of Search Queries

In Table 3, we report the selectivity of the threshold values
on both datasets, where selectivity is deﬁned as the percent-
age of similar strings in the dataset. The reported result is
the average selectivity of 10 query strings.

θ Lastname Femalename
2
3
4
5
6

0.7277
3.329
10.61
27.49
55.80

0.1378
1.1188
5.214
16.4

39.015

Table 3: Selectivity (%) of search queries w.r.t. diﬀerent

threshold values

11. REFERENCES
[1] A. Arasu, V. Ganti, and R. Kaushik. Eﬃcient exact

set-similarity joins. In Proceedings of the 32nd
international conference on Very large data bases
(VLDB), pages 918–929, 2006.

[2] S. Chaudhuri, K. Ganjam, V. Ganti, and R. Motwani.

Robust and eﬃcient fuzzy match for online data
cleaning. In Proceedings of the 2003 ACM SIGMOD
international conference on Management of data,
pages 313–324, 2003.

[3] W. Cheng and K.-L. Tan. Query assurance veriﬁcation

for outsourced multi-dimensional databases. Journal
of Computer Security, 17(1):101–126, 2009.

[4] B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan.

Private information retrieval. Journal of the ACM
(JACM), 45(6):965–981, 1998.

[5] D. Comer. Ubiquitous b-tree. ACM Computing

Surveys (CSUR), 11(2):121–137, 1979.

[6] G. Cong, C. S. Jensen, and D. Wu. Eﬃcient retrieval

of the top-k most relevant spatial web objects.
Proceedings of the VLDB Endowment, 2(1):337–348,
2009.

[7] S. Eidenbenz and C. Stamm. Maximum clique and

minimum clique partition in visibility graphs. In
Theoretical Computer Science: Exploring New
Frontiers of Theoretical Informatics, pages 200–212.
Springer, 2000.

[8] C. Faloutsos and K.-I. Lin. FastMap: A fast algorithm

for indexing, data-mining and visualization of
traditional and multimedia datasets, volume 24. ACM,
1995.

[9] R. Gennaro, C. Gentry, and B. Parno. Non-interactive

veriﬁable computing: Outsourcing computation to
untrusted workers. In Advances in Cryptology
(CRYPTO), pages 465–482. 2010.

[10] M. T. Goodrich, C. Papamanthou, D. Nguyen,
R. Tamassia, C. V. Lopes, O. Ohrimenko, and
N. Triandopoulos. Eﬃcient veriﬁcation of web-content
searching through authenticated web crawlers.
Proceedings of the VLDB Endowment, 5(10):920–931,
2012.

[11] H. Hacig¨um¨u¸s, B. Iyer, C. Li, and S. Mehrotra.

Executing sql over encrypted data in the
database-service-provider model. In Proceedings of the
2002 ACM SIGMOD international conference on
Management of data, pages 216–227, 2002.

[12] G. Hjaltason and H. Samet. Contractive embedding

methods for similarity searching in metric spaces.
Technical report, Technical Report TR-4102,
Computer Science Department.

[13] G. R. Hjaltason and H. Samet. Properties of

embedding methods for similarity searching in metric
spaces. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, 25(5):530–549, 2003.

[14] R. Housley, W. Ford, W. Polk, and D. Solo. Internet
X.509 Public Key Infrastructure Certiﬁcate and CRL
Proﬁle. RFC 2459, RFC Editor, 1999.

[15] L. Hu, W.-S. Ku, S. Bakiras, and C. Shahabi. Spatial

query integrity with voronoi neighbors. IEEE
Transactions on Knowledge and Data Engineering,
25(4):863–876, 2013.

[16] L. Jin, C. Li, and S. Mehrotra. Eﬃcient record linkage

in large data sets. In Database Systems for Advanced
Applications, 2003.(DASFAA 2003). Proceedings.
Eighth International Conference on, pages 137–146.
IEEE, 2003.

[17] N. Koudas, S. Sarawagi, and D. Srivastava. Record

linkage: similarity measures and algorithms. In
Proceedings of the 2006 ACM SIGMOD international
conference on Management of data, pages 802–803,
2006.

[18] C. Li, J. Lu, and Y. Lu. Eﬃcient merging and ﬁltering

algorithms for approximate string searches. In IEEE
24th International Conference on Data Engineering
(ICDE), pages 257–266, 2008.

[19] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin.

Dynamic authenticated index structures for
outsourced databases. In Proceedings of the 2006 ACM
SIGMOD international conference on Management of
data, pages 121–132, 2006.

[20] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin.

Dynamic authenticated index structures for
outsourced databases. In Proceedings of the 2006 ACM
SIGMOD international conference on Management of
data, pages 121–132. ACM, 2006.

[21] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin.

Authenticated index structures for aggregation
queries. ACM Transaction of Information and System
Security, 13:1–35, December 2010.

[22] A. J. Menezes, P. C. Van Oorschot, and S. A.

Vanstone. Handbook of applied cryptography. CRC
press, 1996.

[23] E. Mykletun, M. Narasimha, and G. Tsudik.

Parameter

dataset

setting

Similarity threshold θ

Dimension d of embedding space

MB-tree fanout f

Lastname

2, 2.5, 3. 3.5, 4, 4.5, 5, 5.5, 6

Femalename

Lastname

Femalename

Lastname

Femalename

2, 3, 4, 5, 6

5, 10, 15, 20, 25
5, 10, 15, 20, 25

10, 15, 20, 25, 30, 35, 40

5, 10, 15, 20

Table 2: Parameter settings

Authentication and integrity in outsourced databases.
Transaction of Storage, 2:107–138, May 2006.

[24] H. Pang and K. Mouratidis. Authenticating the query

results of text search engines. Proceedings of the
VLDB Endowment, 1(1):126–137, 2008.

[25] H. Pang, J. Zhang, and K. Mouratidis. Scalable

veriﬁcation for outsourced dynamic databases.
Proceedings of VLDB Endowment, 2:802–813, August
2009.

[26] S. Papadopoulos, L. Wang, Y. Yang, D. Papadias, and

P. Karras. Authenticated multistep nearest neighbor
search. Knowledge and Data Engineering, IEEE
Transactions on, 23(5):641–654, 2011.

[27] C. Papamanthou, R. Tamassia, and N. Triandopoulos.
Optimal veriﬁcation of operations on dynamic sets. In
Advances in Cryptology (CRYPTO), pages 91–110.
2011.

[28] R.C.Merkle. Protocols for public key cryptosystems.

In Symposium on Security and Privacy, pages
122–134, 1980.

[29] D. Wu, B. Choi, J. Xu, and C. S. Jensen.

Authentication of moving top-k spatial keyword
queries. IEEE Transactions on Knowledge and Data
Engineering, 27(4):922–935, 2015.

[30] Y. Yang, D. Papadias, S. Papadopoulos, and

P. Kalnis. Authenticated join processing in outsourced
databases. In Proceedings of the 2009 ACM SIGMOD
International Conference on Management of data,
pages 5–18. ACM, 2009.

[31] Y. Yang, S. Papadopoulos, D. Papadias, and

G. Kollios. Spatial outsourcing for location-based
services. In Proceedings of IEEE 24th International
Conference on Data Engineering (ICDE), pages
1082–1091, 2008.

[32] M. L. Yiu, E. Lo, and D. Yung. Authentication of

moving knn queries. In IEEE 27th International
Conference on Data Engineering (ICDE), pages
565–576, 2011.

[33] Z. Zhang, M. Hadjieleftheriou, B. C. Ooi, and

D. Srivastava. Bed-tree: an all-purpose index structure
for string similarity search based on edit distance. In
Proceedings of the 2010 ACM SIGMOD International
Conference on Management of data, pages 915–926.
ACM, 2010.

