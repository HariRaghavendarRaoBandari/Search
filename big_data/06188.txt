An angular momentum conserving Aﬃne-Particle-In-Cell method

Chenfanfu Jiang, Craig Schroeder, Joseph Teran1

Department of Mathematics

University of California Los Angeles

6
1
0
2

 
r
a

 

M
0
2

 
 
]
h
p
-
p
m
o
c
.
s
c
i
s
y
h
p
[
 
 

1
v
8
8
1
6
0

.

3
0
6
1
:
v
i
X
r
a

Abstract

We present a new technique for transferring momentum and velocity between particles and grid with
Particle-In-Cell (PIC) [1] calculations which we call Aﬃne-Particle-In-Cell (APIC). APIC represents
particle velocities as locally aﬃne, rather than locally constant as in traditional PIC. We show that
this representation allows APIC to conserve linear and angular momentum across transfers while also
dramatically reducing numerical diﬀusion usually associated with PIC. Notably, conservation is achieved
with lumped mass, as opposed to the more commonly used Fluid Implicit Particle (FLIP) [2, 3] transfers
which require a “full” mass matrix for exact conservation. Furthermore, unlike FLIP, APIC retains
a ﬁltering property of the original PIC and thus does not accumulate velocity modes on particles as
FLIP does. In particular, we demonstrate that APIC does not experience velocity instabilities that are
characteristic of FLIP in a number of Material Point Method (MPM) hyperelasticity calculations. Lastly,
we demonstrate that when combined with the midpoint rule for implicit update of grid momentum that
linear and angular momentum are exactly conserved.

Keywords: PIC, FLIP, MPM, APIC, hybrid Lagrangian/Eulerian, particle-grid

1. Introduction

PIC methods have been used for decades to simulate many diﬀerent physical phenomena. Examples
include compressible ﬂow, incompressible ﬂow, plasma physics, computational solids and many more
[4]. PIC utilizes a hybrid particle/grid representation of material to retain the accuracy of Lagrangian
techniques without sacriﬁcing the robustness of Eulerian techniques. In all cases, the hybrid nature of the
approach requires the transfer of state to and from Lagrangian particles and Eulerian grid. Unfortunately,
this frequent remapping can introduce signiﬁcant error and instability. The most apparent error is
excessive dissipation incurred from double interpolation. The FLIP approach of Brackbill et al.
[2, 3]
was developed to reduce the dissipation by transferring changes in grid quantities to particles, rather
than directly interpolating as in PIC. This also greatly improved the angular momentum conservation
properties of the particle/grid transfers [5, 6]. However, as pointed out in [7] exact conservation with
FLIP is only possible with the use of the “full” mass matrix. FLIP cannot guarantee exact conservation
when used with the more eﬃcient “lumped” mass matrix. Unfortunately, since the full mass matrix
can be singular for certain particle conﬁgurations, it is necessary in practice to interpolate between
a mass-lumped and full mass matrix to avoid issues caused by a poorly conditioned mass matrix [7].
However, even with mass lumping, FLIP greatly reduces the angular momentum losses from transfers in
the original PIC.

While all PIC approaches suﬀer to some degree from ﬁnite grid [8, 9] (or ringing [10, 11]) instabilities,
FLIP appears to exacerbate null modes in the transfer operator from particle to grid. This is particularly
true with MPM [12, 13] PIC techniques for simulating history dependent materials. The problems arise
from the mismatch in particle and grid degrees of freedom. Typically there are many more particles
than grid nodes and thus information is lost in the particle to grid transfer. While the original PIC
transfers can be seen as a ﬁlter of particle degrees of freedom by modes resolvable on the grid, FLIP
does not have this property. FLIP transfers can be shown to cause unpredictable behavior since certain
particle velocity modes persist, invisible to the dynamics on the grid only to reappear after particle
movement. Notably, the particle velocities are not used to move the particle positions. Particle positions

1jteran@math.ucla.edu

Preprint submitted to Journal of Computational Physics

March 22, 2016

Figure 1: Ringing test. Particle velocities are drawn to illustrate the noisy modes persistent with FLIP transfers. PIC and
APIC transfers do not suﬀer from this due to the ﬁltering property. However, APIC is not excessively damped like PIC.

are directly interpolated from the grid, which is equivalent to using an interpolated, PIC velocity for
position updates. This is idea has also been used for example in [14]. However, while this reduces the
eﬀect of the velocity modes greatly, it does not completely remove the problem. We illustrate this in
Figure 1. Despite these issues, FLIP transfers are still most commonly used, particularly for MPM.

The typical PIC transfer of particle velocities vp to grid velocities vi is done by ﬁrst transferring

mass and momentum from particle to grid and then dividing out mass to get velocity as

mi =

mpN (xp − xi),

(mv)i =

p

p

mpvpN (xp − xi), vi =

1
mi

(mv)i

(1)

where xp and xi are particle and grid node locations and N (xp − xi) represent interpolating functions
deﬁned on the grid. After a physical update of the momentum is done on the grid, new grid velocities
˜vi are then directly interpolated to particles as

(cid:88)

(cid:88)

(cid:88)

(cid:88)

˜vp =

˜viN (xp − xi).

(2)

i

With this simple convention, linear and angular momentum are conserved in the transfer from particle
to grid as long as the interpolating functions satisfy a partition of unity property. In the transfer from
grid to particle, linear momentum is conserved, but angular momentum is not. Notably, these transfers
are linear operations, and since there are typically many more particle than grid degrees of freedom,
there are particle velocity null modes that are lost when transferring to grid. Since the PIC transfer from
grid to particle is just interpolation, this process can be seen as ﬁltering out particle velocity modes that
are not seen on the grid. The loss of the kinetic energy in these modes is what leads to the excessive
dissipation of PIC.

The energy loss in PIC style transfers is unacceptable for many application areas, and FLIP style
transfers can be used instead. FLIP uses the same transfer from particles to grid as PIC, however
with FLIP, velocities are incremented by interpolated diﬀerences in grid velocities (rather than directly
interpolated as in PIC) when transferring from grid to particles

˜vp = vp +

(˜vi − vi)N (xp − xi).

(3)

i

Since velocities are incremented, rather than overwritten with information from the grid, energy in
particle null modes is not lost and thus the excessive dissipation is avoided. However, these modes are
still invisible to the grid, since the transfer from particle to grid is the same in PIC and FLIP. Thus,
although these modes are not lost, they have no direct eﬀect on the governing physics which can lead to
unpredictable behavior like those discussed in [8, 9, 10, 11, 15, 16].

2

APICPICFLIPWe present a new technique designed to retain the ﬁltering property of the original PIC transfers to
guarantee stable behavior. We show that by representing particle velocities as locally aﬃne, rather than
locally constant, particle/grid transfers can be deﬁned that: (1) ﬁlter out null modes invisible to the
grid, (2) have dissipation comparable to that of FLIP and (3) conserve angular and linear momentum
(both from particle to grid and grid to particle). Furthermore, this is all done with simple mass lumping
foregoing the need for poorly conditioned full mass matrices.

There are a few existing approaches that use similar ideas to what we propose. Our work builds on that
of Jiang et al [17]. The transfers used there are discretely angular momentum conserving only for explicit
symplectic Euler integration. For any other integration scheme, angular momentum may be gradually
lost. Wallstedt and Guilkey also augment particles with derivatives of the ﬁeld variables from grid to
reduce dissipation in [18]. However they still use FLIP style incremental updates and thus still suﬀer
from null mode persistence. Furthermore, their transfer from grid to particle is not angular momentum
conserving. Also, our approach is similar to some aspects of the Constrained Interpolation Proﬁle (CIP)
methods which also store derivative information to reduce diﬀusion and improve conservation, but for
semi-Lagrangian interpolation [19].

2. Momentum transfers

The primary diﬀerence between our method and a traditional PIC scheme is that particles represent
piecewise aﬃne, rather than constant samples of the velocity ﬁeld. Thus, in addition to a sample of the
local velocity vp, we conceptually represent the velocity as v(x) = vp + Cp(x − xp) local to the particle
xp. We show that this will allow us to design a family of transfers that better preserve momentum and
energy without creating persistent null modes on particles.

2.1. Rigid-Particle-In-Cell (RPIC)

The intuition for our transfers is largely derived from a simpler case: piecewise rigid body velocity.
This can be thought of as deﬁning a velocity ﬁeld local to xp as v(x) = vp + Cp(x − xp) with skew
symmetric Cp. That is, Cp = ω∗
p is
the skew symmetric matrix equivalent to Cpx = ωp × x for arbitrary vector x. While this idealization
can also be used with PIC style ﬁltering and both linear and angular momentum conservation across
all transfers, it ultimately suﬀers from excessive dissipation similar to PIC [17]. Nonetheless, it provides
most of the insights needed for making transfers with general aﬃne conservative so we present them
here.

p where ωp is the angular velocity of the rigid body and Cp = ω∗

2.1.1. Particle to grid
With a piecewise rigid assumption, we idealize particle xp as a rigid body consisting of point masses
that the particle distributes to the grid with standard PIC transfer: mip = mpN (xp − xi). That is, rigid
body p consists of point masses mip located at xi. Note that this rigid body then has inertia tensor Kp =
p mip. With this
idealization, the linear momentum of the points in the rigid body are then (mv)ip = mip(vp+Cp(xi−xp))
where again Cp is assumed to be skew symmetric to represent rigid body velocity. We can thus deﬁne
p(mv)ip.
This transfer conserves linear and angular momenta in the following sense. Deﬁne the total linear
p mpvp and the total angular momentum (about the origin) as
p Kpωp + xp× mpvp (see Section 5.1 for justiﬁcation of these deﬁnitions). After the transfer from

(cid:80)
i mip(xi−xp)∗(xi−xp)∗T . Also note that the standard PIC grid mass is then mi =(cid:80)
the grid linear momenta to be the sum of the contributions from all rigid bodies p: (mv)i =(cid:80)
momentum of all rigid bodies as pP =(cid:80)
lP =(cid:80)
particle to grid, we have pG =(cid:80)

i(mv)i and lG =(cid:80) xi × (mv)i as the analogous quantities deﬁned over

the grid. It can be shown that pP = pG and lP = lG (see Section 5.1 for details). That is, we can say
that the linear and angular momentum of the grid state is the same as that of the particle rigid body
state after the transfer from particle to grid.

2.1.2. Grid to particle

The transfer from grid to particle is done after a momentum update on the grid. However, the update
of the grid state will give a new ˜vi since the grid node masses mi do not change over the step. We design
transfers of ˜vi to get ˜vp and skew ˜Cp that give a rigid body state whose linear and angular momentum
are consistent with that of the updated grid state. That is, we want ˜vp and skew ˜Cp = ˜ω∗
p such that
p mp ˜vp = ˜pP and new angular momentum

the new linear momentum is conserved ˜pG =(cid:80)

i mi ˜vi =(cid:80)

3

is conserved ˜lG =(cid:80) xi × mi ˜vi =(cid:80)
velocity as with standard PIC, ˜vp =(cid:80)
particle p, ˜lp =(cid:80)

p(Kp ˜ωp + xp × mp ˜vp) = ˜lP . If we deﬁne the transfer of the linear
i ˜viN (xp − xi), then linear momentum is conserved, as with PIC.
However, with this transfer alone, angular momentum is lost. Speciﬁcally, it can be shown that local to
i(xi − xp) × mip ˜vi is lost. This arises from representing the information in the grid
state mip ˜vi as only mpvp. Clearly, one particle can not represent the angular momentum seen on the
grid in mip ˜vi. The idea is to represent that angular momentum in a rigid body, rather than a simply
translating body to prevent the loss. Thus, if we deﬁne angular velocity ˜ωp to be ˜ωp = K−1
˜lp (and
˜Cp = ˜ω∗
p), then a simple argument shows that both linear and angular momentum are conserved in the
transfer from grid to particle. That is, the transfers give a rigid body state whose linear and angular
momentum are consistent with that of the updated grid state. See Section 5.1 for proofs of these claims.

p

2.2. Aﬃne-Particle-In-Cell (APIC)

For APIC, we will extend the particle-wise, local velocity ﬁeld to be an arbitrary aﬃne function as
v(x) = vp + Cp(x − xp). Here the matrix Cp is fully arbitrary, unlike the skew symmetric view in
RPIC. The problem then is to determine the transfers from particle to grid and vice versa. This can be
done in a manner directly analogous to what was presented in Section 2.1, and we provide those details
in Section 5.6. However, when developing a scheme that is perfectly conservative over the entire time
step (i.e., both transfers and grid updates are conservative), a more general notion of transfer is useful.
The discussion of transfers so far has assumed that information will be transferred from particles to
the grid and then immediately back to particles without any other changes in grid or particle positions.
While we show that these transfers can be made perfectly conservative, this is typically not enough in
practice. The point of hybrid particle/grid schemes is that part of the evolution will occur on the grid.
This introduces an element of time into the conservation problem. For example, immediately following
i vn
i .
Before the transfer back to particles, the grid state will have changed, and angular momentum will be
. We introduce a degree of ﬂexibility into the deﬁnition of the
i , xn+1
APIC transfers to account for this. When transferring to the particles, we have access to xn
,
and xn+1
, which gives us more possible options. We are also free to choose the state that we store. For
example with RPIC, rather than storing angular velocity ωp as state, we could store rotational angular
momentum ˜lp. This additional ﬂexibility is very useful, since it allows us to obtain additional properties
from the method. We require our transfers to be generally of the form described above, subject to the
additional ﬂexibility that has been noted.

the transfer from particle to grid, the angular momentum should be computed as lG =(cid:80)
computed as lG = (cid:80)

i × mn

i × mn

i vn+1

i

i xn+1

i

i xn

p , xn

p

Now that we have broadened our search space of possible transfers, we need to narrow down the

possibilities. We narrow the ﬁeld of choices down to a single scheme by enforcing three properties:

1. A globally aﬃne velocity ﬁeld should be preserved across transfers from particles to the grid and

back when moving particles and moving grids are ignored (for example when ∆t = 0).

2. The transfers should conserve linear and angular momentum, even when the complications of grid-

based evolution, moving grids, and moving particles are taken into account.

3. A simulation with a single particle is stable but non-dissipative when moving grids and moving

particles are taken to account but additional grid-based inﬂuences (forces, etc.) are ignored.

Property 1 is what it means to be an APIC scheme; it is a PIC-style transfer that preserves aﬃne velocity
ﬁelds. Note that this property should only be enforced under very strict circumstances (∆t = 0), since
aﬃne velocity ﬁelds should be able to change due to advection. Property 2 ensures that the entire scheme
will conserve linear and angular momentum provided that the grid-based scheme also conserves these
quantities.

Property 3 is a non-obvious but crucial requirement. The other properties do not uniquely determine
a transfer; they only narrow it down to a one-parameter family of transfers. These transfers tend to
behave similarly except when one particle moves far enough from other particles that it is able to evolve
in isolation. For one particular member of this family, a lone particle will evolve by not changing. For
the rest of the members of this family, part of the particle’s state tends to explode or decay exponentially
when the particle evolves in isolation. Exponential decay is not desirable, and exponential growth is
intolerable. This leads us to choose the stability criterion to narrow the possibilities down to one set
of transfers. We present these transfers in the context of the MPM method in which we use them in
Sections 3.2 and 3.4. Also, we present a derivation of the transfers from the properties 1-3 in Section 5.8.

4

3. Method

We demonstrate the behavior of our transfers on MPM simulations of hyperelasticity. Here we outline

the governing equations and establish some notation used throughout the exposition.

3.1. Equations

Let x = φ(X, t) be the mapping from material coordinates X to world coordinates x. Let V and
v be the Lagrangian and Eulerian velocities. F is the deformation gradient, and J is its determinant.
That is,

V(X, t) =

∂x
∂t

v(x, t) = V(φ

(X, t)
−1(x, t), t)

F(X, t) =

∂x
∂X

(X, t)

J = det(F)

With these deﬁnitions, the evolution equations are

ρ

Dv
Dt

= ∇ · σ,

(4)

(5)

(6)

(7)

(8)

where the Cauchy stress σ is related to the ﬁrst Piola-Kirchhoﬀ stress P and hyperelastic energy density
Ψ through

σ =

P =

PFT

1
J
∂Ψ
∂F

(9)

(10)

The state of stress in hyperelastic materials is simply related to F as Ψ(F) and P(F) where the total
internal potential energy Φ is

Since we will not have access to a reference conﬁguration, we must evolve our deformation gradient
according to

Ω0

Φ(t) =

Ψ(F(X, t)) dX.

(11)

∂F
∂t

(X, t) =

∂v
∂x

(φ(X, t), t)F(X, t).

We seek to conserve total momentum p(t) and total angular momentum l(t), which are given by

p(t) =

l(t) =

T (t) =

For completeness, kinetic energy is

and total energy is E = T + Φ.

ρ(x, t)v(x, t) dx
x × ρ(x, t)v(x, t) dx

ρ(x, t)(cid:107)v(x, t)(cid:107)2 dx,

(12)

(13)

(14)

(15)

(cid:90)

(cid:90)
(cid:90)
(cid:90)

Ω

Ω

Ω

5

3.2. Transfer to grid
Each particle xn

p stores mass mp, velocity vn

p . As we are using MPM,
we also store a deformation gradient Fn
p on particles. Note that particle masses mp do not have a time
superscript because they are constant (and thus never updated from the grid) to account for conservation
of mass. We ﬁrst use our weights to interpolate mass and momentum to the grid.

p , and the additional matrix Bn

(cid:88)
(cid:88)
(cid:88)

p

i

mn

i =

Dn

p =

mn

i vn

i =

mpwn
ip

wn

ip(xn

i − xn

p )(xn

wn

ipmp(vn

p + Bn

i − xn
p )T
−1(xn

p (Dn
p )

i − xn
p ))

(16)

(17)

(18)

p

i , since it will change each time step. The additional matrix Dn

The velocity vn
i
grid mass mn
similar to an inertia tensor (but for an aﬃne rather than rigid motion). Similarly, Bn
momentum information and the local aﬃne velocity ﬁeld is conceptually vn
p (Dn
matrix Cn

is obtained by division. Note that unlike with mp, we specify a time superscript on
p used in the transfer is
p contains angular
p )−1(xn
p ) with

i − xn
p )−1. We will elaborate on these properties later when we prove conservation.

p = Bn

p + Bn

p (Dn

3.3. Grid evolution

At this point, we have transferred state from particle to grid, and we are ready to apply forces and
, and deformation
is purely conceptual. Our implementation uses

perform our grid-based evolution. We must update grid velocity ˜vn+1
gradient Fn+1
ﬁxed Cartesian grids.

. The update of grid positions to ˜xn+1

, position ˜xn+1

p

i

i

i

An important aspect of allowing for exact conservation of linear and angular momentum during
particle/grid transfers is that conservation of the entire method can be achieved by combining with one
of the many conservative integrators used for updating the grid state [20, 21, 22, 23, 24, 25]. We introduce
a parameter λ, which allows us to consider an entire family of methods that conserve linear and angular
momentum. This family contains two notable members: symplectic Euler (λ = 0) and midpoint rule
(λ = 1
2 ). The schemes λ = 0 and λ = 1 are both explicit; the rest are implicit. We use midpoint rule for
all of our examples. Note that schemes such as forward Euler, backward Euler, and trapezoid rule do
not conserve angular momentum and thus are not suitable for our purposes. Our family of grid-based
updates is

(cid:33)

i − xn

(˜xn+1

i )(∇wn

ip)T

(cid:32)

I +

(cid:88)
Fn+1
p =
p = (1 − λ)Fn
Fn+λ
∆t
˜vn+1
i
mn
i

= vn

i +

i

Fn
p

(19)

(20)

(21)

˜xn+1
i + ∆t(λvn
i = xn
The velocity update rule uses forces f n+λ
, which we deﬁne from a potential energy function Φn+λ, which
we compute from an energy density Ψp(Fp). Our rules for computing potential energy Φn+λ, force f n+λ
,
and product by force derivatives are

(22)

)

i

i

i

i + (1 − λ)˜vn+1

p + λFn+1

p

f n+λ
i

p

p

VpΨn+λ

(cid:1)
(cid:0)Fn+λ
(cid:88)
(cid:1)
(cid:0)Fn+λ
(cid:88)
(cid:32)(cid:88)

VpPn+λ

p

p

p

:

∂Pp
∂Fp

(cid:88)

p

6

p = Ψp

Ψn+λ
Φn+λ =

Pn+λ

p
p = Pp
f n+λ
i

=

p )T∇wn

ip

(Fn

∆vi(∇wn

ip)T Fn
p

i

VpAp(Fn

p )T∇wn

ip

(cid:88)

(cid:18) ∂fi

(cid:19)

∂xj

j

Ap =

∆vj =

(cid:33)

(23)

(24)

(25)

(26)

(27)

(28)

Here, Pp is the ﬁrst Piola-Kirchhoﬀ stress tensor. Deﬁning forces through an energy ensures angular
momentum conservation; the particular constitutive model does not matter.

3.4. Transfer to particles

With grid evolution completed, we have updated grid locations ˜xn+1

and velocities ˜vn+1

i

. What

i

remains is to transfer this information back to particles. We do this using the transfers

vn+1

p =

Bn+1

p =

xn+1

p =

(cid:88)
(cid:88)
(cid:88)
(cid:32)

i
1
2

i

wn

ip ˜vn+1

i

(cid:0)˜vn+1

i

i
wn

ip ˜xn+1

i

wn
ip

(cid:88)

i − xn

(xn

p + ˜xn+1

p

i − xn+1
(cid:33)

)T + (xn

i − xn

p − ˜xn+1

i + xn+1

p

)T(cid:1)

)(˜vn+1

i

(29)

(30)

(31)

(32)

Fn+1

p =

I +

i − xn

(˜xn+1

i )(∇wn

ip)T

Fn
p

This completes the speciﬁcation of our angular-momentum-conserving family of APIC schemes.

i

3.5. Interpolation weights

As with PIC, we use weights to transfer information between the two representations. While the
choice of weights is ﬂexible, we require them to satisfy some important properties. Let N (x) be an

interpolation kernel, which must be chosen to satisfy(cid:88)

for any x. The kernel N (x) is used to deﬁne interpolation weights and weight gradients as wn
ip and ∇wn
N (xn
ip.

i ). The properties above lead to properties for wn

ip = ∇N (xn

i ) and ∇wn

p − xn

p − xn

ip =

(cid:88)

i

i

i ) = 1

i ) = x

p − xn
N (xn
i N (x − xn
xn
(cid:88)
(cid:88)
i
wipxn
i − xn
i (∇wn
xn

i
wip(xn

wip = 1

i = xn
p

p ) = 0

ip)T = I

(cid:88)
(cid:88)

i

(33)

(34)

(35)

(36)

(37)

(38)

With these weights deﬁned, we can start describing the method.

i

4. Implementation details

4.1. Implicit midpoint as minimization problem

The grid update is in general implicit, including the midpoint rule (λ = 1

2 ). Since this is the
member that we implemented and recommend using, we restrict our attention here to this case. We also
demonstrate symplectic Euler and backward Euler as grid update schemes for comparison in some of
our numerical experiments. Symplectic Euler is explicit and does not require the optimization treatment
that follows. Backward Euler is not a member of the family described in this paper; we compare against
it for reference.

We solve the resulting nonlinear systems of equations following an optimization-stabilized Newton-

Raphson solver framework [26, 27]. The implicit midpoint scheme for MPM grid nodes is

(cid:19)

(cid:18) vn
(cid:18) xn

i + ˜vn+1

i

,

(cid:19)

.

2
i + ˜xn+1

i

2

˜xn+1
i = xn

i + ∆t

˜vn+1
i

= vn

i +

fi

∆t
mn
i
7

∆vi

.

(39)

(cid:19)

∆vi

.

(cid:1).

Eliminating ˜xn+1

i

gives

i − vn
˜vn+1

i

∆t

mn
i

= fi

= fi

 xn
(cid:18)

Changing to the variable ∆vi = ˜vn+1

i − vn
i ,

mn

i ∆vi = ∆tfi

(cid:18)

xn

i +

(cid:16) vn

i +˜vn+1

i

2

(cid:17)



i + xn

i + ∆t
2

xn

i +

∆t
4

(vn

i + ˜vn+1

i

(cid:19)

)

.

(cid:19)

The corresponding minimization objective function is

∆t
2

vn

i +

∆t
4

(cid:18)

E(∆vi) =

(cid:107)∆vi(cid:107)2 + Φ

mn
i
8

xn

i +

∆t
2

vn

i +

∆t
4

(cid:88)

i

(cid:88)

This is similar to the corresponding objective for backward Euler, which is

(cid:107)∆vi(cid:107)2 + Φ(cid:0)xn

mn
i
2

Ebe(∆vi) =

i + ∆tvn

i + ∆t2∆vi

The minimum of E occurs when

i

gi =

=

=

∂E
∂∆vi

∂

∂∆vi

(cid:88)

j

mj
8

mn
i
4

∆vi − ∆t
4

fi

(cid:18)

(cid:18)

xn

j +

∆t
2

(cid:19)

∆t
4

∆vj

vn

j +

(cid:19)

(cid:107)∆vj(cid:107)2 + Φ

xn

i +

∆t
2

vn

i +

∆t
4

∆vi

,

Note that g(∆vi) = 0 is just (39), so minimizing E is equivalent to solving (39). Multiplying the
derivative of g by some vector δui will be necessary.

(cid:88)

j

∂gi
∂∆vj

δuj =

(cid:88)

j
mn
i
4

=

(cid:18) mn
(cid:88)

∂

i
∂∆vj
4
δui − ∆t2
16

j

(cid:18)

(cid:18)

∆vi − ∆t
4

fi

xn

i +

∆t
2

vn

i +

∆t
4

∆vi

δuj

∂fi
∂xj

xn

i +

∆t
2

vn

i +

∆t
4

∆vi

δuj

(cid:19)(cid:19)

(cid:19)

This in turn requires a matrix-vector multiply by the force derivative, which is done using (27) and (28).

4.2. Momentum conservation on incomplete convergence

The conservation properties of our method (see Section 5.2) depend on solving (39) to convergence. If
this is not done, conservation will be only approximate. We note, however, that this is not a fundamental
problem. One way to track down the source of the problem is to label every vector a velocity-like or
force-like. Assume initial velocity is zero and all forces are momentum-conserving. Then, we can note
some rules about how these types of vector should behave:

1. A force-like vector will sum to zero.
2. A velocity-like vector will sum to zero when scaled by mass.
3. Scaling a velocity-like vector by mass produces a force-like vector.
4. Scaling a force-like vector by inverse mass produces a velocity-like vector.
5. Scaling a vector by a constant preserves its type.
6. Adding vectors is only permitted if they have the same type; the type is preserved.

7. In the matrix-vector multiply δfi =(cid:80)

j

∂fi
∂xj

δuj, δuj must be velocity-like, and δfi will be force-like.

8

Algorithm 1 Conjugate Gradient
1: procedure Conjugate–Gradient(A, x, b)
2:
3:

r ← b − Ax
p ← r
γ ← (cid:104)r, r(cid:105)
while not converged do
ß ← Ap
α ← γ
(cid:104)p, ß(cid:105)
x ← x + αp
r ← r − αß
κ ← (cid:104)r, r(cid:105)
β ← κ
p ← r + βp
γ ← κ
end while

γ

4:
5:
6:

7:

8:
9:
10:
11:

12:
13:
14:
15: end procedure

(cid:46) r and ß have the same type

(cid:46) r and p have the same type

8. Dot product is only allowed if one vector is force-like and the other is velocity-like. (This is done,

for example, when computing kinetic energy.)

As long as these rules are followed, the velocity will be velocity-like, which implies conservation of linear
momentum (the last rule is not strictly required, but we can enforce it anyway). Propagating these labels
through the algorithm (Newton’s method, line searches, conjugate gradient, etc.) is straightforward and
breaks down only inside the conjugate gradient solver. The source of the problem is that p, r, and ß
must be of the same type (see Algorithm 1), so that ß ← Ap means the operator A must take and
produce the same type of vector. The system we are solving takes the general form

A1δv = δf

A1 = M + ζ

∂f
∂x

,

where M is a diagonal mass matrix, ζ is a scalar, δv is a velocity-like vector, δf is a force-like vector.
The operator A1 takes velocity-like vectors and produces force-like vectors, which is a problem. We can
avoid that problem by rewriting

A2δv = M−1δf

A1 = I + M−1ζ

∂f
∂x

.

Now, A2 takes velocity-like vectors and returns velocity-like vectors. Unfortunately, this A2 is not
symmetric.

The conjugate gradient operates on vectors in only a few ways: matrix-vector multiply, vector op-
erations, and inner product. Note that the inner product used does not need to be the standard in-
ner product: A is only required to be symmetric with respect to the inner product chosen. That is,
(cid:104)Au, v(cid:105) = (cid:104)u, Av(cid:105) for any u and v. Note that A2 is symmetric with respect to the mass inner product
(cid:104)u, v(cid:105) = uT Mv. Using this modiﬁed system and a mass inner product for conjugate gradient is a per-
fectly acceptable means of solving the linear system. Furthermore, all vectors in the conjugate gradient
algorithm are now velocity-like, which allows us to label all of our vectors. This in turn guarantees
conservation of momentum, even if our solver is not fully converged.

4.3. CFL condition

We choose our time step size ∆t so that no particle will travel more than the grid spacing ∆x in one
time step. We approximate this by assuming that these particles travel with the initial grid velocity vn
i .
While this does not take into account the potentially dramatic aﬀect of forces, we note that our method

9

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)

wn

ipmpBn
ipmp(cid:107)Bn
wn
ipmp(cid:107)Bn
wn

p (Dn
p )

−1(xn

−1(xn

p (Dn
p )
p(cid:107)F(cid:107)(Dn
p )

i − xn
p )
p )(cid:107)
i − xn
i − xn
p )(cid:107)

−1(xn

−1(xn

i − xn
p )(cid:107)

Interpolation stencil support is bounded by (cid:107)xn
(cid:107)(Dn

p )−1(xn

i − xn

p(cid:107) ≤ κ∆x.

If we also assume Dp = kI, then

is implicit and can tolerate such errors.

mn

i vn

i =

wn

ipmp(vn

p + Bn

p (Dn
p )

−1(xn

i − xn
p ))

i (cid:107)vn
mn

i (cid:107) =

wn

ipmp(vn

p + Bn

p (Dn
p )

−1(xn

i − xn
p ))

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)

p

(cid:88)
(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)(cid:88)
(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)(cid:88)
≤(cid:88)
≤(cid:88)

≤

p

p

p

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13) +

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)(cid:88)
(cid:88)
(cid:88)

p

p

wn

ipmpvn
p
ipmp(cid:107)vn
wn
ipmp(cid:107)vn
wn

p(cid:107) +
p(cid:107) +

p

p

p )(cid:107) ≤ κ
k ∆x.
i (cid:107)vn
mn

p

wn

ipmp

i (cid:107) ≤(cid:88)
ipmp(cid:107)vn
p(cid:107) +
(cid:16)(cid:107)vn
≤(cid:88)
wn
(cid:33)
(cid:32)(cid:88)
(cid:16)(cid:107)vn
(cid:16)(cid:107)vn

= mn
i (cid:107) ≤ max

p(cid:107) +
κ
k

p(cid:107) +

i max

ipmp

wn

≤

p

p

p

p

p

i − xn
(cid:88)
p(cid:107) +

p
κ
k

p(cid:107)F(cid:107)(Dn
ipmp(cid:107)Bn
(cid:17)
wn
p )
(cid:17)

∆x(cid:107)Bn

∆x(cid:107)Bn

p(cid:107)F

(cid:16)(cid:107)vn

p(cid:107)F
(cid:17)

max

p(cid:107) +
κ
k
(cid:17)
p(cid:107)F

∆x(cid:107)Bn
p(cid:107)F

κ
k

∆x(cid:107)Bn

(cid:107)vn

√
k ∆x = 6
∆x , where d is the dimension. A reasonable

d

In the case of both quadratic and cubic interpolation, κ
CFL condition is then

∆t ≤

maxp

We use ν = 1 for our examples.

5. Notes and analysis

(cid:0)(cid:107)vn

ν∆x
p(cid:107) + κ

k ∆x(cid:107)Bn

p(cid:107)F

(cid:1) .

Here we discuss a number of aspects and useful properties of the schemes we have proposed.

5.1. RPIC transfer properties

The RPIC transfers outlined in Sections 2.1.1 from particle momenta to grid momenta are

(mv)i =

mpN (xp − xi)(vp + Cp(xi − xp)).

(40)

(cid:88)

p

(cid:88)

(cid:32)(cid:88)

The transfers from updated grid velocities ˜vi to new particles velocities ˜vp and angular velocities ˜ωp as
outlined in Section 2.1.2 are

˜vp =

N (xp − xi) ˜vi, ˜ωp = K−1

p

(xi − xp) × mpN (xp − xi)˜vi

.

(41)

i

i

These transfers conserves total linear and angular momenta. To deﬁne the total linear and angular
momenta of the particles, we think of them as a collection of rigid bodies, each made up of individual
point masses mip = mpN (xp−xi) located at the grid nodes xi. Then the total momenta of the collection

10

(cid:33)

of rigid bodies is the sum of the contributions from each respective point mass. That is, the total linear
momentum pP of the particles is

pP =

mip (vp + Cp(xi − xp))

(cid:88)

(cid:88)

p

i

(cid:88)
(cid:88)
(cid:88)

p

i

and the total angular momentum (computed about the origin) is

These quantities are deﬁned in a more obvious manner on the grid as

lP =

xi × mip (vp + Cp(xi − xp)) .

pG =

mivi and lG =

xi × mivi.

(cid:88)

In the following, we will show that after the transfer from particle to grid, pP = pG and lP = lG and
after the transfer from grid to particle ˜pP = ˜pG and ˜lP = ˜lG

i

i

5.1.1. Particle to grid: conservation of linear momentum

i

p

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

i

The total linear momenta are equal after the transfer, which can be seen simply from

=

pP =

pP =

mivi = pG.

mpN (xp − xi) (vp + Cp(xi − xp))

However, it is also useful to note that

mpN (xp − xi) (vp + Cp(xi − xp)) =

(cid:88)
(cid:88)
That is, the Cp contribute no net linear momentum. This holds since(cid:80)
(cid:80)
i mpN (xp−xi)vp =(cid:80)
where we assume a partition of unity property of the grid interpolating functions(cid:80)
(cid:80)
(cid:80)
p mpNi(xp)Cp(xi − xp) = 0. This can be seen from
(cid:88)
(cid:88)

mpN (xp − xi) (vp + Cp(xi − xp)) =

(cid:88)
(cid:88)

mpN (xp − xi)Cpxp =

again using partition of unity and lastly

(cid:88)
(cid:88)

(cid:88)
(cid:88)

p

(cid:88)
(cid:88)

p

N (xp − xi) =

mpCpxp

mpCpxp

mpvp.

p

i

i

p

p

mpN (xp − xi)Cpxi =

mpCp

N (xp − xi)xi =

mpCpxp

i

p

i

i

p

i

p

p mpvp
i N (x − xi) = 1 and

where we assume that the grid interpolation function exactly interpolate linear functions, which leads to

(42)

(43)

(44)

(45)

(46)

(47)

(48)

i

p

(cid:80)
i N (x − xi)xi = x.
(cid:88)
(cid:88)

lP =

p

=

(cid:88)
xi ×(cid:88)

i

5.1.2. Particle to grid: conservation of angular momentum

The transfer also conserves total angular momentum since

xi × mpN (xp − xi) (vp + Cp(xi − xp))

mpN (xp − xi) (vp + Cp(xi − xp)) =

i

p

Also, this formula can be expressed as

lP =

(cid:88)

p

xp × mpvp +

11

(cid:88)

l

Kpωp.

(cid:88)

i

xi × mivi = lG.

(49)

(50)

(cid:80)
i xi × mpN (xp − xi)vp can be seen from partition of unity. The

(cid:88)

i

second term is clear when noting

p xp × mpvp =(cid:80)

The ﬁrst term(cid:80)
(cid:88)
i N (xp − xi)xi = xp and(cid:80)
(cid:88)

since(cid:80)

i

p

xp × mpN (xp − xi)Cp(xi − xp) = xp × mpCp(

N (xp − xi)xi − xp) = 0

i N (xp − xi) = 1, combined with

(cid:88)

xi × mpN (xp − xi)Cp(xi − xp) =

mpN (xi − xp)x∗

i (xi − xp)
∗T

ωp

(51)

(52)

yields(cid:88)

i

i

xi × mpN (xp − xi)Cp(xi − xp) =

(cid:88)

i

i

mpN (xi − xp)(xi − xp)

∗

(xi − xp)
∗T

ωp = Kpωp.

(53)

Recall we use x∗ to denote the matrix that expresses x × y = x∗y and Cp = ω∗. This result says that
the total angular momentum of the particles (about the origin) is equal to the sum of the contributions
from the conceptual rigid body centers of mass and the contribution from the angular momentum at
each particle.

5.1.3. Grid to particle: conservation of linear momentum

The transfers in Equation 41 conserve linear momentum since

(cid:88)

(cid:88)

(cid:88)
(cid:88)

p

(cid:88)

˜pP =

=

mp ˜vp =

mp

p

i

mpN (xp − xi)˜vi =

N (xp − xi)˜vi

(cid:88)

mi ˜vi = ˜pG

(54)

i

p

i

where we use the expression for ˜pP derived in Equation 46.

5.1.4. Grid to particle: conservation of angular momentum

The transfers in Equation 41 also conserve angular momentum. We can show this using Equations 50

and Equation 41 to express the new total particle angular momentum as

Kp ˜ωp =

xp × mp

N (xp − xi)˜vi +

(xi − xp) × mpN (xp − xi)˜vi

(cid:88)
(cid:88)

p

˜lP =

=

xp × mp ˜vp +

xi ×(cid:88)

(cid:88)

p

(cid:88)

(cid:88)
(cid:88)

p

mpN (xp − xi)˜vi =

i

xi × mi ˜vi = ˜lG

p

i

(cid:88)

(cid:88)

i

p

i

5.2. APIC conservation of linear momentum

(55)

The APIC scheme is naturally divided into three steps; we show that each step independently con-
serves linear momentum. The ﬁrst step is the transfer of information from particle to grid. We see that
the initial particle momentum pP,n is equal to the grid momentum after the transfer pG,n.

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

i

i

i vn
i

mn

(cid:88)
(cid:88)

p

p
mpvn
p

mpvn
p

pG,n =

=

=

=

=

p

= pP,n

12

wn

ipmp(vn

p + Bn

p (Dn
p )

−1(xn

(cid:88)

(cid:88)
(cid:88)

i

i − xn
p ))
−1(cid:88)

p (Dn
p )

(cid:88)

wn

ipmpvn

p +

wn

ipmpBn

wn

ip +

p
mpBn

p (Dn
p )

i

p

i

−1(xn

i − xn
p )
i − xn
p )

wn

ip(xn

(cid:88)
(cid:88)
(cid:88)

i

i

˜pG,n+1 =

=

=

(cid:19)

mn

i ˜vn+1

i

(cid:18)

mn

i vn

i + ∆t

mn
i

vn

i +

f n+λ
i

∆t
mn
i

(cid:88)
(cid:88)

f n+λ
i

i
VpPn+λ

p

p
VpPn+λ

p

(Fn

(cid:88)
(cid:88)

i

p

i

ip

(Fn

p )T(cid:88)

p )T∇wn
∇wn

ip

i

= pG + ∆t

= pG + ∆t

= pG,n

p

(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

i

pP,n+1 =

=

=

=

mpvn+1

p

(cid:88)
(cid:88)

mp

i
˜vn+1
i

p
i ˜vn+1

i

mn

wn

ip ˜vn+1

i

mpwn
ip

Once mass and momentum are on the grid, grid positions and velocities are updated. We note that
initial grid momentum matches the ﬁnal grid momentum ˜pG,n+1.

The ﬁnal step is transferring information back to particles. This step is also conservative since

i

= ˜pG,n+1

Finally, the entire scheme conserves momentum since pP,n+1 = pP,n.

5.3. APIC conservation of angular momentum

We use the permutation tensor in this section. To make these portions easier to read, we take the
convention that A :  denotes Aαβαβγ. The manipulation u× v = (vuT )T :  is used to transition from
a cross product into the permutation tensor.

5.3.1. Transfer to grid

Our approach to demonstrating angular momentum conservation follows the same three steps. In
this case, we show that lP,n = lG,n = ˜lG,n+1 = lP,n+1, though the individual steps are more involved.
We begin with the transfer from particles to the grid.

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

p

lG,n =

=

=

=

ip(vn

p + Bn

p (Dn
p )

−1(xn

i − xn
p ))

i vn
i

i × mn
(cid:88)
xn
(cid:88)
i
p × mpvn
xn

i × mpwn
xn
i × mpwn
(cid:88)
xn

p +

i

(cid:88)

ipvn

p +

lB
p

p

mp(Bn

p )T : 

p

= lP,n

p

13

where use has been made from
i × mpwn
xn

lB
p =

ipBn

p (Dn
p )

−1(xn

i − xn
p )

(cid:0)mpwn

i

i

=

(cid:88)
(cid:88)
(cid:32)
(cid:32)
=(cid:0)mpBn

=

=

= mp(Bn

p (Dn
p )
p )T : 

i )T(cid:1)T
(cid:33)T

: 

mpBn

p (Dn
p )

i − xn

p )(xn

i )T

: 

mpBn

p (Dn
p )

ip(xn

i − xn

p )(xn

i − xn

p )T +

ipBn

p (Dn
p )

−1(xn

i − xn

p )(xn

i

wn

ip(xn

−1(cid:88)
(cid:32)(cid:88)
p + 0)(cid:1)T

wn

−1(Dn

−1

i

: 

(cid:33)(cid:33)T

: 

wn

ip(xn

i − xn

p )(xn

p )T

(cid:88)

i

Note that this expression for lP,n can be taken to be the deﬁnition of total angular momentum on
particles, with lB

p being the angular momentum contribution of particle p due to Bp.

5.3.2. Grid update

The next step is the grid update. Let Gp =(cid:80)
(cid:88)

(cid:32)

i ˜xn+1

i

(∇wn

ip)T . Then,

i − xn

i )(∇wn

ip)T

Fn
p

(cid:33)

Fn+1

p =

i

I +

(˜xn+1
= (I + Gp − I)Fn
= GpFn
p

p

For the grid update portion, we will use the following manipulations to replace cross products with
permutation tensors.

(cid:88)

i

(cid:88)

i

i × Ap∇wn
xn

ip =

=

(cid:88)
(cid:32)

i

(cid:0)Ap∇wn
(cid:88)

Ap

i

i )T(cid:1)T
(cid:33)T

: 

ip(xn

∇wn

ip(xn

i )T

: 

i × Ap∇wn
˜xn+1

ip =

ip(˜xn+1

i

p : 

= (ApI)T : 
= AT

(cid:88)
(cid:0)Ap∇wn
(cid:32)
(cid:88)
(cid:1)T
=(cid:0)ApGT

Ap

=

i

i

p

: 

∇wn

)T(cid:1)T
(cid:33)T

: 

ip(˜xn+1

i

)T

: 

14

(cid:88)

With this, we note the identity
i + (1 − λ)xn

(λ˜xn+1

i ) × f n+λ

i

i

=

=

=

=

=

=

i

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

i

i

i

Vp

(λ˜xn+1

(λ˜xn+1

p SSn+λ

i + (1 − λ)xn
i + (1 − λ)xn
(cid:88)
(cid:88)
(cid:88)
(cid:88)

(cid:0)Fn+λ
(cid:0)Fn+λ
(cid:0)Fn+λ
(cid:0)Fn+λ

p SSn+λ

p SSn+λ

p SSn+λ

Vp

Vp

Vp

p

p

p

p

p

p

p

p

p

ip

(Fn

VpFn+λ

VpPn+λ

p SSn+λ

p )T∇wn

i ) ×(cid:88)
i ) ×(cid:88)
p )T ((1 − λ)I + λGp)T(cid:1)T
p )T(cid:1)T
)T(cid:1)T

((1 − λ)Fn

((1 − λ)Fn

p + λGpFn

p + λFn+1

(Fn

(Fn

p

p

p

: 

: 

: 

)T(cid:1)T

(Fn+λ

p

: 

p )T∇wn

ip

i

p

= 0

from which it follows that (cid:88)

(λ˜xn+1

i + (1 − λ)xn

i ) × mn

i − vn

i (˜vn+1

i ) = 0.

i

With this identity, it is ﬁnally possible to show that angular momentum is conserved across the grid
update.

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)

i

i

i −(cid:88)
i −(cid:88)

i

i ˜vn+1

i × mn
˜xn+1
i × mn
˜xn+1
i ˜vn+1
i − xn
i ) × mn
∆t((1 − λ)˜vn+1

i × mn
xn
i × mn
xn
i ((1 − λ)˜vn+1
i ) × mn

i + λvn

(˜xn+1

i

˜lG,n+1 − lG,n =

=

=

=

i vn
i

i vn

i −(cid:88)

i

i + λvn
i )
i ((1 − λ)˜vn+1

i + λvn
i )

(λ˜xn+1

i + (1 − λ)xn

i ) × mn

i − vn
i )

i (˜vn+1

i − xn

(xn

p + ˜xn+1

p + ˜xn+1
i − xn+1
) × ˜vn+1

p

p

i − xn+1
) × ˜vn+1

)T + (xn

i − xn
i × (xn

p − ˜xn+1
i − xn

i + xn+1
p − ˜xn+1

p

i + xn+1

p

i + ˜vn+1
i × (−˜xn+1

i + ˜vn+1

i + xn+1

p

)(cid:1)

)T(cid:1)(cid:33)T
)(cid:1)

)(˜vn+1

i

: 

i

= 0

5.3.3. Transfer to particles

Using

lB
p = mp(Bn+1

p

)T : 

i
wn
ip

i

1
2

(cid:32)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

wn

wn

i

i

i

wn
ip

i

wn
ip

(cid:0)˜vn+1
(cid:0)(xn
(cid:0)(˜xn+1

p

i − xn
i − xn+1
i − xn+1
i × ˜vn+1
i × ˜vn+1

ip(˜xn+1

ip ˜xn+1

wn

ip ˜xn+1

= mp

=

=

mp
2
mp
2

= mp

= mp

= mp

i

p

) × ˜vn+1

(cid:88)
i − mp
ipxn+1
p × mpvn+1
i − xn+1

wn

p

i

p × ˜vn+1

i

i

15

we have

lP,n+1 =

=

=

=

=

p

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

p

i

(cid:32)

p

p +

p × mpvn+1
xn+1

(cid:88)
(cid:88)
p × mpvn+1
(cid:88)
xn+1
p +
i × ˜vn+1
(cid:88)
i
i × ˜vn+1
˜xn+1
i × mn
˜xn+1

p
i ˜vn+1

ip ˜xn+1

ipmp

wn

wn

mp

p

i

i

i

mp(Bn+1

)T : 

p

(cid:88)

i

mp

i × ˜vn+1

i − xn+1

p × mpvn+1

ip ˜xn+1

p

wn

(cid:33)

i

= ˜lG,n+1

This completes the proof of angular momentum conservation.

5.4. Stability

It is possible to construct a transfer that conserves angular momentum and retains aﬃne ﬁelds but
is unstable. This instability was observed to occur when variations in the transfer are considered. The
instability conveniently manifests when a particle is isolated, so the problem is easy to avoid. We require
p or Bn
that an isolated particle experiencing no forces should translate uniformly with no change in vn
p .
We now show that our scheme has this property.

Consider that there is only one particle, which experiences no forces (f n+λ

i

rules for vn

i , ˜vn+1

i

, and ˜xn+1

i

reduce to

p (Dn
p )

−1(xn

i − xn
p )

p + Bn

i = vn
vn
˜vn+1
= vn
i
i
˜xn+1
i = xn
i + ∆tvn
i

= 0). Then, the update

(56)

(57)

(58)

(59)

(60)

(61)

(62)

(63)

(64)

(65)

(66)

(67)

(68)

With these, the ﬁnal particle velocity is

ip ˜vn+1

i

vn+1

p =

=

wn

(cid:88)
(cid:88)
(cid:88)

wn

i

i
= vn
p

ip(vn

p + Bn

p (Dn
p )

wn

ip + Bn

p (Dn
p )

−1(xn

−1(cid:88)

i − xn
p ))
i − xn
p )

ip(xn

wn

i

= vn
p

i

The ﬁnal position is

xn+1

p =

=

=

(cid:88)
(cid:88)
(cid:88)

i

i

wn

ip ˜xn+1

i

wn

ip(xn

i + ∆tvn
i )

(cid:88)

wn

ipxn

i + ∆t

wn

ipvn
i

(cid:88)

i
= xn

p + ∆t

i

wn

ip ˜vn+1

i

i

= xn
= xn

p + ∆tvn+1
p
p + ∆tvn
p

16

i

(cid:0)˜vn+1
(cid:0)vn
(cid:0)vn

wn
ip

wn
ip

wn
ip

Finally, Bn+1

p

Bn+1

p =

=

=

=

=

=

=

is now

i

i

1
2

1
2

1
2

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

i

i

i

i

wn

ipvn

wn

ipvn

wn

ipvn

wn

ip(vn

i (xn

i (xn

i − xn
i − xn
i − xn
p )T
−1(cid:88)

p + Bn

i (xn

i
p (Dn
= Bn
p )

p (Dn
p )

= Bn
= Bn
p

i − xn

p + ˜xn+1

i − xn+1

p

(xn

)T + (xn

i − xn

p − ˜xn+1

i + xn+1

i (2xn

i − 2xn

p + ∆tvn

p )T + (∆tvn

p − ∆tvn

i )(vn

i (2xn

i − 2xn

p − ∆tvn

p )T + ∆tvn

p (vn

i − ∆tvn
(cid:33)

(cid:32)(cid:88)

i )T(cid:1)

(cid:32)(cid:88)

i

wn

ipvn
i

(vn

p )T + ∆tvn
p

wn

ipvn
i

p )T − ∆t
p )T − ∆tvn

i

p (vn

p )T + ∆tvn

p (vn

p )T

p

i )T(cid:1)
(cid:33)T

i − xn

i − xn
p )T

−1(xn
p (Dn
p )
i − xn

ip(xn

wn

p ))(xn
i − xn

(cid:88)

p )(xn

p )T + vn
p

wn

ip(xn

i − xn
p )T

i

−1Dn

p

i

)T(cid:1)

)(˜vn+1

i

(69)

(70)

(71)

(72)

(73)

(74)

(75)

(76)

(77)

(78)

This guarantees stability in the case of one particle. In practice, the scheme is observed to be stable with
any number of particles when using a quadratic or cubic basis. It is not, however, stable for a multilinear
basis, as noted in Section 5.9.

5.5. Aﬃne round trip

p = CDn

One of the original motivations behind the original APIC scheme is that, in some reasonable sense,
it should preserve aﬃne velocity ﬁelds. Particles represent an aﬃne velocity ﬁeld when vn
p = v + Cxp
and Bn
p for some vector v and matrix C. We require that such a velocity ﬁeld be preserved in
the limit when an arbitrarily small time step is taken, so that we may assume ∆t = 0. The assumption
∆t = 0 immediately implies ˜vn+1
ip, and
Dn+1

p follow. The transfer to the grid simpliﬁes to

i , from which xn+1

i and ˜xn+1

ip = wn

p = Dn

p , wn+1

= vn

= xn

= xn

p

i

i

p

(cid:88)
(cid:88)
(cid:88)
(cid:88)

p

p

mn

i =

mn

i vn

i =

=

=

mpwn
ip

wn

ipmp(vn

p + Bn

p (Dn
p )

−1(xn

i − xn
p ))

wn

ipmp(v + Cxp + CDn

p (Dn
p )

−1(xn

i − xn
p ))

wn

ipmp(v + Cxn
i )

(79)

(80)

(81)

(82)

(83)

(84)

p
i (v + Cxn
= mn
i )

vn
i = v + Cxn
i

17

so that the grid velocity ﬁeld is produced by the same aﬃne velocity ﬁeld.

vn+1

p =

=

=

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)

i

i

wn

ip ˜vn+1

i

wn

ipvn
i

wn

ip(v + Cxn
i )

(cid:88)

= v

wn

ip + C

wn

ipxn
i

i

i

= v + Cxn
p
= v + Cxn+1

p

(cid:0)˜vn+1

i

wn
ip

(xn
i − xn
p )T

ipvn

i (xn

1
2

(cid:88)
(cid:88)
(cid:88)
(cid:88)

i

i

i
wn

i )(xn

wn

ip(v + Cxn
i − xn

ip(xn

wn

p )T + C

i − xn
(cid:88)
p )T

= v

i
= CDn
p
= CDn+1

p

i

Bn+1

p =

=

=

i − xn

p + ˜xn+1

i − xn+1

p

)T + (xn

i − xn

p − ˜xn+1

i + xn+1

p

)T(cid:1)

)(˜vn+1

i

wn

ip(xn

i − xn

p )(xn

i − xn

p )T + Cxn
p

(cid:88)

i

wn

ip(xn

i − xn
p )T

(85)

(86)

(87)

(88)

(89)

(90)

(91)

(92)

(93)

(94)

(95)

(96)

The new particle state corresponds to the same aﬃne velocity ﬁeld, so the ﬁeld has been preserved across
the transfers.

5.6. Unifying PIC, RPIC and APIC

xi), mi =(cid:80)

p mip, (mv)ip = mip(vp + Cp(xi − xp)) and (mv)i =(cid:80)

For each of PIC, RPIC and APIC the transfer from particle to grid can be written as mip = mpN (xp−
p(mv)ip, where the Cp is zero, skew
or a full matrix to distinguish PIC, RPIC and APIC respectively. However, when designing the transfer
back from grid to particle, the details are less obviously related. There is, in fact, a description that
uniﬁes RPIC, APIC and PIC. It starts with the alternative notation

to describe the velocity ﬁeld local to the particle. Here, the bjpi ∈ R3, bjp ∈ R3Ng with Ng equal to the
number of grid nodes and

vip =

sjpbjpi

j=1

Nr(cid:88)


 .

bjp1
bjp2
...

bjpNG

bjp =

The bjp form a reduced basis for the grid velocity ﬁeld vip local to particle p. That is, the bjp ∈ R3Ng
are individual modes deﬁned over the grid and the sjp describe the local particle state, e.g. they are
equivalent to vp and CP for APIC. The choice of the basis vectors bjp ∈ R3Ng is what distinguishes PIC
from RPIC from APIC etc. For example, PIC uses Nr = 3 and



ej
ej
...
ej

 and vp =



 s1p

s2p
s3p

bjp =

18

for j = 1, 2, 3 = Nr with ej ∈ R3 the jth standard basis vector for R3. RPIC uses Nr = 6 with the same
bjp as PIC for j = 1, 2, 3 and

for j = 4, 5, 6 = Nr where ijk is the permutation tensor (such that the kth component of a × b is

(cid:80)
i,j ijkaibj) and ripk is the kth component of rip = xi − xp. With this convention,

vp =

 .

 s4p

s5p
s6p







bjp =

...

...

s2p
s3p



 s1p

k=1 j−3k1rNgpk
k=1 j−3k2rNgpk
k=1 j−3k3rNgpk

k=1 j−3k1r1pk
k=1 j−3k2r1pk
k=1 j−3k3r1pk
k=1 j−3k1r2pk

(cid:80)3
(cid:80)3
(cid:80)3
(cid:80)3
(cid:80)3
(cid:80)3
(cid:80)3
 and ωp =
(cid:80)3
Lastly, APIC uses the same bjp as RPIC for j = 1, 2, . . . , 6 and
(cid:80)3
k=1 |j−6k1|r1pk
(cid:80)3
k=1 |j−6k2|r1pk
(cid:80)3
k=1 |j−6k3|r1pk
k=1 |j−6k1|r2pk
(cid:80)3
(cid:80)3
k=1 |j−6k1|rNgpk
(cid:80)3
k=1 |j−6k2|rNgpk
k=1 |j−6k3|rNgpk

 s10p
 and Cp =
(cid:80)Nr
j=1 sjpbjpi and (mv)i = (cid:80)

ej−9eT
j−9r1p
ej−9eT
j−9r2p
...
ej−9eT
j−9rNGp



 s1p

s2p
s3p

s4p + s7p
s5p + s8p

bjp =

bjp =

vp =

for j = 7, 8, 9 (which represent symmetric matrices with zero diagonal) and

for j = 10, 11, 12 = Nr which represent the diagonal matrices. With this convection,

 .

s7p − s4p

s11p

s8p − s5p
s9p − s6p

s6p + s9p

s12p

5.6.1. Transfer from particle to grid

With this notation, the transfer from particle to grid is mip = mpN (xp − xi), mi = (cid:80)

p mip,
p(mv)ip. That is, the grid momenta are just the sum
(mv)ip = mip
of the momenta modes local to each particle. Notably, this describes the PIC, RPIC and APIC transfers
in one description. If we deﬁne the total linear momentum of the particle state to be the sum of the
total linear momenta from each local particle state, and the total angular momentum of particle state to
be the sum of the total angular momenta from each local particle state (computed about the particle)
plus the angular momenta of the particles, then the transfer conserves linear and angular momentum by
reasoning analogous to that in Section 5.1.

5.6.2. Transfer from grid to particle

Using this notation, the transfer from grid to particle is done by determining ˜sjp from the updated
grid velocities ˜vi. We can do this in a way that conserves linear, angular momenta, as well as generalized

19

Figure 2: The matrix structure of bT

jpMbip in the multilinear case.

moments directly by solving the system



 = bT

jpMbip˜sip

m1p ˜v1
m2p ˜v2

...

mNgp ˜vNg

bT
jp

for ˜sip. Notably, this describes the PIC and RPIC transfers when the Nr = 3 and Nr = 6 respectively.
Furthermore, it generalizes the result to the aﬃne case. Remarkably, it can be shown that the matrix
bT
jpMbip is both diagonal and constant in time for quadratic and cubic B-splines, i.e. does not depend
on the conﬁguration of the particles relative to the grid. This not only means that these solves can be
done eﬃciently, but it also shows that for APIC, ˜sip are the PIC modes i = 1, 2, 3 and the RPIC modes
for i = 4, 5, 6 and that the remaining APIC modes are determined independently since the components
are decoupled in the solve. Lastly, the transfer conserves linear and angular momentum by the same
argument as for RPIC since the right hand side terms



bT
jp

m1p ˜v1
m2p ˜v2

...

mNgp ˜vNg

 = bT

jpMbip˜sip

are the linear momentum components for j = 1, 2, 3 and the angular momentum components (computed
about the particle) for j = 4, 5, 6.

5.6.3. Coeﬃcient computations

To construct the transfer, we need to compute the basis coeﬃcients ˜sip. This requires building
the matrix bT
jpMbip and inverting it. Notably, building this matrix and its inverse requires very little
computation. In the case of cubic and quadratic B-spline interpolation, the matrix is actually constant
and diagonal. For cubic B-splines, bT

jpMbip is diagonal with entries

mp × {1, 1, 1,

∆x2,

2
3

2
3

∆x2,

2
3

∆x2,

2
3

∆x2,

∆x2,

2
3

2
3

∆x2,

∆x2,

1
3

∆x2,

1
3

∆x2}

1
3

For quadratic B-splines, bT

jpMbip is diagonal with entries

mp × {1, 1, 1,

∆x2,

1
2

1
2

∆x2,

1
2

∆x2,

∆x2,

1
2

1
2

∆x2,

∆x2,

1
2

1
4

∆x2,

∆x2,

1
4

∆x2}.

1
4

For the cubic and quadratic cases, this transfer is equivalent to those derived in previous sections, albeit
without the intuition needed to prove a number of the useful properties.

20

1471014710For multilinear interpolation function, it is a symmetric matrix (but not diagonal).

bT

jpMbip = mp

0

0
0 A0 A1
0 A1 A0
0

0

0 −∆xZ − Z2

where

A0 = −diag

z2

p2 + z2
z2
p1 + z2
z2
p1 + z2

p3 + ∆x(zp2 + zp3)
p3 + ∆x(zp1 + zp3)
p2 + ∆x(zp1 + zp2)

A1 = −diag

0
0
0


(∆x + zp2 + zp3)(zp2 − zp3)

(∆x + zp1 + zp3)(zp3 − zp1)
(∆x + zp1 + zp2)(zp1 − zp2)

 ,

I


Op is the the bottom left corner location of the cell that particle p aﬀects, zp = Op− xp and Z = diag(z).
Figure 2 shows the structure of this matrix. Its inverse has the same structure.

5.7. Degrades to backward Euler case

The transfers are the same as in [17], except for the update rule for Bn+1

, which we show below
simpliﬁes into the transfer from [17] with λ = 0. Using λ recovers the the backward Euler grid update
rule ˜xn+1

. Then,

i + ∆t˜vn+1

i = xn

p

i

(cid:88)

i

˜xn+1
i = xn
ip ˜xn+1
i =

wn

i + ∆t˜vn+1

i
i + ∆t˜vn+1
ip(xn

i

wn

)

i
p = xn
xn+1
p + ∆tvn+1
1
2

p =

wn
ip

Bn+1

i

p

(cid:0)˜vn+1
(cid:0)˜vn+1

i

i

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

1
2

i

i

i

=

=

=

=

i − xn

(xn

p + ˜xn+1

)T + (xn

i − xn

p − ˜xn+1

i + xn+1

p

)(˜vn+1

i

wn
ip

(2xn

i − 2xn

p + ∆t˜vn+1

i − ∆tvn+1

p

)T + ∆t(vn+1

p − ˜vn+1

i

)(˜vn+1

i

p

i − xn+1
(cid:88)
(cid:0)−vn+1

wn
ip

i

p

∆t
2

∆t
2

(cid:0)−˜vn+1

i

(vn+1

p

)T + vn+1

(˜vn+1

p

i

)T(cid:1)

(vn+1

p

)T + vn+1

p

(vn+1

p

wn

ip ˜vn+1

i

i − xn

(xn

p )T +

wn

ip ˜vn+1

i

(xn

wn

ip ˜vn+1

i

(xn

p )T +

i − xn
i − xn
p )T

)T(cid:1)
)T(cid:1)

)T(cid:1)

Another departure from [17] is the update rule for xn+1

p

. We note, however, that these are also

i

This was the original APIC transfer.

equivalent in the λ = 0 case.

xn+1

p =

=

(cid:88)
(cid:88)

i

wn

ip ˜xn+1

i

wn

ip(xn

i + ∆tλvn

(cid:88)
(cid:88)

i

)

i

i + ∆t(1 − λ)˜vn+1
(cid:88)
i + ∆t(1 − λ)
i + ∆t(1 − λ)vn+1

p

i

wn

ipvn

wn

ipvn

i
= xn

p + ∆tλ

= xn

p + ∆tλ

wn

ip ˜vn+1

i

Note that the second term is not vn
p . This term vanishes in the special case λ = 0, so that the transfer in
[17] could be done using the particle velocity. We see that the proposed method represents a generalization
of the original APIC scheme.

i

21

Figure 3: Rotation test.

Figure 4: Rebound test.

5.8. Note on transfer construction

(cid:88)

(cid:0)˜vn+1

i

The most important diﬀerence between the method described above and the original APIC method
from [17] is (30). This transfer was constructed by ﬁrst assuming that the transfer should take the form

Bn+1

p =

wn
ip

(axn

i + bxn

p + c˜xn+1

i + dxn+1

p

)T + (exn

i + f xn

p + g˜xn+1

i + hxn+1

p

)(˜vn+1

i

i

i

)T xn

Terms involving vn
i could also be considered; such terms would add a FLIP-like character to the transfer.
Terms similar to (˜vn+1
i I are also technically possible; we do not include them since we did not ﬁnd
them to contribute meaningfully to the transfer. We restrict ourselves here to the form above, which leaves
us to choose the eight coeﬃcients. We require (1) angular momentum conservation (See Section 5.3),
(2) aﬃne round trip (See Section 5.5), and (3) one particle stability (See Section 5.4). These three
constraints uniquely determine all eight coeﬃcients in the general case. In the special case λ = 0, the
eight terms are not linearly independent; this allows additional freedom to eliminate terms, resulting in
the simpler transfer from [17].

)T(cid:1).

5.9. Stability concerns for multilinear interpolation

With linear interpolation weights, Dn

p is not invertible. The particle to grid transfer from

mn

i vn

i =

wn

ipmp(vn

p + Bn

p (Dn
p )

−1(xn

i − xn
p ))

(cid:88)

p

22

0123450.00980.00990.010.01010.01020.0103TimeAngular momentumTotal Angular Momentum ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint RuleFLIP Backward EulerFLIP Symplectic Euler0123450.00180.001850.00190.001950.0020.00205TimeEnergyTotal Energy ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint Rule (grid)FLIP Backward Euler (grid)FLIP Symplectic Euler (grid)FLIP Midpoint Rule (particle)FLIP Backward Euler (particle)FLIP Symplectic Euler (particle)05010015020001020304050TimeAngular momentumTotal Angular Momentum ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint RuleFLIP Backward EulerFLIP Symplectic Euler05010015020001234TimeEnergyTotal Energy ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint RuleFLIP Backward EulerFLIP Symplectic EulerFigure 5: Skew impact of two elastic cylinders.

can in the multilinear interpolation case be re-written as

mn

i vn

i =

(wn

ipmpvn

p + mpBn

p∇wn
ip)

(cid:88)

p

using wn
particle. Let vn

ip(Dn

p )−1(xn

i − xn

p ) = ∇wn

p = 0 and Bn

p = I. Then

ip. To see why this can cause problems, consider the case with one

mn

i vn

i = mp∇wn
vn

∇wn
wn
ip

i =

ip

ip

2 ∆x), then wn

Consider a grid cell at [0, ∆x]×[0, ∆x] with grid degrees of freedom at x(i,j) = (i∆x, j∆x). If the particle
∆x(cid:105), which is
∆x , 2
p is at (∆x, 1
4∆x mp(−1 + 4).
unbounded. This in turn results in a kinetic energy contribution of 1
Since  can be arbitrarily small, the energy of the grid node can be arbitrarily large. This unbounded
growth in energy causes instability and makes a multilinear interpolation kernel unsuitable for this APIC
formulation.

∆x(cid:105). But then, vn
(1,1)(cid:107)vn

(1,1) = (cid:104) 1
(1,1)(cid:107)2 = 1

(1,1)p = (cid:104) 1
2∆x ,

2 and ∇wn

(1,1)p = 

2 mn



In order to use APIC using multilinear interpolation function without being unstable, we can lag the

aﬃne matrix with the transfers being

mn

i vn

i =

Cn+1

p =

(cid:88)
(cid:88)

p

i

wn

ipmp(vn

p + Cn

wn

ip ˜vi((Dn
p )

p )),

i − xn
p (xn
i − xn

p ))T .

−1(xn

p =(cid:80)

i ˜vi(∇wn

For multilinear interpolation, it further simpliﬁes to Cn+1
ip)T . Note that this formulation
does not suﬀer from the same energy increasing problem as long as C is bounded. The diﬀerence
is eﬀectively that the B formulation inverts Dn
p at the end of the time step rather than doing so at
the beginning of the next time step. In the quadratic and cubic cases, the C formulation and the B
formulation are equivalent, since Dn
p = Dn+1
.
For multilinear interplation, we always use the lagged version for stability.

p is a constant scalar multiple of the identity and thus Dn

p

6. Numerical simulations

6.1. Rotating elastic cylinder

We begin our tests by running a simple rotation test. We use a [0, 1] × [0, 1] domain with 32 × 32
resolution. We initialize a circle with radius 0.3 centered at (0.5, 0.5), seeded with four particles per cell.
The circle begins rotating with angular velocity 0.4 about its center. We use an initial density ρ = 2 and
a Neo-Hookean constitutive model with E = 1000 and ν = 0.3. See Figure 3.

23

05101520-20020406080100TimeAngular momentumTotal Angular Momentum ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint RuleFLIP Backward EulerFLIP Symplectic Euler05101520010203040TimeEnergyTotal Energy ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint Rule (grid)FLIP Backward Euler (grid)FLIP Symplectic Euler (grid)FLIP Midpoint Rule (particle)FLIP Backward Euler (particle)FLIP Symplectic Euler (particle)Figure 6: Colliding rings.

Figure 7: Colliding spheres 3D, frame 70/145/253 with framerate 24Hz.

6.2. Rebound of an elastic cylinder

We run the same example as in section 4.1 of [7].
The grid spacing is h = 0.5. Slip boundary conditions are applied at x = 0 and x = 15. The cylinder
is initially centered at (2.5, 2.5) and has radius 1.5. MPM particles are sampled with alignment to the
grid with spacing 0.25 (so 4 particles per cell for a full cell). Material density is 4. The constitutive
model is Neo-Hookean with Young’s Modulus 85.5 and Poisson’s ratio 0.425. The initial velocity of the
cylinder is (0.5, 0). See Figure 4.

6.3. Skew impact of two elastic cylinders

We run the same example as in section 4.2 of [7].
The grid spacing is h = 1. The ﬁrst cylinder is initially centered at (3, 3) with velocity (0.75, 0).
The second cylinder is initially centered at (16, 5) with velocity (−0.75, 0). Each cylinder has radius 2.
MPM particles are sampled with alignment to the grid with spacing 0.5 (so 4 particles per cell for a full
cell). Material density is 5. The constitutive model is Neo-Hookean with Young’s Modulus 31.685 and
Poisson’s ratio 0.44022.

6.4. Elastic cylinder collision

We extend the previous example to two colliding hollow cylinders.
The grid spacing is h = 0.01. The ﬁrst ring is initially centered at (0.1, 0.24) with velocity (50, 0). The
second ring is initially centered at (0.4, 0.24) with velocity (−50, 0). Each ring has outer radius 0.04 and
inner radius 0.03. MPM particles are sampled with alignment to the grid with spacing 1/300. Material
density is 1010. The constitutive model is Neo-Hookean with Young’s Modulus 7.3e7 and Poisson’s ratio
0.4.

24

00.0020.0040.0060.0080.010.012-1e-08-5e-0905e-091e-08TimeAngular momentumTotal Angular Momentum ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint RuleFLIP Backward EulerFLIP Symplectic Euler00.0020.0040.0060.0080.0101000200030004000500060007000TimeEnergyTotal Energy ComparisonsAPIC Midpoint RuleAPIC Backward EulerAPIC Symplectic EulerPIC Midpoint RulePIC Backward EulerPIC Symplectic EulerFLIP Midpoint Rule (grid)FLIP Backward Euler (grid)FLIP Symplectic Euler (grid)FLIP Midpoint Rule (particle)FLIP Backward Euler (particle)FLIP Symplectic Euler (particle)Figure 8: Colliding spheres 3D with initial angular velocity of 1, frame 1/34/63/92 with framerate 12Hz.

Figure 9: Dropping torus with framerate 24Hz.

6.5. Elastic sphere collision (3D)

We extend the skew impact of spheres to 3D. The grid spacing is h = 30/256. The ﬁrst sphere
is initially centered at (10, 13, 15) with velocity (0.75, 0, 0). The second sphere is initially centered at
(20, 15, 15) with velocity (−0.75, 0, 0). Each sphere has radius 2. MPM particles are sampled with 4
particles per cell for a total particle count of 333, 213. Material density is 5. The constitutive model is
Neo-Hookean with Young’s Modulus 31.685 and Poisson’s ratio 0.44022. Figure 7 shows the visualized
objects at time 2.92, 6.04 and 10.54.

We further extend the previous test by initializing each sphere with an angular velocity of (0, 0, 1)
(i.e., the spheres initially rotate counterclockwise) and scaling the Young’s modulus by 8. Figure 8 shows
the visualized objects at time 0.08, 2.83, 5.25 and 7.67.

6.6. Torus dropping

We drop 25 tori (with 8592 particles each) into a box with width 0.4× 0.4 and height 0.3. Each torus
has inner radius 0.03 and outer radius 0.06 and is sampled at height 1.0 with random initial rotation
around the ground normal. The material density is 5. Young’s modulus is 150 and Poisson’s ratio is 0.3.
Figure 9 shows the particles and the reconstructed surfaces at time 8.50.

Acknowledgements

We thank Daniel Ram and Theodore Gast for their insightful suggestions. The authors were partially
supported by NSF CCF-1422795, ONR (N000141110719, N000141210834), DOD (W81XWH-15-1-0147),
Intel STC-Visual Computing Grant (20112360) as well as a gift from Disney Research.

References

[1] F. Harlow, The particle-in-cell method for numerical solution of problems in ﬂuid dynamics, Meth Comp Phys 3 (1964)

319–343.

[2] J. Brackbill, H. Ruppel, Flip: A method for adaptively zoned, particle-in-cell calculations of ﬂuid ﬂows in two dimen-

sions, J Comp Phys 65 (1986) 314–343.

[3] J. Brackbill, D. Kothe, H. Ruppel, Flip: A low-dissipation, pic method for ﬂuid ﬂow, Comp Phys Comm 48 (1988)

25–38.

25

[4] Y. Grigoryev, V. Vshivkov, M. Fedoruk, Numerical Particle-In-Cell Methods: Theory and Applications, Walter de

Gruyter, 2002.

[5] D. Burgess, D. Sulsky, J. Brackbill, Mass matrix formulation of the ﬂip particle-in-cell method, J Comp Phys 103

(1992) 1–15.

[6] J. Brackbill, On modelling angular momentum and vorticity in compressible ﬂuid ﬂow, Comp Phys Comm 47 (1)

(1987) 1–16.

[7] E. Love, D. Sulsky, An unconditionally stable, energy-momentum consistent implementation of the the material point

method, Comp Meth App Mech Eng 195 (2006) 3903–3925.

[8] A. Langdon, Eﬀects of spatial grid simulation in plasmas, J Comp Phys 6 (2) (1970) 247–267.
[9] H. Okuda, Nonphysical noises and instabilities in plasma simulation due to a spatial grid, J Comp Phys 10 (3) (1972)

475–486.

[10] J. Brackbill, The ringing instability in particle-in-cell calculations of low-speed ﬂow, J Comp Phys 75 (2) (1988)

469–492.

[11] C. E. Gritton, Ringing instabilities in particle methods, Ph.D. thesis, The University of Utah (2014).
[12] D. Sulsky, Z. Chen, H. L. Schreyer, A particle method for history-dependent materials, Comp Meth in App Mech Eng

118 (1) (1994) 179–196.

[13] D. Sulsky, S. Zhou, H. Schreyer, Application of a particle-in-cell method to solid mechanics, Comp Phys Comm 87 (1)

(1995) 236–252.

[14] J. Monaghan, On the problem of penetration in particle methods, J Comp Phys 82 (1) (1989) 1–15.
[15] J. Brackbill, G. Lapenta, Particle-in-cell magnetohydrodynamics, in: 16th Int Conf on the Numer Sim of Plasmas,

1998.

[16] S. Bardenhagen, E. Kober, The generalized interpolation material point method, Comp Mod in Eng and Sci 5 (6)

(2004) 477–496.

[17] C. Jiang, C. Schroeder, A. Selle, J. Teran, A. Stomakhin, The aﬃne particle-in-cell method, ACM Trans Graph 34 (4)

(2015) 51:1–51:10.

[18] P. Wallstedt, J. Guilkey, Improved velocity projection for the material point method, Comp Mod in Eng and Sci 19 (3)

(2007) 223.

[19] T. Yabe, F. Xiao, T. Utsumi, The constrained interpolation proﬁle method for multiphase analysis, J Comp Phys

169 (2) (2001) 556–593.

[20] O. Gonzalez, Exact energy and momentum conserving algorithms for general models in nonlinear elasticity, Comp

Meth in App Mech Eng 190 (13) (2000) 1763–1783.

[21] T. Laursen, X. Meng, A new solution procedure for application of energy-conserving algorithms to general constitutive

models in nonlinear elastodynamics, Comp Meth in App Mech Eng 190 (46) (2001) 6309–6322.

[22] J. Simo, N. Tarnow, The discrete energy-momentum method. conserving algorithms for nonlinear elastodynamics,

Zeitschrift f¨ur angewandte Mathematik und Physik ZAMP 43 (5) (1992) 757–792.

[23] J. C. Simo, N. Tarnow, K. Wong, Exact energy-momentum conserving algorithms and symplectic schemes for nonlinear

dynamics, Comp Meth in App Mech Eng 100 (1) (1992) 63–116.

[24] C. Kane, Variational integrators and the newmark algorithm for conservative and dissipative mechanical systems,

Ph.D. thesis, caltech (1999).

[25] A. Lew, J. Marsden, M. Ortiz, M. West, Variational time integrators, Int J Numer Meth Eng 60 (1) (2004) 153–212.
[26] T. F. Gast, C. Schroeder, Optimization integrator for large time steps, in: Proc ACM SIGGRAPH/Eurograph Symp

Comp Anim, 2014.

[27] T. Gast, C. Schroeder, A. Stomakhin, C. Jiang, J. Teran, Optimization integrator for large time steps, IEEE Trans

Vis Comp Graph 21 (10) (2015) 1103–1115.

26

