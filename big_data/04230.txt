An eﬃcient magic state approach to small angle rotations

1Department of Physics & Astronomy, University of Sheﬃeld, Sheﬃeld, S3 7RH, United Kingdom.∗

Earl T. Campbell1 and Joe O’Gorman2

2Department of Materials, University of Oxford, Oxford, OX1 3PH, United Kingdom.

Standard error correction techniques only provide a quantum memory and need extra gadgets to
perform computation. Central to quantum algorithms are small angle rotations, which can be fault-
tolerantly implemented given a supply of an unconventional species of magic state. We present a
low-cost distillation routine for preparing these small angle magic states. Our protocol builds on the
work of Duclos-Cianci and Poulin [Phys. Rev. A 91, 042315 (2015)], though it uses nearly half the
resources to achieve the same output error rate. Direct access to small angle rotations reduces the
need for costly gate synthesis techniques. We ﬁnd a magic state approach can reduce resource costs
by approximately a factor of 40 compared to using gate synthesis, with some variation depending
on the parameter regime of interest.

6
1
0
2

 
r
a

 

M
4
1

 
 
]
h
p
-
t
n
a
u
q
[
 
 

1
v
0
3
2
4
0

.

3
0
6
1
:
v
i
X
r
a

I.

INTRODUCTION

Fault-tolerant quantum computing involves a host of
resource overheads, entering at diﬀerent stages of the pro-
cess. The most widely known cost is that of encoding a
logical qubit into many physical qubits, which provides
safe storage of quantum information. However, once en-
coded, a logical qubit only natively supports a limited set
of fault-tolerant operations [1]. For high-threshold codes,
the native operations belong within the Cliﬀord group.
Additional layers of gadgets are required to enable gen-
eral purpose quantum computation. The Solovay-Kitaev
theorem [2] ensures that if the Cliﬀord group is aug-
mented by a non-Cliﬀord T gate, also called the π/8 gate,
the device can perform any required quantum algorithm.
These T gates can in turn be fault-tolerantly performed
by using state injection of high-ﬁdelity magic states, pre-
pared by distillation [3]. However, the Solovay-Kitaey
theorem requires a huge number of T gates, and early
magic state distillation protocols put a high price on each
one. The last decade has seen substantial advances in
both these areas. Magic state distillation is now possible
at better rates [3–7], reducing the expected cost per high
quality T -gate. The number of T -gates needed to ap-
proximate some unitary, the so-called T -count, has also
been signiﬁcantly reduced after the discovery of new gate
synthesis techniques [8–12].

Nevertheless,

fault-tolerant quantum computing re-
mains a monumental challenge, so further resources sav-
ings are essential. One suggested route is to circum-
vent magic states altogether, for instance by using gauge-
ﬁxing [13] of subsystem codes like the 3D colour code [14].
However, this route still pays a price for gate-synthesis
and the additional qubit cost of 3D codes leads to a
cubic scaling of overheads that is also achievable using
magic states [15]. Furthermore, all current indications
are that colour codes have a much lower error correction
threshold [16] than the toric code [15, 17–19]. For now,
such low-noise levels appear beyond technological reach,

∗ earltcampbell@gmail.com

FIG. 1. State-injection using a magic state |M(cid:96)(cid:105) to perform
a non-Cliﬀord gate R(cid:96). If the Y -basis measurement outcome
is “+1”, then a correction R(cid:96)−1 is needed.

ruling out gauge-ﬁxing in the near-term. Alternatively,
one could work with qudits, d-level systems, which are
favourable in terms of the cost of magic state distilla-
tion [20–23], though in the qudit context little is known
about gate synthesis or experimental feasibility.

Landahl and Cesare [24] were the ﬁrst to suggest that
the gate synthesis overhead could be reduced by distilling
diﬀerent species of magic states, which provide smaller
angle rotations instead of T -gates. Speciﬁcally, they con-
sidered exp(iπZ/2(cid:96)) gates, where (cid:96) = 3 gives the T -gate
and (cid:96) > 3 explores the small angle regime. These gates
are part of an important family called the Cliﬀord hier-
archy [25], with exp(iπZ/2(cid:96)) residing in the (cid:96)th level of
the hierarchy and naturally appearing in quantum simu-
lation [26] and the quantum Fourier transform. Landahl
and Cesare found that for small integer (cid:96), distillation
was favourable over gate synthesis methods known at the
time. Unfortunately, for very small angle rotations 5 (cid:46) (cid:96),
they saw this advantage vanish.

Progress in gate synthesis has signiﬁcantly eroded the
importance of the Landahl and Cesare result, though
their general idea endures. Several researchers found ef-
ﬁcient protocols that distil Toﬀoli magic states [27–29].
Duclos-Cianci and Poulin [30] modiﬁed a protocol pro-
posed by Meier, Eastin and Knill [4] to prepare magic
states that again provide small angle rotations. This
recent result was a substantial leap forward in the art
of distilling magic states for small angle rotations, mak-
ing magic state distillation signiﬁcantly cheaper than the

|M(cid:31)(cid:30)•YYR(cid:31)−1R(cid:31)Magic state injec(cid:31)ion2

FIG. 2. (a,b,c) Circuit identities and gadgets used to construct distillation protocols. (d) a non-compressed distillation circuit.
Adding |0(cid:105)(cid:104)0| measurements and preparations within the grey box gives the DP(cid:96) protocol. (e) the compressed distillation
circuit describing MEK(cid:96). In both (d) and (e) noisy |M(cid:96)(cid:105) states are input on the bottom two circuits lines (labelled qubits 3
and 4 in the main text) and all R(cid:96) gates with L ≥ 3 are approximately implemented by injection of a noisy |M(cid:96)(cid:105) states.

most recent gate synthesis methods. The Duclos-Cianci
and Poulin proposal works well even for ultraﬁne rota-
tions, and so very large (cid:96). We revisit the work of Duclos-
Cianci and Poulin, and ﬁnd their protocol can be fur-
ther reﬁned. Our proposed alternative requires fewer re-
sources per attempt, and achieves superior error suppres-
sion with a higher success probability. Both our protocol
and that of Duclos-Cianci and Poulin build on the earlier
work of Meier, Eastin, and Knill (MEK) [4]. Before pre-
senting results we review this relevant background mate-
rial in more detail.

II. MAGIC STATES MODEL

First we cover the Cliﬀord hierarchy and the magic
state model. The well known Pauli group P is the group
composed of tensor products of the single qubit Pauli
operators. Unitaries mapping the Pauli group to itself
are called Cliﬀord unitaries, which again form a group
C := {U|U P U† ∈ P,∀P ∈ P}. Cliﬀord operations are
any physical operations composable from Cliﬀord uni-
taries, measurement of Pauli operators and preparation
of their eigenstates (the stabiliser states), and classical
feedforward. The magic state model of quantum compu-
tation [3] assumes Cliﬀord operations are free resources
that can be implemented perfectly, and proceeds to eval-
uate the cost of non-Cliﬀord operations. Such a model is
suitable for logical qubits where the Cliﬀord operations
are fault-tolerantly protected, as is common. Unitaries
outside the Cliﬀord group can fall into other levels of the
Cliﬀord hierarchy, deﬁned recursively as

C(cid:96) := {U|U P U† ∈ P,∀P ∈ C(cid:96)−1},

(1)

where C1 := P. It follows that the Cliﬀord group is the
second level, and all higher levels include non-Cliﬀord
gates. We will soon see the Cliﬀord hierarchy plays an im-
portant operational role in a teleportation process known
as state injection [31].

We introduced small angle rotations in the Z basis,
but here it is more convenient to work in the Y basis.
We deﬁne unitaries R(cid:96) := exp(iθ(cid:96)Y ) with θ(cid:96) = π/2(cid:96).
The R1 and R2 gates are Cliﬀord, which are presumed
ideal and an inexpensive resource. The R3 gate is non-
Cliﬀord and equivalent to the T gate. For (cid:96) ≥ 3, the
gates are non-Cliﬀord and belong to the (cid:96)th level of the
Cliﬀord hierarchy. Also important here are certain Her-
mitian operators in the Cliﬀord hierarchy, and we deﬁne
H(cid:96) := R(cid:96)XR†(cid:96) = XR2
(cid:96) = XR(cid:96)−1 and ﬁnd H(cid:96) ∈ C(cid:96)−1. We
remark that H3 equals the Hadamard.
Preparation of non-stabiliser states are also non-
Cliﬀord operations, and these magic states also fall into a
natural hierarchy. Recall that stabiliser states are eigen-
states of Pauli operators, which are elements of C1. We
consider magic states that are eigenstates of the H(cid:96) op-
erators, so that

|M(cid:96)(cid:105) = H(cid:96)|M(cid:96)(cid:105) = R(cid:96)|0(cid:105),
| ¯M(cid:96)(cid:105) = (−H(cid:96))| ¯M(cid:96)(cid:105) = R(cid:96)|1(cid:105),

(2)

(3)

which we refer to as (cid:96)th level magic state states. Such re-
sources can be used to inject R(cid:96) rotations into circuits as
shown in Fig. 1. The injection procedure is probabilis-
tic, and with probability 1/2 it performs R(cid:96) and with
probability 1/2 it performs R†(cid:96). In the latter case a cor-
rection of R2
(cid:96) = R(cid:96)−1 is needed to get the desired result.
Since R2 is Cliﬀord, the injection process is ensured to
terminate within (cid:96) − 2 attempts.

EHE†HHH=×•×•××••×××H×=•H(cid:31)H(cid:31)H(cid:31)••EHE†EHE†HHHHHH(cid:31)H=•H(cid:31)H(cid:31)H(cid:31)abc(cid:31)|+(cid:28)••|+(cid:28)|0(cid:28)ER3R†3E†R3R†3E†|0(cid:28)|0(cid:28)R3R†3R3R†3|0(cid:28)R3R†3R3R†3R3R†3R(cid:31)−1XR3R†3Ede|+(cid:28)••|+(cid:28)|0(cid:28)ER2E†ER2E†|0(cid:28)|0(cid:28)|0(cid:28)R3R†3R3R†3R3R†3R(cid:31)−1XR3R†3DP(cid:31)MEK(cid:31)Therefore, one can accomplish small angle rotations
with a cost that depends on the cost of distilling high-
ﬁdelity |M(cid:96)(cid:105) states. In contrast, gate synthesis methods
prescribe distilling just |M3(cid:105) states and ﬁnding a gate
sequence R(cid:96) ≈ C1T C2 . . . T Cn in terms of T gates and
Cliﬀords Cj. Although, |M(cid:96)(cid:105) states will prove more ex-
pensive than |M3(cid:105), gate synthesis can require very many
|M3(cid:105) states, making it more expensive overall. While
there are many gate synthesis algorithms for ﬁnding gate
sequences, here we use the phrase synonymously with
the Ross and Selinger [11] algorithm. Some alternative
methods (see e.g. [9]) can reduce gate synthesis costs by
about a third, but they currently lack an eﬃcient soft-
ware implementation and we will see that using magic
states oﬀers a much greater reduction than a third.

III. OVERVIEW OF RESOURCE COSTS

Next we summarise the work of of Meier, Eastin, and
Knill (MEK) [4], upon which Duclos-Cianci and Poulin
built their construction. The MEK protocol takes 10
input magic states and with some probability outputs
2 magic states. Therefore, MEK is said to be a 10 →
2 protocol. Accounting for the species of magic states,
we call MEK a 103 → 23 protocol where the subscripts
indicate that MEK both inputs and outputs 3rd level
magic states. We use DP(cid:96) protocol to label the Duclos-
Cianci and Poulin protocol for performing (cid:96)th level gates.
Each round of DP(cid:96) consumes a cocktail of diﬀerent input
magic states, and we describe it as a

(cid:18) 1

(cid:19)

(cid:18) 1

(cid:19)

(cid:18) 1

(cid:41)

(cid:19)

(cid:40)

,

3

4

2

, . . .

(cid:96)−3

(cid:96)−2

2(cid:96)−3

163, 2(cid:96), 1(cid:96)−1,

→ 2(cid:96)
(4)
protocol. Again, subscripts show what level magic state
is used. We show the expected number of inputs re-
quired per attempt, which is sometimes a fraction. The
fractional sequence terminates at the third level, because
lower levels correspond to Cliﬀord resources and are con-
sidered free. The DP(cid:96) protocol is presented as a direct
generalisation of MEK, but one sees that in the case of
(cid:96) = 3 the DP3 protocol is a 183 → 23 protocol and so ac-
tually needs almost twice as many input states as MEK.
Here we construct a streamlined variant of DP(cid:96), that we
call MEK(cid:96) and is a

(cid:18) 1

(cid:19)

(cid:18) 1

(cid:19)

(cid:18) 1

(cid:41)

(cid:19)

,

4

, . . .

(cid:96)−3

2(cid:96)−3

2 (cid:96)−2

83, 2(cid:96), 1(cid:96)−1,

→ 2(cid:96)
(5)
protocol. We ﬁnd that MEK3 corresponds precisely to
the original MEK, so that MEK(cid:96) is a more apt gener-
alisation than DP(cid:96). Not only does MEK(cid:96) require fewer
input resources, it also achieves superior error suppres-
sion with a higher success probability.

3

Both MEK and DP(cid:96) make use of a simple 4 qubit code.
We use E, short for encoder, to denote the Cliﬀord circuit

(cid:40)

3

that brings qubits into the codespace and acts on pairs
of Pauli operators as

(Z1, X1) → (Z1Z2Z3Z4, X1X3X4),
(Z3, X3) → (Z1Z4, X1X3),
(Z2, X2) → (X1X2X3X4, Z2),
(Z4, X4) → (X1X4, Z1Z3).

(6)
(7)
(8)
(9)

For Pauli operators, we always use the subscript to de-
note which qubit the operator acts upon. Preparing the
ﬁrst two qubits in the state |0(cid:105) and running the en-
coder will yield the code stabilised by Z1Z2Z3Z4 and
X1X2X3X4. The logical state in the codespace is deter-
mined by the initial states of the last two qubits. Having
deﬁned the codespace, we now turn to describing DP(cid:96)
in more detail, where we will also discuss the important
features of the 4-qubit code.

IV. UNCOMPRESSED DP(cid:96) PROTOCOL

The protocol DP(cid:96) is illustrated in Fig. (2d). Through-
out, we label the top wire as the control qubit c, and the
subsequent qubits labelled as 1 to 4. We summarise the
main steps of the protocol here

1. Prepare qubits c, 1 and 2, in stabiliser states |+(cid:105),

|0(cid:105) and |0(cid:105), respectively;

2. Prepare qubits 3 and 4 in noisy |M(cid:96)(cid:105) states of inﬁ-

delity (cid:96);

3. Perform the circuit gates shown in Fig. (2d): the
R3 gates are achieved by state injection using eight
|M3(cid:105) states, and R(cid:96)−1 is achieved with state injec-
tion resulting in overall inﬁdelity η(cid:96)−1;

4. Qubit c is measured in X basis, and we continue if
the outcome is “ + 1” and otherwise declare FAIL-
URE;

5. Qubits 1 and 2 are measured in Z basis, and we
declare SUCCESS if the outcome is “ + 1” and oth-
erwise declare FAILURE;

6. If successful, qubits 3 and 4 are output as |M(cid:96)(cid:105)

states of higher ﬁdelity.

Note that step 3 can include some additional postselected
measurements highlighted in Fig. (2d). If included these
measurements detect some additional errors, but even
without these measurements the protocol quadratically
suppresses noise. For simplicity we will assume they are
not performed. We next review some of the basic intu-
ition behind why DP(cid:96) works, which is closely related to
properties of the 4 qubit code used.

The codespace provides both important transversality
features and keeps the protocol protected against cer-
tain faults. Regarding transversality, a global Hadamard

4

FIG. 3. Circuit identities and reductions used to obtain MEK(cid:96). (a) circuit before compression, with subcircuit V labelled. (b)
and (c) show properties of V . (c) shows partially compressed circuit after applying identity (b). (d) further compressed circuit
after applying identity (b). In (f) we identify subcircuit Q, with (g) showing a property of Q. Applying (g) to (f) yields the
ﬁnal compressed circuit, shown in Fig. (2e).

H ⊗ H ⊗ H ⊗ H will preserve the code space, implement-
ing a logical SWAP between the two encoded logical bits.
More generally, one can verify that E(H ⊗H ⊗H ⊗H)E†
acts as shown in Fig. (2a). We see that even without ﬁx-
ing the ﬁrst two qubits to |0(cid:105), this circuit implements a
swap and a phase-swap (a swap combined with a phase
gate). Furthermore, implementing controlled Hadamards
within the encoding will realise controlled versions of the
swap and phase-swap. Next, we note that for any Her-
mitian unitary, such as H(cid:96), we have that conjugation
by controlled-swaps will produce a controlled H(cid:96) ⊗ H(cid:96) as
shown in Fig. (2b). We combine this observation with the
transversality properties of the code to get the identity
of Fig. (2c). An ancilla on the control of the controlled
H(cid:96) ⊗ H(cid:96) is used to measure the H(cid:96) ⊗ H(cid:96) observable. If
the desired magic state is an eigenstate of H(cid:96), then mea-
suring H(cid:96) ⊗ H(cid:96) allows us to detect a single error between
two noisy |M(cid:96)(cid:105) states input on the bottom two circuit
lines. In this sense, the codespace has provided a SWAP
gadget for distilling noisy |M(cid:96)(cid:105) magic states.

Although the controlled-Hadamard rotations and H(cid:96)
rotation may be non-Cliﬀord, noisy magic states can be
used to implement these operations. To see this recall
that H = R3XR†3, and so a control-Hadamard can be im-
plemented by a control-X gate sandwiched between R3

and R†3. In turn, R3 and R†3 can each be implemented at
the cost of a single |M3(cid:105) magic state. Given noisy |M3(cid:105)
magic states, we implement noisy R3 gates. This brings
us to the second role played by the error-correction code.
The R3 gates are performed on qubits within an error
correction code that can detect a single qubit error, and
so we will detect a single error in any |M3(cid:105) magic states.
Let us explain this point in more detail. When using
state injection, if a magic state carries an error, then it
will result in Y · R3 instead of R3, and so there is an
additional Y acting on one of the four qubits. Inside the
encoding, the state is an eigenstate of X ⊗ X ⊗ X ⊗ X,
but a Y error will cause the state to become an eigen-
state of −X ⊗ X ⊗ X ⊗ X. At the end of the circuit,
we decode and measure, which is equivalent to measur-
ing the X ⊗ X ⊗ X ⊗ X observable. Since we postselect
on all +1 outcomes, any error on a single |M3(cid:105) will be
detected. In contrast, the central R(cid:96)−1 rotation occurs
outside the protection of the codespace when the logical
qubits have been decoded onto single qubits. Therefore,
the protocol will not be robust against failure of this gate,
and so this rotation must be high ﬁdelity and we herein
call it the pivotal rotation. Nevertheless, we can con-
struct good distillation protocols provided magic states
used in the pivotal rotation have already been distilled

ad|+(cid:30)••|+(cid:30)|0(cid:30)ER3R†3E†ER3R†3E†|0(cid:30)|0(cid:30)R3R†3R3R†3|0(cid:30)R3R†3R3R†3R3R†3R(cid:31)−1XR3R†3|+(cid:30)••|+(cid:30)|0(cid:30)ER3R†3VR3R†3E†|0(cid:30)|0(cid:30)|0(cid:30)R3R†3R3R†3R3R†3R3R†3|+(cid:30)••|+(cid:30)|0(cid:30)ER3VR2R†3E†|0(cid:30)|0(cid:30)|0(cid:30)R3R†3R3R†3R3R†3R3R†3ef|+(cid:30)••••|+(cid:30)|0(cid:30)ER3VR2R†3E†|0(cid:30)|0(cid:30)|0(cid:30)R3R†3R3R†3R3R†3R3R†3QV•VR†3R3•V=bVR3=R†3VR2cR3R†3QR2Qg=R†3R3to a much higher ﬁdelity than all other elements of the
circuit. These high ﬁdelity resources will be costly, but
the protocol remains eﬃcient because resources for per-
forming R(cid:96)−1 are less valuable than the |M(cid:96)(cid:105) states we
are distilling. We are erecting a pyramid of distillation
protocols, with resources from lower in the Cliﬀord hier-
archy fuelling distillation at higher levels.

V. COMPRESSED MEK(cid:96) PROTOCOL

Our main contribution is to show that this circuit can
be compressed into Fig. (2e). This cancels several R3 ro-
tations to reduce the number of magic states consumed.
The steps of the protocol roughly follows those numer-
ically listed in the previous section, except step 3 now
uses the circuit of Fig. (2e), and we use only 8 magic
states to inject the R3 gates.
It is important that the
circuit retains its fault-tolerance properties through the
compression process. That is, even when compressed the
noisy R3 gates still occur within the four-qubit error cor-
rection code, and so we still expect to detect the failure
of any single R3 gate. In App. A, we present a full noise
analysis that rigorously conﬁrms this intuition.

Here we show how to compress the distillation proto-
col, removing unnecessary non-Cliﬀord gates. We start
with the protocol shown in Fig. (2d) and through a
series of circuit reductions arrive at Fig. (2e). Tak-
ing Fig. (2d), we identify a subcircuit V shown in
Fig. (3a) inside a dotted box. Next we establish two
properties of V , which are illustrated in Figs. (3b)
and (3c). Algebraically, the V circuit is simply V =
E exp(iθ(cid:96)−1Y4)X4E†, and using Eqs.(6) we see that V =
exp(iθ(cid:96)Y1Z3X4)Z1Z3. This acts trivially on the second
qubit and control qubit, entailing the circuit identity of
Fig. (3b). Going further, we notice that V Y1 = −Y1V
and so exp(iθ3Y1)V exp(−iθ3Y1) = exp(i2θ3Y1)V . Us-
ing 2θ3 = θ2, we conclude exp(iθ3Y1)V exp(−iθ3Y1) =
exp(i2θ2Y1)V . Recall that exp(i2θ2Y1) is the R2 gate
acting on qubit 1, and so we have the identity shown in
Fig. (3c).

Applying the identity Fig. (3b), shows that Fig. (3d)
is equivalent to the original circuit. This observation has
eliminated 4 non-Cliﬀord gates. Next, we apply the iden-
tity of Fig. (3c), to obtain Fig. (3e). Since R2 is Cliﬀord,
we have removed 2 further non-Cliﬀords from the circuit.
Next, we group together a new collection of circuit ele-
ments Q shown in dashed box of Fig. (3f). Algebraically,
Q is

c,1 exp(iθ2Y1)V C X
Q = C X
c,1
c,1 exp(iθ2Y1) exp(iθ(cid:96)Y1Z3X4)Z1Z3C X
= C X
c,1
= exp(iθ2ZcY1) exp(iθ(cid:96)ZcY1Z3X4)ZcZ1Z3

(10)

5

we can again see that QY1 = −Y1Q, which en-
tails that exp(−iθ3Y1)Q exp(iθ3Y1) = Q exp(i2θ3Y1) =
Q exp(iθ2Y1).
the identity of
Fig. (3g). Applying this identity to Fig. (3f), yields the
ﬁnal representation of MEK(cid:96) as shown in Fig. (2e).

This demonstrates

VI. RESULTS

We postpone the technical details on noise analysis un-
til App. (B), and rather ﬁrst present results demonstrat-
ing the beneﬁts of MEK(cid:96). We remark that for simplicity
we assume that all noisy states are diagonal in the appro-
priate {|M(cid:96)(cid:105),| ¯M(cid:96)(cid:105)} basis, which allows direct comparison
with the DP(cid:96) results presented in Ref. [30]. The |M3(cid:105)
magic states can always be Cliﬀord twirled into this di-
agonal basis. More generally, we can encounter noisy ver-
sions of |M(cid:96)(cid:105) that are not diagonal in the {|M(cid:96)(cid:105),| ¯M(cid:96)(cid:105)} ba-
sis, nor can they be diagonalised by Cliﬀord twirling. For
clarity, we focus on diagonal noise and refer the reader to
App. A for a discussion of the subtleties of nondiagonal
noise.

A. Performance

The input resources each have some ﬁdelity and we use
(cid:96) and 3 to denote the input error rates of the noisy |M(cid:96)(cid:105)
and |M3(cid:105) states used. We use η to capture the combined
probability that the pivotal rotation leads to a Y error,
with η in turn being a function of the errors on the various
magic states used to implemented the pivotal rotation.
The output error from MEK(cid:96) is always measured as the
inﬁdelity on a single output qubit (ignoring correlations)
and we ﬁnd

δ(cid:96)(3, (cid:96), η(cid:96)−1) ∼ 82

3 + 2

(cid:96) +

1
4

η(cid:96)−1 + . . . ,

Psuc(3, (cid:96), η(cid:96)−1) ∼ 1 − 83 − 2(cid:96) −

1
2

η(cid:96)−1 + . . . .

(11)

(12)

In the App. C, we provide the full expressions as calcu-
lated by explicit simulation. For η = 0 and 3 = (cid:96), these
expressions are the same as those found by Meier, Eastin
and Knill in their analysis of MEK.

Within the context of a single distillation round the
performance is independent of the level (cid:96), and is solely
a function of the noise of the input states (cid:96), 3 and η.
When we ask how much the input states cost, we ﬁnd this
can increase with (cid:96). Next, we consider many distillation
rounds and combine all performance metrics into a single
quantity, the expected resource cost C(M(cid:96), δ) to distill
a |M(cid:96)(cid:105) state of inﬁdelity δ. Lower δ can require more
rounds of distillation, which drives up costs. For our
protocol we use that the cost is

where we have used C X for control-X gates and
their conjugation relations C X
c,1 = XcX1 and
C X
From this expression for Q

c,1XcC X

c,1 = ZcZ1.

c,1Z1C X

C(M(cid:96), δ(cid:96)) =

2C(M(cid:96), (cid:96)) + 8C(M3, 3) + C(R(cid:96)−1, η(cid:96)−1)

,

2Psuc(3, (cid:96), η(cid:96)−1)

(13)

6

FIG. 4. Comparison of the resource cost of distillation using MEK(cid:96) and DP(cid:96). (a) shows performance when 3 = , (cid:96) =  and
δ = 2. These are benchmarked against the standard MEK3 protocol (pink), where the curves for MEK(cid:96) (purple and dotted)
are barely distinguishable from MEK3, whereas DP(cid:96) (blue) performs much worse. The curves for DP(cid:96) are based on leading
order approximations [32]. (b) shows the full resource cost of MEK(cid:96) protocol (purple) and DP(cid:96) (blue) of distilling a |M(cid:96)(cid:105) state
of ﬁnal error of δ using resources with an initial error of 1%. Data for DP(cid:96) taken from Table 1 of Ref. [30]. Lines are ﬁtted
functions of the form C = a log(δ)b + c.

where δ(cid:96) obeys Eqs. (11) and (C1).
In our analysis,
we optimise the cost over many thousands of possible
combinations of input resources by brute force search.
Notice that we capture the cost of the pivotal rotation as
C(R(cid:96), η(cid:96)), which will in turn depend on the cost of magic
states used to implement the rotation as follows

C(R(cid:96), η(cid:96)) = C(M(cid:96), (cid:96)) +

1
2

C(R(cid:96)−1, η(cid:96)−1).

(14)

where

η(cid:96) =

1
2

(cid:96) +

1
2

((cid:96)(1 − η(cid:96)−1) + (1 − (cid:96))η(cid:96)−1).

(15)

For the lowest non-Cliﬀord levels, C(M3, δ3) are found
by minimising over diﬀerent combinations of protocols
including Bravyi-Haah [5], MEK3 [4] and using the 15
qubit Reed-Muller code [3]. Recall Cliﬀord operations
are considered free and perfect so that C(M2, 0) = 0 and
C(R2, 0) = 0. Throughout we assume that raw initial
non-Cliﬀord states can be prepared with a ﬁdelity that
is independent of (cid:96), and these have unit cost, so that
C(M(cid:96), raw) = 1. This last assumption is warranted in
light of the results of Li. [33].

B. Comparison with DP protocol

There are three aspects to the comparison: the num-
ber of resources require per attempt, the success prob-
ability and how the protocols suppress errors. Regard-
ing resources, each round of MEK(cid:96) uses 8 fewer |M3(cid:105)
states than a round of DP(cid:96). In Figs. (5a) and (5b) we

ﬁx (cid:96) = 3 =  and η(cid:96)−1 = 2 and compare the per-
formance of MEK(cid:96) and DP(cid:96), both benchmarked against
MEK3. We remark that η(cid:96)−1 must be set signiﬁcantly
lower than other errors as the protocol can not detect
noise in the pivotal rotation. In this context, MEK(cid:96) is
barely indistinguishable from MEK3. This is expected
as the protocols perform identically when δ(cid:96)−1 = 0, and
since δ(cid:96)−1 = 2 is very small we only observe a very slight
diﬀerence between MEK(cid:96) and MEK3. In contrast, DP(cid:96)
performs worse despite consuming more resources.

We also consider the full cost of performing many
rounds of MEK(cid:96) and DP(cid:96). Because the cost of the pivotal
rotation increases with (cid:96), we now see a variation in per-
formance with (cid:96). Our results are shown for (cid:96) = 4, 5, 6, 7
in Fig. (5c) and compare favourably against results re-
ported by Duclos-Cianci and Poulin. Roughly, we ob-
serve a factor 1/2 reduction in cost, providing a clear
cut case for using our compressed MEK(cid:96) protocol rather
than the original DP(cid:96) proposal. Given that all compo-
nent metrics (resources per round, failure probability and
error out) are very favourable towards MEK(cid:96), one may
have expected a more dramatic reduction in cost over
DP(cid:96). One explanation is that both MEK(cid:96) and DP(cid:96) re-
quire 1 very high ﬁdelity pivotal rotation, which is very
costly, and this shared cost limits the extent to which
MEK(cid:96) can outperform DP(cid:96).

Duclos-Cianci and Poulin discuss a potential improve-
ment to their scheme that uses larger code sizes. These
larger code blocks would encode, and hence distill, 2m
copies of |M(cid:96)(cid:105) and consume (8m + 8) copies of |M3(cid:105) and
m pivotal rotations. In the large m regime, the ratio of
input to output resources (the rate) becomes compara-

510152050010001500200051015205001000150020002500300051015201000200030004000510152010002000300040005000(cid:31)=4-log(δ)51015failure prob (%)ini(cid:31)al error(%) a0.20.40.60.81Single round performanceMul(cid:31)-round cost analysisb(cid:31)=5(cid:31)=7(cid:31)=6C(H(cid:31),η)CostC(H(cid:31),η)CostC(H(cid:31)=,η)CostC(H(cid:31),η)Cost-log(δ)-log(δ)-log(δ)0.20.40.60.810.050.10ini(cid:31)al error (%) 0.15error out (%) δ7

FIG. 5. Comparison of the resource cost of MEK(cid:96) versus using a gate synthesis (GS) protocol [11] combined with distillation
of |M3(cid:105) states. (a) shows cost C(|M(cid:96)(cid:105), δ)of preparing a magic state |M(cid:96)(cid:105) at inﬁdelity δ, against gate synthesis cost. (b) shows
cost C(R(cid:96), δ) of performing a non-Cliﬀord R(cid:96) at inﬁdelity δ, against gate synthesis cost. Both (a) and (b) use initial error rates
of  = 0.01 and  = 0.001

ble to MEK(cid:96). However, larger code blocks involve more
complex circuits and typically do not suppress noise as
eﬀectively. Furthermore, moving to large block codes
will substantially increase the failure probability, which
scales at least linearly with the block size. The exact
performance of this large block protocol is unclear and
DP presented a rough estimate based on leading order
approximations. For large block codes the number of
possible undetected errors of high weight can grow at
a combinatorial rate and so it is unclear how accurate
leading order approximations will be. In contrast, MEK(cid:96)
oﬀers the improved rate without any of these drawbacks
and MEK(cid:96) will also outperform the large block variant of
DP(cid:96). For a precise comparison, one must move beyond
leading order approximations and presently no such anal-
ysis is available for the large code variant of DP(cid:96).

C. Comparison with gate synthesis protocol

It was already seen by DP that distilling |M(cid:96)(cid:105) states
is a more eﬃcient route to implementing R(cid:96) gates than
using gate synthesis algorithms fuelled by |M3(cid:105) states.
To the authors knowledge, prior to this work, DP(cid:96) of-
fered the most cost eﬃcient route to quantum comput-
ing. Since MEK(cid:96) is more eﬃcient than DP(cid:96), it follows

that MEK(cid:96) provides an eﬃcient alternative to gate syn-
thesis.

Here, we present our own analysis of gate synthesis,
with Fig. 4 showing a comparison of MEK(cid:96) against a gate
synthesis approach. We present data points for combi-
nations of actual instances of gate synthesis (obtained
using the Gridsynth package [34]) and distillation pro-
tocols. Gridsynth provides a decomposition of diagonal
unitaries into T gates (Cliﬀord equivalent to R3) and
Cliﬀord gates. The software provides a T -count, which
we denote T(U, GS) to achieve a particular error rate
GS. The T -count assumes perfect |M3(cid:105) magic states are
available. Given noisy magic states the full cost is

CGS(R(cid:96), η(cid:96)) = T(R(cid:96), GS) · C(M3, 3)

where

η(cid:96) (cid:39) GS + T(R(cid:96), GS) · 3.

(16)

(17)

Notice that the gate synthesis has an inherent error GS
and will also fail if one of the T noisy states fail. See
App. A for a discussion of the subtleties due to diﬀerent
ways of measuring noise.

Exact analysis of gate synthesis results in a slight jitter
of data points for diﬀerent (cid:96), but for (cid:96) = 4, 5, 6 we see they
follow the same trend and are mostly (cid:96) independent. In
contrast, the resource cost of MEK(cid:96) increases with (cid:96). For

51020101001000104105-log(δ)15Key   MEK3   MEK4   MEK5   MEK6     MEK7     GS4   GS5   GS6    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++10100100010410551020-log(η)15Cost of state prepara(cid:31)onCost of gate implementa(cid:31)on=1%=1%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++10100100010410551020-log(η)15=0.1%=0.1%10100100010410551020-log(δ)15CostC(R(cid:31),δ)CostC(R(cid:31),δ)C(H(cid:31),η)CostC(H(cid:31),η)Costabvery large (cid:96), the distillation cost will decrease again as
the resource states become very close to stabiliser states
that are free in the magic state model (see Ref. [30]). For
a fair comparison to gate synthesis, we must benchmark
the noise of using MEK(cid:96) distilled states to implement a
R(cid:96) gate, which is C(R(cid:96), η(cid:96)) in our notation and shown in
Fig. (4b). For completeness, we also report the cost of
magic state preparation C(M(cid:96), (cid:96)), though remark that
this diﬀers only very slightly from gate implementation
cost.

We consider the cases of raw error rates of raw = 0.01
and raw = 0.001. The case of higher raw noise is
an important benchmark as it has been widely stud-
ied [4, 5, 30], and here we see improvements over gate
synthesis. For instance, at δ = 10−15 we ﬁnd gate synthe-
sis is ∼ 38 times more costly than MEK6. However, the
lower raw noise regime raw = 0.001 is in many ways more
interesting. In this regime, the advantage of using MEK(cid:96)
not only remains but is further improved by a slight mar-
gin. For instance, at target error rate δ = 10−15 we ﬁnd
gate synthesis is ∼ 42 times more costly than MEK6,
which is a larger factor than in the high noise regime.
This widening gap between gate synthesis and MEK(cid:96) is
seen for all (cid:96) and δ. This increase in gap is intuitive be-
cause the distillation cost drops dramatically with raw.
In contrast, the cost of gate synthesis is a combined cost
of the T -count and distillation cost of |M3(cid:105) states. While
lowering raw will reduce the distillation cost, the T -count
of gate synthesis is independent of raw and so overall gate
synthesis beneﬁts less in the low noise regime. While the
high noise regime is more widely studied, we next ar-
gue that the lower noise regime is also more realistic.
Underneath magic state factories is a layer of quantum
error correction. The highest known thresholds for error
correction are ∼ 1% for the toric code [15, 17–19] and
∼ 3% for Knill’s model of postselected quantum compu-
tation [35]. To prevent astronomical overheads, physical
gates must be comfortably below the threshold, and so we
assume all physical gates have inﬁdelities well below 1%.
Because preparing raw magic states will involve several
physical gates, it has often been assumed that raw will be
higher than the physical gate error rate, maybe even an
order of magnitude higher. However, Li [33] has shown
that we can probabilistically prepare raw magic states
at inﬁdelities of about half the physical control-X gate
error, assuming control-X failure is the dominant noise
mechanism. We remind the reader that we assume logi-
cal level control-X gates are ideal, but beneath the hood
of error correction we have very noisy physical control-X
gates. All this indicates that raw = 0.001 is a feasible
regime, more plausible than raw = 0.01, and is a regime
where MEK(cid:96) excels.

VII. CONCLUSIONS

We have laid out plans for distilling magic states pro-
viding small angle rotations at a cheaper cost than the

8

previous proposal of Duclos-Cianci and Poulin. The cost,
as measured by number of raw magic states used,
is
signiﬁcantly less than best current gate synthesis tech-
niques. In one regime of practical interest, we saw our
protocol operates 40 times better than gate synthesis.
Assessing this improvement, a factor 20 can be attributed
to the innovations of Duclos-Cianci and Poulin, with our
compression of the protocol providing the additional fac-
tor 2. Open questions include how such methods might
be extended to create savings for multi-qubit gates. We
have discussed one measure of cost, which could be ex-
tended to also investigate cost of Cliﬀord gates. The
ﬁelds of magic state distillation and gate synthesis have
rapidly evolved in the last several years, giving good rea-
son to be hopeful that advancement in these areas will
continue to bring quantum computation ever closer to
reality.

VIII. ACKNOWLEDGEMENTS

This work was supported by the EPSRC (grant
EP/M024261/1). We thank Bryan Eastin and Adam
Meier for assistance with reproducing the simulation of
MEK. We thank Guillaume Duclos-Cianci and Mark
Howard for comments on the manuscript. Gate syn-
thesis calculations used the Gridsynth package, and we
thank Peter Selinger for writing this software and mak-
ing it available. We thank the developers of the Qcircuit
package used in generation of ﬁgures. All our analysis
is available in the Supplementary material [36] as the
Mathematica source ﬁles and also in pdf format.

Appendix A: Diﬀerent types of noise

We have assumed that all noisy magic states are di-
agonal in the |M(cid:96)(cid:105) and | ¯M(cid:96)(cid:105) basis.
If the noise is not
diagonal, one can instead measure the noise as the Schat-
ten 1-norm distance of the density matrix ρ relative to
|M(cid:96)(cid:105)(cid:104)M(cid:96)| state. Whenever state injection is performed
using states with diagonal noise, we have a noise rotation
that is a mixture of a perfect unitary and the unitary fol-
lowed by an unwanted Y rotation. We say such a unitary
has diagonal noise. Similarly, the noise of non-diagonal
unitaries can be quantiﬁed, for instance in terms of the
diamond norm distance to the ideal unitary. These norm
measures enable one to show that the protocol outputs
states where the error is quadratically suppressed. Such
an analysis provides loose inequalities, but otherwise look
similar to Eqs. C1. We omit this analysis as it is consid-
erably involved, does not alter the main conclusions and
distracts from the salient features of our protocol.

Another subtlety is that the gate-synthesis algorithm
measures the noise in terms of the 2-norm distance of the
unitary. If the unitary is diagonal, then the inﬁdelity is no
greater than √2 higher than the 2-norm measure of noise.
In short, the analysis in the paper may very slightly over

9

FIG. 6. Propagation noise terms around distillation circuit.

estimate the performance of gate synthesis, but a factor
of √2 is insigniﬁcant compared to the diﬀerence between
gate synthesis and MEK(cid:96).

y = 1. This yields Fig. (6c).

Next, we pull the Y noise backwards through the en-
coder E. We already know how E acts on Pauli operators
from which we conclude that the inverse action satisﬁes

Appendix B: Noise analysis

This section shows how the circuit operates when the
non-Cliﬀord gates (R3 and R(cid:96)−1) are noisy due to im-
perfect magic states. When a R(cid:96) gate fails due to noise,
it is followed by an additional Y rotation. There are 8
locations that errors can occur on R3 gates and we de-
ﬁne a binary vector x = (x1, x2, x3, x4, x5, x6, x7, x8) that
records whether a Y error occurs at a particular R3 gate.
We use the binary variable y = 0, 1 to track an error in
the pivotal rotation R(cid:96)−1. When the R(cid:96)−1 gate fails, we
have a rotation H(cid:96)(iY ) rather than H(cid:96). Notice the com-
plex phase i, which makes no physical diﬀerence to the
unitary. However, aspects of the proof rely on H(cid:96) being
Hermitian, and the additional phase keeps it Hermitian.
The resulting random circuit is shown in Fig. (6a).

We pull some Y noise operators through the control
phase gates, which can cause Z noise on the control as
shown in Fig. (6b). The central portion of the circuit now
contains no noise terms (except y) and so we can replace
it with a logical control (H(cid:96) ⊗ H(cid:96)) or its equivalent when

E† :Y3 → Y1X2Z3Z4,
E† :Y4 → Y1X2X3X4.

Similarly random unitaries Y α

3 Y β

4 map as

E† :Y α

3 Y β

4 → Y α+β

1 X α+β

2

(Z α

3 X β

3 )(Z α

4 X β
4 )

(B1)

(B2)

(B3)

Applying this rule to our circuit yields Fig. (6d).

From Fig. (6d), we see that to obtain the correct mea-

surement outcome on qubit 1 or 2 requires that

|x| := x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 = 0 (mod 2),
(B4)
which detects any single error on the R3 gates. This
shows that the error correction properties of our original
circuit have survived the compression.

From this circuit we can get some intuition for the
leading order error terms presented in Eqs. 11. First
consider the failure probability, Pfail = 1 − Psuc.
If
|x| := x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 = 1 (mod 2),
then we detect an error and have a failure. The leading
order contribution is single error processes, and there are

abc|+(cid:30)••|+(cid:30)|0(cid:30)ER2E†ER2E†|0(cid:30)|0(cid:30)|0(cid:30)Yx1R3Yx3R†3Yx5R3Yx7R†3Yx2R3Yx4R†3H(cid:30)(iY)yYx6R3Yx8R†3|+(cid:30)••Zx3+x4+x5+x6|+(cid:30)|0(cid:30)ER2E†ER2E†|0(cid:30)|0(cid:30)|0(cid:30)Y(x1+x3)R3R†3R3Y(x5+x6)R†3Y(x2+x4)R3R†3H(cid:30)(iY)yR3Y(x6+x8)R†3|+(cid:30)•Zx3+x4+x5+x6|+(cid:30)|0(cid:30)EE†EE†|0(cid:30)|0(cid:30)|0(cid:30)Y(x1+x3)H(cid:30)(iY)yY(x5+x6)Y(x2+x4)H(cid:30)(iY)yH(cid:30)(iY)yY(x6+xj)|+(cid:30)•Zx3+x4+x5+x6|+(cid:30)|0(cid:30)Yx1+x2+x3+x4+x5+x6+x7+x8|0(cid:30)|0(cid:30)Xx1+x2+x3+x4+x5+x6+x7+x8|0(cid:30)X(x1+x3)Z(x2+x4)H(cid:30)(iY)yX(x5+x7)Z(x6+x8)X(x1+x3)Z(x2+x4)H(cid:30)(iY)yH(cid:30)(iY)yX(x5+x7)Z(x6+x8)d8 such errors, so this contributes 83 to Pfail. Otherwise,
if x = (0, 0, . . . 0) and the pivotal rotation also works,
then we perform a perfect projection onto the +H(cid:96) ⊗ H(cid:96)
subspace. This projection detects an errors, and the pro-
tocol declares failure if one of the two noisy |M(cid:96)(cid:105) states
is faulty, which occurs with probability 2(cid:96). Lastly, we
consider if everything works except the pivotal rotation.
The pivotal rotation fails with probability η(cid:96)−1, but not
all this contributes to the failure probability. When the
pivotal rotation fails, and the rest of the circuit works
correctly, it results in the operation shown in Fig. (2c),
but with the replacement H(cid:96) → iH(cid:96)Y . Algebraically,
this operation is

V =

1
2
= −i
2

[1l + (iH(cid:96)Y ) ⊗ (iH(cid:96)Y )] [(iH(cid:96)Y ) ⊗ 1l)]
[(Y H(cid:96)) ⊗ 1l + 1l ⊗ (Y H(cid:96))]

(B5)

Applying this channel to |M(cid:96)(cid:105)|M(cid:96)(cid:105), and noting that
Y |M(cid:96)(cid:105) = | ¯M(cid:96)(cid:105), we have
|ψ(cid:105) = V |M(cid:96)(cid:105)|M(cid:96)(cid:105) = −i

(| ¯M(cid:96)(cid:105)|M(cid:96)(cid:105) + |M(cid:96)(cid:105)| ¯M(cid:96)(cid:105))

(B6)

2

Therefore,
the probability of an even parity mea-
surement, combined with pivotal rotation failure,
is
η(cid:96)−1(cid:104)ψ|ψ(cid:105). Recalling, (cid:104)M(cid:96)| ¯M(cid:96)(cid:105) = 0, we ﬁnd (cid:104)ψ|ψ(cid:105) = 1/2.
Therefore, the failure probability gains a contribution of
1
2 η(cid:96)−1. This covers all the leading order processes that
contribute to a detected failure.
Next we consider leading order processes that go un-
detected, but output an erroneous state | ¯M(cid:96)(cid:105). The pro-
tocol outputs a two qubit state, and we trace out the sec-
ond qubit and evaluate the error rate on the ﬁrst qubit.
Switching the ﬁrst and second output qubit will yield
the same result. First we consider pairs of errors in the
R3 gates. There are 28 such pairs, all satisfying |x| = 0
(mod 2). However, the parity measurement must yield
the correct outcome also. Since we are only considering
leading order errors, we can assume the noisy |M(cid:96)(cid:105) states
are error free. Therefore, to obtain the |+(cid:105) on the control

10

ancilla, there cannot be a Z ﬂip on the control, and so
x3 + x4 + x5 + x6 = 0 (mod 2). This cuts the number
of undetected error pairs down to 14. Not all undetected
error pairs lead to a logical error on the ﬁrst qubit. For
x1 = x2 = 1 and x7 = x8 = 1 we see that there is a logi-
cal Y ⊗ Y error, and so both these processes contribute.
For the other 12 undetected errors, the parity projection
becomes deformed so that it projects onto a state that on
average has 1/2 overlap with |M(cid:96)(cid:105). Let us expand on this
notion of a deformed parity projection by considering the
case x1 = x5 = 1, with other combinations proving simi-
lar. This causes an X ⊗ X rotation both before and after
the parity projection, so that instead of projecting onto
H(cid:96) ⊗ H(cid:96) we project onto H⊥(cid:96) ⊗ H⊥(cid:96) where H⊥(cid:96)
:= XH(cid:96)X,
which we call a deformed projection. How much this par-
ticular process contributes varies with θ(cid:96), but a lengthily
evaluation over all such error pairs shows the average con-
tribution is 1/2. This totals the error contribution from
failed R3 gates to (2 + 12
3. If the R3 gates do
not fail, but instead we have a perfect parity projection,
then a logical error occurs if the projection is applied to
| ¯M(cid:96)(cid:105)| ¯M(cid:96)(cid:105), which occurs with probability 2
(cid:96) . Lastly, we
contemplate when the pivotal rotation cairres an error.
We see from Eqn. (B6) that |(cid:104) ¯M(cid:96), M(cid:96)|ψ(cid:105)| = 1/4 and so
the this leads to a logical error with probability 1
4 δ(cid:96)−1.
We remark again that the leading order contribute here
is linear, and not quadratically suppressed, and so the
pivotal rotation must be high ﬁdelity to enable distilla-
tion.

3 = 82

2 )2

Appendix C: Simulation results

Using Mathematica, we symbolically simulate the cir-
cuit in Fig. (6d). Full details are available in the Supple-
mentary material (see MEKL simulation.nb).

We ﬁnd the output states are again diagonal in the
{|M(cid:96)(cid:105),| ¯M(cid:96)(cid:105)} basis. The main text quoted the leading
order error and success probability as Eqs. (11), and use
we present the exact results here

Psucδ(cid:96) =82

3 − 483
(cid:96) + 8η(cid:96)−132

3 + 1364
3 − 8η(cid:96)−13
3 + 2246
3
32
32
32
32
(cid:96) + 242
(cid:96) − 24η(cid:96)−12
(cid:96) − 323
(cid:96) + 32η(cid:96)−13
(cid:96)

3 + 4η(cid:96)−14

3 − 2245

1
4

η(cid:96)−1 + −2η(cid:96)−13 + 6η(cid:96)−12
3 + 2
(cid:96) +
(cid:96) − η(cid:96)−12
3 + 328
− 1287
(cid:96) − 832
3 + 2
32
(cid:96) − 16η(cid:96)−14
32
+ 164
(cid:96) ,
3 + 2567
3 − 648
3 − 4486
3(2 − (cid:96) + 2

3(9 − (cid:96) + 2

(cid:96) ) − 324

+ 643

Psuc =4485

3 + 1/2η(cid:96)−1(1 − 23)4(1 − 2(cid:96))2 + 2(cid:96) − 22

(cid:96)

(cid:96) ) + 83(1 − 2(cid:96) + 22

(cid:96) ) − 82

3(5 − 6(cid:96) + 62
(cid:96) ).

(C1)

(C2)

[1] B. Eastin and E. Knill, Phys. Rev. Lett. 102, 110502

[2] A. Y. Kitaev, A. Shen, and M. N. Vyalyi, Classical and

(2009).

11

quantum computation, Vol. 47 (American Mathematical
Society Providence, 2002).

[3] S. Bravyi and A. Kitaev, Phys. Rev. A 71, 022316 (2005).
[4] A. M. Meier, B. Eastin, and E. Knill, Quant. Inf. and

Comp. 13, 195 (2013).

[5] S. Bravyi and J. Haah, Phys. Rev. A 86, 052329 (2012).
[6] C. Jones, Phys. Rev. A 87, 042305 (2013).
[7] A. G. Fowler, S. J. Devitt, and C. Jones, Scientiﬁc re-

ports 3, 1939 (2013).

190504 (2007).

[19] A. G. Fowler, A. C. Whiteside, A. L. McInnes,
A. Rabbani, Physical Review X 2, 041003 (2012).

and

[20] H. Anwar, E. T. Campbell,

and D. E. Browne, New

Journal of Physics 14, 063006 (2012).

[21] E. T. Campbell, H. Anwar, and D. E. Browne, Phys.

Rev. X 2, 041021 (2012).

[22] E. T. Campbell, Phys. Rev. Lett. 113, 230501 (2014).
[23] H. Dawkins and M. Howard, Physical review letters 115,

[8] V. Kliuchnikov, D. Maslov, and M. Mosca, Physical re-

030501 (2015).

view letters 110, 190502 (2013).

[24] A.

J. Landahl

and C. Cesare,

arXiv preprint

[9] A. Paetznick and K. M. Svore, Quantum Information &

arXiv:1302.3240 (2013).

Computation 14, 1277 (2014).

[10] D. Gosset, V. Kliuchnikov, M. Mosca, and V. Russo,
Quantum Information & Computation 14, 1261 (2014).
preprint

J. Ross

Selinger,

and P.

[11] N.

arXiv

arXiv:1403.2975 (2014).

[12] M. Amy and M. Mosca, arXiv preprint arXiv:1601.07363

(2016).

[25] D. Gottesman and I. L. Chuang, Nature 402, 390 (1999).
[26] C. J. Trout and K. R. Brown, International Journal of

Quantum Chemistry 115, 1296 (2015).

[27] C. Jones, Physical Review A 87, 022328 (2013).
[28] B. Eastin, Physical Review A 87, 032321 (2013).
[29] A. Paetznick and B. W. Reichardt, Phys. Rev. Lett. 111,

090505 (2013).

[13] J. T. Anderson, G. Duclos-Cianci, and D. Poulin, Phys.

[30] G. Duclos-Cianci and D. Poulin, Phys. Rev. A 91, 042315

Rev. Lett. 113, 080501 (2014).

(2015).

[14] H. Bombin, R. W. Chhajlany, M. Horodecki, and M. A.
Martin-Delgado, New Journal of Physics 15, 055023
(2013).

[15] R. Raussendorf, J. Harrington, and K. Goyal, New Jour-

nal of Physics 9, 199 (2007), quant-ph/0703143.

[16] B. J. Brown, N. H. Nickerson, and D. E. Browne, arXiv

preprint arXiv:1503.08217 (2015).

[31] D. Gottesman and I. Chuang, Nature 402, 390 (1999).
[32] Duclos-Cianci, private communication.
[33] Y. Li, New Journal of Physics 17, 023037 (2015).
[34] The
available
http://www.mathstat.dal.ca/∼selinger/newsynth/.

Gridsynth

package

is

at

[35] E. Knill, Nature 434, 39 (2005).
[36] https://earltcampbell.files.wordpress.com/2016/

[17] C. Wang, J. Harrington,

and J. Preskill, Annals of

03/supplementarymaterial.zip.

Physics 303, 31 (2003).

[18] R. Raussendorf and J. Harrington, Phys. Rev. Lett. 98,

