Nominal Automata with Name Binding

Lutz Schröder1, Dexter Kozen2, Stefan Milius1, and Thorsten Wißmann1

Friedrich-Alexander-Universität Erlangen-Nürnberg

1
2 Cornell University

Abstract

Automata models for data languages (i.e. languages over inﬁnite alphabets) often feature either global or
local freshness operators. We show that Bollig et al.’s session automata, which focus on global freshness,
are equivalent to regular nondeterministic nominal automata (RNNA), a natural nominal automaton model
with explicit name binding that has appeared implicitly in the semantics of nominal Kleene algebra (NKA),
an extension of Kleene algebra with name binding. The expected Kleene theorem for NKA is known to
fail in one direction, i.e. there are nominal languages that can be accepted by an RNNA but are not
deﬁnable in NKA; via session automata, we obtain a full Kleene theorem for RNNAs for an expression
language that extends NKA with unscoped name binding. Based on the equivalence with RNNAs, we
then slightly rephrase the known equivalence checking algorithm for session automata. Reinterpreting
the data language semantics of name binding by unrestricted instead of clean α-equivalence, we obtain a
local freshness semantics as a quotient of the global freshness semantics. Under local freshness semantics,
RNNAs turn out to be equivalent to a natural subclass of Bojanczyk et al.’s nondeterministic orbit-ﬁnite
automata. We establish decidability of inclusion under local freshness by modifying the RNNA-based
algorithm; in summary, we obtain a formalism for local freshness in data languages that is reasonably
expressive and has a decidable inclusion problem.

1998 ACM Subject Classiﬁcation F.1.1 Models of Computation, F.4.3 Formal Languages

Keywords and phrases Nominal sets, automata, data languages, name binding

1

Introduction

Data languages are languages over inﬁnite alphabets, regarded as modeling the communication
of values from inﬁnite data types such as nonces [17], channel names [11], process identiﬁers [4],
URL’s [1], or data values in XML documents (see [21] for a summary). There is by now a plethora of
automata models for data languages, which can be classiﬁed along several axes. One line of division
in terms of presentation is between models that use explicit registers, thus have a ﬁnite-state descrip-
tion (generating inﬁnite conﬁguration spaces) on the one hand, and more abstract models phrased
as automata over nominal sets [22] on the other hand. The latter have inﬁnitely many states but are
typically required to be orbit-ﬁnite, i.e. there are only ﬁnitely many distinct states up to renaming
implicitly stored letters. There are known correspondences between the two styles; e.g. Bojanczyk
et al.’s nondeterministic orbit-ﬁnite automata (NOFA) [3] are equivalent to Kaminski and Francez’
ﬁnite memory automata (FMA) [12] (also called register automata), or more precisely to their ex-
tension with nondeterministic reassignment [14]. A second distinction concerns the semantics of
constructs for reading “fresh” names: global freshness requires that the next letter to be consumed
has not been seen before, while local freshness postulates only that the next letter is distinct from
the (boundedly many) letters currently stored in the registers.

Although local freshness looks computationally more natural, nondeterministic automata models
(typically more expressive than deterministic ones [15]) featuring local freshness tend to have unde-
cidable inclusion problems. This includes FMAs and NOFAs [21, 3] (unless the putatively larger
FMA has at most two registers [12]) as well as variable automata [10]. Finite-state uniﬁcation-based
automata (FSUBAs) [13] have a decidable inclusion problem but do not support freshness other than

6
1
0
2

 
r
a

M
4

 

 
 
]
L
F
.
s
c
[
 
 

1
v
5
5
4
1
0

.

3
0
6
1
:
v
i
X
r
a

2

Nominal Automata with Name Binding

in the sense of distinctness from a ﬁxed ﬁnite set Θ of read-only symbols. Contrastingly, session
automata, which give up local freshness in favor of global freshness, have a decidable inclusion
problem [4].

Another formalism for global freshness is nominal Kleene algebra (NKA) [8]. It has been shown
that a slight variant of the original NKA semantics satisﬁes one half of a Kleene theorem [15], which
states that NKA expressions can be converted into a species of nondeterministic nominal automata
with explicit name binding transitions (the exact deﬁnition of these automata being left implicit in
op. cit.); the converse direction of the Kleene theorem fails even for deterministic nominal automata.
In the present work, we give an explicit deﬁnition of a nondeterministic nominal automaton
model with name binding that we call regular nondeterministic nominal automata (RNNA). The key
point in the deﬁnition is to impose ﬁnite branching modulo α-equivalence of transitions: a state in an
RNNA with (orbit-ﬁnite) state set Q has a ﬁnite set of transitions that are either free, i.e. elements of
A × Q where A is the inﬁnite alphabet of names, or bound, i.e. elements haiq ∈ [A]Q where [A](−)
denotes the abstraction functor [22] and haiq is read as “bind the name a in q,” taken modulo α-
equivalence. We show ﬁrst that RNNAs are equivalent to a mild generalization of session automata
that we call nondeterministic ﬁnite bar automata (bar NFAs). Immediate consequences are

a full Kleene theorem for RNNAs and a language of regular expressions with unscoped name
binding called regular bar expressions;
a translation of NKA into regular bar expressions, hence, for closed expressions, into session
automata;
decidability in parametrized PSPACE of inclusion for RNNAs, implying the known EXPSPACE
decidability result for NKA [15].

We then go on to modify the semantics of RNNAs: as for NKA [15], their semantics is most naturally
given in terms of strings with name binding, which can be converted into an essentially equivalent
data language by α-renaming bound variables in all possible ways to be mutually distinct, then
removing all binders. By giving up the distinctness requirement, which enforces global freshness,
we obtain a semantics that is essentially a restricted form of local freshness: Following the usual
rules of α-equivalence, a bound name can now stand for any name except those previously bound
names that still appear later in the word. We thus obtain a local freshness semantics as a quotient of
global freshness.

We show that under local freshness, RNNAs correspond to a natural subclass of NOFAs (equiv-
alently, FMAs) deﬁned by excluding nondeterministic reassignment and by enforcing a policy of
name dropping, which in terms of registers can be phrased as “the automaton may keep a letter in
a register only if that letter is going to be used later” (much like teaching your ﬁve-year-old not to
monopolize toys that she does not actually want to play with). For example, one cannot accept the
language {ab | a 6= b} but one can accept {aba | a 6= b}. Unsurprisingly, RNNAs with local fresh-
ness semantics are strictly more expressive than FSUBAs (with empty Θ); the relationships of the
various models are summarized in Figure 1. We show that RNNAs nevertheless retain a decidable
inclusion problem, again in parametrized PSPACE, using an algorithm that we obtain by varying the
one for global freshness. We are not aware of any other nondeterministic automata model for local
freshness (with more than two registers) that has a decidable inclusion problem.

Further Related Work A Kleene theorem for deterministic nominal automata and an expression
language with explicit recursion is mentioned in the conclusion of [15]. Kurz et al. [18] introduce
regular expressions for languages over words with explicit scoped binding, which differ technically
from those used in the semantics of NKA and regular bar expressions in that they are taken only
modulo α-equivalence, not the other equations of NKA concerning the extension of the scope of
binders. They satisfy a Kleene theorem for a species of automata that incorporate an explicit bound
on the depth of nesting of bindings, rejecting words that exceed this depth.

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

3

Register based

Session
Automata

Finite Memory

Automata

(

FSUBA (Θ = ∅)

(

RNNAs
Global

Freshness

Local

Freshness

NOFAs

non-spontaneous

(

name-dropping,
non-spontaneous

Figure 1 Expressivity of selected data language formalisms (restricted to empty initial register assignment)

Surveys on automata for data languages can be found in [2, 10, 23]. Data languages are often
represented as products of a classical ﬁnite alphabet and an inﬁnite alphabet; for simplicity, we use
just the set of names as the alphabet (as for example in [21]). Our unscoped name binding construct
is, under local semantics, similar to the binders in regular expressions with memory as introduced by
Libkin et al., who also observe that while such binders have a more imperative than declarative ﬂavor,
they are necessary to obtain equivalence results with automata (in this case, register automata) [19].

2

Preliminaries

G-sets Recall that a group action of a group G on a set X is a map G × X → X, denoted by
juxtaposition or inﬁx ·, such that π(ρx) = (πρ)x and 1x = x for π, ρ ∈ G, x ∈ X. A G-set is
a set X equipped with an action of G. The orbit of x ∈ X is the set {πx | π ∈ G}. A function
f : X → Y between G-sets X, Y is equivariant if f (πx) = π(f x) for all π ∈ G, x ∈ X. Given a
G-set X, G acts on subsets A ⊆ X by πA = {πx | x ∈ A}. For A ⊆ X and x ∈ X, we put

ﬁx x = {π ∈ G | πx = x}

and

Fix A =Tx∈A ﬁx x.

Note that elements of ﬁx A and Fix A ﬁx A setwise and pointwise, respectively.

Nominal sets Fix a countably inﬁnite set A of names. We ﬁx G to be the group of ﬁnite permu-
tations on A. Putting πa = π(a) makes A into a G-set. Given a G-set X and x ∈ X, a set A ⊆ A
supports x if Fix A ⊆ ﬁx x, and x ∈ X has ﬁnite support if some ﬁnite A ⊆ A supports x. In this
case, there is a smallest set supporting x, denoted supp(x). For a ∈ A, we say that a is fresh for x
and write a # x if a /∈ supp(x). A nominal set is a G-set all whose elements have ﬁnite support.
For every equivariant function f between nominal sets, we have supp(f x) ⊆ supp(x). The function
supp itself is equivariant, i.e. supp(πx) = π(supp(x)) for π ∈ G. It follows that if x1, x2 are in
the same orbit of a nominal set, then ♯supp(x1) = ♯supp(x2) (we use ♯ for cardinalities, avoiding
overuse of ‘|’). A subset S ⊆ X is ﬁnitely supported (fs) if S has ﬁnite support with respect to the
above-mentioned action of G on subsets; equivariant if πx ∈ S for all π ∈ G and x ∈ S (which

implies supp(S) = ∅); and uniformly ﬁnitely supported (ufs) ifSx∈S supp(x) is ﬁnite [26].
◮ Lemma 2.1 ([7], Theorem 2.29). If S is ufs, then supp(S) =Sx∈S supp(x).

For a nominal set X, we denote by Pfs(X) and Pufs(X) the sets of fs and ufs subsets of X, respec-
tively. Note that any ufs set is fs but not conversely; e.g. the set A is fs but not ufs. Moreoever, any
ﬁnite subset of X is ufs but not conversely; e.g. the set of words an for ﬁxed a ∈ A is ufs but not
ﬁnite. A nominal set X is orbit-ﬁnite if the action of G on it has only ﬁnitely many orbits.

◮ Lemma 2.2. Ever ufs subset of an orbit-ﬁnite set Xis ﬁnite.

4

Nominal Automata with Name Binding

On the category Nom of nominal sets and equivariant maps, we have the abstraction functor [A](−)
deﬁned on objects by [A]X = (A × X)/∼, where the relation ∼ abstracts α-equivalence: (a, x) ∼
(b, y) iff (c a) · x = (c b) · y for any fresh c. We write haix for the ∼-equivalence class of (a, x).
Coalgebra An F -coalgebra (C, γ) for an endofunctor F : C → C on a category C consists of a
C-object C of states and a morphism γ : C → F C; here, we are interested in the case C = Nom.
A coalgebra morphism f : (C, γ) → (D, δ) is a morphism f : C → D such that F f γ = δf . An
F -coalgebra (C, γ) is ﬁnal if for each F -coalgebra (D, δ), there exists a unique coalgebra morphism
(D, δ) → (C, γ). A pointed coalgebra is a coalgebra with a distinguished initial state.

For example, F -coalgebras for the functor F X = A × X on Nom consist of equivariant maps
X → A (output) and X → X (next state), thus produce a stream of names at each state x; equiv-
ariance and the ﬁnite support of x imply that this stream has ﬁnite support, i.e. contains only ﬁnitely
many distinct names. Consequently, the ﬁnal F -coalgebra in this case is the set of ﬁnitely supported
streams over A.

3 Nominal Automata and Global Freshness

We next recall the basic deﬁnitions in the theory of nominal automata [3] (developed in op. cit. in
the setting of arbitrary symmetries and for general orbit-ﬁnite alphabets), and introduce our model
of regular nondeterministic nominal automata. Nondeterministic orbit-ﬁnite automata (NOFAs) are
succinctly deﬁned as orbit-ﬁnite coalgebras for the functor F on Nom given by

F X = 2 × Pfs(A × X)

(where 2 = {⊤, ⊥}), equipped with an equivariant subset of initial states. That is, a NOFA A
consists of an orbit-ﬁnite set Q of states, an equivariant set F ⊆ Q of ﬁnal states (those that map to
⊤ under the ﬁrst component of the F -coalgebra structure), and an equivariant transition relation → ⊆
Q × A × Q, where we write q a−→ p for (q, a, p) ∈ →. We refer to a NOFA whose transition relation
is deterministic as a DOFA. An A-language is a subset of A∗. The A-language L(A) accepted by A
is deﬁned in the standard way: First, we inductively extend the transition relation to words w ∈ A by
putting q ǫ−→ q, and q aw−−→ p whenever q a−→ q′ and q′ w−→ p for some state q′. Then, A accepts w ∈ A
if there exist an initial state q and a ﬁnal state p such that q w−→ p, and L(A) = {w | A accepts w}.

NOFAs are equivalent to ﬁnite-memory automata (FMA) with nondeterministic reassignment [3,
14]. These are roughly described as having a ﬁnite set of registers in which names from the current
word can be stored if they are locally fresh, i.e. not currently stored in any register; transitions are
labeled with register indices k, meaning that the transition accepts the next letter if it equals the
content of register k. In the equivalence with NOFAs, the names currently stored in the registers
correspond to the support of states. Summing up, NOFAs are an automata model for local freshness.
So far, transitions of a state in Q are elements of A×Q. Given the central role that the abstraction
functor [A](−) (Section 2) plays in nominal sets, it is natural to extend the model to allow bound
transitions also, i.e. elements of [A]Q, and indeed this is what happens in automata models for
nominal Kleene algebra [15]. We can combine this extension with a restriction on branching: while
it does not make much sense to restrict a NOFA to be ﬁnitely branching (this would imply that any
initial state could accept only words consisting of the names in its support, i.e. such a NOFA could
never read fresh names), it will turn out that ﬁnite branching is technically convenient and still retains
a reasonable level of expressivity in the presence of bound transitions.

◮ Deﬁnition 3.1. A regular nondeterministic nominal automaton (RNNA) is a pointed orbit-ﬁnite
coalgebra A = (Q, ξ : Q → N Q) for the functor N on Nom given by

N X = 2 × Pufs(A × X) × Pufs([A]X).

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

5

The degree deg(A) = max{♯supp(q) | q ∈ Q} of A is the maximum size of supports of states in A.

The functor N is a nondeterministic variant of the functor KX = 2 × X A × [A]X whose coalgebras
are deterministic nominal automata [15]. Explicitly, an RNNA can be described as a tuple A =
(Q, →, s, F ) consisting of

an orbit-ﬁnite set Q of states;
an equivariant subset → of Q × ¯A × Q, the transition relation, where ¯A = A ∪ { a | a ∈ A} and
we write q α−→ q′ for (q, α, q′) ∈ →; transitions of type q a−→ q′ are called free, and those of type
q a−→ q′ bound;
an equivariant subset F ⊆ Q of ﬁnal states; and
an initial state s ∈ Q.

These data are required to satisfy the following conditions:

The relation → is α-invariant, i.e. closed under α-equivalence of transitions, where transitions
q a−→ q′ and p b−→ p′ are α-equivalent if q = p and haiq′ = hbip′.
The relation → is ﬁnitely branching up to α-equivalence, i.e. for each state q the sets {(a, q′) |
q a−→ q′} and {haiq′ | q a−→ q′} are ﬁnite (equivalently ufs, by Lemma 2.2).

We proceed to deﬁne the language semantics of RNNAs.

◮ Deﬁnition 3.2. A bar string is a word over ¯A, i.e. an element of ¯A∗. The set ¯A∗ is made into
a nominal set by the letter-wise action of G. The free names occurring in a bar string w are those
names a that occur in w to the left of any occurrence of a. We write FN(w) for the set of free names
of w, and say that w is closed if FN(w) = ∅. We deﬁne α-equivalence ≡α on bar strings as the
equivalence (not: congruence) generated by w av ≡α w bu if haiw = hbiu (for w, v, w ∈ ¯A∗). We
write [w]α for the α-equivalence class of w. The set FN(w) is clearly invariant under α-equivalence,
so we have a well-deﬁned notion of free names of bar strings modulo ≡α. We say that a bar string
is clean if its bound variables are mutually distinct and distinct from all its free variables. Clearly,
every bar string is α-equivalent to a clean one. For a bar string w, we denote by ub(w) ∈ A∗ (for
unbind) the word arising from w by replacing all bound names a with the corresponding free name
a.

A literal language is a set of bar strings, and a bar language is an fs set of bar strings modulo

α-equivalence, i.e. an fs subset of

¯M := ¯A∗/≡α.

An RNNA A, with data as above, (literally) accepts a bar string w ∈ ¯A∗ if s w−→ q for some q ∈ F ,
where we extend the transition notation w−→ to bar strings in the usual way. The literal language
accepted by A is the set L0(A) of bar strings accepted by A, and the bar language accepted by A is
the quotient Lα(A) of L0(A) modulo α-equivalence.

◮ Remark 3.3. In dynamic sequences [9], there are two dynamically scoped constructs ha and
ai for dynamic allocation and deallocation, respectively, of a name a; in this notation, our a cor-
responds to haa. As we discuss later in this section, the bar language model is isomorphic to the
ν-string-based model of NKA [15]. In particular, the bar languages form the ﬁnal coalgebra for the
endofunctor KX = 2 × X A × [A]X on Nom for deterministic nominal automata mentioned before,
with free and bound transitions understood in the same way as for RNNA. (There is however an
expressivity gap between deterministic and nondeterministic nominal automata [15, Example 4.13]).
The ν-string-based model is equivalent to an alternative language mode AL [16], which essentially
implements global freshness. That is, AL is deﬁned on closed expressions in terms of A-languages,

6

Nominal Automata with Name Binding

with bound names required to be globally fresh, i.e. not previously seen in the current word. For-
mally, AL is given by applying to a bar language L the operator N given by

N (L) = {ub(w) | w clean, [w]α ∈ L} ⊆ A∗.

Summing up, under bar language semantics, RNNAs are a formalism for global freshness, so we
also refer to bar language semantics as global freshness semantics. Since RNNAs will turn out to be
essentially equivalent to session automata under this semantics, we defer examples to Section 4.

A key property of RNNAs is that supports of states evolve in the expected way along transitions
(cf. [15, Lemma 4.6] for the deterministic case):

◮ Lemma 3.4. Let A be an RNNA. Then the following hold.
1. If q a−→ q′ in A then supp(q′) ∪ {a} ⊆ supp(q).
2. If q a−→ q′ in A then supp(q′) ⊆ supp(q) ∪ {a}.
In fact, the properties in the lemma are clearly also sufﬁcient for ufs branching. From Lemma 3.4,
an easy induction shows that for any state q in an RNNA and any w ∈ L0(q), we have FN(w) ⊆
supp(q). Furthermore, we immediately have

◮ Corollary 3.5. Let A be a RNNA. Then Lα(A) is ufs; speciﬁcally, if s is the initial state of A
and w ∈ Lα(A), then supp(w) ⊆ supp(s).

We have an evident notion of α-equivalence of paths in RNNAs, deﬁned analogously as for bar
strings (see Remark A.5 in the appendix). Of course, α-equivalent paths always start in the same
state. The set of paths of an RNNA A is closed under α-equivalence (see Lemma A.15 in the
appendix). However, this does not in general imply that L0(A) is closed under α-equivalence; e.g.
for A being

s() a−→ t(a) b−→ u(a, b)

(1)

(with a, b ranging over distinct names in A), where s() is initial and the states u(−, −) are ﬁnal, we
have a b ∈ L0(A) but the α-equivalent a a is not in L0(A). Crucially, assuming closure of L0(A)
under α-equivalence is nevertheless without loss of generality, as we show next.

◮ Deﬁnition 3.6. An RNNA A is name-dropping if for every state q in A and every subset N ⊆
supp(q) there exists a state q|N in A that restricts q to N ; that is, supp(q|N ) = N , q|N is ﬁnal if q is
ﬁnal, and q|N has at least the same incoming transitions as q (i.e. for all states p in A, if p a−→ q then
p a−→ q|N and if p a−→ q then p a−→ q|N ), and as many of the outgoing transitions of q as possible;
a−→ q′ whenever q a−→ q′ and
i.e. q|N
supp(q′) ⊆ N ∪ {a}.

a−→ q′ whenever q a−→ q′ and supp(q′) ∪ {a} ⊆ N , and q|N

The counterexample shown in (1) fails to be name-dropping, as no state restricts q = u(a, b) to
N = {b}.

The following lemma shows that closure under α-equivalence is restored under name-dropping:

◮ Lemma 3.7. Let A be a name-dropping RNNA. Then L0(A) is closed under α-equivalence, i.e.
L0(A) = {w | [w]α ∈ Lα(A)}.

Finally, we can close a given RNNA under name dropping, preserving the bar language:

◮ Lemma 3.8. Given an RNNA of degree k with n orbits, there exists a bar language-equivalent
name-dropping RNNA of degree k with at most n2k orbits.

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

7

Proof (Sketch). From an RNNA A, construct a name-dropping RNNA with states of the form

q|N := Fix(N )q

where q is a state in A, N ⊆ supp(q), and Fix(N )q denotes the orbit of q under Fix(N ). The ﬁnal
states are the q|N with q ﬁnal in A, and the initial state is s|supp(s), where s is the initial state of A.
As transitions, we take

q|N

q|N

a−→ q′|N ′ whenever q a−→ q′, N ′ ⊆ N , and a ∈ N , and
a−→ q′|N ′ whenever q b−→ q′′, N ′′ ⊆ supp(q′′) ∩ (N ∪ {b}), and hai(q′|N ′) = hbi(q′′|N ′′ ).

One can show that this yields a name-dropping RNNA that is equivalent to A.

◭

◮ Example 3.9. Closing the RNNA from (1) under name dropping as per Lemma 3.8 yields
b−→ u(⊥, b); now,
additional states that we may denote u(⊥, b) (among others), with transitions t(a)
hbiu(⊥, b) = haiu(⊥, a), so a a is accepted.

Relation to Nominal Kleene Algebra We recall that expressions r, s of nominal Kleene alge-
bra (NKA) [8], brieﬂy NKA expressions, are deﬁned by the grammar

r, s ::= 0 | 1 | a | r + s | rs | r∗ | νa. r

(a ∈ A).

Kozen et al. [16, 15] give a semantics of NKA in terms of languages over words with binding, so
called ν-strings, which are either 1 or ν-regular expressions formed using only names a ∈ A, sequen-
tial composition, and name binding ν, taken modulo the laws of NKA [8], including α-equivalence
and laws for scope extension of binding. It is easy to see that the nominal set of ν-strings modulo
these laws is isomorphic to ¯M ; one converts bar strings into ν-strings by replacing any occurrence
of a with νa.a, with the scope of the binder extending to the end of the string. In this semantics,
a binder νa is just interpreted as itself, and all other clauses are standard. Kozen et al. show that
on closed expressions, their semantics is equivalent to the one originally deﬁned by Gabbay and
Ciancia [8].

◮ Remark 3.10. On open expressions, the semantics of [8] and [15, 16] differ. For purposes
of expressivity comparisons, we will generally restrict to closed expressions as well as “closed”
automata and languages in the sequel. For automata, this typically amounts to the initial register
assignment being empty, and for languages to being equivariant.

It has been shown by Kozen et al. [15] that a given NKA expression r can be translated into a
nondeterministic nominal automaton whose states are the so-called spines of r, which amounts to
one direction of a Kleene theorem. One can show that the spines in fact form an RNNA. The other
direction of the Kleene theorem is known to fail even for orbit-ﬁnite deterministic nominal automata,
i.e. RNNAs are strictly more expressive than NKA:

◮ Example 3.11. [15] It is easy to construct an orbit-ﬁnite deterministic nominal automaton (or
an RNNA, shown explicitly in Example 4.6) accepting the ν-language

{ǫ, νb.ba, νb.ba(νa.ab), νb.ba(νa.ab(νb.ba)), νb.ba(νa.ab(νb.ba(νa.ab))), . . . },

which requires unbounded nesting depth of ν, hence cannot be deﬁned in NKA.

8

Nominal Automata with Name Binding

4 Nondeterministic Finite Bar Automata

We next provide a ﬁnite representation of RNNAs by proving their equivalence with ordinary nonde-
terministic ﬁnite automata (NFAs) over ¯A. These are a mild generalization of session automata [4]
and are equivalent to the latter on closed languages (session automata accept only closed languages);
that is, on closed languages RNNA under global freshness semantics are equivalent to session au-
tomata.

◮ Deﬁnition 4.1. A nondeterministic ﬁnite bar automaton, or bar NFA for short, over A is an NFA
A over ¯A. We call transitions of type q a−→ q in A free transitions and transitions of type q
a−→ q
bound transitions. The literal language L0(A) of A is the language accepted by A qua NFA over ¯A.
The bar language Lα(A) ⊆ ¯M accepted by A is deﬁned as

Lα(A) = L0(A)/≡α.

Generally, we denote by L0(q) the ¯A-language accepted by the state q in A and by Lα(q) the quotient
of L0(q) by α-equivalence. The degree deg(A) of A is the number of names a ∈ A that occur in
transitions q a−→ q′ or q a−→ q′ in A.

Similarly, a regular bar expression is a regular expression r over ¯A; the literal language L0(r) ⊆
¯A∗ deﬁned by r is the language deﬁned by r qua regular expression, and the bar language deﬁned
by r is Lα(r) = L0(r)/≡α. The degree deg(r) of r is the number of free or bound names occurring
in r.

◮ Remark 4.2. Disregarding an additional ﬁnite component of the alphabet, a session automa-
ton [4] is essentially a bar NFA (where free names a are denoted as a↑, and bound names a as a⊛).
It deﬁnes an A-language and interprets bound transitions for a as binding a to some globally fresh
name. In the light of the equivalence of global freshness semantics and bar language semantics as
discussed in Section 3, session automata are thus essentially the same as bar NFAs; again, the only
difference concerns the treatment of open bar strings: While session automata explicitly reject bar
strings that fail to be closed (well-formed [4]), a bar NFA will happily accept open bar strings. Part
of the motivation for this permissiveness is that we now do not need to insist on regular bar expres-
sions to be closed; in particular, regular bar expressions are closed under subexpressions. Moreover,
standard regular expressions over A are now (open) regular bar expressions.

◮ Example 4.3. Phrased in terms of A-languages, bar NFAs, being equivalent to session automata,
can express the language “all letters are distinct” but not the universal language A∗.

◮ Construction 4.4. We construct an RNNA ¯A from a given bar NFA A with set Q of states. For
brevity, we already incorporate closure under name dropping as per Lemma 3.8. For a state q ∈ Q,
we put Nq = supp(Lα(q)). The set ¯Q of states of ¯A consists of pairs

(q, πFN )

(q ∈ Q, N ⊆ Nq)

where FN abbreviates Fix(N ) and πFN denotes a left coset. Note that left cosets for FN can be
identiﬁed with injective renamings N → A; intuitively, (q, πFN ) restricts q to N and renames N
according to π. (A slightly similar construction with explicit total injections has been used to con-
vert history-dependent automata into NOFAs [6]). We let G act on states by π1 · (q, π2FN ) =
(q, π1π2FN ). The initial state of ¯A is (s, FNs), where s is the initial state of A; a state (q, πFN ) is
ﬁnal in ¯A iff q is ﬁnal in A. Free transitions in ¯A are given by

(q, πFN )

π(a)
−−−→ (q′, πFN ′ ) whenever

q a−→ q′ and N ′ ∪ {a} ⊆ N

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

9

and bound transitions by

(q, πFN ) a−→ (q′, π′FN ′ ) whenever

q b−→ q′, N ′ ⊆ N ∪ {b}, haiπ′FN ′ = hπ(b)iπFN ′ .

◮ Theorem 4.5. ¯A is a name-dropping RNNA with at most |Q|2deg(A) orbits, deg( ¯A) = deg(A),
and Lα( ¯A) = Lα(A).
◮ Example 4.6. The language from Example 3.11 is equivalent to the bar language L =
{ǫ, ba, ba ab, ba ab ba, ba ab ba ab . . . }. Translating the closed bar language aL equivalently
into an A-language under global freshness, we obtain the language of odd-length words in A∗
with identical letters in positions 0 and 2, and with every letter in an odd position being globally
fresh and repeated three positions later. The language L is deﬁned by the regular bar expression
( ba ab)∗(1 + ba) and accepted by the bar NFA A with four states s, t, u, v, where s is initial and
s and u are ﬁnal, and transitions s b−→ t a−→ u a−→ v b−→ s. The above construction then produces
an RNNA that is similar to the one shown for this example in [15]: By the above description of left
cosets for FN , we annotate every state q with a list of ♯supp(Lα(q)) entries that are either (pairwise
distinct) names or ⊥, indicating that the corresponding name from supp(Lα(q)) has been dropped.
We can draw those orbits of the resulting RNNA that have the form (q, πNq), i.e. do not drop any
names, as

s(c)

b

b

t(c, b)
v(b, c)

c

c

u(b)

for b 6= c, with s(c), u(b) ﬁnal for all b, c ∈ A and s(c) initial.

Additional states and transitions then arise from name dropping; e.g. for t we have additional states
t(⊥, b), t(c, ⊥), and t(⊥, ⊥), all with a b-transition from s(c). The states t(⊥, ⊥) and t(⊥, b) have
no outgoing transitions, while t(c, ⊥) has a c-transition to u(⊥).

We next present the reverse construction, i.e. given an RNNA A we extract a bar NFA A0 (a subau-
tomaton of A) such that Lα(A0) = Lα(A).

Put k = deg(A). We ﬁx a set A0 ⊆ A of size ♯A0 = k such that supp(s) ⊆ A0 for the initial
state s of A, and a name ∗ ∈ A−A0. The states of A0 are those states q in A such that supp(q) ⊆ A0.
As this implies that the set Q0 of states in A0 is ufs, Q0 is ﬁnite by Lemma 2.2. Note that s ∈ Q0.
For q, q′ ∈ Q0, the free transitions q a−→ q′ in A0 are the same as in A (hence have a ∈ A0 by
Lemma 3.4.1). The bound transitions q a−→ q′ in A0 are those bound transitions q a−→ q′ in A such
that a ∈ A0 ∪ {∗}. A state is ﬁnal in A0 iff it is ﬁnal in A. The initial state of A0 is s.
◮ Theorem 4.7. The number of states in the bar NFA A0 is linear in the number of orbits of A
and exponential in deg(A). Moreover, deg(A0) ≤ deg(A) + 1, and Lα(A0) = Lα(A).
In combination with the previous construction, we obtain the announced equivalence result:
◮ Corollary 4.8. RNNAs are expressively equivalent to bar NFAs, hence to regular bar expressions.

This amounts to a Kleene theorem for RNNAs. In combination with the discussion in Section 3, this
shows that regular bar expressions are strictly more expressive than NKA. While it might seem that
we can now just give up nominal automata and use bar NFAs instead, it turns out that our decision
procedure for inclusion (Section 6) will actually use both concepts, essentially running a bar NFA in
synchrony with an RNNA.

5

Local Freshness

Recall that the global freshness semantics of RNNA is deﬁned by removing bars from the clean
representatives of the α-equivalence classes of bar strings in the bar language. Alternatively, we can
extract from a bar language L the A-language

10

Nominal Automata with Name Binding

D(L) = {ub(w) | [w]α ∈ L}.

That is, D(L) is obtained by taking all representatives of α-equivalence classes in L and removing
all bars. As we show below, RNNAs correspond to a class of NOFAs under the semantics D(Lα(·)),
which we therefore call the local freshness semantics. Note that local freshness is coarser than global
freshness; e.g., Lα( a b + aa) = {[ a b]α, [ aa]α} 6= {[ a b]α} = Lα( a b), but D(Lα( a b + aa)) =
A2 = D( a b). The semantics D(Lα(·)) enforces local freshness by blocking α-renamings of bound
names into names that have free occurrences later in the bar string. For example, {ab ∈ A2 | a 6= b}
cannot be accepted by an RNNA under local freshness semantics (e.g. the regular bar expression a b
deﬁnes D( a b) = A2, as a b ≡α a a). Contrastingly, the language {aba ∈ A3 | a 6= b} can be
accepted by an RNNA under local freshness semantics, being deﬁned by the regular bar expression
a ba.

◮ Example 5.1. Under D(Lα(·)), the regular expression a( ba ab)∗(1 + ba) (Example 4.6) de-
ﬁnes the A-language consisting of all odd-length words over A that contain the same letters in
positions 0 and 2 (if any) and repeat every letter in an odd position three positions later (if any) but
no earlier; that is, the bound names are interpreted as being locally fresh. The reason for this is that,
e.g., in the bar string a ba ab, α-renaming of the bound name b into a is blocked by the occurrence
of a after b; similarly, the second occurrence of a cannot be renamed into b.

Relationship to NOFAs To enable a comparison of RNNAs with NOFAs over A (Section 3),
we restrict our attention in the following discussion to RNNAs that are closed, i.e. whose initial state
has empty support, therefore accept equivariant A-languages. We can convert a closed RNNA A into
a NOFA D(A) accepting D(Lα(A)) by simply replacing every transition q a−→ q′ with a transition
q a−→ q′. We show that the image of this translation is a natural class of NOFAs:

◮ Deﬁnition 5.2. A NOFA A is non-spontaneous if supp(s) = ∅ for every initial state s, and

supp(q′) ⊆ supp(q) ∪ {a} whenever

q a−→ q′.

b−→ q′, b # q, and haiq′′ = hbiq′ (this condition
Moreover, A is α-invariant if q
is automatic if a # q). Finally, A is name-dropping if for each state q and each set N ⊆ supp(q) of
names, there exists a state q|N that restricts q to N , i.e. supp(q|N ) = N , q|N is ﬁnal if q is ﬁnal, and

a−→ q′′ whenever q

q|N has at least the same incoming transitions as q;
whenever q
whenever q a−→ q′, a # q, and supp(q′) ⊆ N ∪ {a}, then q|N

a−→ q′, a ∈ supp(q), and supp(q′) ∪ {a} ⊆ N , then q|N
a−→ q′.

a−→ q′;

In words, A is non-spontaneous if transitions q a−→ q′ in A create no new names other than a in q′.

◮ Proposition 5.3. A NOFA is of the form D(B) for some (name-dropping) RNNA B iff it is
(name-dropping and) non-spontaneous and α-invariant.

◮ Proposition 5.4. For every non-spontaneous and name-dropping NOFA, there is an equivalent
non-spontaneous, name-dropping, and α-invariant NOFA.

In combination with Lemma 3.7, these facts imply

◮ Corollary 5.5. Under local freshness semantics, RNNAs are expressively equivalent to non-
spontaneous name-dropping NOFAs.

◮ Corollary 5.6. The class of languages accepted by RNNAs under local freshness semantics is
closed under ﬁnite intersections.

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

11

Proof (Sketch). Non-spontaneous name-dropping NOFAs are closed under the standard product
construction.

◭

◮ Remark 5.7. Non-spontaneity is prevalent in automata models for data languages. Every DOFA
is non-spontaneous. Moreover, ﬁnite memory automata and register automata are morally non-
spontaneous according to their original deﬁnitions, i.e. they can read names from the current word
into the registers but cannot guess names nondeterministically [12, 21]; the variant of ﬁnite memory
automata that is proved equivalent to NOFAs in [3] in fact allows such nondeterministic reassign-
ment [14]. This makes unrestricted NOFAs strictly more expressive than non-spontaneous ones: the
language “the last letter has not been seen before” can be accepted by an unrestricted NOFA (by
guessing the last name at the beginning) but not by a non-spontaneous NOFA [12, 27].

Name-dropping restricts expressivity further, with the mentioned language {ab | a 6= b} be-
ing a separating example. In return, it buys decidability of inclusion (Section 6), while for non-
spontaneous NOFAs even universality is undecidable [3, 21]. DOFAs are incomparable to RNNAs
under local freshness semantics—the language “the last letter has been seen before” is deﬁned by
the regular bar expression ( b)∗ a( b)∗a but not accepted by any DOFA.

Relationship to FSUBAs We now compare RNNAs to ﬁnite-state uniﬁcation-based automata
(FSUBAs) [13, 25]. A particular feature of FSUBAs is that they distinguish a ﬁnite subset Θ of the
alphabet that is read-only, i.e. cannot be written into the registers. We have no corresponding feature,
therefore restrict to Θ = ∅ in the following discussion. An FSUBA then consists of ﬁnite sets Q and
r of states and registers, respectively, a transition relation µ ⊆ Q × r × Pω(r) × Q, an initial state
q0 ∈ Q, a set F ⊆ Q of ﬁnal states, and an initial register assignment u. Register assignments are
partial maps v : r ⇀ A, which means a register k ∈ r can be empty (v(k) = ⊥) or hold a name
from A. An FSUBA conﬁguration is a pair (q, v), where q ∈ Q and v is a register assignment. The
initial conﬁguration is (q0, u). A transition (q, k, S, p) ∈ µ applies to a conﬁguration with state q for
an input symbol a ∈ A if register k is empty or holds a; the resulting conﬁguration has state p, with
the input a ﬁrst written into register k and the register contents from S cleared afterwards. A word
is accepted if there is a sequence of transitions from (q0, u) to a conﬁguration with a ﬁnal state.

As the name uniﬁcation-based suggests, FSUBAs can check equality of input symbols, but not
inequality (except with respect to the read-only letters); in other words, they have no notion of fresh-
ness. Thus the above-mentioned language {aba | a 6= b} cannot be accepted by an FSUBA [13].

The conﬁgurations of an FSUBA A are a nominal set C under the group action π · (q, v) =
(q, π · v). We show in the appendix that one can equip C with the structure of an RNNA that
accepts the same A-language as A under local freshness semantics; that is, RNNAs are strictly more
expressive than FSUBAs with empty read-only alphabet.

6 Deciding Inclusion under Global and Local Freshness

We next show that under both global and local freshness, the inclusion problem for regular bar
expressions (equivalently bar NFAs) is in EXPSPACE. In view of Remark 4.2, for global freshness,
this just reproves the known decidability of inclusion for session automata [4] in a marginally more
general setting (the complexity bound is not stated in [4] but can be extracted from the decidability
proof), while the result for local freshness appears to be new. Our algorithm is mildly different from
the one suggested in [4] in that it exploits name dropping; we describe it explicitly, as we will modify
it for local freshness.

◮ Theorem 6.1. The inclusion problem for bar NFAs (or regular bar expressions) is in EXPSPACE;
more precisely, the inclusion Lα(A1) ⊆ Lα(A2) can be checked using space polynomial in the size
of A1 and A2 and exponential in deg(A2) log(deg(A1) + deg(A2) + 1).

12

Nominal Automata with Name Binding

The theorem can be rephrased as saying that bar language inclusion of NFA is in parameterized
polynomial space (para-PSPACE) [24], the parameter being the degree.

Proof (Sketch). Let A1, A2 be bar NFAs with initial states s1, s2. We exhibit an NEXPSPACE
procedure to check that Lα(A1) is not a subset of Lα(A2), which implies the claimed bound by
Savitch’s theorem. It maintains a state q of A1 and a set Ξ of states in the name-dropping RNNA ¯A2
generated by A2 as described in Construction 4.4, with q initialized to s1 and Ξ to {(s2, idFNs2 )}.
It then iterates the following:

1. Guess a transition q α−→ q′ in A1 and update q to q′.
2. Compute the set Ξ′ of all states of ¯A2 reachable from states in Ξ via α-transitions (literally, i.e.

not up to α-equivalence) and update Ξ to Ξ′.

The algorithm terminates successfully and reports that Lα(A1) 6⊆ Lα(A2) if it reaches a ﬁnal state
q of A1 while Ξ contains only non-ﬁnal states.

Correctness of the algorithm follows from Theorem 4.5 and Lemma 3.7. To analyze space usage,
ﬁrst recall that cosets πFN can be represented as injective renamings N → A. Note that Ξ will
only ever contain states (q, πFN ) such that the image πN of the corresponding injective renaming
is contained in the set P of names occurring literally in either A1 or A2. In fact, at the beginning,
idNs2 consists only of names literally occurring in A2, and the only names that are added are those
occurring in transitions guessed in Step 1, i.e. occurring literally in A1. So states (q, πFN ) in Ξ
can be coded using partial functions Nq ⇀ P . There are only exponentially many such states;
noting that ♯P ≤ deg(A1) + deg(A2), there are at most k · (deg(A1) + deg(A2) + 1)deg(A2) =
k · 2deg(A2) log(deg(A1)+deg(A2)+1) such states, where k is the number of states of A2.

◭

◮ Remark 6.2. The translation from NKA expressions to regular bar expressions from Section 3
increases expression size exponentially but the degree only linearly. Therefore, the EXPSPACE upper
bound on inclusion for NKA expressions [15] follows from Theorem 6.1.

We now adapt the inclusion algorithm to local freshness semantics.

◮ Deﬁnition 6.3. We denote by ⊑ the preorder (in fact: order) on ¯A∗ generated by wav ⊑ w av.

◮ Lemma 6.4. Let L1, L2 be bar languages accepted by RNNA. Then D(L1) ⊆ D(L2) iff for each
[w]α ∈ L1 there exists w′ ⊒ w such that [w′]α ∈ L2.

◮ Corollary 6.5. Inclusion D(Lα(A1)) ⊆ D(Lα(A2)) of bar NFAs (or regular bar expres-
sions) under local freshness semantics is in para-PSPACE, with parameter deg(A2) log(deg(A1) +
deg(A2) + 1).

Proof. By Lemma 6.4, we can use a modiﬁcation of the above algorithm, where Ξ′ additionally
contains states of ¯A2 reachable from states in Ξ via a-transitions in case α is a free name a.

◭

7 Conclusions and Future Work

We have studied the global and local freshness semantics of regular nondeterministic nominal au-
tomata, which feature explicit name-binding transitions. We have shown that RNNAs are equivalent
to session automata [4] under global freshness and to non-spontaneous and name-dropping nondeter-
ministic orbit-ﬁnite automata [3] under local freshness. Under both semantics, RNNAs are compar-
atively well-behaved computationally, and in particular admit inclusion checking in parameterized
polynomial space. While this reproves known results on session automata under global freshness,
decidability of inclusion under local freshness appears to be new, and in fact other nondeterministic

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

13

automata models for local freshness tend to have undecidable inclusion problems (e.g. ﬁnite memory
automata (FMAs) with more than two registers [12], nondeterministic orbit-ﬁnite automata [3], and
variable automata [10]). In terms of expressivity, RNNAs lie strictly between ﬁnite uniﬁcation-based
automata without read-only symbols [13] and FMAs.

We leave the implementation of our calculus, possibly transferring efﬁcient methods for equiv-
alence checking of NFAs using bisimulation up to congruence [5] to the nominal setting, as future
work. Another challenge is to add support for deallocation operators in the spirit of dynamic se-
quences [9] to the framework.

Acknowledgements We wish to thank Charles Paperman for useful discussions. We also thank
the anonymous reviewers of an earlier version of this paper for their insightful comments that helped
us improve the paper, and in particular led us to discover the crucial notion of name dropping.

References

1 M. Bielecki, J. Hidders, J. Paredaens, J. Tyszkiewicz, and J. V. den Bussche. Navigating with a
browser. In Automata, Languages and Programming, ICALP 2002, vol. 2380 of LNCS, pp. 764–
775. Springer, 2002.

2 M. Boja´nczyk. Automata for data words and data trees. In Rewriting Techniques and Applications,

RTA 2010, vol. 6 of LIPIcs, pp. 1–4. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2010.

3 M. Bojanczyk, B. Klin, and S. Lasota. Automata theory in nominal sets. Log. Methods Comput.

4

5

Sci., 10, 2014.
B. Bollig, P. Habermehl, M. Leucker, and B. Monmege. A robust class of data languages and an
application to learning. Log. Meth. Comput. Sci., 10, 2014.
F. Bonchi and D. Pous. Checking NFA equivalence with bisimulations up to congruence.
Principles of Programming Languages, POPL 2013, pp. 457–468. ACM, 2013.

In

6 V. Ciancia and E. Tuosto. A novel class of automata for languages on inﬁnite alphabets. Technical

report, University of Leicester, 2009. CS-09-003.

7 M. J. Gabbay. Foundations of nominal techniques: logic and semantics of variables in abstract

syntax. Bull. Symbolic Logic, 17(2):161–229, 2011.

8 M. J. Gabbay and V. Ciancia. Freshness and name-restriction in sets of traces with names. In Foun-
dations of Software Science and Computational Structures, FOSSACS 2011, vol. 6604 of LNCS, pp.
365–380. Springer, 2011.

9 M. J. Gabbay, D. R. Ghica, and D. Petrisan. Leaving the nest: Nominal techniques for variables
with interleaving scopes. In Computer Science Logic, CSL 2015, vol. 41 of LIPIcs, pp. 374–389.
Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2015.

10 O. Grumberg, O. Kupferman, and S. Sheinvald. Variable automata over inﬁnite alphabets.

In
Language and Automata Theory and Applications, LATA 2010, vol. 6031 of LNCS, pp. 561–572.
Springer, 2010.

11 M. Hennessy. A fully abstract denotational semantics for the pi-calculus. Theor. Comput. Sci.,

278:53–89, 2002.

12 M. Kaminski and N. Francez. Finite-memory automata. Theor. Comput. Sci., 134:329–363, 1994.
13 M. Kaminski and T. Tan. Regular expressions for languages over inﬁnite alphabets. Fund. Inform.,

69:301–318, 2006.

14 M. Kaminski and D. Zeitlin. Finite-memory automata with non-deterministic reassignment. Int. J.

Found. Comput. Sci., 21:741–760, 2010.

15 D. Kozen, K. Mamouras, D. Petrisan, and A. Silva. Nominal Kleene coalgebra.

In Automata,

Languages, and Programming, ICALP 2015, vol. 9135 of LNCS, pp. 286–298. Springer, 2015.

16 D. Kozen, K. Mamouras, and A. Silva. Completeness and incompleteness in nominal kleene alge-
bra. In Relational and Algebraic Methods in Computer Science, RAMiCS 2015, vol. 9348 of LNCS,
pp. 51–66. Springer, 2015.

14

Nominal Automata with Name Binding

17 K. Kürtz, R. Küsters, and T. Wilke. Selecting theories and nonce generation for recursive protocols.

In Formal methods in security engineering, FMSE 2007, pp. 61–70. ACM, 2007.

18 A. Kurz, T. Suzuki, and E. Tuosto. On nominal regular languages with binders. In Foundations of
Software Science and Computational Structures, FOSSACS 2012, vol. 7213 of LNCS, pp. 255–269.
Springer, 2012.
L. Libkin, T. Tan, and D. Vrgoc. Regular expressions for data words. J. Comput. Syst. Sci., 81:1278–
1297, 2015.
S. Milius, L. Schröder,
rational
http://www8.cs.fau.de/ext/thorsten/nomliftings.pdf.
F. Neven, T. Schwentick, and V. Vianu. Finite state machines for strings over inﬁnite alphabets.
ACM Trans. Comput. Log., 5:403–435, 2004.

Regular behaviours with names:

and T. Wißmann.

on

nominal

submitted;

ﬁxpoints

of

endofunctors

available

19

20

21

sets.

On
at

22 A. Pitts. Nominal Sets: Names and Symmetry in Computer Science. Cambridge University Press,

23

24

2013.
L. Segouﬁn. Automata and logics for words and trees over an inﬁnite alphabet.
Science Logic, CSL 2006, vol. 4207 of LNCS, pp. 41–57. Springer, 2006.
C. Stockhusen and T. Tantau. Completeness results for parameterized space classes. In Parameter-
ized and Exact Computation, IPEC 2013, vol. 8246 of LNCS, pp. 335–347. Springer, 2013.

In Computer

25 A. Tal. Decidability of inclusion for uniﬁcation based automata. Master’s thesis, Technion, 1999.
26 D. Turner and G. Winskel. Nominal domain theory for concurrency. In Computer Science Logic,
23rd international Workshop, CSL 2009, 18th Annual Conference of the EACSL, Coimbra, Portugal,
September 7-11, 2009. Proceedings, pp. 546–560, 2009.
T. Wysocki. Alternating register automata on ﬁnite words. Master’s thesis, University of Warsaw,
2013. (In Polish).

27

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

15

A Omitted Proofs

A.1 Abstraction in Nominal Sets

We occasionally use, without express mention, the following alternative description of equality in
the abstraction [A]X, which formalizes the usual intuitions about α-equivalence:

◮ Lemma A.1. Let a, b ∈ A and x, y ∈ X. Then haix = hbiy in [A]X iff either

(i) (a, x) = (b, y), or
(ii) b 6= a, b # x, and (ab) · x = y.

Proof. ‘If’: the case where (i) holds is trivial, so assume (ii). Let c be fresh; we have to show
(ca) · x = (cb) · y. But (cb) · y = (cb) · (ab) · x = (acb) · x = (ca) · x, where we use in the last step
that b, c are both fresh for x so that (ca)−1(acb) = (ca)(acb) = (bc) ﬁxes x.

‘Only if’: We assume (a, x) 6= (b, y) and prove (ii). We ﬁrst show a 6= b: Assume the contrary.
Let c be fresh; by the deﬁnition of abstraction, we then have (ca) · x = (cb) · y, so y = (cb)(ca) · x =
(ca)(ca) · x = x, contradiction. We have supp(x) ⊆ {a} ∪ supp(haix) = {a} ∪ supp(hbiy), whence
b # x since a 6= b and b # hbiy. Finally, with c as above y = (cb)−1(ca) · x = (cb)(ca) · x =
(acb) · x = (ab) · x, again because (ab)−1(abc) = (ab)(abc) = (bc) and b, c are fresh for x.
◭

As an easy consequence we obtain:

◮ Corollary A.2. Let X be a nominal set, a ∈ A and x ∈ X. Then supp(haix) = supp(x) − {a}.

Proof of Lemma 2.2 Firstly, any ﬁnite set S ⊆ X is ufs, becauseSy∈S supp(y) is a ﬁnite union
of ﬁnite sets. Secondly, for any ufs S ⊆ X, we have supp(S) = Sy∈S supp(y), which is a ﬁnite

union (because X is orbit-ﬁnite) of again ﬁnite sets.

◭

A.2 Proofs and Lemmas for Section 3

NOFAs as coalgebras We show that the standard description of NOFAs as repeated at the
beginning of Section 3 is equivalent to the one as F -coalgebras for F X = 2 × Pfs(A × X). For the
direction from the standard description to F -coalgbras, recall that the transition relation is assumed
to be equivariant; therefore, the map taking a state q to {(a, q′) | q a−→ q′} is equivariant, hence
preserves supports and therefore ends up in F Q where Q is the set of states. Conversely, let ξ :
Q → F Q be an F -coalgebra with components f : Q → 2, g : Q → Pfs(A × Q). Deﬁne the
transition relation on Q by q a−→ q′ iff (a, q′) ∈ g(Q), and make q ﬁnal iff f (q) = ⊤. Then ﬁnality
is equivariant by equivariance of f . To see that the transition relation is equivariant let q a−→ q′ and
π ∈ G. Then (πa, πq′) ∈ π(g(q)) = g(π(q)) by equivariance of g, i.e. πq πa−−→ πq′.

◭

◮ Deﬁnition A.3. Given a state q in A we write L0(q) and Lα(q) for the literal language and the
bar language, respectively, accepted by the automaton obtained by making q the initial state of A.

◮ Lemma A.4. In an RNNA, the map q 7→ Lα(q) is equivariant.

Proof. Note ﬁrst that the set of bar strings ¯A∗ is the initial algebra for the functor SX = 1 + A ×
X + A × X on Nom. And the set ¯M of bar strings modulo α-equivalence is the intial algebra
for the functor SαX = 1 + A × X + [A]X on Nom. The functor Sα is a quotient of the functor
S via the natural transformation q : S ։ Sα given by the canonical quotient maps A × X ։
[A]X. The canonical quotient map [−]α : ¯A∗ ։ ¯M that maps every bar string to its α-equivalence

16

Nominal Automata with Name Binding

class is obtained inductively, i.e. [−]α is the unique equivariant map such that the following square
commutes:

S ¯A∗

ι

S[−]α

¯A∗

[−]α

S ¯M q ¯M

/ Sα ¯M ια

/ ¯M

where ι : S ¯A∗ → ¯A∗ and ια : Sα ¯M → ¯M are the structures of the initial algebras, respectively.
Since the map [−]α is equivariant we thus have π[w]α = [πw]α for every w ∈ ¯A∗.

Now we prove the statement of the lemma. Since both free and bound transitions are equivariant,
the literal language L0(−) is equivariant. It follows that the bar language Lα(−) is equivariant: If
m ∈ Lα(q) then there is w ∈ L0(q) such that [w]α = m. For π ∈ G, it follows that π · w ∈ L0(πq),
and hence [π · w]α ∈ Lα(πq). But [π · w]α = π[w]α, so πm ∈ Lα(πq).

◭

Proof of Lemma 3.4
1. Consider the ufs set Z = {(a, q′) | q a−→ q′}. Then we have supp(q′) ∪ {a} = supp(a, q′) ⊆
supp(Z) ⊆ supp(q) where the second inclusion holds because Z is ufs, and the third because Z
depends equivariantly on q.

2. Consider the ufs set Z = {[a]q′ | q

a−→ q′}. Then we have supp(q′) ⊆ supp([a]q′) ∪ {a} ⊆
supp(Z) ∪ {a} ⊆ supp(q) ∪ {a} where the second inclusion holds because Z is ufs, and the
third because Z depends equivariantly on q.
◭

◮ Remark A.5. Given an RNNA A with the state set Q the paths in A form the initial algebra
for the functor Q × S(−), where S is the functor in the proof of Lemma A.4. Paths in A modulo
α-equivalence then form the initial algebra for Q × Sα(−) and the canonical quotient map [−]α
mapping a path to its α-equivalence class is obtained by initiality similarly as the canonical quotient
map in Lemma A.4.

Proof of Lemma 3.7

◮ Lemma A.6. Let A be a name-dropping RNNA, and let q|N restrict a state q in A to N ⊆
supp(q). Then {w ∈ L0(q) | FN(w) ⊆ N } ⊆ L0(q|N ).

Proof. Induction on the length of w ∈ L0(q) with FN(w) ⊆ N , with the base case immediate from
the ﬁnality condition in Deﬁnition 3.6. So let w = αv with α ∈ ¯A, accepted via a path q α−→ q′ v−→ p,
and let q′|Nv restrict q′ to Nv := FN(v). By the induction hypothesis, v ∈ L0(q′|Nv ). Moreover,
α−→ q′|Nv . If α is free, then we have to show
q α−→ q′|Nv. We are done once we show that q|N
Nv ∪ {α} ⊆ N , and if α = a is bound, we have to show Nv ⊆ N ∪ {a}. In both cases, the requisite
inclusion is immediate from FN(αv) ⊆ N .

◭

Proof (Lemma 3.7). We use induction on the word length. It sufﬁces to show that L0(A) is closed
w−→
under single α-conversion steps. So let v aw ∈ ¯A∗ ∈ L0(A), via a path s = q0
q3 (with q3 ﬁnal), let b 6= a with b /∈ FN(w), and let w′ be obtained from w by replacing free
occurrences of a with b. We have to show that v bw′ ∈ L0(A); it sufﬁces to show that bw′ ∈
L0(q1). Put N = supp(q2) − {b}, and let q2|N restrict q2 to N . By Lemma A.6, w ∈ L0(q2|N ),
and hence [w]α ∈ Lα(q2|N ). By Lemma A.4, it follows that [w′]α ∈ Lα((ab)(q2|N )), so by the
a−→ q2|N , and by α-invariance,
induction hypothesis, w′ ∈ L0((ab)(q2|N )). We clearly have q1
q1

a−→ q2

v−→ q1

b−→ (ab)(q2|N ) because b # (q2|N ).
Thus, bw′ ∈ L0(q1) as required.

◭

/
/




/
/
L. Schröder, D. Kozen, S. Milius, and T. Wißmann

17

Proof of Lemma 3.8

◮ Deﬁnition A.7. Given the transition data of an RNNA A (not necessarily assuming any ﬁniteness
and invariance conditions) and a state q in A, we denote by fsuc(q) the set

fsuc(q) = {(a, q′) | q a−→ q′}

of free transitions of q, and by bsuc(q) the set

bsuc(q) = {haiq′ | q a−→ q′}

of bound transitions of q modulo α-equivalence.

Note that under α-invariance of transitions we have haiq′ ∈ bsuc(q) if and only if q a−→ q′.
Before we proceed to the proof of the lemma we note the following general fact about nominal

sets: for the value of π · x, it matters only what π does on the atoms in supp(x):

◮ Lemma A.8. For x ∈ (X, ·) and any π, σ ∈ G with π(v) = σ(v) for all v ∈ supp(x), we have
π · x = σ · x.

Proof. Under the given assumptions, π−1σ ∈ Fix(supp(x)) ⊆ ﬁx(x).

◭

Proof (Lemma 3.8). Let A be an RNNA with set Q of states.

(1) We construct an equivalent name-dropping RNNA A′ as follows. As states, we take pairs

q|N := Fix(N )q

where q ∈ Q, N ⊆ supp(q), and Fix(N )q denotes the orbit of q under Fix(N ). We deﬁne an
action of G on states by π · (q|N ) = (πq)|πN . To see well-deﬁnedness, let π′ ∈ Fix(N ) (i.e.
(π′q)|N = q|N ); we have to show (ππ′q)|πN = (πq)|πN . Since (ππ′π−1)πq = ππ′q, this follows
from ππ′π−1 ∈ Fix(πN ). The map (q, N ) 7→ q|N is equivariant, which proves the bound on the
number of orbits in A′. A state q|N is ﬁnal if q is ﬁnal in A; this clearly yields an equivariant subset
of states of A′. The initial state of A′ is s|supp(s) where s is the initial state of A. We have

supp(q|N ) = N ;

(2)

in particular, the states of A′ form a nominal set. To see ‘⊆’ in (2), it sufﬁces to show that N
supports q|N . So let π ∈ Fix(N ). Then π · (q|N ) = (πq)|πN = q|N , as required. For ‘⊇’, let
a ∈ N ; we have to show that N − {a} does not support q|N . Assume the contrary. Pick b # q. Then
(ab) ∈ Fix(N − {a}), so (ab) · (q|N ) = Fix((ab) · N )(ab) · q = Fix(N )q = q|N . In particular,
q ∈ Fix(ab) · N )(ab) · q, i.e. there is ρ ∈ Fix((ab) · N ) such that ρ(ab) · q = q. By equivariance of
supp, it follows that ρ(ab) · supp(q) = supp(q). Now b ∈ (ab) · N , so ρ(b) = b. Since a ∈ supp(q),
it follows that b ∈ ρ(ab) · supp(q); but b /∈ supp(q), contradiction.

As transitions of A′, we take
q|N
q|N

a−→ q′|N ′ whenever q a−→ q′, N ′ ⊆ N , and a ∈ N , and
a−→ q′|N ′ whenever q b−→ q′′, N ′′ ⊆ supp(q′′) ∩ (N ∪ {b}), and hai(q′|N ′) = hbi(q′′|N ′′ ).
a−→ q′|N ′ need not imply that q a−→ q′,
(We do not require the converse implications. E.g. q|N
only that πq a−→ q′ for some π ∈ Fix(N ); see also (3) below.) Transitions are clearly equivariant.
Moreover, bound transitions are, by construction, α-invariant.

◮ Fact A.9. By construction, every bound transition in A′ is α-equivalent1 to one of the form
q|N

a−→ q′|N ′ where q a−→ q′ and N ′ ⊆ supp(q′) ∩ (N ∪ {a}).

1 Recall that a transition q

a

−→ q′ is α-equivalent to a transition r

b

−→ r′ if q = r and haiq′ = hbir′.

18

Nominal Automata with Name Binding

(2) To see ufs branching, let q|N be a state in A′. For free transitions, we have to show that the set

fsuc(q|N ) = {(a, q′|N ′ ) | N ′ ⊆ N, a ∈ N, πq a−→ q′ for some π ∈ Fix(N )}

of free successors of q|N is ufs. But for π ∈ Fix(N ), N ′ ⊆ N , and a ∈ N , we have πq a−→ q′ iff q a−→
π−1q′, and then moreover π−1 ∈ Fix(N ′) so Fix(N ′)π−1q′ = Fix(N ′)q′, i.e. q′|N ′ = (π−1q′)|N ′.
We thus have

fsuc(q|N ) = {(a, (π−1

q′)|N ′ | N ′ ⊆ N, a ∈ N, q a−→ π−1q′}

= {(a, q′|N ′ ) | N ′ ⊆ N, a ∈ N, q a−→ q′},

(3)

which is ufs.

We proceed similarly for the bound transitions: We need to show that the set bsuc(q|N ) of bound
a−→ q′|N ′ arises from π ∈ Fix(N ) and
(π−1a)
−−−−−→ π−1q′. Moreover, we claim that

successors of q|N is ufs. By Fact A.9, a bound transition q|N
N ′ ⊆ supp(q′) ∩ (N ∪ {a}) such that πq

a−→ q′. Then q

hai(q′|N ′ ) = hπ−1ai(π−1(q′|N ′)).

(4)

To see (4), we distinguish two cases: If π−1(a) = a then the two sides are equal because π−1 ﬁxes
the support of q′|N ′. If π−1(a) 6= a then π−1a /∈ N because π−1 ﬁxes N , so π−1a /∈ N ∪ {a}
and therefore π−1a /∈ N ′ = supp(q′|N ′ ). This means that we can α-equivalently rename a into
π−1a in ( a, q′|N ′); since π−1 ﬁxes N , the result of this renaming equals ( π−1a, π−1q′|N ′). Since
π−1(q′|N ′) = (π−1q)|π−1N ′ and π−1N ′ ⊆ supp(π−1q′)∩(N ∪{π−1(a)}) (recall π ∈ Fix(N )), (4)
proves

bsuc(q|N ) = {hπ−1ai((π−1q′)|π−1N ′ ) |

π ∈ Fix(N ), π−1N ′ ⊆ supp(π−1q′) ∩ (N ∪ {π−1a}), q π−1a−−−−→ π−1q′}

= {hai(q′|N ′) | N ′ ⊆ supp(q′) ∩ (N ∪ {a}), q a−→ q′}.

(5)

By (5), bsuc(q|N ) is ufs; indeed, we have supp(hai(q′
N ′ )) = N ′ − {a} so the support of every
element of bsuc(q|N ) is a subset of N . (Note that (5) is not the same as Fact A.9, as in (5) we use a
ﬁxed representative q of Fix(N )q.)

(3) We show next that A′ is name-dropping. So let q|N be a state in A′, and let N ′ ⊆
supp(q|N ) = N . We show that q|N ′ restricts q|N to N ′. We ﬁrst establish that q|N ′ has at least
the same incoming transitions as q|N . For the free transitions, let π ∈ Fix(N ), q′ a−→ πq and
a−→ (πq)|N = q|N . Then also π ∈ Fix(N ′) and N ′ ⊆ N ′′, so
a ∈ N ′′ ⊇ N , so that q′|N ′′
a−→ πq|N ′ = q|N ′ as required. For the bound transitions, let π ∈ Fix(N ), let hai(q|N ) =
q′|N ′′
b−→ π(ab) · q where π ∈ Fix((ab)N ), and let (ab) · N ⊆ N ′′ ∪ {b},
hbi((ab) · (q|N )), let q′
b−→ π(ab) · q we have
so that q′|N ′′
b−→ ((π(ab)q)|(ab)N ′ ) = (((ab)q)|(ab)N ′ ), because (ab)N ′ ⊆ (ab)N ⊆ N ′′ ∪ {b} and
q|N ′′
π ∈ Fix((ab)N ) ⊆ Fix((ab)N ′). If b = a, we are done. So assume b 6= a. Since A′ is α-invariant,
it remains only to show that

a−→ q|N . We have to show that q′|N ′′

a−→ q|N ′. From q′

hbi((ab)q|(ab)N ′ ) = hai(q|N ′ ),

i.e. that b /∈ supp(q|N ′ ); but since b 6= a and hai(q|N ) = hbi((ab) · (q|N )), we even have b /∈
supp(q|N ) ⊇ N ′ ⊇ supp(q|N ′ ).

Next, we show that q|N ′ has the requisite outgoing transitions. For the free transitions, let q|N

q′|M where supp(q′|M ) ∪ {a} = M ∪ {a} ⊆ N ′. We have to show q|N ′

a−→
a−→ q′|M . By (3), we have

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

19

Now if M ⊆ N ′ ∪ {a} this yields a transition q|N ′

a−→ (πq′)|M = q′|M , as required. For the
q a−→ πq′ for some π ∈ Fix M . By construction of A′, q|N ′
a−→ q′|M
bound transitions, we proceed as follows. By (5), a given outgoing bound transition of q|N
yields a state r|S of A′ and b ∈ A such that haiq′|M = hbir|S, S ⊆ supp(r) ∩ (N ∪ {a}) and q b−→ r.
a−→ q′|M by construction of A′; indeed, we
already have q b−→ r, S ⊆ supp(r) and haiq′|M = hbir|S, so it remains to show that S ⊆ N ′ ∪ {b}.
By Lemma A.1, haiq′|M = hbir|S iff either a = b and q′|M = r|S (and the latter yields M = S,
thus we are done), or a 6= b, a # r|S and (ba)(r|S ) = q′|M . It follows that a 6∈ S and M = (ba)S.
Since (ba)S ⊆ N ′ ∪ {a} we have equivalently S ⊆ (ba)N ′ ∪ {b}. This implies S ⊆ N ′ ∪ {b} using
that a 6∈ S.

(4) It remains to show that Lα(A′) = Lα(A). To show ‘⊆’, we show that [w]α ∈ Lα(q) for every
state q|N in A′ and every w ∈ L0(q|N ), by induction on w: for the empty word, the claim follows
v−→ t be an accepting path
from the deﬁnition of ﬁnal states in A′. For w = αv, let q|N
in A′. Then we have [v]αv ∈ Lα(q′) by induction hypothesis and FN(v) ⊆ N ′ by Corollary 3.5.
By (3) and (5), we have q α−→ πq′ for some π ∈ Fix N ′. It follows that π · v = v and therefore
[v]α = π[v]α ∈ Lα(πq′) by the equivariance of Lα (see Lemma A.4). Hence [αv]α ∈ Lα(q).

α−→ q′|N ′

To see Lα(A′) ⊇ Lα(A), it sufﬁces to note that A is included as a subautomaton in A′ via the

map that takes q to q|supp(q), i.e. q α−→ q′ in A implies q|supp(q)

α−→ q′|supp(q′) in A′.

◭

A.3 Proofs and Lemmas for Section 4

◮ Lemma A.10. Let q be a state in a bar NFA; then Lα(q) is ufs.

Proof. The ﬁnitely many transitions of A only mention letters from a ﬁnite subset of ¯A, and

Sw∈Lα(q) supp(w) is contained in that ﬁnite subset.

Proof of Theorem 4.5

◭

As indicated in the text, we split the construction into two parts, and ﬁrst construct a plain RNNA ˜A.
The states of ˜A are pairs

(q, πHq) where Hq = Fix(supp(Lα(q)))

consisting of a state q in A and a left coset πHq, where the action of G is as on ¯A:

π1 · (q, π2Hq) = (q, π1π2Hq).

We continue to write Nq = supp(Lα(q)) (note Hq = FNq in the notation used in the construction
of ¯A). The initial state of ˜A is (s, Hs) where s is the initial state of A; a state (q, πHq) is ﬁnal in ˜A
iff q is ﬁnal in A. Free transitions in ˜A are of the form

(q, πHq)

π(a)
−−−→ (q′, πHq′ ) where q a−→ q′ and a ∈ Nq,

(where the condition a ∈ Nq is automatic unless Lα(q′) = ∅) and bound transitions are of the form

(q, πHq) a−→ (q′, π′Hq′ ) where q b−→ q′ and haiπ′Hq′ = hπ(b)iπHq′ .

◮ Remark A.11. (1) Note that by Lemma 2.1, Nq = supp(Lα(q)) =Sw∈Lα(q) supp(w), i.e. Nq

is the set of names that appear free in some word w ∈ Lα(q).

(2) Observe that πHq = π′Hq iff π′(v) = π(v) for all v ∈ Nq: πHq = π′Hq iff π−1π′ ∈ Hq iff

π−1π′(v) = v for all v ∈ Nq iff π′(v) = π(v) for all v ∈ Nq.

20

Nominal Automata with Name Binding

(3) For a coset πHq, we have

supp(q, πHq) = supp(πHq) = πNq

so the set ˜Q of states of ˜A is a nominal set. This is by Item (2): for π′ ∈ G, we have π′πHq =
πHq iff π′π(a) = π(a) for all a ∈ Nq iff π′ ∈ Fix(πNq).

(4) Note that hai(πHq) = hbi(π′Hq) implies hai(q, πHq) = hbi(q, π′Hq) since the action of G on

states of ˜A is trivial in the ﬁrst component.

◮ Remark A.12. Left cosets for Hq are in one-to-one correspondence with injections Nq → A.
Indeed, in the light of Remark A.11(2) it sufﬁces to prove that every injection i : Nq → A can be
extended to a ﬁnite permutation. Deﬁne π by

π(a) =(i(a)

i−n(a)

a ∈ Nq
else, for n ≥ 0 minimal s.t. i−n(a) 6∈ i[Nq]

For the proof that π is a indeed a ﬁnite permutation see [20, Corollary 2.4].

Transitions from a given state (q, πHq) can be characterized as follows.

◮ Lemma A.13. Let (q, πHq) be a state in ˜A. Then

fsuc(q, πHq) = {(π(a), (q′, πHq′ )) | q a−→ q′, a ∈ Nq}

and

bsuc(q, πHq) = {hπ(a)i(q′, πHq′ ) | q a−→ q′}.

Proof. For the free transitions, we have by deﬁnition

(6)

(7)

fsuc(q, πHq) = {(π′(a), (q′, π′Hq′ )) | π′Hq = πHq, q a−→ q′, a ∈ Nq}.

Now if π′Hq = πHq and q a−→ q′, then π and π′ agree on Nq and hence on Nq′ ∪{a} (as Nq′ ∪{a} ⊆
Nq), so (π′(a), (q′, π′Hq′ )) = (π(a), (q′, πHq′ )). This shows (6).

For the bound transitions, we have by deﬁnition and using Remark A.11(4)

bsuc(q, πHq) = {hπ′(a)i(q′, π′Hq′ ) | π′Hq = πHq, q a−→ q′}.

So let π′Hq = πHq and q a−→ q′. The claim (7) follows from

hπ′(a)i(q′, π′Hq′ ) = hπ(a)i(q′, πHq′ ),

(8)

which we now prove. By Remark A.11(2) we know that π and π′ agree on Nq. In order to prove (8),
we distinguish two cases: if π(a) = π′(a) then π and π′ agree on Nq′ ⊆ Nq ∪ {a}, i.e. π′Hq′ =
πHq′, so the two sides of (8) are literally equal. Otherwise, a /∈ Nq, and π′, π differ on Nq′ only
w.r.t. their value on a. It follows that (π(a) π′(a))π and π′ agree on Nq′ = supp(Hq′ ). Therefore
(π(a) π′(a))πHq′ = π′Hq′ by Lemma A.8. So, by Lemma A.1, to show (8) it sufﬁces to show
that π′(a) /∈ supp(q′, πHq′ ). But supp(q′, πHq′ ) = πNq′ ⊆ πNq ∪ π(a) = π′Nq ∪ π(a), and
π′(a) /∈ π′Nq ∪ π(a) because a /∈ Nq and π′(a) 6= π(a).

◭

The key ingredient in the proof that ˜A accepts the same bar language as A will be a normalization
result on paths that uses an obvious notion of α-equivalence on paths in an RNNA (see Remark A.5);
explicitly:

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

21

◮ Deﬁnition A.14. α-equivalence of paths in an RNNA is deﬁned inductively by

q0

a−→ q1

α2−→ q2

α3−→ · · · αn−−→ qn is α-equivalent to q0

a−→ q′
1

α′
2−→ q′
2

α′
3−→ · · ·

α′
n−−→ q′
n

if q1

α2−→ q2

α3−→ · · · αn−−→ qn is α-equivalent to q′
1

α′
2−→ q′
2

α3−→ · · ·

α′
n−−→ q′

n, and

q0

a−→ q1

α2−→ q2

α3−→ · · · αn−−→ qn is α-equivalent to q0

b−→ q′
1

α′
2−→ q′
2

α′
3−→ · · ·

α′
n−−→ q′
n

α2−→ q2

if hai[q1
α-equivalence classes of paths.

α3−→ · · · αn−−→ qn]α = hbi[q′
1

α′
2−→ q′
2

α′
3−→ · · ·

α′
4−→ q′

n]α, where we use [−]α to denote

◮ Lemma A.15. The set of paths of an RNNA is closed under α-equivalence.

Proof. Observe that by equivariance, G acts pointwise on paths. It sufﬁces to show closure under
αn−−→ qn be path in an RNNA A, denote the path
single α-conversion steps. So let q0
from q1 onwards by P , and let haiP = hbiP ′, so P ′ = (ab) · P . Then by α-invariance of →, we
have q0

b−→ (ab)q1, and by equivariance, (ab) · P is a path from (ab)q1.

α2−→ . . .

a−→ q1

◭

◮ Lemma A.16. Let P = q0
Then there exists a path in A of the form q0

a−→ q1

α2−→ . . .

αn−−→ qn be a path in an RNNA A, and let haiq1 = hbiq′
1.

b−→ q′
1

α′
2−→ . . .

α′
n−−→ q′

n that is α-equivalent to P .

Proof. Since A is an RNNA, the support of the α-equivalence class of q1
α′
supp(q1) (Remark A.17), so we obtain an α-equivalent path q0
2−→ . . .
a into b in q1

αn−−→ qn.

α2−→ . . .

b−→ q′
1

α2−→ . . .
α′
n−−→ q′

αn−−→ qn is
n by renaming

◭

◮ Remark A.17. Note that the support of the α-equivalence class of a path in an RNNA is the
support of its starting state. Indeed, let [P ]α be such an equivalence class and let q be the starting
state of P . The inclusion supp(q) ⊆ supp([P ]α) holds because we have a well-deﬁned equivariant
projection from paths to their initial states. The converse inclusion is shown by induction, using
Lemma 3.4.

In the proof that ˜A accepts Lα(A), the following normalization result for paths is crucial.

◮ Deﬁnition A.18. A path in ˜A is π-literal for π ∈ G if all transitions in it are of the form
(q, πHq) πα−−→ (q′, πHq′ ) where α ∈ ¯A and q α−→ q′.

Intuitively, a π-literal path is one that uses the same pattern of name reusage for free and bound
names as the underlying path in A, up to a joint renaming π of the free and bound names.

◮ Lemma A.19. Let P be a path in ˜A beginning at (q0, π0Hq0 ). Then P is α-equivalent to a
π0-literal path.

α1−→ (q1, π1Hq1 )

Proof. We prove the statement by induction over the path length. The base case is trivial. For the
α2−→ · · · αn−−→ (qn, πnHqn ) be a path of length
inductive step, let P = (q0, π0Hq0 )
n > 0. If α1 is a free name then π1Hq1 = π0Hq1 by (6); by induction, we can assume that the length-
(n − 1) path from (q1, π0Hq1 ) onward is π0-literal, and hence the whole path is π0-literal. If α1 = a
b−→ q1 in A. By
then by (7) we have hai(q1, π1Hq1 ) = hπ0(b)i(q1, π0Hq1 ) for some transition q0
π0(b)
Lemma A.16, this induces an α-equivalence of P with a path (q0, π0Hq0 )
−−−−→ (q1, π0Hq1 ) −→
. . . ; by the induction hypothesis, we can transform the length-(n − 1) path from (q1, π0Hq1 ) onward
into a π0-literal one, so that the whole path becomes π0-literal as desired.

◭

22

Nominal Automata with Name Binding

◮ Lemma A.20. ˜A is an RNNA, with as many orbits as A has states, and accepts the bar language
Lα(A).

Proof. The free and bound transitions of ˜A are equivariant, and the bound transitions are α-invariant
by construction of the transition relation on ˜A (note that all states in the orbit of (q, πHq) have the
form (q, π′Hq)). Every orbit of ˜A contains a state of the form (q, idHq). This proves the claim
on the number of orbits, which implies that ˜A is orbit-ﬁnite. Finite branching is immediate from
Lemma A.13. Thus, ˜A is an RNNA.

It remains to show that Lα( ˜A) = Lα(A). The inclusion ‘⊇’ is clear because A is a subautomaton
in ˜A via the inclusion map f taking a state q to (q, idHq); i.e. q α−→ q′ in A implies (q, idHq) α−→
(q′, idHq′ ) in ˜A. For the reverse inclusion, note that by Lemma A.19, every accepting path of ˜A is
α-equivalent to an id-literal accepting path starting at the initial state (s, idHs) of ˜A; such a path
comes from an accepting path in A for the same bar string via the map f .

◭

We are now set to prove Theorem 4.5 by combining the above construction with that of Lemma 3.8;
i.e. we show that ( ˜A)′ is isomorphic, and in fact equal, to ¯A: A state in ( ˜A)′ has the form

(q, πHq)|N = (Fix N ) · (q, πHq) = (q, (Fix N )πHq)

for N ⊆ supp(q, πHq) = πNq (hence π−1N ⊆ Nq). We claim that

(Fix N )πHq = π Fix(π−1N )(= πFπ−1N ).

(9)

To see ‘⊆’, let ρ ∈ Fix N and σ ∈ Hq. Then π−1ρπ ∈ Fix(π−1N ) and, since π−1N ⊆ Nq,
σ ∈ Fix(π−1N ), so π−1ρπσ ∈ Fix(π−1N ) and therefore ρπσ = ππ−1ρπσ ∈ π Fix(π−1N ).

For ‘⊇’, let ρ ∈ Fix(π−1N ). Then πρπ−1 ∈ Fix(N ), so to show πρ ∈ Fix(N )πHq it sufﬁces to

show (πρπ−1)−1πρ ∈ πHq. But (πρπ−1)−1πρ = π ∈ πHq.

This proves equality of the state sets. It remains to show that the transitions in ( ˜A)′ and ¯A are
π(a)
−−−→ (q′, πHq′ )|N ′ where q a−→ q′,
the same. The free transitions in ( ˜A)′ are of the form (q, πHq)|N
N ′ ⊆ πNq′, and N ′ ∪ {a} ⊆ N ⊆ πNq; by (9), they thus have, up to α-equivalence, the form
π(a)
−−−→ (q′, πFπ−1N ′) where π−1N ′ ⊆ Nq′ π−1N ′ ∪ {a} ⊆ π−1N ⊆ Nq, and hence

(q, πFπ−1N )
are the same as in ¯A.

The bound transitions in ( ˜A)′ are, up to α-equivalence, those of the form (q, πHq)|N

π(a)
−−−→
(q′, πHq′ )|N ′ where q a−→ q′, N ′ ⊆ {a} ∪ N , N ′ ⊆ πNq′; and N ⊆ πNq; by (9), they thus have
π(a)
the form (q, πFπ−1N )
−−−→ (q′, πFπ−1N ′) where π−1N ′ ⊆ {a} ∪ π−1N , π−1N ′ ⊆ Nq′, and
π−1N ⊆ Nq, and hence again are the same as in ¯A.

◭

Proof of Theorem 4.7

We have to show that every accepting path in A is α-equivalent to an accepting path in A0. Note
that Q0 is closed under free transitions in A, so by Lemma A.16, it sufﬁces to show that for every
bound transition q b−→ q′ in A with q ∈ Q0 we ﬁnd an α-equivalent transition q a−→ q′′ in A0. We
distinguish the following cases.

If already b ∈ A0 then supp(q′) ⊆ supp(q) ∪ {b} ⊆ A0, so q′ ∈ Q0 and we are done.
If b /∈ A0 and b /∈ supp(q′) then supp(q′) ⊆ supp(q) ⊆ A0. In particular, q′ is already in Q0 and
|∗
∗ is fresh for q′, so we can rename b into ∗ and obtain an α-equivalent transition q
−→ q′ in A0.
If b /∈ A0 and b ∈ supp(q′) then |supp(q′) ∩ A0| < k, so that we can pick a name a ∈ A0 that
is fresh for q′. We put q′′ = (ab)q′; then hbiq′ = haiq′′, and q′′ ∈ Q0 because supp(q′′) =
{a} ∪ (supp(q′) − {b}) ⊆ {a} ∪ supp(q) ⊆ A0; thus, q a−→ q′′ is a transition in A0.

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

23

A.4 Proofs and Lemmas for Section 5

◮ Lemma A.21. If π ∈ G and q|N restricts a state q in a NOFA to N ⊆ supp(q), then π(q|N )
restricts πq to πN .

Proof. We have πN ⊆ πsupp(q) = supp(πq), so the claim is well-formed.

For the support of π(q|N ), we have supp(π(q|N )) = πsupp(q|N ) = πN as required.
By the equivariance of ﬁnal states we have that π(q|N ) is ﬁnal if q is ﬁnal.
For incoming transitions, let p a−→ πq. Then π−1p π−1a−−−→ q by equivariance, hence π−1p π−1a−−−→

q|N so that p a−→ π(q|N ).

For outgoing transitions, let πq a−→ q′ where supp(q′) ⊆ πN ∪ {a}. Then q π−1a−−−→ π−1q′ by
π−1a−−−→ π−1q′ and hence, by equivariance,

equivariance, and supp(π−1q′) ⊆ N ∪ π−1a, so q|N
π(q|N ) a−→ q′.

◭

Proof of Proposition 5.3. In the ﬁrst claim, ‘only if’ is immediate by Lemma 3.4. To see ‘if’, let
A be a non-spontaneous and α-invariant NOFA. We construct an RNNA B with the same states as
A, as follows.

q a−→ q′ in B iff q a−→ q′ in A and a ∈ supp(q).
q a−→ q′ in B iff q b−→ q′′ in A for some b, q′′ such that b # q and hbiq′′ = haiq′.

The transition relation thus deﬁned is clearly equivariant and α-invariant. That for every q the sets
{(a, q′) | q a−→ q′} and {haiq′ | q a−→ q′} are ufs (whence ﬁnite) easily follows from non-spontaneity.

It remains to verify that D(B) = A, i.e. that

a−→ q′ in A iff

q

(q

a−→ q′ or q

a−→ q′ in B).

To see the ‘only if’ direction, let q a−→ q′ in A. If a ∈ supp(q) then q a−→ q′ in B. Otherwise, a#q and
hence q a−→ q′. For the ‘if’ direction, we have two cases; the case where q a−→ q′ in B is immediate
by construction of B. So let q a−→ q′ in B, that is, we have q b−→ q′′ in A for some b, q′′ such that
hbiq′′ = haiq′ and b # q. Then by α-invariance of A, q a−→ q′.

We proceed to prove the second claim, beginning with ‘only if’. So let C be a name-dropping
RNNA, let q be a state, let N ⊆ supp(q), and let q|N restrict q to N in C. We show that q|N restricts
q to N in D(C). The condition supp(q|N ) ⊆ N is clear, as the nominal set of states is not changed
by D. Since q|N has at least the same incoming transitions as q in C, the same holds in D(C). For
the outgoing transitions, ﬁrst let q a−→ q′ in D(C) where a ∈ supp(q) and supp(q′) ∪ {a} ⊆ N .
Then either q a−→ q′ or q a−→ q′ in C. In the ﬁrst case, q|N
a−→ q′ in C and hence also in D(C). In
a−→ q′ in
the second case, we have supp(q′) ⊆ N ⊆ {a} ∪ N and therefore q|N
D(C). Second, let q a−→ q′ in D(C) where a # q and supp(q′) ⊆ N ∪ {a}. By Lemma 3.4.1 we
know that q a−→ q′ in C, so q|N

a−→ q′ in C and hence q|N

a−→ q′ in C, so q|N

a−→ q′ in D(C).

For the ‘if’ direction of the second claim, let A be a non-spontaneous, name-dropping, and α-
invariant NOFA. We construct B such that D(B) = A as for the ﬁrst claim, and show additionally
that B is name-dropping. Let q be a state, let N ⊆ supp(q), and let q|N restrict q to N in A. We
claim that q|N also restricts q to N in B. We ﬁrst show that q|N has at least the same incoming
transitions as q in B. For the free transitions, let p a−→ q in B. Then by construction of B, p a−→ q in
A and a ∈ supp(p), so since A is name-dropping, p a−→ q|N in A and hence p a−→ q|N in B. For the
bound transitions, let p a−→ q in B, i.e. we have p b−→ q′ in A with b#p and haiq = hbiq′, in particular
q′ = (ab)q. If a = b then p a−→ q in A, and since A is name-dropping p a−→ q|N in A whence in B.
Otherwise, b # q. By Lemma A.21, (ab)(q|N ) restricts q′ to (ab)N in A, so p b−→ (ab)(q|N ) in A.

24

Nominal Automata with Name Binding

Since supp(q|N ) ⊆ supp(q), we have b # q|N , so hbi((ab)(q|N )) = hai(q|N ). By construction of
B we have q a−→ q|N in B, as required.

For the outgoing transitions, ﬁrst let q a−→ q′ in B where supp(q′) ∪ {a} ⊆ N . Then q a−→ q′
a−→ q′ in A; since a ∈ N = supp(q|N ), it follows by construction of B that
in A = D(B), so q|N
a−→ q′ in B. Second, let q a−→ q′ in B where supp(q′) ⊆ N ∪ {a}. Pick b # (q, a) (so b /∈ N );
q|N
b−→ (ab)q′ in B by α-invariance. Thus, q b−→ (ab)q′ in
then hbi((ab)q′) = haiq′ and therefore q
A = D(B), and supp((ab)q′) = (ab)supp(q′) ⊆ (ab)(N ∪ {a}) = N − {a} ∪ {b} ⊆ N ∪ {b},
b−→ (ab)q′ in A since A is
where the last but one equation holds since b 6∈ N . Therefore, q|N
a−→ q′ in B.
name-dropping. By construction of B, it follows that q|N

◭

Proof of Proposition 5.4. Let A be a non-spontaneous and name-dropping NOFA. We construct
a NOFA ¯A by closing A under α-equivalence of transitions; that is, ¯A has the same states as A (in
particular is orbit-ﬁnite), and its transitions are given by

q a−→ q′ in ¯A iff q a−→ q′ in A or

there exist b, q′′ such that q b−→ q′′ in A, b # q, and haiq′ = hbiq′′.

We say that a transition q a−→ q′ in ¯A is new if it is not in A.

◮ Fact A.22. If q a−→ q′ is new then a ∈ supp(q) and there exist b, q′′ such that q b−→ q′′ in A, b # q
(so a 6= b), and haiq′ = hbiq′′.

We check that ¯A has the requisite properties. First, the transition relation is clearly equivariant.
Moreover, ¯A is α-invariant by construction.

¯A is non-spontaneous: It sufﬁces to check new transitions q a−→ q′. By Fact A.22, we have
a ∈ supp(q) and b, q′′ such that q b−→ q′′ in A, b # q, and haiq′ = hbiq′′. Since A is non-spontaneous,
supp(q′′) ⊆ supp(q) ∪ {b}. Let c ∈ supp(q′) and c 6= a; we have to show c ∈ supp(q). Now
q′ = (ab) · q′′, so supp(q′) = (ab) · supp(q′′) ⊆ (ab) · (supp(q) ∪ {b}). Since haiq′ = hbiq′′, we have
b # q′, so c /∈ {a, b}; thus, c ∈ (ab) · (supp(q) ∪ {b}) implies c ∈ supp(q) ∪ {a}, hence c ∈ supp(q).
¯A is name-dropping: Let N ⊆ supp(q) for a state q, and let q|N restrict q to N in A; we show
that q|N also restricts q to N in ¯A. The support of q|N stays unchanged in ¯A, so we only have to
check that q|N retains the requisite transitions. Throughout, it sufﬁces to check new transitions.

For incoming transitions, let p a−→ q in ¯A be new, i.e. by Fact A.22 we have a ∈ supp(p), p b−→ q′
in A, b # p (hence a 6= b), and hbiq′ = haiq. Then (ab) · q = q′. Therefore, (ab) · (q|N ) restricts q′ to
(ab) · N in A by Lemma A.21. It follows that p b−→ (ab) · (q|N ) in A. Since a 6= b and hbiq′ = haiq,
we have a # q′ and therefore a # ((ab) · (q|N )), so hbi((ab) · (q|N )) = hai(q|N ) and therefore
p a−→ q|N by construction of ¯A.

For outgoing transitions, let q a−→ q′ be new in ¯A; i.e. by Fact A.22 we have a ∈ supp(q), q b−→ q′′
a−→ q′
in A, b # q (hence a 6= b) and hbiq′′ = haiq′. Since a ∈ supp(q), we have to show that q|N
in ¯A, assuming supp(q′) ∪ {a} ⊆ N . From b # q we have b # q|N , so by construction of ¯A, it
b−→ q′′ in A, which will follow once we show supp(q′′) ⊆ N ∪ {b}. So let
sufﬁces to show q|N
b 6= c ∈ supp(q′′); we have to show b ∈ N . Now a 6= b and hbiq′′ = haiq′ imply a # q′′, so
c 6= a and hence c /∈ {a, b}. Therefore c ∈ (ab) · supp(q′′) = supp((ab) · q′′) = supp(q′) ⊆ N , as
required.

¯A is equivalent to A: L(A) ⊆ L( ¯A) is immediate as A ⊆ ¯A by construction. For the reverse

inclusion, we show that2

2 For greater clarity we write L(A, q) for L(q) where q is a state in A.

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

25

(∗) whenever w ∈ L( ¯A, q) then there exists N ⊆ supp(q) such that if q|N restricts q to N
in A then w ∈ L(A, q|N )

(in fact, N will be such that |supp(q) − N | ≤ 1). Since supp(s) = ∅ for the initial state s, this
implies that L( ¯A) ⊆ L(A).

We prove (∗) by induction on w, with trivial induction base. So let w = av and q a−→ q′ in ¯A
where v ∈ L( ¯A, q′). By induction, there is N ⊆ supp(q′) such that v ∈ L(A, q′|N ) whenever q′|N
restricts q′ to N in A. If q a−→ q′ in A then q a−→ q′|N in A, so that av ∈ L(A, q). The remaining case
is that q a−→ q′ is new. By Fact A.22, we have a ∈ supp(q) and b, q′′ such that q b−→ q′′ in A, b # q
(so a 6= b), and haiq′ = hbiq′′. We claim that whenever q|Na restricts q to Na := supp(q) − {a} in
A then av ∈ L(A, q|Na). It sufﬁces to show

q|Na

a−→ q′|N in A.

(10)

Since a 6= b and haiq′ = hbiq′′, we have a#q′′ so from q b−→ q′′ in A we obtain supp(q′′) ⊆ {b}∪Na
b−→ q′′ in A (recall that
by non-spontaneity of A. By the deﬁnition of restriction, it follows that q|Na
a−→ q′, which
b # q). Since a /∈ supp(q|Na ) = Na, we obtain by equivariance of transitions that q|Na
implies (10) by the deﬁnition of restriction: we have q′ = (ab) · q′′ which implies

supp(q′) = (ab) · supp(q′′) ⊆ {a} ∪ (ab) · Na = {a} ∪ Na,

where the last step holds since a, b 6∈ Na.

◭

Additional proof details for Corollary 5.6. It is straightforward to verify that non-spontaneous
name-dropping NOFAs are closed under the standard product construction; speciﬁcally, given a state
(q1, q2) in a product automaton and N ⊆ supp(q1, q2) = supp(q1) ∪ supp(q2), one checks readily
that if qi|Ni restricts qi to Ni := N ∩ supp(qi) for i = 1, 2, then (q1|N1, q2|N2) restricts (q1, q2) to
N .

◭

Translation of FSUBAs into RNNAs

Let A be an FSUBA with set Q of state, set r of registers, initial state q0, set F of ﬁnal states,
transition relation µ ⊆ Q × r × Pω(r) × Q, and initial register assignment u; as indicated in
Section 5, we restrict the read-only alphabet Θ to be empty. We denote the A-language accepted
by A by L(A). We construct an equivalent RNNA R(A) as follows. The states of R(A) are the
conﬁgurations of A, which form a nominal set C under the group action π · (q, v) = (q, π · v). The
transitions of R(A) are given by

fsuc(q, v) = {(v(k), (p, eraseS(v))) | (q, k, S, p) ∈ µ}

∪ {(a, (p, eraseS(v[k 7→ a]))) | (q, k, S, p) ∈ µ, a ∈ supp(v), v(k) = ⊥}

bsuc(q, v) = {hai(p, eraseS(v[k 7→ a])) | (q, k, S, p) ∈ µ, a # v, v(k) = ⊥}

(11)
(12)
(13)

where eraseS clears the contents of the registers in S.

This RNNA R(A) behaves, under local freshness semantics, like the FSUBA A:

◮ Lemma A.23. The transitions between conﬁgurations of A are precisely given by (q, v)
(p, w), where (q, v) α−→ (p, w), α ∈ ¯A, is a transition in R(A).

ub(α)
−−−→

Proof. Let (q, v) α−→ (p, w) be a transition in the RNNA R(A). We distinguish cases:

For (11), we have an FSUBA transition (q, k, S, p) ∈ µ with α = v(k) ∈ A, and w = eraseS(v).
Hence we have a transition (q, v)

ub(α)
−−−→ (p, w) between FSUBA conﬁgurations.

26

Nominal Automata with Name Binding

For (12), we have an FSUBA transition (q, k, S, p) ∈ µ and v(k) = ⊥, α = v(i) ∈ A for some
i ∈ r, and w = eraseS(v[k 7→ v(i)]). Hence, from the FSUBA conﬁguration (q, v) the input v(i)
is read into register k and then the registers in S are cleared, i.e. (q, v) α−→ (p, w) is a transition
of FSUBA conﬁgurations.
For (13), i.e. for α = a, we have an FSUBA transition (q, k, S, p′) ∈ µ and v(k) = ⊥
and some b # v with hai(p, w) = hbi(p′, eraseS(v[k 7→ b])).
It follows that (ab)(p, w) =
(p′, eraseS(v[k 7→ b])), and equivalently, p = p′ and (ab)w = eraseS(v[k 7→ b]). The latter
implies that w = eraseS(v[k 7→ a]). Thus, we obtain a transition of FSUBA conﬁgurations
(q, v) a−→ (p, w) as desired.

Conversely, consider a transition (q, v)
(q, k, S, p) ∈ µ.

a−→ (p, w) of FSUBA conﬁgurations admitted by

a−→ (p, w) is a transition in R(A) by (11).
If v(k) 6= ⊥, then v(k) = a. Hence (q, v)
If v(k) = ⊥ and a ∈ supp(v), then (q, v) a−→ (p, w) is a transition in R(A) by (12).
If v(k) = ⊥ and a#v, then w = eraseS(v[k 7→ a]) and hai(p, w) ∈ bsuc(q, v). By α-invariance,
this implies (q, v) a−→ (p, w) in R(A).

◭

Using Lemma A.23, one shows by induction on w that L(A) = {ub(w) | w ∈ L0(R(A))}. The
RNNA R(A) in general fails to be name-dropping, but for any [ aw]α ∈ Lα(q, v), w ∈ ¯A∗, we have

(q, v) a−→ (p, v′), w ∈ Lα(p, v′) or

(q, v) a−→ (p, v′), w ∈ Lα(p, v′) :

(14)

b−→ (p′, v′′) in R(A) such that haiw =
Since [ aw]α ∈ Lα(q, v), we have some transition (q, v)
hbiw′ for some w′ ∈ Lα(p′, v′′); if we cannot α-equivalently rename the b-transition into an a-
transition to obtain the left alternative in (14), then b 6= a ∈ supp(v′′) and hence a ∈ supp(v), so
by construction of R(A) we obtain the right alternative in (14). By induction on w, it follows that
{ub(w) | w ∈ L0(q0, u)} = D(Lα(q0, u)), so that L(A) = D(Lα(R(A)), as claimed.
◭

Details for Remark 5.7 We show that the data language

L = {wava | w, v ∈ A∗, a ∈ A}

is not accepted by any DOFA. Assume for a contradiction that A is a DOFA that accepts L. Let n
be the maximal size of a support of a state in A. Let w = a1 . . . an+1 for distinct ai, and let q be
the state reached by A after consuming w. Then there is i ∈ {1, . . . , n + 1} such that ai /∈ supp(q).
Pick a fresh name b. Then δ(ai, q) is ﬁnal and δ(b, q) is not; but since δ(ai, q) = (aib) · δ(b, q), this
is in contradiction to equivariance of the set of ﬁnal states.

◭

A.5 Proofs and Lemmas for Section 6

Additional details for the proof of Theorem 6.1. We have omitted the space analysis of the
initialization step. To initialize Ξ we need to compute N2 = supp(Lα(s2)). This can be done in
nondeterministic logspace: for every free transition q a−→ q′ in A2, in order to decide whether or not
a ∈ Ns2, remove from the transition graph of A2 all transitions with label a and then check whether
there exists a path from s2 to a ﬁnal state passing through the given transition.

◭

Details for Remark 6.2 The spines of an NKA expression r arise by α-renaming and subsequent
deletion of some binders from expressions that consist of subexpressions of r, preﬁxed by at most
as many binders as occur already in r; therefore, the degree of the RNNA formed by the spines, and
hence, by Theorem 4.7 (and the fact that the translation from bar NFA to regular bar expressions

L. Schröder, D. Kozen, S. Milius, and T. Wißmann

27

is polynomial and preserves the degree), that of the arising regular bar expression, is linear in the
degree of r (speciﬁcally, at most twice as large).
◭
We shortly write D(w) = D(Lα(w)) = {ub(w′) | w′ ≡α w} for w ∈ ¯A∗.
◮ Lemma A.24. If w ⊑ w′ then D(w) ⊆ D(w′).

Proof. Induction over w, with trivial base case. The only non-trivial case in the induction step is
that w = av and w′ = av′ where v ⊑ v′. All bar strings that are α-equivalent to w have the form
au where v ≡α u; we have to show ub(au) ∈ D( av′). We have ub(u) ∈ D(v), so ub(u) ∈ D(v′)
by induction; that is, there exists ¯v′ ≡α v′ such that ub(¯v′) = ub(u). Then ub( a¯v′) = ub(au) and
a¯v′ ≡α av′, so au ∈ D( av′).

◭

Lemma 6.4 is immediate from the following:

◮ Lemma A.25. Let L be a regular bar language, and let w ∈ ¯A∗. Then D(w) ⊆ D(L) iff there
exists w′ ⊒ w such that [w′]α ∈ L.
Proof. ‘If’: If [w′]α ∈ L then D(w′) ⊆ D(L), so D(w) ⊆ D(L) by Lemma A.24.

‘Only if’: We generalize the claim to state that whenever

D(w) ⊆ [i∈I

D(Lα(qi))

for states qi in a name-dropping RNNA A and a ﬁnite index set I, then there exist i and w′ ⊒ w
such that [w′]α ∈ Lα(qi).

We prove the generalized claim by induction over w. The base case is trivial.

Induction step for words aw: Let D(aw) ⊆Sn

D(Lα(q′)).

D(w) ⊆

i=1 D(Lα(qi)). We prove below that

[

i∈I,qi

α−→q′,α∈{a, a}

(15)

Indeed, let u ∈ D(w), i.e. there exists v ≡α w with ub(v) = u. Then ub(av) = au and av ≡α aw
imply au ∈ D(aw), so by assumption there exists i ∈ {1, . . . , n} such that au ∈ D(Lα(qi)),
i.e. au = ub(α¯u) for α ∈ {a, a} and [α¯u]α ∈ Lα(qi). By Lemma 3.7, α¯u ∈ L0(qi). Therefore
α−→ q′ and ¯u ∈ L0(q′). We conclude that u = ub(¯u) ∈ D(Lα(q′)) as
there exists a transition q
desired.

Now, by induction hypothesis, it follows from (15) that we have i ∈ I, α ∈ {a, a}, qi

α−→ q′,

and w′ ⊒ w such that [w′]α ∈ Lα(q′). Then αw′ ⊒ aw and [αw′]α ∈ Lα(qi), as required.

Induction step for words aw: Let D( aw) ⊆Sn
D( aw) = [b=a∨b#[w]α

bD(πab · w)

i=1 D(Lα(qi)). Notice that

(where · denotes the permutation group action and πab = (a b) the transposition of a and b; also
note that b # [w]α iff b 6∈ FN(w)). Now pick b ∈ A such that b # [w]α and none of the qi has a
b-transition (such a b exists because the set of free transitions of each qi is ﬁnite, as A is an RNNA).
We prove below that

bD(πab · w) ⊆ [i∈I,qi

b−→q′

bD(Lα(q′)),

and hence we have

D(πab · w) ⊆ [i∈I,qi

b−→q′

D(Lα(q′)),

(16)

28

Nominal Automata with Name Binding

that bu ∈ D( aw). By our assumption D( aw) ⊆ Sn

again a ﬁnite union. In order to see that the above inclusion holds, let bu ∈ bD(πab · w), i.e., we have
v ≡α πab · w with ub(v) = u. Then bv ≡α b(πab · w) ≡α aw and ub( bv) = bu, which implies
i=1 D(Lα(qi)) we obtain i ∈ {1, . . . , n} such
that bu ∈ D(Lα(qi)), i.e. bu = ub(β ¯u) for β ∈ {b, b} and [β ¯u]α ∈ Lα(qi). By Lemma 3.7,
we have β ¯u ∈ L0(qi), and since qi has no b-transitions, we therefore know that β = b. Hence
b−→ q′ and ¯u ∈ L0(q′). It follows that u = ub(¯u) ∈ D(Lα(q′)), whence
we have a transition qi
bu ∈ dD(Lα(q′)) as desired.

Now, by induction hypothesis, we obtain from (16) i ∈ I, qi

b−→ q′, and w′ ⊒ πab · w such that

[w′]α ∈ Lα(q′). It follows that

bw′ ⊒ b(πab · w)

and [ bw′]α ∈ Lα(qi).

Now we have a # [πab · w]α (because b # [w]α)), and therefore a # [w′]α because πab · w ⊑ w′; it
follows that a(πab · w′) ≡α bw′. As ⊑ is clearly equivariant, we have πab · w′ ⊒ w, so

a(πab · w′) ⊒ aw and [ a(πab · w′)]α = [ bw′]α ∈ Lα(qi),

which proves the inductive claim.

◭

