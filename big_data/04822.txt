6
1
0
2

 
r
a

 

M
5
1

 
 
]
T
I
.
s
c
[
 
 

1
v
2
2
8
4
0

.

3
0
6
1
:
v
i
X
r
a

Centralized Repair of Multiple Node Failures

with Applications to Communication Eﬃcient

1

Secret Sharing

Ankit Singh Rawat, O. Ozan Koyluoglu, and Sriram Vishwanath

Abstract

This paper considers a distributed storage system, where multiple storage nodes can be reconstructed

simultaneously at a centralized location. This centralized multi-node repair (CMR) model is a generalization

of regenerating codes that allow for bandwidth-eﬃcient repair of a single failed node. This work focuses on

the trade-oﬀ between the amount of data stored and repair bandwidth in this CMR model. In particular,

repair bandwidth bounds are derived for the minimum storage multi-node repair (MSMR) and the minimum

bandwidth multi-node repair (MBMR) operating points. The tightness of these bounds are analyzed via

code constructions. The MSMR point is characterized through codes achieving this point under functional

repair for general set of CMR parameters, as well as with codes enabling exact repair for certain CMR

parameters. The MBMR point, on the other hand, is characterized with exact repair codes for all CMR

parameters for systems that satisfy a certain entropy accumulation property. Finally, the model proposed

here is utilized for the secret sharing problem, where the codes for the multi-node repair problem is used

to construct communication eﬃcient secret sharing schemes with the property of bandwidth eﬃcient share

repair.

Codes for distributed storage, regenerating codes, cooperative regenerating codes, centralized multi-

node regeneration, communication eﬃcient sercret sharing.

Index Terms

I. Introduction

The ability to preserve the stored information and maintain the seamless operation in the event of

permanent failures and (or) transient unavailability of the storage nodes is one of the most important issues

This paper was presented in parts at IEEE Information Theory and Applications Workshop, San Diego, CA, February 2016.

A. S. Rawat is with the Computer Science Department, Carnegie Mellon University, Pittsburgh, PA 15213 USA (e-mail:

asrawat@andrew.cmu.edu).

O. O. Koyluoglu is with the Department of Electrical and Computer Engineering, The University of Arizona, Tucson, AZ

85721 USA (e-mail: ozan@email.arizona.edu).

S. Vishwanath is with the Laboratory of Informatics, Networks and Communications, Department of Electrical and Computer

Engineering, The University of Texas at Austin, Austin, TX 78751 USA (e-mail: sriram@austin.utexas.edu).

March 16, 2016

DRAFT

2

that need to be addressed while designing distributed storage systems. This gives rise to the so called ‘code

repair’ or ‘node repair’ problem which requires a storage system to enable mechanism to regenerate (repair)

the content stored on some (failed/unavailable) storage nodes with the help of the content stored on the

remaining (live/available) nodes in the system. A simple replication scheme where one stores multiple copies

of each data block on diﬀerent nodes clearly enables the node repair as one can regenerate the data blocks

stored on a node by obtaining one of their copies from the other nodes in the system. However, replication

suﬀers from the decreasing rate as one increases the replication factor in order to enhance the resilience

of the system. This motives the use of erasure codes as they eﬃciently trade-oﬀ the storage space for the

ability to tolerate failure/unavailability of storage nodes. However, the better utilization of the storage space

should also be accompanied by a resource-eﬃcient node repair process and eﬃciency of the node repair

becomes a yardstick for implementing one erasure code over another.

Towards this, Dimakis et al. propose repair bandwidth, the amount of data downloaded from the contacted

nodes during the repair of a single node, as a measure of the eﬃciency of the repair process in [1]. Considering

n storage nodes where any set of k nodes are suﬃcient to reconstruct the entire information, Dimakis et al.

further characterize an information-theoretic trade-oﬀ among the storage space vs. the repair bandwidth

for such codes. The codes which attain any point on this trade-oﬀ are referred to as regenerating codes.

Over the past few years, the problem of designing regenerating codes has fueled numerous research eﬀorts

which have resulted into the constructions presented in [1], [2], [3], [4], [5] and the references therein.

In this paper, we explore the problem of enabling bandwidth eﬃcient repair of multiple nodes in a

centralized manner. In particular, we consider a setting where one requires the content of any k out of n

nodes in the system to be suﬃcient to reconstruct the entire information (as a parameter for the worst

case fault-tolerance of the system). As for the centralized repair process, we consider a framework where
the repair of t ≥ 1 node failures is performed by contacting any d out of the n − t remaining storage
nodes. We also assume that β amount of data from each of the d contacted nodes are downloaded. We aim

to characterize the storage vs. repair-bandwidth trade-oﬀ under this centralized multi-node repair (CMR)

framework.

We believe that this framework is more suitable for the setting of large scale storage systems where there

is a need to perform repairs at a central location. Our CMR model is perhaps useful for the following

scenarios: a) Architectural and implementation related issues: Architectural constraints could make it more

eﬃcient to regenerate the content in a centralized manner. For instance, in a rack-based node placement

architecture, a top-of-the-rack (TOR) switch failure would imply failure of nodes in the corresponding rack

to be unaccessible, and regenerating entire content of the failed rack on a per-node basis, i.e., independently

one by one, would be less eﬃcient as compared to regenerating the content at a central location, e.g., at a

leader node in that rack. b) Threshold-based data maintenance: These schemes regenerate servers after a

threshold number of them fail. After regenerating the content stored on the failed nodes, the administrator

can recruit t newcomers as replacements of the failed nodes and re-distribute the data to the newcomers

March 16, 2016

DRAFT

3

in order to restore the state of the system prior to the failures. c) Availability: In the event of transient

unavailability of the t storage nodes, the centralized repair process allows the user to get access the content

stored on the unavailable nodes in a bandwidth eﬃcient manner.

A. Related work

We note that the repair of multiple nodes in a bandwidth-eﬃcient manner has previously been considered

under the cooperative repair model introduced in [6], [7]. There are two major diﬀerences between the

cooperative and centralized repair frameworks: a) Under cooperative repair framework [6], [7], all t newcomer
nodes are not constrained to contact the same set of d out of n−t surviving nodes. The framework allows each
newcomer to contact any d surviving nodes independent of the nodes contacted by other t − 1 newcomers.
b) Under cooperative repair framework, after downloading data from the surviving nodes, the newcomers

exchange certain amount of data among themselves. On the other hand, since a centralized entity (e.g.,

the administrator or a master server node) has access to all the downloaded information, such information

exchange is not required in the centralized repair model. Our hope is that removing the additional restriction

imposed by the cooperative repair framework will enable designing codes for a broader range of system

parameters.

The problem of centralized bandwidth-eﬃcient repair of multiple node failures in a DSS employing has

previously been considered by Cadambe et al. [8]. However, they restrict themselves to only MDS codes and

they show existence of such codes only in the asymptotic regime where node size (amount of data stored

on a node) tends to inﬁnity.

In addition, locality, the number of nodes contacted during repair of a single node, is another measure of

node repair eﬃciency which have been extensively studied in the literature [9]. Various minimum distance

bounds and constructions achieving trade-oﬀs are presented in [9], [10], [11], [12] and the references therein.

In particular, recent works [13], [14], [15] have studied locality problem with multiple node repairs, which

is a model relevant to the framework studied in this paper.

Finally, in a recent work [16], Huang et al. proposed a model for communication eﬃcient secret sharing,

where the system stores a secret over n nodes (shares) with the property that accessing to any z shares

does not reveal any information about the secret, and accessing to any d shares does reveal the secret.

The framework [16] is similar to that of [1] in the sense that one contacts to more than enough number of

nodes (and download a partial data from each) in order to reduce the total amount of bits downloaded (to

reveal secret in the former, and to repair a node in the latter). Given this setup, [16] provides a bound on

required amount of communication to reconstruct the secret, constructs explicit coding schemes for certain

parameter regimes achieving the stated bound, and shows an existence result for general set of parameters.

More recently, [17] focuses on the same model and proposes codes that can achieve the bound provided

in [16] for general set of parameters. A separate body of work [18], [19], [10], [20], [21], [22] considers

secure regenerating codes, where eavesdropper accessing to a subset of nodes in the system does not get

March 16, 2016

DRAFT

4

any information about the stored data in the system. These works essentially focus on characterizing the

maximum amount of secret bits that can be stored within a system that employs a given regenerating code

(e.g., MSR/MBR). In this sense, these works consider a storage of data that is composed of both public

(without security constraints) and private (with security constraints) information, and a data collector

connects to a predeﬁned number of nodes to recover both types of information. Whereas, in [16], only the

reconstruction of the private information is the concern. In addition to this key diﬀerence, the eavesdropper

models in secure regenerating code papers also include eavesdroppers that can observe the data transferred

during node repairs1, whereas the framework in [16] does not consider repair problem. We note that

regenerating coding schemes which are secure against such eavesdroppers are presented in [18], [19], [10],

[20] and references therein. And, the problem of designing secure cooperative regenerating codes is explored

in [21], [22].

B. Contributions

The results of this work can be summarized as follows.

• We develop general repair bandwidth bounds for the CMR model at minimum per-node storage multi-

node repair and minimum bandwidth multi-node repair regimes, referred to as MSMR and MBMR

operating points respectively.

• We investigate tightness of the derived bounds with appropriate code constructions, and characterize the

fundamental limits of the CMR model. In particular, for the MSMR scenario, the fundamental limit is

characterized utilizing functional repair for all parameters. For special cases, explicit constructions that

achieve the stated bound are also provided. These constructions are based on cooperative regenerating

codes with minimum per-node storage (MSCR) codes as well as Zigzag codes. For the former set of

codes, we show a result that any MSCR code can be utilized as MSMR code achieving the stated

bounds. For the latter case, we show that multiple nodes can be repaired in Zigzag codes, and this

proposed repair process is bandwidth-wise optimal, achieving the derived bound in this paper.

• For the MBMR scenario, we deﬁne minimum repair bandwidth as the property of having amount

of downloaded data matching to the entropy of t nodes. For this setup, the fundamental limit is

characterized for systems having a certain entropy accumulation property. In addition, we obtain a

general mapping from minimum bandwidth cooperative regenerating (MBCR) codes to MBMR codes,

and, utilizing MBCR with a certain entropy accumulation property, we show achievability of the stated

bounds, characterizing the MBMR operating point in this special entropy accumulation case.

• Finally, we focus on the secret sharing problem, and show that the codes for the multi-node repair

problem can be transformed into communication eﬃcient secret sharing schemes that posses not only

1This eavesdropping model is important for non-MBR codes, as for MBR codes, the amount of downloaded content for a

node repair is same as the data stored in the node.

March 16, 2016

DRAFT

5

the reliability (for multi-node repairs) but also the security properties. We propose a secret sharing

mechanism with repairable shares that have the highest possible repair bandwidth-eﬃciency in the

multi-node failure setup. Adversarial attack setup is considered to provide secrecy.

II. Centralized multi-node repair model

We introduce a new model for simultaneous repair of multiple node failures in a distributed storage

system (DSS), namely centralized multi-node repair (CMR) model. Consider an (n, k)-DSS, i.e., the system

comprises n storage nodes and the content stored on any k nodes is suﬃcient to reconstruct the information

stored on the system. For an (n, k)-DSS, under (d, t)-CMR model, any set of t failed nodes in the system
can be repaired by downloading data from any set of d out of n − t surviving nodes. Let α denote the
size of each node (over a ﬁnite ﬁeld F) and β denote the amount of data downloaded from each of the
contacted d nodes under the (d, t)-CMR model. In order to denote all the relevant system parameters,

we also expand the notation for the CMR model as (n, k, d, t, α, γ)-CMR model or (d, t, α, γ)-CMR model.

After downloading γ = dβ symbols from the contacted nodes, the content stored on all t failed nodes is

recovered simultaneously in a centralized manner2.

III. A ﬁle size bound for the CMR model

In this section, we initiate the study of the trade-oﬀ between the per-node storage α and repair bandwidth

γ for the CMR model. We ﬁrst provide a ﬁle size bound for the CMR model.

Let the system store a uniformly distributed ﬁle f of size |f| = M (over a ﬁnite ﬁeld F). Consider the
case when the nodes indexed by a set K ⊆ [n] such that |K| = k are used to reconstruct the ﬁle f . Further,
assume that this set of nodes are partitioned into g number of distinct subsets Si with |Si| = ni ≤ t such
that

ni = k. We have the following bound.

g(cid:80)

i=1

Lemma 1. The system parameters necessarily satisfy

M ≤ g(cid:88)

min

(cid:110)
niα,(cid:0)d − i−1(cid:88)

(cid:1)β

(cid:111)

.

nj

Proof: Denoting the symbols stored on the nodes indexed by the set S by xS , we have

i=1

j=1

M = H(f )

(b)
=

g(cid:88)
(c)≤ g(cid:88)

i=1

i=1

(a)

= H(f ) − H(f|xK) = I(xK; f ) ≤ H(xK)
H(xSi|xS1:Si−1)

H(xSi),(cid:0)d − i−1(cid:88)

j=1

nj

(cid:1)β



min

(1)

(2)

(3)

(4)

2The CMR model also allow for the distributed/parallel repair of all the t failed nodes by t newcomers independently.

However, it is assumed that each of the t newcomers have an access to all the γ downloaded symbols.

March 16, 2016

DRAFT

(d)≤ g(cid:88)

i=1

min

niα,(cid:0)d − i−1(cid:88)

j=1

(cid:1)β

 ,

nj

6

(5)

where (a) is due to recoverability constraint H(f|xK) = 0 as |K| = k, (b) is due to K = ∪g
are due to the following bounds for each term in the sum: H(xSi|xS1:Si−1) ≤ H(xSi) ≤ niα, and

i=1Si, (c) & (d)

H(xSi|xS1:Si−1 )

(e)

= H(xSi|xS1:Si−1 )
− H(xSi|xS1:Si−1 , dHi−S1:Si−1)

= I(dHi−S1:Si−1; xSi|xS1:Si−1)

≤ H(dHi−S1:Si−1 ) ≤

d − i−1(cid:88)

j=1

 β

nj

where set of helper nodes to regenerate symbols in Si is denoted as Hi, this set of d nodes is constructed by
ni = k ≤ d),
using the sets S1 ···Si−1 and additional nodes not belonging to these sets (this is possible as

downloaded symbols from these additional nodes are denoted as dHi−S1:Si−1 with |Hi−S1 : Si−1| = d−i−1(cid:80)

nj,
and (e) follows as H(xSi|xS1:Si−1, dHi−S1:i−1 ) = 0 as H(xS|dH)=0 for any S such that |S| ≤ t and any H
such that |H| = d.

j

g(cid:80)

i=1

Given the bound in Proposition 1, we diﬀerentiate between two operating regimes of the system: Minimum

storage multi-node regeneration (MSMR) and minimum bandwidth multi-node regeneration (MBMR). The
MSMR point corresponds to having an MDS code which requires that α = M/k. Codes that attain minimum
possible repair bandwidth under this constraint, i.e., α = M/k, are referred to as MSMR codes. On the
other hand, the MBMR point restricts that H(xS ) = γ = dβ for every S ⊆ [n] such that |S| = t, i.e.,
the amount of data downloaded during the centralized repair of t node failures is equal to the amount of

information stored on the lost t nodes. MBMR codes achieve the minimum possible repair bandwidth under

this restriction, i.e., H(xS ) = γ = dβ. In the following, we focus on the problem of characterizing these two

operating points of the CMR model.

IV. MSMR Codes

We ﬁrst utilize Lemma 1 to obtain a bound on the repair bandwidth at the MSMR point, and then focus

on achievability.

A. Repair bandwidth bound
Proposition 1. Consider an (n, k)-DSS that stores a ﬁle of size M and enables repair of t failed nodes under
a (d, t, αM SM R = M

k , γ)-CMR model. Then, we have

March 16, 2016

γM SM R ≥ Mdt

k(d − k + t)

.

(6)

DRAFT

Proof: Let a = (cid:98)k/t(cid:99) and b = k − at. We set n1 = b and ni = t for i = 2,··· , g = a + 1. From the

bound (1), we obtain

M ≤ min{bα, dβ} +

a(cid:88)

i=1

min{tα, [d − (i − 1)t − b]β} .

(7)

Note that we have α = M

k which implies that dβ ≥ bα and

[d − (i − 1)t − b]β ≥ tα,∀i = 1,··· , a,

7

From this, we obtain β ≥ bα

(cid:27) (i)
d and [d − (a − 1)t − b]β ≥ tα, i.e., β ≥
γM SM R = dβ ≥ dα max

(cid:26)

=

t

d − k + t

,

b
d

where (i) follows from the fact that we have b < t ≤ k and α = M
k .

tα

[d−at−b+t] = tα

[d−k+t] . This implies that

Mdt

k(d − k + t)

,

Remark 1. Note that the same bound is also obtained by Cadambe et al. in [8] where they consider repair

of multiple failures in an MDS code.

Remark 2. A code that allows for repair of t failed nodes with the parameters(cid:0)d, t, α = M

(cid:1)-

k , γ = Mdt
k(d−k+t)

CMR is an MSMR code.

Proposition 2. The bound above (6) does not improve when helper nodes are allowed to contribute diﬀerent

amounts of data for regeneration of t nodes.

Proof: The proof follows from the steps given in [16]. Assume that the n nodes in the DSS are indexed
by the set [n]. Let’s consider a speciﬁc failure pattern, where the t nodes indexed by the set [t] ⊂ [n] are
under failure. Furthermore, we assume that the d nodes indexed by the set {t + 1, t + 2, . . . , t + d} are
contacted to repair the t failures under the centralized repair model. For j ∈ {t + 1, t + 2, . . . , t + d}, let sj
denote the symbols downloaded from the node indexed by j in order to repair the t failed nodes. Without

loss of generality, we can assume that3

|st+1| ≥ |st+2| ≥ ··· ≥ |st+d|.

(8)

Note that an (n, k)-coding scheme with α = M
k is an MDS coding scheme. Therefore, the content of the
nodes indexed by the set {t + 1, . . . , k} does not provide any information about the content of the failed
nodes, i.e., the nodes indexed by the set [t]. Therefore, in order to be able to repair the t failed nodes, we

need to have

t+d(cid:88)

j=t+k+1

|si| ≥ tα,

(9)

3Note that the proof holds even when we deﬁne βt = γt

d =

(cid:80)t+d
j=t+1 |sj|

d

, i.e., βt represents the average number of symbols

downloaded from each of the contacted nodes. In the special setting where we have each contacted node contributes the equal
number of symbols during the centralized node repair process, we have βt = |st+1| = · · · = |st+d|.

March 16, 2016

DRAFT

8

1

2

3

4

5

6

x0,0

x0,1

x0,2

x0,0 + x0,1 + x0,2

x0,0 + x6,1 + x2,2

x0,0 + x3,1 + x1,2

x1,0

x1,1

x1,2

x1,0 + x1,1 + x1,2

x1,0 + x7,1 + x0,2

x1,0 + x4,1 + x2,2

x2,0

x2,1

x2,2

x2,0 + x2,1 + x2,2

x2,0 + x8,1 + x1,2

x2,0 + x5,1 + x0,2

x3,0

x3,1

x3,2

x3,0 + x3,1 + x3,2

x3,0 + x0,1 + x5,2

x3,0 + x6,1 + x4,2

x4,0

x4,1

x4,2

x4,0 + x4,1 + x4,2

x4,0 + x1,1 + x3,2

x4,0 + x7,1 + x5,2

x5,0

x5,1

x5,2

x5,0 + x5,1 + x5,2

x5,0 + x2,1 + x4,2

x5,0 + x8,1 + x3,2

x6,0

x6,1

x6,2

x6,0 + x6,1 + x6,2

x6,0 + x3,1 + x8,2

x6,0 + x0,1 + x7,2

x7,0

x7,1

x7,2

x7,0 + x7,1 + x7,2

x7,0 + x4,1 + x6,2

x7,0 + x1,1 + x8,2

x8,0

x8,1

x8,2

x8,0 + x8,1 + x8,2

x8,0 + x5,1 + x7,2

x8,0 + x2,1 + x6,2

Fig. 1: Repair of the ﬁrst two systematic nodes in a (6, 3)-zigzag code. (Coding coeﬃcients of the parity

symbols are not speciﬁed.) Blue (red) colored symbols contribute in the repair of only node 1 (respectively,

2) in the case of single node failure. Green colored symbols contribute in the repair of both node 1 and

node 2 in the case of single node failure. Magenta colored symbols denote the additional symbols that need

to be downloaded to enable the centralized repair of both the nodes.

i.e., the amount of data downloaded from the remaining d + t − k contacted nodes should be at least the
amount of information lost due to node failures. Therefore, we have

t+k(cid:88)

j=t+d

γt =

|sj| (a)≥

d

d − k + t

t+d(cid:88)

|sj|

j=t+k+1

(b)≥

dtα

d − k + t

,

(10)

where (a) and (b) follow from (8) and (9), respectively.

B. Constructions and the characterization of the MSMR point

1) Constructions from existing MSCR codes: Minimum storage cooperative regenerating (MSCR) codes

allow for simultaneous repair of t storage nodes with the following scheme: Each newcomer node contacts

to d nodes and downloads β symbols from each. (Diﬀerent nodes can contact to diﬀerent live nodes.) Then,
each newcomer node sends β(cid:48) symbols to each other. Under this setup, the repair bandwidth per failed
node is dβ + (t − 1)β(cid:48). MSCR codes operate at αM SCR = M/k and βM SCR = β(cid:48)
Proposition 3. A code C that operates as an MSCR code is also an MSMR code for the CMR model.

M SCR = M

k(d−k+t) .

March 16, 2016

DRAFT

9

Proof: Consider that each failed node contact to the same set of d nodes in the MSCR code C. Then,
each failed node downloads βM SCR symbols from these d helper nodes, resulting in a total of at most
γ = tdβM SCR = Mdt
nodes in the CMR model. Therefore, code C is an MSMR code with α = M

k(d−k+t) symbols. These symbols can recover each failed node, hence regenerates t failed

k and γ = Mdt

k(d−k+t) .

We remark that random linear network coding attains MSCR point [6], hence it provides an MSMR code

with functional repair. Explicit code constructions for the MSCR setup while ensuring exact-repair, on the

other hand, are know for a small set of parameters. The only such constructions that we are aware of are

provided in [23] for k = t = 2, in [24] for t = 2 (for parameters (n, k, d) at which (n, k, d + 1) MSR codes

exist), and in [6] for d = k. We believe that moving from the cooperative repair model [6], [7] to the CMR

model would allow us to construct MDS codes (MSMR codes) that enable repair-bandwidth eﬃcient repair

of t nodes for an expanded set of system parameters. We exhibit this by designing a scheme to perform

centralized repair of multiple nodes in a distributed storage system employing a zigzag code [3].

2) Centralized repair of multiple node failures in a zigzag code [3]: The zigzag codes, as introduced in

[3], are MDS codes that allow for repair of a single node failure among systematic nodes by contacting
d = n − 1 (all of the) remaining nodes. The zigzag codes are associated with the MSR point [1] (or MSMR
point with t = 1 (cf. (6))) as each of the contacted d = n − 1 nodes contributes β = α
d−k+1 = α
n−k symbols
during the repair of a single failed node. This amounts to the repair bandwidth of γ = dβ = n−1
n−k α. Here,
we show that the framework of zigzag codes also enable repair of multiple nodes in the CMR model.

We state the achievable parameters in the following result. We then illustrate the proposed centralized

repair scheme with the help an example of an (n = 6, k = 3)-zigzag code where we can simultaneously

repair any 2 systematic nodes4.

Theorem 1. For an (n = k + r, k) zigzag code with r = n − k ≥ 2, it is possible to repair any 1 ≤ t ≤ 3
systematic nodes in a centralized manner with the optimal repair-bandwidth (cf. 6) by contacting d = n− t
helper nodes.

Proof: We provide the details of the repair process for 2 ≤ t ≤ 3 systematic nodes along with the

necessary background on zigzag codes in Appendix A.

Example 1 (Repairing t = 2 systematic nodes in a (6, 3)-zigzag code). Let’s consider a zigzag code with

the parameters n = 6, k = 3 and α = 9 from [3]. This code is illustrated in Table 1 where each column

(indexed from 1 to 6) represents a storage node. Recall that, in the event of a single node failure, this code
allows for the repair of any systematic node failure by contacting ˆd = 5 remaining nodes and downloading

β = α

n−k = 3 symbols from each of these nodes. We now show that we can use this same construction (with
required modiﬁcations of the non-zero coeﬃcients in coded symbols) to repair 2 systematic node failures

4In a parallel and independent work [25], the authors present a mechanism for repairing multiple failures in zigzag codes as

well. They show that the zigzag codes can repair any t ≤ n − k failures while achieving the lower bound in (6).

March 16, 2016

DRAFT

by contacting d = n − 2 = 4 remaining nodes. We download t
d = 4 contacted nodes.

α(cid:98)d−k+2

= 2 α

n−k = 6 symbols from each of the

Assume that node 1 and 2 are in failure. We download the colored symbols from node 3 to node 6 in

Figure 1 to repair these two nodes. Using the downloaded symbols, we get the following 18 combinations

in the 18 unknown information symbols. (We suppress the coeﬃcients of the linear combinations here.)

10

x0,0 + x6,1, x1,0 + x4,1, x2,0 + x2,1, x3,0 + x0,1,

x4,0 + x7,1, x5,0 + x5,1, x6,0 + x0,1, x7,0 + x7,1,

x8,0 + x5,1, x2,0 + x8,1, x1,0 + x7,1, x6,0 + x6,1,

x2,0 + x5,1, x7,0 + x4,1, x0,0 + x3,1, x8,0 + x2,1,

x1,0 + x1,1, x0,0 + x0,1.

(11)

Now, we need to show that it is possible to choose the coding coeﬃcients in such a manner that these
18 equations allow us to recover the desired 18 symbols. Assuming that A denotes the 18 × 18 coeﬃcient
matrix of the aforementioned 18 combinations, it is a necessary and suﬃcient (with large enough ﬁeld size)

condition for the matrix A to be full rank that the natural bipartite graph associated with the matrix A

contains a perfect matching5 [26], [27]. We illustrate one such perfect matching in (11), where the colored

unknown symbol in a combination represents the unknown symbol matched by that combination. The

similar argument can be performed for the remaining combinations of 2 failed systematic nodes.

3) MSMR point: The achievability results above together with the repair bandwidth bound reported in

the previous section, see Remark 2, results in the following characterization.

Theorem 2. The MSMR point for the (n, k, d, t, α, γ)-CMR model is given by

αM SM R =

M
k

,

γM SM R =

Mdt

k(d − k + t)

.

V. MBMR Codes

In this section, we focus on the other extremal point of the storage vs. repair-bandwidth trade-oﬀ, namely

the MBMR point.

A. Repair bandwidth bound

For the MBMR point, depending on whether t|k or t (cid:45) k, we state the following two results.

Proposition 4. Assume that t|k. Consider an (n, k)-DSS that stores a ﬁle of size M and enables repair of
t failed nodes under a (d, t, αM BM R, γM BM R)-CMR model. Then, denoting the entropy of t nodes as Ht,

5The left and the right nodes in the bipartite graph correspond to the combinations and the unknowns, respectively.

March 16, 2016

DRAFT

we have

tαM BM R ≥ Ht = γM BM R,
γM BM R ≥ M2dt

k(2d − k + t)

.

11

(12)

(13)

Proof: Note that the MBMR point has H(xS ) = γM BM R for every S ⊆ [n] such that |S| = t. Therefore,

we have

In order to establish the lower bound on γM BM R in (13), we use ni = t,∀i ∈ [a] in the bound (1), we obtain

γM BM R = H(xS ) ≤(cid:88)
k/t(cid:88)
(cid:0)d − (i − 1)t(cid:1)β =

i∈S

M ≤

i=1

H(xi) ≤ tαM BM R.

(cid:18) 2d − k + t

(cid:19)

2

k
t

β.

(14)

This implies that γM BM R = dβ ≥ M2dt
Proposition 5. Consider an (n, k)-DSS that stores a ﬁle of size M and enables repair of t failed nodes under
a (d, t, αM BM R, γM BM R)-CMR model. Then, the bounds given in (12) and (13) hold for the case of t (cid:45) k,

k(2d−k+t) .

if Hb ≥(cid:16) β

t

(cid:17)(cid:104)
b(cid:0) 2d+t−1

2

(cid:1)(cid:105)

(cid:1) −(cid:0)b

2

, where b = k (mod t), and Hb denotes entropy of b nodes in the system.

Proof: The bound in (12) follows from the similar analysis as presented in the proof of Proposition 5.
In order to establish (13), we select g = (cid:98)k/t(cid:99) + 1 = a + 1 disjoint sets of nodes indexed by the sets
S1,S2, . . . ,Sg such that n1 = |S1| = b and ni = |Si| = t for i ∈ {2, 3,··· , g = a + 1}. Note that we have
i ni = k. Utilizing this particular sequence of sets in (4) along with the fact that we have H(xSi) = dβ

(cid:80)

for 2 ≤ i ≤ g, we obtain

M ≤ min(cid:8)H(xS1), dβ(cid:9) +

a(cid:88)

(cid:0)d − (i − 1)t − b(cid:1)β

i=1

(cid:0)d − (i − 1)t − b(cid:1)β.

a(cid:88)

i=1

= H(xS1 ) +

2

aβ

(cid:18) 2d − k + (t − b)
(cid:19)

(cid:19)
(cid:19)
(cid:18) 2d − k + t
(cid:19)
(cid:18) 2d − k + (t − b)

aβ ≥ k
t

2

β −

β.

aβ

M ≤ Hb +

(cid:18) 2d − k + (t − b)
(cid:19) k
(cid:18) 2d − k + t

2

2

t

2

Hb ≥

Note that the choice of the set S1 is arbitrary and all the nodes in the system are equivalent in terms of
their information content. Therefore, Hb = H(S1) (the amount of information stored on b nodes indexed
by the set S1) only depends on b. It follows from (15) that

(15)

(16)

In order to have the bound in (13) we need the RHS of (16) to be at least the RHS of (14), i.e.,

Hb +

This implies that

March 16, 2016

DRAFT

(cid:19)(cid:20)

b

(cid:18) β

t

=

(cid:18) 2d + t − 1

(cid:19)

2

(cid:18)b

(cid:19)(cid:21)

2

.

−

12

(17)

Remark 3. A code that allows for repair of t failed nodes with Ht = γ = M2dt

the case of t|k and t (cid:45) k, if for the latter case the system also operates at Hb ≥(cid:16) β

(cid:17)(cid:104)
b(cid:0) 2d+t−1

k(2d−k+t) is an MBMR code for

(cid:1) −(cid:0)b

2

(cid:1)(cid:105)

.

t

2

B. Constructions and the characterization of the MBMR point

1) Constructions from existing MBCR codes: MBCR codes have αM BCR = M

2d+t−k ,
and β(cid:48) = M
2d+t−k . A construction of MBCR codes for all parameters is provided in [28], where the
entropy accumulation for MBCR codes is also characterized. In particular, entropy of b ≤ k nodes is given
by Hb =

b(cid:0) 2d+t−1

2d+t−k , β = M
2d+t−1

(cid:1)(cid:17)

(cid:16)

k

k

k

1

2

2

Proposition 6. A code C that operates as an MBCR code is also an MBMR code for the CMR model that
operates at α =

M(2d+t−1)

.

(cid:17)(cid:104)
b(cid:0) 2d+t−1

2

(cid:1) −(cid:0)b

2

(cid:1)(cid:105)

2

β.

(cid:1) −(cid:0)b
k(2d+t−k) and Hb ≥(cid:16) β
(cid:1)(cid:1) M

t

results in a repair bandwidth of at most γ = tdβM BCR = M2dt

Proof: Consider that each failed node contact to the same set of d nodes in the MBCR code C. This
k(2d+t−k) . Entropy of t nodes in this code is
k(2d+t−k) = γ. These and also the entropy of b nodes meet

given by Ht =(cid:0)t(cid:0) 2d+t−1

2d+t−k = M2dt

(cid:1) −(cid:0)t

k

2

2

2

the conditions stated in Remark 3, establishing the claimed result.
Remark 4. In general, for MBMR codes, we have the condition that tα ≥ Ht = γM BM R. It is not clear if
α can be further reduced than that in Proposition 6, e.g., when b = 0.

2) MBMR point: The achievability results above together with the repair bandwidth bound reported in

the previous section results in the following characterization.

Theorem 3. Let k (mod t) = b. Then, for the CMR models satisfying Hb ≥ (cid:16) β

t

(cid:17)(cid:104)
b(cid:0) 2d+t−1

2

(cid:1)(cid:105)

(cid:1) −(cid:0)b

2

, the

MBMR point is given by

Ht = γM BM R =

M2dt

k(2d + t − k)

.

VI. Applications to communication and repair eﬃcient secret sharing schemes

Recently, in [16], Huang et al. proposed a model for communication eﬃcient secret sharing. They consider
Q into N shares s1, s2, . . . , sN ∈ FQ. The encoding
a setting where one wants to encode a secret m ∈ FK
from secret to shares should satisfy two requirements: 1) Given any z shares one should not be able to
learn any information about the secret m and 2) given access to any d ≥ N − r shares one should be
able to reconstruct (or decode) the entire secret m. Huang et al. refer to such secret sharing schemes as

(N, K, r, z)Q secret sharing schemes. For a naive secret reconstruction process, one downloads Q symbols
over FQ from each of the d contacted shares leading to the communication bandwidth (the amount of data
downloaded for secret reconstruction) of dQ symbols over FQ. In [16], Huang et al. explore the minimum

March 16, 2016

DRAFT

possible communication bandwidth of an (N, K, r, z)Q secret sharing scheme as a function of the number

13

of shares participating in the reconstruction process d. Towards this end, the authors obtain the following
bound on the communication bandwidth of an (N, K, r, z)Q secret sharing scheme when N − r ≤ d ≤ N
shares are available during the reconstruction process6.
BWd ≥ d
d − z

(18)

K,

where the communication bandwidth is counted in terms of the number of symbols over FQ. Huang et al.
further present an explicit (N, K = N − r − z, r, z)Q secret sharing scheme which attain the bound in (18)
for d = k and d = N . They also show the existence of (N, K = N − r− z, r, z)Q secret sharing schemes which
attain the lower bound on the communication bandwidth for all values of d in {N − r, N − r + 1, . . . , N}.
Note that these secret sharing schemes are designed to work for a particular value d. However, it is also an

interesting question to design secret sharing schemes which simultaneously work for all the values of d. In
[17], Bitar and El Rouayheb present two explicit constructions which give (N, K = N − r − z, r, z)Q secret
sharing schemes with optimal communication bandwidth. The ﬁrst construction attains the bound in (18)
for any ﬁxed d and the second construction simultaneously attains the bound for N − r ≤ d ≤ N .

In this section, we show that the communication optimal (N, K, r, z)Q secret sharing schemes can be

designed using the codes which allow for centralized repair of multiple nodes. The added advantage of using

this approach to construct secret sharing scheme is that this method also enables bandwidth eﬃcient repair

of shares in the secret sharing scheme. This can also be viewed as an attempt to unify the study of repair

bandwidth eﬃcient codes for distributed storage and communication eﬃcient eﬃcient secret sharing. This

allows us to employ various ideas from the work on secure distributed storage literature to the setting of

communication eﬃcient secret sharing.

Let Ms be the size of the secret m (over Fq) that we want secure in the secret sharing scheme. We
further assume that each of the N shares in the secret sharing scheme consists of α symbols over Fq, i.e.,
we have FQ = Fqα . Note that Huang et al. deﬁne the sizes of the secret and the shares over the same
alphabet FQ = Fqα [16]. However, we denote the size of the secret over a base ﬁeld Fq and assume that
each share comprises a symbol from the extension ﬁeld FQ = Fqα. This representation is quite prevalent
in the distributed storage literature and is consistent with the rest of the paper as well. We represent the
secret sharing scheme as an (N,Ms, r, z)α,q or (N,Ms, r, z)α secret sharing scheme. First, we restate the
lower bound on the communication bandwidth of an (N,Ms, r, z)α secret sharing schemes (cf. (18)) in our
notations as follows.

where we count the communication bandwidth BWd in terms of number of symbols over the base ﬁeld Fq.

BWd ≥ d
d − z

Ms,

(19)

6In [16], the authors present this bound in terms of communication overhead COd which is the diﬀerence between the

communication bandwidth BWd and the size of the secret K.

March 16, 2016

DRAFT

14

Deﬁnition 1. (z-secure distributed storage system) Consider an (n, k)-DSS storing a ﬁle f s of size Ms (over
Fq) under the (d, t)-CMR model. We say that the DSS is z-secure if an eavesdropper who has access to the
content of any set of z (out of n) storage nodes does not gain any information about the ﬁle f s.

Remark 5. Recall that when there is no security requirement, we denote the ﬁle stored on the DSS and its
size as f and M (over Fq), respectively (cf. Section III). The quantity M − Ms denotes the loss in the ﬁle
size that the system has to bear in order to guarantee the information theoretic security of the stored ﬁle

against an eavesdropper. Or, this part of the data can be considered as public information (without any

secrecy constraints), as compared to the private counterpart (which has secrecy constraints).

The ﬁle size bounds for DSS which are secure against even a general eavesdropping model where an

eavesdropper can observe both the content stored on a set of nodes and the content downloaded during

the repair of another set of node have been previously considered in the literature. The regenerating coding

schemes which are secure against such eavesdroppers are presented in [18], [19], [10], [20] and references

therein. Similarly, the problem of designing secure cooperative regenerating codes is explored in [21], [22].

As discussed in Section IV and V, both regenerating codes and cooperative regenerating codes are speciﬁc

sub-classes of codes for centralized repair model. Therefore, both the secure regenerating codes and secure

cooperative regenerating codes which can prevent the leakage of information to an eavesdropper observing

the content stored on z-storage nodes form special cases of z-secure DSS under CMR model with respective

system parameters.

We can utilize z-secure coding scheme for DSS under the CMR model to obtain communication eﬃcient

secret sharing schemes. We ﬁrst illustrate this approach with the help of a secure MSR code in the following

subsection. We then comment on how this approach can be employed using general secure coding schemes

for DSS under the CMR model.

A. An example

Let C be a linear systematic code which operates at (n,M, d < n − 1, α = M

d−(z+1)+1 )q MSR
point. Note that this C is also an MDS code where the content of any k = z + 1 symbols is suﬃcient to
recover the entire ﬁle of size M. We next show how we can use C to construct a communication bandwidth
eﬃcient (N = n − 1,Ms = α = M

z+1 , r = N − z − 1, z)α secret sharing scheme.

z+1 , β =

α

Let m = (m1, . . . , mα) ∈ Fα

q denote the secret of size α over Fq. Let r = (r1, r2, . . . , rzα) ∈ Fzα

q using the MSR code C. Let (c1, c2, . . . , cn) = (m, r, cz+2, . . . , cn) ∈ Fn

q be zα
random symbols which are distributed uniformly at random over Fq. We encode the M = (z + 1)α-length
vector (m, r) ∈ FM
qα denote the
associated MSR codeword. Note that a code symbol, say ci, can be repaired by any set of d out of the
remaining n − 1 code symbols by downloading at most dβ =
d−zMs symbols (over Fq) from
the contacted d nodes. In order to obtain a secret sharing scheme we puncture the symbol c1 from each of
the codewords in C which gives us another code ˜C ∈ Fn−1

qα . Let ˜c = (c2, c3, . . . , cn) ∈ Fn−1

qα be the codeword

d

d−(z+1)+1 α = d

March 16, 2016

DRAFT

in ˜C which is obtained by removing the ﬁrst code symbol from the codeword c ∈ C. For the secret m we
treat n− 1 symbols in ˜c as N = n− 1 shares of the secret sharing scheme. In order to reconstruct the secret
m, we can invoke the node repair process of ﬁrst node (code symbol) in the original MSR code C where we
contact d shares and download β = α
d−k+1 from each of these d shares. This leads to the communication

bandwidth of

15

dβ =

d
d − z

Ms,

which matches the bound in (19). Using the MDS property 7 of ˜C, it is easy to argue that C is a z-secure
coding scheme. Note that besides reconstructing the secret m in a communication eﬃcient manner, the
proposed scheme also allows the bandwidth eﬃcient repair of any of the N = n − 1 shares by using d out
of N − 1 = n − 2 remaining shares. This can be performed again by invoking the repair mechanism of the
original MSR code C.

Fig. 2: Message puncturing from an MSR code gives communication eﬃcient secret sharing with repairable

shares.

B. Construction of communication and repair eﬃcient secret sharing schemes using MSMR codes

Generally, we can utilize an MSMR code to obtain a communication eﬃcient secret sharing scheme
which also enables bandwidth eﬃcient repair of the shares in the scheme. Let C be a systematic linear
d−k+t )q-MSMR code. Recall that this code encodes a ﬁle f of size M over
(n, k = z + t, d, t, α = M
Fq to an n-length codeword c = (c1, c2, . . . , cn) ∈ Fn

k , γ = tM

qα such that we have

k

d

ci = (f(i−1)α+1, f(i−1)α+2, . . . , fiα) ∈ Fα

q for 1 ≤ i ≤ k.

Using the code C, we now construct a communication eﬃcient (N = n − t,Ms = tα = tM
n − k − t, z)α secret sharing scheme. Let m ∈ FMs
(r1, r2, . . . , rzα) ∈ Fzα
Fq. We encode the M = (z + t)α symbols long ﬁle f = (m, r) ∈ F(z+t)α
(c1, c2, . . . , cn) ∈ Fn

q be zα independent random symbols which are distributed uniformly at random over
using the MSMR code C. Given c =
qα, the codeword associated with the ﬁle f in the MSMR code C, we puncture the codeword

z+t , r = N − z − t =
q denote the secret to be encoded. Let r =

q = Ftα

q

7Since C is an (n, z + 1) MDS code, it is straightforward to observe that ˜C is an (n − 1, z + 1) MDS code.

March 16, 2016

DRAFT

mc2c3cnc2c3cnat the ﬁrst t code symbols to obtain a punctured codeword ˜c = (˜c1, ˜c2, . . . , ˜cN ) = (ct+1, ct+2, . . . , cn) ∈ Fn−t
qα .
Assuming that ˜C denotes the codebook obtained by puncturing all the codewords in C at the ﬁrst t code
symbols, we have ˜c ∈ ˜C. We claim that ˜C gives us a (N = n − t,Ms = tα = tM
z+t , r = N − z = n − k, z)α
secret sharing scheme.

16

Fig. 3: Puncturing of the secret covering multiple symbols in an MSMR code gives communication eﬃcient

secret sharing with multi-share repair property.

• Security: Let’s consider an adversary who has access to z shares ˜ci1, ˜ci2, . . . , ˜ciz . We make two
observations: First, we have H(˜ci1 , ˜ci2, . . . , ˜ciz ) ≤ zα = H(r). Second, given m and ˜ci1, ˜ci2, . . . , ˜ciz
we have access to k = z + t code symbols of c ∈ C; as a result, we can decode r (by decoding
f = (m, r)) as C is an (n, k = z + t) MDS code. From these two observations, it follows that the
adversary does not get any information about the secret m from the z shares at its disposal [19], [10].
• Communication eﬃciency: Assume that we contact a set of d shares ˜ci1, ˜ci2, . . . , ˜cid . Since these d shares
form d code symbols in the codeword c of the MSMR code, we can use these d shares to recover the

secret m which constitutes the ﬁrst t code symbols of the code word c. Recall that we download total
γ = tM
equal to the lower bound on (19) which establishes the communication eﬃciency of the obtained secret

d−zMs symbols (over Fq) from the d shares we contact. Note that γ is exactly

z+t

d

d−(z+t)+t = d

sharing scheme.

Remark 6. Note that if we have d < N − t, by invoking the repair process of the original MSMR code
C, we can repair any t shares by contacting any set of d out of N − t remaining shares and downloading
d−zMs symbols from the contacted shares. We are not necessarily required to repair the shares in
γ = d

the group of t failed shares at a time. If the original MSMR coding scheme also allows for bandwidth

eﬃcient repair of less than t code symbols (nodes) at a time, then we can also repair less than t failed

shares at a time by using such repair mechanism. Speciﬁcally, in Section IV-B1 and IV-B2, we discuss some

constructions of MSMR codes that are obtained from MSR codes. Therefore, the secret sharing schemes

designed by these codes enable bandwidth eﬃcient repair of one share at a time as well.

March 16, 2016

DRAFT

m1m2mtct+1ct+2cnct+1ct+2cn17

C. Secret sharing schemes using MBMR codes

In this subsection, we illustrate how coding schemes at the MSMR point can be utilized to construct

communication and repair eﬃcient secret sharing scheme. Note that this allows us to increase the size of the

share in an MDS code in order to lower the repair bandwidth. Furthermore, this also allows us to construct

explicit secret sharing schemes for a wider set of parameters n, k, d, and α. Here we note that the MBMR

coding scheme that we employ in this subsection is from [28]. We deﬁne the following quantities.

M = k(2d + t − k) = (z + t)(2d + t − (z + t)) = (z + t)(2d − z)
Ms = t(2d + t − k − z) = t(2d + t − (z + t) − z) = 2t(d − z).

(20)

(21)

Given n, k = z + t and d, we construct an MBMR code as follows.

• Let {y1, y2, . . . , yn+d+t−1} ⊆ Fq be n + d + t − 1 distinct elements in Fq. Similarly, we select another

set of n + d − 1 distinct elements in Fq as {x1, x2, . . . , xn+d−1} ⊆ Fq.

• Given an M-length message vector f = (f1, f2, . . . , fM) ∈ FM

q

construct a bi-variate polynomial such

that

Here,

F (X, Y ) =

(cid:88)

0≤i<k,
0≤j<k

ai,jX iY j +

(cid:88)

0≤i<k,
k≤j<d+t

bi,jX iY j +

(cid:88)

k≤i<d,
0≤j<k

ci,jX iY j.

(22)

(a0,1, a0,2, . . . , ak−1,k−1, b0,k, b1,k, . . . , bk−1,d+t−1, ck,0, ck,1, . . . , cd−1,k−1) = Af

(23)

for an M × M matrix A with entries from Fq which we specify later.

• Given the polynomial F (X, Y ), the ith code symbol ci of the codeword associated with f in C is

obtained by evaluating F (X, Y ) at

{(xi, yi), (xi, yi+1), . . . , (xi, yi+d+t−1), (xi+1, yi), (xi+2, yi), . . . , (xi+d−1, yi)}.

That is, we have

ci =(cid:0)F (xi, yi), F (xi, yi+1), . . . , F (xi, yi+d+t−1), F (xi+1, yi), F (xi+2, yi), . . . , F (xi+d−1, yi)(cid:1) ∈ F2d+t−1

q

.

Remark 7. Note that the code symbol ci contains d + t evaluations of the degree-(d + t) polynomial
hi(Y ) = F (xi, Y ) at distinct points {yi, yi+1, . . . , yi+d+t−1}. Therefore, the content of ci is suﬃcient to
recover the polynomial hi(Y ) = F (xi, Y ). Similarly, ci contains d evaluations of the degree-d polynomial
gi(X) = F (X, yi) at distinct points {xi, xi+1, . . . , xi+d−1}. This implies that the content of ci is suﬃcient
to recover the polynomial gi(X) = F (X, yi).

Remark 8. In [28], Wang and Zhang show that this construction enables repair of any t code symbols

(nodes) under a cooperative repair framework. This implies that the coding scheme can also be utilized in

March 16, 2016

DRAFT

18

the centralized repair framework. As discussed in Section V-B, these codes operate at the MBMR point
with α = 2d + t − 1 and the repair bandwidth

M2dt

k(2d + t − k)

=

M2dt

(z + t)(2d − z)

.

γt =

(24)

The codeword associated with the information symbols f in C is described in Figure 4. Note that the
content of evaluations highlighted in Figure 4 form an information set as the original M information symbols
f can be reconstructed from the highlighted symbols [28]. Therefore, it is possible to precode the information
symbols f using an M × M matrix A (cf. (23)) such that the information symbols themselves appear at
the highlighted positions in the codewords of C. Note that this corresponds to a systematic encoding for
the code C.

q

We now describe how we can utlize the MBMR code described above to obtain a a communication eﬃcient
(N = n − t,Ms, d, r = N − z − t = n − z − 2t, z)α,q-secret sharing scheme. Let m = (m1, m2, . . . , mMs) ∈
be a Ms-length (over Fq) secret that needs to be encoded in the secret sharing scheme. Let r =
FMs
q be R = M − Ms = 2dz + zt − z2 i.i.d. random variables which are uniformly
(r1, r2, . . . , rR) ∈ FR
distributed over Fq. Given the Ms-length secret m, the (M − Ms)-length random symbols r and the
precoding matrix A, we construct the M-length information vector 8 f such that the secret m appears
in the code symbols cz+1, . . . , cz+t as described in Figure 4. In other words, there exists a permutation
σ : [Ms] → [Ms] such that we have

F (xz+1, yz+1) = mσ(1), F (xz+1, yz+2) = mσ(2), . . . , F (xz+1, yz+d+t−1) = mσ(d+t),

...

F (xz+t, yz+1) = mσ((t−1)(d+t)+1), F (xz+t, yz+2) = mσ((t−1)(d+t)+2), . . . , F (xz+t, yz+d+t−1) = mσ(t(d+t))

F (xz+t+1, yz+1) = mσ(t(d+t)+1), F (xz+t+1, yz+2) = mσ(t(d+t)+2), . . . , F (xz+t+1, yz+t) = mσ(t(d+t)+t),

...

F (xd, yz+1) = mσ((t−1)(d+t)+1), F (xd, yz+2) = mσ((t−1)(d+t)+2), . . . , F (xd, yz+t) = mσ(Ms),

(25)

where we have used the fact that Ms = 2t(d − z) in the last equality. Now, the encoding of the secret
m in the secret sharing scheme ˜C is obtained by puncturing the code symbols cz+1, cz+2, . . . , cz+t for the
codeword c ∈ C (cf. Figure 5). Thus, the N = n− t shares associated with the secret m in the secret sharing
scheme ˜C are deﬁned as

˜c = (˜c1, ˜c2, . . . , ˜cN ) = (c1, . . . , cz, cz+t+1, . . . , cn) ∈ FN
qα .

(26)

We now argue the security and the communication eﬃciency of the proposed secret sharing scheme.

8Each of the M symbols in the vector f comprises either a symbol from m or r. Moreover, each symbol of m and r appears

in exactly one coordinate of the vector f .

March 16, 2016

DRAFT

19

Fig. 4: Description of the MBMR coding scheme with a particular systematic encoding utilized in this paper.
Each node (code symbol) is collection of d + t and d evaluations of the univariate polynomials {hi(Y )} and
{gi(X)}, respectively. Note that the systematic encoding ensures that the random symbols r and the secret
symbols m appear in the ﬁrst z and the subsequent t code symbols, respectively.

March 16, 2016

DRAFT

Evaluationsofh1(Y)=F(x1,Y)Evaluationsofg1(Y)=F(X,y1)c1Evaluationsofhz(Y)=F(xz,Y)Evaluationsofgz(Y)=F(X,yz)czEvaluationsofhz+1(Y)=F(xz+1,Y)Evaluationsofgz+1(Y)=F(X,yz+1)cz+1Evaluationsofhz+t(Y)=F(xz+t,Y)Evaluationsofgz+t(Y)=F(X,yz+t)cz+tEvaluationsofhn(Y)=F(xn,Y)Evaluationsofgn(Y)=F(X,yn)cnRandomsymbolsrSecretsymbolsm20

Fig. 5: Puncturing of the secret covering multiple symbols in the MBMR code gives communication eﬃcient

secret sharing with multi-share repair property.

• Security: Assume that an adversary has access to z shares ˜ci1, ˜ci2, . . . , ˜ciz . Let these shares correspond to
the code symbols cj1, cj2, . . . , cjz in the associated codeword in the MBMR code C with {j1, j2, . . . , js} ⊂
[n]\{z + 1, . . . , z + t}. It follows from the Remark 7 that the adversary knows the following univariate
polynomials9.

(cid:8)hjs (Y ) = F (xjs, Y ), gjs(X) = F (X, yjs)(cid:9) for s = 1, 2, . . . , z.

(27)

It is argued in [21] that if e denote the symbols (in Fq) known to the adversary by observing z shares,
then we have

H(e) ≤ H(r) = M − Ms.

(28)

Next, we argue that given the observations of the adversary (cf. (27)) and the secret m, one can decode
the random symbols r, i.e., H(r|m, e) = 0. Note that the secret symbols m correspond to part of
the code symbols cz+1, . . . , cz+t. As highlighted in (25), the secret symbols m are evaluations of the
polynomial F (X, Y ) (cf. (22)). In particular, knowing the secret m translates to knowing d + t − z
evaluations of each of the polynomials in {hj(Y ) = F (xj, Y )}j=z+1,...,z+t and d− z evaluations of each
of the polynomials in {gj(X) = F (X, yj)}j=z+1,...,z+t (cf. (25)). Now, using the observations of the
adversary (cf. (27)), we can obtain z additional observations of each of the polynomials {hj(Y ) =

9Knowing a polynomial means that the adversary knows the coeﬃcients of the polynomials and can evaluate the polynomial

at any point in Fq

March 16, 2016

DRAFT

c1czcz+1cz+tcnRandomsymbolsrSecretsymbolsmc1czcz+t+1cnF (xj, Y ), gj(X) = F (X, yj)}j=z+1,...,z+t as follows.

hj(yjs) = F (xj, yjs ) = gjs (xj) for j ∈ {z + 1, . . . , z + t} and s ∈ {1, . . . , z}

and

gj(xjs ) = F (xjs, yj) = hjs(yj) for j ∈ {z + 1, . . . , z + t} and s ∈ {1, . . . , z}.

21

(29)

(30)

Therefore, given the observations of the adversary and the secret symbols one has access to k = z + t
code symbols cj1, . . . , cjs , cz+1, . . . , cz+t of the associated codeword in C. Now one can use a decoding
algorithm of C to decode Af and subsequently obtain f . Note that the random symbols r can now be
obtained as these symbols constitute M − Ms coordinates of the vector f .
From the two observations shown above that H(e) ≤ H(r) and H(r|e, m) = 0, it follows that the
adversary does not get any information about the secret m from the z shares it has access to [19], [10].
• Communication eﬃciency: Note that the secret m can be obtained by repairing t code symbols
cz+1, cz+2, . . . , cz+t in the associated codeword c ∈ C. Since C is an MBMR code, this repair process
can be performed by contacting a set of d shares say ˜ci1, ˜ci2, . . . , ˜cid and downloading total

γt =

(z + t)(2d − z)

M2dt

=

d
d − z

Ms

symbols (over Fq) from the d shares we contact (cf. 24). Comparing γt to the lower bound on (19)
establishes the communication eﬃciency of the secret sharing scheme based on the MBMR code from

[28].

Remark 9. Since the secret sharing scheme ˜C is obtained by puncturing t code symbols in the MBMR
code C. Assuming that the original MBMR code has d ≤ N − t = n − 2t, we can repair any t shares in a
bandwidth eﬃcient manner by invoking the repair mechanism of the MBMR code C. This repair process
would involve contacting any set of d out of remaining N − t shares and downloading γt = M2dt
symbols (over Fq) from the contacted shares.

(z+t)(2d−z)

The authors would like to thank Salim El Rouayheb for pointing us to the work by Cadambe et al. [8],

which includes a bound and an existential result on the repair of multiple failures in an MDS code.

Acknowledgememt

References

[1] A. G. Dimakis, P. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran. Network coding for distributed storage systems.

IEEE Trans. Inf. Theory, 56(9):4539–4551, 2010.

[2] K. Rashmi, N. Shah, and P. Kumar. Optimal exact-regenerating codes for distributed storage at the MSR and MBR

points via a product-matrix construction. IEEE Trans. Inf. Theory, 57:5227–5239, 2011.

[3] I. Tamo, Z. Wang, and J. Bruck. Zigzag codes: MDS array codes with optimal rebuilding. IEEE Trans. Inf. Theory,

59(3):1597–1616, 2013.

[4] D. Papailiopoulos, A. G. Dimakis, and V. Cadambe. Repair optimal erasure codes through hadamard designs. IEEE

Trans. Inf. Theory, 59(5):3021–3037, 2013.

March 16, 2016

DRAFT

22

[5] B. Sasidharan, G. K. Agarwal, and P. V. Kumar. A high-rate MSR code with polynomial sub-packetization level. CoRR,

abs/1501.06662, 2015.

[6] K. W. Shum and Y. Hu. Cooperative regenerating codes. IEEE Transactions on Information Theory, 59(11):7229–7258,

2013.

[7] A.-M. Kermarrec, N. Le Scouarnec, and G. Straub. Repairing multiple failures with coordinated and adaptive regenerating

codes. In Proc. of 2011 NetCod, pages 1–6, 2011.

[8] V. R. Cadambe, S. A. Jafar, H. Maleki, K. Ramchandran, and C. Suh. Asymptotic interference alignment for optimal

repair of mds codes in distributed storage. IEEE Transactions on Information Theory, 59(5):2974–2987, May 2013.

[9] P. Gopalan, C. Huang, H. Simitci, and S. Yekhanin. On the locality of codeword symbols. IEEE Trans. Inf. Theory,

58(11):6925–6934, 2012.

[10] A. S. Rawat, O. O. Koyluoglu, N. Silberstein, and S. Vishwanath. Optimal locally repairable and secure codes for distributed

storage systems. IEEE Trans. Inf. Theory, 60(1):212–236, 2014.

[11] G. M. Kamath, N. Prakash, V. Lalitha, and P. V. Kumar. Codes with local regeneration and erasure correction. IEEE

Trans. Inf. Theory, 60(8):4637–4660, Aug 2014.

[12] I. Tamo and A. Barg. A family of optimal locally recoverable codes. IEEE Trans. Inf. Theory, 60(8):4661–4676, Aug 2014.

[13] A. S. Rawat, A. Mazumdar, and S. Vishwanath. Cooperative local repair in distributed storage. EURASIP J. Adv. Signal

Process., pages 1–17, 2015.

[14] N. Prakash, V. Lalitha, and P. V. Kumar. Codes with locality for two erasures. In Proc. of 2014 IEEE International

Symposium on Information Theory (ISIT), pages 1962–1966, June 2014.

[15] W. Song and C. Yuen. Locally repairable codes with functional repair and multiple erasure tolerance. arXiv preprint

arXiv:1507.02796, 2015.

[16] W. Huang, M. Langberg, J. Kliewer, and J. Bruck. Communication eﬃcient secret sharing. CoRR, abs/1505.07515, 2015.

[17] Rawad Bitar and Salim El Rouayheb. Staircase codes for secret sharing with optimal communication and read overheads.

CoRR, abs/1512.02990, 2015.

[18] S. Pawar, S. El Rouayheb, and K. Ramchandran. Securing dynamic distributed storage systems against eavesdropping

and adversarial attacks. IEEE Transactions on Information Theory, 57(10):6734–6753, 2011.

[19] N. B. Shah, K. V. Rashmi, and P. V. Kumar. Information-theoretically secure regenerating codes for distributed storage.

In Proceedings of 2011 IEEE Global Telecommunications Conference (GLOBECOM), pages 1–5, 2011.

[20] K. Huang, U. Parampalli, and M. Xian. Characterization of secrecy capacity for general MSR codes under passive

eavesdropping model. CoRR, abs/1505.01986, 2015.

[21] O. O. Koyluoglu, A. S. Rawat, and S. Vishwanath. Secure cooperative regenerating codes for distributed storage systems.

IEEE Transactions on Information Theory, 60(9):5228–5244, Sept 2014.

[22] K. Huang, U. Parampalli, and M. Xian. Security concerns in minimum storage cooperative regenerating codes. CoRR,

abs/1509.01324, 2015.

[23] N. Le Scouarnec. Exact scalar minimum storage coordinated regenerating codes. In Proceedings of 2012 IEEE International

Symposium on Information Theory (ISIT), pages 1197–1201, 2012.

[24] J. Li and B. Li. Cooperative repair with minimum-storage regenerating codes for distributed storage. In Proc. of 2014

IEEE INFOCOM, pages 316–324, 2014.

[25] Z. Wang, I. Tamo, and J. Bruck. Optimal rebuilding of multiple erasures in MDS codes. CoRR, abs/1603.01213, 2016.

[26] L. Lov´asz. On determinants, matchings, and random algorithms. In Fundamentals of Computing Theory. Akademia-Verlag,

Berlin, 1979.

[27] N. Alon. Combinatorial nullstellensatz. Comb. Probab. Comput., 8(1-2):7–29, 1999.

[28] A. Wang and Zhang. Exact cooperative regenerating codes with minimum-repair-bandwidth for distributed storage. In

Proc. of 2013 IEEE INFOCOM, pages 400–404, 2013.

March 16, 2016

DRAFT

Zigzag codes: simultaneous repair of up to 3 failed systematic nodes

Appendix A

A. Description of the zigzag construction [3]

23

Let Zr denote the set {0, 1, . . . , r − 1}. Let e1, e2, . . . , em ∈ Zm

r denote the m standard m-dimensional
unit vectors. For i ∈ [m], the vector ei has all but one of its coordinates as zero. The vector ei has value
1 at its i-th coordinate. We use e0 ∈ Zm
to denote an m-dimensional all zero vector. For an integer in
[0, rm − 1] we associate a unique vector from Zm
symbols, encoding of an (n = m + 1 + r, k = m + 1) zigzag code works as follows.

r as its vector representation. Given (m + 1)rm information

r

• Arrange the (m + 1)rm information symbols in an rm × (m + 1) array. For j ∈ [m] and i ∈ [rm − 1], let
xi,j denote the (i + 1)-th information symbol in the (j + 1)-th column of the array. The k = (m + 1)

columns of the information array represent the k systematic nodes in the zigzag code construction.

• In order to generate r parity nodes, for every l ∈ [0, r − 1] and s ∈ [0, rm − 1], we deﬁne the zigzag set

Z l
s = {xi,j

: i + lej = s}.

(31)

Note that we use the vector representations of i, s ∈ [0, rm − 1] while deﬁning the set Z l
the zigzag set Z l
information symbols in the zigzag set Z l
elements (multiplicative group) of a large enough ﬁnite ﬁeld.

s, (s + 1)-th symbol stored on the (l + 1)-th parity node is linear combination of the

s. The coeﬃcients of the linear combinations belong to non-zero

s in (31). Given

1) Repair of a single systematic node in zigzag codes [3]: Here, we brieﬂy describe the repair mechanism
of a single systematic node in the zigzag code construction. For j ∈ [1, m] and l ∈ [0, r − 1], we deﬁne the
set

X l
j = {i ∈ [0, rm − 1]

: i · ej = r − l}.

(32)

Again, we use the vector representation of the integer j ∈ [0, rm − 1] while deﬁning the set X l
j = 0 and l ∈ [0, r − 1], we deﬁne the corresponding set X l

0 as follows.

j in (32). For

X l
0 = {i ∈ [0, rm − 1]

: i · (1, 1, . . . , 1) = l}.

(33)
For j ∈ [0, m], those informations symbols stored on the (j + 1)-th systematic node which are indexed by the
set X l
j are recovered by downloading the code symbols from the (l + 1)-th partiy node. From the remaining
k − 1 = m systematic nodes, we download those symbols which appear in the symbols downloaded from
the parity nodes. Combining the deﬁnitions in (31), (32) and (33), we obtain the following.

Proposition 7. For l ∈ [0, r − 1], let D1

l be the set deﬁned as follows.

D1
l = {i ∈ [0, rk−1 − 1]

: i · (1, 1, . . . , 1) = l}.

Furthermore, for j ∈ [1, k − 1] and l ∈ [0, r − 1], we deﬁne the set Dj+1

l

as follows.

Dj+1
l = {i ∈ [0, rk−1 − 1]

: i · ej = 0 (mod r)}.

March 16, 2016

(34)

(35)

DRAFT

24

Then, for j ∈ [0, k − 1] and l ∈ [0, r − 1], the set Dj+1
from (l + 1)-th parity node in order to repair the (j + 1)-th systematic node in the event of a single failure.

denotes the indices of the parity symbols downloaded

l

2) Structure of symbols downloaded to repair diﬀerent node in the even of a single node failure: In our
approach to repair t simultaneous node failures, we contact the remaining d = n − t nodes and download
n−k = rk−2
symbols in two stages. In the ﬁrst stage, for each of the failed t node, we download those
symbols from the contacted node which would have been downloaded to repair this node in the event of

α

single node failure. Since some of the symbols from a helper node contribute to the repair of many nodes

during the repair of a single node failure, we end up downloading less than tα
n−k symbols from each of the
d = n − k contacted node. Using the structure of the zigzag code, in the second stage, we then download
additional symbols from the helper nodes so that each helper node contributes exactly tα
n−k symbols. In
order to identify which symbols need to be downloaded in the second stage we need to understand the

structure of the parity symbols downloaded in the ﬁrst stage. Therefore, we ﬁrst explore this.

For the ease of exposition, without loss of generality, we assume that the ﬁrst t systematic nodes are in
failure, i.e., the systematic nodes indexed by the set [t] := {0, 1, . . . , t − 1} experience failure. The analysis
for other t systematic nodes can be carried out in a similar manner. Recall that for j ∈ [0, t − 1] and
l ∈ [0, r − 1], Dj+1
denotes the indices of the parity symbols downloaded from (l + 1)-th parity node to

repair the (j + 1)-th systematic node failure. The sets(cid:8)Dj+1

j∈[0,t−1], l∈[0,r−1] are deﬁned in Proposition 7.
It follows from the deﬁnition of these sets, that for any set of u out t failed nodes, say indexed by the set
{j1, j2, . . . , ju} ⊆ [0, t − 1], and l ∈ [0, r − 1], we have the following.
Dj+1
l = rk−1−u.

(cid:92)

(cid:9)

(36)

l

l

j∈{j1,j2,...,ju}

Given this observations, we now deﬁne the following families of sets. For {j1, j2, . . . , ju} ⊆ [0, t − 1] and
l ∈ [0, r − 1], we deﬁne the set U{j1+1,j2+1,...,ju+1}
to be the indices of the pairty symbols downloaded from
the (l + 1)-th parity node which participate in the repair of exactly u ≤ t systematic nodes indexed by the
set {j1, . . . , ju} in the event of single node failure. In particular, given S ⊆ [t] and l ∈ [0, r − 1],we have

l

l \ (cid:91)

Dj

(cid:92)

j∈S

US
l =

(cid:92)

S(cid:40)S(cid:48)⊆[t−1]

j∈S(cid:48)

Dj
l .

(37)

Combining (37) with the deﬁnitions of the sets {Dj+1

l

}j∈[0,k−1],l∈[0,r−1], we obtain that

1) Case 1: 1 ∈ S,

US
l = {i : i · (1, . . . , 1) = l; i · ew−1 = 0 ∀w ∈ S\{1}; and i · ev−1 (cid:54)= 0 ∀ v ∈ [t]\S} ⊆ [0, rk−1 − 1].
(38)

2) Case 2: 1 ∈ [t]\S,

l = {i : i · ew−1 = 0 ∀w ∈ S; i · (1, . . . , 1) (cid:54)= l; and i · ev−1 (cid:54)= 0 ∀ v ∈ [2, t]\S} ⊆ [0, rk−1 − 1].
US

March 16, 2016

(39)

DRAFT

Moreover, we have that

|US

l | − | (cid:91)

l | = |(cid:92)
= rk−1−|S|(cid:18)

Dj

j∈S

(a)

S(cid:40)S(cid:48)⊆[t]
1 − 1
r

(cid:92)
(cid:19)t−|S|

j∈S(cid:48)

,

Dj
l |

25

(40)

l

sets (cid:8)US

(cid:9)
where (a) follows from (38) and (39). Note that, by construction, for a ﬁxed l ∈ [0, r − 1], the family of
S⊆[0,t−1] comprises disjoint sets. In case of t = 3, for a ﬁxed value of l ∈ [0 : r − 1], this gives us
. Here, for j ∈ [0, 2],
denotes the indices of those symbols from the (l + 1)-th parity node which participate only in the

the following sequences of disjoint sets, U{1}
U{j+1}
repair of (j + 1)-th systematic node in the event of single node failure. The sets U (1,2)
symbols from (l + 1)-th parity node that participate only in the repair of 1st and 2nd systematic nodes in

represent the sets of

,U{1,2,3}

,U{1,2}

,U{2,3}

,U{1,3}

,U{2}

,U{3}

l

l

l

l

l

l

l

l

l

the event of single node failure. Similarly, the parity symbols from (l + 1)th parity nodes that enable repair
of each of the ﬁrst 3 systematic nodes in the event of a single node failure are represented by U (1,2,3)

.

l

We now characterize the sets of information symbols on the lost (failed) systematic nodes that participate

l }S⊆[t],l∈[0,r−1]. For a given j ∈ [0, k − 1], l ∈ [0, r − 1], and S ⊆ [t], let US

in the sets {US
j→l denotes the
indices of the symbols from the (j + 1)-th systematic node which participate in the parity symbols in the
set US
case.

l . Using (31) and (38), we can explicitly characterize these sets. In particular, we consider 3 diﬀerent

1) Case 1 (a) : j = 0 and 1 ∈ S,

= (cid:8)i ∈ [0, r − 1]k−1 : i ∈ US

(a)

US
j→l

l

(cid:9)

(b)

= {i : i · (1, . . . , 1) = l; i · ew−1 = 0 ∀w ∈ S\{1}; and i · ev−1 (cid:54)= 0 ∀ v ∈ [t]\S} ⊆ [0, rk−1 − 1].
(41)

2) Case 1 (b) : j = 0 and 1 ∈ [t]\S,

US
j→l = {i : i · ew−1 = 0 ∀w ∈ S; i · (1, . . . , 1) (cid:54)= l; and i · ev−1 (cid:54)= 0 ∀ v ∈ [2, t]\S} ⊆ [0, rk−1 − 1].
(42)

3) Case 2 (a) : j (cid:54)= 0 and {1, j + 1} ⊆ S,

US
j→l

(a)

= (cid:8)i ∈ [0, r − 1]k−1 : i + lej ∈ US
(cid:9)
= (cid:8)i : i · (1, . . . , 1) = 0; i · ej + l = 0; i · ew−1 = 0 ∀w ∈ S\{1, j + 1}; and
i · ev−1 (cid:54)= 0 ∀ v ∈ [t]\S(cid:9) ⊆ [0, r − 1]k−1.

l

(b)

4) Case 2 (b) : j (cid:54)= 0, 1 ∈ S and j + 1 ∈ [t]\S,

j→l=(cid:8)i : i · (1, . . . , 1) = 0; i · ew−1 = 0 ∀w ∈ S\{1}; i · ej + l (cid:54)= 0 and

US

i · ev−1 (cid:54)= 0 ∀ v ∈ [t]\{S ∪ {j + 1}}(cid:9) ⊆ [0, r − 1]k−1.

March 16, 2016

(43)

(44)

DRAFT

5) Case 2 (c): j (cid:54)= 0, 1 ∈ [t]\S and j + 1 ∈ S,

US

j→l=(cid:8)i : i · ej + l = 0; i · ew−1 = 0 ∀w ∈ S\{j + 1}; i · (1, . . . , 1) (cid:54)= 0; and
i · ev−1 (cid:54)= 0 ∀ v ∈ [2, t]\S(cid:9) ⊆ [0, r − 1]k−1.

6) Case 2 (d): j (cid:54)= 0 and {1, j + 1} ∈ [t]\S,

j→l=(cid:8)i : i · ew−1 = 0 ∀w ∈ S; i · (1, . . . , 1) (cid:54)= 0; i · ej + l (cid:54)= 0;

US

i · ev−1 (cid:54)= 0 ∀ v ∈ [2, t]\{S ∪ {j + 1}}(cid:9) ⊆ [0, r − 1]k−1.

and

B. Repairing t = 2 failed nodes

26

(45)

(46)

1) First stage of the download process: In the ﬁrst stage, we download the symbols which enable the
repair of 1st and 2nd systematic nodes in the event of single node failure. In particular, for l ∈ [0, r − 1],
we download the parity symbols indexed by the set
l = U{1}

D1
l ∪ D2

∪ U{1,2}

∪ U{2}

l

l

l

from the (l + 1)-th parity node. From the remaining k − 2 systematic nodes, we download those systematic
symbols which appear in these parity nodes.

U{1}

l

0→0,U{1}
U{1}

1→0 =

0→1,U{1}

1→1 =

0→r−1,U{1}
U{1}

1→r−1 =

Sets

l = 0



U{1,2}
1→1
U{1,2}
1→2
...
U{1,2}
1→r−1

 U{1}
 ,U{2}

1→0

U{2}
0→1 =



U{1,2}
0→1
U{1,2}
0→2
...
U{1,2}
0→r−1
U{1,2}
0→0 ,U{1,2}
1→0

l = 1



···

U{1,2}
1→0
U{1,2}
1→2
...
U{1,2}
1→r−1

 ···
 ,U{2}

···

1→1

···



U{1,2}
0→0
U{1,2}
0→2
...
U{1,2}
0→r−1
U{1,2}
0→1 ,U{1,2}
1→1

U{2}

l

U{2}
0→0 =

U{1,2}

l

l = r − 1





U{1,2}
1→0
U{1,2}
1→1
...
U{1,2}
1→r−2

 ,U{2}

1→r−1



U{1,2}
0→0
U{1,2}
0→1
...
U{1,2}
0→r−2
U{1,2}
0→r−1,U{1,2}
1→r−1

U{2}
0→r−1 =

TABLE I: Composition of parity symbols downloaded in the ﬁrst stage of the repair process to repair of 1st

and 2nd systematic nodes. Blue color symbols correspond to the matched symbols from the 1st systematic

node. Red color symbols represent the matched symbols from the 2nd system node.

We next illustrate a strategy to match the symbols from the failed systematic nodes using the downloaded

symbols illustrated in Table I. Formally, we have the following.

March 16, 2016

DRAFT

• Matching symbols from the 2nd systematic node using parity symbols (cid:8)U{1,2}

(cid:9): We use the symbols

27

for the (l + 1)-th parity node which are indexed by the set U{1,2}
2nd systematic node that are indexed by the set

l

to match those symbols from the

• Matching symbols from the 1st systematic node using parity symbols (cid:8)U{1}

U{1,2}
1→l = {i : i · (1, . . . , 1) = 0, i · e1 = r − l}.

(cid:9): We use the symbols

for the (l + 1)-th parity node which are indexed by the set U{1}
systematic node that are indexed by the set

l

to match those symbols from the 1st

l

l

• Matching symbols from the 1st and the 2nd systematic node using parity symbols (cid:8)U{2}

U{1}
0→l = {i : i · (1, . . . , 1) = l, i · e1 (cid:54)= 0}.

(cid:9): We use

l

the symbols for the (l + 1)-th parity node which are indexed by the set U{1}
from the 1st systematic node that are indexed by the set

l

to match those symbols

U{1,2}
0→l+1 = {i : i · (1, . . . , 1) = l + 1, i · e1 = 0}.

(47)

We use the remaining | U{2}
from the 2nd systematic node with the following indices.

1→l | − | U{1,2}

0→(l+1) |= (rk−2 − 2rk−3)) parity symbols to match the symbols

{i : i · (1, . . . , 1) /∈ {0, 1}, i · e1 = r − l} ⊆ U{2}

1→l = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = r − l}.

(48)

As it is clear from Table I and the matching processing described above, the following number of symbols

from the 2 failed nodes are matched by the parity symbols downloaded in the ﬁrst stage.

1) Number of symbols matched from 1st systematic node (blue colored):

0→l

r−1(cid:88)
(cid:124)

l=0
from U{1}

(cid:12)(cid:12)(cid:12)U{1}
(cid:12)(cid:12)(cid:12)
(cid:125)
(cid:123)(cid:122)
1→l|(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{1,2}
(cid:16)(cid:12)(cid:12)(cid:12)U{2}
(cid:12)(cid:12)(cid:12)(cid:17)
(cid:123)(cid:122)
(cid:125)

0→l+1

l

from U{2}

l

+

+

from U{2}

l=0

r−1(cid:88)
(cid:124)
r−1(cid:88)
(cid:124)

0→l+1

(cid:12)(cid:12)(cid:12)U{1,2}
(cid:123)(cid:122)
(cid:12)(cid:12)(cid:12)U{1,2}
(cid:12)(cid:12)(cid:12)
(cid:125)
(cid:123)(cid:122)

1→l

l

l=0
from U{1,2}

l

r−1(cid:88)
(cid:124)

l=0

= r ·(cid:0)rk−2 − rk−3(cid:1) + r · rk−3 = rk−1 = α.

(cid:12)(cid:12)(cid:12)
(cid:125)
= r ·(cid:0)rk−2 − 2rk−3(cid:1) + r · rk−3 = rk−1 − rk−2 = α − rk−2.

(49)

2) Number of symbols matched from 2nd systematic node (red colored):

2) Second Stage of download process:

• Unmatched symbols from the second systematic node : It follows from (50) that it remains to match
rk−2 symbols from the 2nd systematic node. This requires us to download additional symbols from the
intact nodes. Towards this, let’s consider the unmatched symbols from the second systematic node in

(50)

the (l + 1)-th parity node (cf. Table I). These are exactly those symbols among the symbols indexed
by the set U{2}

1→l which form linear combinations with the symbols indexed by the set U{1,2}

0→l+1. It can

March 16, 2016

DRAFT

28

be easily deduced from (48) that the unmatched symbols from the second systematic node have the

following indices.

R1→l = {i : i · (1, . . . , 1) = 1, i · e1 = r − l}

Another way to see this is as follows. Using (41), we know that

U{1,2}
0→l+1 = {i : i · (1, . . . , 1) = l + 1, i · e1 = 0}.

(51)

(52)

Utilizing the deﬁnition of the zigzag set (cf. (31)), the symbols from the ﬁrst systematic nodes which
are indexed by the set U{1,2}
indexed by the set

0→l+1 appear in those parity symbols in the (l + 1)-th parity node which are

{i : i ∈ U{1,2}

0→l+1} ⊆ [0 : rk − 1].

(53)

We again utilize the deﬁnition of the zigzag sets (cf. (31)) to identify the symbols from the second

systematic node that appear in those parity symbols from the (l + 1)-th parity node which are indexed

by the set deﬁned in (53). These are exactly the symbols indexed by the following set.

R1→l = {i : i · (1, . . . , 1) + l = l + 1, i · e1 + l = 0}

= {i : i · (1, . . . , 1) = 1, i · e1 = r − l}

(54)

• Additional symbols downloaded to match remaining symbols from the second systematic node : Now,

let’s consider an integer i∗ ∈ [0, rm − 1] = [0, rk−1 − 1] such that the following two conditions hold.
1) i∗ · (1, 1, . . . , 1) = 1. Note that we are using vector representation of i∗ in Zk−1

in deﬁning

r = Zm

r

this relationship.

2) i∗ · e1 = r − 1, i.e., the ﬁrst coordinate of the vector representation of i∗ takes the nonzero value

r − 1.

For j ∈ [2, k − 1], the set of additional symbols downloaded from the (j + 1)-th systematic node have
their row indices belonging to the following set.
S{1,2} = {i∗ + a1(e3 − e2) + a2(e4 − e2) + ··· + ak−3(ek−1 − e2) : (a1, . . . , ak−3) ∈ [r − 1]k−3}. (55)
Note that we have |S{1,2}| = rk−3. The reason behind this particular choice for the set S{1,2} will
become clear very soon. Now, let’s focus on the additional code symbols that need to be downloaded
from the parity nodes. For l ∈ [0 : r − 1], we download those parity symbols from the (l + 1)-th parity
node which involve the information symbols associated with the set S{1,2}. Recall that one can use
the deﬁnitions of the zigzag sets (cf. (31)) to identify these additional parity symbols that need to be

downloaded. In particular, for l = 0, the additional symbols downloaded from the 1st parity node have

their row indices belonging to the set

March 16, 2016

P{1,2}

0

= S{1,2}.

(56)

DRAFT

In general, for l ∈ [0, r − 1], the additional parity symbols downloaded from the (l + 1)-th parity nodes
have their row indices belonging to the following sets

29

l

P{1,2}

= S{1,2} + l · e2 = S{1,2} + l · e3 = ··· = S{1,2} + l · ek−1.

(57)
Now, let’s make sure if these additional parity symbols indexed by the sets {P{1,2}
}l∈[0:r−1] indeed
help us match the unmatched symbols from the second systematic node. Let’s ﬁrst consider the parity
symbols indexed by the set P{1,2}
using these parity symbols are the ones indexed by the set P{1,2}

. The symbols from the second systematic node which can be mathced

= S{1,2} ⊂ [0 : r − 1]k itself, i.e.,

0

l

0

{i : i · (1, 1, . . . , 1) = 1, i · e1 = r − 1}.

(58)

Note that these are exactly those symbol which remained unmatched as they appear together those
symbols from the ﬁrst systematic nodes that are indexed by the set U{1,2}
0→2 in the 2nd parity node, i.e.,
the symbols from the second systematic node which are indexed by the set R1→1 (cf. 54). Similarly, one
can show that the symbols from the second systematic node which can potentially be matched using

l

the additional symbols downloaded from the (l + 1)-th parity node, i.e., the parity symbols indexed by
the set P{1,2}

, are associated with the set.

(cid:8)i : i + le1 ∈ P{1,2}

(cid:9) = {i : i · (1, 1, . . . , 1) = 1, i · e1 = r − (l + 1)}.

l

(59)
Note that these are exactly those symbol denoted by the set R1→l+1. That is, the symbols from second
systematic node which remained unmatched as they appear together those symbols from the ﬁrst
systematic nodes that are indexed by the set U{1,2}

0→l+2 in the (l + 2)-th parity node.

C. Repairing t = 3 failed nodes

1) First stage of the download process: In the ﬁrst stage, we download the symbols which enable the
repair of the ﬁrst 3 systematic nodes in the event of single node failure. In particular, for l ∈ [0, r − 1], we
download the parity symbols indexed by the set

D1
l ∪ D2

l ∪ D3

l = U{1}

l

∪ U{2}

l

∪ U{3}

l

∪ U{1,2}

l

∪ U{2,3}

l

∪ U{1,3}

l

∪ U{1,2,3}

l

from the (l + 1)-th parity node. From the remaining k − 2 systematic nodes, we download those systematic
symbols which appear in these parity nodes.

• Matching symbols from ﬁrst and second systematic node using parity symbols(cid:8)U{1,2,3}

(cid:9): We use the

l

symbols for the (l + 1)-th parity node which are indexed by the set U{1,2,3}
from the third systematic node that are indexed by the set

l

to match those symbols

• Matching symbols from ﬁrst and second systematic node using parity symbols (cid:8)U{1,3}

U{1,2,3}
2→l = {i : i · (1, . . . , 1) = 0, i · e1 = 0, i · e2 = r − l}.

l

(cid:9): We propose

the following matching scheme for the symbols from the ﬁrst and the second systematic node. Given

March 16, 2016

DRAFT

Sets

U{1}

l

U{1}
0→0,




U{2}

l

U{3}

l

U{1,2}

l

U{2,3}

l

l = 0



U{1,2}
1→1
U{1,2}
1→2
U{1,2}
1→3

U{1,2}
1→r−1

.
.
.






,

U{1,2}
0→1
U{1,2}
0→2
U{1,2}
0→2

.
.
.

U{1,2}
0→r−1
U{1,3}
0→1
U{1,3}
0→2
U{1,3}
0→3
U{1,3}
0→4

.
.
.

U{1,3}
0→r−1



,




U{2,3}
1→1
U{2,3}
1→2
U{2,3}
1→3
U{2,3}
1→4

.
.
.




U{1,3}
2→1
U{1,3}
2→2
U{1,3}
2→3

.
.
.

U{1,3}
2→r−1
U{2,3}
2→1
U{2,3}
2→2
U{2,3}
2→3

U{2,3}
2→r−1

.
.
.



, U{3}
2→0



1→0 , U{2,3}
2→0

U{1,2}
0→0 , U{1,2}
1→0 ,



U{1,2,3}
0→1
U{1,2,3}
0→2
.
.
.

U{1,2,3}
0→r−1

U{2,3}
1→r−1
U{1,2,3}
2→1
U{1,2,3}
2→2
.
.
.

U{1,2,3}
2→r−1


 , U{2,3}


U{1,2,3}
1→1
U{1,2,3}
1→2
U{1,2,3}
1→3
U{1,2,3}
1→4
.
.
.

U{1,2,3}
1→r−1
, U{1,2,3}
1→0



l = 1



U{1,2}
1→0
U{1,2}
1→2
U{1,2}
1→3

U{1,2}
1→r−1

U{1}
0→1,




U{1,2}
0→0
U{1,2}
0→2
U{1,2}
0→3

.
.
.

U{1,2}
0→r−1
U{1,3}
0→0
U{1,3}
0→2
U{1,3}
0→3
U{1,3}
0→4

.
.
.

U{1,3}
0→r−1

.
.
.






,



,




U{2,3}
1→0
U{2,3}
1→2
U{2,3}
1→3
U{2,3}
1→4

.
.
.




U{1,3}
2→0
U{1,3}
2→2
U{1,3}
2→3

.
.
.

U{1,3}
2→r−1
U{2,3}
2→0
U{2,3}
2→2
U{2,3}
2→3

U{2,3}
2→r−1

.
.
.



U{1,2}
0→1 , U{1,2}
1→1 ,



U{1,2,3}
0→0
U{1,2,3}
0→2
.
.
.

U{1,2,3}
0→r−1



1→1 , U{2,3}
2→1

U{2,3}
1→r−1
U{1,2,3}
2→0
U{1,2,3}
2→2
.
.
.

U{1,2,3}
2→r−1


 , U{2,3}


U{1,2,3}
1→0
U{1,2,3}
1→2
U{1,2,3}
1→3
U{1,2,3}
1→4
.
.
.

U{1,2,3}
1→r−1
, U{1,2,3}
1→1

, U{1,2,3}

2→1



U{1,2,3}

l

U{1,2,3}
0→0

, U{1,2,3}

2→0

U{1,2,3}
0→1

, U{2}
2→1

· · ·

· · ·

· · ·

U{1}
0→r−1

,



l = r − 1
U{1,2}
1→0
U{1,2}
1→1
U{1,2}
1→2

,



.
.
.

U{1,2}
1→r−2

30







U{1,3}
2→0
U{1,3}
2→1
U{1,3}
2→2

.
.
.

U{1,3}
2→r−2
U{2,3}
2→0
U{2,3}
2→1
U{2,3}
2→2

.
.
.

U{2,3}
2→r−2

, U{2}

2→r−1

U{2,3}
1→0
U{2,3}
1→1
U{2,3}
1→2
U{2,3}
1→3

.
.
.








,




U{1,2}
0→0
U{1,2}
0→1
U{1,2}
0→2

.
.
.

U{1,2}
0→r−2
U{1,3}
0→0
U{1,3}
0→1
U{1,3}
0→2
U{1,3}
0→3

.
.
.

U{1,3}
0→r−2

U{1,2}
0→r−1



U{1,2,3}
0→0
U{1,2,3}
0→1
.
.
.

U{1,2,3}
0→r−2

, U{1,2}
1→r−1



U{1,2,3}
2→0
U{1,2,3}
2→1
.
.
.

U{1,2,3}
2→r−2

, U{2,3}
2→r−1

, U{1,3}
2→r−1

,

U{2,3}
1→r−2


 , U{2,3}


U{1,2,3}
1→0
U{1,2,3}
1→1
U{1,2,3}
1→2
U{1,2,3}
1→3
.
.
.

1→r−1



U{1,2,3}
1→r−2
, U{1,2,3}
1→r−1

U{1,2,3}
0→r−1

, U{1,2,3}
2→r−1

· · ·

· · ·

· · ·

· · ·

, U{2}
1→0,

, U{2}
1→1 ,

· · ·

, U{2}

1→r−1

,

U{1,3}

l

U{1,3}
0→0 ,

, U{1,3}
2→0

U{1,3}
0→1 ,

, U{1,3}
2→1

U{1,3}
0→r−1

,

TABLE II: Composition of parity symbols downloaded during repair of t = 3 node failures. Blue colored

symbols correspond to the matched symbols from the 1st systematic node. Red colored symbols represent

the matched symbols from the 2nd system node. Green colored symbols are used to denote the matched

symbols from the 3rd systematic node.

the parity symbols from the (l + 1)-th parity node which are indexed by the set U{1,3}
to match those symbols from the second systematic node which are indexed by the set

l

, we use them

U{1,2,3}
1→l+3 = {i : i · (1, . . . , 1) = 0, i · e1 = r − (l + 3), i · e2 = 0}.

(60)

This would allow us to use the remaining | U{1,3}
by the set U{1,3}

1→l+3 |= (r − 2)rk−4 parity symbols indexed
to match those symbols from the second systematic node which are indexed by the

| − | U{1,2,3}

l

l

March 16, 2016

DRAFT

31

following set.
{i : i · (1, . . . , 1) = l, i · e1 /∈ {0, r − 3}, i · e2 = 0} ⊂ U{1,3}

• Matching symbols from ﬁrst and third systematic node using parity symbols(cid:8)U{2,3}

(cid:9): We propose the

0→l = {i : i · (1, . . . , 1) = l, i · e1 (cid:54)= 0, i · e2 = 0}.
(61)

l

following matching scheme for the symbols from the ﬁrst and the second systematic node. Given the
parity symbols from the (l + 1)-th parity node which are indexed by the set U{2,3}
match those symbols from the ﬁrst systematic node which are indexed by the set

, we use them to

l

U{1,2,3}
0→l+1 = {i : i · (1, . . . , 1) = l + 1, i · e1 = 0, i · e2 = 0}.

(62)
0→l+1 |= (r − 2)rk−4 parity symbols indexed
to match those symbols from the third systematic node which are indexed by the

| − | U{1,2,3}

l

This would allow us to use the remaining | U{2,3}
by the set U{2,3}
following set.
{i : i · (1, . . . , 1) /∈ {0, 1}, i · e1 = 0, i · e2 = r − 2} ⊂ U{2,3}

l

• Matching symbols from second systematic node using parity symbols(cid:8)U{1,2}

(cid:9): Given the parity symbols

(63)

l

2→l = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = 0, i · e2 = 0}.

from the (l +1)-th parity node which are indexed by the set U{1,2}
from the second systematic node which are indexed by the set

l

, we use them to match those symbols

• Matching symbols from ﬁrst and third systematic node using parity symbols (cid:8)U{1}

U{1,2}
1→l = {i : i · (1, . . . , 1) = 0, i · e1 = r − l, i · e2 = 0}.

(cid:9): We utilize the

(64)

parity symbols from the (l + 1)-th parity node which are indexed by the set {U c
symbols from the third systematic node with the following indices.

{1}
l

to match the

U{1,3}
2→l+1 = {i : i · (1, . . . , 1) = 0, i · e1 (cid:54)= 0, i · e2 = r − (l + 1)}.
| − | U{1,3}

(65)
2→l+1 |= rk−4(r − 1)2 − rk−4(r − 1) unused parity symbols indexed by the
are used to match the symbols from the ﬁrst systematic appearing in those parity symbols.

• Matching symbols from ﬁrst and third systematic node using parity symbols(cid:8)U{2}

(cid:9): Using the parity

The remaining | U{1}
set U{1}

l

l

symbols from the (l + 1)-th parity node which are indexed by the set U{2}
the ﬁrst systematic node with the following indices.

l

, we match the symbols from

l

l

U{1,2}
0→l+2 = {i : i · (1, . . . , 1) = l + 2, i · e1 = 0, i · e2 (cid:54)= 0}.

(66)

(67)

In addition, we also use these parity symbols to match the symbols from the third systematic node

with the following indices.

(cid:98)U{2,3}
2→l+2 = {i : i · (1, . . . , 1) = 1, i · e1 = 0, i · e2 = r − (l + 2)} ⊂ U{2,3}
2→l+2.

March 16, 2016

(68)

DRAFT

0→l+2 | − | (cid:98)U{2,3}

32

This leaves us with | U{2}
2→l+2 |= rk−4(r − 1)2 − rk−4(r − 1) − rk−4 unused parity
symbols, which we use to match the symbols from the second systematic node appearing in those parity

| − | U{1,2}

l

symbols.

• Matching symbols from ﬁrst and third systematic node using parity symbols(cid:8)U{3}

(cid:9): Using the parity

l

symbols from the (l + 1)-th parity node which are indexed by the set U{3}
the second systematic node with the following indices.

l

, we match the symbols from

U{2,3}
1→l+2 = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = r − (l + 2), i · e2 = 0}.

(69)

In addition, we also use these parity symbols to match the symbols from the ﬁrst systematic node with

the following indices.(cid:98)U{1,3}

0→l+3{i : i · (1, . . . , 1) = l + 3, i · e1 = r − 3, i · e2 = 0} ⊂ U{1,3}
0→l+3.

(70)
We utilize the remaining | U{3}
0→l+3 |= rk−4(r − 1)2 − rk−4(r − 1) − rk−4 unused
parity symbols, which we use to match the symbols from the second systematic node appearing in

1→l+2 | − | (cid:98)U{1,3}

| − | U{2,3}

l

those parity symbols.

This concludes the ﬁrst stage of the downloading process and we have utilized all the parity symbols

downloaded in the ﬁrst stage to match certain systematic symbols corresponding to the three failed nodes.

We now move to the second stage of the download process where we download additional symbols in order

to match the remaining unmatched symbols associated with the three failed systematic nodes. We illustrate

our strategy to match the symbols from the failed systematic nodes using the downloaded symbols during

the ﬁrst stage in Table II. Let’s count the number of symbols from diﬀerent failed systematic nodes that

are matched according to Table II.

1) Symbols from 1st systematic node (blue colored):

0→l

(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{1,2,3}
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{1,3}
(cid:16)(cid:12)(cid:12)(cid:12)U{1,3}
(cid:12)(cid:12)(cid:12)(cid:17)
r−1(cid:88)
(cid:124)
(cid:123)(cid:122)
(cid:125)
=(cid:0)rk−2 − rk−3 − rk−3(cid:1) + rk−3 + rk−3 +(cid:0)rk−2 − rk−3(cid:1) +(cid:0)rk−1 − 2rk−2 + rk−3 − (rk−2 − rk−3)(cid:1)

(cid:12)(cid:12)(cid:12)U{1,2,3}
(cid:12)(cid:12)(cid:12)
(cid:125)
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12)U{1,2}
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12)(cid:98)U{1,3}
(cid:123)(cid:122)

(cid:16)(cid:12)(cid:12)(cid:12)U{1}

l=0
from U{2,3}

r−1(cid:88)
(cid:124)

r−1(cid:88)
(cid:124)

r−1(cid:88)
(cid:124)

r−1(cid:88)
(cid:124)

(cid:12)(cid:12)(cid:12)(cid:17)
(cid:125)

from U{1,3}

from U{1}

from U{2}

from U{3}

1→l+3

0→l+3

0→l+2

0→l+1

2→l+1

(cid:12)(cid:12)(cid:12)
(cid:125)

(cid:12)(cid:12)(cid:12)
(cid:125)

0→l

l=0

l=0

l=0

l=0

+

+

+

+

l

l

l

l

l

= rk−1 − (rk−2 − rk−3).

(71)

2) Symbols from 2nd systematic node (red colored):

1→l+3

r−1(cid:88)
(cid:124)

(cid:12)(cid:12)(cid:12)U{1,2}
(cid:12)(cid:12)(cid:12)
(cid:125)
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12)U{1,2,3}
(cid:12)(cid:12)(cid:12)
r−1(cid:88)
(cid:125)
(cid:123)(cid:122)
(cid:124)
= rk−3 +(cid:0)rk−2 − rk−3(cid:1) +(cid:0)rk−2 − rk−3)(cid:1) +(cid:0)(rk−1 − 2rk−2 + rk−3) − (rk−2 − rk−3) − rk−3(cid:1)

(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{1,2}
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)(cid:98)U{2,3}

(cid:12)(cid:12)(cid:12)U{2,3}
(cid:123)(cid:122)

(cid:16)(cid:12)(cid:12)(cid:12)U{2}

l=0
from U{1,3}

l=0
from U{1,2}

r−1(cid:88)
(cid:124)

r−1(cid:88)
(cid:124)

(cid:12)(cid:12)(cid:12)(cid:17)
(cid:125)

from U{3}

from U{2}

1→l+2

0→l+2

1→l+2

(cid:12)(cid:12)(cid:12)
(cid:125)

1→l

1→l

l=0

l=0

+

+

+

l

l

l

l

= rk−1 − rk−2.

March 16, 2016

(72)

DRAFT

3) Symbols from 3rd systematic node (green colored):

2→l

l=0

l

l

2→l

+

0→l+1

+

from U{2,3}

l=0
from U{1,2,3}

(cid:12)(cid:12)(cid:12)(cid:17)
(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{1,2,3}
(cid:16)(cid:12)(cid:12)(cid:12)U{2,3}
(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)U{1,2,3}
r−1(cid:88)
r−1(cid:88)
(cid:124)
(cid:124)
(cid:125)
(cid:123)(cid:122)
(cid:125)
(cid:123)(cid:122)
(cid:12)(cid:12)(cid:12)(cid:17)
(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)U{2,3}
(cid:12)(cid:12)(cid:12) −(cid:12)(cid:12)(cid:12)(cid:98)U{1,3}
(cid:16)(cid:12)(cid:12)(cid:12)U{3}
r−1(cid:88)
r−1(cid:88)
(cid:124)
(cid:124)
(cid:123)(cid:122)
(cid:125)
= rk−3 +(cid:0)(rk−2 − rk−3) − rk−3(cid:1) +
(cid:0)(rk−1 − 2rk−2 + rk−3) − rk−3 − (rk−2 − rk−3)(cid:1) +(cid:0)rk−2 − rk−3(cid:1) + rk−3

(cid:12)(cid:12)(cid:12)U{1,3}
(cid:123)(cid:122)

(cid:12)(cid:12)(cid:12)(cid:98)U{2,3}
(cid:123)(cid:122)

r−1(cid:88)
(cid:124)

l=0

from U{2}

l

from U{3}

l

from U{1}

l

1→l+2

+

2→l

0→l+3

2→l+1

+

1→l+2

l=0

l=0

(cid:12)(cid:12)(cid:12)
(cid:125)

(cid:12)(cid:12)(cid:12)
(cid:125)

33

(73)

= rk−1 − rk−2.

2) Second Stage of download process: First, let’s identify the unmatched systematic symbols at the end

of the ﬁrst stage of the downloading process.

• Unmatched symbols from the ﬁrst systematic node: The symbols from the second systematic node that

are matched using the parity symbols from the (l + 1)-th parity node are indexed by the set

U{1,3}
2→l+1 = {i : i · (1, . . . , 1) = 0, i · e1 (cid:54)= 0, i · e2 = r − (l + 1)}.

(74)

Using (31), we can identify the indices of the partiy symbols from the (l + 1)-parity node where these

symbols participate is as follows.

Z{1,3}
l,(2→l+1) = U{1,3}

2→l+1 + le2 = {i : i · (1, . . . , 1) = l, i · e1 (cid:54)= 0, i · e2 = r − 1}.

(75)

The symbols from the ﬁrst systematic node which remain unmatched at the end of ﬁrst stage (and

require downloading additional symbols) due to their participation in the parity symbols indexed by
the set Z{1,3}

l,(2→l+1) in the (l + 1)-th parity node are as follows.

R0→l = {i : i ∈ Z{1,3}

l,(2→l+1)} = {i : i · (1, . . . , 1) = l, i · e1 (cid:54)= 0, i · e2 = r − 1}.

(76)

• Unmatched symbols from the second systematic node: The symbols from the ﬁrst systematic node that

are (potentially) matched using the parity symbols downloaded from the (l + 1)-th parity node during

the ﬁrst stage are indexed by the following two sets.

U{1,2}
0→l+2 = {i : i · (1, . . . , 1) = l + 2, i · e1 = 0, i · e2 (cid:54)= 0}.
(cid:101)U{2,3}
2→l+2 = {i : i · (1, . . . , 1) = 1, i · e1 = 0, i · e2 = r − (l + 2)} ⊂ U{2,3}
2→l+2.

(77)

(78)

Using (31), we can identify the indices of the partiy symbols from the (l + 1)-parity node where these

symbols participate as follows.

(cid:101)Z{2,3}
l,(2→l+2) = (cid:101)U{2,3}

l,(0→l+2) = U{1,2}
Z{1,2}

0→l+2 = {i : i · (1, . . . , 1) = l + 2, i · e1 = 0, i · e2 (cid:54)= 0}.
2→l+2 + le2 = {i : i · (1, . . . , 1) = l + 1, i · e1 = 0, i · e2 = r − 2}.

(79)

(80)

DRAFT

March 16, 2016

The symbols from the second systematic node which remain unmatched at the end of ﬁrst stage (and

34

require downloading additional symbols) due to their participation in the parity symbols indexed by
the set Z{1,2}

l,(2→l+2) in the (l + 1)-th parity node are as follows.

l,(0→l+2)} = {i : i · (1, . . . , 1) = 2, i · e1 = r − l, i · e2 (cid:54)= 0}.
l,(2→l+2)} = {i : i · (1, . . . , 1) = 1, i · e1 = r − l, i · e2 = r − 2}.

(81)

(82)

l,(0→l+2) ∪ (cid:101)Z{2,3}
R1→l = {i : i + le1 ∈ Z{1,2}
(cid:101)R1→l = {i : i + le1 ∈ (cid:101)Z{2,3}

• Unmatched symbols from the third systematic node: The symbols from the second systematic node

that are (potentially) matched using the parity symbols downloaded from the (l + 1)-th parity node

during the ﬁrst stage are indexed by the following two sets.

U{2,3}
1→l+2 = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = r − (l + 2), i · e2 = 0}.
(cid:101)U{1,3}
0→l+3 = {i : i · (1, . . . , 1) = l + 3, i · e1 = r − 3, i · e2 = 0} ⊂ U{1,3}
0→l+3.

(83)

(84)

(85)

Using (31), we can identify the indices of the partiy symbols from the (l + 1)-parity node where these

symbols participate as follows.

l,(1→l+2) = U{2,3}
Z{2,3}
(cid:101)Z{1,3}
l,(0→l+3) = (cid:101)U{1,3}

1→l+2 + le1 = {i : i · (1, . . . , 1) (cid:54)= l, i · e1 = r − 2, i · e2 = 0}.

0→l+3 = {i : i · (1, . . . , 1) = l + 3, i · e1 = r − 3, i · e2 = 0}.

(86)

(87)

The symbols from the third systematic node which remain unmatched at the end of ﬁrst stage (and

require downloading additional symbols) due to their participation in the parity symbols indexed by
the set Z{2,3}

l,(0→l+3) in the (l + 1)-th parity node are as follows.

l,(1→l+2)} = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = r − 2, i · e2 = r − l}.
l,(0→l+3)} = {i : i · (1, . . . , 1) = 3, i · e1 = r − 3, i · e2 = r − l}

(88)

(89)

l,(1→l+2) ∪ (cid:101)Z{1,3}
R2→l = {i : i + le2 ∈ Z{2,3}
(cid:101)R2→l = {i : i + le2 ∈ (cid:101)Z{1,3}

We now describe the set of additional symbols downloaded to match the unmatched symbols from the

three failed systematic nodes (cf. (76), (81) and (88)).

• Additional symbols downloaded to match remaining symbols from the ﬁrst systematic node: Consider
a set of r − 1 integers I0 = {i0,1, . . . , i0,r−1} ⊂ [0, rk−1 − 1] such that the following two conditions hold.
1) i0,j · (1, 1, . . . , 1) = 1 ∀ j ∈ [r − 1].
2) i0,j · e1 = j for j ∈ [r − 1].
3) i0,j · e2 = r − 1 ∀ j ∈ [r − 1].
Note that we are using vector representation of the integers from the I0 in Zk−1
in order to deﬁne
these three requirements. For j ∈ [3, k−1], the set of additional symbols downloaded from the (j +1)-th
systematic node in order to match the remaining symbols from the ﬁrst systematic node have their

r

row indices belonging to the following set.

S{1,2,3}

0

= I0 + {a1(e4 − e3) + ··· + ak−4(ek−1 − e3) : (a1, . . . , ak−4) ∈ [r − 1]k−4}.

(90)

March 16, 2016

DRAFT

Note that we have |S{1,2,3}
(l + 1)-th parity nodes where these symbols appear. Let P{1,2,3}
symbols in the (l + 1)-th parity node. Then, from the deﬁnition of the zigzeg sets (cf. 31), we have that

| = (r − 1)rk−4. Next, we identify the set of the parity symbols in the
denote the indices of these parity

0,l

0

35

P{1,2,3}

0,l

0

+ le3 = S{1,2,3}

= S{1,2,3}
= {i : i · (1, . . . , 1) = l + 1, i · e1 (cid:54)= 0, i · e2 = r − 1}.

+ le4 = ··· = S{1,2,3}

0

0

+ lek−1

(91)

We can again use (31) to indentify the symbols from the second systematic node that appear in the
parity symbols from l + 1-th parity symbols that are indexed by the set P{1,2,3}

.

0,l

{i : i ∈ P{1,2,3}

} = {i : i · (1, . . . , 1) = l + 1, i · e1 (cid:54)= 0, i · e2 = r − 1}.

(92)
Note that this is exactly equal to R0→l+1 which is the indices of the unmatched symbols from the ﬁrst
systematic as they appeared in the parity symbols downloaded from the (l + 1)-th parity node during

0,l

the ﬁrst stage.

• Additional symbols downloaded to match remaining symbols from the second systematic node:

1) Consider a set of r − 1 integers I1 = {i1,1, . . . , i1,r−1} ⊂ [0, rk−1 − 1] such that the following two

conditions hold.
a) i1,j · (1, 1, . . . , 1) = 2 ∀ j ∈ [r − 1].
b) i1,j · e1 = r − 1 ∀ j ∈ [r − 1].
c) i1,j · e2 = j for j ∈ [r − 1].
Note that we are using vector representation of the integers from the I1 in Zk−1
in order to deﬁne
these three requirements. For j ∈ [3, k − 1], the set of additional symbols downloaded from the
(j + 1)-th systematic node in order to match the remaining symbols from the second systematic

r

node have their row indices belonging to the following set.

S{1,2,3}

1

= I1 + {a1(e4 − e3) + ··· + ak−4(ek−1 − e3) : (a1, . . . , ak−4) ∈ [r − 1]k−4}.

Note that we have |S{1,2,3}
(l + 1)-th parity nodes where these symbols appear. Let P{1,2,3}
symbols in the (l + 1)-th parity node. Then, from the deﬁnition of the zigzeg sets (cf. 31), we have

(93)
| = (r − 1)rk−4. Next, we identify the set of the parity symbols in the
denote the indices of these parity

1,l

1

that

P{1,2,3}

1,l

1

+ le3 = S{1,2,3}

= S{1,2,3}
= {i : i · (1, . . . , 1) = l + 2, i · e1 = r − 1, i · e2 (cid:54)= 0}.

+ le4 = ··· = S{1,2,3}

1

1

+ lek−1

(94)

We can again use (31) to indentify the symbols from the second systematic node that appear in
the parity symbols from l + 1-th parity symbols that are indexed by the set P{1,2,3}

.

1,l

{i : i + le1 ∈ P{1,2,3}

1,l

} = {i : i · (1, . . . , 1) = 2, i · e1 = r − (l + 1), i · e2 (cid:54)= 0}.

(95)

March 16, 2016

DRAFT

= ˜i1 + {a1(e4 − e3) + ··· + ak−4(ek−1 − e3) : (a1, . . . , ak−4) ∈ [r − 1]k−4}.

(96)

| = rk−4. Next, we identify the set of the parity symbols in the (l +1)-th
denote the indices of these parity symbols

(cid:101)S{1,2,3}

1

1

Note that we have |(cid:101)S{1,2,3}
parity nodes where these symbols appear. Let (cid:101)P{1,2,3}
+ le3 = (cid:101)S{1,2,3}

= (cid:101)S{1,2,3}

1,l

(cid:101)P{1,2,3}

1,l

Note that this is exactly equal to R1→l+1 which is the indices of the unmatched symbols from the
second systematic as they appeared in the parity symbols downloaded from the (l + 1)-th parity

node during the ﬁrst stage.

2) Consider an integers ˜i1 ∈ [0, rk−1 − 1] such that the following two conditions hold.

36

a) ˜i1 · (1, 1, . . . , 1) = 1.
b) ˜i1 · e1 = r − 1.
c) ˜i1 · e2 = r − 2.
For j ∈ [3, k − 1], we download additional symbols from the (j + 1)-th systematic node with their
row indices belonging to the following set.

in the (l + 1)-th parity node. Then, from the deﬁnition of the zigzeg sets (cf. 31), we have that

+ le4 = ··· = (cid:101)S{1,2,3}

1

+ lek−1
= {i : i · (1, . . . , 1) = l + 1, i · e1 = r − 1, i · e2 = r − 2}.

1

1

(97)

We can again use (31) to indentify the symbols from the second systematic node that appear in

the parity symbols from l + 1-th parity symbols that are indexed by the set (cid:101)P{1,2,3}

.

1,l

} = {i : i · (1, . . . , 1) = 1, i · e1 = r − (l + 1), i · e2 = r − 2}.

(98)

{i : i + le1 ∈ (cid:101)P{1,2,3}

1,l

Note that this is exactly equal to the unmatched symbols from the second systematic node denoted

by (cid:101)R1→l+1 (cf. (82)).

• Additional symbols downloaded to match remaining symbols from the third systematic node:

1) Consider a set of r − 1 integers I2 = {i2,1, . . . , i2,r−1} ⊂ [0, rk−1 − 1] such that the following two

conditions hold.
a) i2,j · (1, 1, . . . , 1) = j for j ∈ [r − 1].
b) i2,j · e1 = r − 2 ∀ j ∈ [r − 1].
c) i2,j · e2 = r − 2 ∀ j ∈ [r − 1].
Note that we are using vector representation of the integers from the I2 in Zk−1
in order to deﬁne
these three requirements. For j ∈ [3, k − 1], the set of additional symbols downloaded from the
(j + 1)-th systematic node in order to match the remaining symbols from the third systematic

r

node have their row indices belonging to the following set.

S{1,2,3}

2

= I2 + {a1(e4 − e3) + ··· + ak−4(ek−1 − e3) : (a1, . . . , ak−4) ∈ [r − 1]k−4}.

(99)

March 16, 2016

DRAFT

Note that we have |S{1,2,3}
(l + 1)-th parity nodes where these symbols appear. Let P{1,2,3}
symbols in the (l + 1)-th parity node. Then, from the deﬁnition of the zigzeg sets (cf. 31), we have

| = (r − 1)rk−4. Next, we identify the set of the parity symbols in the
denote the indices of these parity

2,l

2

37

that

P{1,2,3}

2,l

2

+ le3 = S{1,2,3}

= S{1,2,3}
= {i : i · (1, . . . , 1) (cid:54)= l, i · e1 = r − 2, i · e2 = r − 2}.

+ le4 = ··· = S{1,2,3}

2

2

+ lek−1

(100)

We can again use (31) to indentify the symbols from the third systematic node that appear in
the parity symbols from (l + 1)-th parity symbols that are indexed by the set P{1,2,3}
.
} = {i : i · (1, . . . , 1) (cid:54)= 0, i · e1 = r − 2, i · e2 = r − (l + 2)}.

(101)
Note that this is exactly equal to R2→l+2 which is the indices of the unmatched symbols from
the third systematic node as they appeared in the parity symbols downloaded from the (l + 1)-th

{i : i + le2 ∈ P{1,2,3}

2,l

2,l

parity node during the ﬁrst stage.

2) Consider an integers ˜i2 ∈ [0, rk−1 − 1] such that the following two conditions hold.

a) ˜i2 · (1, 1, . . . , 1) = 3.
b) ˜i2 · e1 = r − 3.
c) ˜i2 · e2 = r − 1.
For j ∈ [3, k − 1], we download additional symbols from the (j + 1)-th systematic node with their
row indices belonging to the following set.

= ˜i2 + {a1(e4 − e3) + ··· + ak−4(ek−1 − e3) (mod r) : (a1, . . . , ak−4) ∈ [r − 1]k−4}.

2

(cid:101)S{1,2,3}
Note that we have |(cid:101)S{1,2,3}
parity nodes where these symbols appear. Let (cid:101)P{1,2,3}
+ le3 = (cid:101)S{1,2,3}

= (cid:101)S{1,2,3}

(cid:101)P{1,2,3}

2,l

2

2,l

(102)
| = rk−4. Next, we identify the set of the parity symbols in the (l +1)-th
denote the indices of these parity symbols

in the (l + 1)-th parity node. Then, from the deﬁnition of the zigzag sets (cf. 31), we have that

+ le4 = ··· = (cid:101)S{1,2,3}

2

2

+ lek−1
= {i : i · (1, . . . , 1) = l + 3, i · e1 = r − 3, i · e2 = r − 1}.

2

We can again use (31) to indentify the symbols from the third systematic node that appear in

the parity symbols from l + 1-th parity symbols that are indexed by the set (cid:101)P{1,2,3}

{i : i + le2 ∈ (cid:101)P{1,2,3}

2,l

.
} = {i : i · (1, . . . , 1) = 3, i · e1 = r − 3, i · e2 = r − (l + 1)}.

2,l

Note that this is exactly equal to the unmatched symbols from the third systematic node denoted

by (cid:101)R2→l+1 (cf. (89)).

March 16, 2016

DRAFT

(103)

(104)

