On GitHub’s Programming Languages

Amirali Sanatinia, Guevara Noubir

College of Computer and Information Science

Northeastern University, Boston, USA

{amirali,noubir}@ccs.neu.edu

6
1
0
2

 
r
a

M
1

 

 
 
]
L
P
.
s
c
[
 
 

1
v
1
3
4
0
0

.

3
0
6
1
:
v
i
X
r
a

Abstract—GitHub is the most widely used social, distributed
version control system. It has around 10 million registered users
and hosts over 16 million public repositories. Its user base is
also very active as GitHub ranks in the top 100 Alexa most
popular websites. In this study, we collect GitHub’s state in
its entirety. Doing so, allows us to study new aspects of the
ecosystem. Although GitHub is the home to millions of users and
repositories, the analysis of users’ activity time-series reveals that
only around 10% of them can be considered active. The collected
dataset allows us to investigate the popularity of programming
languages and existence of pattens in the relations between users,
repositories, and programming languages.

By, applying a k-means clustering method to the users-
repositories commits matrix, we ﬁnd that two clear clusters of
programming languages separate from the remaining. One cluster
forms for “web programming” languages (Java Script, Ruby,
PHP, CSS), and a second for “system oriented programming”
languages (C, C++, Python). Further classiﬁcation, allow us to
build a phylogenetic tree of the use of programming languages
in GitHub. Additionally, we study the main and the auxiliary
programming languages of the top 1000 repositories in more
detail. We provide a ranking of these auxiliary programming
languages using various metrics, such as percentage of lines of
code, and PageRank.

I.

INTRODUCTION

GitHub is the most widely used social code hosting plat-
form, based on Git, a distributed version control system. It
introduces a social aspect
to software development where
users can browse, fork and even contribute to the projects
created and maintained by others. Such platform facilitates
agile development and has the potential to address problems
such as collaboration, communication, and code conﬂicts.
Furthermore, it provides a social platform similar to Twitter,
for users to interact. For example, users can follow another
user or mention them in discussions.

Currently, GitHub is the home to more than 10 million
registered users and over 16 million public repositories. It has
more users and hosts more projects than other source code
hosting platforms, such as SourceForge (324000 projects) [5],
Google Code (250000 projects) [3], or Launchpad (32000
projects) [4]. The number of users on GitHub has been increas-
ing exponentially until 2014. For instance, the number of users
created in 2013 and 2014, is twice more than the number of
users created from 2007 to 2012, combined. However, it seems
like 2014 is an inﬂection point in GitHub’s growth. GitHub is
ranked 98 on Alexa, as of May 2015. The majority of the
visitors [15] are from the United States (19.6%), followed by
India (15.5%), China (8.5%), Russia (3.3%) and Brazil (3.1%).
It
is a truly geographically diverse collaboration platform
where users can contribute to the development of open-source

software. Not only, it is a popular choice between developers,
scientists and hobbyist, even enterprises such as Lockheed
Martin, Microsoft, LivingSocial, VMware, and Walmart also
use GitHub [10].

GitHub is rising as a platform for social open-source
software development, and previous studies have looked at its
social aspects [18]. However, they are either limited to surveys,
or are based on a relatively smaller sample of repositories.
A body of literature [29], [28] mined software repositories
such as GitHub, but they had a smaller scope. To the best of
our knowledge we are the ﬁrst to thoroughly investigate the
programming languages relationship in Open Source Software
development on GitHub, we are also the ﬁrst to perform a
large scale analysis of GitHub’s dynamics, spanning 8 years of
contributions. From 2007, when the ﬁrst repository was created
by the ﬁrst registered user (co-founder, Tom Preston-Werner),
until the end of 2014. Such large scale holistic dataset allow
us to investigate research problems more conclusively.

In this work, we investigate the state of modern software
development. Today’s software is not only developed by pro-
fessional software engineers, but by a large diverse group of
users some of whom are considered amateur and hobbyist.
Modern software artifacts also use more than one programming
language, many of them utilize an array of programming
language to achieve different objectives. It is of paramount
importance to understand the relationship of programming
languages in software development. To shed light on these re-
search questions, we investigate correlations between program-
ming languages and repositories. Furthermore, we look at the
popularity of different programming language, and compare
the results to the tags on Stack Overﬂow [6], the Q&A website
dedicated to programming questions. Even more, we provide
a user-driven tree classiﬁcation of programming languages,
and discuss the underlying reasons for this phenomenon.
Additionally, we look at the set of programming languages
that are used in a repository in more detail. Based on these
observation we create the graph of relationship of auxiliary
programming languages, and rank them using different metrics
such as PageRank, and percentage of lines of code.

Our contributions are summarized as follows:
•

Collection of a large dataset mirroring the state of
GitHub, spanning 8 years of interactions (2007-2014);
consisting of around 10 million users, 16 million
repositories, 11 million user relationships, and over
3 billion contributions. We will make this dataset
publicly available to the beneﬁt of the research com-
munity.
A holistic analysis of GitHub’s ecosystem, growth

•

Fig. 1: Data collection system, with 200 crawler instance, an
index server and a storage server. The index server keeps track
of the progress of each crawler. The storage server writes
the data received from the crawler to persistent storage after
parsing it.

•

•

•

and adoption rate, based on the number of users and
repositories.
A detailed analysis of the top repositories, and the
identiﬁcation of the popular programming languages
on GitHub, and comparing the results with other
sources, such as Stack Overﬂow, and TIOBE [16].
Investigation of the correlation between different pro-
gramming languages, and hierarchical clustering of the
different languages and technologies using machine
learning techniques.
Derive a user-driven phylogenetic tree classiﬁcation of
programming languages based on the user-repository-
language interactions. Furthermore, we examine the
relationship between the main and auxiliary program-
ming languages in repositories.

The rest of the paper is organized as the following. In
section II we describe the data collection infrastructure and
methodology. Then, in section III we provide basic analysis
and statistics of GitHub’s ecosystem, and its growth pattern.
In section IV we investigate the relationship between program-
ming languages, and their clustering. Followed by an overview
of the related work in section V. In section VI, we overview the
future work; and ﬁnally, we conclude the work in section VII.

II. DATA COLLECTION: INFRASTRUCTURE AND

METHODOLOGY

We build our infrastructure to collect and analyze data
from GitHub. Although data collections such as GitHub
Archive [13] and GHTorrent [2] already exist, for the pur-
pose of our study,
these datasets are not sufﬁcient. Both
datasets only mirror the public events that happen on GitHub.
Therefore, it makes them limited as they do not provide a
holistic view of GitHub. We are interested in a holistic study
of GitHub. Furthermore, our data set ﬁlls the current gap
in the aforementioned data collections attempts. For example
both GitHub Archive and GHTorrent are available from 2012
onwards. One can extend the snapshot of our collection (as
the baseline), to the current state of GitHub, by interpolating

Fig. 2: The attributes collected for each entity (user and repos-
itory), and the relationship between users and repositories. A
user can own and contribute to repositories. Additionally, a
user can follow another user. Note that the attributes with a
star must have a value.

the events collected by GitHub Archive and GHTorrent. The
main challenge in collecting the state of GitHub, is the size
of data and the rate limit imposed by GitHub. An account and
IP address is limited to 5000 queries per hour. Since there
are more than 10 million users, 16 million repositories, and
5 million follower-followee relationships, collecting this data
with the rate limit would take months. We implemented and
deployed a resilient distributed collection system, consisting of
200 collection advantage points. This is a one time data col-
lection, and to avoid introducing substantial load on GitHub’s
server, we geographically spread the data collection advantage
points. We also implemented a backoff mechanism to address
the load issues. The following describes the data collection
infrastructure, methodology and the data that we collected.

GitHub provides a RESTful API (currently version 3) to
make queries about the users and repositories. The list of
current users can be queried at https://api.github.com/users,
and the list of current repositories is accessible at
https://api.github.com/repositories. More detailed information
about users and repositories can be obtained by making speciﬁc
GET queries for a repository or a user. The result is returned
in JSON format. Queries make use of paging to limit the
amount of data that is returned from the server. Figure 1,
shows a high-level description of our infrastructure. We divided
the number of users and repositories between our 200 data
collection advantage points. Each client
is responsible for
collecting a range of IDs. We use free public cloud system,
but unfortunately the free tier systems do not offer persistent
storage and the clients can crash or reboot. To address this
limitation we adapt our system to make it resilient to such
failures, by implementing an index server and a storage server.
The index server keeps track of the current ID for each data

Index ServerStorage ServerCrawler InstanceGithub.comuser+id*+login*+type*+name+orgs+company+blog+location+email+bio+hireable+public_repos*+public_gists+followers*+following*+created_at*+updated_at*repository+id*+name*+full_name*+owner_id*+owner_login*+fork*+created_at*+updated_at*+pushed_at*+size*+stargazers_count*+watchers_count*+forks_count*+open_issues_count*+language*+homepage+mirror_url+parent+source+owns+follows+contributescollection client. We implemented an in memory key-value
storage system that provides a RESTful API. At the beginning,
when a client starts, it queries the index server for the last ID
it has collected the data for. We use the IDs to keep track
of the users and repositories since the login names and the
repository names can change, however IDs stay the same.
Furthermore, IDs increment in order of user/repository creation
time. The IDs of the deleted users and repositories do not get
reused, therefore there can be gaps in the IDs. The clients
parse the JSON data received from GitHub and collect the
attributes for the users and the repositories. As mentioned
earlier, we implemented a number of ad-hoc techniques to
avoid overloading the GitHub’s servers. For example, we
introduce delayed request sequences, and backoff mechanisms
if the average response time from the server exceeds the
acceptable threshold. In the next step the clients send the
parsed data to the persistent storage system. Since the server
receives a large amount of trafﬁc from 200 clients, it keeps
a queue for the incoming data and a worker processor reads
the data in the queue, and writes it into the persistent storage.
We serialize the data and write it to a ﬂat ﬁle. Later, in the
processing stage, another script would create a dataset based on
the arguments that we need to analyze. Using this mechanism
allows us to avoid loading the entire data set into the volatile
memory. During the processing stage records are loaded and
evicted linearly. We only collect the main attributes, and we
infer the other attributes based on the collected data. For users,
we collect name, ID, number of public repositories
and creation time among other features. For repositories,
we store metadata such as the owner, owner, number of
stars and creation time. Figure 2 depicts the features
that we collected for users and repositories and the relationship
between the entities. Note that the attribute with a star, must
have a value. The remaining attributes are free text entries and
can be empty.

III. ANALYSIS OF GITHUB’S ECOSYSTEM

In this section we start by a discussion of macro-statistics
of GitHub. Later, in the following section we delve deeper
into different aspects of the aforementioned ecosystem. In
our dataset there are around 10 million (9993767) users and
around 17 million (16812452) repositories. Figure 3, shows
the histogram of users joining GitHub, at different months
from 2007 to 2014. As we can see, the number of users has
been increasing exponentially until 2014. For instance, the
number of users created in 2013 and 2014, is twice more than
the number of users created from 2007 to 2012, combined.
However, it seems like 2014 is an inﬂection point in GitHub’s
growth, and the number of newly registered users in 2014, is
only 30% more than 2013. This trend follows the diffusion
of innovation [30] principle, and the late majority are joining
now. The large majority (about 95%, 9533220 out of 9993767)
of these accounts are “Users”, and the rest (460547), are
“Organizations”.

As expected the number of users registering on GitHub in
December is lower than the previous two months, because of
the holidays. The sudden increase in the number of new users
in 2012, can partially be explained by non technical events and
the press coverage that GitHub received in 2012. For example
the co-founders PJ Hyett and Chris Wanstrath were named 30
under 30 by Forbes [8], GitHub won the “Best Overall Startup”

award by TechCrunch [14] and was selected in the Forbes’ top
10 startups [9]. Furthermore, in 2012 Andreessen Horowitz (4
billion dollar venture capital ﬁrm founded by Marc Andreessen
and Ben Horowitz), invested 100 million dollars in GitHub,
which was also the ﬁrst ever outside investment [12]. As we
can also see from the data, 2012 has been a critical year in
GitHub’s success and popularity. Our data set shows how such
socioeconomic external factors had impact on the growth and
success of GitHub.

The repositories are written in more than 220 different pro-
gramming languages. Note that these programming languages
are based on GitHub’s deﬁnition of programming languages.
For instance, Makefile and Batchfile are also consid-
ered languages in GitHub’s deﬁnition. The top 5 programming
languages in terms of number of repositories, in order are: Java
Script, Java, Ruby, Python, and PHP. As Figure 4 depicts, the
exponential growth rate of the repositories. The number of
repositories created in years 2007 to 2012, combined, is less
than number of repositories created in 2013, and less than
half of the repositories created in 2014. This observation is in
harmony with the observation on the adoption of GitHub by the
users. More than 55% of the repositories are original (7304258
repositories are fork and 9508194 are original). Meaning these
are not a direct fork of another repository on Gihub, though
they can be a re-upload of another repository. Only 8603 of the
forked repositories outshine their source repository, in terms
of number of stars. Meaning a fork having more stars than its
source. However, the gap is marginal and not signiﬁcant. The
distribution of the stars is uneven and follows the power law
characteristics, where a very small fraction takes the majority
of resources. For example, 80% of the repositories have no
stars, and 99% of the repositories have 13 stars or less. Even,
after excluding the projects with no stars, still, 95% of the
remaining repositories have 13 stars or less.

To shed light on the nature of GitHub’s programming lan-
guages, we analyze repositories in more detail in the following
section.

A. Delving into the Repositories

In this section we investigate what are the top 10 pro-
gramming languages, by interpolating the number of stars for
repositories in GitHub. Stars in GitHub are equivalent of “like”
in social platforms such as Facebook. The other metrics that we
look at our the overall number of commits, size of software
artifacts repositories (bytes), overall number of repositories,
and overall number of forks. We also compare the results to
the rankings provided by TIOBE and Stack Overﬂow. As we
can see in Table I, Java Script is by a far margin on the
top of the list followed by Ruby and Python, even though
Java is the top programming language according to Stack
Overﬂow and TIOBE. Note that Stack Overﬂow is based on the
number of questions that are asked in a different programming
language, meanwhile, we are using a popularity measure. It is
not surprising that Java is ranked number one according to
Stack Overﬂow, given that simply reading from a ﬁle requires
substantially more lines of code, compared to e.g., Python (1
line of code).

The other top 3 programming language that are not in
our top 10 popular languages are: C#, Perl and R. The

Fig. 3: Histogram of creation of users on GitHub. As we can see, the number of users has been increasing exponentially until
2014. For instance, the number of users created in 2013 and 2014, is twice more than the number of users created from 2007
to 2012, combined. However, 2014 is an inﬂection point in GitHub’s growth.

Programming Language

Java Script

Ruby
Python

Objective-C

Popularity

1
2
3
4
5
6
7
8
9
10

Stars

7328824
2997381
2387965
1905905
1854823
1566619
1172607
1127017
877088
580677

Commit

3
7
6
11
4
5
8
1
2
12

Size

3
8
5
10
1
6
9
2
4
23

N Repos

1
3
4
9
2
5
6
7
8
14

Fork

1
3
4
7
2
5
9
6
8
13

TIOBE

6
18
8
4
1
7
-
2
3
-

StackOverﬂow

10
14
20
22
1
28
30
23
3

> 200

Java
PHP
CSS
C
C++
Go

TABLE I: Programming Languages popularity using different metrics. Java Script is at the ﬁrst place (overall number of stars)
by a far margin.

aforementioned languages have the following ranks in our
table. C# is at 12th place, followed by Perl at 17th place,
and ﬁnally R at 25th place. C# is mostly restricted to .NET
framework and Microsoft; Perl is gradually being replaced
by other scripting languages; and R is a statistical domain
speciﬁc language, and recently is being challenged by general
programming languages such as Python.

Another question is whether the top 10 programming lan-
guages appeared on GitHub at the same pace? As we can see
in Figure 5, until 2011 Ruby was the dominant programming
language on GitHub, in terms of the number of projects. Even
more, in 2007, the very ﬁrst and only repository on GitHub
(Grit) was in Ruby. Grit, is written by GitHub’s co-founder,
Tom Preston-Werner. Java Script, Ruby and Python are the top
3 programming languages until 2012. Java takes the second
place in 2013 and 2014, after Java Script. The rise of Java
can be attributed to the popularity of Android platform and
wearable devices, and third party libraries. The abundance and
utility of third parties is a deciding factor in the success and

Fig. 4: Growth of the repositories in GitHub. The dashed blue
line shows the cumulative number of repositories, while the
red line indicates the number of repositories created in each
year.

 0 100000 200000 300000 400000 500000 60000020072008200920102011201220132014JanFebMarAprMayJunJulAugSepOctNovDec 0 2e+06 4e+06 6e+06 8e+06 1e+07 1.2e+07 1.4e+07 1.6e+07 1.8e+07 2007 2008 2009 2010 2011 2012 2013 2014YearTotalFig. 5: Histogram of repository creation year for the top 10 popular programming languages. Until 2011 Ruby was at the ﬁrst
place in terms of the number of repositories, and after Java Script takes the ﬁrst place.

adoption of programming languages. According to Gartner [1],
the share of Android devices raised from 30% in 2010 to 84%
in 2015.

By looking at the contributions to repositories we ﬁnd
out that, the repositories with the most number of commits
are generated by bots to change the appearance of the user’s
timeline, or participate in a contest. This is an interesting
phenomenon worth investigating further, to see whether these
are malicious or benign activities. However,
the ﬁrst real
repository is google/capsicum-linux, which also has
the most number of contributors, with over 4500 contributors.
As a matter of fact, all top 5 repositories in terms of the number
of contributors are Linux kernel related, and two of which are
owned by Google.

B. An Inquiry of Top Repositories

To have a better understanding of the repositories on
GitHub, and specially what each programming language is
mostly used for, we look at the top 5 repositories. We select
the repositories based on the number of stars for our top
10 programming languages. Here we discuss a summary of
these ﬁndings. The most prominent project written in the Go
programming language is Docker. Docker is a suite to automate
the deployment of applications inside software containers,
and was released on GitHub in 2013. It is nearly twice as
popular as the second repository. On the contrary,
to the
other programming languages, such as Java Script, Ruby or
Python, the top repository have a close popularity measure.
The top 5 repositories in Java Script were released between
2009 and 2010. The ﬁrst repository has around 34000 stars,
and the 5th one has around 28000 stars. Furthermore, the
projects show a closer relationship between their category and
classiﬁcation. For instance 4 out of the top 5 repositories

in Ruby, are in the web application/framework category. As
expected, the more domain speciﬁc programming languages
such as PHP, CSS, and Java Script, are largely used in
web based projects. Another example is Objective-C, which
is entirely used in iOS/Mac OS X based project. However,
Java user base is mostly spread between two communities,
Android development, and distributed big data based project.
An interesting and challenging future work is the analysis of
the growth and adoption of languages such as Java, in different
communities/software suites.

By looking at the projects’ release timeline on GitHub, we
ﬁnd out that Go projects are more recent compared to other
programming languages. This can be an indication of the fact
that now Go has reached a maturity level (e.g., in terms of
libraries ecosystem) that makes it a suitable choice for open
source projects. On the other hand, Ruby, Java Script and C
projects are older. As mentioned earlier, Ruby was the ﬁrst
programming language to appear on GitHub, and until 2011
had been the dominating programming language, in terms of
number of projects (Figure 5). The oldest popular projects
(created in 2008) are: Jekyll, and Rails. Jekyll, is a simple,
blog-aware, static site generator for personal, project, or or-
ganization sites, written in Ruby; Co-authored by GitHub’s
co-founder. Rails, is a web-application framework to create
database-backed web applications in Ruby.

IV. PROGRAMMING LANGUAGES

RELATIONSHIP

In this section, we look at the relationship between the
top 10 programming languages on GitHub. Our goal is to
ﬁnd out whether there is a correlation between programming
languages. For example, is someone who codes in Python
more likely to also code in Ruby, or PHP? The answer to this

 0 200000 400000 600000 800000 1e+06 1.2e+062008200920102011201220132014JavaScriptRubyPythonObjective-CJavaPHPCSSCC++GoJava Script

Python
Ruby

Objective-C

Java
PHP
CSS
C
C++
Go

Java Script

-

10.27
13.76
7.30
6.58
12.21
19.78
11.78
8.11
13.75

Python
4.29

-

2.37
1.97
3.22
1.87
6.28
12.86
8.35
10.67

Ruby
4.40
1.82

-

4.02
1.89
1.59
7.85
4.85
2.91
9.08

Objective-C

1.00
0.64
1.72

-

1.00
0.44
1.47
2.13
1.51
1.63

Java
7.93
9.27
7.10
8.80

-

6.23
6.78
10.21
8.36
7.56

PHP
5.66
2.07
2.30
1.50
2.39

-

7.57
4.34
2.98
3.90

CSS
20.77
15.76
25.76
11.29
5.91
17.16

-

6.63
4.95
19.56

C
6.81
17.78
8.76
9.00
4.90
5.43
3.65

-

15.53
20.55

C++
3.77
9.28
4.22
5.15
3.23
2.99
2.19
12.48

-

7.66

Go
0.64
1.19
1.33
0.56
0.29
0.39
0.87
1.66
0.77

-

TABLE II: The correlation between our top 10 Programming Languages. The correlations are calculated over the data collected
from the commits that users made to different repositories.

Java Script

Python
Ruby

Objective-C

Java
PHP
CSS
C
C++
Go

Java Script

-

14.86
18.54
10.39
8.54
18.23
22.32
15.80
10.87
17.74

Python
4.46

-

2.44
2.13
3.76
2.09
7.35
14.96
9.43
12.66

Ruby
5.34
2.34

-

3.68
2.95
2.12
8.92
8.61
4.53
10.44

Objective-C

1.42
0.97
1.75

-

1.51
0.66
2.06
4.60
2.51
2.41

Java
8.00
11.75
9.62
10.36

-

7.34
7.70
13.32
9.33
10.31

PHP
6.83
2.61
2.76
1.80
2.93

-

9.36
6.69
4.33
6.15

CSS
14.63
16.06
20.31
9.86
5.38
16.37

-

7.01
4.70
17.80

C
9.59
30.24
18.14
20.39
8.62
10.84
6.49

-

22.69
47.03

C++
4.10
11.85
5.94
6.91
3.75
4.36
2.70
14.10

-

11.00

Go
0.55
1.30
1.12
0.54
0.34
0.51
0.84
2.39
0.90

-

TABLE III: The correlation between our top 10 Programming Languages. The correlations are based on the repositories created
by different users.

question can help us to understand the fundamental question of
what is the general relationship between different programming
languages. Are they only an evolution of the older generation
of programming languages, or whether different technologies
try to answer and solve a different set of problems. Of course,
all of programming languages that we are considering are
Turing complete, with the exception of CSS, but do people
use them in the same way and for the same purposes, or
each one is more suitable for a different set of problems.
This suitability can be because of the innate features of
the programming language, or an external factor. Namely, a
killer application/library for that language, or adoption of the
language in a certain product. For example, iOS and Mac OS
X’s Software Development Kits (SDK) are based on Objective-
C. As a results all top 5 repositories in Objective-C are Apple,
and more speciﬁcally iOS/Mac OS related.

To calculate the correlations between programming lan-
guages, we look at
the commits that are made by users
(Table II) and the repositories that are created by each user
(Table III). We use the following methodology to calculate
the values. Imagine, Alice codes in Python, Ruby, and C;
Bob codes in Python, and C; and Carol codes in Python, and
Ruby. Therefore, the correlation between Python and Ruby,
Alice+Bob+Carol ), and the correlation
is 2
between Ruby and Python is 1 = 100% ( Alice+Carol
Alice+Carol ). Mean-
ing, 66% of people who use Python also use Ruby, while
100% of users who use Ruby also use Python. Note that these
relationships are asymmetric. As we can see, this translate to
the conditional probability, i.e., P (A|B). The probability that
A occurs given B.

3 = 0.66 = 66% ( Alice+Carol

P (A|B) =

P (A ∩ B)

P (B)

P (P ython|Ruby) =

P (P ython ∩ Ruby)

P (Ruby)

As we can see in Table II, Ruby programmers are most
likely to also code in Java Script or CSS rather than in Go or
Objective-C. Such relationships can be linked to the popularity
of web frameworks such as Ruby on Rails, and Sinatra. Note
that projects categorized as CSS, can in fact be Java Script
frameworks where the majority of the code base is CSS
ﬁles. Such usage patterns also surfaces in other programming
languages as well. PHP programmers are much more likely to
use Java Script and CSS than any other programming language.
Considering that the aforementioned programming languages
are mostly used in web development, such a closed relationship
is expected. On the other hand, Python and Go programmers
are much more likely to program in C than other programming
languages. The de facto implementation of these programming
languages is in C, and are more likely to be used in systems
related software and projects, compared to Ruby or Java Script.
As we can see in Table III, the same observations hold for
the data based on the programming language of the repositories
that are created by users, as opposed to the repositories that
users have contributed to. Such correlation and entangled
behavior, motivate us to further investigate the clustering
behavior of programming languages, by using unsupervised
machine learning algorithms.

A. Clustering of Programming Languages

In the following we cluster the top 10 programming lan-
guages on GitHub, using k-means [17] clustering. K-means is a
vector quantization method originated from signal processing,
which is used for clustering. We perform a maximum of 300
iterations with 10 centroid seeds. We use the values in Table II

and Table III as our input dataset. Each column represents a
feature and each row is an entry. Figure 6a and Figure 6b
depict the clustering of programming languages. To be able to
visualize the data, we perform a dimension reduction (from 10
dimensions to 3 dimension), using principal component analy-
sis (PCA) [21]. PCA is an orthogonal transformation to convert
a set of correlated variables into a set of values of linearly
uncorrelated variables. As we can see in Figure 6a, there are
5 clusters of programming languages; the web programming
languages (Java Script, Ruby, PHP, CSS), system oriented
(Python, C, C++), Android (Java), iOS/Mac OS X (Objective-
C) and “trending/upcoming” (Go). Furthermore, if we look
at the repositories created by users we see slightly different
results. As we can see in Figure 6b, the web programming
languages still consist of Java Script, PHP, and CSS. However,
with 5 clusters, Ruby emerges as its own cluster, and Go falls
within the system oriented programming languages, alongside
Python, C, and C++. Clustering of Java Script, PHP, and CSS is
expected, as previous measurements [11] have estimated 39%
of the backend webservers were running PHP in 2013. How-
ever, emergence of Ruby in the web programming languages
is more speciﬁc to the GitHub platform. As mentioned before
Ruby was the ﬁrst and the dominant programming language on
GitHub until 2011. Among the big web companies that used
Ruby for their back-end development is Twitter [7]. Based
on these observations we look at the gradual separation of
programming languages, and create a user-driven tree classiﬁ-
cation of programming languages.

We start with two clusters and gradually increase the
number of clusters. Figure 7, is based on the commits data
(Table II). As we can see, at ﬁrst
there are two families
of programming languages; the web programming languages
(Java Script, Ruby, PHP, CSS), and the “others” (Python, C,
C++, Go, Java, Objective-C). The ﬁrst programming languages
that separates from the herd of “others”,
is Objective-C,
which has a different use and platform from the rest (almost
exclusively iOS/Mac OS X). Next, Java emerges as a different
category (Android, distributed Big Data), followed by Go.
However, in the next step PHP leaves the web family, followed
by Ruby. The last separation of “other” family is between
Python and C (Python’s reference implementation, CPython,
is in C). Java Script and CSS, keep their close tie, until the
last clustering step. Note that, as mentioned earlier many of
the CSS repositories are in fact Java Script libraries where the
majority of code base is CSS.

B. Investigation of Auxiliary Programming
Languages

As mentioned earlier a project may be written in more than
one programming language. In the previous section we consid-
ered the dominant programming languages of a repository, in
terms of lines of code. In this section we look further into all
the programming languages that are used in a repository. To
investigate a good representative of the open source project
we look at the top 100 repositories for each of the top 10
programming languages, a total of 1000 repositories.

We represent the relationship between the programming
languages as a directed graph. The nodes of the graph represent
the programming languages, and we consider an edge between
two nodes if the corresponding programming languages are

PageRank Ranking

1
2
3
4
5
6
7
8
9
10

Programming Language

HTML

Perl

Makeﬁle
Batchﬁle

Shell

CoffeeScript
JavaScript

Python
Ruby
PHP

TABLE IV: Top 10 Programming Language, based on the
PageRank algorithm. As we can see, HTML is used in many
projects and is used with other programming languages, fol-
lowed by scripting languages to facilitate tasks in the projects.

used in a project. The source of the edge is the dominant
programming language and the destination is the other pro-
gramming programming language. For example, if a repository
is written in Python, Ruby, C and Java, where the majority of
the source code is in Python, we consider edges from Python
to Java, Python to Ruby, and Python to C. To deﬁne it more
formally, |V | = set of all programming languages, |E| = set
of all edges. Therefore, ∀u, v ∈ V , ∃(u, v) ∈ E, ⇐⇒ u and
v, are used in a same project, where u is the main, and v is
the auxiliary language.

After forming such a graph we use the PageRank [26] al-
gorithm to rank the programming languages. It is an algorithm
used by Google to determine the importance of the websites,
based on the other websites that link to it. PageRank works in
multiple iterations, and in the ﬁrst iteration it assigns the same
score to all nodes. In the future iterations it updates the scores,
where the score of node p is divided between the other nodes
it points to. Therefore each node receives
L(p) of the score.
L(p) is the number of outbound links from p. Therefore, the
following formula calculates the score of page p at iteration i:

1

(cid:88)

P R(pi) =

1 − d
N

+ d

P R(pj)
L(pj)

pj∈M (pi)

where pi is the node under consideration, M (pi) is the set of
nodes that link to pi, L(pj) is the number of outbound edges
from node pj, and N is the total number of nodes.

As we can see in Table IV, which is based on the directed
graph described above, HTML is used in many projects
and is used with other programming languages, followed by
scripting languages to facilitate tasks in the projects. For
example, Makeﬁle scripts are a common practice in Unix based
Operating Systems software developments to perform tedious
tasks such as compilation and installation of the software from
source code. Table V, summarizes the top 10 programming
languages that are used as auxiliary programming language
in repositories. It is based on the number of projects, that
the auxiliary languages are used in. Shell scripting is used
in 47%, and HTML is used in 42% of the projects. To
further investigate the dynamics of programming languages
we build the weighted graph of the programming languages
by considering the percentage of the code that is written in
an auxiliary programming language. For example, if a project
in written in Python (40%), C (30%) and Java (20%), then

(a) 5 clusters of programming languages, based on the commits
(Table II); the web programming languages (Java Script, Ruby, PHP,
CSS), system oriented languages (Python, C, C++), Android (Java),
iOS/Mac OS X (Objective-C) and “trending/upcoming” (Go).

(b) 5 clusters of programming languages, based on users’ repositories
(Table III); the web programming languages (Java Script, PHP, CSS),
system oriented languages (Python, Go, C, C++), Android (Java),
iOS/Mac OS X (Objective-C) and Web/Minimalist (Ruby).

Fig. 6: Clustering of programming languages

Shell
HTML

JavaScript

CSS
Ruby
Python

C

Programming Language

Makeﬁle

C++

Objective-C

Percentage of the Projects

47.1
41.6
39.2
38.1
29.8
28.8
26.5
25.5
22.7
19.2

TABLE V: Top 10 Programming Language, based on the
number of projects they are used. As we can see,
large
percentage of the repositories rely on Shell scripts and use
HTML.

the edge from Python would have the weight wpython→java =
wpython→java+0.2, and the edge from Python to C would have
the weight, wpython→c = wpython→c + 0.3. Figure 8, depicts
the weighted graph of programming languages, where the blue
nodes are the top 10 programming language from Table I and
the red nodes are the auxiliary programing languages used
in the top 1000 repositories but are not in the Table I. As
we can see, HTML, CSS, and Java Script are the dominant
auxiliary programming languages based on the percentage of
lines of code, followed by scripting languages such as Shell
and general purpose and scripting languages such as Python.

V. RELATED WORK

Prior work have studied and collected data from GitHub
and other source code hosting repositories [20], [27]. However,
to the best of our knowledge we are the ﬁrst to collect and ana-
lyze GitHub’s data at its entirety and at this scale. This dataset
enabled us to study unique aspects of GitHub ecosystem,
that was not possible previously. For example, GHTorrent [2],

Fig. 7: Hierarchical phylogenetic clustering and separation of
programming languages. At ﬁrst, there are two families of
programming languages; the web programming languages and
the “others”.

js-rb-css-phpgopy-c-cppobj-cjavajs-css-phpgo-py-c-cpprbjavaobj-cFig. 8: Weighted directed graph of programming languages relationship in the top 1000 repositories. The blue nodes are the top
10 programming language from Table I and the red nodes are the other auxiliary programing languages used in the top 1000
repositories.

is a mirror of GitHub’s public events, using its RESTful
API. GitHubarchive [13], collects and mirrors GitHub’s public
events since December 2011. Ray et al. [29], study the impact
of programming languages on software quality. They collected
data from 729 repositories on GitHub.

Another direction of research is on trends of different
programming languages. For example, Meyerovich and Rabkin
[24], investigate the adoption of different programming lan-
guages, by using surveys, and collecting the metadata of
some project from SourceForge and Ohloh. They ﬁnd out that
languages adoption follows power law, and factors such as li-
braries and existing code are more important to the developers,
compared to performance and semantics. Chen et al. [19], look
at the software engineering and programming languages trends.
They choose 17 and measure their evolution using different
factors such as intrinsic, extrinsic and quantifying factors.
Karus and Gall [22] look at the language evolution of open
source software development and the amount of code written in
different languages. They study 22 open source softwares, and
look at how XML and XSL are used. Another study explores
the developer commit patterns in GitHub [33], by deﬁning
four metrics to measure commit activity and code evolution:
the changes in commits; the time between two commits; the
author of each change; and the source code dependency.

Previous works look at the social aspects of coding and
platform such as GitHub [34], [25]. For example, Begel et
al. [18], look at the social aspects of software development in
platforms such as GitHub and MSDN, by interviewing leaders
of companies. Marlow et al. [23], look at impression formation,

by tracing activity and personal proﬁles in GitHub. Authors
conclude that developers form impressions around one another
based on history of one’s contributions across projects and
interactions in the community. Thung et al. [31] look at the
network structure of social coding in GitHubg by constructing
the developer-developer and project-project relationship graphs
to examine characteristics of the graphs. The authors collected
data from 100000 projects, and 30000 developers in this study.
Vasilescu et al. [32] look at the continuous integration in
GitHub ecosystem, and explore whether direct and indirect
continuations and different project characteristics such as the
project age are associated with the success of the automatic
builds.

VI. FUTURE WORK

In this section, we look at the future work based on the
collected dataset. For example, investigation questions such
as, “What makes a programming language popular?”, “How
are programming languages adopted in projects?”, and “What
are the important internal and external factors in the adoption
of a programming language?”

Another interesting research question is the investigation
and discovery of users’ hidden social structures based on
their contributions to repositories. Such study requires the
examination of the user-user and user-repository relationships.
Furthermore, our goal is to study the users’ expertise based
on their contributions to different categories of applications.
Imagine, a community of users who are only contributing to the
projects related to data science, and another community that

CShellPythonJavaScriptC++CoffeeScriptObjective-CHTMLPHPRubyCSSis only active in the projects related to security. Discovering
the existence of such cliques, and investigating them is an
interdisciplinary study, which uses social sciences and software
engineering principles. Another direction of research is the
examination of the dynamics of a project in its life span. For
instance the study of the key moments and the tipping point
in the success and adoption of a project between users.

VII. CONCLUSION

In this work, we collected and studied GitHub,

in its
entirety. We investigated around 10 million user proﬁles, over
16 million public repositories, 11 million user relationships,
and over 3 billion contributions. To the best of our knowledge,
we are the ﬁrst to perform a study at such a large scale. We
looked at the growth and adoption rate of GitHub, based on
the number of users and repositories. We provided an analysis
of the top repositories, and the use of different programming
languages for different purposes in projects. Additionally, we
identiﬁed the popular programming languages on GitHub,
and compared the results with other sources, such as TIOBE
and Stack Overﬂow. Next, we investigated the correlation
between different programming languages, and clustered the
different languages and technologies using machine learning,
and unsupervised learning. We found out that two clear clusters
of programming languages separate from the remaining, “web
programming” languages (Java Script, Ruby, PHP, CSS), and
a second for “system oriented programming”. We provided
a hierarchical user-driven phylogenetic tree classiﬁcation of
programming languages. Furthermore, we studied the top 1000
repositories in more detail, by looking at the main and the
auxiliary programming languages in these repositories. Our
results indicated the use of multiple programming language
in modern software artifacts. We provided a ranking of these
auxiliary programming languages using different metrics, such
as percentage of lines of code, and PageRank. We hope this
work, adds to the body of literature on mining software repos-
itories, and to answer research questions and shed new light
on the dynamics of software development and programming
languages.

REFERENCES

[1] Gartner. http://www.gartner.com.
[2] Ghtorrent. http://ghtorrent.org/.
[3] Google Developers (previously Google Code).

google.com/.

https://developers.

[4] Launchpad. https://launchpad.net/.
[5] SourceForge. http://sourceforge.net/.
[6] Stackoverﬂow. stackoverﬂow.com/.
[7] Twitter on scala. http://www.artima.com/scalazine/articles/twitter on

[8]

scala.html, April 2009.
30 under 30. http://www.forbes.com/special-report/2012/30-under-30/
30-under-30 tech.html, December 2012.

[9] Top 10 tech companies of 2012.

http://www.forbes.com/sites/
December

tanyaprive/2012/12/30/top-10-tech-companies-of-2012/,
2012.
2 reasons to keep an eye on github. http://www.inc.com/magazine/
201303/will-bourne/2-reasons-to-keep-an-eye-on-github.html,
Feburary 2013.

[10]

[11] PHP just grows and grows. http://news.netcraft.com/archives/2013/01/

31/php-just-grows-grows.html, January 2013.

[12] Software eats software development. http://peter.a16z.com/2012/07/09/

software-eats-software-development/, July 2012.

[13] Github archive. https://www.githubarchive.org/, March 2012.
overall
[14] Github wins
may
2013/01/31/github-wins-the-2012-crunchie-for-best-overall\
-startup-may-the-fork-be-with-you/, March 2012.

2012
be with

the
fork

you.

crunchie

for

the

“best

startup”,
http://techcrunch.com/

[15] Alexa. http://www.alexa.com/siteinfo/github.com, May 2015.
[16] TIOBE index. http://www.tiobe.com, May 2015.
[17] D. Arthur and S. Vassilvitskii. K-means++: The advantages of careful
seeding. In Proceedings of the Eighteenth Annual ACM-SIAM Sympo-
sium on Discrete Algorithms, SODA ’07, 2007.

[18] A. Begel, J. Bosch, and M.-A. Storey. Social networking meets software
development: Perspectives from github, msdn, stack exchange, and
topcoder. IEEE Softw., 30(1), 2013.

[19] Y. Chen, R. Dios, A. Mili, L. Wu, and K. Wang. An empirical study
of programming language trends. Software, IEEE, 22(3):72–79, May
2005.

[20] R. Ding, Q. Fu, J.-G. Lou, Q. Lin, D. Zhang, J. Shen, and T. Xie.
Healing online service systems via mining historical issue repositories.
In Proceedings of the 27th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2012, 2012.
I. Jolliffe. Principal component analysis. Wiley Online Library, 2002.
[21]
[22] S. Karus and H. Gall. A study of language usage evolution in open
In Proceedings of the 8th Working Conference on

source software.
Mining Software Repositories, MSR ’11, 2011.
J. Marlow, L. Dabbish, and J. Herbsleb. Impression formation in online
peer production: Activity traces and personal proﬁles in github. In Pro-
ceedings of the 2013 Conference on Computer Supported Cooperative
Work, CSCW ’13, 2013.

[23]

[24] L. A. Meyerovich and A. S. Rabkin. Empirical analysis of programming
language adoption. In ACM SIGPLAN Notices, volume 48, pages 1–18.
ACM, 2013.

[25] R. Padhye, S. Mani, and V. S. Sinha. A study of external community
contribution to open-source projects on github. In Proceedings of the
11th Working Conference on Mining Software Repositories. ACM, 2014.
[26] L. Page, S. Brin, R. Motwani, and T. Winograd. The pagerank citation

ranking: bringing order to the web. 1999.

[27] R. Pham, L. Singer, O. Liskin, F. Figueira Filho, and K. Schneider.
Creating a shared understanding of testing culture on a social coding
site. In Proceedings of the 2013 International Conference on Software
Engineering, ICSE ’13, 2013.

[28] M. M. Rahman and C. K. Roy. An insight into the pull requests of
In Proceedings of the 11th Working Conference on Mining

github.
Software Repositories, MSR 2014, 2014.

[29] B. Ray, D. Posnett, V. Filkov, and P. Devanbu. A large scale study of
programming languages and code quality in github. In Proceedings of
the 22Nd ACM SIGSOFT International Symposium on Foundations of
Software Engineering, FSE 2014, 2014.

[30] E. M. Rogers. Diffusion of innovations. Simon and Schuster, 2010.
[31] F. Thung, T. Bissyande, D. Lo, and L. Jiang. Network structure of
social coding in github. In Software Maintenance and Reengineering
(CSMR), 2013 17th European Conference on, 2013.

[32] B. Vasilescu, S. Van Schuylenburg, J. Wulms, A. Serebrenik, and
M. G. van den Brand. Continuous integration in a social-coding
world: Empirical evidence from github. In Software Maintenance and
Evolution (ICSME), 2014 IEEE International Conference on. IEEE,
2014.

[33] Y. Weicheng, S. Beijun, and X. Ben. Mining github: Why commit stops
– exploring the relationship between developer’s commit pattern and ﬁle
version evolution. In Software Engineering Conference (APSEC), 2013
20th Asia-Paciﬁc, 2013.

[34] Y. Yu, G. Yin, H. Wang, and T. Wang. Exploring the patterns of social
behavior in github. In Proceedings of the 1st International Workshop on
Crowd-based Software Development Methods and Technologies. ACM,
2014.

