6
1
0
2

 
r
a

 

M
8
1

 
 
]
L
F
.
s
c
[
 
 

1
v
7
1
0
6
0

.

3
0
6
1
:
v
i
X
r
a

Automatic Theorem Proving in

Walnut

Hamoon Mousavi

March 22, 2016

Contents

1 Introduction

2 Basics

2.1 Words and Automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Number Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Automatic Words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Automata accepting Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2

3
3
4
6
7

3 Syntax and Semantic of Predicates in Walnut

9
9
3.1 Alphabets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.2 Arithmetic and Alphabetic Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.3 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.4 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Arithmetic Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
3.6 Indexing Expressions and Their Semantic Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.7 Calling Expressions and Their Semantic Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.8 Relative Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.9 Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12

4 Decision Procedure: Walnut’s Implementation

12
4.1 Cross Product . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
4.2 Quantiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
15
4.3 Complement and Reverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Arithmetic and Comparison Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
4.5 Calling an Automaton . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
18
4.6 Indexing an Automatic Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5 Special Automata in Walnut

5.1 True and False Automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Non-arithmetic Automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6 Installation

6.1 Eclipse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

19
19
19

20
20

1

7 Commands

20
7.1 eval: eval <name> <predicate> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
7.2 def: def <name> <predicate> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
7.3 reg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
7.4 load: load <ﬁle name> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29

8 Working with Input/Output

29
29
8.1 Deﬁning Automata in Text Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.2 Deﬁning New Automatic Words
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
8.3 Deﬁning New Number Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
8.4 Converting .gv ﬁles to .jpeg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

1 Introduction

Walnut is a software package that implements a mechanical decision procedure for deciding certain combinatorial properties
of some special words referred to as automatic words or automatic sequences. To learn more about automatic words and
their applications, see [2]. To learn about decision procedures for automatic words, see Schaeffer’s Master’s thesis [6] and the
survey paper [7]. To read more about decidable properties of automatic words, refer to [4]. To read about another software
package that provided a similar mechanical decision procedure for automatic words, and was developed before Walnut, read
Goc’s Master’s thesis [5]. To see applications of Walnut, refer to [8–13].

The aim of this article is to introduce Walnut and explain its core features. This article consists of four parts: basics,
syntax, implementation, and the Walnut guide. In the ﬁrst part, Section 2, we establish the basic notation and concepts.
We go over words, automata, number systems, automatic words, and Presburger arithmetic. We learn what it means for an
automaton to accept a predicate. We also learn how to automatically decide properties of automatic words.

The second part, Section 3, talks about the building blocks of predicates: constants, variables, operators, and different
types of expressions. The semantics of predicates in Presburger arithmetic are well-known and are not explained, whereas
semantic rules for calling and indexing, with which we extend the Presburger arithmetic to include automatic words, are
explained in detail.

The third part, Sections 4 and 5, explains the decision procedure implemented in Walnut. The cross product of two
automata, which is behind the construction of automata for all binary logical operators, is introduced. Building on that,
we see how to construct automata for predicates from automata for subpredicates. In Section 5, we talk about two types of
automata that do not appear often in Walnut, but are nevertheless important to understand.

The fourth and last part, Sections 6–8, starts with Walnut’s installation and goes over all of its commands, i.e., exit, eval,
def, reg, and load. In Section 8, we learn how to manually deﬁne automata in text ﬁles. We also learn how to deﬁne new
number systems.

If you are already familiar with the objects described in the ﬁrst sentence of this introduction, you can skip Section 2
and come back to it only as a reference. For a more comprehensive treatment of the theory behind decision procedures for
automatic words refer to [4, 6, 7].

Since this article is more about Walnut than the theory behind it, when we explain the latter, we use Walnut’s notation as
opposed to the more familiar mathematical notation. For example, we use & and A for conjunction and universal quantiﬁer
as opposed to ∧ and ∀ of mathematical logic 1. As another example, when we deﬁne structures such as number systems
or objects such as automatic words, we give the deﬁnitions that are closer to Walnut’s capabilities than the most general
theoretical ones possible. This will help the reader make a smoother transition from the theory to its application in Walnut.
You can download Walnut from Jeffrey Shallit’s website, or alternatively from GitHub. Walnut is written in Java and
is open source. It is licensed under GNU General Public License. We would appreciate it if users cite this article in their
publications. For automata minimization and converting regular expressions to automata, Walnut relies on the automata
library in [3]. We would greatly appreciate it if users report bugs to sh2mousa@uwaterloo.ca. The author would like to thank
Jeffrey Shallit for revising this article.

1Users enter logical predicates in a terminal when they use Walnut. We ﬁnd that entering latex-like commands in the terminal, e.g., \forall, does not

improve the readability.

2

2 Basics

2.1 Words and Automata
A word (ai )i∈I for a ﬁnite, inﬁnite, or a possibly empty subset I of natural numbers (cid:78), is a sequence of symbols ai over a ﬁnite
set called an alphabet. The set I usually equals (cid:78) or (cid:78)l = {k ∈ (cid:78) : k < l} for some l. The set of ﬁnite and inﬁnite words over
and Σω, respectively. The empty word is denoted by . For the ﬁnite word w = a0a1··· al−1,
the alphabet Σ are denoted by Σ∗
the length |w|, is deﬁned and equals l. We let Σl denote the set of all words over Σ of length l. A subword (sometimes called
“factor” in the literature) is a ﬁnite and contiguous subsequence of a word. The subword of w starting at position i of length
k ≥ 0 is denoted by w[i ..i + k − 1] = ai ··· ai+k−1. Many interesting properties of words can be expressed in terms of their
subwords. For example, the property of having two equal and adjacent subwords, referred to as a square, is discussed in
numerous papers in the area of combinatorics on words. The product of two words x and y, denoted by x y, is the result of
concatenating x by y.
There are cases where our words are deﬁned over alphabets consisting of tuples of symbols, so let us ﬁx our notation
regarding these words. For a word w over an alphabet Σ1 × Σ2 ...× Σn, we let the projection map πj (w) for 1 ≤ j ≤ n denote
the word over Σj , obtained from w by looking at the j ’th coordinates, i.e., words πj (w) are uniquely deﬁned by

For example, for w = (0,1)(1,1)(0,0) over {0,1}× {0,1} we have π1(w) = 010 and π2(w) = 110.

(cid:161)π1(w)[i ], π2(w)[i ],..., πn(w)[i ](cid:162).
an automaton M with n inputs (input tapes), is an (n + 4)-tuple(cid:161)Q, q0,F, δ, Σ1, Σ2,..., Σn

(cid:162), where Q is the (ﬁnite) set of states,
The reader is probably familiar with the notions of deterministic and nondeterministic ﬁnite state automata. In Walnut,
q0 ∈ Q is the initial state, F ⊆ Q is the set of ﬁnal states, δ : Q × Σ1 × Σ2 ×···× Σn → Q is the transition function, and Σi is the
alphabet of the i ’th input (tape). The automaton’s alphabet is deﬁned to be the cross product Σ1 × Σ2 ×···× Σn, and the
notions of accepting a word w or a language over this alphabet is deﬁned as usual. A nondeterministic automaton is deﬁned
similarly, except that the transition function is deﬁned by δ : Q×Σ1×Σ2×···×Σn → 2Q. In Walnut and throughout this article,
the Σi are ﬁnite subsets of integers (cid:90).

|w|−1(cid:89)

w =

i=0

Two automata are equal (isomorphic) if their underlying graphs are isomorphic. Two automata are equivalent if they
accept the same language. There exists a determinization algorithm that converts a nondeterministic automaton to an
equivalent deterministic automaton. There exists a minimization algorithm that converts an automaton to an equivalent
automaton with the least number of states (which is unique up to isomorphism). It is known that extending the automata
model by allowing multiple initial states (similar to how there can be multiple ﬁnal states) does not add to the model’s
expressiveness.

Next we extend the notion of accepting languages to relations, since the latter is more natural in Walnut:

Deﬁnition 1 (relations computed by automata). The relation R ⊂ Σ∗

1

2

n computed/accepted by M is deﬁned by

× Σ∗

× ...× Σ∗

R =(cid:169)(cid:161)π1(w), π2(w),..., πn(w)(cid:162) : M accepts w(cid:170).
R ⊆(cid:91)
101, and |w1| = |w2|(cid:170):

× ...× Σ∗
n.

(cid:161)Σl

l≥0

n

1

1

2

2

Since for every word w, the words πi (w) are all of the same length, the relation R accepted by an automaton is consisted of
tuples of the words of the same length, i.e., we have
× Σl

(cid:162) ⊂ Σ∗

×···× Σl

× Σ∗

For example, the language accepted by the following automaton is L = (0,0)

∗

(1,1)(0,0)(0,1), whereas the relation accepted

is R =(cid:169)(w1, w2) : w1 ∈ 0

∗

100, w2 ∈ 0

∗

Figure 2.1: Automaton accepting tuples of same length representations of 4 and 5 in binary

3

In other words, the automaton accepts tuples t = (w1, w2) ∈ {0,1}

where w1 and w2 are representations of the
the same length, in the most-signiﬁcant-digit-ﬁrst binary system, of natural numbers 4 and 5 respectively. On the other
hand, referring to the words w in ({0,1}× {0,1})
that are accepted by this automaton is not very descriptive. That is why, in
this article, we prefer the relation (tuple) terminology over the language (word) terminology.

∗ × {0,1}

∗

∗

An automaton with output is a tuple(cid:161)Q, q0,O, δ, Σ, Σ1, Σ2,..., Σn

In almost all depictions of the underlying graphs of automata, such as the one in Figure 2.1, when a transition is not
speciﬁed, it is assumed to be a transition to a dead state. In Walnut we do not store transitions to the dead state. Adding the
dead state and all implicit transitions to it, is called totalizing an automaton.
alphabet, and, instead of a set of ﬁnal states, we have a map O : Q → Σ. The symbol O(q) is called the output of the state q.
An automaton with output can be thought of as an automaton that reads a word over Σ1× Σ2···× Σn and outputs whatever is
the last state’s output. In Walnut, the output alphabet Σ is a ﬁnite subset of integers. We can think of ordinary automata as a
special case of automata with output by letting the set of ﬁnal states to be F = {q : O(q) (cid:54)= 0}. This is indeed how ordinary
automata are stored in Walnut.

(cid:162) where Q, q0, δ, Σj are as before, the set Σ is the output

of automata to(cid:161)Q, q0,F, δ,S1,S2,...,Sn

In the next section, we learn how to add more structure to alphabets by deﬁning number systems. As we saw in the
example, the automaton in Figure 2.1 accepts binary representations of numbers. In a moment we will extend our deﬁnition

(cid:162), where the Sj are number systems and concealed in them are alphabets ΣSj among

other things.

2.2 Number Systems

In any course on theory of computation, it is customary to talk about the representations of the objects an algorithm/Turing
machine takes as inputs. At the core of Walnut are automata taking natural numbers as inputs, and doing various computa-
tions on them, so ﬁxing a representation for natural numbers is essential. We could limit ourselves to binary representations.
However, there are many interesting automata accepting representations in number systems other than the binary one. So
we are going to deﬁne, in general terms, the concept of a number system. Walnut allows number systems to be deﬁned and
used (with a few restrictions to the general deﬁnition below).
Deﬁnition 2 (number systems). A number system S is a 3-tuple (ΣS,RS,[]S) of alphabet ΣS ⊇ {0,1}, language RS ⊂ Σ∗
S of valid
, and decoding function []S : RS → (cid:78) that assigns integers to every
representations containing 0
word in RS and for which []S(w) is usually written as [w]S. The decoding function has the following additional properties:

and at least one of 0

1 or 10

∗

∗

∗

∗

• [z]S = 0 if and only if z ∈ 0
• [1]S = 1
• For all w ∈ RS, either zw ∈ RS and [zw]S = [w]S for all z ∈ 0
called an msd number system and the latter is called an lsd number system2.
• For all positive n ∈ (cid:78), there exists w ∈ RS for which [w]S = n and w[0] (cid:54)= 0 if S is msd or w[|w|− 1] (cid:54)= 0 if S is lsd. The
word w, if unique, is called the canonical encoding of n in S, and is sometimes denoted by (n)S. We let (0)S = .

, or w z ∈ RS and [w z]S = [w] for all z ∈ 0

. The former is

∗

∗

S is deﬁned such that (x, y, z) ∈ +S if and only if x, y, z are of the same length and [x]S = [y]S+[z]S.
The addition relation +S ⊂ R3
The equality relation =S⊂ R2
S is deﬁned such that (x, y) ∈=S if and only if x and y are of the same length and [x]S = [y]S.
S for which (x, y) ∈<S if and only if x and y are of the same length and [x]S < [y]S.
The less than relation is deﬁned as <S⊂ R2
We adopt the in-order notation for +S, =S, and <S, i.e., we write x = y +S z, x =S y, and x <S y as opposed to the more
cumbersome (x, y, z) ∈ +S, (x, y) ∈=S, and (x, y) ∈<S respectively. It follows from the deﬁnition that for all n ∈ (cid:78), the set of
representations of n in S, deﬁned by {w : [w]S = n} is non-empty.

∗
For example, the most-signiﬁcant-digit binary system, denoted by msd_2, is deﬁned by ({0,1},{0,1}

,[]msd_2) where

|w|−1(cid:88)

i=0

[w]msd_2 =

[w[i ]]msd_22

|w|−i−1,

2msd and lsd are short for most-signiﬁcant-digit-ﬁrst and least-signiﬁcant-digit-ﬁrst, respectively. However, it should not be taken literally in this
deﬁnition, as one could deﬁne msd number systems (in the sense deﬁned here), with no direct correspondence to the notion of most-signiﬁcant-digit-ﬁrst
representation.

4

e.g., [001001]msd_2 = 0· 25 + 0· 24 + 1· 23 + 0· 22 + 0· 21 + 1· 20 = 9. For msd_2, we are very fortunate to have simple automata
computing all of its important aspects, namely, valid representations Rmsd_2, the addition relation +msd_2, the equality
relation =msd_2, and the less-than relation <msd_2. See Figures 2.2,2.3,2.4, and 2.5 respectively.

Figure 2.2: Automaton computing Rmsd_2

Figure 2.3: Automaton computing +msd_2

Figure 2.4: Automaton computing =msd_2

Figure 2.5: Automaton computing <msd_2

We can deﬁne the least-signiﬁcant-digit-ﬁrst binary system, denoted by lsd_2, in a similar way. In fact, we can deﬁne
msd_n and lsd_n for all n ≥ 2, and for all of them, there are simple automata computing valid representations, addition,
equality, and less-than relations. In fact we can deﬁne the following:

5

Deﬁnition 3 (number systems in Walnut). Number systems for which the automata for representations, addition, equality,
and less-than exist, and equality is the same as word equality, i.e., x =S y if and only if x = y, are exactly the type of number
systems one can deﬁne and use in Walnut. Note that the alphabet of a number system is restricted to ﬁnite subsets of (cid:90) due
to the same restriction on automata in Walnut.

In addition to base-n number systems, Walnut has a built-in deﬁnition for the Fibonacci number system.
The most-signiﬁcant-digit-ﬁrst Fibonacci system, denoted by msd_ﬁb, is deﬁned by ({0,1},0

( | 1)(0 | 01)
∗

∗

,[]msd_ﬁb)

where Fi is the i ’th Fibonacci number given by F0 = 1,F1 = 2, and Fi = Fi−1 + Fi−2 for i ≥ 2. For example, [001001]msd_ﬁb =
0· F5 + 0· F4 + 1· F3 + 0· F2 + 0· F1 + 1· F0 = 6. The set of valid representations is exactly the set of binary words avoiding
consecutive 1s. The avid reader might want to verify that msd_ﬁb is a number system. There are automata computing all
major aspects of msd_ﬁb. For example, here is the automaton accepting Rmsd_ﬁb

3:

where

[w]msd_ﬁb =

[w[i ]]msd_ﬁbF|w|−i−1,

|w|−1(cid:88)

i=0

Figure 2.6: Automaton computing Rmsd_ﬁb

In cases, where an automaton’s inputs are representations of integers in some number system, which by far are the most
important type of automata in Walnut, we would like to signify these number systems instead of the input alphabets. For

example, we might write(cid:161)Q, q0,F, δ,S1,S2,...,Sn

(cid:162) to mean(cid:161)Q, q0,F, δ, ΣS1, ΣS2,..., ΣSn

(cid:162). It should be understood that in these

cases, if for a word w input πj (w) is not a valid representation in Sj, it does not mean that the automaton’s behavior is not
deﬁned for w. This just means that w is, by default, not going to get accepted. The behaviors of both automata and automata
with output that are taking representations of numbers in some number systems as inputs are deﬁned for all words (even
those not representing numbers in the given number systems).

2.3 Automatic Words
An automatic word W = (ai )i≥0 is a word in Σω for which there exists a number system S and an automaton with output

M(cid:161)Q, q0,O, δ, Σ,S(cid:162) for which reading x ∈ RS outputs W [[x]S] = a[x]S. In other words, for an automatic word, the symbol at

position i for all i can be effectively computed by running an automaton with output on any single representation of i in a
number system. As usual we assume Σ is a ﬁnite subset of (cid:90).

The word T for which the symbol at position i , is the number of 1s in any binary representation of i , modulo 2, is called
the Thue-Morse word. The Thue-Morse word is well-deﬁned since all the inﬁnitely many different binary representations
of an integer have the same number of 1’s. It is instantly clear that T is an automatic word over msd_2 if one notes the
automaton with output in Figure 2.7.

Figure 2.7: The Thue-Morse word

In the introduction, we mentioned that Walnut decides some properties of automatic words. Recall from Section 2.1 that
squares are non-empty words of the form xx. It is easy to see that T has square subwords. The following predicate captures

3The automaton accepting +msd_ﬁb has 16 states, which is too big to be represented here.

6

this property:

∃i∃n∀j, j < n =⇒ T [i + j ] = T [i + n + j ].

(cid:161)Q, q0,F, δ,msd_2,msd_2,msd_2(cid:162) for subpredicate
Walnut provides a decision procedure that takes predicates like this and decides whether they are true or false. Walnut
does so, by constructing automata for every subpredicate in the predicate above; see Section 2.4 for more details. It starts
by constructing from the automaton in Figure 2.7 an automaton M1
P1 := T [i + j ] = T [i + j + n]. This means (see Section 2.4) that M1 is constructed so that it accepts tuples t = (w1, w2, w3)
if and only if |w1| = |w2| = |w3| and substitutions i = [w1]msd_2, j = [w2]msd_2, and n = [w3]msd_2 are satisfying P1. Walnut
then using M1 constructs an automaton M2 for P2 := ∀j, j < n =⇒ T [i + j ] = T [i + n + j ]. The automaton M2 takes
two inputs representing the two free variables i and n in P2. Walnut continues by constructing the automaton M3 for
P3 := ∃n∀j, j < n =⇒ T [i + j ] = T [i + n + j ]. In the end, Walnut returns true if M3 accepts anything. The fact that M1,M2,
and M3 exist is explained in Section 2.4. The details of how Walnut constructs these automata are explained in Section 4.
The details of what comprises a valid predicate is explained in Section 3. To see more examples of the properties of the
Thue-Morse word and their proofs see Section 7.1.

We can extend the deﬁnition of automatic words to higher dimensions. The (n-dimensional) automatic word

is an inﬁnite word over Σ for which there exist number systems Sj and an automaton with output

(cid:162)

i1≥0,i2≥0,...,in≥0

W =(cid:161)ai1,i2,...,in
M(cid:161)Q, q0,O, δ, Σ,S1,S2,...,Sn
(cid:164)···(cid:163)[πn[x]]Sn

(cid:162)

(cid:164) = a[π1[x]]S1 ,[π2[x]]S2 ,...,[πn [x]]Sn .

for which reading x, such that πj (x) ∈ RSj for all j , outputs

W(cid:163)[π1[x]]S1

(cid:164)(cid:163)[π2[x]]S2

2.4 Automata accepting Predicates

In Walnut, we are interested in automaton M accepting same-length representations in number systems S1,S2,...,Sn of
integers x1, x2,..., xn satisfying some predicate P. When this is the case we say that automaton M accepts the predicate P
(or equivalentlyM accepts relation R of tuples satisfying P). We already saw a few examples of such automata in Figures
2.1–2.6. From [1], also see [6], and as it will be proved again in Section 4, for predicate P in Presburger arithmetic such
an automaton always exists. Presburger arithmetic is the ﬁrst-order theory of natural numbers, in which predicates are
consisted of constants (natural numbers), variables over natural numbers, existential quantiﬁers, universal quantiﬁers,
logical operators (conjunction, disjunction, negation, exclusive disjunction, implication, equivalence), arithmetic operators
(addition, subtraction, multiplication and division by constants), and comparison operators (equality, less than, greater than,
less than or equal, greater than or equal)4.

You can ﬁnd the list of all operators in table 3.1. This list has three operators, namely, reverse ` ,indexing [], and calling $,
that are not allowed in Presburger arithmetic. By indexing we mean indexing into an automatic word, e.g., writing things
like W [i + j ] = W [i + n + j ]; see Section 3.6 for more details. In [7],[4],[6], and also in Section 4.6 we learn that extending
Presburger arithmetic to include indexing is still decidable. In Section 3.7 we learn about calling and in Section 4.5 we learn
that it is just a syntactic sugar and does not add to the power of the extended Presburger arithmetic (one that includes
indexing into automatic words). We learn about reverse operation in Section 4.3. From here on, by “predicate” we mean a
predicate over this extended Presburger arithmetic (extended to include indexing into automatic words) and until we see the
proof in Section 4, we accept the fact that there exist automata accepting such predicates.

In Section 3 we formally deﬁne what constitutes a predicate, but ﬁrst let us see a few examples:
• P1 := a = 4 & b = 5
• P2 := a = b + c
• P3 := Ax Ey x = 2∗ y | x = 2∗ y + 1
• P4 := T [i + j ] = T [i + n + j ]
4Presburger arithmetic in its formal deﬁnition recognizes only a minimal subset of constants and operators: 0,1,+,=,<,∀, but it is not difﬁcult to show
that all the other objects and operators we mentioned, e.g., multiplication by constants, does not add to the power of Presburger arithmetic and can be
derived from that minimal set of objects. See Section 3.2 for more details. One thing to note here is that subtraction a − b exists only when there exists a
non-negative number c for which b + c = a.

7

We adopt the terminology of free variables from mathematical logic, i.e., a variable that is not bound to a quantiﬁer

(quantiﬁed). For example P3 has no free variables, and can be regarded as a constant, in this case it is always true.

We have seen that, given a predicate P, for any ordering x1, x2,..., xn of free variables and for every assignment of number
systems S1,S2,...,Sn to those variables, there exists an automaton M accepting such a predicate, i.e., a tuple of same length
words t = (w1, w2,..., wn) is accepted by M if and only if the substitutions xi = [wi ]Si satisfy P.
For example, consider the predicate P1. The automaton in Figure 2.1 accepts P1. Furthermore there exists automaton M
accepting tuples (x, y) for which |x| = |y| and substitutions a = [y]msd_2, and b = [x]msd_2 are satisfying P1. There also exists
an automaton N accepting tuples (x, y) for which |x| = |y| and substitutions a = [x]msd_ﬁb and b = [y]lsd_2 are satisfying P1.
By deﬁnition, both M and N also accept the predicate P1.

We would like to annotate predicates so that they contain information on number systems without ambiguity (we will
see how shortly). For such an annotated predicate P and the ordering x1, x2,..., xn on free variables, there exists a unique
minimized automaton accepting the predicate. We denote this unique automaton by

The ordering we ﬁx on variables, in Walnut and throughout this article, is the lexicographic ordering on the variables’

name.

The following are examples of annotated predicates5:

(x1, x2,..., xn) : P.

• P

• P

1 := ?msd_2 a = 4 & b = 5
(cid:48)
2 := ?msd_ﬁb a = b + c
(cid:48)
1 we understand that a,b,4,5 should all be interpreted in msd_2 and = should be interpreted
(cid:48)
From the annotated predicate P
as =msd_2. Hence (a,b) : P
(cid:48)
1 is the automaton accepting msd_2 representations of 4 and 5 as its ﬁrst and second inputs
respectively. Also from annotation ?msd_ﬁb in P

(cid:48)
2 it is clear what to expect from automaton (a,b,c) : P

We can annotate a predicate with multiple number systems, e.g., see Figure 2.9. Here are the rules with which we assign

(cid:48)
2.

number systems to constants, variables, and operators in a predicate:

• If ?S appears inside a pair of parentheses or brackets, then the number system S is effective from the place it occurs in

the predicate to the nearest closing parenthesis or bracket6.

• If ?S appears outside all parentheses and brackets, then the number system S is effective from the place it occurs in the

predicate to the end of predicate.

• If none of the rules above applies, the number system is assumed to be msd_2 by default.

• It is assumed that the number systems do not contradict each other, i.e., a single variable cannot have two different
number systems in one predicate, and all operands of an arithmetic or comparison operator must belong to the same
number system.

We saw in Figure 2.1, the unique automaton (a,b) : P

that when the number system is not speciﬁed it is assumed to be msd_2):

1. In Figure 2.8, we see the automaton (a,b) : a = 4 & b = 13 (recall
(cid:48)

Figure 2.8: The automaton accepting a = 4 & b = 13, does not accept all representations of 4

Note how this automaton fails to accept t = (100, w2) for any w2. This is obviously due to the fact that 13 does not have
a representation of length 3 in msd_2. So we stress again that when we say automaton M accepts predicate P, we mean

5Names for variables, words, and automata in Walnut start with a letter and can contain alphanumerics and underscores. So to distinguish number

system annotations in a predicate we use the preﬁx ?.

6Brackets [] only appear in indexing expressions. See Sections 3 and 3.6 for more details.

8

that M accepts all (tuples of) equal length representations of x1,..., xn satisfying P. Therefore this example conforms to the
deﬁnition.
(a,b) : a = 1 & (?lsd_2 b = 1).

Let us see an example of an automaton having multiple number systems. Figure 2.9 depicts the automaton

Figure 2.9: Automaton accepting a = 1 & (?lsd_2 b = 1)

3 Syntax and Semantic of Predicates in Walnut

3.1 Alphabets

We mentioned in earlier sections that all input and output alphabets of automata are subsets of integers in Walnut. Speciﬁcally
for any automatic word W , we can assume W [i ] is an integer.

3.2 Arithmetic and Alphabetic Constants

Arithmetic constants in a predicate are allowed to be natural numbers only. There is, however, another type of constant: the
alphabetic constant. Alphabetic constants are useful when referring to symbols at particular positions in automatic words.
For example, the predicate that accepts positions for which the automatic word W is 1 is written as W [i ] = @1. In order
to draw the distinction between alphabetic and arithmetic constants, we use alphabetic constants with a preﬁx of @. The
reason we call these constants alphabetic (as opposed to arithmetic) is due to the fact that Walnut does not allow (and it does
not make much sense to allow) predicates that are comparing indexing expressions 3.6 and arithmetic expressions 3.5, e.g.,
expressions such as W [i ] = a + b is not allowed. As we will see in Section 3.8, the only objects that can be compared with
indexing expressions are alphabetic constants and indexing expressions themselves.
Alphabetic constants are ordered like ordinary integers, so we can compare alphabetic constants, just like we can compare
arithmetic constants. For example, @− 1 < @1 is a valid predicate, and it is always true; see Sections 3.6 and 3.8. However, we
cannot use alphabetic constants in arithmetic expressions.

3.3 Variables

A variable’s name must start with a letter and can contain upper- and lower-case alphanumerics and underscores. A variable’s
name cannot be E or A.

3.4 Operators
The full list of operators allowed in predicates can be found in Table 3.17. This list has operator precedences. The lower this
number is, the higher the precedence is. For example, multiplication by constant has the highest precedence. Parentheses
override all precedences. All operators are associative from left to right, except for complement ∼, reverse ` , quantiﬁers E
and A, calling $, and indexing [] which are all associative from right to left.

7we prefer this notation to those familiar from mathematical logic, because we want to liken our notation to those of programming languages, as Walnut

is ultimately a programming language.

9

precedence
1
1
2
2
3
3
3
3
3
3
4
4
5
5
5
6
7
8
8
9
9

operator
∗
/
+
−
=
!=
<
>
<=
>=
∼
`
&
|
∧
=>
<=>
E
A
$
[]

explanation
multiplication by a constant
division by a constant
addition
subtraction
equality
inequality
less than
greater than
less than or equal
greater than or equal
complement
reverse
conjunction
disjunction
exclusive disjunction
implication
equivalence
existential quantiﬁer
universal quantiﬁer
calling
indexing

examples
2∗ x and x ∗ 2
x/2 but not 2/x

Ex, y, z or Ex Ey Ez
Ax, y, z or Ax Ay Az
$M(x, y)
T [i + j ]

Table 3.1: List of operators in Walnut

3.5 Arithmetic Expressions
The permissible arithmetic operators are +,−,∗,/. Equality = is not an arithmetic operator. A constant expression is an
expression involving only constants and arithmetic operators that evaluates to a natural number, e.g., 4,3+ 2,6/4,2∗ 3 but
not −3 nor 2− 3. An arithmetic expression is deﬁned recursively in the usual way:
• A constant expression is an arithmetic expression, e.g., 2,10,7− 4, but not −1.

• A variable is an arithmetic expression, e.g., x, y, z,etc.

• For arithmetic expression e, the expression (e) is also arithmetic.
• For arithmetic expression e1 and e2 both of e1 + e2 and e1 − e2 are arithmetic expressions.
• For variable x and constant expression c all of x ∗ c,c ∗ x, and x/c are arithmetic expressions.
• For arithmetic expression e and constant expression c all of (e)∗ c, c ∗ (e), and (e)/c are arithmetic expressions.

An arithmetic expression on its own is not a predicate, and it is not meaningful to talk about an automaton accepting an
arithmetic expression. For example, talking about an automaton accepting x + y + z = 0 makes sense, while talking about an
automaton accepting x + y + z is not meaningful. Walnut reports an error if the user tries to construct an automaton for an
arithmetic expression.

See Section 4.4 to see how Walnut constructs automaton for valid predicates like

(y1 ⊗ y2 ⊗···⊗ ym)(cid:60) (x1 ⊗ x2 ⊗···⊗ xn),

where the xi and y j are variables or arithmetic constants, ⊗ are arithmetic operators, and(cid:60) is a comparison operator.

10

3.6 Indexing Expressions and Their Semantic Rules
For an n-dimensional automatic word W , an indexing expression is W [e1][e2]···[en] where the ei are either arithmetic
expressions or predicates with one free variable.

An indexing expression on its own is not a valid predicate, and it is not meaningful to talk about automata accepting
indexing expressions. Smallest predicates involving indexing expressions are deﬁned in Section 3.8 and they involve
comparison operators.

We use indexing expressions to refer to positions indicated by ei . The semantic of predicates involving indexing

expressions can be derived from the following rule:

Deﬁnition 4 (semantic rule regarding indexing). Suppose automatic word W , expressions e1,e2,...,en where the ei are
either arithmetic expressions or predicates with one free variable, free variables x1, x2,..., xm occurring in the ei , and an
alphabetic constant α are given. Predicate W [e1][e2]···[en] = @α is satisﬁed by substitutions xk = vk for all k, if all of the
following hold:

• If ei is an arithmetic expression, then ai is the value of the ei when evaluated at xk = vk for all k.
• If ei is a predicate with one free variable, then it is satisﬁed by substitutions xk = vk for all k. Let ai equals vk when xk
is the free variable in ei .

• The symbol W [a1][a2]...[an] equals α.
Having this rule, coming up with similar rules for other comparison operators, e.g., W [e1][e2]···[en] < @α, and even pred-
(cid:48)
n], should be straightforward.

icates involving comparison of two automatic words, e.g., W1[e1][e2]···[em]>=W2[e
Recall that alphabetic constants are ordered just like integers.

(cid:48)
1][e

2]···[e
(cid:48)

3.7 Calling Expressions and Their Semantic Rules

For an automaton M with n inputs a calling expression is $M(e1,e2,...,en) where the ei are either arithmetic expressions
or predicates with one free variable. For such an expression, we say that M is called with arguments e1,e2,...,en. A calling
expression on its own is a valid predicate, as we will see in Section 3.8.

Deﬁnition 5 (semantic rule regarding calling). Suppose M is the automaton y1, y2,..., yn : P for some predicate P. Suppose
expressions e1,e2,...,en where the ei are either arithmetic expressions or predicates with one free variable, and free variables
x1, x2,..., xm occurring in the ei are given. Predicate $M(e1,e2,··· ,en) is satisﬁed by substitutions xk = vk for all k, if all of
the following hold:

• If ei is an arithmetic expression, then ai is the value of ei when evaluated at xk = vk for all k.
• If ei is a predicate with one free variable, then it is satisﬁed by substitutions xk = vk for all k. Let ai equals vk when xk
is the free variable in ei .
• P is satisﬁed by substitutions yi = ai for all i .

3.8 Relative Expressions
Comparison operators are =,!=,<,>,<=, and >=. A relative expression is any of the following:

• An expression e1(cid:60) e2 where e1 and e2 are arithmetic expressions and(cid:60) is any comparison operator.
• An expression e1(cid:60) e2 where e1 and e2 are indexing expressions and/or alphabetic constants and(cid:60) is any comparison

operator.

• A calling expression is a relative expression.

We stress that W [a] = b + 2 is not a relative expression based on the deﬁnition above, since W [a] is an indexing expression
and b + 2 is an arithmetic expression. We will see shortly that any relative expression is a predicate. Section 4.4 explains how
to construct automata accepting relative expressions.

11

3.9 Predicates

A predicate is an expression formed from relative expressions and logical operators:

• Every relative expression is a predicate.
• For every predicate P all of (P), ∼ (P) and `(P) are predicates.
• For every predicate P1 and P2 all of P1 & P2, P1 | P2, P1 ∧ P2, P1 => P2, P1 <=> P2 are predicates.
• For every predicate P and free variables x1, x2,..., xn both of Ex1, x2,..., xn P and Ax1, x2,..., xn P are predicates.

The semantic rules with which we assign true and false values to predicates deﬁned here can be obtained by adding the
semantic rules for indexing and calling to the well-known semantics of ﬁrst-order logic and Presburger arithmetic.

Walnut provides two commands for converting predicates to automata accepting them: eval and def; see Sections 7.1

and 7.2, respectively.

4 Decision Procedure: Walnut’s Implementation

In this section, we learn about a procedure that takes a predicate and constructs an automaton accepting that predicate. The
procedure explained here is what implemented in Walnut, and we shall call it the decision procedure.

For every deﬁned number system, Walnut knows the automata for valid representations, addition, equality, and less-than
predicates/relations. Every predicate is ultimately built out of these four predicates using logical operators. So we only
need to explain the construction of automata for complex predicates from automata for simpler subpredicates. We start by
explaining cross product in Section 4.1, which is the core object when constructing automata for predicates formed from
binary logical operators, i.e., &,|,∧,=>,<=>. Then we move on to quantiﬁcation in Section 4.2, explaining the construction
of automata for predicates formed from E and A operators. In Section 4.3, we discuss construction of automata for the
complement ∼ and reverse ` operators. With these tools at our disposal, we are on the right track to construct automata for
complex predicates formed from comparison and arithmetic operators, e.g., ∗,/,>,<=,etc. which we explain in Section 4.4.

4.1 Cross Product

Let M(cid:161)Q, q0,F, δ,S1,...,Sm

(cid:162) be the automaton (x1,..., xm) : P and (x
(cid:48)(cid:161)Q
(cid:162) and M
(cid:48)
(cid:48)
(cid:48)
(cid:48)
(cid:48)
, δ(cid:48)
(cid:48)
(cid:48)
1,...,S
,S
1,..., x
respectively.
n) : P
0,F
p} where p ≤ m + n be the union of {x1,..., xm} and {x
j then Si = S
(cid:48)
(cid:48)
(cid:48)(cid:48)
(cid:48)
(cid:48)(cid:48)
(cid:48)
n
n} and
j. Let {x
1,..., x
1 ,..., x
= x
(cid:48)
(cid:48)(cid:48)
(cid:48)(cid:48)
j , let S
k denote Si or
k

Let us assume that if xi = x
(cid:48)(cid:48)
further assume that the x
i are appearing in lexicographic order. Depending on whether x
(cid:48)
S
j respectively. Then the cross product of M and M

= xi or x

is the tuple

(cid:48)(cid:48)
k

, q

(cid:48)

(cid:48)

(cid:48)

,(q0, q

0), δ(cid:48)(cid:48)
(cid:48)

(cid:161)Q ×Q

denoted by M × M
(cid:48)

where the transition function is deﬁned to be

(cid:162)
),(γ1,..., γp)(cid:162) =(cid:161)δ(q,(α1,..., αm)), δ(cid:48)
= xi or x
= x
(cid:48)(cid:48)
(cid:48)(cid:48)
for γk equals αi or βj depending on whether x
k
k
(cid:48)(cid:48) ⊆ Q ×Q
, let (M × M
(cid:48)
(cid:48)
(cid:48)(cid:170), the automaton (M × M
set of ﬁnal states is not speciﬁed. For F
(cid:48) ∈ F
), we obtain automaton (x

(cid:48)(cid:48) =(cid:169)(q, q

δ(cid:48)(cid:48)(cid:161)(q, q

) : q ∈ F and q

(cid:48)(cid:48)
(cid:48)(cid:48)
1,...,S
,S
p

)(F

(cid:48)(cid:48)

(cid:48)

(cid:48)

.

,(β1,..., βn))(cid:162)
)(F ) denote the automaton(cid:161)Q ×Q
j respectively. Note that M × M
(cid:48)

(q

(cid:48)

(cid:48)

(cid:48)

Theorem 6. For F
minimizing (M × M
(cid:48)(cid:48)
(cid:48)(cid:48)
p) : P & P
1 ,..., x
Proof. Based on the deﬁnition for cross product, for M × M
have to have the
. But that is exactly the same condition that needs to hold for number system
same number systems assigned in P and P
annotations in P & P
| are all equal and wi = w
n) such that wi ∈ Σ∗
(cid:48)
(cid:48)
j
= xi or x
= wi or w

where |wi| and |w
(cid:48)
(cid:48)
and w
j
j
= w
(cid:48)
(cid:48)(cid:48)
(cid:48)(cid:48)
j depending on whether x
k
k

Let t = (w1,..., wm) and t
(cid:48)(cid:48) = (w

to be consistent (in the sense deﬁned in the last bullet in Page 8).

to be deﬁned, the same variables in P and P

whenever xi = x

(cid:48)(cid:48)
p) such that w

(cid:48) = (w
(cid:48)(cid:48)
1 ,..., w

) accepts predicate P & P

(cid:48)
1,..., w

(cid:48)
j . Let t

. Furthermore,

∈ Σ∗
(cid:48)
S
j

= x

(cid:48)
j .

)(F

(cid:48)(cid:48)
k

(cid:48)(cid:48)
k

Si

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)(cid:48)

(cid:48)

is not an automaton since a
(cid:48)
,(q0, q

(cid:48)(cid:48)
(cid:48)(cid:48)
1,...,S
,S
p

(cid:48)
0),F

, δ(cid:48)(cid:48)

(cid:48)(cid:48)

(cid:162).

We have the following equivalent statements:
1. (M × M

) accepts t

)(F

(cid:48)(cid:48)

(cid:48)(cid:48)

(cid:48)

.

12

2. There is a path from (q0, q

(cid:48)
0) to (q, q

(cid:48)

) ∈ F

(cid:48)(cid:48)

in M × M

(cid:48)

reading t

(cid:48)(cid:48)

.

3. There is a path from q0 to q in M reading t, and there is a path from q

(cid:48)

(cid:48)
0 to q

(cid:48)

in M

reading t

(cid:48)

.

(cid:48)

(cid:48)

4. M accepts t and M
5. P is satisﬁed by substituting xi = [wi ]Si for all i , and P

accepts t

.

(cid:48)

6. P & P

is satisﬁed by substituting x

(cid:48)(cid:48)
k

= [w

(cid:48)(cid:48)
(cid:48)(cid:48)
k ]S
k

.

(cid:48)

is satisﬁed by substituting x

(cid:48)
j

= [w

(cid:48)
(cid:48)
j ]S
j

for all j .

Obviously both the construction of cross product and minimizing automata can be carried out using algorithmic

procedures. Therefore Theorem 6 gives us a procedure for constructing the automaton for conjunction.

With proper deﬁnitions for F
Let us construct the automaton (a,b) : a = 1 & b = 2 from (a) : a = 1 in Figure 4.1 and (b) : b = 2 in Figure 4.2.

(cid:48)(cid:48)

, we have similar theorems for P ⊗ P

(cid:48)

when ⊗ is any other binary logical operator.

Figure 4.1: Automaton (a) : a = 1

Figure 4.2: Automaton (b) : b = 2

Recall that transitions not depicted are transitions to a dead state. The cross product operation is depicted below:

Figure 4.3: Cross product (a) : a = 1× (b) : b = 2

Making (1,2) a ﬁnal state, minimizing, and renaming the states, we get the automaton in Figure 4.4.

Figure 4.4: Automaton (a,b) : a = 1 & b = 2

13

4.2 Quantiﬁcation
In this section we learn how to construct an automaton (x1,..., xi−1, xi+1,..., xm) : Exi P from automaton (x1,..., xm) : P.
be the predicate Exi P. We ﬁrst construct the

(cid:162) be the automaton (x1,..., xm) : P and let P

Let M(cid:161)Q, q0,F, δ,S1,...,Sm

(cid:48)

nondeterministic automaton E(M,i )

,S1,...,Si−1,Si+1,...,Sm
from M by eliminating the i ’th input (coordinate) on all transitions, i.e., letting

δ(cid:48)(cid:161)q,(α1,..., αi−1, αi+1,..., αm)(cid:162) =(cid:169)δ(q,(α1,..., αi−1, αi , αi+1,..., αm)) : for all αi ∈ ΣSi

(cid:170).

(cid:161)Q, q0,F, δ(cid:48)

(cid:162)

For example, letting M be the automaton (a,b) : a = 1 & b = 2 depicted in Figure 4.4, the automaton E(M,2) is depicted as

follows:

Figure 4.5: Non-deterministic automaton E(M,2)

By the deﬁnition of transition function of E(M,i ), i.e., δ(cid:48)

, it is easy to see that if M accepts (w1,..., wi−1, wi , wi+1,..., wm),

then E(M,i ) accepts

(w1,..., wi−1, wi+1,..., wm).

However, there might be t = (w1,..., wi−1, wi+1,..., wm) where the |w j| are equal for all j (cid:54)= i and substitutions x j = [w j ]Sj
for all j (cid:54)= i , satisﬁes P
In our example M accepts (0n1,0n−110) for all n ≥ 1, and as it is clear E(M,2) accepts (0n1) for all n ≥ 1. However E(M,2)
does not accept (1), whereas (1) should be accepted by any automaton accepting Eb (a = 1 & b = 2).

but E(M,i ) does not accept t. In other words, there are cases where E(M,i ) does not accept P

(cid:48)

(cid:48)

.

Therefore, we have to do more work on E(M,i ), to get to an automaton for P

. However as we will see in Lemma 1,
the automaton E(M,i ) might only miss an insigniﬁcant portion of accepted tuples of an automaton accepting P
. These
insigniﬁcant tuples missed by E(M,i ) are those with leading or trailing zeros. The good news is that with a little bit of
technical work, it is possible to revive even these insigniﬁcant tuples.

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

, then t is also satisfying P

, and i be as in the discussion above, and suppose t = (w1,..., wi−1, wi+1,..., wm) is some tuple
Lemma 1. Let M,P,P
is satisﬁed with substitutions x j = [w j ]Sj for j (cid:54)= i , then there exists a constant k ≥ 0 and
of same length words. If P
tk = (wk,1,..., wk,i−1, wk,i+1,..., wk,m) such that for all j (cid:54)= i we have wk,j = 0k w j or wk,j = w j 0k depending on whether Sj is
msd or lsd, and tk is accepted by E(M,i ). It is also the case that whenever tk for any k ≥ 0, with the appropriate substitutions,
is satisfying P
:= Exi P means that there exists a natural number v, such that
Proof. Substitutions x j = [w j ]Sj for j (cid:54)= i satisfying predicate P
the substitutions above together with xi = v is satisfying the predicate P. By deﬁnition of number systems, there exists a word
wi such that v = [wi ]Si. Also by deﬁnition of number systems for any integer y and word w, if we have y = [w]S, then either
y = [0k w]S for all k ≥ 0 or y = [w0k]S for all k ≥ 0 depending on whether S is msd or lsd. Therefore there exists an integer
k such that wk,i is either 0k wi or wi 0k depending on whether Sj is msd or lsd and v = [wk,i ]Si and |wk,i| = |w j|+ k for all
j (cid:54)= i . Therefore (wk,1,..., wk,i−1, wk,i , wk,i+1,..., wk,m) is accepted by M where for all j we have wk,j = 0k w j or wk,j = w j 0k
depending on whether Sj is msd or lsd. Now by deﬁnition of E(M,i ), we know that tk = (wk,1,..., wk,i−1, wk,i+1,..., wk,m) is
accepted by E(M,i ). This completes the ﬁrst part of the lemma.

(cid:48)

.

The second part follows very easily from the same properties of number systems mentioned in the proof of the ﬁrst part

of the lemma.

Based on Lemma 1, to get (x1,..., xi−1, xi+1,..., xm) : Exi P we just have to construct an automaton from E(M,i ) such that
whenever tk for any k ≥ 0 is accepted, t is also accepted. For the case where all Sj for j (cid:54)= i are either all msd or all lsd, we can
come up with an easy algorithm to revive tuples t from tk. In case of all msd, let I be the set of all states in E(M,i ) reachable

14

from the initial state by reading (0,...,0)
(0,...,0)

. We can compute I or F

∗

(cid:48)

, or in case of all lsd, let F

be the set of all states reaching to a ﬁnal state by reading

using breadth-ﬁrst search. In the case of msd the nondeterministic automaton8

∗

(cid:48)

(Q, I ,F, δ(cid:48)

,S1,...,Si−1,Si+1,...,Sn)

and in the case of lsd the nondeterministic automaton
, δ(cid:48)

(Q, q0,F

(cid:48)

,S1,...,Si−1,Si+1,...,Sn)

is equivalent to (x1,..., xi−1, xi+1,..., xm) : Exi P. Determinizing and minimizing this automaton gives us (x1,..., xi−1, xi+1,..., xm) :
Exi P.
accepts Eb a = 1 & b = 2:

In Figure 4.5, the variable a is over msd_2. So the set I is {0,1}, therefore the following nondeterministic automaton

Figure 4.6: Non-deterministic automaton accepting Eb a = 1 & b = 2

Now determinizing and minimizing this automaton gives us (a) : Eb a = 1 & b = 2:

Figure 4.7: (a) : Eb a = 1 & b = 2

Currently if for (x1,..., xn) : P it is not the case that for all j (cid:54)= i number systems Sj are all msd or all lsd, then Walnut only
constructs E(M,i ) for Exi P, which is not theoretically accurate. So the user has to be very cautious when quantifying
predicates over mixed msd and lsd number systems, or in cases where the quantiﬁed automaton is non-arithmetic. For
a deﬁnition of the latter see Section 5.2.
To obtain an automaton for Axi P, note its equivalence to ∼ (Exi ∼ (P)), where ∼ is the logical complement (negation).

See the next section to learn about the complement operator.

4.3 Complement and Reverse
To obtain (x1,..., xm) :∼ (P) from (x1,..., xm) : P, one has to add all transitions to dead state (in Walnut, we call this totalizing
an automaton), and then switching ﬁnal and non-ﬁnal states, but one also has to make sure that the resulting automaton
×···× RSm where Si is the number system assigned to xi in (annotated)
is intersected with the automaton accepting RS1
predicate P. (Recall that RS is the set of all valid representations in the number system S. Also recall that to deﬁne and use a
number system in Walnut, one has to provide automaton accepting the set of all representations in that number system,
therefore automaton accepting RS1

×···× RSm could be constructed easily using cross product explained in Section 4.1.)

Take a look at automaton (a) : ?msd_ﬁb a = 1 depicted in Figure 4.8 that accept words representing 1 in msd_ﬁb.
Now to obtain (a) :∼ (?msd_ﬁb a = 1), we ﬁrst add the dead state and all the transitions to it:
8This is an automaton with multiple initial states. One can show that for every nondeterministic automaton with multiple initial states, there is an

equivalent automaton with only one initial state.

15

Figure 4.8: Number 1 in Fibonacci

Switching ﬁnal and non-ﬁnal states we obtain an automaton accepting {0,1}

∗

∗

1:

\ 0

Figure 4.9: Totalized automaton

Figure 4.10: Switching ﬁnal and non-ﬁnal states

But then this automaton accepts words that have consecutive 1’s which are not acceptable Fibonacci representations. So
to get the ﬁnal answer we have to intersect this automaton with the one depicted in Figure 2.6. The result is depicted in 4.11.

Figure 4.11: Automata accepting all numbers in Fibonacci except 1

The reverse operator is not a logical operator per se, but we include it because it is useful when working with automata.

The operand of the reverse operator is an automaton 9. The result is an automaton with all its transitions reversed.

4.4 Arithmetic and Comparison Operators
Recall that for every number system S that we use in Walnut the three automata (a,b,c) : ?S a = b + c, (a,b) : ?S a = b10, and
(a,b) : ?S a < b are deﬁned. In this section we show that using these three automata and the decision procedure outlined in
Sections 4.1–4.3, we can construct automata for more complex relative expressions with lots of arithmetic operators.

9Unlike the reverse operator, operands for logical operators are predicates. The reader however understands the very thin and superﬁcial distinction
between automata and predicates in this article.
10This automaton does not need to be deﬁned explicitly by the user, because we assumed for all number systems S in Walnut a =S b if and only if a = b.

16

(cid:48)

is the predecessor of c, i.e., c

For a constant c > 0, a natural number, automata (a) : ?S a = c can be constructed recursively using automata (b) : ?S b = c
(cid:48)
and (a,b) : ?S a = b + 1 where c
(cid:48) + 1 = c. For example, predicate ?S a = 2 is equivalent to
?S Eb a = b + 1 & b = 1. Similarly ?S b = 1 is equivalent to ?S Eb2 b = b2 + 1 & b2 = 0. Based on Deﬁnition 2, for all number
systems S, the automaton for ?S b2 = 0 is the simple automaton accepting 0
. To construct automaton (a,b) : ?S a = b + 1,
just note that the predicate is equivalent to ?S Ec a = b + c & c = 1.
A similar recursive argument can be applied to obtain (a,b) : a = c ∗ b for a constant c > 0, i.e., one can construct
(a,b) : (a = b2+ b) & (b2 = c
is the predecessor of c. The similar argument can be applied to obtain automata for
division by constants or subtraction.
To construct (a,b) : ?S a <= b, note its equivalence to (a,b) : ?S a < b | a = b. With similar arguments, one can construct

∗

(cid:48)∗ b) where c

(cid:48)

automaton for other comparison operators.

It is important to understand Walnut’s construction of

(y, x1, x2,..., xn) : ?S y(cid:60) (x1 ⊗1 x2 ⊗2 ···⊗n−1 xn)

where n ≥ 3. Here(cid:60) denotes an arbitrary comparison operator, and the ⊗i are arbitrary arithmetic operators. Also let y and

xi be variables or arithmetic constants. All arithmetic operators in Walnut are associative from left to right; see Section 3.4.
Based on this, Walnut ﬁrst transforms the predicate to an equivalent predicate

(y, x1, x2,..., xn) : ?S Ey1,..., yn−2 (y1 = x1 ⊗1 x2) & (y2 = y1 ⊗2 x3) &··· & (y = yn−2 ⊗n−1 xn).

Now Walnut has all the resources necessary to construct this last automaton.

For example, to construct (a) : 0<=(a − 1+ 1), Walnut ﬁrst transforms it to (a) : Eb (b = a − 1) & (0 = b + 1). The automaton

is depicted below:

Figure 4.12: Automaton for 0<=a − 1+ 1 does not accept 0

∗

There is something here that is worth noting. Note how this automaton does not accept 0? In arithmetic over integers
a = 0 satisﬁes the predicate. However in Presburger arithmetic setting a = 0 gives b = −1, which is not acceptable, since
Presburger arithmetic is deﬁned over natural numbers. In order to ﬁx this issue, try to always postpone subtraction and
division to the rightmost position in your predicates. For example, writing (a) : 0 <= (a + 1− 1) results in

Figure 4.13: Automata for 0<=a + 1− 1 accepts 0

∗

4.5 Calling an Automaton

In Section 3.7, we learned about the syntax and semantic of calling an automaton. A calling expression is a kind of syntactic
sugar to save some space when writing long and complicated predicates. Suppose we already have computed the automaton
(x1, x2,..., xn) : P and given it the name M. We can refer to P in a predicate P
without writing P all over again, by just

(cid:48)

17

writing $M(e1,e2,...,en), where $ symbol is to signify that M is an automaton, and the ei are either arithmetic expressions or
predicates with exactly one free variable. In such case, we say, predicate P

is calling M (or is calling predicate P).

(cid:48)

To construct automaton for $M(e1,e2,...,en), Walnut constructs the equivalent automaton:

Ex1, x2,..., xn P & (x1 = e

(cid:48)
1) & (x2 = e

(cid:48)
2) &··· & (xn = e

(cid:48)
n) & (e j1) & (e j2) & ... & (e jk )

where x1, x2,..., xn are the free variables in P, k is the number of predicates in e1,e2,...,en, j1, j2,..., jk are indices of
(cid:48)
predicates among e1,e2,...,en, and if e j is an arithmetic expression, then e
j is the
free variable occurring in e j .

= e j , otherwise e j is a predicate, and e

(cid:48)
j

The fact that this predicate is equivalent to $M(e1,e2,...,en) could be obtained easily using the semantic rule explained
in Section 3.7. Walnut’s implementation includes some considerations to improve efﬁciency. For example, obviously when
e j is a variable, we do not need to introduce a new variable x j .

Calling an automaton inside a predicate P
because Walnut does not need to construct M every time we write $M in P

is also more efﬁcient than copying P over and over again in P

(cid:48)

(cid:48)

.

(cid:48)

. This is

the command def saves the automaton M so it can be called later from other predicates like P
information on def command.

The commands def and eval in Walnut are responsible for constructing the automaton M from predicate P. Unlike eval,
. See Section 7.2 for more
To see an example, let M be the automaton (a,b) : a + b = 10, and let Q be the predicate $M(x, y) & y = 8. The automaton

(cid:48)

in Figure 4.14 accepts Q.

Figure 4.14: Automaton accepting Q

Please refer to Section 7.2, which is devoted to examples of calling automata.

When calling an automaton M, one has to make sure that the j ’th argument is in the same number system as j ’th input
in M for all j .

4.6 Indexing an Automatic Word

Suppose W is an n-dimensional automatic word and M(cid:161)Q, q0,O, δ, Σ,S1,S2,...,Sn
output. Also let α be an alphabetic constant. We note that (x1, x2,..., xn) : W [x1][x2]···[xn] = @α is the automaton
when minimized, where F =(cid:169)q : O(q) = α(cid:170). Similar arguments can be made for other comparison operators.
Suppose W1 and W2 are m- and n-dimensional automatic words, respectively, and let M1 and M2 be their corresponding
automata with output. We note that (x1, x2,..., xm, y1, y2,..., yn) : W1[x1][x2]···[xm] = W2[y1][y2]···[yn] is (M1×M2)(F ) when
minimized, where F contains all (q1, q2) where q1 and q2 are states of M1 and M2, respectively, and they have the same
output. Similar arguments can be made for other comparison operators.

(cid:162) is its corresponding automaton with

(cid:161)Q, q0,F, δ,S1,S2,...,Sn

(cid:162)

The above statements can be proved easily using the semantic rule explained in Section 3.6. Now what if indices are
arithmetic expressions and/or predicates with one free variable? The construction is based on substitutions similar to the
ones mentioned for calling expressions in Section 4.5.

18

5 Special Automata in Walnut

5.1 True and False Automata

In Section 2.4 we saw an example of a predicate with no free variables:

Ax Ey x = 2∗ y | x = 2∗ y + 1

This predicate evaluates to true (it is a tautology). Here is an example of a predicate with no free variable that evaluates to
false (contradiction):

Ex x > x + 1

Walnut assigns a special automaton called true (false) automaton to predicates with no free variable that evaluate to true
(false). However there could be predicates with free variables that are converted to true or false automata. See the following
conventions implemented in Walnut:

• Conjunction (disjunction) of true automaton with automaton M yields M (true automaton, respectively).

• Conjunction (disjunction) of false automaton with automaton M yields false automaton (M, respectively).

• Negation of true automaton is false automaton and vice versa.

• Conventions for other logical operators follow from the above.

These conventions are reﬂecting the following facts from mathematical logic (for a predicate P):

• P & true and P | true are equivalent to P and true respectively.
• P & false and P | false are equivalent to false and P respectively.
• ∼ true = false and ∼ false = true.

As an example, the automaton (y) : (Ax x < x + 1) & y = 2 is exactly the same as automaton (y) : y = 2. As another example, the
automaton (y) : (Ex x < 0) & y = 2 is the false automaton. As in our last example, note that ∼ (Ex x < 0) is the true automaton.

Figures 5.1 and 5.2 show the special way Walnut represents true and false automata.

Figure 5.1: True automaton

Figure 5.2: False automaton

5.2 Non-arithmetic Automata

There is a need for automata in which inputs (or some of them) do not represent numbers in a speciﬁc number system.
These automata might accept patterns, or they might be relying on some non-arithmetic instructions.

∗

∗

For example, the pattern 0

represents powers of 2 in msd_2. However, the same pattern represents powers of 2 in
lsd_2. Therefore, by not assigning a number system to the automaton M accepting the pattern 0
, we are allowed to call
M both in predicates in msd_2 and in predicates in lsd_2. Assigning number systems to automata accepting patterns usually
does not make much sense. See more examples in Section 7.3.

10

∗

∗

10

Allowing non-arithmetic automata is specially helpful when working with the class of paperfolding words. These words
are deﬁned with an automaton that takes two inputs. One input is a number that represents a position in the paperfolding
word and the other input is folding instruction that does not represent numbers. To see how Walnut can be used to prove
properties of paperfolding words see [8].

19

6 Installation

Walnut is a command line program. You can run Walnut on any platform as long as you have Java 8 or later (preferably JDK 8
or higher) installed. To see which version of Java is installed on your machine type the following in the terminal (without the
command line prompt $):
$java −version
If you download Walnut as the zipped ﬁle Walnut.zip ﬁrst thing you need to do is to uncompress it. Then open the terminal
(or command prompt in Windows), and change the directory to “.../Walnut/bin/”, and run Walnut by typing:

$java Main . prover

To exit Walnut, type the following command (with the semicolon):

e x i t ;

To make the distinction that we are typing a Walnut command, names of all Walnut’s commands are written in green. Walnut
produces graphical representations of automata among other things. Those representations are ﬁles with .gv extensions. In
order to open these ﬁles you need to install Graphviz, a graph visualization package which is available for all platforms. All
text ﬁles that Walnut produces are in the UTF-16 encoding. All text ﬁles that Walnut reads have to be in the UTF-16 encoding
as well.

6.1 Eclipse

As explained in the previous section, you can use the terminal to work with Walnut and enter your commands. However, I
encourage you to use a Java IDE, like Eclipse, because in my opinion, entering commands in the console of a good IDE is
more convenient than doing the same in the terminal. You are only going to run Walnut inside the IDE and use the IDE’s
console (not the source code editor) to enter Walnut commands. Here is the instructions on how to run Walnut inside Eclipse
for Java:

1. Go to this link and download Eclipse for Java for your speciﬁc platform.

2. Downloaded ﬁle is probably compressed. To start Eclipse, ﬁrst uncompress the ﬁle, then click on the ﬁle named

Eclipse.

3. When you run Eclipse, it asks for a workspace address. Feel free to enter the path to your desired directory.

Now we need to import Walnut into Eclipse as a Java project:

4. When in Eclipse, go to “File > Import ... ”. In the dialog that opens up choose “General > Existing Project into Workspace”.

5. In the dialog that opens up, click browse, ﬁnd Walnut (that you downloaded and uncompressed in the Installation

section) and press open. Then click ﬁnish.

6. Close the Welcome page in your Eclipse window.

7. On the "Project Explorer" (probably) on the left of your screen, you can see only one project (the one that you just

imported). Click on it. Then click on “src”. Then double click on “prover.java”.

8. You will see a green circle with a white triangle inside it. Click on it. This causes Walnut to run.

9. You can enter your Walnut commands in the console window in your Eclipse. If you are not able to ﬁnd the console

window, go to “Window > Show View > Other > General > Console” to open it.

7 Commands

Every command ends in either a colon or a semicolon. If you want to see the reports on the intermediate steps of a
computation use colon, otherwise use semicolon. For example, if we type:

eval

t e s t "a = b + 1" :

20

we get an output similar to the following written in the console:
a = b + 1 has 2 s t a t e s : 2ms
t o t a l computation time : 5ms
which explains that the automaton for predicate a = b + 1 has 2 states and it took 2 milliseconds to compute it. We use blue
to denote predicates. Here we use grey to indicate the output produced by Walnut in the console. We use red to indicate
errors in the console.

Whitespace is ignored. You can, for example, span one single command into multiple lines to improve readability. So, for

example, you can write the following interchangeably:

t e s t "a = b + 1" ;
eval
eval
t e s t
"a = b + 1" ;
eval
= b + 1" ;
eval
t e s t
"a = b + 1"
;

t e s t "a

In case we forget to separate the name test and predicate a = b + 1 of the eval command, Walnut catches it by returning

an error:

t e s t "a = b + 1" :

eval
invali d use of eval / def command

: eval

t e s t "a = b + 1" :

Here is the full list of commands in Walnut and we will go over them one by one in detail:

• exit

• eval <name> <predicate>

• def <name> <predicate>

• reg <name> <number system> <regular expression>

• reg <name> <alphabet> <regular expression>

• load <ﬁle name>

7.1 eval: eval <name> <predicate>

This is the most important command in Walnut and it stands for “evaluate.” This command takes two arguments. The
ﬁrst argument is a name for the evaluation. Name of the evaluation starts with a letter and could contain alphanumerics
and underscore. The ﬁles generated as the result of the eval command, all share the name given in the ﬁrst argument. The
second argument is a predicate that we want to evaluate. Predicates are always placed between quotation marks. To see the
deﬁnition for predicates see Section 3.9. In this article we typeset predicates in math mode in LATEX. However, the reader
should note that this typesetting is different from the one they see in the terminal. Let us see an example:

four "a = 4" :

eval
a = 4 has 4 s t a t e s : 3ms
t o t a l computation time : 3ms
This evaluates to an automaton with one binary input labeled a. This is the automaton (a) : a = 4. To learn about the notation
(a) : a = 4 see Section 2.4. The automaton accepts only if a is the most-signiﬁcant-digit-ﬁrst binary representation of 4, i.e., if
it belongs to 0
100. This automaton is drawn and saved in the directory “/Walnut/Result/” in a ﬁle named four.gv as shown
in Figure 7.1. The graph drawing software Graphviz is required to open this ﬁle; see Section 6.

∗

21

Figure 7.1: Content of the ﬁle four.gv

How does Walnut know to use the most-signiﬁcant-digit-ﬁrst binary system? Walnut defaults to msd_2 which is how we
show the most-signiﬁcant-digit-ﬁrst binary system in Walnut; see Section 2.2 to learn about this notation and to learn about
number systems in general. To explicitly mention msd_2 type:

eval

four "?msd_2 a = 4" ;

Similarly, for the least-signiﬁcant-digit-ﬁrst binary type:

eval

lsd_four "?lsd_2 a = 4" ;

Figure 7.2: lsd_four.gv

Here is another example, this time in lsd_3:

eval

ternary_example "?lsd_3 a < 5" ;

Figure 7.3: ternary_example.gv

∗

∗

∗

This automaton accepts exactly those words representing the numbers 0,1,2,3,and 4 in the least-signiﬁcant-digit ternary
base, i.e., 0
respectively. Note the trailing zeros in the representations as opposed to the leading zeros in
a most-signiﬁcant-digit-ﬁrst (msd) number system. Also note that this automaton accepts the empty word. This is because
in the deﬁnition of number systems we agreed that the empty word represents 0.

,010

,110

,10

,20

∗

∗

Let us see an example of an automaton with 2 inputs:

two_inputs "b = a + 1" ;

eval
This constructs the automaton (a,b) : b = a+1 in which the ﬁrst input corresponds to a, and the second input corresponds to
b. Recall from Section 2.4 that Walnut uses lexicographic ordering on the name of variables when constructing automata. So,
for example, even though the ﬁrst variable that appears in b = a + 1 is b, it corresponds to the second input in the automaton.

22

Figure 7.4: two_inputs.gv

Walnut generates two other ﬁles as the outcomes of the eval command which can also be found in the directory
“/Walnut/Result/”. For the evaluation two_inputs, these two ﬁles are named two_inputs_log.txt and two_inputs.txt and they
are both text ﬁles.

The ﬁle two_inputs_log.txt contains the details of the evaluation including the intermediate steps and the time each of

those steps took to complete. In our example, there are not many intermediate steps involved:

b = 2 has 3 s t a t e s : 0ms
t o t a l computation time : 0ms

File 1: two_inputs_log.txt

The ﬁle two_inputs.txt contains the deﬁnition of the automaton in Figure 7.4:

1 msd_2 msd_2
2
3
4
5
6
7

0 0
0 0 −> 0
0 1 −> 1
1 1 −> 0
1 1
1 0 −> 1

File 2: two_inputs.txt

Line 1 indicates that the ﬁrst and the second inputs of the automaton are both in msd_2. The two states 0 and 1 in Figure
7.4 are declared in Lines 2 and 6. The ﬁrst zero in Line 2 refers to the state 0 and the second zero refers to its output. Likewise,
the ﬁrst one in Line 6 refers to the state 1 and the second one refers to its output. Note that the automaton for evaluation
two_inputs is not an automaton with output, however all automata are stored as automata with outputs in Walnut; see
Section 2.1. For an ordinary automaton, states with non-zero outputs are interpreted as ﬁnal states, and states with zero
outputs are interpreted as non-ﬁnal states. So here state 0 is non-ﬁnal, whereas state 1 is ﬁnal. Transitions for states 0 and 1
are declared in Lines 3-5 and 7 respectively. For example, state 0 on (0,0) transitions to itself, and on (0,1) transitions to state
1. Transitions not depicted are transitions to the dead state. For example, state 1 transitions to the dead state on every tuple
except (1,0). To learn more about deﬁnition of an automaton in text ﬁles and how to manually deﬁne automata in text ﬁles
see Section 8.1.

We talked about square subwords in the Thue-Morse word. The following predicate is satisﬁed by (i ,n) if

In Section 2.3, we talked about the Thue-Morse word. The Thue-Morse word’s corresponding automaton with output,
depicted in Figure 2.7, is deﬁned in directory “/Walnut/Word Automata Library/” in a ﬁle named T.txt. We can refer to the
Thue-Morse word in predicates by typing T . See Section 8.2 on how to deﬁne new automatic words in Walnut.
T [i ..i + n − 1] = T [i + n..i + 2n − 1], i.e., if there exists a square subword of length 2n starting at position i .
eval squares_in_thue_morse_word "n > 0 & (Ak k < n => T [i + k] = T [i + n + k])" ;
The order of a square is half its length. Now if we want to ﬁnd all natural numbers n for which there exists a square of order n
in the Thue-Morse word, we simply use the existential quantiﬁer E:
eval order_of_squares_in_thue_morse_word "Ei n > 0 & (Ak k < n => T [i + k] = T [i + n + k])" ;

23

Figure 7.5: order_of_squares_in_thue_morse_word.gv

Based on this automaton, the natural number n with msd_2 representation of the form 0
the Thue-Morse word. In other words, the set of orders in the Thue-Morse word is

(cid:169)n : there exists k ≥ 0 such that n = 2k or n = 2k+1 + 2k(cid:170)

∗

(1|11)0

∗

is an order of a square in

Overlaps are the words of the form axaxa where a is a symbol and x is any word, e.g., the word “alfalfa” in English is an
overlap. It is a known that the Thue-Morse word avoids overlaps. How do we make sure, using Walnut, that the Thue-Morse
word does not have any overlaps? The result of the following predicate must be the true automaton; see Section 5.1, if the
Thue-Morse does not have any overlaps:

thue_morse_does_not_have_overlaps "∼ (Ei ,n n > 0 & (Ak k <= n => T [i + k] = T [i + n + k]))" :

eval
n > 0 has 2 s t a t e s : 1ms

k <= n has 2 s t a t e s : 1ms

T [(i + k)] = T [((i + n)+ k)] has 12 s t a t e s : 6ms

(k <= n => T [(i + k)] = T [((i + n)+ k)]) has 25 s t a t e s : 1ms

(Ak(k <= n => T [(i + k)] = T [((i + n)+ k)])) has 1 s t a t e s : 27ms

(n > 0 & (Ak(k <= n => T [(i + k)] = T [((i + n)+ k)]))) has 1 s t a t e s : 0ms

(Ei ,n(n > 0 & (Ak(k <= n => T [(i + k)] = T [((i + n)+ k)])))) has 1 s t a t e s : 1ms

∼ (Ei ,n(n > 0 & (Ak(k <= n => T [(i + k)] = T [((i + n)+ k)])))) has 1 s t a t e s : 0ms

t o t a l computation time : 38ms

Figure 7.6: thue_morse_does_not_have_overlaps.gv

The automaton in Figure 7.6 is the true automaton. For more information see Section 5.1.

Note that if a predicate is not valid Walnut returns an error:

inv ali d "x + y + z " ;

eval
the f i n a l

r e s u l t of

the evaluation i s not of

type automaton

: eval

inv ali d "x + y + z " ;

To understand why this is not a valid predicate see Section 3.5. In the following examples note how Walnut points to the
locations of the errors in the predicates. By saying "char at n", Walnut tries to convey that there is something wrong going on
at the vicinity of the n’th character in the predicate.

invalid2 "(x + y + z = 0" ;

eval
unbalanced parenthesis

: char at 0
: eval

invalid2 "(x + y + z = 0" ;

eval

invalid3 "(∼ x) = 0" ;

24

operator ∼ cannot be applied to the operand x of
: char at 1
: eval

invalid3 "(∼ x) = 0" ;

type variable

invalid4 "T [i + j ] = i − 1" ;

eval
operator = cannot be applied to operands T [(i + j )] and (i − 1) of

types word and arithmetic

r e s p ec ti v e l y

: char at 6
: eval

invalid4 "T [i + j ] = i − 1" ;

invalid5 "T [2] = 1" ;

eval
operator = cannot be applied to operands T [2] and 1 of

r e s p ec ti v e l y

types word and number l i t e r a l

: char at 4
: eval

invalid5 "T [2] = 1" ;
The last example can be ﬁxed as follows:

eval

fixed5 "T [2] = @1" ;

To understand why see Section 3.8.

The last thing to note about the eval command is that Walnut overrides the ﬁles generated by an evaluation if the name

of the evaluation is used in a new evaluation.

7.2 def: def <name> <predicate>

The word def stands for deﬁne. The syntax for this command is exactly the same as the syntax for eval command. The only
difference between this command and eval is that the automaton constructed is saved in the directory “/Walnut/Automata
Library/” for later use. Suppose we write the following:
def sum10 "x + y = 10" ;
This creates as usual the ﬁles sum10.gv, sum10.txt, and sum10_log.txt in the directory “/Walnut/Result/”. However, it also
saves a copy of sum10.txt in the directory “/Walnut/Automata Library/”. Any automaton saved in this directory can be called
in other predicates by referring to its name and the special character $. To learn about calling see Sections 3.7 and 4.5.

Let us see examples of predicates calling the automaton sum10:

lessThanThree "Ea a >= 8 & $sum10(b, a)" ;

eval
This predicate is satisﬁed by numbers b for which there exist an a >= 8 such that b + a = 8, i.e., 0,1,2:

Figure 7.7: lessThanThree.gv

We can send the same variable to both arguments of sum10:

eval

f i v e "$sum10(a, a)" ;

25

We can send constants to any arguments of sum10:

eval

three "$sum10(7, a)" ;

Figure 7.8: ﬁve.gv

Figure 7.9: three.gv

Indeed, we can send any arithmetic expressions or predicates with one free variable to arguments:

eval

eval

three "$sum10(a − 2,3∗ a)" ;
three "Eb $sum10(a,b + 3 = 10)" ;

The resulting automaton for both of these is depicted in Figure 7.9. We can call sum10 to deﬁne new automata:
def threeSum10 "$sum10(x + y, z)" ;
Now we can write

eval

three "Ey, z $threeSum10(x, y, z) & y = 2 & z = 5" ;
The result of this evaluation is again depicted in Figure 7.9.

Now look at the following example:
eval nonsense "$sum10(a = b,4)" ;
argument 1 of

function sum10 cannot be an automaton with != 1 inputs

: char at 1
: eval nonsense "$sum10(a = b,4)" ;

This is because the ﬁrst argument is a predicate with two free variables.

We cannot send a variable in lsd_2 to an automaton that accepts only msd_2, and expect getting anything interesting in

return. The following example would run ﬁne, but the result is another nonsense:

eval another_nonsense "?lsd_2 $sum10(x,4)" ;

The number of arguments when calling an automaton should match the number of inputs of that automaton:

Figure 7.10: another_nonsense.gv

26

i nv a l id "$sum10(x, y, z)" ;

eval
function sum10 requires 2 arguments

: char at 1
: eval

i nv al i d "$sum10(x, y, z)" ;

Always remember the roles of the inputs to an automaton created by the def command. For example, look at the following

examples of the def command:

f1 "y < x " ;
f2 "x < y " ;

def
def
Now the following evaluates to an automaton accepting representations of numbers > 1:
eval greater_than_1 " $f1 ( a , 1 ) " ;
whereas the following evaluates to an automaton accepting representations of numbers < 1:
eval

less_than_1 " $f2 ( a , 1 ) " ;

This is because f1 is an automaton for which the ﬁrst argument is greater than the second argument, whereas, f2 is an
automaton for which the ﬁrst argument is less than the second argument. Always remember that Walnut sorts inputs of an
automaton based on their labels’ lexicographic order.

7.3 reg

The word reg stands for regular expression. Before we talk about this command in detail, let us motivate the need for it
through an example. Suppose we need an automaton accepting msd_2 representations of powers of 2 that are less than
20. There is no straightforward way of constructing an automaton accepting representations of powers of 2 using eval and
def commands11. Remember how def command saves automata deﬁnition in directory “/Walnut/Automata Library/”?
We can manually create a ﬁle power2.txt in this directory and write in it the deﬁnition of an automaton accepting binary
representations of powers of 2:

1 msd_2
2
0 0
0 −> 0
3
1 −> 1
4
5
1 1
0 −> 1
6

File 3: power2.txt

See Section 8.1 to learn the syntaxes of deﬁning an automaton in a text ﬁle. Now we can write a predicate for powers of 2

that are less than 20:
eval power2LessThan20 "$power2(a) & a < 20" ;

Figure 7.11: power2LessThan20.gv

The better approach to this problem is to use the reg command. This command can be used in two different ways:

11The set of powers of 2 is not expressible in Presburger arithmetic. However the extended Presburger arithmetic that involves automatic words is powerful

enough to express this set (why?)

27

1. reg <name> <number system> <regular expression>

2. reg <name> <alphabet> <regular expression>

To construct an automaton that accepts msd_2 representations of powers of 2 we can use the ﬁrst syntax:

reg power2 msd_2 "0

10

" ;

∗

∗

Similar to eval and def command, the second argument is a name. The third argument is a number system, and the last
argument is a regular expression. This will construct an automaton for the regular expression, and saves the result in a ﬁle
named power2.txt in “/Walnut/Automata Library/”, in addition to saving, as usual, the drawing of the automata in power2.gv
in directory “/Walnut/Result/”. The ﬁle power2.txt is exactly the same as File 3.

10

Note that 0

is also the lsd_2 representations of powers of 2. For this reason, there needs to be a way of deﬁning
an automaton from a regular expression that is not restricted to a particular number system. We call such an automaton
a non-arithmetic automaton; see Section 5.2. To create a non-arithmetic automaton accepting a pattern we can use the
second version of the reg command in which instead of a number system we specify an alphabet:

∗

∗

reg general_power2 { 0 , 1 } "0

10

" ;

∗

∗

The ﬁle general_power2.txt generated by this command is the following:

1
2
3
4
5
6

{ 0 , 1 }
0 0
0 −> 0
1 −> 1
1 1
0 −> 1

File 4: general_power2.txt

The only difference between Files 3 and 4 is the ﬁrst line; see Section 8.1 for more information.
Since general_power2 is not restricted to a particular number system both of the following are valid:

eval power2Less20_msd "?msd_2 $general_power2(a) & a < 20" ;
eval power2Less20_lsd "?lsd_2 $general_power2(a) & a < 20" ;

Note that 0

10

∗

∗

is also msd_n and lsd_n representations of powers of n for any n > 1. So what if we write the following:

inv al id "?msd_3 $general_power2(a) & a < 20" ;

eval
in computing cross product of two automata , variables with the same label must have the same

alphabet

: char at 12
: eval power3_less10_msd "?msd_3 $general_power2(a) & a < 20" ;

Here Walnut is complaining about the fact that msd_3’s alphabet is {0,1,2}, whereas general_power2’s input alphabet is
{0,1}; see File 4. Walnut is very strict about matching alphabets, which we understand is sometimes a drawback, for example
in the above example. We will improve this feature in future releases of Walnut.

We use the automata library in [3] for converting regular expressions to automata. To see the syntax for regular expressions

refer to this website.

Here is a summary of the important syntax:
The alphabet in the second version of reg command could only be a subset of {0,1,...,9}. Therefore the following is not

allowed:
reg invali d {0 ,−1 ,−2} "−20
the input alphabet of an automaton generated from a regular expression must be a subset of

" ;

∗

{ 0 , 1 , . . . , 9 }

reg in va l i d {0 ,−1 ,−2} "−20

∗

" ;

:

The last thing to note about the reg command is that for any regular expression r , the resulting automaton from reg
where Σ is the alphabet given as the third argument of the reg

command is the intersection of the automaton for r with Σ∗
command. For example:

28

∗
+
|
.
[]
∧

∗

zero or more occurrences of an expression
one or more occurrences of an expression
union, e.g., (0 | 1)2
any single character, e.g., 2.
character class, e.g., [1− 4] means any of 1,2,3,4
∧
complement of a character class, e.g., [

∗

2− 9] is any of 0,1

Table 7.1: syntax summary for regular expressions

reg note_the_intersection { 2 , 3 } "2.

∗

2" ;

Figure 7.12: note_the_intersection.gv

7.4 load: load <ﬁle name>

We can write any series of legitimate Walnut commands in a text ﬁle and save it in the directory “/Walnut/Command Files/”.
Then we can load it by writing the following in Walnut:

load file_name . t x t ;

This runs all commands in ﬁle_name.txt in the order they appear. Recall that the ﬁle’s encoding must be UTF-16.

8 Working with Input/Output

Throughout this section it is assumed that all ﬁles have UTF-16 encoding.

8.1 Deﬁning Automata in Text Files

In this section we learn how to manually deﬁne all automata types in text ﬁles. Recall that an ordinary automaton can
be thought of as an automaton with output, in which states with non-zero outputs are treated as ﬁnal states; see Section

2.1. Therefore suppose M(cid:161)Q, q0,O, δ, Σ,S1,S2,...,Sn
(cid:162) is an automaton with output with m states and n inputs over number
systems Si. Furthermore suppose that the states are labeled 0 to m − 1, i.e., Q =(cid:169)0,1,...,m − 1(cid:170), and that q0 = 012. To deﬁne

M in a text ﬁle, ﬁrst create a text ﬁle M.txt13. The ﬁrst line must be
S1 S2 ··· Sn

which declares inputs’ number systems. The second line is declaring state 0 as follows:

where α = O(0). Next lines are declarations of transitions of state 0 which can come in any order. For every α1 ∈ ΣS1, α2 ∈
ΣS2,..., αn ∈ ΣSn transitions are of the following form

0 α

12If an automaton does not follow these criteria we can always come up with an isomorphic one that does.
13File names in Walnut start with letters and can contain alphanumerics and underscore.

α1 α2 ··· αn -> q

29

whenever δ(cid:161)0, α1, α2,..., αn

(cid:162) = q. There is no need to declare transitions to a dead state. For any pair (α1, α2,..., αn) that no

declaration of the form above is mentioned, it is assumed that δ(0, α1, α2,..., αn) is a dead state. We can use ∗, the wildcard
matching symbol, in place of any symbol αi . If there is a transition of the form
α1 α2 ... αi−1 ∗ αi+1 ... αn -> q

it is understood that δ(cid:161)0,(α1, α2,..., αi−1, β, αi+1,..., αn)(cid:162) = q for every β ∈ ΣSi. After transitions of the state 0 are declared,

we declare state 1 followed by its transitions. We continue like this until all states and their transitions are declared. Note that
nowhere in M.txt we are deﬁning the output alphabet Σ. The output alphabet is inferred indirectly by looking at the state
declarations. To see examples refer to Files 2–4.

A non-arithmetic automaton is deﬁned in the same way, except that in the ﬁrst line, for inputs that do not have number
systems associated with them, we write down the alphabet between curly brackets. Alphabets can be any subset of integers.
As an example see File 4.

Deﬁning true or false automata in text ﬁles is easy. They have only one line and it is either true or false.
As one last example, the paperfolding words are given by the following automaton; see Section 5.2 and article [8] for more

details:

Figure 8.1: Automata for paperfolding words

This automaton is deﬁned in the ﬁle PF.txt in directory “/Walnut/Word Automata Library/”:

{−1 ,1}

lsd_2

1 1

1
2
0 0
3
* 0 −> 0
4
1 1 −> 1
5
6 −1 1 −> 2
7
8
9
10
11
12
13
14
15
16
17
18
19
20

* 1 −> 4
* 0 −> 3
2 −1
* 0 −> 4
* 1 −> 3

* * −> 3
4 −1
* * −> 4

3 1

File 5: PF.txt

30

8.2 Deﬁning New Automatic Words

The eval and def commands always produce automata accepting a predicate, therefore the result is never an automaton
with output. So to deﬁne an automatic word W , we need to manually deﬁne its corresponding automaton with output in
the directory “/Walnut/Word Automata Library/”. For example, the Thue-Morse word is deﬁned in the ﬁle “/Walnut/Word
Automata Library/T.txt” as follows:

1 msd_2
0 0
2
0 −> 0
3
1 −> 1
4
1 1
5
0 −> 1
6
1 −> 0
7

File 6: T.txt

8.3 Deﬁning New Number Systems
Based on Deﬁnition 3, to deﬁne a new number system S, we need to deﬁne automata for RS, +S, and <S. We do not need
to deﬁne an automaton for =S, because it can be generated easily, since we assumed that w1 =S w2 if and only if w1 = w2
for any two words w1 and w2 of the same length. The automata for number systems must be deﬁned in the directory
“/Walnut/Custom Bases/”. For example, for the number system S, assuming it is msd, one needs to create msd_S.txt,
msd_S_addition.txt, and msd_S_less_than.txt for RS, +S, and <S respectively. If S is lsd, ﬁle names must be lsd_S.txt,
lsd_S_addition.txt, and lsd_S_less_than.txt respectively. The number system S deﬁned in this way can be used in predicates
by typing ?msd_S or ?lsd_S depending on whether S is msd or lsd. If the automaton for <S is not deﬁned by the user, Walnut
assumes that <S is the lexicographic ordering, i.e., if w1 and w2 are of the same length, then w1 <S w2 if and only if w1 comes
before w2 in lexicographic order14. If the automata for RS is not given, then RS is assumed to be Σ∗
S. The alphabet ΣS is
inferred from the automaton for +S which is always given.

Note that reversing all automata for msd_n we get the corresponding automata for lsd_n. The same goes with msd_ﬁb
and lsd_ﬁb. Thus for a number system msd_S if we only deﬁne ﬁles for msd_S, but then typing ?lsd_S in a predicate, Walnut
automatically creates automata for lsd_S by reversing those of msd_S and vice versa. However the user should be cautious
since there could very well be number systems for which the difference between msd and lsd is more than the direction of
the arrows in their corresponding automata.

8.4 Converting .gv ﬁles to .jpeg

The drawings of automata in Walnut are stored in .gv ﬁles. Not only can the software Graphviz open the ﬁles with this
extension, but it can also convert them to many different ﬁle formats. For example, suppose you have a ﬁle named
automaton.gv. To convert it to automaton.jpeg type the following in the terminal:
$dot −Tjpg automaton . gv −o automaton . jpeg
See Graphviz to learn how to convert .gv ﬁles to other ﬁle types.

References

[1]

J. R. Büchi. “On a Decision Method in Restricted Second Order Arithmetic”. In: Logic, Methodology and Philosophy of
ScienceProceeding of the 1960 International Congress. Studies in Logic and the Foundations of Mathematics 44 (1966).
Ed. by Patrick Suppes Ernest Nagel and Alfred Tarski, pp. 1 –11.

J.-P. Allouche and J. Shallit. Automatic Sequences: Theory, Applications, Generalizations. Vol. 1. CUP, 2003.

[2]
[3] Anders Møller. dk.brics.automaton – Finite-State Automata and Regular Expressions for Java. http://www.brics.dk/automaton/.

2010.

14Lexicographic ordering on symbols is assumed to be ··· < −2 < −1 < 0 < 1 < 2 < ···.

31

[4] E. Charlier, N. Rampersad, and J. Shallit. “Enumeration and Decidable Properties of Automatic Sequences”. In:

International Journal of Foundations of Computer Science (2012), pp. 1035–1066.

[5] D. Goc. “Automatic Sequences and Decidable Properties: Implementation and Applications”. Master’s thesis. University

of Waterloo, 2013.

[6] L. Schaeffer. “Deciding Properties of Automatic Sequences”. Master’s thesis. University of Waterloo, 2013.

[7]

J. Shallit. “Decidability and Enumeration for Automatic Sequences: a survey”. In: Lecture Notes in Computer Science
7913 (2013). Ed. by A. A. Bulatov and A. M. Shur, pp. 49–63.

[8] D. Goˇc, H. Mousavi, L. Schaeffer, and J. Shallit. “A New Approach to the Paperfolding Sequences”. In: Lecture Notes in

Computer Science 9136 (2015). Ed. by A. Beckmann, V. Mitrana, and M. Soskova. CiE 2015, pp. 34–43.

[9] H. Mousavi and J. Shallit. “Mechanical Proofs of Properties of the Tribonacci Word”. In: Lecture Notes in Computer

Science 9304 (2015). Ed. by F. Manea and D. Nowotka. WORDS 2015, pp. 170–190.

[10] L. Schaeffer and J. Shallit. “Trapezoidal, and Balanced Words in Automatic Sequences”. preprint. 2015.

[11] C. F. Du, H. Mousavi, L. Rowland, L. Schaeffer, and J. Shallit. “Decision Algorithms for Fibonacci-Automatic Words, II:

Related Sequences and Avoidability”. submitted. 2016.

[12] C. F. Du, H. Mousavi, L. Schaeffer, and J. Shallit. “Decision Algorithms for Fibonacci-Automatic Words, III: Enumeration

and Abelian Properties”. submitted. 2016.

[13] H. Mousavi, L. Schaeffer, and J. Shallit. “Decision Algorithms for Fibonacci-Automatic Words, I: Basic Results”. RAIRO

Inform. Theorique to appear. 2016.

32

