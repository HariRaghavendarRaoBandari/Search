6
1
0
2

 
r
a

 

M
8
2

 
 
]

G
C
.
s
c
[
 
 

2
v
7
4
8
0
0

.

3
0
6
1
:
v
i
X
r
a

Shortest Paths and Convex Hulls in 2D Complexes with

Non-Positive Curvature

Anna Lubiw∗

Daniela Maftuleac∗

Megan Owen†

Abstract

Globally non-positively curved, or CAT(0), polyhedral complexes arise in a number
of applications, including evolutionary biology and robotics. These spaces have unique
shortest paths and are composed of Euclidean polyhedra, yet many properties of convex
hulls in Euclidean space fail to transfer over. We give examples of some such prop-
erties. For 2-dimensional CAT(0) polyhedral complexes, we give eﬃcient algorithms
for computing convex hulls using linear programming and for answering shortest path
queries from a given source point.

1

Introduction

Convex hulls and shortest paths—and algorithms to ﬁnd them—are very well understood
in Euclidean spaces, but less so in non-Euclidean spaces. We consider these two problems
in ﬁnite polyhedral complexes which are formed by joining a ﬁnite number of d-dimensional
convex polyhedra along lower dimensional faces. We will primarily be concerned with the
2D case of triangles or rectangles joined at edges.

We will restrict our attention to polyhedral complexes that are globally non-positively
curved, or CAT(0). Introduced by Gromov in 1987 [24], CAT(0) metric spaces (or spaces of
global non-positive curvature) constitute a far-reaching common generalization of Euclidean
spaces, hyperbolic spaces and simple polygons. The initials “CAT” stand for Cartan, Alexan-
drov, and Toponogov, three researchers who made substantial contributions to the theory
of comparison geometry. In a CAT(0) space, in contrast to a space of positive curvature,
there is a unique geodesic (locally shortest path) between any two points and this property
characterizes CAT(0) complexes.

The impact of CAT(0) geometry on mathematics is signiﬁcant especially in the ﬁeld of
geometric group theory where the particular case of CAT(0) polyhedral complexes formed
∗David R. Cheriton School of Computer Science, University of Waterloo, Waterloo, Ontario N2L 3G1,
Canada, alubiw@uwaterloo.ca,daniela.maftuleac@uwaterloo.ca; † Department of Mathematics and Com-
puter Science, Lehman College, City University of New York, United States, megan.owen@lehman.cuny.edu

1

by cubes—the so-called “CAT(0) cube complexes”—are particularly relevant [10, 24, 27].
Most of the work on CAT(0) metric spaces so far has been mathematical. Algorithmic
aspects remain relatively unexplored apart from a few results for some particular CAT(0)
spaces [15, 16, 20].

This paper is about algorithms for ﬁnite CAT(0) polyhedral complexes, which we will
call “CAT(0) complexes” from now on. We are primarily interested in the algorithmic
properties of CAT(0) complexes because of their applications, particularly to computational
evolutionary biology. The (moduli) space of all phylogenetic (evolutionary) trees with n
leaves can be modelled as a CAT(0) cube complex with a single vertex [7], and being able to
compute convex hulls in this space would give a method for computing conﬁdence intervals
for sets of trees (see Section 2.3 for more details). A second application of CAT(0) cube
complexes is to reconﬁgurable systems [23], a large family of systems which change according
to some local rules, e.g. robotic motion planning, the motion of non-colliding particles in a
graph, and phylogenetic tree mutation, etc. In many reconﬁgurable systems, the parameter
space of all possible positions of the system can be seen as a CAT(0) cube complex [23].

In this paper we study the shortest path problem and the convex hull problem in 2D
CAT(0) complexes formed by triangles or rectangles. We give an algorithm to solve the
single-source shortest path problem in 2D CAT(0) complexes. Given a 2D CAT(0) complex
of n triangles and a source point s, our algorithm uses O(n2) preprocessing time and O(n)
storage, and ﬁnds the shortest path from s to any query point t in time proportional to
the number of triangles traversed by the path. This generalizes and improves two previous
results: an algorithm by Maftuleac [38] for the case of planar 2D CAT(0) complexes, where
every edge is in at most two faces; and an algorithm by Chepoi and Maftuleac [17] for the
case of 2D CAT(0) rectangular complexes.

The problem of ﬁnding the convex hull of a set of points in a 2D CAT(0) complex is
signiﬁcantly more challenging. For any set of points P we deﬁne the convex hull to be the
minimal set containing P that is closed under taking the shortest path between any two
points in the set. We show that convex hulls in 2D CAT(0) complexes fail to satisfy some
of the properties we take for granted in Euclidean spaces. Our main result is an eﬃcient
algorithm to ﬁnd the convex hull of a ﬁnite set of points in a 2D CAT(0) complex with a
single vertex. In general, for any CAT(0) complex, the convex hull of a set of points is the
union of a convex set in each cell of the complex. For the case of 2D CAT(0) complexes, these
convex sets are polygons. For the special case when there is a single vertex, we show how
to ﬁnd these polygons using linear programming. Our algorithm runs in polynomial time
when we can compute sines of the angles of the complex in polynomial time—in particular,
it runs in polynomial time for a cube complex, which has angles of 90◦.

The rest of the paper is organized as follows. Section 2 contains further background on
the problem, including existing algorithmic results for CAT(0) polyhedral complexes and
applications to phylogenetics. Section 3 reviews the relevant mathematics and tree space
notation. Section 4 gives our results for convex hulls, and Section 5 gives our results for
shortest paths in CAT(0) polyhedral complexes. Finally we give our conclusions in Section 6.

2

2 Background

In this section we describe background work on shortest path and convex hull algorithms,
and discuss the application of our work to phylogenetic trees.

One of the most basic CAT(0) spaces is the interior of any simple polygon in the plane.
This can be viewed as a 2D CAT(0) complex once the polygon is triangulated. The fact that
geodesic paths are unique is at the heart of eﬃcient algorithms for shortest paths and related
problems. On the other hand, generalizing a polygon to a polygonal domain (a polygon with
holes) or a polyhedral terrain yields spaces that are not CAT(0), since geodesic paths are
no longer unique. This helps explain why shortest path and convex hull problems are more
diﬃcult in these more general settings.

2.1 Shortest Paths

The shortest path problem is a fundamental algorithmic problem with many applications,
both in discrete settings like graphs and networks (see, e.g., [1]) as well as in geomet-
ric settings like polygons, polyhedral surfaces, or 3-dimensional space with obstacles (see,
e.g., Mitchell [40]).

All variants of the shortest path problem can be solved eﬃciently for a polygon once it
is triangulated, and triangulation can be done in linear time with Chazelle’s algorithm [12].
The shortest path (the unique geodesic) between two given points can be found in linear
time [35]. For query versions, linear space and linear preprocessing time allow us to answer
single-source queries [25,28], and more general all-pairs queries [26], where answering a query
means returning the distance in logarithmic time, and the actual path in time proportional
to its number of edges.

By contrast, in a polygonal domain, where geodesic paths are no longer unique, the best
shortest path algorithm uses a continuous-Dijkstra approach in which paths are explored
by order of distance. For a polygonal domain of n vertices, this method takes O(n log n)
[preprocessing] time [29] (see the survey by Mitchell [40]). For a polyhedral terrain the
continuous-Dijkstra approach gives O(n2 log n) time [41], and the best-known run-time of
O(n2) is achieved by Chen and Han’s algorithm [14] that uses a breadth-ﬁrst-search approach.
There are no shortest path algorithms for the general setting of CAT(0) polyhedral com-
plexes, although there are some for certain specializations. For planar 2D CAT(0) complexes,
where every edge is in at most two faces, Maftuleac [38] gave a Dijkstra-like algorithm for
the single-source shortest path query problem, with preprocessing time O(n2 log n), space
O(n2) and query time proportional to the size of the output path.

There are also some partial results on ﬁnding shortest paths when we restrict the CAT(0)
polyhedral complex to be composed of cubes or rectangles. The space of phylogenetic trees
mentioned in the introduction is a CAT(0) cube complex. For these “tree spaces,” Owen
and Provan [44] gave an algorithm to compute shortest paths (geodesics) with a running
time of O(m4), where m is the dimension of the maximal cubes. The algorithm is much
faster in practice for realistic trees. The result was extended to a polynomial time algorithm
for computing geodesics in any orthant space [39], where an orthant space is a CAT(0) cube

3

complex with a single vertex. The algorithm for tree space was also adapted by Ardila et
al. [2] to give a ﬁnite algorithm that computes the shortest path between two points in a
general CAT(0) cube complex, however this algorithm is likely not polynomial time. Finally,
Chepoi and Maftuleac [17] used diﬀerent methods to give a polynomial time algorithm for
all-pair shortest path queries in any 2D CAT(0) rectangular complex, with preprocessing
time O(n2), space O(n2), and query time larger in general than the size of the output path.

2.2 Convex Hulls

The problem of computing the convex hull of a set of points is fundamental to geometric
computing, especially because of the connection to Voronoi diagrams and Delaunay triangu-
lations [36].

The convex hull of a set of points in the plane can be found in provably optimal time
O(n log h) where n is the number of points and h is the number of points on the convex
hull. The ﬁrst such algorithm was developed by Kirkpatrick and Seidel [34] and a simpler
algorithm was given by Chan [11]. An optimal algorithm for computing convex hulls in
2(cid:99)) was given by Chazelle [13]. See the survey by Seidel [46]
higher dimension d in time O(n(cid:98) d
A simple polygon, triangulated by chords, is the most basic example of a 2D CAT(0)
complex. In this setting, the convex hull of a set of points P (i.e. the smallest set containing
P and closed under taking geodesics) is referred to as the relative (or geodesic) convex hull.
Toussaint gave an O(n log n) time algorithm to compute the relative convex hull of a set of
points in a simple polygon [47], and studied properties of such convex hulls [48]. Ishaque and
T´oth [31] considered the case of line segments that separate the plane into simply connected
regions (thus forming a CAT(0) space) and gave an semi-dynamic algorithm to maintain the
convex hull of a set of points as line segments are added and points are deleted.

Moving beyond polygons to polygonal domains or terrains, geodesic paths are no longer
unique, so there is no single natural deﬁnition of convex hull (one could take the closure
under geodesic paths, or the closure under shortest paths). We are unaware of algorithmic
work on these variants.

However, in a polyhedral surface with unique geodesics—that is, in a planar 2D CAT(0)
complex—the convex hull is well deﬁned, and Maftuleac [38] gave an algorithm to compute
the convex hull of a set of points in O(n2 log n) time, were n is the number of vertices in the
complex plus the number of points in the set.

In all the above cases the boundary of the convex hull is composed of segments of shortest
paths between the given points, which—as we shall see in Section 4.1—is not true in our
setting of 2D CAT(0) complexes.

Beyond polyhedral complexes, convex hulls become much more complicated. Indeed it
is still an open question if the convex hull of 3 points on a general Riemannian manifold
of dimension 3 or higher is closed [6, Note 6.1.3.1]. Bowditch [9] and Borb´ely [8] give some
results for convex hulls on manifolds of pinched negative curvature, but our complexes need
not be manifolds. In the space of positive deﬁnite matrices, which is a CAT(0) Riemannian
manifold, Fletcher et al. [22] give an algorithm to compute generalized convex hulls using
horoballs, which are generalized half-spaces. Lin et al. [37] look at convex hulls of three points

4

in a CAT(0) cubical complex that generalizes the space of phylogenetic trees. They show
that for d ≤ 400, these triangles have dimension at least 5d/6. Bridson and Haeﬂiger [10,
Proposition II.2.9] give conditions for when the convex hull of three points in a CAT(0) space
is “ﬂat”, or 2-dimensional. Finally, for a survey of convexity results in complete CAT(0) (aka
Hadamard) spaces, of which the space of phylogenetic trees is one, see [4].

2.3 Application to phylogenetic trees

While this paper will look at arbitrary 2D complexes with non-positive curvature, our work
is motivated by a particular complex with non-positive curvature, namely the space of phy-
logenetic trees introduced by Billera, Holmes, and Vogtmann [7], called the BHV tree space.
This space is a complex of Euclidean orthants (the higher dimensional version of quadrants
and octants), in which each point in the space represents a evolutionary or phylogenetic
tree. Phylogenetic trees represent the evolutionary history of a set of organisms and are
ubiquitous in biology.

One area of active phylogenetics research is how to statistically analyze sets of phyloge-
netic trees on the same, or roughly the same, set of species. Such sets can arise in various
ways: from sampling a known distribution of trees, described mathematically, such as the
Yule process [50]; from tree inference programs, such as the posterior distribution returned
by performing Bayesian inference [45] or the bootstrap trees from conducting a maximum
likelihood search [21]; or from improvements in genetic sequencing technologies that lead to
large sets of gene trees, each of which represents the evolutionary of a single gene, as opposed
to the species’ evolutionary history as a whole. Traditionally, most of the research in this
area focused on summarizing the set of trees, although recent work has included computing
variance [3, 39] and principal components [43].

It is an open question to ﬁnd a good way to compute conﬁdence regions for a set of
phylogenetic trees. While work has been done on proving a central limit theorem for the
BHV tree space [5], even the equivalent of a Gaussian distribution is not fully known on the
BHV tree space, and thus this approach can not yet be used to compute conﬁdence regions.
Thus we must assume that the underlying distribution is unknown. In [30], Holmes proposes
applying the approach of Tukey [49] for Euclidean space to the BHV tree space, namely
peeling convex hulls. The convex hull is the minimum set that contains all the data points,
as well as all geodesics between points in the convex hull. By peeling convex hulls, we mean
to compute the convex hull for the data set, and then remove all data points that lie on the
convex hull. This can then be repeated. To get the 95% conﬁdence region, for example, one
would remove successive convex hulls until only 95% of the original data points remain.

If we keep peeling convex hulls until a single point remains, we have the univariate median
of Tukey [49]. This could also be a useful one-dimensional summary statistic for a set of
trees. Many of the most-used tree summary statistics have a tendency to yield a degenerate
or non-binary tree, which is a tree in which some of the ancestor relationships are undeﬁned.
This is considered a problem by biologists, but the univariate median tree found by peeling
convex hulls would be guaranteed to be binary if all trees in the data set are.

Currently, these methods cannot be used, because it is not known how to compute convex

5

hulls in BHV tree space. We show several examples of how Euclidean intuition and properties
for convex hulls do not carry over to convex hulls in the BHV tree space. Our algorithm
to ﬁnd convex hulls applies to the space of trees with ﬁve leaves which is described in more
detail in Section 3.1.

3 Preliminaries
A metric space (X, d) is geodesic if every two points x, y ∈ X are connected by a locally
shortest or geodesic path. A geodesic metric space X is CAT(0) if its triangles satisfy the
following CAT(0) inequality. For any triangle ABC in X with geodesic segments for its sides,
construct a comparison triangle A(cid:48)B(cid:48)C(cid:48) in the Euclidean plane such d(A, B) = d(A(cid:48)B(cid:48)),
d(A, C) = d(A(cid:48)C(cid:48)), and d(B, C) = d(B(cid:48)C(cid:48)). Let Y be a point on the geodesic between
B and C, and let Y (cid:48) be a comparison point on the line between B(cid:48) and C(cid:48) such that
d(B, Y ) = d(B(cid:48)Y (cid:48)). Then triangle ABC satisﬁes the CAT(0) inequality if d(Y, A) ≤ d(Y (cid:48)A(cid:48)).
Intuitively, this corresponds to all triangles in X being at least as skinny as the corresponding
triangle in Euclidean space (Figure 1).

Figure 1: The triangle on the left represents a triangle in a CAT(0) space, with its corre-
sponding comparison triangle in Euclidean space on the right.

A polyhedral complex is a set of convex polyhedra (“cells”) glued together by isometries
along their faces. In this paper we only consider ﬁnite polyhedral complexes. When all of the
cells are cubes, then this is called a cube, or cubical, complex. The length of a path between
two points in a polyhedral complex is the sum of the Euclidean lengths of the pieces of the
path in each cell of the complex. The distance between two points is deﬁned as the length
of the shortest path between them.

We will consider polyhedral complexes that are CAT(0). The cells are 2D (planar)
convex polygons. These can always be triangulated, so the general setting is when the cells
are triangles. We call this a 2D CAT(0) complex. Sometimes we will consider a complex in
which all the cells are rectangles, either bounded or unbounded. We call this a 2D CAT(0)

6

ABCYA’B’C’Y’rectangular complex. In general we allow the space to have boundary (i.e., an edge that is
incident to only one cell).

For any vertex v of a 2D complex, we deﬁne the link graph, Gv as follows. The vertices of
Gv correspond to the edges incident to v in the complex. The edges of Gv correspond to the
cells incident to v in the complex: if r and s are edges of cell C with r and s incident to v,
then we add an edge between vertices r and s in Gv with weight equal to the angle between
r and s in C. Every point p (cid:54)= v in cell C can be mapped to a point on edge (r, s) in Gv:
if the angle between vr and vp in C is α then p corresponds to the point along edge (r, s)
that is distance α from r. We use the same notation for a point of C and the corresponding
point in the link graph when the meaning is clear from the context.

When we have a 2D polyhedral complex, there is also an alternative condition for deter-

mining whether it is CAT(0).
Theorem 1 ( [10, Theorem II.5.4 and Lemma II.5.6]). A 2D polyhedral complex K is CAT(0)
if and only if it is simply connected and for every vertex v ∈ K, every cycle in the link graph
Gv has length at least 2π.

Some of our results are only for the case where the complex has a single vertex O, which
we call the origin. We will call such a complex a single-vertex complex. In a 2D single-vertex
complex every cell is a cone formed by two edges incident to O with angle at most π between
them. There is a single link graph GO. Every point of the complex except O corresponds to
a point of GO, and every point of GO corresponds to a ray of points in the complex.

3.1 BHV Tree Space

The results in this paper are for 2D CAT(0) complexes. As mentioned in Section 2.3 one
application is to tree spaces. In this section we describe the BHV tree space, T5, that is a
2D CAT(0) complex. The tree space T5 contains all unrooted leaf-labelled, edge-weighted
phylogenetic trees with 5 leaves (equivalently all such rooted trees with 4 leaves). For a
description of the general space with more than 5 leaves, see [7]. A phylogenetic tree is
a tree in which each interior vertex has degree ≥ 3 and there is a one-to-one labelling
between the leaves (degree 1 vertices) and some set of labels L. For this paper, we assume
L = {1, 2, 3, 4, 5}. These trees also have a positive weight or length on each interior edge.
A split is a partition of the leaf-set L into two parts L1∪L2 = L such |Li| ≥ 2 for i = 1, 2.
We write a split as L1|L2. Each edge in a phylogenetic tree corresponds to a unique split,
where the two parts are the sets of leaves in the two subtrees formed by removing that edge
from the tree. Trees with ﬁve leaves contain two interior edges, and hence two splits. There
are 10 possible splits, and they can be combined to form 15 diﬀerent tree shapes. The shape
of a tree deﬁnes which species are most closely related, and is given by the set of interior
edges or splits in that tree. (Figure 2).
Each of the 15 possible tree shapes corresponds to a Euclidean quadrant in T5. The two
axes of the quadrant are labelled by the two splits in the tree shape. A point in the quadrant
corresponds to the tree with that tree shape whose interior edges have the lengths given by
the coordinates. We identify axes labelled by the same split, so that if two quadrants both

7

Figure 2: Several tree shapes with their constituent splits listed below them. Tree (a) and
tree (b) have the same tree shape, which does not depend on the planar embedding of the
tree. Tree (c) has diﬀerent splits and hence a diﬀerent tree shape from trees (a) and (b).
Tree (d) is a non-binary tree shape.

contain an axis labelled by the same split, then they are glued together along that shared
axis (see Figure 3).

The BHV distance is the length of the shortest path, or geodesic, between the two trees
(Figure 3). Billera et al. [7] proved that this tree space is a CAT(0) cube complex, which
implies that there is a unique geodesic between any two trees in the tree space.
To understand how the 15 quadrants in T5 are connected, consider the link graph of the
origin, which is shown in Figure 4 and is the Petersen graph. The Petersen graph has multiple
overlapping 5-cycles, one of which corresponds to the 5 quadrants in Figure 3. Also note
that each vertex in the link graph of the origin is adjacent to three edges. This corresponds
to each axis lying in three quadrants in T5.

Note that this example illustrates that the link graph of even a CAT(0) rectangular

complex with a single vertex need not be planar.

4 Convex Hulls
Let P be a ﬁnite set of points in a CAT(0) complex K. Recall from Section 1 that the
convex hull of P is deﬁned to be the minimal set containing P that is closed under taking
the shortest path between any two points in the set. Let CH(P ) denote the convex hull of
P in K. For algorithmic purposes, there are several ways to specify CH(P ). One possibility
is to specify the intersection of CH(P ) with each cell of the complex.
In the case of 2D
CAT(0) complexes, each such set is a convex polygon, which can be given by its vertices.
Our algorithm will do this. However, we note that there is another way to specify CH(P ),
which might be easier but would still suﬃce for many applications, and that is to give an
algorithm to decide if a given query point of K is inside CH(P ).

Convex hulls in CAT(0) complexes are something of a mystery. It is not known, for exam-
ple, whether they are closed sets [6, Note 6.1.3.1]. We begin in subsection 4.1 by giving some
examples to show that various properties of Euclidean convex hulls fail in CAT(0) complexes.

8

54321≠12345=3421512345{1,2}|{3,4,5}{3,4}|{1,2,5}{1,2}|{3,4,5}{3,4}|{1,2,5}{1,3}|{2,4,5}{2,4}|{1,3,5}{1,2,3}|{4,5}(a)(b)(c)(d)Figure 3: Five quadrants in T5. The upper right quadrant illustrates how trees with the
same tree shape but diﬀerent edge lengths lie at diﬀerent coordinates in the quadrant. The
dashed lines represent geodesics between two pairs of trees where Ti and T (cid:48)
i have the same
tree shape but diﬀerent edges lengths. The geodesic T (cid:48)
2 passes through the origin, while
the geodesic T1 to T2 passes through an intermediate quadrant.

1 to T (cid:48)

After that we give our main result, an eﬃcient algorithm (using linear programming) to ﬁnd
convex hulls in any 2D CAT(0) complex with a single vertex O. This algorithm implies that
the convex hull is closed in the case of 2D CAT(0) complexes. The idea of our algorithm is to
ﬁrst use the link graph to test if point O is in the convex hull and to identify the edges of the
complex that intersect the convex hull at points other than O. Then we formulate the exact
computation of the convex hull as a linear program whose variables represent the boundary
points of the convex hull on the edges of the complex. Our algorithm is eﬃcient but whether
it runs in polynomial time depends on bit complexity issues. Linear programming algorithms
run in polynomial time depending on the number of bits of the input [32,33]. However, in the
ﬁrst part of our algorithm we need to assume the stronger real RAM model of computation
in order to perform computations on the angles of the input CAT(0) complex. In the special
case of a cube complex, our algorithm runs in polynomial time.

4.1 Counterexamples for Convex Hulls in CAT(0) complexes

In this section we give examples to show that the following properties of the convex hull of
a set of points P in Euclidean space do not carry over to CAT(0) complexes.

1. Any point on the boundary of the convex hull of points in 2D is on a shortest path

9

{1,5}|{2,3,4}51234T1T2{1,2,3}|{4,5}{1,2}|{3,4,5}{1,2,5}|{3,4}T’151234{1,4,5}|{2,3}512344Tn421435123455213451234T’2Figure 4: The Petersen graph, which is the link graph of the origin of T5. The graph edges
correspond to tree shapes, and the graph vertices correspond to splits. The 5 quadrants in
Figure 3 correspond to the outer 5-cycle in the Petersen graph.

between two points of P .

2. In any dimensional space, the convex hull of three points is 2-dimensional.

3. Any point inside the convex hull can be written as a convex combination of points of

P .

Figure 5: The shortest paths between p1, p2, p3 (shown in black) do not determine the convex
hull because the thin red line is on the boundary of the convex hull but not on any of the
shortest paths.

Our ﬁrst example, shown in Figure 5, has three cells sharing an edge. Set P contains one
point in each cell. The three shortest paths between pairs of points in P do not determine
the convex hull. This shows that property 1 fails.

Furthermore, the example in Figure 6 shows that even in a single-vertex 2D CAT(0)
rectangular complex, the convex hull of a set of points P can contain a point in a quadrant
that is not entered by any shortest path between points of P .

The example in Figure 7 shows that the convex hull of three points in a 3D CAT(0)

complex may contain a 3D ball. This shows that property 2 fails.

10

{1,2,5}|{3,4}{1,2}|{3,4,5}{1,2,3}|{4,5}{1,4,5}|{2,3}{1,5}|{2,3,4}p1p3p2Figure 6: (left) A 2D CAT(0) space consisting of 5 quadrants. Quadrants S1, S2, S5 share
a vertical edge, and quadrants S3, S4, S5 share a horizontal edge. Point pi, i = 1, 2, 3, 4, lies
in quadrant Si. The convex hull of p1, p2, p3, p4 contains points—in particular p and the
dashed red line—in a quadrant, S5, that is not entered by any shortest path between points
P (shown as black lines). Note that 4 of the 6 shortest path between points of P go through
the origin. (right) The tree representation of point p in terms of P .

Property 3 must be expressed more carefully for CAT(0) complexes because it is not clear
what a convex combination of a set of points means except when the set has two points. If
p and q are two points in a CAT(0) complex, then the points along the shortest path from
p to q can be parameterized as (1 − t)p + tq for t ∈ [0, 1]. Based on the deﬁnition of the
convex hull, any point in the convex hull of a set of points P can be represented as a rooted
binary tree with leaves labelled by points in P (with repetition allowed) and with the two
child edges of each internal node v labelled by two numbers (1 − tv) and tv for tv ∈ [0, 1],
meaning that the point associated with v is this combination of the points represented by
the child nodes. For example, see Figure 6.

One might hope that every point in the convex hull can be represented by a binary tree
whose leaves are labelled by distinct elements of P , but this is false for the example in
Figure 7.

Furthermore, this property may even fail for a 2D CAT(0) complex as we prove below

for the example in Figure 8:

Lemma 1. For the 2D CAT(0) complex shown in Figure 8, the point p cannot be represented
by a binary tree with distinct leaves from {p1, p2, p3, p4}.
Proof. From the link graph (shown in Figure 8(b)), the angle between p3 and p4 is 180◦ so
the geodesic between them goes through the origin. Similarly, the geodesics between the
following pairs also go through the origin: p3 and p2; p3 and p1; p2 and p4. The only pairs
with angles less than 180◦ are p1, p2, and p1, p4. The geodesic from p1 to p2 crosses axis 3
at point a. The geodesic from p1 to p4 crosses axis 5 at point c. Because p1 is closer to axis
2, point c is closer to the origin than point a (see Figure 8(d)). The geodesic paths from p3
to both a and c cross axis 4 and thus can be used to construct points in the cell bounded

11

b1b2p1p2p3p4b1b2p0.50.5pp1p2p3p40.50.50.50.5S1S2S3S4S5Figure 7: The convex hull of the three points p1, p2, p3 in this 3D CAT(0) complex contains a
3D ball. Point p1 lies in the x+y+z+ octant, p2 in the x+y+z− octant, and p3 in the x+y−z+
octant. The x+y−z− octant is missing. Point p is where the shortest path from p2 to p3
intersects the x+ axis, and point q is where the triangle p1p2p3 is pierced by the x+ axis.
The convex hull of P consists of the union of two simplices p1p3pq and p1p2pq.

by axes 4 and 5 (where p lies). However, as shown in Figure 8(e), the geodesic path from
p3 to a crosses axis 4 further from the origin at point b, and therefore point p can only be
constructed using points a and b, as shown by the binary tree in Figure 8(b). Therefore p
can only be represented by a binary tree that repeats the leaf p1.

4.2 Convex Hull Algorithm for a Single-Vertex 2D CAT(0) Com-

plex

In this section we prove our main result:

Theorem 2. There is an eﬃcient algorithm to ﬁnd the convex hull of a ﬁnite set of points
P in a 2D CAT(0) complex K with a single vertex O. The algorithm runs in polynomial
time in the special case of a cube complex.

4.2.1 Combinatorics of the Convex Hull

In this subsection we show how to decide if O is in the convex hull and how to identify the
edges of K that contain points of the convex hull other than O. We will do this using the
link graph G = GO.
First consider the problem of testing whether O is in the convex hull. If O ∈ P we are
done, so assume that O (cid:54)∈ P . Consider two points a and b in K, distinct from O, and consider
the corresponding points a and b in G. Let σ(a, b) be the (unique) geodesic path between
a and b in the space K. Let σG(a, b) be the shortest path between a and b in G. Let |σ|
indicate the length of path σ. Then exactly one of the following two things holds:

• |σG(a, b)| ≥ π and σ(a, b) goes through O,

12

p1p2p3pqy+z+x+y-z-Figure 8: An example of a 2D CAT(0) complex where point p in CH({p1, p2, p3, p4}) cannot
be represented as a binary tree with distinct leaves. Points p1, p2, p3, p4 are all distance 1
from the origin, with angles as speciﬁed in the link graph. (a) the complex (not to scale);
(b) the link graph; (c) the binary tree representing p; (d) construction of points a and c; (e)
construction of points b and p.

• |σG(a, b)| < π and σ(a, b) maps to σG(a, b) and does not go through O.
Now, since O is in CH(P ) if and only if there is a path between two points in CH(P )− O

that goes through O, we have:
Observation 1. O is in CH(P ) if and only if there are two points a and b in CH(P ) − O
such that the distance between a and b in the link graph is at least π.

We test if O is in CH(P ) as follows. If there are two points p, q ∈ P whose distance in
the link graph is at least π, then O is in CH(P ). Otherwise, let G[P ] be the subset of the
link graph that is the union of all shortest paths σG(p, q), p, q ∈ P . Note that G[P ] is not

13

p1p2p3p4bcpp1ap11abc2345678p2p3p412345p1p4abc20º70º10º80º10ºp2pp152p13p220º10º10ºp4ac374ac10ºp35bp(a)(b)(c)(d)(e)876p3a subgraph of G in the usual sense because in general it includes portions of edges. Every
point of G[P ] is the image of some point in CH(P ). By the following lemma, it suﬃces to
test if G[P ] has a cycle.
Lemma 2. Suppose that no path between two points of P goes through O. Then O ∈ CH(P )
if and only if G[P ] contains a cycle.

Proof. Suppose G[P ] contains a cycle. Because the space is CAT(0), the cycle has length at
least 2π, so it must contain two points a, b whose minimum distance in the cycle is π. Then
the length of the shortest path between a and b in the link graph is π (otherwise we would
have a cycle of length less than π). By Observation 1, O is in CH(P ).

For the other direction, suppose G[P ] does not contain a cycle. G[P ] is connected, so it
must be a tree. We claim that the leaves of the tree are points of P : If d is a point of G[P ]
that is not in P then d is an internal point of some path σG(p, q), p, q ∈ P , so d has degree
at least 2 in G[P ], so it is not a leaf.

Let a and b be points of G[P ]. The path between a and b in G[P ] can be extended to a
path between leaves of G[P ], and, since the leaves are in P , this path has length less than
π. Thus there is a path between a and b in G[P ] of length less than π. This must be the
shortest path between a and b in G. Thus, G[P ] is closed under taking shortest paths. We
will never get two points at distance π or more. Therefore O is not in the convex hull.

The algorithm to test if O is in CH(P ) has a straight-forward implementation that runs
in time O(m(n + m)) where n is the number of cells in K and m is the size of P . For each
point p ∈ P , we do a depth-ﬁrst search in the link graph to ﬁnd paths to all the points of P
within distance π of p. Note that a search to distance π will not ﬁnd any cycles in the link
graph, and therefore ﬁnds shortest paths from p. If some point q ∈ P is not reached then we
know that O is in CH(p). Otherwise, we construct G[P ] as the union of all these depth-ﬁrst
search trees, and test if G[P ] contains a cycle. Each depth-ﬁrst search takes time O(n + m)
so the total time is O(m(n + m)). Constructing and exploring G[P ] takes linear time.
We now show how to identify the edges of the complex K that contain points of CH(P )−
O. Equivalently, we will identify the vertices of the link graph that correspond to points in
the convex hull. Our method applies whether or not O is inside the convex hull.

We will build up a set S of points and vertices in the link graph. Initially S will just be
the input set of points P , and at the end of the algorithm, S will also contain all vertices of
the link graph that correspond to points in the convex hull. We will also keep a subset F of
S that represents the “frontier” that we still need to explore from. Initially F = S = P .

The general step is to remove one element v from F . We then explore the part of the
link graph within distance π from v. This can be done by a depth-ﬁrst search in O(n + m)
time. As noted above, a search tree to distance π will ﬁnd no cycles, and will therefore
ﬁnd shortest paths from v. We remove the part of the depth-ﬁrst tree that is beyond the
deepest point of S on each branch. Then for every vertex w of the link graph that is in the
depth-ﬁrst search tree, we check if w is already in S—if not then we add w to S and to F .
The size of S is bounded by n + m where n is the number of cells in K and m is the size
of P . Note that the amount of work we do for one element of F is O(n + m). Thus the

14

algorithm runs in time O((n + m)2).

The algorithm is correct because the ﬁnal set S is closed under taking shortest paths of

length less than π in the link graph.

4.2.2 Finding the Convex Hull

In this section we give an eﬃcient algorithm to explicitly ﬁnd the convex hull of a ﬁnite point
set P in a 2D CAT(0) complex K with a single vertex O.

Suppose ﬁrst that the origin O is inside the convex hull. The case where the origin in
not inside the convex hull will be dealt with later. It suﬃces to describe the intersection of
the convex hull with each cell of the complex. Consider a cell C bounded by rays e and f
incident to O. The part of the convex hull inside C is a convex polygon determined by its
vertices which consist of: point O; the points of P inside C; and two points xe and xf on
edges e and f , respectively, that are on the boundary of the convex hull. Note that we do
not make any assumption about whether xe and xf are in the convex hull, because we are
not making any assumption about whether the convex hull is open or closed.
Let B be the set of edges of the complex that have points other than O inside the convex
hull. These are found as described in the previous section. For each (cid:96) ∈ B make a variable
x(cid:96) ∈ R representing the point on (cid:96) that is on the boundary of the convex hull. Then x(cid:96) > 0.
To “ﬁnd” the convex hull, it suﬃces to ﬁnd the values of the variables x(cid:96).

There is an obvious iterative approach: Initialize H0 to be the set P . For i = 1, 2, . . .,
initialize Hi to Hi−1 and then take every pair of points from Hi−1, compute the shortest path
σ between them, and add to Hi all the intersection points of σ with edges of the complex.
(When two points lie on the same edge, we can discard the one closer to O.) In order for
this to be an eﬃcient algorithm we would need a bound on the number of iterations, but we
do not even have a ﬁnite bound, although we make the following conjecture:

Conjecture 1. Hk = Hk+1 for some polynomially bounded k.

Rather than using iteration we will ﬁnd the values for x(cid:96) using linear programming.
Our inequalities will be determined by pairs of elements from the set L = P ∪B. Notation
will be eased by viewing elements of P and of B uniformly, which we can do by constructing
an edge ep through each point of p ∈ P (subdividing its cell) and associating p with the
variable xep which has a known constant value. Then for any two elements e and f of
L, such that the angle between e and f is < π, consider the shortest path σ between the
corresponding points. We will add a constraint for each edge (cid:96) of K crossed by σ, expressing
the fact that the convex hull includes the point where σ crosses (cid:96). The constraint has the
form x(cid:96) ≥ t where t is the point where σ crosses (cid:96). (More precisely, t is the distance from
O to the crossing point.) We can express t in terms of known quantities. The set-up is
illustrated in Figure 9. Note that there may be several polyhedral cells separating e and f ,
but we can lay them down to form a triangle.

Let γ1 be the angle between e and (cid:96), and let γ2 be the angle between (cid:96) and f . Then we

have:

15

Figure 9: Expressing the intersection point t in terms of known quantities.

Claim 1.

t =

xexf sin(γ1 + γ2)
xe sin γ1 + xf sin γ2

Proof. We apply the sine law several times. Let α and β be the angles opposite sides xe and
t, respectively, in the triangle Oxet, and let c be the distance from xe to xf . By the sine law

t =

xe sin β
sin α

,

sin β =

Combining these we get

xf sin(γ1 + γ2)

.

c

.

t =

xexf sin(γ1 + γ2)

c sin α

Let c1 and c2 be the parts of c opposite γ1 and γ2, respectively. By the sine law, we also
have c1 sin α = xe sin γ1 and c2 sin(π − α) = c2 sin α = xf sin γ2. So c sin α = (c1 + c2) sin α =
xe sin γ1+xf sin γ2. Substituting into the above expression for t gives the desired formula.

Using the above claim, the constraint x(cid:96) ≥ t becomes
x(cid:96) ≥ xexf sin(γ1 + γ2)
xe sin γ1 + xf sin γ2

This is not a linear inequality, but substituting y(cid:96) = 1
x(cid:96)

yields

y(cid:96) ≤ yf

sin γ1

sin γ2

+ ye

(1)

We claim that maximizing(cid:80) y(cid:96) subject to the inequalities (1) and y(cid:96) ≥ 0 gives the convex

Since the γi’s are constant, this is a linear inequality.

sin(γ1 + γ2)

sin(γ1 + γ2)

hull of P . The argument is as follows. First note that the closure of CH(P ) provides a feasible
solution to the linear system, because the convex hull satisﬁes the constraints x(cid:96) ≥ t which
, (cid:96) ∈ L. Next, note that
we used to construct our inequalities. Denote this solution by yCH

(cid:96)

16

Oαc2γc1βγ2c1xfxetfefor all (cid:96) ∈ L—in other words, any other solution
any other solution y(cid:48)
includes CH(P ). This is because the points P are included, and the inequalities enforce

closure under shortest paths. Therefore, the solution that maximizes(cid:80) y(cid:96) is the convex hull

(cid:96), (cid:96) ∈ L, has y(cid:48)

(cid:96) ≤ yCH

(cid:96)

of P .

Thus we have reduced the problem of ﬁnding the convex hull (when O is in the convex

hull) to linear programming.

We now deal with the case where the origin O is not inside the convex hull. In this case,
by Lemma 2, the subgraph of the link graph corresponding to the convex hull is a tree, and
it seems even more plausible that an iterative approach can be used to ﬁnd the convex hull.
However, we leave this as an open question, and give a linear programming approach like
the one above.
Let B be the set of edges of the complex that have points other than O inside the convex
hull. For each (cid:96) ∈ B we will make two variables, xmin
in R representing the
minimum and maximum points on (cid:96) that are on the boundary of the convex hull. To ﬁnd
the convex hull, it suﬃces to ﬁnd the values of these variables.

and xmax

(cid:96)

(cid:96)

We want to ensure that xmax

is
smaller than any crossing point on edge (cid:96). Using the same notation and set-up as above with
edges e and f , and using the inverse variables ymin
these properties
are captured by the following two inequalities:

is larger than any crossing point on edge (cid:96) and that xmin

(cid:96) = 1
xmax

(cid:96) = 1
xmin

and ymax

(cid:96)

(cid:96)

(cid:96)

(cid:96)

f

(cid:96) ≤ ymax
ymax
(cid:96) ≥ ymin
ymin

sin γ1

sin(γ1 + γ2)

+ ymax

e

sin γ1

sin γ2

sin(γ1 + γ2)

sin γ2

sin(γ1 + γ2)

If we maximize the objective function(cid:80)(ymax

sin(γ1 + γ2)

f

+ ymin

e

(cid:96) − ymin

(cid:96)

(cid:96) ≥ ymax

) subject to the above inequalities
(cid:96) ≥ 0 then, by a similar argument to the one above, this gives the convex hull
and ymin
of P . Thus we have reduced the problem of ﬁnding the convex hull to linear programming.
We now discuss the running time of the algorithm. We will concentrate on the case where
O is in the convex hull—the other case is similar. At the beginning of the algorithm we test if
O is in the convex hull, and ﬁnd the set B of edges of the complex that contain points of the
convex hull other than O. This takes O((n + m)2) time as discussed in the previous section.
The set B has size O(m) and the set L has size O(n + m), where n is the number of points in
P and m is the number of cells in the complex. The linear program has O(m) variables. The
number of inequalities is O(m(n + m)2) since we consider each pair of elements, e, f from
L, and add an inequality for each edge of the complex crossed by the shortest path from e
to f . We can construct the linear program in polynomial time assuming a real RAM model
of computation that allows us to do computations on the input angles (including computing
the sine of angles). To obtain an eﬃcient algorithm, we use the simplex method for linear
programming [18].

In the special case of a cube complex, it is more natural to give each input point using
x- and y-coordinates relative to the quadrant containing the point. In this case, we claim

17

that all the low-level computations described above can be performed in polynomial time
when measuring bit complexity. We give a few more details for the computation of t in
Figure 9 in this case. If xe and xf correspond to input points, t is just the point where a
line between two known points crosses an axis. The case when both xe and xf are variables
cannot arise because they would be distance π apart in the link graph. Thus the only case
we must take care of is when xe corresponds to an input point and xf is a variable (or vice
versa). The situation is shown in Figure 10, with xe having coordinates (h, v) as shown.
Then t = vxf /(xf + h), so constraint (1) becomes y(cid:96) ≤ (hyf + 1)/v. Since the coeﬃcients in
our linear constraints are rationals whose bit complexity is polynomially bounded in terms of
the input bit complexity, we can use polynomial-time linear programming algorithms [32,33]
so our whole algorithm runs in polynomial time.

Figure 10: Expressing the intersection point t in terms of known quantities in the case of a
cube complex.

This completes the proof of Theorem 2.

5 Shortest Paths

This section is about the single-source shortest path problem in a 2D CAT(0) complex. The
input is a 2D CAT(0) complex, K, composed of n triangles, and a point s in K. We will
build a data structure that allows us to ﬁnd, for any query point t, the shortest path from
s to t, denoted σ(s, t). We will achieve O(n2) preprocessing time, O(n) storage, and query
time proportional to the number of triangles and edges traversed by the path.

Typically in a shortest path problem, the diﬃculty is to decide which of multiple geodesic
(or locally shortest) paths to the destination is shortest. This is the case, for example, for
shortest paths in a planar polygon with holes, or for shortest paths on a terrain, and is a
reason to use a Dijkstra-like approach that explores paths to all target points in order of
distance. For shortest paths on a terrain, Chen and Han [14] provided an alternative that
uses a Breadth-First-Search (BFS) combined with a clever pruning when two paths reach
the same target point.

When geodesic paths are unique, however, it is enough to explore all geodesic paths, and
there is no need to explore paths in order of distance or in BFS order. This is the case,
for example, for shortest paths in a polygon, where the “funnel” algorithm [25, 28] achieves

18

OxfxetfevhO(n) processing time and storage, and O(log n) query time (plus output size to produce the
actual path).

In a CAT(0) complex, geodesic paths are unique. One approach to the single source
shortest path problem is to compute the whole shortest path map from s, partitioning each
face into regions where all points have the same combinatorial shortest path. In a 2D CAT(0)
complex the shortest path map has worst case size Θ(n2), and can be computed with O(n2)
time and storage, so that the shortest path to query point t can be found in time proportional
to the number of faces along the path. We do not see how to achieve linear preprocessing
time as in the funnel algorithm, nor how to ﬁnd the distance to a query point in logarithmic
time, but we will improve the storage. We will achieve O(n2) preprocessing time, and O(n)
storage, and we will recover a shortest path to query point t in time proportional to the
number of faces along the path.

The high-level idea as follows. Starting with the faces containing s, we expand to adjacent
faces, constructing the last-step shortest path map in which two points p and q inside a face
are equivalent if σ(s, p) and σ(s, q) enter the face on the same edge/vertex. We thus store a
constant amount of information for each face. See Figure 11. We show that this information
is suﬃcient to recover the path from s to any point t in time proportional to the number of
faces on the path. This involves “unfolding” the faces along the path into the plane. The
idea of storing in each face only the combinatorial information about the last step of the
shortest path comes from [19].

We now ﬁll in the details of our algorithm.
The algorithm will categorize faces according to how shortest paths enter them. Shortest
paths may enter a face through: one edge (type E ); one vertex (type V ); one edge and an
incident vertex (type EV ); or two edges and their common vertex (type EVE ). There are
no other possibilities otherwise there would be a point in the face reached by more than one
shortest path. See Figure 11. Shortest paths may reach an edge from an incident face, or
from an endpoint of the edge when the edge itself lies on a shortest path. Note that diﬀerent
points on an edge e cannot be reached by shortest paths through diﬀerent faces incident to
e otherwise, by continuity, there would be a point on e reached by two geodesic paths.

The algorithm will discover how shortest paths enter each face, edge and vertex. For
each face we store the incoming edge(s)/vertex through which shortest paths enter the face.
For faces of types EV or EVE we store the one or two rays that form the boundaries of the
part of the face reached by shortest paths through the vertex, as shown in Figure 11. For
each edge we store the incoming face/vertex through which shortest paths reach the edge.
For each vertex we store the incoming face or edge that contains the last segment of the
shortest path to the vertex, and in the case of an incoming face we store the last segment
of the shortest path to the vertex. In general, a ray or segment is given in local coordinates
of the face in which it lies (i.e., in terms of vertices of the face). Note that the incoming
information has constant size per face/edge/vertex, and therefore linear size overall.

At the beginning of the algorithm every face/edge/vertex is unmarked. When we have
complete information about shortest paths to a face/edge/vertex then it is marked explored.
We will have a third category for edges and vertices—an edge or vertex marked frontier is

19

Figure 11: Shortest paths may enter a face through: (a) one edge (type E ); (b) one vertex
(type V ); (c) one edge and an incident vertex (type EV ); or (d) two edges and their common
vertex (type EVE ). For type EV and EVE faces we store the rays (shown in bold red) that
partition the face based on the edge/vertex through which shortest paths enter.

one that we know the shortest path to (via incoming information), but have not explored
beyond. The general step is to take an edge or vertex out of the frontier and “explore”
beyond it, moving some incident faces/edge/vertices out of the unmarked category into the
frontier or explored category. The algorithm terminates when every face/edge/vertex is
marked explored.

We now give the details of the algorithm to build the data structure for shortest path
queries. The algorithm to answer shortest path queries is described later on. The two
methods are entwined, because we need to answer shortest path queries in order to build the
data structure.

Initialization. Assume that s is a vertex of the complex (if necessary, by triangulating
the face containing s). For each edge e = (s, v) incident to s, mark e as “explored” with
incoming vertex s and put v into the frontier with entering ray sv. For each face f incident
to s, mark f as “explored”, and as type V with incoming vertex s and put the edge of f
not incident to s into the frontier with incoming face f .

General Step. Until the frontier is empty, take a vertex or edge out of the frontier and
explore beyond it as speciﬁed in the following cases. Before we take an edge out of the
frontier, there are special conditions that must be met, which we describe below.

I. Taking a vertex v out of the frontier. Mark v “explored”. Let r be the incoming
ray to v. Starting from point r in v’s link graph Gv, we search the link graph to identify
all points within distance π from r. The complementary set (all points in Gv of distance
≥ π from r) correspond to points in K that have shortest paths that go through v, and we
call this set the ruﬄe of v. Note that this includes the case where v is on the boundary.
See Figure 12. For each edge e = (v, u) incident to v, if e is in the ruﬄe then we mark e
“explored” with incoming vertex v and we put u in the frontier with incoming ray vu.
For each face f incident to v we consider several cases depending on how f intersects the
ruﬄe of v. Let e = (a, b) be the edge of f not incident to v.
Case 0. No point of e is inside the ruﬄe. Do nothing, as no shortest paths to this face pass
through v.

20

(a)(b)(c)(d)Figure 12: The ruﬄe (in red) of vertex v ∈ K with respect to incoming ray r, shown in K
(left) and in the link graph Gv (right).

Case 1. Both a and b are inside the ruﬄe. Note that all of f is in the ruﬄe because f
corresponds in the link graph Gv to an edge whose endpoints (corresponding to a and b) are
distance ≥ π from r, so all points internal to the edge are also distance ≥ π from r. Mark f
“explored” of type V with incoming vertex v, and put e in the frontier with incoming face
f .
Case 2. Exactly one of a or b (say a) is inside the ruﬄe. Mark f of type VE with incoming
vertex v and incoming edge (v, b). A boundary ray of the ruﬄe goes from v to a point on
the edge (a, b). We store this ray with the face f . Note that we do not yet mark f as
“explored”—we will only do that after exploring edge (v, b).
Case 3. Neither a nor b is inside the ruﬄe but some interior point(s) of e are in the ruﬄe.
Mark f of type EVE with incoming vertex v and incoming edges (v, b) and (v, a). If a single
point of e is inside the ruﬄe then exactly one ray goes from v to a point on the edge e, and
otherwise two boundary rays of the ruﬄe go from v to points on the edge e. We store these
rays with the face f . Note that we do not yet mark f as “explored”—we will only do that
after exploring edges (v, b) and (v, a).

II. Taking an edge e out of the frontier. We only take an edge e = (u, v) out of the
frontier if both vertices u and v have already been explored. Mark e as “explored”. Let g
be the incoming face for e. For each face f (cid:54)= g incident to e, let w be the third vertex of f
and do the following.
Case 1. If f is not already marked VE or EVE then we mark f “explored” of type E with
incoming edge e. We put the edges (u, w) and (v, w) in the frontier with incoming face f .
Using the method described below, we ﬁnd the shortest path from s to w and the segment
r along which the shortest path reaches w. We put vertex w in the frontier with entering
segment r and incoming face f .

21

r31234567812345r30º60ºrr1r2r1r2r330º30º60ºvCase 2. If f is marked VE with, say, v as an incoming vertex then we mark f “explored”
and put edge (u, w) in the frontier with incoming face f . (The case when u is the incoming
vertex is symmetric.)
Case 3. If f is marked EVE with, say, v as an incoming vertex then if edge (v, w) is already
explored we mark f “explored” and put edge (u, w) in the frontier with incoming face f .
(The case when u is the incoming vertex is symmetric.)

Correctness of the algorithm is straightforward by induction on the number of faces.
The one thing worth commenting on is our condition about not removing an edge from the
frontier until both its vertices have been explored. Since an edge only enters the frontier
when both endpoints are in the frontier or already explored, we can always remove something
from the frontier unless it is empty. When the frontier is empty, all faces, edges and vertices
will be explored.

We now analyze the run time of the algorithm. Each edge/vertex enters the frontier only
once. The time to process a vertex (step I) is proportional to the number of incident edges
and faces, so this is linear overall. The time to process an edge (step II) is proportional to
the number of incident faces times the time to recover a shortest path to a point (point w
in case 1). As shown below, it takes O(n) time to recover a shortest path. Thus the total
run time is O(n2). Storage is O(n).

We now describe how to answer a query for the shortest path to a point t. We can do
this as soon as the face/edge/vertex containing t has been explored—the algorithm need
not have terminated. If t is a vertex, or a point on an edge, we can tell from the incoming
information if a shortest path reaches t along an edge, say the edge from u to v. In this case,
we replace t by u and recurse.

In the more general case t lies in a face, edge or vertex and we know that a shortest path
reaches t through a face, say f . If f is of type V, we replace t by the incoming vertex of f
and recurse. If f is of type VE or type EVE we locate t relative to the rays in f . From this
we can tell if the shortest path to t goes through a vertex of f or not. If it does, then we
replace t by that vertex and recurse.

We are left with the case where the shortest path to t enters face f through some edge,
say edge e. Let g be the incoming face for edge e. We place f in the plane and attach
triangle g to edge e. The placement of f is arbitrary, but then t and g are ﬁxed. Now we
enter the main loop of the algorithm (see Figure 13): If g is of type V, we replace t by the
incoming vertex of g and recurse. If g is of type VE or type EVE we locate t relative to the
rays in g (although t is not in g we just extend the rays to do the test). From this we can
tell if the shortest path to t goes through a vertex of g or not. If it does, then we replace t
by that vertex and recurse. Otherwise the shortest path to t enters g through an edge, and
we repeat with the incoming face of that edge.

This algorithm will ﬁnd the shortest path from s to t in time proportional to the number

of triangles and edges on the path, which is O(n) in the worst case.

To wrap up, the whole algorithm takes time O(n2) to preprocess the complex from s, and
results in a structure of space O(n) that allows searching for a path to t in time proportional
to the size of the path.

22

Figure 13: Finding the shortest path from s to point t in face f . In this example, f is of
type VE. Testing the ray of f , we ﬁnd that the shortest path to t enters from edge e which
has incoming face g of type VE. Testing the rays of g, we ﬁnd that the shortest path to t
enters from edge e(cid:48) which has incoming face g(cid:48) of type EVE. Finally, testing the rays of g(cid:48)
we ﬁnd that the shortest path to t comes from vertex v. We recursively ﬁnd the shortest
path to v.

It is possible that results of Mount [42] might provide an algorithm that uses O(n2) time,
O(n log n) space, and answers queries for the distance in O(log n) time1. The rough idea is
to store the whole shortest path map via nested trees that allow us to search all the rays
entering a triangle.

6 Conclusions

We have given eﬃcient algorithms for computing convex hulls and shortest paths in 2D
CAT(0) polyhedral complexes. The algorithm for computing convex hulls relies on linear
programming, and we leave it as an open question to ﬁnd a combinatorial algorithm, or
prove that a simple iterative approach takes polynomial time (Conjecture 1).

We do not see how to extend our linear programming solution to higher dimensional
CAT(0) complexes. In 2D, the codimension-1 boundary between maximal cells is an edge,
and we only need to store one point (or two when the convex hull does not contain the
origin) for the convex hull. In higher dimensions, this boundary has dimension 2 or greater,
and it is not clear that the intersection of the convex hull with a boundary face is even a
polytope. Rather than computing the convex hull explicitly, it might be easier to ﬁnd an
algorithm that tests whether a point is in the convex hull or not. This would be suﬃcient
for most applications, including computing a geometric centre by peeling convex hulls.

1Thanks to Stefan Langerman for this suggestion

23

tfgg'ee'v7 Acknowledgements

The authors thank Sean Skwerer for the example showing convex hulls of 3 points can be
3-dimensional (Figure 7), and Aasa Feragen, Steve Marron, Ezra Miller, Vinayak Pathak,
Scott Provan, and Sean Skwerer for helpful discussions about convex hulls in tree space.
MO acknowledges the support of the Fields Institute. Research supported by NSERC, the
Natural Sciences and Engineering Research Council of Canada.

References

[1] R. K. Ahuja, T. L. Magnanti, and J. B. Orlin. Network Flows: Theory, Algorithms,

and Applications. Prentice Hall, Englewood Cliﬀs, NJ, 1993.

[2] F. Ardila, M. Owen, and S. Sullivant. Geodesics in CAT(0) cubical complexes. Advances

in Applied Mathematics 48(1):142–163, 2012.

[3] M. Bacak. Computing medians and means in Hadamard spaces. SIAM Journal on

Optimization 24(3):1542–1566, 2014.

[4] M. Bacak. Convex analysis and optimization in Hadamard spaces, vol. 22. Walter de

Gruyter GmbH & Co KG, 2014.

[5] D. Barden, H. Le, and M. Owen. Limiting behaviour of Fr´echet means in the space of

phylogenetic trees. arXiv preprint arXiv:1409.7602, 2014.

[6] M. Berger. A panoramic view of Riemannian geometry. Springer Science & Business

Media, 2003.

[7] L. J. Billera, S. P. Holmes, and K. Vogtmann. Geometry of the space of phylogenetic

trees. Advances in Applied Mathematics 27(4):733–767, 2001.

[8] A. Borb´ely. Some results on the convex hull of ﬁnitely many convex sets. Proceedings

of the American Mathematical Society 126(5):1515–1525, 1998.

[9] B. H. Bowditch. Some results on the geometry of convex hulls in manifolds of pinched

negative curvature. Commentarii Mathematici Helvetici 69(1):49–81, 1994.

[10] M. R. Bridson and A. Haeﬂiger. Metric spaces of non-positive curvature, vol. 319.

Springer Science & Business Media, 1999.

[11] T. M. Chan. Optimal output-sensitive convex hull algorithms in two and three dimen-

sions. Discrete & Computational Geometry 16(4):361–368, 1996.

[12] B. Chazelle. Triangulating a simple polygon in linear time. Discrete & Computational

Geometry 6:485–524, 1991, doi:10.1007/BF02574703.

24

[13] B. Chazelle. An optimal convex hull algorithm in any ﬁxed dimension. Discrete and

Computational Geometry 10(1):377–409, 1993.

[14] J. Chen and Y. Han. Shortest paths on a polyhedron, Part I: Computing shortest paths.
International Journal of Computational Geometry & Applications 6(02):127–144, 1996,
doi:10.1142/S0218195996000095.

[15] V. Chepoi. Graphs of some CAT(0) complexes. Advances in Applied Mathematics

24(2):125–179, 2000.

[16] V. Chepoi, F. F. Dragan, and Y. Vax`es. Distance and routing labeling schemes for

non-positively curved plane graphs. Journal of Algorithms 61(2):60–88, 2006.

[17] V. Chepoi and D. Maftuleac.

of global nonpositive curvature.
doi:10.1016/j.comgeo.2012.04.002.

Shortest path problem in rectangular complexes
Computational Geometry 46(1):51–64, 2013,

[18] G. B. Dantzig. Linear Programming and Extensions. Princeton University Press, 1963.

[19] M. Dror, A. Efrat, A. Lubiw, and J. S. Mitchell. Touring a sequence of polygons.
Proceedings of the 35th Annual ACM Symposium on Theory of Computing (STOC),
pp. 473–482, 2003, doi:10.1145/780542.780612.

[20] M. Elder and J. McCammond. CAT(0) is an algorithmic property. Geometriae Dedicata

107(1):25–46, 2004, doi:10.1023/B:GEOM.0000049096.63639.e3.

[21] J. Felsenstein. Conﬁdence limits on phylogenies: an approach using the bootstrap.

Evolution pp. 783–791, 1985.

[22] P. Fletcher, J. Moeller, J. Phillips, and S. Venkatasubramanian. Horoball hulls and
extents in positive deﬁnite space. Algorithms and Data Structures, pp. 386-398. Springer
Berlin Heidelberg, Lecture Notes in Computer Science 6844, 2011, doi:10.1007/978-3-
642-22300-6 33.

[23] R. Ghrist and V. Peterson. The geometry and topology of reconﬁguration. Advances in

applied mathematics 38(3):302–323, 2007.

[24] M. Gromov. Hyperbolic groups. Essays in Group Theory, pp. 75-263. Springer New
York, Mathematical Sciences Research Institute Publications 8, 1987, doi:10.1007/978-
1-4613-9586-7 3.

[25] L. Guibas, J. Hershberger, D. Leven, M. Sharir, and R. E. Tarjan. Linear-time algo-
rithms for visibility and shortest path problems inside triangulated simple polygons.
Algorithmica 2(1-4):209–233, 1987, doi:10.1007/BF01840360.

[26] L. J. Guibas and J. Hershberger. Optimal shortest path queries in a simple polygon.
Journal of Computer and System Sciences 39(2):126 – 152, 1989, doi:10.1016/0022-
0000(89)90041-X.

25

[27] F. Haglund and D. T. Wise. Special cube complexes. Geometric and Functional Analysis

17(5):1551–1620, 2008.

[28] J. Hershberger and J. Snoeyink. Computing minimum length paths of a given homotopy

class. Computational Geometry 4(2):63–97, 1994, doi:10.1016/0925-7721(94)90010-8.

[29] J. Hershberger and S. Suri. An optimal algorithm for euclidean shortest paths in the

plane. SIAM J. Comput 28:2215–2256, 1997.

[30] S. Holmes. Statistical approach to tests involving phylogenies. Mathematics of evolution

and phylogeny. Oxford University Press, Oxford, UK pp. 91–120, 2005.

[31] M. Ishaque and C. D. T´oth. Relative convex hulls in semi-dynamic arrangements.

Algorithmica 68(2):448–482, 2014, doi:10.1007/s00453-012-9679-6.

[32] N. Karmarkar. A new polynomial-time algorithm for linear programming. Proceedings

of the sixteenth annual ACM symposium on Theory of computing, pp. 302–311, 1984.

[33] L. G. Khachiyan. Polynomial algorithms in linear programming. USSR Computational

Mathematics and Mathematical Physics 20(1):53–72, 1980.

[34] D. G. Kirkpatrick and R. Seidel. The ultimate planar convex hull algorithm? SIAM

Journal on Computing 15(1):287–299, 1986.

[35] D. Lee and F. P. Preparata. Euclidean shortest paths in the presence of rectilinear

barriers. Networks 14(3):393–410, 1984, doi:10.1002/net.3230140304.

[36] D.-T. Lee and B. J. Schachter. Two algorithms for constructing a Delaunay trian-
gulation. International Journal of Computer and Information Sciences 9(3):219–242,
1980.

[37] B. Lin, B. Sturmfels, X. Tang, and R. Yoshida. Convexity in tree spaces. arXiv preprint

arXiv:1510.08797, 2015.

[38] D. Maftuleac. Algorithms for distance problems in planar complexes of global non-
positive curvature. International Journal of Computational Geometry & Applications
24(01):1–38, 2014, doi:10.1142/S0218195914500010.

[39] E. Miller, M. Owen, and J. S. Provan. Polyhedral computational geometry for averaging

metric phylogenetic trees. Advances in Applied Mathematics 68:51–91, 2015.

[40] J. S. Mitchell. Geometric shortest paths and network optimization. Handbook of Compu-
tational Geometry, pp. 633–701. Elsevier Science Publishers B.V. North-Holland, 1998.

[41] J. S. Mitchell, D. M. Mount, and C. H. Papadimitriou. The discrete geodesic problem.

SIAM Journal on Computing 16(4):647–668, 1987.

26

[42] D. M. Mount. Storing the subdivision of a polyhedral surface. Discrete & Computational

Geometry 2(1):153–174, 1987, doi:10.1007/BF02187877.

[43] T. M. Nye. An algorithm for constructing principal geodesics in phylogenetic treespace.
Computational Biology and Bioinformatics, IEEE/ACM Transactions on 11(2):304–
315, 2014.

[44] M. Owen and J. S. Provan. A fast algorithm for computing geodesic distances in tree
space. IEEE/ACM Transactions on Computational Biology and Bioinformatics (TCBB)
8(1):2–13, 2011.

[45] F. Ronquist and J. P. Huelsenbeck. MrBayes 3: Bayesian phylogenetic inference under

mixed models. Bioinformatics 19(12):1572–1574, 2003.

[46] R. Seidel. Convex hull computations. Handbook of Discrete and Computational Geom-

etry (2nd edition), pp. 495–512. CRC Press, Inc., 2004.

[47] G. Toussaint. An optimal algorithm for computing the relative convex hull of a set of
points in a polygon. Signal Processing III: Theories and Applications, Proc. EURASIP-
86, Part 2, pp. 853–856, 1986.

[48] G. Toussaint. Computing geodesic properties inside a simple polygon. Rev. Intell. Artif.

3:9–42, 1989.

[49] J. W. Tukey. Mathematics and the picturing of data. Proceedings of the International

Congress of Mathematicians, vol. 2, pp. 523–531, 1975.

[50] G. U. Yule. A mathematical theory of evolution, based on the conclusions of Dr. JC
Willis, FRS. Philosophical Transactions of the Royal Society of London. Series B,
Containing Papers of a Biological Character pp. 21–87, 1925.

27

