6
1
0
2

 
r
a

M
1

 

 
 
]

G
L
.
s
c
[
 
 

1
v
2
2
5
0
0

.

3
0
6
1
:
v
i
X
r
a

Solving Combinatorial Games using

Products, Projections and Lexicographically Optimal Bases

Swati Gupta
Michel Goemans
Patrick Jaillet

SWATIG@MIT.EDU
GOEMANS@MATH.MIT.EDU
JAILLET@MIT.EDU

Abstract

In order to ﬁnd Nash-equilibria for two-player zero-sum games where each player plays combinatorial objects
like spanning trees, matchings etc, we consider two online learning algorithms: the online mirror descent
(OMD) algorithm and the multiplicative weights update (MWU) algorithm. The OMD algorithm requires the
computation of a certain Bregman projection, that has closed form solutions for simple convex sets like the
Euclidean ball or the simplex. However, for general polyhedra one often needs to exploit the general machin-
ery of convex optimization. We give a novel primal-style algorithm for computing Bregman projections on the
base polytopes of polymatroids. Next, in the case of the MWU algorithm, although it scales logarithmically
in the number of pure strategies or experts N in terms of regret, the algorithm takes time polynomial in N;
this especially becomes a problem when learning combinatorial objects. We give a general recipe to simu-
late the multiplicative weights update algorithm in time polynomial in their natural dimension. This is useful
whenever there exists a polynomial time generalized counting oracle (even if approximate) over these objects.
Finally, using the combinatorial structure of symmetric Nash-equilibria (SNE) when both players play bases
of matroids, we show that these can be found with a single projection or convex minimization (without using
online learning).
Keywords: multiplicative weights update, generalized approximate counting oracles, online mirror descent,
Bregman projections, submodular functions, lexicographically optimal bases, combinatorial games

(cid:80)

1. Introduction
The motivation of our work comes from two-player zero-sum games where both players play combinatorial
objects, such as spanning trees, cuts, matchings, or paths in a given graph. The number of pure strategies
of both players can then be exponential in a natural description of the problem. These are succinct games,
as discussed in the paper of Papadimitriou and Roughgarden (2008) on correlated equilibria. For example,
in a spanning tree game in which all the results of this paper apply, pure strategies correspond to spanning
trees T1 and T2 selected by the two players in a graph G (or two distinct graphs G1 and G2) and the payoff
Lef is a bilinear function; this allows for example to model classic network interdiction games
(see for e.g., Washburn and Wood (1995)), design problems (Chakrabarty et al. (2006)), and the interaction
between algorithms for many problems such as ranking and compression as bilinear duels (Immorlica et al.
(2011)). To formalize the games we are considering, assume that the pure strategies for player 1 (resp. player
2) correspond to the vertices u (resp. v) of a strategy polytope P ⊆ Rm (resp. Q ⊆ Rn) and that the loss for
player 1 is given by the bilinear function uT Lv where L ∈ Rm×n. A feature of bilinear loss functions is that
the bilinearity extends to mixed strategies as well, and thus one can easily see that mixed Nash equilibria (see

e∈T1,f∈T2

c(cid:13) S. Gupta, M. Goemans & P. Jaillet.

discussion in Section 3) correspond to solving the min-max problem:

min
x∈P

max
y∈Q

xT Ly = max
y∈Q

min
x∈P

xT Ly.

(1)

We refer to such games as MSP (Min-max Strategy Polytope) games.

Nash equilibria for two-player zero-sum games can be characterized and found by solving a linear pro-
gram (von Neumann (1928)). However, for succinct games in which the strategies of both players are ex-
ponential in a natural description of the game, the corresponding linear program has exponentially many
variables and constraints, and as Papadimitriou and Roughgarden (2008) point out in their open questions
section, “there are no standard techniques for linear programs that have both dimensions exponential.” Under
bilinear losses/payoffs however, the von Neumann linear program can be reformulated in terms of the strategy
polytopes P and Q, and this reformulation can be solved using the equivalence between optimization and
separation and the ellipsoid algorithm (Gr¨otschel et al. (1981)) (discussed in more detail in Section 3). In the
case of the spanning tree game mentioned above, the strategy polytope of each player is simply the spanning
tree polytope characterized by Edmonds (1971). Note that Immorlica et al. (2011) give such a reformulation
for bilinear games involving strategy polytopes with compact formulations only (i.e., each strategy polytope
must be described using a polynomial number of inequalities).

In this paper, we ﬁrst explore ways of solving efﬁciently this linear program using learning algorithms. As
is well-known, if one of the players uses a no-regret learning algorithm and adapts his/her strategies according
to the losses incurred so far (with respect to the most adversarial opponent strategy) then the average of the
strategies played by the players in the process constitutes an approximate equilibrium (Cesa-Bianchi and
Lugosi (2006)). Therefore, we consider the following learning problem over T rounds in the presence of
an adversary: in each round the “learner” (or player) chooses a mixed strategy xt ∈ P . Simultaneously, the
adversary chooses a loss vector lt = Lvt where vt ∈ Q and the loss incurred by the player is xT
t lt. The goal of
t lt. Note that this setting is similar to the classical
full-information online structured learning problem (see for e.g., Audibert et al. (2013)), where the learner is
required to play a pure strategy ut ∈ U (where U is the vertex set of P ) possibly randomized according to a
mixed strategy xt ∈ P , and aims to minimize the loss in expectation, i.e., E(uT

the player is to minimize the cumulative loss, i.e.,(cid:80)t

i=1 xT

t lt).

Our two main results on learning algorithms are (i) an efﬁcient implementation of online mirror descent
when P is the base polytope of a polymatroid and this is obtained by designing a novel algorithm to compute
Bregman projections over such a polytope, and (ii) an efﬁcient implementation of the MWU algorithm over the
vertices of 0/1 polytopes P , provided we have access to a generalized counting oracle for the vertices. These
are discussed in detail below. In both cases, we assume that we have an (approximate) linear optimization
oracle for Q, which allows to compute the (approximately) worst loss vector given a mixed strategy in P .
Finally, we study the combinatorial properties of symmetric Nash-equilibria for matroid games and show how
this structure can be exploited to compute these equilibria.

1.1. Online Mirror Descent
Even though the online mirror descent algorithm is near-optimal in terms of regret for most of online learning
problems (Srebro et al. (2011)), it is not computationally efﬁcient. One of the crucial steps in the mirror
descent algorithm is that of taking Bregman projections on the strategy polytope that has closed form solutions
for simple cases like the Euclidean ball or the n-dimensional simplex, and this is why such polytopes have
been the focus of attention. For general polyhedra (or convex sets) however, taking a Bregman projection is
a separable convex minimization problem. One could exploit the general machinery of convex optimization
such as the ellipsoid algorithm, but the question is if we can do better.

2

First contribution: We give a novel primal-style algorithm, INC-FIX for minimizing separable strongly
convex functions over the base polytope P of a polymatroid. This includes the setting in which U forms the
bases of a matroid, and cover many interesting examples like k-sets (uniform matroid), spanning trees (graphic
matroid), matchable/reachable sets in graphs (matching matroid/gammoid), etc. The algorithm is iterative
and maintains a feasible point in the polymatroid (or the independent set polytope for a matroid). This point
follows a trajectory that is guided by two constraints: (i) the point must remain in the polymatroid, (ii) the
smallest indices (not constrained by (i)) of the gradient of the Bregman divergence increase uniformly. The
correctness of the algorithm follows from ﬁrst order optimality conditions, and the optimality of the greedy
algorithm when optimizing linear functions over polymatroids. We discuss special cases of our algorithm
under two classical mirror maps, the unnormalized entropy and the Euclidean mirror map, under which each
iteration of our algorithm reduces to staying feasible while moving along a straight line. We believe that the
key ideas developed in this algorithm may be useful to compute projections under Bregman divergences over
other polyhedra, as long as the linear optimization for those is well-understood.

As a remark, in order to compute -approximate Nash-equilibria, if both the strategy polytopes are poly-
matroids then the same projection algorithms apply to the saddle-point mirror prox algorithm (Nemirovski
(2004)) and reduce the dependence of the rate of convergence on  to O(1/).

e:u(e)=1 λ(e) for some multiplier vector λ ∈ Rm

U ⊆ {0, 1}m is such that p(u) ∝ (cid:81)

1.2. Multiplicative Weights Update
The multiplicative weights update (MWU) algorithm proceeds by maintaining a probability distribution over
all the pure strategies of each player, and multiplicatively updates the probability distribution in response to
the adversarial strategy. The number of iterations the MWU algorithm takes to converge to an −approximate
strategy1 is O(ln N/2), where N is the number of pure strategies of the learner, in our case the size of the
vertex set of the combinatorial polytope. However, the running time of each iteration is O(N ) due to the
updates required on the probabilities of each pure strategy. A natural question is, can the MWU algorithm be
adapted to run in logarithmic time in the number of strategies?
Second contribution: We give a general framework for simulating the MWU algorithm over the set of
vertices U of a 0/1 polytope P efﬁciently by updating product distributions. A product distribution p over
+ . Note that it is easy
to start with a uniform distribution over all vertices in this representation, by simply setting λ(e) = 1 for
all e. The key idea is that a multiplicative weight update to a product distribution results in another product
distribution, obtained by appropriately and multiplicatively updating each λ(e). Thus, in different rounds of
the MWU algorithm, we move from one product distribution to another. This implies that we can restrict
our attention to product distributions without loss of generality, and this was already known as any point in
a 0/1 polytope can be decomposed into a product distribution. Product distributions allow us to maintain a
distribution on (the exponentially sized) U by simply maintaining λ ∈ Rm
+ . To be able to use the MWU
algorithm together with product distributions, we require access to a generalized (approximate) counting
oracle which, given λ ∈ Rm
e:ue=1 λ(e) and also, for any element f,
e:ue=1 λ(e) allowing the derivation of the corresponding marginals x ∈ P . For self-
reducible structures U (Schnorr (1976)) (such as spanning trees, matchings or Hamiltonian cycles), the latter
condition for every element f is superﬂuous, and the generalized approximate counting oracle can be replaced
by a fully polynomial approximate generator as shown by Jerrum et al. (1986).
Whenever we have access to a generalized approximate counting oracle, the MWU algorithm converges to
-approximate in O(ln|U|/2) time. A generalized exact counting oracle is available for spanning trees (this
1. A strategy pair (x∗, y∗) is called an -approximate Nash-equilibrium if x∗T Ly− ≤ x∗T Ly∗ ≤ xT Ly∗+ for all x ∈ P, y ∈ Q.

+ , (approximately) computes(cid:80)

u∈U(cid:81)

computes(cid:80)

(cid:81)

u∈U :uf =1

3

is Kirchhoff’s determinantal formula or matrix tree theorem) or more generally for bases of regular matroids
(see for e.g., Welsh (2009)) and randomized approximate ones for bipartite matchings (Jerrum et al. (2004))
and extensions such as 0 − 1 circulations in directed graphs or subgraphs with prespeciﬁed degree sequences
(Jerrum et al. (2004)).

As a remark, if a generalized approximate counting oracle exists for both strategy polytopes (as is the case
for the spanning tree game mentioned early in the introduction), the same ideas apply to the optimistic mirror
descent algorithm (Rakhlin and Sridharan (2013)) and reduce the dependence of the rate of convergence on 
to O(1/) while maintaining polynomial running time.

1.3. Structure of symmetric Nash equilibria
For matroid MSP games, we study properties of Nash equilibria using combinatorial arguments with the hope
to ﬁnd constructive algorithms to compute Nash equilibria. Although we were not able to solve the problem
for the general case, we prove the following results for the special case of symmetric Nash equilibria (SNE)
where both the players play the same mixed strategy.
Third contribution: We combinatorially characterize the structure of symmetric Nash equilibria. We prove
uniqueness of SNE under positive and negative deﬁnite loss matrices. We show that SNE coincide with lex-
icographically optimal points in the base polytope of the matroid in certain settings, and hence show that
they can be efﬁciently computed using any separable convex minimization algorithm (for example, algorithm
INC-FIX in Section 4). Given an observed Nash-equilibrium, we can also construct a possible loss matrix for
which that is a symmetric Nash equilibrium.

Comparison of approaches. Both the learning approaches have different applicability and limitations. We
know how to efﬁciently perform the Bregman projection only for polymatroids, and not for bipartite matchings
for which the MWU algorithm with product distributions can be used. On the other hand, there exist matroids
(Azar et al. (1994)) for which any generalized approximate counting algorithm requires an exponential number
of calls to an independence oracle, while an independence oracle is all what we need to make the Bregman
projection efﬁcient in the online mirror descent approach. Our characterization of symmetric Nash-equilibria
shows that a single projection is enough to compute symmetric equilibria (and check if they exist).

This paper is structured as follows. After discussing related work in Section 2, we review background and
notation in Section 3 and show a reformulation for the game that can be solved using separation oracles for the
strategy polytopes. We give a primal-style algorithm for separable convex minimization over base polytopes of
polymatroids in Section 4. We discuss the special cases of computing Bregman projections under the entropy
and Euclidean mirror maps, and show how to solve the subproblems that arise in the algorithm. In Section 5,
we show how to simulate the multiplicative weights algorithm in polynomial time using generalized counting
oracles. We further show that the MWU algorithm is robust to errors in these algorithms for optimization
and counting. Finally in Section 6, we completely characterize the structure of symmetric Nash-equilibria for
matroid games under symmetric loss matrices. Sections 4, 5 and 6 are independent of each other, and can be
read in any order.

2. Related work
The general problem of ﬁnding Nash-equilibria in 2-player games is PPAD-complete (Chen et al. (2009),
Daskalakis et al. (2009)). Restricting to two-player zero-sum games without any assumptions on the structure

4

of the loss functions, asymptotic upper and lower bounds (of the order O(log N/2)) on the support of -
approximate Nash equilibria with N pure strategies are known (Alth¨ofer (1994), Lipton and Young (1994),
Lipton et al. (2003), Feder et al. (2007)). These results perform a search on the support of the Nash equilibria
and it is not known how to ﬁnd Nash equilibria for large two-player zero sum games in time logarithmic
in the number of pure strategies of the players.
In recent work, Hazan and Koren (2015) show that any
online algorithm requires ˜Ω(
N ) time to approximate the value of a two-player zero-sum game, even when
given access to constant time best-response oracles.
In this work, we restrict our attention to two-player
zero-sum games with bilinear loss functions and give polynomial time algorithms for ﬁnding Nash-equilibria
(polynomial in the representation of the game).

√

One way to ﬁnd Nash-equilibria is by using regret-minimization algorithms. We look at the problem of
learning combinatorial concepts that has recently gained a lot of popularity in the community (Koolen and
Van Erven (2015), Audibert et al. (2013), Neu and Bart´ok (2015), Cohen and Hazan (2015), Ailon (2014),
Koolen et al. (2010)), and has found many real world applications in communication, principal component
analysis, scheduling, routing, personalized content recommendation, online ad display etc. There are two pop-
ular approaches to learn over combinatorial concepts. The ﬁrst is the Follow-the-Perturbed-Leader (Kalai and
Vempala (2005)), though efﬁcient in runtime complexity it is suboptimal in terms of regret (Neu and Bart´ok
(2015), Cohen and Hazan (2015)). The other method for learning over combinatorial structures is the online
mirror descent algorithm (online convex optimization is attributed to Zinkevich (2003) and mirror descent to
Nemirovski and Yudin (1983)), which fares better in terms of regret but is computationally inefﬁcient (Srebro
et al. (2011), Audibert et al. (2013)). In the ﬁrst part of the work, we give a novel algorithm that speeds up the
mirror descent algorithm in some setting.

Koolen et al. (2010) introduce the Component Hedge (CH) algorithm for linear loss functions that sum
over the losses for each component. They perform multiplicative updates for each component and subse-
quently perform Bregman projections over certain extended formulations with a polynomial number of con-
straints, using off-the-shelf convex optimization subroutines. Our work, on the other hand, allows for poly-
topes with exponentially many inequalities. The works of Helmbold and Warmuth (2009) (for learning over
permutations) and Warmuth and Kuzmin (2008) (for learning k-sets) have been shown to be special cases of
the CH algorithm. Our work applies to these settings.

One of our contributions is to give a new efﬁcient algorithm INC-FIX for performing Bregman projections
on base polytopes of polymatroids, a step in the online mirror descent algorithm. Another way of solving the
associated separable convex optimization problem over base polytopes of polymatroids is the decomposition
algorithm of Groenevelt (1991) (also studied in Fujishige (2005)). Our algorithm is fundamentally different
from the decomposition algorithm; the latter generates a sequence of violated inequalities (a dual approach)
while our algorithm maintains a feasible point in the polymatroid (a primal approach). The violated inequal-
ities in the decomposition algorithm come from a series of submodular function minimizations, and their
computations can be amortized into a parametric submodular function minimization as is shown in Nagano
(2007a,b); Suehiro et al. (2012). In the special cases of the Euclidean or the entropy mirror maps, our iterative
algorithm leads to problems involving the maintenance of feasibility along lines, which reduces to parametric
submodular function minimization problems. In the special case of cardinality-based submodular functions
(f (S) = g(|S|) for some concave g), our algorithm can be implemented overall in O(n2) time, matching the
running time of a specialized algorithm due to Suehiro et al. (2012).

We also consider the multiplicative weights update (MWU) algorithm (Littlestone and Warmuth (1994),
Freund and Schapire (1999), Arora et al. (2012)) rediscovered for different settings in game theory, machine
learning, and online decision making with a large number of applications. Most of the applications of the
MWU algorithm have running times polynomial in the number of pure strategies of the learner, an observation

5

also made in Blum et al. (2008). In order to perform this algorithm efﬁciently for exponential experts (with
combinatorial structure), it does not take much to see that multiplicative updates for linear losses can be made
using product terms. However, the analysis of prior works was very speciﬁc to the structure of the problem.
For example, Takimoto and Warmuth (2003) give efﬁcient implementations of the MWU for learning over
general s − t paths that allow for cycles or over simple paths in acyclic directed graphs. This approach relies
on the recursive structure of these paths, and does not generalize to simple paths in an undirected graph (or
a directed graph). Similarly, Helmbold and Schapire (1997) rely on the recursive structure of bounded depth
binary decision trees. Koo et al. (2007) use the matrix tree theorem to learn over spanning trees by doing large-
margin optimization. We give a general framework to analyze these problems, while drawing a connection to
sampling or generalized counting of product distributions.

(resp. y ∈ ∆N ) where ∆K is the simplex {x ∈ RK,(cid:80)K

3. Preliminaries
In a two-player zero-sum game with loss (or payoff) matrix R ∈ RM×N , a mixed strategy x (resp. y) for the
row player (resp. column player) trying to minimize (resp. maximize) his/her loss is an assignment x ∈ ∆M
i=1 xi = 1, x ≥ 0}. A pair of mixed strategies
(x∗, y∗) is called a Nash-equilibrium if x∗T R¯y ≤ x∗T Ry∗ ≤ ¯xT Ry∗ for all ¯x ∈ ∆M , ¯y ∈ ∆N , i.e. there is
no incentive for either player to switch from (x∗, y∗) given that the other player does not deviate. Similarly, a
pair of strategies (x∗, y∗) is called an −approximate Nash-equilibrium if x∗T R¯y− ≤ x∗T Ry∗ ≤ ¯xT Ry∗ +
for all ¯x ∈ ∆M , ¯y ∈ ∆N . Von Neumann showed that every two-player zero-sum game has a mixed Nash-
equilibrium that can be found by solving the following dual pair of linear programs:

(LP 1) : min λ

RT x ≤ λe,
eT x = 1, x ≥ 0.

(LP 2) : max µ

Ry ≥ µe,
eT y = 1, y ≥ 0.

where e is a vector of all ones in the appropriate dimension.
In our two-player zero-sum MSP games, we let the strategies of the row player be U = vert(P ), where
P = {x ∈ Rm, Ax ≤ b} is a polytope and vert(P ) is the set of vertices of P and those of the column player
be V = vert(Q) where Q = {y ∈ Rn, Cy ≤ d} is also a polytope. The numbers of pure strategies, M = |U|,
N = |V| will typically be exponential in m or n, and so may be the number of rows in the constraint matrices
A and C. The linear programs (LP 1) and (LP 2) have thus exponentially many variables and constraints. We
restrict our attention to bilinear loss functions that are represented as Ruv = uT Lv for some m × n matrix L.
An artifact of bilinear loss functions is that the bilinearity extends to mixed strategies as well. If λ ∈ ∆U and
u∈U λuu

θ ∈ ∆V are mixed strategies for the players then the expected loss is equal to xT Ly where x =(cid:80)
and y =(cid:80)

v∈V θvv:

Eu,v(Ruv) =

λuθv(uT Lv) = (

λuu)L(

θvv) = xT Ly.

(cid:88)

(cid:88)

u∈U

v∈V

(cid:88)

u∈U

(cid:88)

v∈V

Thus the loss incurred by mixed strategies only depend on the marginals of the distributions over the vertices
of P and Q; distributions with the same marginals give the same expected loss. This plays a crucial role in
our proofs. Thus the Nash equilibrium problem for MSP games reduces to (1): minx∈P maxy∈Q xT Ly =
maxy∈Q minx∈P xT Ly.
As an example of an MSP game, consider a spanning tree game where the pure strategies of each player
are the spanning trees of a given graph G = (V, E) with m edges, and L is the m × m identity matrix. This

6

corresponds to the game in which the row player would try to minimize the intersection of his/her spanning
tree with that of the column player, whereas the column player would try to maximize the intersection. For
a complete graph, the number of pure strategies for each player is nn−2 by Cayley’s theorem, where n is the
number of vertices. For the graph G in Figure 1(a), the marginals of the unique Nash equilibrium for both
players are given in 1(b) and (c). For graphs whose blocks are uniformly dense, both players can play the
same (called symmetric) optimal mixed strategy.

Figure 1: (a) G = (V, E), (b) Optimal strategy for the row player minimizing the number of edges in the intersection of the two

trees, (c) Optimal strategy for the column player maximizing the number of edges in the intersection.

For MSP games with bilinear losses, the linear programs (LP 1) and (LP 2) can be reformulated over the

space of marginals, and (LP 1) becomes

(LP 1(cid:48)) : min λ

xT Lv ≤ λ ∀ v ∈ V,
x ∈ P ⊆ Rm,

(2)
(3)
and similarly for (LP 2): max{µ : uT Ly ≥ µ ∀u ∈ U, y ∈ Q}. This reformulation can be used to show that,
for these MSP games with bilinear losses (and exponentially many strategies), there exists a Nash equilibrium
with small (polynomial) encoding length. A polyhedron K is said to have vertex-complexity at most ν if there
exist ﬁnite sets V, E of rational vectors such that K = conv(V ) + cone(E) and such that each of the vectors
in V and E has encoding length at most ν. A polyhedron K is said to have facet-complexity at most φ if there
exists a system of inequalities with rational coefﬁcients that has solution set K such that the (binary) encoding
length of each inequality of the system is at most φ. Let νP and νQ be the vertex complexities of polytopes P
and Q respectively; if P and Q are 0/1 polytopes, we have νP ≤ m and νQ ≤ n. This means that the facet
complexity of P and Q are O(m2νP ) and O(n2νQ) (see Lemma (6.2.4) in Lov´asz et al. (1988)). Therefore
the facet complexity of the polyhedron in (LP 1(cid:48)) can be seen to be O(max(m(cid:104)L(cid:105)νQ, n2νP )), where (cid:104)L(cid:105) is
the binary enconding length of L and the ﬁrst term in the max corresponds to the inequalities (2) and the
second to (3). From this, we can derive Lemma 1.
Lemma 1 The vertex complexity of the linear program (LP 1(cid:48)) is O(m2(m(cid:104)L(cid:105)νQ + n2νP )) where νP and
νQ are the vertex complexities of P and Q and (cid:104)L(cid:105) is the binary encoding length of L. (If P and Q are 0/1
polytopes then νP ≤ m and νQ ≤ n.)

This means that our polytope deﬁning (LP 1(cid:48)) is well-described (`a la Gr¨otschel et al.). We can thus use
the machinery of the ellipsoid algorithm (Gr¨otschel et al. (1981)) to ﬁnd a Nash Equilibrium in polynomial

7

bc1bc2bc3bc4bc5bc6bc7bc8(a)bc1bc2bc3bc4bc5bc6bc7bc8(b)3/413/36bc1bc2bc3bc4bc5bc6bc7bc811/121/3(c)time for these MSP games, provided we can optimize (or separate) over P and Q. Indeed, by the ellipsoid
algorithm, we have the equivalence between strong separation and strong optimization for well-described
polyhedra. The strong separation over (2) reduces to strong optimization over Q, while a strong separation
algorithm over (3), i.e. over P , can be obtained from a strong separation over P by the ellipsoid algorithm.
We should also point out at this point that, if the polyhedra P and Q admit a compact extended formu-
lation then (LP 1(cid:48)) can also be reformulated in a compact way (and solved using interior point methods, for
example). A compact extended formulation for a polyhedron P ⊆ Rd is a polytope with polynomially many
(in d) facets in a higher dimensional space that projects onto P . This allows to give a compact extended
formulation for (LP 1(cid:48)) for the spanning tree game as a compact formulation is known for the spanning tree
polytope (Martin (1991)) (and any other game where the two strategy polytopes can be described using poly-
nomial number of inequalities). However, this would not work for a corresponding matching game since the
extension complexity for the matching polytope is exponential (Rothvoß (2014)).

4. Online mirror descent
In this section, we show how to perform mirror descent faster, by providing algorithms for minimizing strongly
convex functions over base polytopes of polymatroids.
Consider a compact convex set X ⊆ Rn, and let D ⊆ Rn be a convex open set such that X is included
in its closure. A mirror map (or a distance generating function) is a k-strongly convex function2 and differen-
tiable function ω : D → R that satisﬁes additional properties of divergence of the gradient on the boundary
of D, i.e., limx→∂D ||∇ω(x)|| = ∞ (for details, refer to Nemirovski and Yudin (1983), Beck and Teboulle
(2003), Bubeck (2014)). In particular, we consider two important mirror maps in this work, the Euclidean
2||x||2,
mirror map and the unnormalized entropy mirror map. The Euclidean mirror map is given by ω(x) = 1
for D = RE and is 1-strongly convex with respect to the L2 norm. The unnormalized entropy map is given
+ and is 1-strongly convex over the unnormalized

e∈E x(e) ln(x(e)) −(cid:80)

by ω(x) =(cid:80)

e∈E x(e), for D = RE

simplex with respect to the L1 norm (see proof in Appendix A, Lemma 15).

The Online Mirror Descent (OMD) algorithm with respect to the mirror map ω proceeds as follows. Think
of X as the strategy polytope of the row player or the learner in the online algorithm that is trying to minimize
regret over the points in the polytope with respect to loss vectors l(t) revealed by the adversary in each round.
The iterative algorithm starts with the ﬁrst iterate x(1) equal to the ω-center of X given by arg minx∈X ω(x).
Subsequently, for t > 1, the algorithm ﬁrst moves in unconstrained way using

∇ω(y(t+1)) = ∇ω(x(t)) − η∇l(t)(x(t)).

Then the next iterate x(t+1) is obtained by a projection step:

x(t+1) = arg min

x∈X∩D Dω(x, y(t+1)),

(4)

where the generalized notion of projection is deﬁned by the function Dω(x, y) = ω(x)− ω(y)−∇ω(y)T (x−
y), called the Bregman divergence of the mirror map. Since the Bregman divergence is a strongly convex
function in x for a ﬁxed y, there is a unique minimizer x(t+1). For the two mirror maps discussed above,
2||x − y||2 for y ∈ RE for the Euclidean mirror map, and is Dω(x, y) =
the divergence is Dω(x, y) = 1

(cid:80)
e∈E x(e) ln(x(e)/y(e)) −(cid:80)

e∈E x(e) +(cid:80)

e∈E y(e) for the entropy mirror map.

2. A function f is said to be k-strongly convex over domain D with respect to a norm || · || if f (x) ≥ f (y) + ∇f (y)T (x − y) +

k

2||x − y||2.

8

√
The regret of the online mirror descent algorithm is known to scale as O(RG

t) where R depends on
the geometry of the convex set and is given by R2 = arg maxx∈X ω(x) − arg minx∈X ω(x) and G is the
Lipschitz constant of the underlying loss functions, i.e., ||∇l(i)||∗ ≤ G for all i = 1, . . . , T . We restate the
theorem about the regret of the online mirror-descent algorithm (adapted from Bubeck (2011), Ben-Tal and
Nemirovski (2001), Rakhlin and Sridharan (2014)).
Theorem 2 Consider online mirror descent based on a k-strongly convex (with respect to ||·||) and differen-
tiable mirror map ω : D → R on a closed convex set X. Let each loss function l(i) : X → R be convex and G-
Lipschitz, i.e. ||∇l(i)||∗ ≤ G ∀i ∈ {1, . . . , t} and let the radius R2 = arg maxx∈X ω(x)−arg minx∈X ω(x).
Further, we set η = R
G

then:

(cid:114) 2t

k

l(i)(x∗) ≤ RG

for all x∗ ∈ X.

(cid:113) 2k
t(cid:88)

t

l(i)(xi) − t(cid:88)

i=1

i=1

4.1. Convex Minimization on Base Polytopes of Polymatroids
In this section, we consider the setting in which X is the base polytope of a polymatroid. Let f be a monotone
submodular function, i.e., f must satisfy the following conditions: (i) (monotonicity) f (A) ≤ f (B) for all
A ⊆ B ⊆ E, and (ii) (submodularity) f (A) + f (B) ≥ f (A∪ B) + f (A∩ B) for all A, B ⊆ E. Furthermore,
we will assume f (∅) = 0 (normalized) and without loss of generality we assume that f (A) > 0 for A (cid:54)= ∅.
+ : x(U ) ≤ f (U ) ∀ U ⊆
Given such a function f, the independent set polytope is deﬁned as P (f ) = {x ∈ RE
+ : x(E) = f (E), x(U ) ≤ f (U ) ∀ U ⊆ E} (Edmonds
E} and the base polytope as B(f ) = {x ∈ RE
(1970)). A typical example is when f is the rank function of a matroid, and the corresponding base polytope
corresponds to the convex hull of its bases. Bases of a matroid include spanning trees (bases of a graphic
matroid), k-sets (uniform matroid), maximally matchable sets of vertices in a graph (matching matroid), or
maximal subsets of T ⊆ V having disjoint paths from vertices in S ⊆ V in a directed graph G = (V, E)
(gammoid).
Let us consider any strongly convex separable function h : D → R, deﬁned over a convex open set D
such that P (f ) ⊆ D (i.e., closure of D) and ∇h(D) = RE. We require that either 0 ∈ D or there exists some
x ∈ P (f ) such that ∇h(x) = cχ(E), c ∈ R. These conditions hold, for example, for minimizing the Bregman
divergence of the two mirror maps (Euclidean and entropy) we discussed in the previous section. We present
in this section an algorithm INC-FIX, that minimizes such convex functions h over the base polytope B(f )
of a given monotone normalized submodular function f. Our approach can be interpreted as a generalization
of Fujishige’s monotone algorithm for ﬁnding a lexicographically optimal base to handle general separable
convex functions.
Key idea: The algorithm is iterative and maintains a vector x ∈ P (f ) ∩ D. When considering x we
associate a weight vector given by ∇h(x) and consider the set of minimum weight elements. We move x
within P (f ) in a direction such that (∇h(x))e increases uniformly on the minimum weight elements, until
one of two things happen: (i) either continuing further would violate a constraint deﬁning P (f ), or (ii) the set
of elements of minimum weight changes. If the former happens, we ﬁx the tight elements and continue the
process on non-ﬁxed elements. If the latter happens, then we continue increasing the value of the elements
in the modiﬁed set of minimum weight elements. The complete description of the INC-FIX algorithm is
given in Algorithm 1. We refer to the initial starting point as x(0). The algorithm constructs a sequence of
points x(0), x(1), . . . , x(k) = x∗ in P (f ). At the beginning of iteration i, the set of non-ﬁxed elements whose
value can potentially be increased without violating any constraint is referred to as Ni−1. The iterate x(i)

9

is obtained by increasing the value of minimum weight elements of x(i−1) in Ni−1 weighted by (∇h(x))e
such that the resulting point stays in P (f ). Iteration i of the main loop ends when some non-ﬁxed element
becomes tight and we ﬁx the value on these elements by updating Ni. We continue until all the elements are
ﬁxed, i.e., Ni = ∅. We denote by T (x) : RE → 2E the maximal set of tight elements in x (which is unique
by submodularity of f).

e∈E he, and input x(0)

e he(z(e))

(cid:80)

Algorithm 1 INC-FIX

Input: f : 2E → R, h =(cid:80)

Output: x∗ = arg minz∈B(f )
N0 = E, i = 0
repeat
i ← i + 1
x = x(i−1)
M = arg mine∈Ni−1 ∇(h(x))e
while T (x) ∩ M = ∅ do

/* Main loop */

/* Inner loop */

/* Increase */

/* Fix */

1 = max{δ : (∇h)−1(∇h(x) + δχ(M )) ∈ P (f )}
2 = arg mine∈Ni−1\M (∇h(x))e − arg mine∈Ni−1(∇h(x))e
x ← (∇h)−1(∇h(x) + min(1, 2)χ(M ));
M = arg mine∈Ni−1(∇h(x))e

end
x(i) = x, Mi = arg mine∈Ni−1(∇h(x(i)))e Ni = Ni−1 \ (Mi ∩ T (x(i)))

until Ni = ∅;
Return x∗ = x(i).

Choice of starting point: We let x(0) = 0 unless 0 /∈ D; observe that 0 ∈ P (f ) ⊆ D. In the latter case,
we let x(0) ∈ P (f ) such that ∇h(x(0)) = cχ(E) for some c ∈ R. For example, for the Euclidean mirror map
and some y ∈ RE, ∇h(x) = ∇Dω(x, y) = x − y and D = RE, hence we start the algorithm with x(0) = 0.
However, for the entropy mirror map and some positive (component-wise) y ∈ RE, ∇h(x) = ∇Dω(x, y) =
>0. We thus start the algorithm with x(0) = cy for a small enough c > 0 such that x ∈ P (f ).
ln( x

y ) and D = RE
We now state the main theorem to prove correctness of the algorithm.

Theorem 3 Consider a k-strongly convex and separable function(cid:80)

The proof relies on the following optimality conditions, which follows from ﬁrst order optimality condi-

e∈E he(·) : D → R where D is a convex
open set in RE, P (f ) ⊆ D and ∇h(D) = RE such that either 0 ∈ D or there exists x ∈ P (f ) such that
∇h(x) = cχ(E) for c ∈ R. Then, the output of INC-FIX algorithm is x∗ = arg minz∈B(f )

(cid:80)
Theorem 4 Consider any strongly convex separable function h(x) : D → R where h(x) =(cid:80)

e∈E he(x(e)),
and any monotone submodular function f : 2E → R with f (∅) = 0. Assume P (f ) ⊆ D and ∇h(D) = RE.
Consider x∗ ∈ RE. Let F1, F2, . . . , Fk be a partition of the ground set E such that (∇h(x∗))e = ci for all
e ∈ Fi and ci < cj for i < j. Then, x∗ = arg minz∈B(f )
e∈E he(z(e)) if and only if x∗ lies in the face Hopt
of B(f ) given by

tions and Edmonds’ greedy algorithm.

e he(z(e)).

(cid:80)

Hopt := {z ∈ B(f )| z(F1 ∪ . . . ∪ Fi) = f (F1 ∪ . . . ∪ Fi) ∀ 1 ≤ i ≤ k}.

10

Proof By ﬁrst order optimality conditions, we know that x∗ = arg minz∈B(f )
e he(x(e)) if and only if
∇h(x∗)T (z − x∗) ≥ 0 for all z ∈ B(f ). This is equivalent to x∗ ∈ arg minz∈B(f ) ∇h(x∗)T z. Now consider
the partition F1, F2, . . . , Fk as deﬁned in the statement of the theorem. Using Edmonds’ greedy algorithm
Edmonds (1971), we know that any z∗ ∈ B(f ) is a minimizer of ∇h(x∗)T z if and only if it is tight (i.e., full
rank) on each F1 ∪ . . . Fi for i = 1, . . . , k, i.e., z∗ lies in the face Hopt of B(f ) given by

(cid:80)

Hopt := {z ∈ B(f )| z(F1 ∪ . . . ∪ Fi) = f (F1 ∪ . . . ∪ Fi) ∀ 1 ≤ i ≤ k}.

Note that at the end of the algorithm, there may be some elements at zero value (speciﬁcally in cases
where x(0) = 0). In our proof for correctness for the algorithm, we use the following simple lemma about
zero-valued elements.
Lemma 5 For x ∈ P (f ), if a subset S of elements is tight then so is S \ {e : x(e) = 0}.
Proof Let S = S1 ∪ S2 such that x(S2) = 0 and x(e) > 0 for all e ∈ S1. Then, f (S1) ≥ x(S1) =
x(S1 ∪ S2) = f (S1 ∪ S2) ≥ f (S1), where the last inequality follows from monotonicity of f, implying that
we have equality throughout. Thus, x(S1) = f (S1).

Proof Note that since h(x) =(cid:80)

We now give the proof for Theorem 3 to show the correctness of the INC-FIX algorithm.

e he(x(e)) is separable and k-strongly convex, ∇h is a strictly increasing
e(y) ≥ k(x− y) for x > y). Moreover, (∇h)−1 is well-deﬁned for
e(x)− h(cid:48)
function (for each component e, h(cid:48)
all points in RE since ∇h(D) = RE. Consider the output of the algorithm x∗ and let us partition the elements
e(x∗(e)) = ci for all e ∈ Fi and ci < cj for i < j. We will
of the ground set E into F1, F2, . . . , Fk such that h(cid:48)
show that Fi = Mi ∩ T (x(i)) and that k is the number of iterations of Algorithm 1. We ﬁrst claim that in each
iteration i ≥ 1 of the main loop, the inner loop satisﬁes the following invariant, as long as the initial starting
point x(0) ∈ P (f ):
(a). The inner loop returns x(i) ∈ P (f ) such that h(cid:48)

e(x(i−1)(e)), (i)} for e ∈ Ni−1 and

some (i) ∈ R, x(i)(e) = x(i−1)(e) for e ∈ E \ Ni−1, and T (x(i)) ∩ Mi (cid:54)= ∅.

e(x(i)(e)) = max{h(cid:48)

Note that M is initialized to be the set of minimum elements in Ni−1 with respect to ∇h(x(i−1)) before
entering the inner loop. 1 ensures that the potential increase in ∇h(x) on elements in M is such that the
corresponding point x ∈ P (f ) (1 exists since x(i−1) ∈ P (f )). 2 ensures that the potential increase in
∇h(x) on elements in M is such that M remains the set of minimum weighted elements in Ni−1. Finally,
x is obtained by increasing ∇h(x) by min(1, 2) and M is updated accordingly. This ensures that at any
point in the inner loop, M = arg mine∈Ni−1 h(cid:48)
e(x(e)). This continues till there is a tight set T (x) of the
current iterate, x, that intersects with the minimum weighted elements M. Observe that in each iteration
of the inner loop either the size of T (x) increases (in the case when 1 = min(1, 2)) or the size of M
increases (in the case when 2 = min(1, 2)). Therefore, the inner loop must terminate. Note that (i) =
mine∈Ni−1 h(cid:48)
Recall that Mi = arg mine∈Ni−1(∇h(x(i)))e and let the set of elements ﬁxed at the end of each iteration
be Li = Mi ∩ T (x(i)). We next prove the following claims at the end of each iteration i ≥ 1.
(b). x(i−1)(e) ≤ x(i)(e) for all e ∈ E, as ∇h is a strictly increasing function and ∇h(x(i−1)) ≤ ∇h(x(i))

f (x(i)(f )) for f ∈ Mi, by deﬁnition of Mi.

e(x(i)(e)) = h(cid:48)

due to claim (a).

11

(c). Next, observe that we always decrease the set of non-ﬁxed elements Ni, i.e., Ni ⊂ Ni−1. This follows

since Ni = Ni−1 \ Li and ∅ (cid:54)= Li ⊆ Ni−1 (follows from (a) and deﬁnition of Li).

(d). By construction, the set of elements ﬁxed at the end of each iteration partition E \ Ni, i.e., E \ Ni =

L1 ˙∪ . . . ˙∪Li.

(e). We claim that the set of minimum elements Mi at the end of any iteration i always contains the left-over
minimum elements from the previous iteration, i.e., Mi−1 \ Li−1 ⊆ Mi. This is clear if Li−1 = Mi−1,
so consider the case when Li−1 ⊂ Mi−1. At the beginning of the inner loop of iteration i, M =
e(x(i−1)(e)) = Mi−1 \ Li−1. Subsequently, in the inner loop the set of minimum
arg mine∈Ni−1 h(cid:48)
elements can only increase and thus, Mi ⊇ Mi−1 \ Li−1.

(f). We next show that (i−1) < (i) for i ≥ 2. Consider an arbitrary iteration i ≥ 2. If Li−1 = Mi−1, then
e(x(i)(e))≥(∗) mine∈Ni−2\Mi−1 h(cid:48)
(i) = mine∈Ni−1=Ni−2\Li−1 h(cid:48)
e(x(i−1)(e)) > mine∈Mi−1 h(cid:48)
e(x(i)(e)) =
(i−1) where (*) follows from (b). Otherwise, we have Li−1 ⊂ Mi−1. This implies that Mi−1 \ Li−1
is not tight on x(i−1), and it is in fact equal to arg mine∈Ni−1 h(cid:48)
e(xi−1(e)) (= M at the beginning of
the inner loop in iteration i). As this set is not tight, the gradient value can be strictly increased and
therefore (i) > (i−1).

We next split the proof into two cases (A) and (B), depending on how x(0) is initialized.

(A) Proof for x(0) = 0:
(g). We claim that x(i)(e) = x(i−1)(e) for all e ∈ Ni\Mi. This follows since the gradient values, h(cid:48)

e(xi(e)),
for the edges e ∈ Ni \ Mi are greater than (i) and thus remain unchanged from x(i−1) (due to claim
(a)).

(h). We claim that x(i)(e) = 0 for e ∈ Ni\Mi. Using (e) we get Ni\Mi = Ni−1\Mi ⊆ Ni−1\(Mi−1\Li).
Since Li ∩ Ni = ∅, we get Ni \ Mi ⊆ Ni−1 \ Mi−1. Now (g) implies that x(i)(e) = x(0)(e) for all
e ∈ Ni \ Mi.

(i). We next prove that 1 ≤ j ≤ i, x(i)(L1 ∪ . . . ∪ Lj) = f (L1 ∪ . . . ∪ Lj). First, for i = 1 note
that T (x(1)) can be partitioned into {L1, T (x(1)) \ M1}. Since T (x(1)) \ M1 ⊆ N1 \ M1, we get
x(1)(T (x(1)) \ M1) = 0 using (g). Thus, by Lemma 5, we get that x(1) is tight on L1 as well.
Next, consider any iteration i > 1. If j < i, then x(j)(L1 ∪ . . . ∪ Lj) = f (L1 ∪ . . . ∪ Lj) by induction.
Since x(i) ≥ x(j), x(i) must also be tight on L1 ∪ . . . ∪ Lj. Note that T (x(i)) can be partitioned into

(cid:1),(cid:0)T (x(i)) ∩
{(cid:0)T (x(i)) ∩ (E \ Ni−1
(Ni \ Mi)(cid:1), Li} using (d). Note that x(i) is zero-value on Ni \ Mi, from (h). By Lemma (5) we get that
x(i) is also tight on(cid:0)L1 ∪ . . . ∪ Li

(cid:1).

(cid:1),(cid:0)T (x(i)) ∩ (Ni−1 \ Mi)(cid:1),(cid:0)T (x(i)) ∩ Mi

(cid:1)} = {(cid:0)L1 ∪ . . . ∪ Li−1

Claim (b) implies the termination of the algorithm when for some t, Nt = ∅. From claim (d), we have
obtained a partition of E into disjoint sets {L1, L2, . . . , Lt}. From claims (a) and (d), we get x(t)(e) = (i) for
e ∈ Li. Claim (f) implies that the partition in the theorem {F1, . . . , Fk} is identical to the partition obtained
via the algorithm {L1, . . . , Lt} (hence t = k). Claim (i) implies that x∗ = x(t) lies in the face Hopt as deﬁned
in Theorem 4.
(B) Proof for x(0) ∈ P (f ) such that ∇h(x(0)) = cχ(E) for some c ∈ R:

12

M1 = E by (g(cid:48)), we have T (x(1)) = L1. So, x(1) is tight on L1.
Next, consider any iteration i > 1. If j < i, then x(j)(L1 ∪ . . . ∪ Lj) = f (L1 ∪ . . . ∪ Lj) by induction.
Since x(i) ≥ x(j), x(i) must also be tight on L1 ∪ . . . ∪ Lj. Note that T (x(i)) can be partitioned into

(cid:1),(cid:0)T (x(i))∩ (Ni−1 \ Mi)(cid:1),(cid:0)T (x(i))∩ Mi

(cid:1)} = {(cid:0)L1 ∪ . . .∪ Li−1

{(cid:0)T (x(i))∩ (E \ Ni−1

(cid:1),∅, Li} using

e(x(1)(e)) = (1) for all e ∈ E, since h(cid:48)
(g(cid:48)). We claim that Mi = Ni−1. For iteration i = 1, h(cid:48)
e(x(0)(e)) = c
for all the edges. Thus, indeed, M1 = E = N0. For iteration i > 1, we have Ni−1 = Ni−2 \ Li−1 =
Mi−1 \ Li−1 (by induction). This implies that h(cid:48)
e(x(i−1)(e)) = (i−1) for all the edges in Ni−1. Thus,
in iteration i, all the edges e must again have the same gradient value, h(cid:48)
e(x(i)(e)), due to invariant (a).
(h(cid:48)). We claim that 1 ≤ j ≤ i, x(i)(L1 ∪ . . . ∪ Lj) = f (L1 ∪ . . . ∪ Lj). First, for iteration i = 1, since

(d), the claim follows.

Claim (b) implies the termination of the algorithm when for some t, Nt = ∅. From claim (d), we have
obtained a partition of E into disjoint sets {L1, L2, . . . , Lt}. From claims (a) and (d), we get x(t)(e) = (i) for
e ∈ Li. Claim (f) implies that the partition in the theorem {F1, . . . , Fk} is identical to the partition obtained
via the algorithm {L1, . . . , Lt} (hence t = k). Claim (h(cid:48)) implies that x∗ = x(t) lies in the face Hopt as
deﬁned in Theorem 4.

4.2. Bregman Projections under the Entropy and Euclidean Mirror Maps
We next discuss the application of INC-FIX algorithm to two important mirror maps. One feature that is
common to both is that the trajectory of x in INC-FIX is piecewise linear, and the main step is ﬁnd the
maximum possible increase of x in a given direction d.

Unnormalized entropy mirror map This map is given by ω(x) =(cid:80)
e∈E x(e) +(cid:80)
its divergence is Dω(x, y) =(cid:80)

e∈E x(e) ln(x(e)/y(e)) −(cid:80)

y ) for a given y > 0. Finally, ∇D−1

e∈E x(e) and
e∈E y(e). Note that ∇Dω(x, y) =
ω (x) = ye−x. In order to minimize the divergence Dω(x, y) with
ln( x
respect to a given point y ∈ RE
+ using the INC-FIX algorithm, we need to ﬁnd the maximum possible increase
in the gradient ∇Dω while remaining in the submodular polytope P (f ). In each iteration, this amounts to
computing:

e∈E x(e) ln x(e) −(cid:80)

1 = max{δ : (∇Dω)−1(∇Dω(x) + δχ(M )) ∈ P (f )} = max{δ : ye(∇Dω(x)+δχ(M )) ∈ P (f )}

= max{δ : x + z ∈ P (f ), z(e) = (eδ − 1)x(e) for e ∈ M, z(e) = 0 for e /∈ M},

for some M ⊆ E. For the entropy mirror map, the point to be projected, y, must be positive in each coordinate
(otherwise the divergence is undeﬁned). We initialize x(0) = cy ∈ P (f ) for a small enough constant c >
0. Apart from satisfying the conditions of the INC-FIX algorithm, this ensures that there is a well deﬁned
direction for increase in each iteration.
Euclidean mirror map The Euclidean mirror map is given by ω(x) = 1
Dω(x, y) = 1
plies that for any iteration, we need to compute

2||x||2 and its divergence is
2||x − y||2. Here, for a given y ∈ R, ∇Dω(x, y) = ∇ω(x) − ∇ω(y) = x − y. This im-

1 = max{δ : (∇Dω)−1(∇Dω(x) + δχ(M )) ∈ P (f )} = max{δ : (∇Dω(x) + δχ(M )) + y ∈ P (f )}

= max{δ : x + δχ(M ) ∈ P (f )},

13

for some M ⊆ E. Notice that in each iteration of both the algorithms for the entropy and the Euclidean
mirror maps, we need to ﬁnd the maximum possible increase to the value on non-tight elements in a ﬁxed
given direction d ≥ 0. For the case of the entropy mirror map, de = xe for e ∈ M and de = 0 otherwise,
while, for the Euclidean mirror map, d = χ(M ) (for current iterate x ∈ P (f ), and corresponding minimum
weighted set of edges M ⊆ E).
Let LINE be the problem of ﬁnding the maximum δ s.t. x + δd ∈ P (f ). P1 is equivalent to ﬁnding
maximum δ such that minS⊆E f (S) − (x + δd)(S) = 0; this is a parametric submodular minimization
problem. For the graphic matroid, feasibility in the forest polytope can be solved by O(|V |) maximum ﬂow
problems (Cunningham (1985), Corollary 51.3a in Schrijver (2003)), and as result, LINE can be solved as
O(|V |2) maximum ﬂow problems (by Dinkelbach’s discrete Newton method) or O(|V |) parametric maximum
ﬂow problems. For general polymatroids over the ground set E, the problem LINE can be solved using
Nagano’s parametric submodular function minimization (Nagano (2007c)) that requires O(|E|6 + γ|E|5)
running time, where γ is the time required by the value oracle of the submodular function. Each of the
entropy and the Euclidean mirror maps requires O(|E|) (O(|V |) for the graphic matroid) such computations
to compute a projection, since each iteration of the INC-FIX algorithm at least one non-tight edge becomes
tight. Thus, for the graphic matroid we can compute Bregman projections in O(|V |4|E|) time (using Orlin’s
O(|V ||E|) algorithm (Orlin (2013)) for computing the maximum ﬂow) and for general polymatroids the
running time is O(|E|7 + γ|E|6) where |E| is the size of the ground set. For cardinality-based submodular
functions3, we can prove a better bound on the running time.
Lemma 6 The INC-FIX algorithm takes O(|E|2) time to compute projections over base polytopes of poly-
matroids when the corresponding submodular function is cardinality-based.
Proof Let f be a cardinality-based submodular function such that f (S) = g(|S|) for all S ⊆ E and some
concave g : N → R. Let T (x) denote the maximal tight set of x ∈ P (f ). Let LINE be the problem to ﬁnd
λ∗ = max{λ : x + λz ∈ P (f )} where x ∈ P (f ), z ∈ RE
+. Let S(x) be a sorted sequence of components of
x in decreasing order. We will show that for both the mirror maps, we can solve LINE in O(|E|) time.

(i) We ﬁrst claim that (x+λ∗y)(e) ≤ mine(cid:48)∈T (x) x(e(cid:48)) for all e ∈ E\T (x). Let e∗ ∈ arg mine(cid:48)∈T (x) x(e(cid:48)).
The claim holds since otherwise the submodular constraint on the set T (x) \ {e∗} ∪ {e(cid:48)} (which is of
the same cardinality as T (x)) will be violated.

if a vector x is in P (f ), one can simply check if(cid:80)k

(ii) Let S(x) = {x(e1), x(e2), . . . , x(em)} such that x(ei) ≥ x(ej) for 1 ≤ i < j ≤ m. Then, to check
i=1 x(ei) ≤ g(k) for each k = 1, . . . , m as the

submodular function f is cardinality-based.

(iii) We next claim that for each of the Euclidean and entropy mirror maps, the ordering of the elements
remains the same in subsequent iterations, i.e., at the end of each iteration i, the ordering S(x(i)) =
S(x(i−1)) up to equal elements.

(A) For the Euclidean mirror map, with x(0) = 0: We ﬁrst claim that S(y) = S(x(0)) up to equal
elements; this holds since x(0) = 0. Next, for each iteration i we claim that S(x(i−1)) =
S(x(i−1) + λz) up to equal elements for λ > 0. For the Euclidean mirror map, z = χ(M )
for M = arg mine∈Ni−1(x(i−1)(e) − y(e)) (or for some intermediate iterate in the inner loop).
Let D = {e ∈ Ni−1 : x(i−1)(e) > 0}. Note that D ⊆ M using claim (e) of the proof for Theorem

3. A submodular function is cardinality-based if f (S) = g(|S|) for all S ⊆ E and some concave g : N → R.

14

3. As all elements of D are increased by the same amount λ, while being bound by the value of
minimum element in T (x), their ordering remains the same as S(x(i−1)) after the increase. Fur-
ther the zero-elements in M, i.e., M \ D have the highest value of y(e) among zero-elements of
x(i−1). Therefore, increasing these uniformly respects the ordering with respect to S(y), while
being less than the value of elements in D.

(B) For the entropy mirror map, with x(0) = y ∈ P (f ):

For each iteration i, we claim that S(x(i−1)) = S(x(i−1) + λz) up to equal elements, for some
λ > 0. For the entropy mirror map, the direction z is given by z(e) = x(i)(e) for e ∈ Ni−1 =
E\T (x) (see claim (g(cid:48)) in the proof for Theorem 3) and z(e) = 0 for e ∈ T (x). Since we increase
x(i−1) proportionally to x(i−1)(e) on all elements in Ni−1, while being bound by the value of the
minimum element in T (x), the ordering of the elements S(x(i−1) + λz) is the same as S(x(i−1))
(up to equal elements).

(iv) Since the ordering of the elements remains the same after an increase, we get an easy way to solve the
problem LINE. For each k = |T (x)| + 1, . . . ,|E|, we can compute the maximum possible increase
. Then λ∗ =

possible without violating a set of cardinality k which is given by tk = g(k)−(cid:80)k
mink tk and this can be checked in O(|E|) time.

i=1 xi
i=|T (x)| z(i)

(cid:80)k

Hence, we require a single sort at the beginning of the INC-FIX algorithm (O(|E| ln|E|) time), and using
this ordering (that does not change in subsequent iterations) we can perform LINE in O(|E|) time. Therefore,
the running time of INC-FIX for cardinality-based submodular functions is O(|E|2).

1

− η∇l(t−1)

1

1

e−η∇l(t−1)

1

m e−η∇l(t−1)

; . . . ; x(t−1)
m − η∇l(t−1)

; . . . ; x(t−1)

Computing Nash-equilibria Let us now consider the MSP game over strategy polytopes P and Q under
a bilinear loss function, such that P is the base polytope of a matroid (and Q is any polytope that one can
optimize linear functions over). The online mirror descent algorithm starts with x(0) being the ω−center
of the base polytope, that is simply obtained by projecting a vector of ones on the base polytope. Each
subsequent iteration x(t) is obtained by projecting an appropriate point y(t) under the Bregman projection of
the mirror map. For the entropy map, y(t) = [x(t−1)
m ], and for the Euclidean
map y(t) is simply given by y(t) = [x(t−1)
m ]. Here, ∇l(t) = Lv(t) where
v(t) = arg maxz∈Q x(t)T Lz. Note that for the entropy map, each y(t) (that we project) is guaranteed to be
strictly greater than zero since x(0) > 0. Assuming the loss functions are G-Lipschitz under the appropriate
norm (i.e., L1-norm for the entropy mirror map, and L2-norm for the Euclidean mirror map), after T =
O(G2R2/2) iterations of the mirror descent algorithm, we obtain a −approximate Nash-equilibrium of
i=1 v(i)/T ). For the entropy map, R2 ≤ r(E) ln(m) and for the
Euclidean mirror map, R2 ≤ r(E). Using the Euclidean mirror map (as opposed to the entropy map) even
though we reduce the R2 term in the number of iterations, the Lipschitz constant might be greater with respect
to the L2-norm (as opposed to the L1-norm). For example, suppose in a spanning tree game the loss matrix L
is scaled such that ||L||∞ ≤ 1. Then, the loss functions are such that Gentropy = ||∇l(i)||∞ = ||Lv(i)||∞ ≤ n
√
and GEuc = ||∇li||2 = ||Lv(i)||2 ≤ n
m and so, the online mirror descent algorithm converges to an -
approximate strategy in O(R2G2/2) = O(n2 r(E) ln m/2) = O(n3 ln m/2) rounds (of learning) under
the entropy mirror map4, whereas it takes O(n3m/2) rounds under the Euclidean map.

the MSP game given by ((cid:80)T

i=1 x(i)/T,(cid:80)T

4. Even though this case is identical to the multiplicative weights update algorithm, the general analysis for the mirror descent

algorithms gives a better convergence rate with respect to the size of the graph n, m (but the same dependence on ).

15

5. The Multiplicative Weights Update Algorithm
We now restrict our attention to MSP games over 0/1 strategy polytopes P and Q such that U = vert(P ) ⊆
{0, 1}m and V = vert(Q) ⊆ {0, 1}n. The vertices of these polytopes constitute the pure strategies of these
games (i.e., combinatorial concepts like spanning trees, matchings, k-sets). We review the Multiplicative
Weights Update (MWU) algorithm for MSP games over strategy polytopes P and Q. The MWU algorithm
starts with the uniform distribution over all the vertices, and simulates an iterative procedure where the learner
(say player 1) plays a mixed strategy x(t) in each round t. In response the ORACLE selects the most adversarial
loss vector for the learner, i.e., l(t) = Lv(t) where v(t) = arg maxy∈Q x(t)Ly. The learner observes losses for
all the pure strategies and incurs loss equal to the expected loss of their mixed strategy. Finally the learner
updates their mixed strategy by lowering the weight of each pure strategy u by a factor of βuT l(t)/F for a ﬁxed
constant 0 < β < 1 and a factor F that accounts for the magnitude of the losses in each round. That is, for
each round t ≥ 1, the updates in the MWU algorithm are as follows, starting with w(1)(u) = 1 for all u ∈ U:

x(t) =

u∈U w(t)(u)u
u∈U w(t)(u)

, v(t) = arg max
y∈Q

x(t)T Ly, w(t+1)(u)

= w(t)(u)βuT Lv(t)/F ∀u ∈ U.

Standard analysis of the MWU algorithm shows that an −approximate Nash-equilibrium can be obtained in
O(( ln |U|
(/F )2 ) rounds in the case of MSP games (see for e.g. Arora et al. (2012)).
Note that in many interesting cases of MSP games, the input of the game is O(ln|U|). Even though the
MWU algorithm converges in O(ln|U|) rounds it requires O(|U|) updates per round. We will show in the
following sections how this algorithm can be simulated in polynomial time (i.e., polynomial in the input of
the game).

(cid:80)
(cid:80)

that p(u) ∝ (cid:81)

5.1. MWU in Polynomial Time
We show how to simulate the MWU algorithm in time polynomial in ln|U| where U is the vertex set of the
0/1 polytope P ⊂ Rm, by the use of product distributions. A product distribution p over the set U is such
e∈u λe for some vector λ ∈ Rm. We refer to the λ vector as the multiplier vector of the
product distribution. The two key observations here are that product distributions can be updated efﬁciently
by updating only the multipliers (for bilinear losses), and multiplicative updates on a product distribution
results in a product distribution again.
To argue that the MWU can work by updating only product distributions, suppose ﬁrst that in some
iteration t of the MWU algorithm, we are given a product distribution p(t) over the vertex set U implicitly by
its multiplier vector λ(t), and a loss vector l(t) ∈ Rm such that the loss of each vertex u is uT l(t). In order to
multiplicatively update the probability of each vertex u as p(t+1)(u) ∝ p(t)(u)βuT l(t), note that we can simply
update the multipliers with the loss of each component.

p(t+1)(u) ∝ p(t)(u)βuT l(t) ∝

λ(t)(e)

as u ∈ {0, 1}m.

(cid:32)(cid:89)

e∈u

(cid:33)

βuT l(t) ∝(cid:89)

(cid:16)

λ(t)(e)βl(t)(e)(cid:17)

e∈u

Hence, the resulting probability distribution p(t+1) is also a product distribution, and we can implicitly
represent it in the form of the multipliers λ(t+1)(e) = λ(t)(e)βl(t)(e)(e ∈ [m]) in the next round of the MWU
algorithm.

Suppose we have a generalized counting oracle M which, given λ ∈ Rm

+ , computes(cid:80)

u∈U(cid:81)

and also, for any element f, computes(cid:80)

u∈U :uf =1

e:ue=1 λ(e)
e:ue=1 λ(e). Such an oracle can be used to compute

(cid:81)

16

the marginals x ∈ P corresponding to the product distribution associated with λ. Suppose we have also
an adversary oracle R that computes the worst-case response of the adversary given a marginal point in
the learner’s strategy polytope, i.e., R(x) = arg maxv∈V xT Lv (the losses depend only on marginals of
the learner’s strategy and not the exact probability distribution). Then, we can exactly simulate the MWU
algorithm. We can initialize the multipliers to be λ(1)(e) = 1 for all e ∈ [m], thus effectively starting with
uniform weights w(1) across all the vertices of the polytope. Given the multipliers λ(t) for each round, we
can compute the corresponding marginal point x(t) = M(λ(t)) and the corresponding loss vector Lv(t) where
v(t) = R(x(t)). Finally, we can update the multipliers with the loss in each component, as discussed above.
It is easy to see that the standard proofs of convergence of the MWU go through, as we only change the way
of updating probability distributions, and we obtain the statement of Theorem 7. We assume here that the loss
matrix L ≥ 05. The proof is included in Appendix B.
Theorem 7 Consider an MSP game with strategy polytopes P , Q and loss(x, y) = xT Ly for x ∈ P, y ∈ Q,
as deﬁned above. Let F = maxx∈P,y∈Q xT Ly and U = vert(P ). Given two polynomial oracles M and R
where M(λ) = x is the marginal point corresponding to multipliers λ, and R(x) = arg maxy∈Q xT Ly, the al-
gorithm MWU with product updates gives an O()−approximate Nash equilibrium (¯x, ¯y) = ( 1
in O( ln(|U|)

(/F )2 ) rounds and time polynomial in (n, m).

i=1 x(i), 1
t

(cid:80)t

t

(cid:80)t

i=1 v(i))

Having shown that the updates to the weights of each pure strategy can be done efﬁciently, the regret
bound follows from known proofs for convergence of the multiplicative weights update algorithm. We would
like to draw attention to the fact that, by the use of product distributions, we are not restricting the search of
approximate equilibria. This follows from the analysis, and also from the fact that any point in the relative
interior of a 0/1 polytope can be viewed as a (max-entropy) product distribution over the vertices of the
polytope (Asadpour et al. (2010), Singh and Vishnoi (2014)).
Approximate Computation.
If we have an approximate generalized counting oracle, we would have an
approximate marginal oracle M1 that computes an estimate of the marginals, i.e. M1(λ) = ˜x such that
||M (λ)− ˜x||∞ ≤ 1 where M (λ) is the true marginal point corresponding to λ, and an approximate adversary
oracle R2 that computes an estimate of the worst-case response of the adversary given a marginal point in the
learner’s strategy polytope, i.e. R2(x) = ˜v such that xT L˜v ≥ maxv∈V xT Lv − 2 (for example, in the case
when the strategy polytope is not in P and only an FPTAS is available for optimizing linear functions). We

Algorithm 2 The MWU algorithm with approximate oracles
Input: M1: Rm → Rm, R2: Rm → Rn,  > 0.
Output: O( + F 1 + 2)-approximate Nash equilibrium (¯x, ¯y)
λ(1) = 1, t = 1, F = maxx∈P,y∈Q xT Ly, (cid:48) = /F, β = 1
√

2(cid:48) repeat

1+

˜x(t) = M1(λ(t)) ˜v(t) = R2(˜x(t)) λ(t+1)(e) = λ(t)(e) ∗ βL˜v(t)(e)/F ∀e ∈ E t ← t + 1

until t < F 2 ln |U|
2
(¯x, ¯y) = ( 1
t−1

(cid:80)t−1

;
i=1 ˜x(i), 1
t−1

(cid:80)t−1

i=1 ˜v(i))

give a complete description of the algorithm in Algorithm 2 and the formal statement of the regret bound in
the following lemma (for loss matrices L ≥ 05) (proved in Appendix B). The tricky part in the proof is that
since the loss vectors are approximately computed from approximate marginal points, there is a possibility of

5. This is however an artiﬁcial condition, and the regret bounds change accordingly for general losses.

17

t

2

not converging at all. However, we show that this is not the case since we maintain the true multipliers λ(t) in
each round. It is not clear if there would be convergence, for example, had we gone back and forth between
the marginal point and the product distribution.
Lemma 8 Given two polynomial approximate oracles M1 and R2 where M1(λ) = ˜x s.t. ||M (λ)− ˜x||∞ ≤
1, and R2(x) = ˜v s.t. xT L˜v ≥ maxy∈Q xT Ly − 2, the algorithm MWU with product updates gives an
O( + F 1 + 2)−approximate Nash equilibrium (¯x, ¯y) = ( 1
) rounds
and time polynomial in (n, m).

(cid:80)t
i=1 ˜v(i)) in O( F 2 ln(|U|)

i=1 ˜x(i), 1
t

(cid:80)t

T

(cid:81)

from Kirchoff’s matrix theorem (Lyons and Peres (2005)) that states that the value of(cid:80)

Applications: For learning over the spanning tree polytope, an exact generalized counting algorithm follows
e∈T λe is equal to
the value of the determinant of any cofactor of the weighted Laplacian of the graph. One can use fast Laplacian
solvers (see for e.g., Koutis et al. (2010)) for obtaining a fast approximate marginal oracle. Kirchhoff’s
determinantal formula also extends to (exact) counting of bases of regular matroids. For learning over the
bipartite matching polytope (i.e., rankings), one can use the randomized generalized approximate counting
oracle from (Jerrum et al. (2004)) for computing permanents to obtain a feasible marginal oracle. Note that
the problem of counting the number of perfect matchings in a bipartite graph is #P-complete as it is equivalent
to computing the permanent of a 0/1 matrix (Valiant (1979)). The problem of approximately counting the
number of perfect matchings in a general graph is however a long standing open problem, if solved, it would
result in another way of solving MSP games on the matching polytope. Another example of a polytope that
admits a polynomial approximate counting oracle is the cycle cover polytope (or 0 − 1 circulations) over
directed graphs (Singh and Vishnoi (2014)). Also, we would like to note that to compute Nash-equilibria
for MSP games that admit marginal oracles for both the polytopes, the optimistic mirror descent algorithm
is simply the exponential weights with a modiﬁed loss vector (Rakhlin and Sridharan (2013)), and hence the
same framework applies.
Sampling pure strategies:
In online learning scenarios that require the learner to play a combinatorial
concept (i.e., a pure strategy in each round), we note ﬁrst that given any mixed strategy (that lies in a strategy
polytope ∈ Rn), the learner can obtain a convex decomposition of the mixed strategy into at most n + 1
vertices by using the well-known Caratheodory’s Theorem. The learner can then play a pure strategy sampled
proportional to the convex coefﬁcients in the decomposition. In the case of learning over the spanning tree and
bipartite perfect matching polytopes using product distributions however, there exists a more efﬁcient way of
sampling due to the self-reducibility6 of the these polytopes (Kulkarni (1990), Asadpour et al. (2010)): Order
the edges of the graph randomly and decide for each probabilistically whether to use it in the ﬁnal object
or not. The probabilities of each edge are updated after every iteration conditioned on the decisions (i.e., to
include or not) made on the earlier edges. This sampling procedure works as long as there exists a polynomial
time marginal oracle (i.e., a generalized counting oracle) to update the probabilities of the elements of the
ground set after each iteration and if the polytope is self-reducible (Sinclair and Jerrum (1989)). Intuitively,
self-reducibility means that there exists an inductive construction of the combinatorial object from a smaller
instance of the same problem. For example, conditioned on whether an edge is taken or not, the problem of
ﬁnding a spanning tree (or a matching) on a given graph reduces to the problem of ﬁnding a spanning tree (or
a matching) in a modiﬁed graph.

6. Intuitively, self-reducibility means that there exists an inductive construction of the combinatorial object from a smaller instance
of the same problem. For example, conditioned on whether an edge is taken or not, the problem of ﬁnding a spanning tree (or a
matching) on a given graph reduces to the problem of ﬁnding a spanning tree (or a matching) in a modiﬁed graph.

18

6. Symmetric Nash-equilibria
In this section we explore purely combinatorial algorithms to ﬁnd Nash-equilibria, without using learning
algorithms. Symmetric Nash-equilibria are a set of optimal strategies such that both players play the exact
same mixed strategy at equilibrium. We assume here that the strategy polytopes of the two players are the
same. In this section, we give necessary and sufﬁcient conditions for a symmetric Nash-equilibrium to exist
in case of matroid MSP games. More precisely, our main result is the following:
Theorem 9 Consider an MSP game with respect to a matroid M = (E,I) with an associated rank function
r : E → R+. Let L be the loss matrix for the row player such that it is symmetric, i.e. LT = L. Let
x ∈ B(M ) = {x ∈ RE : x(S) ≤ r(S) ∀ S ⊂ E, x(E) = r(E), x ≥ 0}. Suppose x partitions the elements
of the ground set into {P1, P2, . . . Pk} such that (Lx)(e) = ci ∀e ∈ Pi and c1 < c2 . . . < ck. Then, the
following are equivalent.

(i). (x, x) is a symmetric Nash-equilibrium,

(ii). All bases of matroid M have the same cost with respect to weights Lx,
(iii). For all bases B of M, |B ∩ Pi| = r(Pi),
(iv). x(Pi) = r(Pi) for all i ∈ {1, . . . , k},
(v). For all circuits C of M, ∃i : C ⊆ Pi.
Proof Case (i) ⇔ (ii). Assume ﬁrst that (x, x) is a symmetric Nash-equilibrium. Then, the value of the game
(1)
is maxz∈B(M ) xT Lz = minz∈B(M ) zT Lx = minz∈B(M ) xT LT z
= minz∈B(M ) xT Lz, where (1) follows
from LT = L. This implies that every base of the matroid has the same cost under the weights Lx.
Coversely, if every base has the same cost with respect to weights Lx, then x ∈ arg maxy∈B(M ) xT Ly and
x ∈ arg miny∈B(M ) xT Ly. Since no player has an incentive to deviate, this implies that (x, x) is a Nash-
equilibrium.
Case (ii) ⇔ (iii). Assume (ii) holds. Suppose there exists a base B such that |B ∩ Pi| < r(Pi) for some
i. We know that there exists a base BT such that |BT ∩ Pi| = r(Pi). Since B ∩ Pi, BT ∩ Pi ∈ I and
|BT ∩ Pi| > |B ∩ Pi|, ∃e ∈ (BT \ B) ∩ Pi such that (B ∩ Pi) + e ∈ I. Since (B ∩ Pi) + e ∈ I and B is a
base, ∃f ∈ B \ Pi such that B + e − f ∈ I. This gives a base of a different cost as e and f are in different
members of the partition. Hence, we reach a contradiction. Thus, (ii) implies (iii).
i=1 ci|Pi ∩ B|. Thus, (iii) implies

Conversely, assume (iii) holds. Note that the cost of a base B is c(B) =(cid:80)k
that every base has the same cost(cid:80)k
matroid, i.e. x =(cid:80)
B λB|B ∩ Pi| =(cid:80)
plies that x(Pi) =(cid:80)
Conversely assume (iv) and consider any base B of the matroid. Then, r(E) = |B| =(cid:80)k
= (cid:80)k

Case (iii) ⇔ (iv). Assume (iii) holds. Since x ∈ B(M ), x is a convex combination of the bases of the
B lBχ(B) where χ(B) denotes the characteristic vector for the base B. Thus, (iii) im-

i=1 x(Pi) = x(E) = r(E), where (1) follows from rank inequality and (2) follows from (iv) for each

Pi. Thus, equality holds in (1) and we get that for each base B, |B ∩ Pi| = r(Pi).
Case (iii) ⇔ (v). Assume (iii) and let C be a circuit. Let e ∈ C and B be a base that contains C − e.

i=1 cir(Pi).

(2)

B λBr(Pi) = r(Pi) for all i ∈ {1, . . . , k}.

i=1 |B∩Pi|≤(1)(cid:80)k

i=1 r(Pi)

19

Hence, the unique circuit in B + e is C. Thus, for any element f ∈ C − e, B − e + f ∈ I. Hence, (iii) implies
that all the elements of C − e must lie in the same member of the partition as e does. Hence, ∃i : C ⊆ Pi.
Conversely, assume (v). Consider any two bases B and BT such that B \ BT = {e} and BT − B = {f} for
some e, f ∈ E. Let C be the unique circuit in BT + e and hence f ∈ C. It follows from (v) that e, f are in
the same member of the partition, and hence |B ∩ Pi| = |BT ∩ Pi| for all i ∈ {1, . . . , k}. Since we know
there exists a base Bi such that |Bi ∩ Pi| = r(Pi) for each i, hence all bases must have the same intersection
with each Pi and (iii) follows.

Corollary 10 Consider a game where each player plays a base of the graphic matroid M (G) on a graph
G, and the loss matrix of the row player is the identity matrix I ∈ RE×E. Then there exists a symmetric
Nash-equilibrium if and only if every block of G is uniformly dense.
Proof Since the loss matrix is the identity matrix, x(e) = ci for all e ∈ Pi. Theorem 9 (v) implies that each
Pi is a union of blocks of the graph. Further, as x(Pi) = r(Pi) = ci|Pi|, each Pi (and hence each block
contained in Pi) is uniformly dense.

, x > 0 in the base polytope of a matroid M = (E,I), one can

Corollary 11 Given any point x ∈ RE
construct a matroid game for which (x, x) is the symmetric Nash equilibrium.
Proof Let the loss matrix L be deﬁned as Le,e = 1/xe for e ∈ E and 0 otherwise. Then, Lx(e) = 1 for all
e ∈ E. Thus, all the bases have the same cost under Lx. It follows from Theorem 9 that (x, x) is a symmetric
Nash equilibrium of this game.

Uniqueness: Consider a symmetric loss matrix L such that Le,f = 1 for all e, f ∈ E. Note that any feasible
point in the base polytope B(M ) forms a symmetric Nash equilibrium. Hence, we need a stronger condition
for the symmetric Nash equilibria to be unique. We note that for positive and negative-deﬁnite loss matrices,
symmetric Nash-equilibria are unique, if they exist (proof in the Appendix).
Theorem 12 Consider the game with respect to a matroid M = (E,I) with an associated rank function
r : E → R+. Let L be the loss matrix for the row player such that it is positive-deﬁnite, i.e. xT Lx > 0 for all
x (cid:54)= 0. Then, if there exists a symmetric Nash equilibrium of the game, it is unique.
Proof Suppose (x, x) and (y, y) are two symmetric Nash equilibria such that x (cid:54)= y, then the value of the
game is xT Lx = yT Ly. Then, xT Lz ≤ xT Lx ≤ zT Lx ∀z ∈ B(M ) implying that xT Lz ≤ xT Lx ≤ xT LT z
∀z ∈ B(M ). Since L is symmetric, we get xT Lx = xT Lz ∀z ∈ B(M ). Similarly, we get yT Ly = yT Lz
∀z ∈ B(M ). Consider z = x+y
T Ly. This con-
tradicts the strict convexity of the quadratic form of xT Lx. Hence, x = y and there exists a unique symmetric
Nash equilibrium.

2 . Then, zT Lz = (x+y)

T Lz + y
2

T Lz = x
2

T Lx + y
2

T

Lz = x
2

2

Lexicographic optimality: We further note that symmetric Nash-equilibria are closely related to the concept
of being lexicographically optimal as studied in Fujishige (1980). For a matroid M = (E,I), x ∈ B(M )
is called lexicographically optimal with respect to a positive weight vector w if the |E|-tuple of numbers
x(e)/w(e) (e ∈ E) arranged in the order of increasing magnitude is lexicographically maximum among all

20

|E|-tuples of numbers y(e)/w(e) (e ∈ E) arranged in the same manner for all y ∈ B(M ). We evoke the
following theorem from Fujishige (1980).
Theorem 13 Let x ∈ B(M ) and w be a positive weight vector. Deﬁne c(e) = x(e)/w(e) (e ∈ E) and let
the distinct numbers of c(e) (e ∈ E) be given by c1 < c2 < . . . < cp. Futhermore, deﬁne Si ⊆ E (i =
1, 2, . . . , p) by

Si = {e|e ∈ E, c(e) ≤ ci} (i = 1, 2, . . . , p).

Then the following are equivalent:

(i) x is the unique lexicographically optimal point in B(M ) with respect to the weight vector w;

(ii) x(Si) = r(Si) (i = 1, 2, . . . , p).

The following corollary gives an algorithm for computing symmetric Nash-equilibria for matroid MSP

games.
Corollary 14 Consider a matroid game with a diagonal loss matrix L such that Le,e > 0 for all e ∈ E. If
there exists a symmetric Nash-equilibrium for this game, then it is the unique lexicographically optimal point
in B(M ) with respect to the weights 1/Le,e (e ∈ E).

The proof follows from observing the partition of edges with respect to the weight vector Lx, and proving
that symmetric Nash-equilibria satisfy the sufﬁcient conditions for being a lexicographically optimal base.
Lexicographically optimal bases can be computed efﬁciently using Fujishige (1980), Nagano (2007a), or the
INC-FIX algorithm from Section 4. Hence, one could compute the lexicographically optimal base x for a
weight vector deﬁned as w(e) = 1/Le,e (e ∈ E) for a positive diagonal loss matrix L, and check if that is
a symmetric Nash-equilibrium. If it is, then it is also the unique symmetric Nash-equilibrium and if it is not
then there cannot be any other symmetric Nash-equilibrium.

References
N. Ailon.

Improved Bounds for Online Learning Over the Permutahedron and Other Ranking Polytopes.
Proceedings of the Seventeenth International Conference on Artiﬁcial Intelligence and Statistics, 33, 2014.

I. Alth¨ofer. On sparse approximations to randomized strategies and convex combinations. Linear Algebra

and its Applications, 199(1994):339–355, 1994. ISSN 00243795. doi: 10.1016/0024-3795(94)90357-3.

S. Arora, E. Hazan, and S. Kale. The Multiplicative Weights Update Method: a Meta-Algorithm and Appli-

cations. Theory of Computing, 8:121–164, 2012. doi: 10.4086/toc.2012.v008a006.

A. Asadpour, M. X. Goemans, A. Madry, S. Oveis Gharan, and A. Saberi. An O (log n/log log n)-

approximation Algorithm for the Asymmetric Traveling Salesman Problem. SODA, 2010.

J. Audibert, S. Bubeck, and G. Lugosi. Regret in online combinatorial optimization. Mathematics of Opera-

tions Research, 39(1):31–45, 2013.

Y. Azar, A. Z. Broder, and A. M. Frieze. On the problem of approximating the number of bases of a matriod.

Information processing letters, 50(1):9–11, 1994.

21

A. Beck and M. Teboulle. Mirror descent and nonlinear projected subgradient methods for convex optimiza-

tion. Operations Research Letters, 31(3):167–175, 2003.

A. Ben-Tal and A. Nemirovski. Lectures on modern convex optimization: analysis, algorithms, and engineer-

ing applications, volume 2. SIAM, 2001.

A. Blum, M. T. Hajiaghayi, K. Ligett, and A. Roth. Regret minimization and the price of total anarchy.

Proceedings of the fortieth annual ACM symposium on Theory of computing, pages 1–20, 2008.

S. Bubeck. Introduction to online optimization. Lecture Notes, pages 1–86, 2011.

S. Bubeck. Theory of Convex Optimization for Machine Learning. arXiv preprint arXiv:1405.4980, 2014.

N. Cesa-Bianchi and G. Lugosi. Prediction, learning, and games. Cambridge university press, 2006.

D. Chakrabarty, A. Mehta, and V. V. Vazirani. Design is as easy as optimization. In Automata, Languages

and Programming, pages 477–488. Springer, 2006.

Xi Chen, Xiaotie Deng, and Shang-Hua Teng. Settling the complexity of computing two-player Nash equi-

libria. FOCS, page 53, April 2009.

A. Cohen and T. Hazan. Following the perturbed leader for online structured learning. In Proceedings of the

32nd International Conference on Machine Learning (ICML-15), pages 1034–1042, 2015.

W. H. Cunningham. Minimum cuts, modular functions, and matroid polyhedra. Networks, 15(2):205–215,

1985.

C. Daskalakis, P. W. Goldberg, and C. H. Papadimitriou. The complexity of computing a Nash equilibrium.

SIAM Journal on Computing, 2009.

J. Edmonds. Submodular functions, matroids, and certain polyhedra. Combinatorial structures and their

applications, pages 69–87, 1970.

J. Edmonds. Matroids and the greedy algorithm. Mathematical programming, 1(1):127–136, 1971.

T. Feder, H. Nazerzadeh, and A. Saberi. Approximating Nash equilibria using small-support strategies. Elec-

tronic Commerce, pages 352–354, 2007.

Y. Freund and R. E. Schapire. Adaptive game playing using multiplicative weights. Games and Economic

Behavior, 29(1–2):79–103, 1999.

S. Fujishige. Lexicographically optimal base of a polymatroid with respect to a weight vector. Mathematics

of Operations Research, 1980.

S. Fujishige. Submodular functions and optimization, volume 58. Elsevier, 2005.

H. Groenevelt. Two algorithms for maximizing a separable concave function over a polymatroid feasible

region. European journal of operational research, 54(2):227–236, 1991.

M. Gr¨otschel, L. Lov´asz, and A. Schrijver. The ellipsoid method and its consequences in combinatorial

optimization. Combinatorica, 1(2):169–197, 1981.

22

E. Hazan and T. Koren. The computational power of optimization in online learning. arXiv preprint

arXiv:1504.02089, 2015.

D. P. Helmbold and R. E. Schapire. Predicting nearly as well as the best pruning of a decision tree. Machine

Learning, 27(1):51–68, 1997.

D. P. Helmbold and M. K. Warmuth. Learning permutations with exponential weights. The Journal of

Machine Learning Research, 10:1705–1736, 2009.

N. Immorlica, A. T. Kalai, B. Lucier, A. Moitra, A. Postlewaite, and M. Tennenholtz. Dueling algorithms.
In Proceedings of the forty-third annual ACM Symposium on Theory of Computing, pages 215–224. ACM,
2011.

M. Jerrum, A. Sinclair, and E. Vigoda. A polynomial-time approximation algorithm for the permanent of a
matrix with nonnegative entries. ACM Symposium of Theory of Computing, 51(4):671–697, 2004. ISSN
00045411. doi: 10.1145/1008731.1008738.

M. R. Jerrum, L. G. Valiant, and V. V. Vazirani. Random generation of combinatorial structures from a

uniform distribution. Theoretical Computer Science, 43:169–188, 1986.

A. Kalai and S. Vempala. Efﬁcient algorithms for online decision problems. Journal of Computer and System

Sciences, 71(3):291–307, October 2005. ISSN 00220000. doi: 10.1016/j.jcss.2004.10.016.

T. Koo, A. Globerson, X. C. P´erez, and M. Collins. Structured prediction models via the matrix-tree theorem.
In Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural
Language Learning (EMNLP-CoNLL), pages 141–150, 2007.

W. M. Koolen and T. Van Erven. Second-order quantile methods for experts and combinatorial games. In

Proceedings of The 28th Conference on Learning Theory, pages 1155–1175, 2015.

W. M. Koolen, M. K. Warmuth, and J. Kivinen. Hedging Structured Concepts. COLT, 2010.

I. Koutis, G. L. Miller, and R. Peng. Approaching optimality for solving SDD linear systems. Proceedings
ISSN

- Annual IEEE Symposium on Foundations of Computer Science, FOCS, pages 235–244, 2010.
02725428. doi: 10.1109/FOCS.2010.29.

V. G. Kulkarni. Generating random combinatorial objects. Journal of Algorithms, 11(2):185–207, 1990.

R. J. Lipton and N. E. Young. Simple strategies for large zero-sum games with applications to complexity
theory. Proceedings of the twenty-sixth annual ACM symposium on Theory of computing., pages 734–740,
1994.

R. J. Lipton, E. Markakis, and A. Mehta. Playing large games using simple strategies. Proceedings of the 4th

ACM conference on Electronic commerce, pages 36–41, 2003.

N. Littlestone and M. K. Warmuth. The weighted majority algorithm. Information and computation, 1994.

L. Lov´asz, M. Gr¨otschel, and A. Schrijver. Geometric algorithms and combinatorial optimization. Berlin:

Springer-Verlag, 33:34, 1988.

R. Lyons and Y. Peres. Probability on trees and networks. 2005.

23

R. K. Martin. Using separation algorithms to generate mixed integer model reformulations. Operations

Research Letters, 10(April):119–128, 1991. ISSN 01676377. doi: 10.1016/0167-6377(91)90028-N.

K. Nagano. On convex minimization over base polytopes. Integer Programming and Combinatorial Opti-

mization, pages 252–266, 2007a.

K. Nagano. A strongly polynomial algorithm for line search in submodular polyhedra. Discrete Optimization,

4(3):349–359, 2007b.

K. Nagano. A faster parametric submodular function minimization algorithm and applications. 2007c.

A. Nemirovski. Prox-method with rate of convergence o (1/t) for variational inequalities with lipschitz con-
tinuous monotone operators and smooth convex-concave saddle point problems. SIAM Journal on Opti-
mization, 15(1):229–251, 2004.

A. S. Nemirovski and D. B. Yudin. Problem complexity and method efﬁciency in optimization. Wiley-

Interscience, New York, 1983.

G. Neu and G. Bart´ok. Importance weighting without importance weights: An efﬁcient algorithm for combi-

natorial semi-bandits. Journal of Machine Learning Research, 2015.

J. B. Orlin. Max ﬂows in o(nm) time, or better. In Proceedings of the forty-ﬁfth annual ACM Symposium on

Theory of Computing, pages 765–774. ACM, 2013.

C. H. Papadimitriou and T. Roughgarden. Computing correlated equilibria in multi-player games. Journal of

the ACM (JACM), 55(3):14, 2008.

A. Rakhlin and K. Sridharan. Optimization, learning, and games with predictable sequences. In Advances in

Neural Information Processing Systems, pages 3066–3074, 2013.

A. Rakhlin and K. Sridharan. Lecture Notes on Online Learning. Draft, 2014.

T. Rothvoß. The matching polytope has exponential extension complexity. ACM Symposium of Theory of

Computing, pages 1–19, 2014. ISSN 07378017. doi: 10.1145/2591796.2591834.

C. Schnorr. Optimal algorithms for self-reducible problems. In ICALP, volume 76, pages 322–337, 1976.

A. Schrijver. Combinatorial optimization: polyhedra and efﬁciency, volume 24. Springer Science & Business

Media, 2003.

A. Sinclair and M. Jerrum. Approximate counting, uniform generation and rapidly mixing markov chains.

Information and Computation, 82(1):93–133, 1989.

M. Singh and N. K. Vishnoi. Entropy, optimization and counting. In Proceedings of the 46th Annual ACM

Symposium on Theory of Computing, pages 50–59. ACM, 2014.

N. Srebro, K. Sridharan, and A. Tewari. On the universality of online mirror descent. Advances in Neural

Information Processing Systems, 2011.

D. Suehiro, K. Hatano, and S. Kijima. Online prediction under submodular constraints. Algorithmic Learning

Theory, pages 260–274, 2012.

24

E. Takimoto and M. K. Warmuth. Path kernels and multiplicative updates. The Journal of Machine Learning

Research, 4:773–818, 2003.

L. G. Valiant. The complexity of computing the permanent. Theoretical computer science, 8(2):189–201,

1979.

J. von Neumann. Zur theorie der gesellschaftsspiele. Mathematische Annalen, 100(1):295–320, 1928.

M. K. Warmuth and D. Kuzmin. Randomized online pca algorithms with regret bounds that are logarithmic

in the dimension. Journal of Machine Learning Research, 9(10):2287–2320, 2008.

A. Washburn and K. Wood. Two person zero-sum games for network interdiction. Operations Research,

1995.

D. Welsh. Some problems on approximate counting in graphs and matroids. In Research Trends in Combina-

torial Optimization, pages 523–544. Springer, 2009.

M. Zinkevich. Online convex programming and generalized inﬁnitesimal gradient ascent. ICML, pages 421–

422, 2003.

Appendix A. Mirror Descent

Lemma 15 The unnormalized entropy map, ω(x) = (cid:80)n

i=1 xi, is 1-strongly convex with
respect to the L1-norm over any matroid base polytope B(f ) = {x ∈ RE : x(E) = r(E), x(E(S)) ≤
r(S)∀S ⊆ E, x ≥ 0}.
Proof We have
ω(x) − ω(y) − ∇ω(y)T (x − y) =

xe ln xe −(cid:88)

ye −(cid:88)

ln ye(xe − ye) (5)

i=1 xi ln xi −(cid:80)n
xe −(cid:88)
(cid:88)
(cid:88)

e∈E
|xe − ye|)2 =

ye ln ye +

e∈E

(

e∈E

e∈E

=

xe ln(xe/ye) ≥(1) 1
2

e∈E

||x − y||2
1,

1
2

(6)

where (1) follows from Pinsker’s inequality.

Appendix B. Multiplicative Weights Update Algorithm
Lemma 16 Consider an MSP game with strategy polytopes P ⊆ Rm and Q ⊆ Rn, and let the loss function
for the row player be given by loss(x, y) = xT Ly for x ∈ P, y ∈ Q. Suppose we simulate an online algorithm
A such that in each round t the row player chooses decisions from x(t) ∈ P , the column player reveals an
adversarial loss vector v(t) such that x(t)T Lv(t) ≥ maxy∈Q x(t)T Ly − δ and the row player subsequently
incurs loss x(t)T Lv(t) for round t. If the regret of the learner after T rounds goes down as f (T ), that is,

(cid:80)T

i=1 x(i), 1
T

then ( 1
T

(cid:80)T

RT (A) =

x(i)T Lv(i) − min
x∈P

xT Lv(i) ≤ f (T )

(7)

i=1 v(i)) is an O( f (T )

T + δ)-approximate Nash-equilibrium for the game.

(cid:88)
(cid:88)

e∈E

e∈E

T(cid:88)

i=1

t(cid:88)

i=1

25

(cid:80)T

(cid:80)T

Proof Let ¯x = 1
value of the game is λ∗ = minx maxy xT Ly = maxy minx xT Ly. This gives,
T

i=1 x(i) and ¯v = 1
T

i=1 v(i). By the von Neumann minimax theorem, we know that the

min

x

max

y

xT Ly = λ∗ ≤ max

¯xT Ly = max

y

x(i)Ly ≤ 1
T

T(cid:88)

i=1

1
T

T(cid:88)

i=1

x(i)T Ly

max

y

(8)

(9)

(10)

y

T(cid:88)

i=1

≤ 1
T

(

≤ min
x∈P

1
T

T(cid:88)

i=1

x(i)T Lv(i) + δ)

xT Lv(i) +

+ δ

f (T )

T

f (T )

T(cid:88)

i=1

= min
x∈P
≤ max
y∈Q

xT L

1
T

v(i) +

xT Ly +

min
x∈P

f (T )

T

+ δ = min
x∈P

T
+ δ = λ∗ +

f (T )

T

+ δ.

xT L¯v +

f (T )

T

+ δ

where the last inequality in (8) follows from the convexity maxy xT Ly in x, (9) follows from the error in
the adversarial loss vector, and (10) follows from the given regret equation (7). Thus, we get ¯xT L¯v ≤
maxy∈Q ¯xT Ly ≤ λ∗ + f (T )
approximate Nash-equilibrium for the game.

T −δ. Hence, (¯x, ¯v) is a(cid:0) 2f (T )

T +δ, and ¯xT L¯v ≥ minx∈P xT L¯v ≥ λ∗− f (T )

T +2δ(cid:1)-

w(t)(u) =(cid:81)
Let Z(t) be the normalization constant for round t, i.e., Z(t) =(cid:80)

Proof for Theorem 7.
Proof We want to show that the updates to the weights of each pure strategy u ∈ U can be done efﬁciently.
For the multipliers λ(t) in each round, let w(t)(u) be the unnormalized probability for each vertex u, i.e.,
e∈E λ(t)(e)u(e) where E is the ground set of elements such that the strategy polytope P of the
row player (learner in the MWU algorithm) lies in R|E|. Recall that the set of vertices of P is denoted by U.
u∈U w(t)(u). Thus, the probability of each
vertex u is p(t)(u) = w(t)(u)/Z(t). Let F = maxx∈P,y∈Q xT Ly. For readability, we denote the scaled loss
xT Ly/F as η(x, y); η(x, y) ∈ [0, 1].
The algorithm starts with λ(1)(e) = 1 for all e ∈ E and thus w(1)(u) = 1 for all u ∈ U. We claim that
w(t+1)(u) = w(t)(u)βuT Lv(t)/F , where v(t) is revealed to be a vector in arg maxy∈Q x(t)Ly in each round t.

w(t+1)(u) =

λ(t)(e)u(e)β(Lv(t)/F )e

. . . u ∈ {0, 1}m.

(cid:89)
= β(uT Lv(t)/F )(cid:89)

e∈E

λ(t+1)(e)u(e) =

(cid:89)

e∈E

λ(t)(e)u(e)

e∈E

= w(t)(u)βuT Lv(t)/F = w(t)(u)βη(u,v(t)).

26

standard proofs the MWU algorithm. We prove that Z(t+1) ≤ Z(1) exp(−(1 − β)(cid:80)t

Having shown that the multiplicative update can be performed efﬁciently, the rest of the proof follows as

i=1 η(x(i), v(i))).

Z(t+1) =

w(t+1)(u) =

w(t)(u)βη(u,v(t))

(cid:88)

u∈U

(cid:88)
≤(cid:88)

u∈U

u∈U

w(t)(u)(1 − (1 − β)η(u, v(t)))

= Z(t)(1 − (1 − β)η(x(t), v(t)))
≤ Z(t) exp(−(1 − β)η(x(t), v(t)))

. . . (1 − θ)x ≤ 1 − θx for x ∈ [0, 1], θ ∈ [−1, 1].

. . . (1 − θx) ≤ e−xθ ∀ x, ∀ θ.

Rolling out the above till the ﬁrst round, we get

Z(t+1) ≤ Z(1) exp(−(1 − β)

t(cid:88)

i=1

η(x(i), v(i))).

(11)

Since w(t+1)(u) ≤ Z(t+1) for all u ∈ U, using (11), we get

ln w(1)(u) + ln β

η(u, v(i)) ≤ ln Z(1) − (1 − β)

η(x(i), v(i))

t(cid:88)

η(x(i), v(i)) ≤ − ln β
(1 − β)

i=1

η(u, v(i)) +

ln Z(1) − ln w(1)(u)

1 − β

. . . β < 1

η(x(i), v(i)) ≤ 1 + β
2β
− ln x
1 − x

. . .

η(u, v(i)) +

ln Z(1) − ln w(1)(u)

1 − β

≤ 1 + x
2x

for x ∈ (0, 1]

i=1

t(cid:88)
⇒ t(cid:88)
⇒ t(cid:88)

i=1

i=1

t(cid:88)

t(cid:88)

i=1

1
t

t(cid:88)
t(cid:88)

i=1

i=1

t(cid:88)

t(cid:88)

i=1

27

Consider an arbitrary mixed strategy for the row player p such that(cid:80)

i=1

i=1

η(u, v(i)) +

η(x(i), v(i)) ≤ 1 + β
2βt

⇒ 1
t

equation for each vertex u with the p(u) and sum them up -

ln Z(1) − ln w(1)(u)

(1 − β)t

u∈U p(u)u = x, and multiply the above

η(x(i), v(i)) ≤ 1 + β
2βt

η(x, v(i)) +

ln Z1 − ln w(1)(u)

(1 − β)t

Note that Z1 = |U|, w(1)(u) = 1. Setting (cid:48) = /F , β = 1
√

t(cid:88)

√

2(cid:48)

η(x, v(i)) +

1+

2(cid:48) , t = ln |U|
(cid:48)2 = F 2 ln(|U|)
√
(cid:48)2 ln(|U|)(1 +
2(cid:48))
2(cid:48) ln(|U|)

√

2

i=1

η(x, v(i)) +

√

2(cid:48) + (cid:48)2

. . . using

i=1

t(cid:88)
t(cid:88)
t(cid:88)

i=1

i=1

1
t

⇒ 1
t

η(x(i), v(i)) ≤ 2 +
2t

η(x(i), v(i)) ≤ 1
t

t(cid:88)
t(cid:88)

i=1

i=1

⇒ 1
t

x(i)T Lv(i) ≤ 1
t

xT Lv(i) + O()

we get

t(cid:88)

i=1

(12)

η(x, v(i)) ≤ t

(13)

(14)

Thus, we get that the MWU algorithm converges to an -approximate Nash-equilibrium in O(F 2 ln(|U|)/2)

rounds.

Proof for Lemma 8.
Proof Let the multipliers in each round t be λ(t), the corresponding true and approximate marginal points in
round t be x(t) and ˜x(t) respectively, such that ||x(t)− ˜x(t)||∞ ≤ 1. Now, we can only compute approximately
adversarial loss vectors, ˜v(t) in each round such that ˜x(t)L˜v(t) ≥ maxy∈Q ˜x(t)Ly − 2.

Even though we cannot compute x(t) exactly, we do maintain the corresponding λ(t)s that correspond to
these true marginals. Let us analyze ﬁrst the multiplicative updates corresponding to approximate loss vectors
˜v(t) using product distributions (that can be done efﬁciently) over the true marginal points. Using the proof
for Theorem 7, we get the following regret bound with respect to the true marginals corresponding to (14) for
t = F 2 ln(|U|)

rounds:

2

t(cid:88)

i=1

1
t

x(i)T L˜v(i) ≤ 1
t

t(cid:88)

i=1

xT L˜v(i) + O()

(15)

We do not have the value for x(i) for i = 1, . . . , t, but only estimates ˜x(i) for i = 1, . . . , t such that
||˜x(i) − x(i)||∞ ≤ 1. Since the losses we consider are bilinear, we can bound the loss of the estimated point
in each iteration i as follows:

where e = (1, . . . , 1)T . Thus using (15), we get

|˜x(i)T L˜v(i) − x(i)T L˜v(i)| ≤ 1eL˜v(i) ≤ F 1,

˜x(i)T L˜v(i) ≤ 1
t

t(cid:88)

i=1

xT L˜v(i) + O( + F 1).

t(cid:88)

i=1

1
t

(cid:80)t

Now, considering that we played points ˜x(i) for each round i, and suffered losses ˜v(i), we have shown that the
MWU algorithm achieves O( + F 1) regret on an average. Thus, as R2 is assumed to have error 2, using
Lemma 16 we have that ( 1
t

i=1 ˜v(i)) is an O( + F 1 + 2)-approximate Nash-equilibrium.

i=1 ˜x(i), 1
t

(cid:80)t

(16)

(17)

28

