6
1
0
2

 
r
a

M
 
1

 
 
]

.

C
O
h
t
a
m

[
 
 

1
v
7
4
3
0
0

.

3
0
6
1
:
v
i
X
r
a

Using a conic bundle method to accelerate both

phases of a quadratic convex reformulation

Alain Billionnet1, Sourour Elloumi1, Am´elie Lambert2, Angelika Wiegele3

1 ENSIIE-CEDRIC, 1 square de la r´esistance FR-91025 Evry
alain.billionnet@ensiie.fr, sourour.elloumi@ensiie.fr

2 CNAM-CEDRIC, 292 Rue St Martin FR-75141 Paris Cedex 03

3 Institut f¨ur Mathematik, Alpen-Adria-Universit¨at Klagenfurt

amelie.lambert@cnam.fr

angelika.wiegele@aau.at

Abstract. We present algorithm MIQCR-CB that is an advancement of
method MIQCR (Billionnet, Elloumi and Lambert, 2012). MIQCR is a method
for solving mixed-integer quadratic programs and works in two phases:
the ﬁrst phase determines an equivalent quadratic formulation with a
convex objective function by solving a semideﬁnite problem (SDP ), and,
in the second phase, the equivalent formulation is solved by a standard
solver. As the reformulation relies on the solution of a large-scale semidef-
inite program, it is not tractable by existing semideﬁnite solvers, already
for medium sized problems. To surmount this diﬃculty, we present in
MIQCR-CB a subgradient algorithm within a Lagrangian duality frame-
work for solving (SDP ) that substantially speeds up the ﬁrst phase.
Moreover, this algorithm leads to a reformulated problem of smaller size
than the one obtained by the original MIQCR method which results in a
shorter time for solving the second phase. We present extensive compu-
tational results to show the eﬃciency of our algorithm. First, we apply
MIQCR-CB to the k-cluster problem that can be formulated by a binary
quadratic program. As an illustration of the eﬃciency of our new algo-
rithm, for instances of size 80 and of density 25%, MIQCR-CB is on average
78 times faster for Phase 1 and 24 times faster for Phase 2 than the origi-
nal MIQCR. We also compare MIQCR-CB with QCR (Billionnet, Elloumi and
Plateau, 2009) and with BiqCrunch (Krislock, Malick and Roupin, 2013)
two methods devoted to binary quadratic programming. We show that
MIQCR-CB is able to solve most of the 225 considered instances within 3
hours of cpu time. We also present experiments on two classes of gen-
eral integer instances where we compare MIQCR-CB with MIQCR, Couenne
and Cplex12.6. We demonstrate the signiﬁcant improvement over the
original MIQCR approach. Finally, we show that MIQCR-CB is able to solve
almost all of the considered instances while Couenne and Cplex12.6 are
not able to solve half out of them.

Keywords: Semideﬁnite programming, Lagrangian duality, Subgradi-
ent algorithm, Bundle method, Convex reformulation, Quadratic 0-1 pro-
gramming, k-cluster, Densest sub-graph

2

1

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

Introduction

We present an algorithm that accelerates the computation time of method MIQCR
(Mixed-Integer Quadratic Convex Reformulation) [8]. This method is an
exact solution algorithm for quadratic programs having mixed-integer variables.
This obviously includes the class of quadratic problems having pure integer vari-
ables such as (QP ):

n(cid:88)

n(cid:88)

n(cid:88)



max f (x) =

qijxixj +

i=1

j=i

i=1

s.t.

n(cid:88)

(QP )

i=1

arixi = br
0 ≤ xi ≤ ui
xi ∈ N0

cixi

1 ≤ r ≤ m
i ∈ I
i ∈ I

(1)

(2)

(3)

where I = {1, . . . , n}.
(QP ) belongs to the class of Mixed-Integer Non-Linear Programs (MINLP).
It includes the case of linear inequalities, since any problem with inequalities
can be rewritten as (QP ) by introducing non-negative slack variables. Con-
ventional approaches to solve MINLP are based on global optimization tech-
niques [3,6,21,40,48,55]. Software is available to solve this large class of problems
that includes (QP ), see for instance [5,49] . The solver Couenne [5] uses linear re-
laxations within a spatial branch-and-bound algorithm [50,51,52], together with
heuristics for ﬁnding feasible solutions. Using a branch-and-bound framework
based on convex relaxations [12], the recent implementation of Cplex12.6 [31]
also handles (QP ).

Many applications in operations research and industrial engineering involve
general integer variables in their formulation. Some of these applications can be
formulated as (QP ). Methods are available for solving particular cases of (QP ).
If the objective function is linear, we refer to Mixed-Integer Linear Programming
(MILP), which is still NP-Hard, but for which a large variety of methods are
well developed. If we assume the objective function to be convex, there also exist
fairly eﬃcient solvers [13,30].

MIQCR is an algorithm in two phases: the ﬁrst phase computes an equivalent
quadratic convex formulation of the initial problem by solving a large semidef-
inite problem, and in the second phase the reformulated problem is solved by
a standard solver. Due to its size, the solution of the semideﬁnite problem of
Phase 1 often constitutes the bottleneck of this method. However, once the
equivalent formulation is computed, solving the obtained reformulated program
is practicable, since the continuous relaxation bound of the reformulation is tight.
Hence, to handle larger instances method MIQCR needs an appropriate algorithm
to solve Phase 1, while Phase 2 can still be handled by a standard solver. Thus,
our ﬁrst contribution in this paper lies in a diﬀerent algorithm to solve Phase 1 of
MIQCR. We ﬁrst introduce a subgradient algorithm within a Lagrangian duality

Using Conic Bundle to accelerate a quadratic convex reformulation

3

framework for solving (SDP ) approximately following the procedure introduced
in [20]. Then, we parameterize our algorithm obtaining a dual heuristic for solv-
ing Phase 1 of the original MIQCR method. With this new algorithm, the time
for computing Phase 1 signiﬁcantly decreases and allows us to handle large-scale
instances. Moreover, we obtain also a speed up of Phase 2 since by construction
the equivalent formulation computed with the new algorithm is smaller than the
reformulation obtained in the original MIQCR method. Hence, we can claim that
our new algorithm MIQCR-CB is a general exact solution method for mixed-integer
(or binary) quadratic programs of large size.

To illustrate our algorithm we apply it to the k-cluster problem. This prob-
lem can be formulated by an equality constrained binary quadratic program, the
subclass of (QP ) obtained by setting all the upper bounds of the integer vari-
ables to one. The reason for choosing a binary quadratic program is to demon-
strate the impact of the new ideas compared to method QCR (Quadratic Convex
Reformulation) [11] from both theoretical and experimental point of view. Re-
call that MIQCR exploits the ideas behind QCR and widens the applicability to
the general mixed-integer case. As MIQCR, QCR is also a method in two phases,
where the computation of the equivalent formulation requires the solution of a
semideﬁnite problem. The advantage of QCR over MIQCR lies in the short time
required to compute the quadratic convex equivalent formulation (i.e. to solve
the associated semideﬁnite problem). However, for large instances, this method
is limited by the weakness of its bound. Hence, methods QCR and MIQCR do not
have the same bottleneck: QCR is limited by the time needed for solving Phase 2
due to the weakness of its bound, and MIQCR is limited by the solution time
of the huge semideﬁnite problem of Phase 1. In the experiments the solution
technique of Phase 1 of MIQCR-CB turns out to be almost as fast as Phase 1 in
QCR, while the computed bound is as tight as in MIQCR.

We compare experimentally MIQCR-CB with MIQCR and QCR. We also compare
MIQCR-CB with the recent approach of Krislock, Malick and Roupin [37] called
BiqCrunch, on 225 instances of the k-cluster problem with up to 160 variables.
Algorithm BiqCrunch is developed for solving binary quadratic programs. It
consists of the branch-and-bound framework BOB [18] using semideﬁnite pro-
gramming bounds [41]. We show that our approach is comparable with BiqCrunch
for solving instances with up to 120 variables. BiqCrunch is slightly faster on
larger instances, but, the limit of both algorithms (BiqCrunch and MIQCR-CB)
lies in instances having 140 to 160 variables.

We also draw comparisons for general integer quadratic problems. First, we
test our algorithm on Equality Integer Quadratic Problems (EIQP) and we show
that MIQCR-CB is about 3 times faster than MIQCR. We also compare MIQCR-CB
with the solvers Couenne [5] and Cplex12.6 [31] on an integer problem of
equipartition that can be seen as the extension of a classical binary combi-
natorial optimization problem to the general integer case. For the considered
instances, MIQCR-CB is able to solve 27 instances over the 40 presented while the
solvers Cplex12.6 and Couenne solve only 3 and 8 instances respectively, within
one hour of CPU time.

4

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

The paper is organized as follows. In Section 2, we describe algorithm MIQCR
and discuss its limitations. Section 3 presents our improved algorithm MIQCR-CB.
In Section 4, we state the formal deﬁnition of the k-cluster problem and we
present extensive computational results for solving it, and in Section 4.2 we
show experimentally that our algorithm is eﬃcient for the general integer case.
Section 5 draws a conclusion.

2 Recall of method MIQCR [8]

In the following we describe method MIQCR (Mixed-Integer Quadratic Convex
Reformulation) [8]. In Phase 1 of MIQCR we aim to ﬁnd an equivalent formula-
tion of (QP ) having a concave objective function. Three parameters, α, λ and
β, are obtained from the dual solution of a semideﬁnite relaxation of (QP ) that
we call (SDP ). Using these parameters, we construct an equivalent problem
(QPα,λ,β) having a concave objective function. The second phase consists of
solving (QPα,λ,β) by a standard solver. In detail this works as follows.

Phase 1: Constructing an equivalent formulation
Consider the following semideﬁnite relaxation of (QP ).

n(cid:88)

n(cid:88)

n(cid:88)



(SDP )

max f (X, x) =

qijXij +

cixi

s.t.

n(cid:88)
m(cid:88)

i=1

i=1

j=i+1

i=1

arixi = br

N(cid:88)

N(cid:88)

ariarjXij − 2aribrxi)) = − m(cid:88)

(

(

r=1

r=1

i=1

j=1

i ≤ 0

−Xii + xi ≤ 0
−Xii + 2uixi − u2
Xii − uixi ≤ 0
Xij − ujxi ≤ 0
Xij − uixj ≤ 0
−Xij + ujxi + uixj − uiuj ≤ 0
−Xij ≤ 0

(cid:18) 1 xT

(cid:19)

(cid:23) 0

x X
x ∈ Rn, X ∈ Sn

1 ≤ r ≤ m (1)

b2
r

(4)

(5)

(6)

i ∈ I
i ∈ I
i ∈ I
(7)
(i, j) ∈ I 2, i < j (8)
(i, j) ∈ I 2, i < j (9)
(i, j) ∈ I 2, i < j(10)
(i, j) ∈ I 2, i < j(11)

(12)

(13)
where Sn is the space of symmetric matrices of order n. Constraint (4) of (SDP )
is obtained by squaring and then summing up the m equations (1), and replacing
i ≥ xi which is true if xi is
each product xixj by Xij. Constraints (5) arise from x2

Using Conic Bundle to accelerate a quadratic convex reformulation

5

a general integer variable, and Constraints (6)-(11) are the so-called McCormick
inequalities that tighten the formulation [44]. (SDP ) is known as the ”SDP +
RLT” semideﬁnite relaxation [1].

Let (α, λ, β) be a dual optimal solution of (SDP ) where:
– α ∈ R is the dual variable associated with Constraint (4),
– λi ∈ R with λi = −λ1
i , λ2
– βij ∈ R with βij = β1

i , are the non-
negative dual variables associated with Constraints (5),(6),(7), respectively,
ij for any (i, j) with 1 ≤ i < j ≤ n,
ij, are the non-negative dual variables associated with

i for any i ∈ I, where λ1

i + λ3
ij − β3

ij − β4

where β1
Constraints (8), (9), (10), (11), respectively.

ij, β4

ij, β3

ij β2

i − λ2

ij + β2

i , λ3

We introduce the following reformulated function:

fα,λ,β(x, y) =

f (x) + α

m(cid:88)

N(cid:88)

arixi − b)2 +

(

r=1

i=1

n(cid:88)

i=1:λi(cid:54)=0

λi(yii − x2

i ) +

n(cid:88)

i=1

n(cid:88)

(14)
βij(yij − xixj)

j=i+1:βij(cid:54)=0

It is clear that fα,λ,β(x, y) = f (x) if (x, y) satisﬁes Constraints (1), and yij =
xixj for any (i, j) ∈ I 2. We use the linearization of the equality yij = xixj
introduced in [8] and deﬁne the set Sxyzt containing the quadruplets (x, y, z, t)
satisfying the following conditions:

xi =

2ktik

(cid:98)log(ui)(cid:99)(cid:88)
(cid:98)log(ui)(cid:99)(cid:88)

k=0

k=0

2kzijk

yij =
zijk ≤ ujtik
zijk ≤ xj
zijk ≥ xj − uj(1 − tik)
zijk ≥ 0
tik ∈ {0, 1}
yii ≥ xi
yii ≥ 2uixi − u2
yii ≤ uixi
yij = yji
yij ≤ ujxi
yij ≤ uixj
yij ≥ ujxi + uixj − uiuj
yij ≥ 0

i



i ∈ I

(i, j) ∈ I 2
(i, k) ∈ E, j ∈ I
(i, k) ∈ E, j ∈ I
(i, k) ∈ E, j ∈ I
(i, k) ∈ E, j ∈ I
(i, k) ∈ E
i ∈ I, λi (cid:54)= 0
i ∈ I, λi (cid:54)= 0
i ∈ I, λi (cid:54)= 0
(i, j) ∈ I 2, i < j, βij (cid:54)= 0
(i, j) ∈ I 2, i < j, βij (cid:54)= 0
(i, j) ∈ I 2, i < j, βij (cid:54)= 0
(i, j) ∈ I 2, i < j, βij (cid:54)= 0
(i, j) ∈ I 2, i < j, βij (cid:54)= 0

(15)

(16)

(17)

(18)

(19)

(20)

(21)

(22)

(23)

(24)

(25)

(26)

(27)

(28)

(29)

6

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

with E = {(i, k) : i ∈ I, k = 0, . . .(cid:98)log(ui)(cid:99)}.

This allows us to reformulate (QP ) as problem (QPα,λ,β), where fα,λ,β(x, y)

is a concave function and all constraints are linear:



(QPα,λ,β)

max fα,λ,β(x, y)
s.t.

n(cid:88)

arixi = br
(x, y, z, t) ∈ Sxyzt

i=1

1 ≤ r ≤ m (1)

Phase 2: Solving the reformulated problem (QPα,λ,β)
(QPα,λ,β) has a concave quadratic objective function and all its constraints
are linear, thus computing the optimal value of the continuous relaxation of
(QPα,λ,β) can be done in polynomial time. A general-purpose MIQP solver con-
sisting of a branch-and-bound framework based on the continuous relaxation can
solve (QPα,λ,β).

Several properties can be deduced from the general mixed-integer case pre-

sented in [8] which are the following.

– Problem (QPα,λ,β) is an equivalent formulation of (QP ) and the two prob-

lems have therefore the same optimal values.

– The optimal solution value of the continuous relaxation of (QPα,λ,β) is equal
to the optimal solution value of (SDP ). Moreover, parameters α, λ, and β
computed as described above, provide the tightest convex equivalent formu-
lation of (QP ) in this reformulation scheme.

– From any feasible dual solution (¯α, ¯λ, ¯β) of (SDP ), the associated function
f ¯α,¯λ, ¯β(x, y) is concave and thus our equivalent formulation is valid even if
we are not able to solve (SDP ) to optimality.

Property 1. From any (α, λ, β) where fα,λ,β(x, y) is not a concave function, we
are always able to build a concave function fα,λ,β(x, y) by taking (α, λ + , β),
where  is the biggest eigenvalue of the Hessian matrix of function fα,λ,β(x, y).

To illustrate the computational limitations of this approach when (SDP )
is solved by standard semideﬁnite programming solvers, we refer to the exper-
iments presented in Section 4.1 where we compare methods MIQCR and QCR on
45 k-cluster instances of size n = 80. Recall that the k-cluster problem can be
formulated by an equality constrained binary quadratic program. Recall that the
k-cluster problem can be formulated by an equality constrained binary quadratic
program.

While QCR [11] is devoted to solve binary quadratic programs, MIQCR [8]
was devised as a solution method for quadratic programs having general integer
variables and continuous variables. In the end, the two methods are based on
the same ideas of quadratic convex reformulation. QCR is in fact a special case

Using Conic Bundle to accelerate a quadratic convex reformulation

7

of method MIQCR where all parameters βij are ﬁxed to 0. Hence, Phase 1 of
QCR amounts to solve (SDP ) without Constraints (8)-(11) and Constraints (5)
replaced by Xii = xi. Moreover, in QCR no additional variables y are necessary
to get an equivalent formulation. Indeed, it can be seen from set Sxyzt that
variables yij, i (cid:54)= j, are created only if βij (cid:54)= 0, and since xi ∈ {0, 1}, we have
yii = x2

i = xi.

In MIQCR the equivalent formulation is thus of larger size than the initial
problem. Naturally, the equivalent formulation obtained by MIQCR leads to a
better bound than the one obtained by QCR [38]. Hence, MIQCR relies on a tighter
semideﬁnite relaxation but with a larger number of additional constraints. Sum-
marizing, in binary quadratic programming methods QCR and MIQCR diﬀer by the
compromise between tightness of the used bounds versus size of the semideﬁnite
relaxation and of the reformulated problem. These sizes are clearly in relation
with the cpu time needed for solving both, the semideﬁnite relaxation and the
reformulated problem.

3 MIQCR-CB - a method for large-scale problems

In this section we propose a non-standard algorithm to compute the reformulated
problem provided by method MIQCR. This algorithm is much faster than a stan-
dard semideﬁnite programming solver. Moreover, it allows us to start Phase 2
with a tight bound and a reformulated problem of reduced size, and thus to
handle large instances.

As already explained, the bottleneck of method MIQCR is solving (SDP ).
The most prominent methods for solving semideﬁnite problems are interior-
point methods, e.g. [29]. These methods are well-studied and several implemen-
tations exist, e.g., CSDP [14], SeDuMi [54], SDPA [22]. The computational eﬀort
depends on the order of the matrix and on the number of constraints. For in-
stances with matrix size larger than 1000, or with more than 10 000 constraints,
the semideﬁnite problems become intractable for interior-point methods. In Sec-
tion 4.1 we demonstrate the weakness of interior-point methods applied to our
problem. It turns out that for k-cluster problems of size n = 80 it is already not
practicable.

A variety of alternative methods for solving semideﬁnite problems has been
developed in the last decades. Many of these are based on augmented Lagrangian
methods. In [15,16] an augmented Lagrangian algorithm is presented where the
constraint X (cid:23) 0 is replaced by X = RR(cid:62), R being a matrix of low rank.
Augmented Lagrangian algorithms using projection techniques are proposed
in [33,42,56].

Another class for solving semideﬁnite programs are bundle methods. In the
spectral bundle method [28] the semideﬁnite problem is reformulated as an eigen-
value optimization problem, which is then solved by a subgradient method. An
implementation of this algorithm is SBMethod [26], or more general, the callable
Conic Bundle library [27].

8

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

We choose to use a bundle method to obtain a reasonable solution within
short time. Following the idea of [20], we design subgradient algorithm within a
Lagrangian duality framework.

3.1 A static bundle method for solving (SDP )

Let us consider a partial Lagrangian dual of (SDP ) where we dualize the lin-
earization constraints, i.e. constraints (8)–(11). We rewrite (SDP ) as (SDPT )
using the following notation.

n(cid:88)

n(cid:88)

n(cid:88)

(SDPT )

max f (X, x) =

qijXij +

i=1

j=i+1

i=1

s.t.

(X, x) ∈ S
ij(X, x) ≤ 0,
ht

cixi

(i, j, t) ∈ T



where S = {(X, x) : (X, x) satisﬁes (1), (4) − (7), (12), (13)} and T = {(i, j, t) :
1 ≤ i < j ≤ n, t = 1, . . . , 4}, and for all (i, j, t) ∈ T :



ht
ij(X, x) =

Xij − ujxi
Xij − uixj
−Xij + ujxi + uixj − uiuj
−Xij

t = 1

t = 2

t = 3

t = 4

With each constraint ht
Lagrange multiplier βt

LT (X, x, β) =

ij. We now consider the partial Lagrangian

ij(X, x) ≤ 0 of (SDPT ) we associate a non-negative
n(cid:88)
n(cid:88)

n(cid:88)
cixi − (cid:88)

βt
ijht

ij(X, x)

qijXij +

(i,j,t)∈T

i=1

j=i+1

i=1

and we obtain the dual functional

gT (β) = max
(X,x)∈S

LT (X, x, β).

By minimizing this dual functional we obtain the partial Lagrangian dual prob-
lem (LDT ) associated with (SDPT ),

(cid:26) min gT (β)

(LDT )

s.t. βt

ij ≥ 0, (i, j, t) ∈ T.

Our aim is to solve (LDT ) using the bundle method. The outline of the algorithm
is the following. For a given ¯β ≥ 0, we evaluate gT ( ¯β) and determine the associate
primal solution ( ¯X, ¯x), such that gT ( ¯β) = LT ( ¯X, ¯x, ¯β). We call a pair ( ¯β, ( ¯X, ¯x))
a matching pair for gT . Evaluating function gT for given ¯β amounts to maximize
a linear function in (X, x) over the set S. This is an SDP that has much less

Using Conic Bundle to accelerate a quadratic convex reformulation

9

constraints than (SDPT ) and can be solved eﬃciently by interior-point meth-
ij( ¯X, ¯x) ∈ ∂gT ( ¯β).
ods. From the solution ( ¯X, ¯x), we compute a subgradient ht
The bundle method is an iterative algorithm that maintains at each iteration a
“best” approximation ˆβ and a sequence X = (( ¯X1, ¯x1), ( ¯X2, ¯x2), . . . , ( ¯Xk, ¯xk))
where ( ˆβ, ( ¯Xi, ¯xi)) is a matching pair. Then, from the sequence X , the best ap-
proximation, ˆβ, and the new subgradient, the bundle method computes a new
value ˆβ that will be used at the next iteration. A detailed description of the
method is available in [20].

3.2 A dynamic bundle method for solving (SDPT )

elements in T is 4(cid:0)n

(cid:1). However, we are interested only in the subset of T for which

In order to preserve eﬃciency we adopt another idea from [20]. The number of
ij(X, x) ≤ 0 are likely to be active at the optimum. This set is
the constraints ht
not known in advance, however, in the course of the algorithm we dynamically
add and remove elements in order to identify “important” constraints. Here, we
consider T ⊆ T and work with the function

2

gT (β) = max
(X,x)∈S

LT (X, x, β).

Initially we set T = ∅ and after a ﬁrst function evaluation we separate violated
inequalities and add the elements to set T accordingly. We keep on updating
this set in course of the bundle iterations by removing elements with associated
multiplier close to zero and separate newly violated constraints. In this way we
obtain a “good” set of constraints.

Convergence for dynamic bundle methods has been analyzed in detail in [4],
giving a positive answer for convergence properties in a rather general setting.

3.3 A parameterized dual heuristic for solving (SDPT )
The computation of the “nearly” optimal (α∗, λ∗, β∗) with the dynamic bundle
method still can require much computational time. An idea for reducing this
computational time is to consider a relaxation of (SDPT ). Indeed, as observed
in Section 2, any feasible dual solution to (SDPT ) allows us to build a convex
equivalent formulation to (QP ). A possible way to get such a solution is to
drop some constraints from (8)–(11) of (SDPT ) and compute a dual “nearly”
optimal solution (¯α, ¯λ, ¯β) of the reduced problem. Then, a feasible dual solution
to (SDPT ) can be obtained by completing (¯α, ¯λ, ¯β) with zeros for those dual
variables corresponding to the dropped constraints. To carry out this idea, we
consider a parameter p that is an upper bound on the cardinality of T (|T | ≤
p). In other words, p is the maximum number of constraints considered in the
reduced problem. Finally, the proposed dual heuristic has two extreme cases:

(cid:1), we solve (SDPT ) and get the associated dual solution as in

– if p = 4(cid:0)n

2
Section 3.2.

10

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

– if p = 0, we make a single iteration: we get the optimal solution of the reduced
problem obtained from (SDPT ) where we drop all constraints (8)–(11) (For
binary quadratic programming this amounts to method QCR).

We call this procedure ComputeBeta(gT ,p) and sketch it in Algorithm 1. The
algorithm returns a solution β∗ having at most p positive components. Thus, the
number of variables yij of problem (QPα,λ,β) is also at most p only and Phase 2
of MIQCR-CB can be solved much faster than Phase 2 of MIQCR. Finally, this
parameter p controls the size, and in a sense the tightness, of the semideﬁnite
relaxation used for computing the equivalent formulation of method MIQCR-CB.

Algorithm 1 ComputeBeta(gT ,p)
Initialization
1: k=0 {counter on the number of iterations}
2: Tk = ∅ {Current set of dualized constraints : we start with 0 for all β}
3: Solve gTk (0). Let ( ¯X, ¯x) be the obtained solution. {We start by solving (SDPT )
without any Constraints (8)–(11) and determine the p most violated constraints}
4: Tk = { sub-set of T corresponding to the at most p violated constraints of (SDPT )
at point ( ¯X, ¯x)}.

ij( ¯X, ¯x) of gT (β) for β = 0.

5: Compute a subgradient ht
6: while predicted progress of the next step is suﬃcient do
7:
8:

Update β value: β = ˆβ {using the Conic Bundle algorithm [27]}
Solve gTk ( ˆβ). Let ( ¯X, ¯x) be the obtained solution. {where the objective function
of gTk ( ˆβ) is the function obtained by dualizing each constraint (i, j, t) ∈ Tk}
Compute a subgradient ht
Compute Tk+1 : drop from Tk constraints that are no longer violated and add
new most violated constraints such that |Tk+1|
k++;

11:
12: end while
13: Complete the solution β∗ by zeros for constraints that do not belong to Tk.

9:
10:

ij( ¯X, ¯x) of gT (β) for β = ˆβ.

Remark 1. In Steps 3 and 8, gTk ( ˆβ) is computed by CSDP [14].

4 Computational results

In this section, we present computational results for our method MIQCR-CB. We
ﬁrst evaluate our algorithm on binary quadratic programming instances of the
k-cluster problem. For this, we start with a detailed comparison of methods QCR,
MIQCR, and MIQCR-CB for instances of size n = 80. For these instances, we also
study the behavior of MIQCR-CB when varying parameter p. As instances of size
n = 80 are not practicable for CSDP, we make experiments using instances of
smaller size (n = 40) to compare MIQCR-CB with the interior-point solver CSDP

Using Conic Bundle to accelerate a quadratic convex reformulation

11

turned into a heuristic. These experiments illustrate that for Phase 1 the bun-
dle algorithm is faster. Finally, we compare our method with BiqCrunch [37]
for larger instances of sizes n ∈ {100, 120, 140, 160}. Furthermore, we evaluate
MIQCR-CB on instances with general integer variables. For theses instances, we
compare our algorithm with the solvers Couenne [5] and cplex 12.6 [31] as the
scope of BiqCrunch is binary quadratic programming. Note that our method
can also handle general mixed-integer problems, some computational results can
be found in [9].

Experimental environment:

We implemented algorithm MIQCR-CB in C. We use the Conic Bundle callable
C-library of Christoph Helmberg [27] to implement Algorithm 1 and the SDP
solver CSDP of Brian Borchers [14] for the function evaluation. Methods MIQCR
and QCR are also available as C implementations. For solving (SDP ) of method
MIQCR we use the solver SBMethod [26], as the solver CSDP [14] was not able
to handle (SDP ) (allocation storage error), and the solver CSDP [14] is used
for solving the semideﬁnite programs of QCR. The C-interface of Cplex12.5 [30]
serves for solving the quadratic programs.

Experiments for all methods (MIQCR-CB, MIQCR, QCR and BiqCrunch) were
carried out on a laptop with an Intel quad-core i7 processor of 1.73 GHz and 6
GB of RAM using a Linux operating system.

4.1 Computational results for the k-cluster problem
Given a graph G of n vertices and a number k ∈ {3, . . . , n − 2}, the k-cluster
problem consists in ﬁnding a subset of k vertices of G such that the induced
subgraph is as dense as possible. This problem or its weighted version has many
applications and is classical in combinatorial optimization. It is also known as the
“heaviest k-subgraph problem”, the “k-dispersion problem” [45], the “k-defense-
sum problem” [35], the “densest k-subgraph problem” and the “k-subgraph prob-
lem”. It can be formulated by the following binary quadratic program.

n(cid:88)

n(cid:88)

i=1

j=i+1

max f (x) =

δijxixj



(KC)

s.t.

n(cid:88)

xi = k
x ∈ {0, 1}n

i=1

where δij = 1 if and only if an edge links vertices i and j and xi is the binary
variable indicating whether vertex i is selected in the subset. (KC) is known
to be NP-hard even for bipartite graphs [17]. Many approximation results are

12

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

known for (KC) [2,25,34,53]. Concerning the solution algorithms of (KC), clas-
sical approaches based on linearization techniques are able to solve medium size
instances with up to 80 variables [7,19,45]. A few methods are able to solve (KC)
to optimality for large size instances (when n > 80). The most eﬃcient exact
solution methods are based on nonlinear approaches, such as convex quadratic
programming [11] or semideﬁnite programming [24,32,43,47].

We compare experimentally our new algorithm MIQCR-CB with three ap-
proaches: the original MIQCR and QCR approaches, and the method BiqCrunch
of Krislock, Malick, and Roupin [37]. This latter approach uses the branch-and-
bound solver Bob [18] in monothreading together with semideﬁnite programming
bounds [41] to solve (KC) to optimality. At each node, a dual bound is com-
puted solving a semideﬁnite relaxation of (KC). The semideﬁnite relaxation
turns out to be tighter than the one used in MIQCR because it integrates the
family of triangular inequalities that are not used inside MIQCR. To compute the
dual bound, the SDP program is ﬁrst formulated as an equivalent program with
a spherical constraint (a constraint on the norm of matrix X). This spherical
constraint is then dualized within a Lagrangian framework, and the dual prob-
lem is viewed and solved as a particular least-squares semideﬁnite program. The
resulting bound is very close to the optimal value of the semideﬁnite relaxation
and can be computed very fast.

We report numerical results on 225 instances of (KC) with up to 160 ver-
tices. We use the 90 instances of sizes n = 80 and 100 introduced in [7], extended
in [10] and [46], and also used in [37]. Additionally we consider the set of 135
instances of sizes n ∈ {120, 140, 160} used in [37]. All these instances were gener-
ated as follows. For a given number of vertices n and a density d an unweighted
graph is randomly generated. The parameter k is then set to n
4 . All
instances are available online [36].

2 , and 3n

4 , n

Parameters:
– Phase 1: Parameter termeps of SBMethod [26] is set to 10−4. Parameters
axtol, aytol of CSDP [14] are set to 10−4. The precision of the Conic
Bundle [27] is set to 10−4. For method MIQCR-CB, we allow to dualize all

constraints, i.e., p = 4(cid:0)n

– Phase 2: The tolerance for parameter βij to be considered as non-zero is
10−4. For Cplex12.5 [30] (used in QCR, MIQCR, and MIQCR-CB), the relative
mipgap is 10−6 and the absolute gap is 0.99. The parameter objdiff is set
to 0.999, and the parameter varsel to 4. The time limit is set to 3 hours.
We use the multi-threading version of Cplex12.5 with up to 8 threads.

(cid:1).

2

Legend of Tables 1–4

– Each line is an average over 5 instances and we consider 45 instances for

each size 80, 100, 120, 140, 160; .
– n indicates the size of the graph;
– k is the size of the subgraph or cluster;
– d is the density of the graph;

Using Conic Bundle to accelerate a quadratic convex reformulation

13

– Gap is the relative gap in percentage between the optimal solution value v
and the value of the continuous relaxation c at the root node of the branch-
and-bound tree (Gap =

∗ 100);

|c−v|

v

– P1 is the cpu time in seconds for solving Phase 1;
– P2 is the cpu time in seconds for solving Phase 2 by Cplex12.5 [30]; (i) means

that only i instances were solved within the time limit;

– Tt is the total time in seconds, i.e., the sum of P1 and P2 ;
– Min and Max are the minimum and maximum total time, respectively,

within the ﬁve instances of the same characteristics.

– Nodes is the number of nodes explored.

MIQCR

n d (%) k Gap P1 P2 Tt Nodes Gap P1
0.6
80
9.2
20 3.39 1434 129 1563 2371
2.68
80
1
924
40 1.00 482 83 565
0.87 0.8
80
60 0.30 199 39 238
182
8.03 0.6
80
20 2.34 981 173 1154 3281
1.81 0.8
40 0.76 373 143 516 1809
80
1
0.6
80
60 0.29 178 215 393 1748
1
20 1.49 1273 188 1461 3912
80
6.47
1
40 0.59 411 988 1399 19621 1.35
80
80
60 0.20 220 132 352
0.42
1

25
25
25
50
50
50
75
75
75

917

QCR (p = 0)
P2
12.2
2.8
1.6
21.6

Tt
12.8
3.8
2.4
22.2
3.8
2.8
66.6
12.8
2.8

3
1.8
65.6
11.8
1.8

MIQCR-CB (p = 4(cid:0)n

(cid:1))

2

Nodes Gap P1 P2 Tt Nodes
77083.6
12786.6
1137.4

940
204

0

3.00 6
0.72 6
0.07 5
231259.8 2.02 6
14048.8
0.49 6
0.08 5
792944.2 1.37 5
113409.6 0.49 6
0.04 5

3246.8

3249

4 10
9
3
3
8
5 11 2013
3
426
3
6 11 2081
6 12 5353
3

9
8

8

0

8

Mean

1.57 617 232 849 3863 3.49 0.87 13.57 14.44 138796.2 0.92 6 4 10 1225

Table 1. Average computational results of MIQCR, QCR and MIQCR-CB for 45 k-cluster
instances with n = 80.

To illustrate how the three methods compare with respect to bound, CPU
time and nodes, we show in Table 1 numerical results for 45 instances of size
n = 80 solved using MIQCR, QCR and MIQCR-CB, where each line corresponds to
average values over 5 instances, the bottom line averages the values over all in-
stances.

Comparison of MIQCR and QCR

As expected, we observe that the gap obtained by MIQCR is always smaller
than the gap obtained by QCR. On average the gap is only half of the gap obtained
by QCR. In spite of this improvement of the gap, the cpu time of MIQCR is 20 times
larger than the cpu time of QCR. This is caused by the addition of the variables y
and the corresponding linearization constraints in the reformulated problem. In-
deed, in QCR the reformulation has n variables and m constraints, while in MIQCR
the reformulation has in the worst case (i.e. all βij (cid:54)= 0) n + n|E| + |E| variables
and 5n2 +4n|E|+4n constraints. Observe, however, that as a consequence of the
smaller root gap, about 180 times less nodes are explored by Cplex12.5 in MIQCR.

Concerning the comparison of MIQCR and QCR, we summarize:

14

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

i) The reformulated problem for method QCR is faster to compute, but the
theoretical continuous relaxation bound provided by its equivalent formula-
tion is weaker. As a consequence, the solution computed by the associated
branch-and-bound algorithm in Phase 2 of QCR is hard to obtain.

ii) Conversely, the reformulated problem provided by MIQCR leads to a tight
theoretical continuous relaxation bound, but this equivalent formulation
computed in Phase 1 is very hard to solve.

iii) For both methods, the solution of large-scale k-cluster problems is intractable.

Comparison of MIQCR-CB and MIQCR

We would like to demonstrate the improvement of MIQCR-CB over MIQCR.

When comparing these two latter methods, we can observe the following.

i) The computation time of Phase 1 is signiﬁcantly reduced. Indeed, the average
computational time over all the instances reduces from 617 seconds to 6
seconds.

ii) The SDP bound is tightened. For these instances, the gap obtained by
MIQCR-CB is smaller compared to MIQCR. This might sound strange because
the SDP problem considered is the same for both methods. The diﬀerence
results from our algorithm used to solve Phase 1 that is more accurate than
SB for these instances.

iii) The computation time of Phase 2 is reduced. This time is divided by a factor
58 on average for MIQCR-CB. This is mainly due to the smaller number of
variables in the reformulated problem. Indeed, we have a signiﬁcant num-
ber of βij values that are 0, and thus less variables yij with their associated
constraints are considered in the reformulated problem. As an illustration
of this phenomenon, for one of the instances with n = 80, d = 25%, and
k = 20, we observe 2488 non-zero βij in MIQCR, and only 1890 non-zero βij
in MIQCR-CB.

Comparison of MIQCR-CB and QCR

We make the following observations.

i) P1 is smaller for QCR than for MIQCR-CB. For QCR, P1 is always smaller than
one second. In MIQCR-CB P1 varies from 4 to 7 seconds. This is the conse-
quence of adding Constraints (8)-(11) which number is potentially Θ(|I|).
ii) The gap in MIQCR-CB is signiﬁcantly smaller than the gap in QCR. Com-
pared to QCR, the gap in MIQCR-CB is approximatively divided by 4 for all
the instances. This is also the consequence of using a stronger semideﬁnite
relaxation.

iii) On average MIQCR-CB is faster than QCR. The average total cpu time of
MIQCR-CB is divided by a factor 4 compared to QCR. Note that for both
methods the k-cluster problem gets harder with smaller values of k. Es-
pecially for small values of k, MIQCR-CB is signiﬁcantly faster than QCR,
although QCR is faster for these medium size instances for half cases.

Using Conic Bundle to accelerate a quadratic convex reformulation

15

All the instances considered of size n = 80 are solved to optimality by MIQCR-CB
within 20 seconds. We present in the next section results for larger problems, to
determine the limitations of method MIQCR-CB and compare it with BiqCrunch.

Computational study of the inﬂuence of parameter p

In Section 3.3, we introduced a dual heuristic version of our bundle algorithm
used for solving Phase 1 that is parameterized by p. This parameter controls
the size, and the tightness, of the semideﬁnite relaxation used for computing
the equivalent formulation of method MIQCR-CB. To evaluate the inﬂuence of p
on method MIQCR-CB, we run our method for diﬀerent values of p. Denote by

(cid:1) = |T| the initial number of inequalities (8)–(11), we run our method

p0 = 4(cid:0)n

2

for p = δp0, with δ = 1, 0.5, 0.2, 0.1, 0.05 and 0.01. We report in Table 2 the
corresponding values of δ and of p for these instances of size 80. We can see in
Figure 1 the results obtained for the initial gap, the solution time of Phase 1,
and the total solution time. We observe that if the number of active constraints
at the optimum is strictly smaller than p, the optimal solution of (SDP ) is
obtained faster when δ is set to 1. Indeed, see for instance when δ = 0.5, the
solution time is larger than for δ = 1, and the initial gaps are the same for both
parameters. Otherwise, the smaller the p, the faster the solution time of (SDP )
is computed. These results also illustrate the advantage of method MIQCR-CB
over method QCR (when p = 0), as for any considered values of p, MIQCR-CB is
always faster.

p

δ
1 3160
0.5 1580
0.2 632
0.1 316
0.05 158
0.01 31

Table 2. Number p of considered constraints with diﬀerent values of δ

Experimental comparison of MIQCR-CB (with p = 4(cid:0)n

2
Phase 1 is solved with CSDP turned into a heuristic

(cid:1)) and MIQCR where

In this paper, we want to accelerate Phase 1 of our algorithm, and further-
more get an equivalent formulation with a reasonable size. A way to do this
using interior-point algorithm for solving (SDP ) is to stop the solver CSDP with
a much smaller precision and to consider the β equals to zero with a much smaller
precision. As instances of size n = 80 are not practicable for CSDP, we make ex-
periments using instances of smaller size (n = 40). We use 3 conﬁgurations for
solving Phase 1 of our method:

16

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

Fig. 1. k-cluster instances of size n = 80 : inﬂuence of parameter p

– Conﬁguration 1: We use CSDP turned into a heuristic: parameters axtol
and aytol are set to 10−4 and parameter objtol is set to 10−1, and the
tolerance for parameters βij to be considered as non-zero to 10−4.
– Conﬁguration 2: We use CSDP turned into a heuristic: parameters axtol,
aytol are set to 10−4 and objtol is set to 10−1, and the tolerance for
parameters βij to be considered as non-zero to 10−2.
– Conﬁguration 3: We use Algorithm 1: the stopping criteria is set to 10−4,
and the tolerance for parameters βij to be considered as non-zero to 10−4.

2

We set p to 4(cid:0)n

(cid:1).

We report in Table 3 the average number of variables yij created in Phase 2
for each considered conﬁguration of Phase 1. We recall that for these instances
the maximum number of variables yij created is 820.

Conﬁg. for Phase 1 nb yij in Phase 2

Conﬁguration 1
Conﬁguration 2
Conﬁguration 3

738
554
409

Table 3. Average number of variables yij considered in Phase 2 of our algorithm

We report in Figure 2 the results obtained for the initial gap, the solution time
of Phase 1, and the total solution time. In this graphic, the scale is logarithmic.
We observe that the initial gap obtained with conﬁguration 3 is about 22 times
smaller than the initial gap obtained by conﬁgurations 1 and 2. Moreover, the
solution time of Phase 1 is 68 times smaller for conﬁguration 3, in comparison
to conﬁgurations 1 and 2.

Using Conic Bundle to accelerate a quadratic convex reformulation

17

Fig. 2. k-cluster instances of size n = 40 : comparison with CSDP turned into a heuristic

Experiments to show the limitations of interior-points methods for solving
problems with a huge number of constraints were already done in [20] and re-
vealed a similar trend as ours.

Comparison of MIQCR-CB and BiqCrunch

In Table 4 we report computational results on instances of larger size, namely
n ∈ {100, 120, 140, 160}. For these instances, we compare method MIQCR-CB with
BiqCrunch run on the same computer.

For instances of size n = 100 and n = 120, we observe that MIQCR-CB is as fast
as BiqCrunch. Indeed, MIQCR-CB solves all 45 instances of size n = 100 (n = 120
resp.) within 37.44 (370.89 resp.) seconds on average, while BiqCrunch solves
all the instances within 34.53 (338.07 resp.) seconds. Notice that the initial gap
is 1.6 (1.5 resp.) times tighter for BiqCrunch than for MIQCR-CB. The average
number of nodes is 1025 (1839 resp.) times larger for MIQCR-CB for instances of
size n = 100 (n = 120 resp.).

For the largest instances, namely those of size n = 140 (n = 160 resp.),
MIQCR-CB is able to solve 38 (26 resp.) instances out of 45 within the time
limit of 3 hours while BiqCrunch solves 43 (33 resp.) instances within 3 hours.
The average computation time is 2086.10 (3323.88 resp.) seconds for MIQCR-CB
and 1548.32 (2548 resp.) seconds for BiqCrunch. The initial gap is 1.4 (1.3 resp.)
times tighter for BiqCrunch than for MIQCR-CB. These largest instances represent
the limit of both algorithms.

18

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

MIQCR-CB (p = 4(cid:0)n

(cid:1))

7
5

37

BiqCrunch

Min Max Nodes

5

91

31

Mean

265
29
3

11964
3407

29116
77626

12559
3603

140
149
11
116

334.8
343
9.8

19
17
16
21
18
16
23
19
17

14
2
2
19
3
2
44
2
2

25
25
25
50
50
50
75
75
75

82
44
18
116
176
28
54
31
19

26
4
1
33
28
1
43
1
1
15
104
69
2

Tt
71.3
9.3
2.6
59.4
83.3
3.9
75.1
3.3
2.6
35

P2
25.2
9.8
5.2
41.2
87.8
6.2
21.4
10.2
5.8
24

Tt
39.6
23.4
17
54.8
105
20.6
35
24
17.6
38
366
376.4
38.8
474
633.8
90.2
823.2
498.2
37.4
371

n d (%) k Gap P1
25 3.30 14.4
100
50 0.84 13.6
100
100
75 0.08 11.8
25 2.50 13.6
100
50 0.90 17.2
100
75 0.08 14.4
100
25 1.37 13.6
100
50 0.35 13.8
100
100
75 0.04 11.8
1.05 14
30 3.53 31.2
60 1.03 33.4
90 0.10 29
30 2.53 29.2
60 0.81 32.6
90 0.14 34
30 1.57 31.6
60 0.47 40.4
90 0.04 29
1.14 32
35 3.55 53.6
70 1.07 61.2
105 0.09 46.2
35 2.61 50.8 3591.3(4) 3645.5 (4) 1262 7062 1501072 2.16 1958.9 (4) 806 3589 493
379 8763 800
70 0.89 53.8
105 0.08 50
11
35 1.69 52.8 3748.3(3)
70 0.39 54.4
105 0.05 47.2

2
Min Max Nodes Gap
1.78
0.28
0.11
1.76
0.43
0.06
1.19
0.10
0.03
15378 0.64
168 818 140208 2.22
695 151256 0.53
75
34
48
0.03
208 867 232762 1.92
310 1246 322930 0.41
50
0.08
56 2922 576795 1.42
111 903 245271 0.21
32
0.02
185803 0.76
452 9940 1624107 2.41
221 7939 1124785 0.57
51
0.04

3800 (3) 2000 7048 1924558 1.57 4289.9 (4) 2475 9031 1128
1722.2
240.4

251 1161 186
249 446
85
38
22
301
74 3232 403
40
66
1.00
3
101
305 3493 349
129 2456 143

1913 (1) 1913 1913 1013112 0.54
0.04

493 4843 700401 0.19
0.03
47

581.9
360.4
135.1
1124.9
193.4

120
120
120
120
120
120
120
120
120

140
140
140
140
140
140
140
140
140

444.8
601.2
56.2
791.6
457.8

224 522
582
52
4
17

8.4
339
4458
2725.4

25
25
25
50
50
50
75
75
75

25
25
25
50
50
50
75
75
75

1691.7
864.6
19.2

185 551
140

4511.6
2786.6

1667.8
193.2

721 9100.6

305.9
49.2

348.5
285.3

4.2
338

1871(1)

4663.7

Mean

54

151

5

7

4

392

6

160

2895

46

79.4

75

134

25

3

46
6

15.6

61.8

43.8

93.8

9.2

1462

91.9

251

256.4

Mean

4049(2)

877637 0.84 1548 (43)

1.16 52 2035 (38) 2086 (38)

160
160
160
160
160
160
160
160
160

331
40 3.27 78.4 3932.7 (3) 4009.3 (3) 1705 7986 769425 2.29 2874.2 (4) 829 7078 453
491 6662 357
80 1.02 86.6
120 0.16 84.4
38
31
40 2.54 72.6
80 0.66 80.6
120 0.08 78.8
40 1.68 74.2
80 0.46 75.6
120 0.05 66.8

9914 9914 2768184 2.15 6041.1(2) 5103 6979 1037
2182 7314 982063 0.42 5406.4(4) 558 9369 536
16
4518 4518 657
40
12
349
(i): i instances out of 5 were solved within the time limit. The reported values correspond to these instances.

0.04
3593(1)
3593 3593 871354 1.55
2264.5(2) 379 4150 403871 0.29
0.03

4126.5(2) 2117 6136 811861 0.60
0.09

1.10 78 3242 (26) 3324 (26)

736924 0.83 2549 (33)

25
25
25
50
50
50
75
75
75

84 1202
42
281

4518(1)
643.0(2)

100 1392 12461

3483(1)
2176(2)

9845(1)
4665(2)

9914(1)
4748(2)

2737.7
353.1

Mean

340.8

151.4

212.5

619.8

220.2

8872

4222

739

899

299

264

468

553

71

86

41

Table 4. Average computational results of MIQCR-CB and BiqCrunch for 180 instances
of the k-cluster of size n = 100, 120, 140 and 160 (time limit: 10 800 seconds).

Using Conic Bundle to accelerate a quadratic convex reformulation

19

4.2 Computational results on the general integer case

In this section we extend our computational experiments to the class of (gen-
eral) quadratic integer problems to compare the improvement of MIQCR-CB over
MIQCR on this more general class of instances, and evaluate our method with the
state-of-the-art solvers Cplex12.6 [31] and Couenne [5]. We brieﬂy recall that
the solver Couenne [5] uses linear relaxations within a spatial branch-and-bound
algorithm [6], and that Cplex12.6 uses a branch-and-bound algorithm based on
convex relaxations [12]. For both solvers, numerous heuristics are incorporated
into branch-and-bound algorithms in order to improve their performances.

(cid:1)).

dualize all constraints (i.e. p = 4(cid:0)n

Parameters:
– Parameters axtol, aytol of CSDP [14] are set to 10−8. The precision of
the Conic Bundle [27] is set to 10−8. For method MIQCR-CB, we allow to
– Phase 2: A parameter βij is considered as 0 if |βij| is below 10−6. For
Cplex12.5 [30], the relative mipgap is 10−8 and the absolute gap is 0.99.
The parameter objdiff is set to 0.999, and the parameter varsel to 4. We
used the multi-threading version of Cplex12.5 and Cplex12.6 with up to 8
threads. For solvers Cplex 12.6 and Couenne we keep the default parame-
ters.

2

Experiments on the Equality Integer Quadratic Problem

We consider the Equality Integer Quadratic Problem (EIQP) that consists

in minimizing a quadratic function subject to one linear equality constraint:



(EIQP )

n(cid:88)

n(cid:88)

qijxixj +

i=1

j=i

n(cid:88)

i=1

cixi

min f (x) =

s.t.

n(cid:88)

i=1

aixi = b
0 ≤ xi ≤ ui
xi ∈ N

1 ≤ i ≤ n
1 ≤ i ≤ n

We use the instances introduced in [8], available online [39]. We run experi-
ments on two classes of problem, EIQP 1 and EIQP 2. For each class we generate
instances with 20, 30, and 40 variables where the coeﬃcients are randomly gen-
erated as follows:

– The coeﬃcients of Q and c are uniformly distributed integers from the in-

terval [−100, 100].

– The ai coeﬃcients are uniformly distributed integers from the interval [1, 50]

for class 1 and from [1, 100] for class 2.

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

20

– b = µ · n(cid:88)

ai, where µ = 15 for class 1 and µ = 20 for class 2.

i=1

– ui = 30 for 1 ≤ i ≤ n for class 1, and ui = 50 for class 2.
For each class and each n ∈ {20, 30, 40} we consider 5 instances obtaining
a set of 30 instances in total. Each of these instances has at least one feasible
solution (xi = µ for all i). In table 5 each line presents the results for one
instance, n indicates the size of the problem and r the reference of the instance
within the 5 instances with the same characteristics. The other columns are as
described in Legends of Tables 1–4. We use the same experimental environment
as described in Section 4.1.

(cid:16)n

(cid:17)

2

)

MIQCR

MIQCR-CB (p = 4

Cplex12.6

Couenne

class

1252

3956

26
15
20
23
26

n r Gap P1 P2
115
EIQP 1 20 1 0.1
15
EIQP 1 20 2 0.1
8
EIQP 1 20 3 0.1
4
EIQP 1 20 4 0.0
EIQP 1 20 5 0.2
16
EIQP 1 30 1 0.0 289 108
EIQP 1 30 2 0.0 184
11
EIQP 1 30 3 0.0 216 384
EIQP 1 30 4 0.1 218
68
EIQP 1 30 5 0.1 200 248
1251
EIQP 1 40 1 0.0 1093 2234 3327 1816
EIQP 1 40 2 0.0 1219 452 1671
558
EIQP 1 40 3 0.0 1325 196 1521
EIQP 1 40 4 0.0 1672 870 2542 3226
EIQP 1 40 5 0.2 2281 863 3144 3871

Tt Nodes Gap P1 P2 Tt Nodes Gap Tt
2
141
30
1
2
28
1
27
2
42
25
397
13
195
33
600
286
218
223
448
13
432

37
0.1
12
0.1
13
0.1
3
0.0
25
0.2
45
0.0
25
0.0
59
0.0
23
0.1
92
0.1
0.0
237 254
0.0 220 254 474
0.0
145
0.0 1239 157 1396 799
0.2 1362 622 1984 6365

39
14
16
6
28
59
39
96
42
112 1352
296
233

159
178
177
144
2000
209
8000
182
3500
175
13500
183
53500
160
84000
159
3000
175
161
56000
172 (10%) 259500
169 2382 258000
(2%) 87323
163 (9%) 294000 (14%) 84268

1644 116242
16938
347
179
9714
1231 53330
33841
596
148
1925

2
2
3
3
3
14
14
37
19
20
17

Nodes
2000
817
1000

Nodes
2044
342
1990

Tt
16
5
16
4
8

5
0
0
43
80
0

failed
failed

11
75
0

218
26

255
142

56
475

2741

78

69

23

67

1

0

2

Mean

0.1 587 373 960 1171 0.1 201 112 314 735 171

349
(13)

69259

319
(11)

34944

2583

3
73

23
60
30
32
19

89
66
EIQP 2 20 1 0.1
70
10
EIQP 2 20 2 0.0
47
17
EIQP 2 20 3 0.0
1726
86
54
EIQP 2 20 4 0.2
341
50
EIQP 2 20 5 0.1
31
4237
975
EIQP 2 30 1 0.3 481 494
1488
593
EIQP 2 30 2 0.1 337 256
1009
465
EIQP 2 30 3 0.0 264 201
3728
847
EIQP 2 30 4 0.1 180 667
3591
EIQP 2 30 5 0.1 476 398
874
EIQP 2 40 1 0.0 1078 1137 2215
739
EIQP 2 40 2 0.1 1216 2295 3511 4876
EIQP 2 40 3 0.1 1118 2180 3298 3275
EIQP 2 40 4 0.0 1306 165 1471
EIQP 2 40 5 0.0 2234 1415 3649 3616

0

22
20
63
51

3
10
2
7
6

39
21
5
16
9

5585
1748
336
2132
724

2
3
1
2
4
86
21
159

2000
3500
500
3000
5000
50000
13500
125000

112 115 7979
12
18
56
45

159
0.1
180
11
0.0
138
140
0.0
155
2777
0.2
588
0.1
1590
14978
287
186
0.3 1296 165 1461 2011
4655
92
282 288 45378 171
0.1
15589
284
105 149
160
893
0.0
4440
86
6000
134
0.1
226 232 4255
413
24752
160
0.1 1161 100 1261 1737
70000
160 1739 236000
750 783 2610
0.0
1387 39258
33
216 (11%) 535500 (15%) 82426
28
0.1
989 1017 5473
166 1366 253000
17 1238 1255 6664
0.1
3016 95223
162
25
0.0
0.0
67
177 (6%) 450000

84
697 764 2841

6
44
6

1500

failed

169

109

391

80

9

5

7

Mean

0.1 590 626 1216 2086 0.1 181 325 506 3830 194

259
(13)

116967

582
(13)

23104

Table 5. Computational results of MIQCR-CB, MIQCR, Cplex12.6 and Couenne for 30
general integer instances with 20, 30 and 40 variables of classes EIQP 1 and EIQP 2.

The numerical results comparing methods MIQCR-CB, MIQCR, Cplex12.6 and
Couenne are given in Table 5. We observe that both algorithms MIQCR-CB and
MIQCR solve all considered instances in less than 3 649 seconds of cpu time, while
Cplex12.6 solves only 26 instances and Couenne only 24 instances, over the
30 considered instances in less than one hour of CPU time. Comparing MIQCR
and MIQCR-CB, we observe that MIQCR-CB is always faster than MIQCR. More
precisely, while the initial gap remains the same for both methods, for class
EIQP 1 (EIQP 2 resp.) the solution time for Phase 1, for MIQCR-CB in compar-
ison to MIQCR, is divided on average by a factor of about 2.9 (3.3 resp.), and

Using Conic Bundle to accelerate a quadratic convex reformulation

21

by a factor 3.3 (1.9 resp.) for the solution time of Phase 2. Hence the total
run time signiﬁcantly decreases (factor 3.1 for EIQP 1 and 2.4 for EIQP 2).
Comparing Cplex12.6 and Couenne with MIQCR-CB, we observe that Cplex12.6
and Couenne are often faster than MIQCR-CB for the smallest considered in-
stances, but with increasing dimension, MIQCR-CB is superior to Cplex12.6 and
Couenne. Moreover, we can notice a signiﬁcant decrease of the initial gap with
method MIQCR-CB (by a factor 2600) and of the number of visited nodes dur-
ing the branch-and-bound algorithm (by a factor 40 and 18), in comparison to
Cplex12.6 and Couenne.

Experiments on the Integer Equipartition Problem

We consider the Integer Equipartition Problem (IEP). This problem is an
extension of the classical min-cut graph problem which consists in partitioning
the vertices of a graph into a collection of disjoint sets satisfying speciﬁed size
constraints, while minimizing the sum of weights of edges connecting vertices in
diﬀerent sets [23]. In (IEP) we consider n types of items, m items of each type,
and a partition of the n· m items into p equally sized sets. We assume that n· m
is a multiple of p. For all pairs of type of items (i, j), i ≤ j, we denote by cij
the cost of allocating each pair of items of types i and j to diﬀerent sets. The
problem consists thus to minimize the total cost of allocating the n · m items to
the p sets. By introducing decision variables xik which represent the number of
items of type i allocated to set k, (IEP) can be formulated as follows:

(cid:88)

(cid:88)

i

k<l

ciixikxil



(IEP )

min

s.t.

i<j

k(cid:54)=l

(cid:88)
(cid:88)
n(cid:88)
p(cid:88)

xik =

i=1

cijxikxjl +

n · m
p

xik = m

k=1

0 ≤ xik ≤ min(m,
xik ∈ N

n · m
p

)

1 ≤ k ≤ p

1 ≤ i ≤ n

(30)

(31)

1 ≤ i ≤ n, 1 ≤ k ≤ p (32)
1 ≤ i ≤ n, 1 ≤ k ≤ p (33)

where Constraints (30) ensure that exactly n·m

items are allocated to each
set, Constraints (31) ensure that all items are allocated to a set. This problem
has a quadratic objective function, n+p linear equalities and n·p general integer
variables.

p

We generate instances of (IEP) with n = 3 or 4, m = 20 or 24 and p = 5 or
6, where the coeﬃcients c are uniformly distributed integers from the interval
[1, 10]. For each characteristics, we generate 10 instances. The numerical results
comparing methods MIQCR-CB, Cplex12.6 and Couenne are given in Table 6
where each line presents the results for one instance, n indicates the number of

22

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

types of items, m the number of items of each type, p the number of equally sized
sets, and r the reference of the instance within the 10 instances with the same
characteristics. The other columns are as described in Legends of Tables 1–4

MIQCR-CB p = (4(cid:0)n

(cid:1))

2

0
0

Cplex12.6

Couenne

Tt

n m p r Gap P1
0
03 20 05 1 0.00
0
03 20 05 2 0.00
1
03 20 05 3 2.07
1
03 20 05 4 1.50
0
03 20 05 5 1.73
03 20 05 6 0.11
1
1
03 20 05 7 1.01
9
03 20 05 8 0.11
1
03 20 05 9 0.12
1
03 20 05 10 0.14
2
0.7
03 24 06 1 0.00
1
0
03 24 06 2 0.00
1
03 24 06 3 0.00
1
03 24 06 4 0.00
5
03 24 06 5 0.00
1
03 24 06 6 0.02
03 24 06 7 0.00
4
03 24 06 8 0.35 20
03 24 06 9 0.04 11
03 24 06 10 0.07 73
0.1 12

Mean

Mean

1943

0

0

31505

Nodes

(5.8%)

241

7
25
34

Tt
16
2

P2
16
2

Tt
2888

546
606
552

317
309
663

Nodes Gap

0
0
29
321

2143
1122
1534
2194

29966
8990
2457
1507
7481
571
1815
864
5365

110
38
13
13
23
8
13
9
25
5
4
7
9
3
34
2

111
39
13
14
24
17
14
10
27
6
4
8
10
8
35
6

Nodes
1074696
90.87 (5.07%) 3054000
(1.4%) 1271760
2244000
76.64
122622
2487500
78.21
118438
76.31
2244000
231750
95.76 (2.17%) 2875500
(2.1%) 1182335
81.73 (8.24%) 3272500
744678
97.8
3158000
424302
81.6 (5.17%) 3009000
595765
94.24 (4.73%) 2951000
88.09 (5.07%) 3054000
814563
86.1 568 (3) 2834950 1396 (8) 658091
88.2 (16.88%) 2636000
(12.5%) 661600
(14.1%) 659827
87.11 (18.6%) 2575500
721369
(3.4%)
80.19 (10.46%) 2604500
745568
(3.8%)
83.39 (11.17%) 2501500
(6.5%)
84.66 (12.63%) 2543500
713247
(14.8%) 650991
88.75 (18.1%) 2611500
(10.8%) 667285
86.81 (15.61%) 2503500
84.27 (14.99%) 2582000
(11.5%) 647872
(11.7%) 693954
77.35 (15.64%) 2522000
79.58 (16.06%) 2574000
(12.5%) 662087
(15%) 2565400 (10.1%) 682380
(31.7%) 546677
(24.8%) 571394
(24.2%) 590082
(32.2%) 528364
(15.9%) 630677
(33.1%) 518391
(36.9%) 496121
(31.8%) 512563
(24.6%) 5764810
(27.1%) 557275
1.2 102 123 (3) 185 (3) 126958 90.9 (22.1%) 1976667 (28.2%) 552803
(72.3%) 308012
(65.1%) 314582
(61.7%) 336893
(74.9%) 298315
(58.5%) 340087
(74.2%) 299641
(71.5%) 295719
(75.0%) 301299
(60.3%) 324965
(66.3%) 315380
(68%) 313489

93.62 (42.69%) 1193500
90.36 (43.71%) 1210500
93.48 (36.72%) 1252500
99.26 (43.95%) 1227000
94.02 (40.12%) 1251000
93.13 (45.61%) 1224500
95.88 (43.85%) 1199500
118263 99.65 (48.48%) 1218500
95.21 (42.23%) 1194500
92.82 (44.19%) 1171500
0.7 257 350 (4) 378.4 (4) 51362 93.8 (41.6%) 1216917

309
1754
3586
185288 94.02 (24.69%) 1925000
190884 91.46 (22.58%) 1964500
176167 86.75 (19.82%) 2018500
90.17 (24.84%) 1908500
155941 90.05 (16.85%) 2036500
84.43 (26.29%) 1924500
87.1 (27.58%) 1923000
97.29 (27.02%) 1901500
188395 95.93 (21.16%) 199250
141855 91.96 (25.06%) 1903000

74597
79635
70921
13603
66534

261
18
98
46
-
-
-

3903
79072

829
6261

-

-

-
-

-
-
-

-

255
489

4454

217944

3942

152

260

143

411

-

-

4714

736

84

8

04 20 05 1 0.37 39 (0.18%)
04 20 05 2 1.84 97 (1.26%)
04 20 05 3 2.42 72 (1.83%)
04 20 05 4 0.09
04 20 05 5 3.82 79 (2.33%)
04 20 05 6 0.06 131
04 20 05 7 0.62 89 (0.46%)
04 20 05 8 0.05 47
04 20 05 9 1.50 102 (1.15%)
04 20 05 10 1.41 351 (1.27%)

144

129

96

Mean

04 24 06 1 0.06 102 (0.06%)
04 24 06 2 1.26 113 (1.12%)
04 24 06 3 1.26 93 (1.09%)
04 24 06 4 0.03 15
04 24 06 5 2.96 107 (2.29%)
04 24 06 6 0.01 189
04 24 06 7 0.00 136
04 24 06 8 0.25 16 (0.21%)
04 24 06 9 0.01 151
04 24 06 10 0.85 1648 (0.81%)

66
353

721

260

Mean

Table 6. Computational results of MIQCR-CB, Cplex12.6 and Couenne for 40 instances
of (IEP)

We observe that MIQCR-CB is able to solve 27 of the 40 considered instances,
while Cplex12.6 solves only 3 instances and Couenne 7 instances of the 10 of
the smallest size. Moreover these 3 (8 resp.) instances are solved by Cplex12.6
(Couenne resp.) within 568 (1396 resp.) seconds in average, while MIQCR-CB
solves the 10 instances within 25 seconds on average. An important advantage
of MIQCR-CB is its gap that is on average 136 times smaller than the gap of

Using Conic Bundle to accelerate a quadratic convex reformulation

23

Cplex12.6, and that is moreover quite stable independently from the character-
istics of the instances. As a consequence, the number of nodes visited during the
branch-and-bound algorithm is much smaller for MIQCR-CB than for Cplex12.6
and Couenne (factor 46 and 12 respectively).

5 Conclusion

We presented algorithm MIQCR-CB for solving general integer quadratic pro-
grams with linear constraints. This algorithm is an improvement of MIQCR [8].
MIQCR-CB is an approach in two phases: the ﬁrst phase calculates an equiv-
alent quadratic reformulation of the initial problem by solving a semideﬁnite
program, and the second phase solves the reformulated problem using standard
mixed-integer quadratic programming solver.

In Phase 1, a subgradient algorithm within a Lagrangian duality framework is
used to solve the semideﬁnite program that yields the parameters for construct-
ing an equivalent (convex) formulation. This signiﬁcantly speeds up Phase 1
compared to the earlier method MIQCR. Furthermore, by construction, we can
control the size of the reformulated problem. As a consequence, Phase 2 of our
algorithm is also accelerated. Thus, MIQCR-CB builds a reformulated problem
with a tight bound that can be computed in reasonable time, even for large
instances.

Computational experiments carried out on the k-cluster problem demon-
strate that our method is competitive with the best current approaches devoted
to the solution of this binary quadratic problems for instances with up to 120
variables. Moreover, our approach is able to solve most of the instances with 160
variables to optimality within 3 hours of cpu time. We also demonstrate that
MIQCR-CB outperforms MIQCR, Cplex12.6 and Couenne on two classes of general
integer quadratic problems, which conﬁrms the impact of the newly designed
procedure for solving the SDP.

Acknowledgment: We thank Franz Rendl for useful discussions and two

anonymous referees for suggestions that improved this paper.

References

1. K. M. Anstreicher.

the reformulation-
linearization technique for nonconvex quadratically constrained quadratic pro-
gramming. Journal of Global Optimization, 43:471–484, 2009.

Semideﬁnite programming versus

2. Y. Asahiro, K. Iwama, H. Tamaki, and T. Tokuyama. Greedily ﬁnding a dense
subgraph. In Proceedings of the 5th Scandinavian Workshop on Algorithm Theory.
Lectures notes in Computer Science, 1097, Springer-Verlag, pages 136–148, 1996.
3. C. Audet, P. Hansen, B. Jaumard, and G. Savard. A branch and cut algorithm
for non-convex quadratically constrained quadratic programming. Mathematical
Programming, 87(1):131–152, 2000.

4. A. Belloni and C. Sagastiz´abal. Dynamic bundle methods. Math. Program., 120(2,

Ser. A):289–311, 2009.

5. P. Belotti. Couenne, a users manual. ”http://www.coin-or.org/Couenne/”, 2013.

24

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

6. P. Belotti, J. Lee, L. Liberti, F. Margot, and A. Wchter. Br anching and bounds
tightening techniques for non-convex minlp. Optimization Methods and Software,
4–5(24):597–634, 2009.

7. A. Billionnet. Diﬀerent formulations for solving the heaviest k-subgraph problem.

Information Systems and Operational Research, 3(43):171–186, 2005.

8. A. Billionnet, S. Elloumi, and A. Lambert. Extending the QCR method to the
case of general mixed integer program. Mathematical Programming, 131(1):381–
401, 2012.

9. A. Billionnet, S. Elloumi, and A. Lambert. Exact quadratic convex reformulations
of mixed-integer quadratically constrained problems. To appear, Mathematical
Programming, 2015.

10. A. Billionnet, S. Elloumi, and M.-C. Plateau. Convex quadratic programming
for exact solution of 0-1 quadratic programs. Technical Report CEDRIC-05-856,
CEDRIC, 2005.

11. A. Billionnet, S. Elloumi, and M.-C. Plateau. Improving the performance of stan-
dard solvers for quadratic 0-1 programs by a tight convex reformulation: the QCR
method. Discrete Applied Mathematics, 0(157):1185–1197, 2009.

12. C. Bliek and P. Bonami. Non-convex quadratic programming in cplex. INFORMS

2013 Annual Meeting, 2013.

13. P. Bonami, L. Biegler, A. Conn, G. Cornu´ejols, I. Grossmann, C. Laird, J. Lee,
A. Lodi, F. Margot, N. Sawaya, and A. Waechter. An algorithmic framework for
convex mixed integer nonlinear programming. Discrete Optimization, 5:186–204,
2005.

14. B. Borchers. CSDP, a C library for semideﬁnite programming. Optimization

Methods and Software, 11(1):613–623, 1999.

15. S. Burer and R.D.C. Monteiro. A nonlinear programming algorithm for solv-
ing semideﬁnite programs via low-rank factorization. Math. Program., 95(2, Ser.
B):329–357, 2003. Computational semideﬁnite and second order cone program-
ming: the state of the art.

16. S. Burer and R.D.C. Monteiro. Local minima and convergence in low-rank semidef-

inite programming. Math. Program., 103(3, Ser. A):427–444, 2005.

17. D.G. Corneil and Y.A. Perl. Clustering and domination in perfect graphs. Discrete

Applied Mathematics, 9(1):27–39, 1984.

18. B. Le Cun, C. Roucairol, and The PNN Team. A uniﬁed platform for implementing

branch-and-bound like algorithms, 1995.

19. E. Erkut. The discrete p-dispersion problem. European Journal of Operational

Research, 46:46–80, 1990.

20. I. Fischer, G. Gruber, F. Rendl, and R. Sotirov. Computational experience with a
bundle approach for semideﬁnite cutting plane relaxations of Max-Cut and equipar-
tition. Mathematical Programming, 105:451–469, 2006.

21. C. A. Floudas. Deterministic global optimization. Kluwer Academic Publishing,

Dordrecht, The Netherlands, 2000.

22. K. Fujisawa and M. Kojima. SDPA (semideﬁnite programming algorithm) users

manual. Technical Report B-308, Tokyo Institute of Technology, 1995.

23. W.W. Hager and Y. Krylyuk. Graph partitioning and continuous quadratic pro-

gramming. SIAM Journal on Discrete Mathematics, 12:500–523, 1999.

24. Q. Han, Y. Ye, and J. Zhang. An improved rounded method and semideﬁnite pro-
gramming relaxation for graph partition. Mathematical Programming, 92(3):509–
535, 2002.

25. R. Hassin, S. Rubinstein, and A. Tamir. Approximation algorithms for maximum

dispersion. Operations Research Letters, pages 133–137, 1997.

Using Conic Bundle to accelerate a quadratic convex reformulation

25

26. C. Helmberg. A C++ implementation of the spectral bundle method. Manual ver-

sion 1.1.1, 2000.

27. C. Helmberg. Conic Bundle v0.3.10, 2011.
28. C. Helmberg and F. Rendl. A spectral bundle method for semideﬁnite program-

ming. SIAM Journal of Optimization, 10(3):673–696, 2000.

29. C. Helmberg, F. Rendl, R.J. Vanderbei, and H. Wolkowicz. An interior-point

method for semideﬁnite programming. SIAM J. Optim., 6(2):342–361, 1996.

30. IBM-ILOG.

Ibm ilog cplex 12.5 reference manual. ”http://pic.dhe.ibm.com/

infocenter/cosinfoc/v12r2/index.jsp”, 2013.

31. IBM-ILOG.

Ibm ilog cplex 12.6 reference manual.

”http://www-01.ibm.

com/support/knowledgecenter/SSSA5P_12.6.0/ilog.odms.studio.help/
Optimization_Studio/topics/COS_home.html”, 2014.

32. G. J¨ager and A. Srivastav.

Improved approximation algorithms for maximum
graph partitioning problems. Journal of Combinatorial Optimization, 10(2):133–
167, 2005.

33. F. Jarre and F. Rendl. An augmented primal-dual method for linear conic pro-

grams. SIAM J. Optim., 19(2):808–823, 2008.

34. G. Kortsarz and D. Peleg. On choosing a dense subgraph. In Proceedings of the
34th Annual IEEE Symposium on Foundations of Computer Science, pages 692–
701, 1993.

35. J. Krarup, D. Pisinger, and F. Plastria. Discrete location problems with push-pull

objectives. Discrete Applied Mathematics, 123:363–378, 2002.

36. N. Krislock, J. Malick, and F. Roupin. Library of k-cluster instances. ”http:

//lipn.univ-paris13.fr/BiqCrunch/download”, 2013.

37. N. Krislock, J. Malick, and F. Roupin. Computational results of a semideﬁnite
branch-and-bound algorithm for k-cluster. Computers & Operations Research,
66:153–159, 2016.

38. A. Lambert. R´esolution de programmes quadratiques en nombres entiers. Th`ese de
doctorat en informatique, Conservatoire National des Arts et M´etiers, Paris, 2009.
39. A. Lambert. EIQP/IIQP: Library of integer quadratic programs. ”http://cedric.

cnam.fr/~lamberta/Library/eiqp_iiqp.html”, 2012.

40. L. Liberti and N. Maculan. Global optimization: From theory to implementation,
chapter: Nonconvex optimization and its applications. Springer, New York, 2006.
41. J. Malick. Spherical constraint in boolean quadratic programming. Journal of

Global Optimization, 39(4):609–622, 2007.

42. J. Malick, J. Povh, F. Rendl, and A. Wiegele. Regularization methods for semidef-

inite programming. SIAM J. Optim., 20(1):336–356, 2009.

43. J. Malick and F. Roupin. Solving k-cluster problems to optimality with semideﬁnite

programming. Math. Program., 136(2 (B)):279–300, 2012.

44. G.P. McCormick. Computability of global solutions to factorable non-convex pro-
grams: Part i - convex underestimating problems. Mathematical Programming,
10(1):147–175, 1976.

45. D. Pisinger. Upper bounds and exact algorithms for p-dispersion problems. Com-

puters and Operations Research, 33:1380–1398, 2006.

46. M.-C. Plateau. Reformulations quadratiques convexes pour la programmation
quadratique en variables 0-1. Th`ese de doctorat en informatique, Conservatoire
National des Arts et M´etiers, Paris, 2006.

47. F. Roupin. From linear to semideﬁnite programming: an algorithm to obtain
semideﬁnite relaxations for bivalent quadratic problems. Journal of Combinatorial
Optimization, 8(4):469–493, 2004.

26

Alain Billionnet, Sourour Elloumi, Am´elie Lambert, Angelika Wiegele

48. N.V. Sahinidis and M. Tawarmalani. A polyhedral branch-and-cut approach to

global optimization. Mathematical Programming, 103(2):225–249, 2005.

49. N.V. Sahinidis and M. Tawarmalani. Baron 9.0.4: Global optimization of mixed-

integer nonlinear programs. User’s Manual, 2010.

50. E. M. B. Smith. On the optimal design of continuous processes. PhD thesis,
Imperial College of Science, Technology and Medicine, University of London, 1996.
51. E. M. B. Smith and C. C. Pantelides. Global optimisation of nonconvex minlps.

Computers and Chem. Engineering, 21:S791–S796, 1997.

52. E. M. B. Smith and C. C. Pantelides. A symbolic reformulation/spatial branch-
and-bound algorithm for the global optimisation of nonconvex minlps. Computers
and Chem. Engineering, 23:457–478, 1999.

53. A. Srivastav and K. Wolf. Finding dense subgraph with semideﬁnite program-
ming. Approximation Algorithms for Combinatorial Optimization, K. Jansen and
J. Rolim (Eds.), pages 181–191, 1998.

54. Jos F. Sturm. Using SeDuMi 1.02, a MATLAB toolbox for optimization over

symmetric cones. Optim. Methods Softw., 11-12(1-4):625–653, 1999.

55. M. Tawarmalani and N.V. Sahinidis. Convexiﬁcation and global optimization in
continuous and mixed-integer nonlinear programming. Kluwer Academic Publish-
ing, Dordrecht, The Netherlands, 2002.

56. X.-Y. Zhao, D. Sun, and K.-C Toh. A Newton-CG augmented Lagrangian method

for semideﬁnite programming. SIAM J. Optim., 20(4):1737–1765, 2010.

