6
1
0
2

 
r
a

M
1

 

 
 
]
S
D
.
s
c
[
 
 

1
v
3
1
2
0
0

.

3
0
6
1
:
v
i
X
r
a

An Optimal Algorithm for ℓ1-Heavy Hitters in Insertion Streams

and Related Problems

Arnab Bhattacharyya⋆, Palash Dey⋆, and David P. Woodruﬀ†

⋆Indian Institute of Science, Bangalore

†IBM Research, Almaden

⋆{arnabb,palash}@csa.iisc.ernet.in,† dpwoodru@us.ibm.com

Abstract

We give the ﬁrst optimal bounds for returning the ℓ1-heavy hitters in a data stream of insertions,
together with their approximate frequencies, closing a long line of work on this problem. For a stream
of m items in {1, 2, . . . , n} and parameters 0 < ε < ϕ 6 1, let fi denote the frequency of item i,
i.e., the number of times item i occurs in the stream. With arbitrarily large constant probability, our
algorithm returns all items i for which fi > ϕm, returns no items j for which fj 6 (ϕ − ε)m, and
returns approximations ˜fi with | ˜fi − fi| 6 εm for each item i that it returns. Our algorithm uses
O(ε−1 log ϕ−1 + ϕ−1 log n + log log m) bits of space, processes each stream update in O(1) worst-case
time, and can report its output in time linear in the output size. We also prove a lower bound, which
implies that our algorithm is optimal up to a constant factor in its space complexity. A modiﬁcation of
our algorithm can be used to estimate the maximum frequency up to an additive εm error in the above
amount of space, resolving Question 3 in the IITK 2006 Workshop on Algorithms for Data Streams
for the case of ℓ1-heavy hitters. We also introduce several variants of the heavy hitters and maximum
frequency problems, inspired by rank aggregation and voting schemes, and show how our techniques can
be applied in such settings. Unlike the traditional heavy hitters problem, some of these variants look at
comparisons between items rather than numerical values to determine the frequency of an item.

1

Introduction

The data stream model has emerged as a standard model for processing massive data sets. Because of the
sheer size of the data, traditional algorithms are no longer feasible, e.g., it may be hard or impossible to
store the entire input, and algorithms need to run in linear or even sublinear time. Such algorithms typically
need to be both randomized and approximate. Moreover, the data may not physically reside on any device,
e.g., if it is internet traﬃc, and so if the data is not stored by the algorithm, it may be impossible to recover
it. Hence, many algorithms must work given only a single pass over the data. Applications of data streams
include data warehousing [HSST05, BR99, FSG+98, HPDW01], network measurements [ABW03, CKMS08,
DLOM02, EV03], sensor networks [BGS01, SBAS04], and compressed sensing [GSTV07, CRT06]. We refer
the reader to recent surveys on the data stream model [Mut05, Nel12, Cor12].

One of the oldest and most fundamental problems in the area of data streams is the problem of ﬁnding the
ℓ1-heavy hitters (or simply, “heavy hitters”), also known as the top-k, most popular items, frequent items,
elephants, or iceberg queries. Such algorithms can be used as subroutines in network ﬂow identiﬁcation at
IP routers [EV03], association rules and frequent itemsets [AS94, SON95, Toi96, Hid99, HPY00], iceberg
queries and iceberg datacubes [FSG+98, BR99, HPDW01]. The survey [CH08] presents an overview of the
state-of-the-art for this problem, from both theoretical and practical standpoints.

We now formally deﬁne the heavy hitters problem that we focus on in this paper:

1

Deﬁnition 1. ((ε, ϕ)-Heavy Hitters Problem) In the (ε, ϕ)-Heavy Hitters Problem, we are given pa-
rameters 0 < ε < ϕ 6 1 and a stream a1, . . . , am of items aj ∈ {1, 2, . . . , n}. Let fi denote the number of
occurrences of item i, i.e., its frequency. The algorithm should make one pass over the stream and at the end
of the stream output a set S ⊆ {1, 2, . . . , n} for which if fi > ϕm, then i ∈ S, while if fi 6 (ϕ − ε)m, then
i /∈ S. Further, for each item i ∈ S, the algorithm should output an estimate ˜fi of the frequency fi which
satisﬁes |fi − ˜fi| 6 εm.

Note that other natural deﬁnitions of heavy hitters are possible and sometimes used. For example, ℓ2-
heavy hitters are those items i for which f 2
j , and more generally, ℓp-heavy hitters are those
items i for which f p
j . It is in this sense that Deﬁnition 1 corresponds to ℓ1-heavy hitters.
While ℓp-heavy hitters for p > 1 relax ℓ1-heavy hitters and algorithms for them have many interesting
applications, we focus on the most direct and common formulation of the heavy hitters notion.

i > ϕpPn

i > ϕ2Pn

j=1 f p

j=1 f 2

We are interested in algorithms which use as little space in bits as possible to solve the (ε, ϕ)-Heavy
Hitters Problem. Further, we are also interested in minimizing the update time and reporting time of such
algorithms. Here, the update time is deﬁned to be the time the algorithm needs to update its data structure
when processing a stream insertion. The reporting time is the time the algorithm needs to report the answer
after having processed the stream. We allow the algorithm to be randomized and to succeed with probability
at least 1 − δ for 0 < δ < 1. We do not make any assumption on the ordering of the stream a1, . . . , am.
This is desirable as often in applications one cannot assume a best-case or even a random order. We are also
interested in the case when the length m of the stream is not known in advance, and give algorithms in this
more general setting.

1

1

, where F res(k)

[DLOM02], and again by Karp et al.

The ﬁrst algorithm for the (ε, ϕ)-Heavy Hitters Problem was given by Misra and Gries [MG82], who
achieved O(ε−1(log n + log m)) bits of space for any ϕ > ε. This algorithm was rediscovered by Demaine et
[KSP03]. Other than these algorithms, which are deterministic,
al.
there are also a number of randomized algorithms, such as the CountSketch [CCFC04], Count-Min sketch
[CM05], sticky sampling [MM02], lossy counting [MM02], space-saving [MAE05], sample and hold [EV03],
multi-stage bloom ﬁlters [CFM09], and sketch-guided sampling [KX06]. Berinde et al. [BICS10] show that
using O(kε−1 log(mn)) bits of space, one can achieve the stronger guarantee of reporting, for each item i ∈ S,
˜fi with | ˜fi − fi| 6 ε/kF res(k)
< m denotes the sum of frequencies of items in {1, 2, . . . , n}
excluding the frequencies of the k most frequent items.
We emphasize that prior to our work the best known algorithms for the (ε, ϕ)-Heavy Hitters Problem
used O(ε−1(log n + log m)) bits of space. Two previous lower bounds were known. The ﬁrst is a lower bound

of log((cid:0) n

1/ϕ(cid:1)) = Ω(ϕ−1 log(ϕn)) bits, which comes from the fact that the output set S can contain ϕ−1 items

and it takes this many bits to encode them. The second lower bound is Ω(ε−1) which follows from a folklore
reduction from the randomized communication complexity of the Index problem. In this problem, there are
two players, Alice and Bob. Alice has a bit string x of length (2ε)−1, while Bob has an index i. Alice creates
a stream of length (2ε)−1 consisting of one copy of each j for which xj = 1 and copies of a dummy item
to ﬁll the rest of the stream. She runs the heavy hitters streaming algorithm on her stream and sends the
state of the algorithm to Bob. Bob appends (2ε)−1 copies of the item i to the stream and continues the
execution of the algorithm. For ϕ = 1/2, it holds that i ∈ S. Moreover, fi diﬀers by an additive εm factor
depending on whether xi = 1 or xi = 0. Therefore by the randomized communication complexity of the
Index problem [KNR99], the (ε, 1/2)-heavy hitters problem requires Ω(ε−1) bits of space. Although this proof
was for ϕ = 1/2, no better lower bound is known for any ϕ > ε.

Thus, while the upper bound for the (ε, ϕ)-Heavy Hitters Problem is O(ε−1(log n + log m)) bits, the
best known lower bound is only Ω(ϕ−1 log n + ε−1) bits. For constant ϕ, and log n ≈ ε−1, this represents a
nearly quadratic gap in upper and lower bounds. Given the limited resources of devices which typically run
heavy hitters algorithms, such as internet routers, this quadratic gap can be critical in applications.

A problem related to the (ε, ϕ)-Heavy Hitters Problem is estimating the maximum frequency in a
data stream, also known as the ℓ∞-norm. In the IITK 2006 Workshop on Algorithms for Data Streams,
Open Question 3 asks for an algorithm to estimate the maximum frequency of any item up to an additive εm
error using as little space as possible. The best known space bound is still O(ε−1 log n) bits, as stated in the
original formulation of the question (note that the “m” in the question there corresponds to the “n” here).

2

Problem

(ε, ϕ)-Heavy Hitters

ε-Maximum and ℓ∞-approximation

ε-Minimum

ε-Borda

ε-Maximin

Upper bound

Lower bound

Space complexity

[Theorem 1 and 7]

[Theorem 1 and 7]

O(cid:0)ε−1 log ϕ−1 + ϕ−1 log n + log log m(cid:1)
O(cid:0)ε−1 log ε−1 + log n + log log m(cid:1)
O(cid:0)ε−1 log log ε−1 + log log m(cid:1)
O(cid:0)n(log ε−1 + log n) + log log m(cid:1)
O(cid:0)nε−2 log2 n + log log m(cid:1)

[Theorem 5 and 8]

[Theorem 6 and 8]

[Theorem 4 and 8]

[Theorem 9 and 14]

Ω(cid:0)ε−1 log ϕ−1 + ϕ−1 log n + log log m(cid:1)
Ω(cid:0)ε−1 log ε−1 + log n + log log m(cid:1)

[Theorem 9 and 14]

Ω(cid:0)ε−1 + log log m(cid:1)

[Theorem 11 and 14]

[Theorem 12 and 14]

Ω(cid:0)n(log ε−1 + log n) + log log m(cid:1)
Ω(cid:0)n(ε−2 + log n) + log log m(cid:1)

[Theorem 13]

Table 1: The bounds hold for constant success probability algorithms and for n suﬃciently large in terms of ε. For
the (ε, ϕ)-Heavy Hitters problem and the ε-Maximum problem, we also achieve O(1) update time and reporting
time which is linear in the size of the output. The upper bound for ε-Borda (resp. ε-Maximin) is for returning
every item’s Borda score (resp. Maximin score) up to an additive εmn (resp. additive εm), while the lower bound
for ε-Borda (resp. ε-Maximin) is for returning only the approximate Borda score (resp. Maximin score) of an
approximate maximum.

Note that, if one can ﬁnd an item whose frequency is the largest, up to an additive εm error, then one can
solve this problem. The latter problem is independently interesting and corresponds to ﬁnding approximate
plurality election winners in voting streams [DB15]. We refer to this problem as the ε-Maximum problem.
Finally, we note that there are many other variants of the (ε, ϕ)-Heavy Hitters Problem that one
can consider. One simple variant of the above is to output an item of frequency within εm of the minimum
frequency of any item in the universe. We refer to this as the ε-Minimum problem. This only makes sense
for small universes, as otherwise outputting a random item typically works. This is useful when one wants
to count the “number of dislikes”, or in anomaly detection; see more motivation below. In other settings,
one may not have numerical scores associated with the items, but rather, each stream update consists of
a “ranking” or “total ordering” of all stream items. This may be the case in ranking aggregation on the
web (see, e.g., [MBG04, MYCC07]) or in voting streams (see, e.g., [CS05, CP11, DB15, Xia12]). One may
consider a variety of aggregation measures, such as the Borda score of an item i, which asks for the sum, over
rankings, of the number of items j 6= i for which i is ranked ahead of j in the ranking. Alternatively, one may
consider the Maximin score of an item i, which asks for the minimum, over items j 6= i, of the number of
rankings for which i is ranked ahead of j. For these aggregation measures, one may be interested in ﬁnding
an item whose score is an approximate maximum. This is the analogue of the ε-Maximum problem above.
Or, one may be interested in listing all items whose score is above a threshold, which is the analogue of the
(ε, ϕ)-Heavy Hitters Problem.

We give more motivation of these variants of heavy hitters in this section below, and more precise

deﬁnitions in Section 2.

1.1 Our Contributions

Our results are summarized in Table 1. We note that independently of this work and nearly parallelly,
there have been improvements to the space complexity of the ℓ2-heavy hitters problem in insertion streams
[BCIW16] and to the time complexity of the ℓ1-heavy hitters problem in turnstile1 streams [LNNT16]. These
works use very diﬀerent techniques.

1In a turnstile stream, updates modify an underlying n-dimensional vector x initialized at the zero vector; each update is of
the form x ← x + ei or x ← x − ei where ei is the i’th standard unit vector. In an insertion stream, only updates of the form
x ← x + ei are allowed.

3

Our ﬁrst contribution is an optimal algorithm and lower bound for the (ε, ϕ)-Heavy Hitters Problem.
Namely, we show that there is a randomized algorithm with constant probability of success which solves this
problem using

O(ε−1 log ϕ−1 + ϕ−1 log n + log log m)

bits of space, and we prove a lower bound matching up to constant factors. In the unit-cost RAM model with
O(log n) bit words, our algorithm has O(1) update time and reporting time linear in the output size, under
the standard assumptions that the length of the stream and universe size are at least poly(ε−1 log(1/ϕ)).
Furthermore, we can achieve nearly the optimal space complexity even when the length m of the stream is
not known in advance. Although the results of [BICS10] achieve stronger error bounds in terms of the tail,
which are useful for skewed streams, here we focus on the original formulation of the problem.

Next, we turn to the problem of estimating the maximum frequency in a data stream up to an additive

εm. We give an algorithm using

O(ε−1 log ε−1 + log n + log log m)

bits of space, improving the previous best algorithms which required space at least Ω(ε−1 log n) bits, and show
that our bound is tight. As an example setting of parameters, if ε−1 = Θ(log n) and log log m = O(log n),
our space complexity is O(log n log log n) bits, improving the previous Ω(log2 n) bits of space algorithm.
We also prove a lower bound showing our algorithm is optimal up to constant factors. This resolves Open
Question 3 from the IITK 2006 Workshop on Algorithms for Data Streams in the case of insertion streams,
for the case of “ℓ1-heavy hitters”. Our algorithm also returns the identity of the item with the approximate
maximum frequency, solving the ε-Maximum problem.

We then focus on a number of variants of these problems. We ﬁrst give nearly tight bounds for ﬁnding an
item whose frequency is within εm of the minimum possible frequency. While this can be solved using our
new algorithm for the (ε, ε)-Heavy Hitters Problem, this would incur Ω(ε−1 log ε−1 + log log m) bits of
space, whereas we give an algorithm using only O(ε−1 log log(ε−1) + log log m) bits of space. We also show a
nearly matching Ω(ε−1 + log log m) bits of space lower bound. We note that for this problem, a dependence
on n is not necessary since if the number of possible items is suﬃciently large, then outputting the identity
of a random item among the ﬁrst say, 10ε−1 items, is a correct solution with large constant probability.

Finally, we study variants of heavy hitter problems that are ranking-based. In this setting, each stream
update consists of a total ordering of the n universe items. For the ε-Borda problem, we give an algorithm
using O(n(log ε−1 + log log n) + log log m) bits of space to report the Borda score of every item up to an
additive εmn. We also show this is nearly optimal by proving an Ω(n log ε−1 + log log m) bit lower bound for
the problem, even in the case when one is only interested in outputting an item maximum Borda score up to
an additive εmn. For the ε-Maximin problem, we give an algorithm using O(nε−2 log2 n + log log m) bits
of space to report the maximin score of every item up to an additive εm, and prove an Ω(nε−2 + log log m)
bits of space lower bound even in the case when one is only interested in outputting the maximum maximin
score up to an additive εm. This shows that ﬁnding heavy hitters with respect to the maximin score is
signiﬁcantly more expensive than with respect to the Borda score.

1.2 Motivations for Variants of Heavy Hitters

While the (ε, ϕ)-Heavy Hitters and ε-Maximum problem are very well-studied in the data stream liter-
ature, the other variants introduced are not. We provide additional motivation for them here.

For the ε-Minimum problem, in our formulation, an item with frequency zero, i.e., one that does not
occur in the stream, is a valid solution to the problem. In certain scenarios, this might not make sense, e.g.,
if a stream containing only a small fraction of IP addresses. However, in other scenarios we argue this is
a natural problem. For instance, consider an online portal where users register complaints about products.
Here, minimum frequency items correspond to the “best” items. That is, such frequencies arise in the context
of voting or more generally making a choice: in cases for which one does not have a strong preference for
an item, but deﬁnitely does not like certain items, this problem applies, since the frequencies correspond to
“number of dislikes”.

4

The ε-Minimum problem may also be useful for anomaly detection. Suppose one has a known set of
sensors broadcasting information and one observes the “From:” ﬁeld in the broadcasted packets. Sensors
which send a small number of packets may be down or defective, and an algorithm for the ε-Minimum
problem could ﬁnd such sensors.

Finding items with maximum and minimum frequencies in a stream correspond to ﬁnding winners under
plurality and veto voting rules respectively in the context of voting2 [BCE+15]. The streaming aspect of
voting could be crucial in applications like online polling [KTW11], recommender systems [RV97, HKTR04,
AT05] where the voters are providing their votes in a streaming fashion and at every point in time, we would
like to know the popular items. While in some elections, such as for political positions, the scale of the
election may not be large enough to require a streaming algorithm, one key aspect of these latter voting-
based problems is that they are rank-based which is useful when numerical scores are not available. Orderings
naturally arise in several applications - for instance, if a website has multiple parts, the order in which a user
visits the parts given by its clickstream deﬁnes a voting, and for data mining and recommendation purposes
the website owner may be interested in aggregating the orderings across users. Motivated by this connection,
we deﬁne similar problems for two other important voting rules, namely Borda and maximin. The Borda
scoring method ﬁnds its applications in a wide range of areas of artiﬁcial intelligence, for example, machine
learning [HHS94, CP06, VZ14, PPR15], image processing [LN06, MG09], information retrieval [Li14, AM01,
NC06], etc. The Maximin score is often used when the spread between the best and worst outcome is very
large (see, e.g., p. 373 of [MR91]). The maximin scoring method also has been used frequently in machine
learning [WL04, JMP+14], human computation [MPC12, MPC13], etc.

2 Preliminaries

We denote the disjoint union of sets by ⊔. We denote the set of all permutations of a set U by L(U). For
a positive integer ℓ, we denote the set {1, . . . , ℓ} by [ℓ]. In most places, we ignore ﬂoors and ceilings for the
sake of notational simplicity.

2.1 Model of Input Data
The input data is an insertion-only stream of elements from some universe U. In the context of voting, the
input data is an insertion-only stream over the universe of all possible rankings (permutations).

2.2 Communication Complexity

We will use lower bounds on communication complexity of certain functions to prove space complexity lower
bounds for our problems. Communication complexity of a function measures the number of bits that need to
be exchanged between two players to compute a function whose input is split among those two players [Yao79].
In a more restrictive one-way communication model, Alice, the ﬁrst player, sends only one message to Bob,
the second player, and Bob outputs the result. A protocol is a method that the players follow to compute
certain functions of their input. Also the protocols can be randomized; in that case, the protocol needs to
output correctly with probability at least 1 − δ, for δ ∈ (0, 1) (the probability is taken over the random
coin tosses of the protocol). The randomized one-way communication complexity of a function f with error
probability δ is denoted by R1-way

(f ). [KN97] is a standard reference for communication complexity.

δ

2.3 Model of Computation

Our model of computation is the unit-cost RAM model on words of size O(log n), capable of generating
uniformly random words and of performing arithmetic operations in {+,−, log2} in one unit of time. We
note that this model of computation has been used before [DHKP97]. We store an integer C using a variable
length array of [BB08] which allows us to read and update C in O(1) time and O(log C) bits of space.

2In fact, the ﬁrst work [Moo81] to formally pose the heavy hitters problem couched it in the context of voting.

5

2.4 Universal Family of Hash Functions

Deﬁnition 2. (Universal family of hash functions)
A family of functions H = {h|h : A → B} is called a universal family of hash functions if for all a 6= b ∈ A,
Pr{h(a) = h(b)} = 1/|B|, where h is picked uniformly at random from H.

We know that there exists a universal family of hash functions H from [k] to [ℓ] for every positive integer

ℓ and every prime k [LRSC01]. Moreover, |H|, the size of H, is O(k2).

2.5 Problem Deﬁnitions

We now formally deﬁne the problems we study here. Suppose we have 0 < ε < ϕ < 1.

Deﬁnition 3. (ε, ϕ)-List heavy hitters
Given an insertion-only stream of length m over a universe U of size n, ﬁnd all items in U with frequency
more than ϕm, along with their frequencies up to an additive error of εm, and report no items with frequency
less than (ϕ − ε)m.
Deﬁnition 4. ε-Maximum
Given an insertion-only stream of length m over a universe U of size n, ﬁnd the maximum frequency up to
an additive error of εm.

Next we deﬁne the minimum problem for 0 < ε < 1.

Deﬁnition 5. ε-Minimum
Given an insertion-only stream of length m over a universe U of size n, ﬁnd the minimum frequency up to
an additive error of εm.

Next we deﬁne related heavy hitters problems in the context of rank aggregation. The input is a stream
of rankings (permutations) over an item set U for the problems below. The Borda score of an item i is the
sum, over all rankings, of the number of items j 6= i for which i is ranked ahead of j in the ranking.
Deﬁnition 6. (ε, ϕ)-List borda
Given an insertion-only stream over a universe L(U) where |U| = n, ﬁnd all items with Borda score more
than ϕmn, along with their Borda score up to an additive error of εmn, and report no items with Borda
score less than (ϕ − ε)mn.
Deﬁnition 7. ε-Borda
Given an insertion-only stream over a universe L(U) where |U| = n, ﬁnd the maximum Borda score up to
an additive error of εmn.

The maximin score of an item i is the minimum, over all items j 6= i, of the number of rankings for which

i is ranked ahead of j.

Deﬁnition 8. (ε, ϕ)-List maximin
Given an insertion-only stream over a universe L(U) where |U| = n, ﬁnd all items with maximin score more
than ϕm along with their maximin score up to an additive error of εm, and report no items with maximin
score less than (ϕ − ε)m.
Deﬁnition 9. ε-maximin
Given an insertion-only stream over a universe L(U) where |U| = n, ﬁnd the maximum maximin score up
to an additive error of εm.

Notice that the maximum possible Borda score of an item is m(n − 1) = Θ(mn) and the maximum
possible maximin score of an item is m. This justiﬁes the approximation factors in Deﬁnition 6 to 9.
We note that ﬁnding an item with maximum Borda score within additive εmn or maximum maximin score
within additive εm corresponds to ﬁnding an approximate winner of an election (more precisely, what is
known as an ε-winner) [DB15].

6

3 Algorithms

In this section, we present our upper bound results. All omitted proofs are in Appendix B. Before describing
speciﬁc algorithms, we record some claims for later use. Lemma 1 follows by checking whether we get all
heads in log m tosses of a fair coin.
Lemma 1. Suppose m is a power of two3. Then there is an algorithm A for choosing an item with probability
1/m that has space complexity of O(log log m) bits and time complexity of O(1) in the unit-cost RAM model.

Proof. We generate a (log2 m)-bit integer C uniformly at random and record the sum of the digits in C.
Choose the item only if the sum of the digits is 0, i.e. if C = 0.

We remark that the algorithm in Lemma 1 has optimal space complexity as shown in Proposition 2 in

Appendix B.

Our second claim is a standard result for universal families of hash functions.

Lemma 2. For S ⊆ A, δ ∈ (0, 1), and universal family of hash functions H = {h|h : A → [⌈|S|2/δ⌉]}:

Pr

h∈U H

[∃i 6= j ∈ S, h(i) = h(j)] 6 δ

Proof. For every i 6= j ∈ S, since H is a universal family of hash functions, we have Prh∈UH[h(i) = h(j)] 6
⌈|S|2/δ⌉ . Now we apply the union bound to get Prh∈U H[∃i 6= j ∈ S, h(i) = h(j)] 6

⌈|S|2/δ⌉

6 δ

|S|2

1

Our third claim is folklore and also follows from the celebrated DKW inequality [DKW56]. We provide

a simple proof here that works for constant δ.
Lemma 3. Let fi and ˆfi be the frequencies of an item i in a stream S and in a random sample T of
size r from S, respectively. Then for r > 2ε−2 log(2δ−1), with probability 1 − δ, for every universe item i
simultaneously,

Cm . By the union bound, if we sample
m , then the probability there exists an i for which

1
100 , as desired.

ε2 for a constant C > 0 makes this probability at most 4fi

Setting r = C
each element in the stream independently with probability r
| ˆfi − E[ ˆfi]| > rε

C , which for C > 400 is at most

4fi
Cm

6 4

i=1

2 is at most Pn

For now, assume that the length of the stream is known in advance; we show in Section 3.5 how to remove

this assumption.

3In all our algorithms, whenever we pick an item with probability p > 0, we can assume, without loss of generality, that 1/p
is a power of two. If not, then we replace p with p′ where 1/p′ is the largest power of two less than 1/p. This does not aﬀect
correctness and performance of our algorithms.

7

6 ε.

ˆfi
r −

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

fi

m(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

Proof for constant δ. This follows by Chebyshev’s inequality and a union bound. Indeed, consider a given i ∈
[n] with frequency fi and suppose we sample each of its occurrences pairwise-independently with probability
r/m, for a parameter r. Then the expected number E[ ˆfi] of sampled occurrences is fi · r/m and the variance
Var[ ˆfi] is fi · r/m(1 − r/m) 6 fir/m. Applying Chebyshev’s inequality,
4fir
mr2ε2 .

Var[ ˆfi]
(rε/2)2

rε

6

Prh(cid:12)(cid:12)(cid:12)

ˆfi − E[ ˆfi](cid:12)(cid:12)(cid:12) >

2 i 6

3.1 List Heavy Hitters

For the (ε, ϕ)-List heavy hitters problem, we present two algorithms. The ﬁrst is slightly suboptimal, but
simple conceptually and already constitutes a very large improvement in the space complexity over known
algorithms. We expect that this algorithm could be useful in practice as well. The second algorithm is more
complicated, building on ideas from the ﬁrst algorithm, and achieves the optimal space complexity upto
constant factors.

We note that both algorithms proceed by sampling O(ε−2 ln(1/δ)) stream items and updating a data
structure as the stream progresses. In both cases, the time to update the data structure is bounded by
O(1/ε), and so, under the standard assumption that the length of the stream is at least poly(ln(1/δ)ε),
the time to perform this update can be spread out across the next O(1/ε) stream updates, since with large
probability there will be no items sampled among these next O(1/ε) stream updates. Therefore, we achieve
worst-case4 update time of O(1).

3.1.1 A simpler, near-optimal algorithm

Theorem 1. Assume the stream length is known beforehand. Then there is a randomized one-pass algo-
rithm A for the (ε, ϕ)-List heavy hitters problem which succeeds with probability at least 1 − δ using
O(cid:0)ε−1(log ε−1 + log log δ−1) + ϕ−1 log n + log log m(cid:1) bits of space. Moreover, A has an update time of O(1)
and reporting time linear in its output size.

Overview The overall idea is as follows. We sample ℓ = O(ε−2) many items from the stream uniformly at
random as well as hash the id’s (the word “id” is short for identiﬁer) of the sampled elements into a space
of size O(ε−4). Now, both the stream length as well as the universe size are poly(ε−1). From Lemma 3,
it suﬃces to solve the heavy hitters problem on the sampled stream. From Lemma 2, because the hash
function is chosen from a universal family, the sampled elements have distinct hashed id’s. We can then feed
these elements into a standard Misra-Gries data structure with ε−1 counters, incurring space O(ε−1 log ε−1).
Because we want to return the unhashed element id’s for the heavy hitters, we also use log n space for
recording the ϕ−1 top items according to the Misra-Gries data structure and output these when asked to
report.

Proof of Theorem 1. The pseudocode of our (ε, ϕ)-List heavy hitters algorithm is in Algorithm 1. By
Lemma 3, if we select a subset S of size at least ℓ = 6ε−2log(6δ−1) uniformly at random from the stream,
then Pr[∀i ∈ U,|( ˆfi/|S|) − (fi/n)| 6 ε] > 1 − δ/3, where fi and ˆfi are the frequencies of item i in the input
stream and S respectively. First we show that with the choice of p in line 10 in Algorithm 1, the number
of items sampled is at least ℓ and at most 11ℓ with probability at least (1 − δ/3). Let Xi be the indicator
random variable of the event that the item xi is sampled for i ∈ [m]. Then the total number of items sampled
X =Pm

i=1 Xi. We have E[X] = 6ℓ since p = 6ℓ/m. Now we have the following.

Pr[X 6 ℓ or X > 11ℓ] 6 Pr[|X − E[X]| > 5ℓ] 6 δ/3

The inequality follows from the Chernoﬀ bound and the value of ℓ. From here onwards we assume that the
number of items sampled is in [ℓ, 11ℓ].

We use (a modiﬁed version of) the Misra-Gries algorithm [MG82] to estimate the frequencies of items
in S. The length of the table in the Misra-Gries algorithm is ε−1. We pick a hash function h uniformly at
random from a universal family H = {h|h : [n] → ⌈4ℓ2/δ⌉} of hash functions of size |H| = O(n2). Note that
picking a hash function h uniformly at random from H can be done using O(log n) bits of space. Lemma 2
shows that there are no collisions in S under this hash function h with probability at least 1− δ/3. From here
onwards we assume that there is no collision among the ids of the sampled items under the hash function h.
We modify the Misra-Gries algorithm as follows. Instead of storing the id of any item x in the Misra-Gries
table (table T1 in line 5 in Algorithm 1) we only store the hash h(x) of the id x. We also store the ids (not

4We emphasize that this is stronger than an amortized guarantee, as on every insertion, the cost will be O(1).

8

Algorithm 1 for (ε, ϕ)-List heavy hitters
Input: A stream S of length m over U = [n]; let f (x) be the frequency of x ∈ U in S
Output: A set X ⊆ U and a function ˆf : X → N such that if f (x) > ϕm, then x ∈ X and f (x) − εm 6
1: Initialize:

ˆf (x) 6 f (x) + εm and if f (y) 6 (ϕ − ε)m, then y /∈ X for every x, y ∈ U
2: ℓ ← 6 log(6/δ)/ε2
3: Hash function h uniformly at random from a universal family H ⊆ {h : [n] → ⌈4ℓ2/δ⌉}.
4: An empty table T1 of (key, value) pairs of length ε−1. Each key entry of T1 can store an

integer in [0,⌈400ℓ2/δ⌉] and each value entry can store an integer in [0, 11ℓ].
will be in sorted order by value throughout.

⊲ The table T1
5: An empty table T2 of length 1/ϕ. Each entry of T2 can store an integer in [0, n]. ⊲ The entries

of T2 will correspond to ids of the keys in T1 of the highest 1/ϕ values

6:
7: procedure Insert(x)
8: With probability p = 6ℓ/m, continue. Otherwise, return .
9:
10:

Perform Misra-Gries update using h(x) maintaining T1 sorted by values.
if The value of h(x) is among the highest 1/ϕ valued items in T1 then

if xi is not in T2 then

if T2 currently contains 1/ϕ many items then

For y in T2 such that h(y) is not among the highest 1/ϕ valued items in T1, replace y with

11:

12:
13:

14:
15:

16:

x.

else

We put x in T2.

Ensure that elements in T2 are ordered according to corresponding values in T1.

17:
18: procedure Report( )
19:

return items in T2 along with their corresponding values in T1

the hash of the id) of the items with highest 1/ϕ values in T1 in another table T2. Moreover, we always
maintain the table T2 consistent with the table T1 in the sense that the ith highest valued key in T1 is the
hash of the ith id in T2.
Upon picking an item x with probability p, we create an entry corresponding to h(x) in T1 and make
its value one if there is space available in T1; decrement the value of every item in T1 by one if the table is
already full; increment the entry in the table corresponding to h(x) if h(x) is already present in the table.
When we decrement the value of every item in T1, the table T2 remains consistent and we do not need to
do anything else. Otherwise there are three cases to consider. Case 1: h(x) is not among the 1/ϕ highest
valued items in T1. In this case, we do not need to do anything else. Case 2: h(x) was not among the 1/ϕ
highest valued items in T1 but now it is among the 1/ϕ highest valued items in T1. In this case the last item
y in T2 is no longer among the 1/ϕ highest valued items in T1. We replace y with x in T2. Case 3: h(x) was
among the 1/ϕ highest valued items in T1. When the stream ﬁnishes, we output the ids of all the items in
table T2 along with the values corresponding to them in table T1. Correctness follows from the correctness
of the Misra-Gries algorithm and the fact that there is no collision among the ids of the sampled items.

3.1.2 An optimal algorithm

Theorem 2. Assume the stream length is known beforehand. Then there is a randomized one-pass al-
gorithm A for the (ε, ϕ)-List heavy hitters problem which succeeds with constant probability using
O(cid:0)ε−1 log ϕ−1 + ϕ−1 log n + log log m(cid:1) bits of space. Moreover, A has an update time of O(1) and reporting
time linear in its output size.

Note that in this section, for the sake of simplicity, we ignore ﬂoors and ceilings and state the results for

9

a constant error probability, omitting the explicit dependence on δ.

Algorithm 2 for (ε, ϕ)-List heavy hitters
Input: A stream S of length m over universe U = [n]; let f (x) be the frequency of x ∈ U in S
Output: A set X ⊆ U and a function ˆf : X → N such that if f (x) > ϕm, then x ∈ X and f (x) − εm 6
1: Initialize:

ˆf (x) 6 f (x) + εm and if f (y) 6 (ϕ − ε)m, then y /∈ X for every x, y ∈ U
2: ℓ ← 105ε−2
3: s ← 0
4: Hash functions h1, . . . , h200 log(12ϕ−1) uniformly at random from a universal family

H ⊆ {h : [n] → [100/ε]}.
element of [n] and each value entry can store an integer in [0, 10ℓ].

5: An empty table T1 of (key, value) pairs of length 2ϕ−1. Each key entry of T1 can store an
6: An empty table T2 with 100ε−1 rows and 200 log(12ϕ−1) columns. Each entry of T2 can
7: An empty 3-dimensional table T3 of size at most 100ε−1 × 200 log(12ϕ−1) × 4 log(ε−1). Each
⊲ These are upper bounds; not all the allowed

store an integer in [0, 100εℓ].

entry of T3 can store an integer in [0, 10ℓ].
cells will actually be used.

8:
9: procedure Insert(x)
10: With probability ℓ/m, increment s and continue. Else, return
11:

Perform Misra-Gries update on T1 with x.
for j ← 1 to 200 log(12ϕ−1) do

i ← hj(x)
With probability ε, increment T2[i, j]
t ← ⌊log(10−6T2[i, j]2)⌋ and p ← min(ε · 2t, 1)
if t > 0 then

With probability p, increment T3[i, j, t]

18:
19: procedure Report( )
20:

X ← ∅
for each key x with nonzero value in T1 do

t=0

for j ← 1 to 200 log(12ϕ−1) do
ˆfj(x) ←P4 log(ε−1)
ˆf (x) ← median( ˆf1, . . . , ˆf10 log ϕ−1)
if ˆf (x) > (ϕ − ε/2)s then
X ← X ∪ {x}

return X, ˆf

T3[h(x), j, t]/ min(ε2t, 1)

12:
13:

14:
15:

16:

17:

21:

22:

23:

24:

25:
26:

27:

Overview As in the simpler algorithm, we sample ℓ = O(ε−2) many stream elements and solve the (ε/2, ϕ)-
List heavy hitters problem on this sampled stream. Also, the Misra-Gries algorithm for (ϕ/2, ϕ)-List
heavy hitters returns a candidate set of O(ϕ−1) items containing all items of frequency at least ϕℓ. It
remains to count the frequencies of these O(ϕ−1) items with upto εℓ/2 = O(ε−1) additive error, so that we
can remove those whose frequency is less than (ϕ − ε/2)ℓ.
Fix some item i ∈ [n], and let fi be i’s count in the sampled stream. A natural approach to count fi
approximately is to increment a counter probabilistically, instead of deterministically, at every occurrence of
i. Suppose that we increment a counter with probability 0 6 pi 6 1 whenever item i arrives in the stream.
Let the value of the counter be ˆci, and let ˆfi = ˆci/pi. We see that Eh ˆfii = fi and Var[ ˆfi] 6 fi/pi.
It
follows that if pi = Θ(ε2fi), then Var[ ˆfi] = O(ε−2), and hence, ˆfi is an unbiased estimator of fi with additive

10

error O(ε−1) with constant probability. We call such a counter an accelerated counter as the probability of
incrementing accelerates with increasing counts. For each i, we can maintain O(log ϕ−1) accelerated counters
independently and take their median to drive the probability of deviating by more than O(ε−1) down to
O(ϕ). So, with constant probability, the frequency for each of the O(ϕ−1) items in the Misra-Gries data
structure is estimated within O(ε−1) error, as desired.

However, there are two immediate issues with this approach. The ﬁrst problem is that we may need to
keep counts for Ω(ℓ) = Ω(ε−2) distinct items, which is too costly for our purposes. To get around this, we
use a hash function from a universal family to hash the universe to a space of size u = Θ(ε−1), and we work
throughout with the hashed id’s. We can then show that the space complexity for each iteration is O(ε−1).
Also, the accelerated counters now estimate frequencies of hashed id’s instead of actual items, but because
of universality, the expected frequency of any hashed id is ℓ/u = O(ε−1), our desired error bound.

The second issue is that we need a constant factor approximation of fi, so that we can set pi to Θ(ε2fi).
But because the algorithm needs to be one-pass, we cannot ﬁrst compute pi in one pass and then run the
accelerated counter in another. So, we divide the stream into epochs in which fi stays within a factor of 2,
and use a diﬀerent pi for each epoch. In particular, set pt
i = ε · 2t for 0 6 t 6 log(pi/ε). We want to keep a
running estimate of i’s count to within a factor of 2 to know if the current epoch should be incremented. For
this, we subsample each element of the stream with probability ε independently and maintain exact counts
for the observed hashed id’s. It is easy to see that this requires only O(ε−1) bits in expectation. Consider
any i ∈ [u] and the preﬁx of the stream upto b 6 ℓ, and let fi(b) be i’s frequency in the preﬁx, let ¯ci(b) be i’s
. We see that E(cid:2) ¯fi(b)(cid:3) = fi(b), Moreover, we
frequency among the samples in the preﬁx, and ¯fi(b) = ¯ci(b)
ε
show that for any b ∈ [ℓ], ¯fi(b) is a 4-factor approximation of fi(b) with constant probability. By repeating
O(log ϕ−1) times independently and taking the median, the error probability can be driven down to O(ϕ).
Now, for every hashed id i ∈ [u], we need not one accelerated counter but O(log(εfi)) many, one corre-
sponding to each epoch t. When an element with hash id i arrives at position b, we decide, based on ¯fi(b),
the epoch t it belongs to and then increment the t’th accelerated counter with probability pt
i. The storage
cost over all i is still O(1/ε). Also, we iterate the whole set of accelerated counters O(log ϕ−1) times, making
the total storage cost O(ε−1 log ϕ−1).

Let ˆci,t be the count in the accelerated counter for hash id i and epoch t. Then, let ˆfi = Pt ˆci,t/pt
Clearly, Eh ˆfii = fi. The variance is O(ε−2) in each epoch, and so, Var[ ˆfi] = O(ε−2 log ε−1), not O(ε−2)

which we wanted. This issue is ﬁxed by a change in how the sampling probabilities are deﬁned. We now go
on to the formal proof.

i.

Proof of Theorem 2. Pseudocode appears in Algorithm 2. Note that the numerical constants are chosen for
convenience of analysis and have not been optimized. Also, for the sake of simplicity, the pseudocode does
not have the optimal reporting time, but it can be modiﬁed to achieve this; see the end of this proof for
details.

By standard Chernoﬀ bounds, with probability at least 99/100, the length of the sampled stream ℓ/10 6
s 6 10ℓ. For x ∈ [n], let fsamp(x) be the frequency of x in the sampled stream. By Lemma 3, with probability
at least 9/10, for all x ∈ [n]:

is

s

s − fsamp(x)

Now, ﬁx j ∈ [10 log ϕ−1] and x ∈ [n]. Let i = hj(x) and fi = Py:hj(y)=hj (x) fsamp(y). Then, for a random
hj ∈ H, the expected value of fi
100 , since H is a universal mapping to a space of size 100ε−1.
Hence, using Markov’s inequality and the above:
Pr(cid:20)(cid:12)(cid:12)(cid:12)(cid:12)

In Lemma 4 below, we show that for each j ∈ [200 log(12ϕ−1)], with error probability at most 3/10, ˆfj(x)
(in line 23) estimates fi with additive error at most 5000ε−1, hence estimating fi
s with additive error at
most ε
2 . Taking the median over 200 log(12ϕ−1) repetitions (line 24) makes the error probability go down

2(cid:21) 6 Pr(cid:20)(cid:12)(cid:12)(cid:12)(cid:12)

4(cid:21) + Pr(cid:20)(cid:12)(cid:12)(cid:12)(cid:12)

f (x)
m −

f (x)
m −

ε

4(cid:21) <

fi

s(cid:12)(cid:12)(cid:12)(cid:12)

fi

s(cid:12)(cid:12)(cid:12)(cid:12)

m −

fsamp(x)

ε

>

ε

>

fsamp

1
10

+

<

1
25

3
20

(cid:12)(cid:12)(cid:12)(cid:12)

(1)

>

s

fsamp(x)

(cid:12)(cid:12)(cid:12)(cid:12)

s

ε

6

ε
4

−

f (x)

m (cid:12)(cid:12)(cid:12)(cid:12)

11

6 using standard Chernoﬀ bounds. Hence, by the union bound, with probability at least 2/3, for each of
m within additive error ε, thus showing

to ϕ
the 2/ϕ keys x with nonzero values in T1, we have an estimate of f (x)
correctness.
Lemma 4. Fix x ∈ [n] and j ∈ [200 log 12ϕ−1], and let i = hj(x). Then, Pr[| ˆfj(x)− fi| > 5000ε−1] 6 3/10,
where ˆfj is the quantity computed in line 23.

Proof. Index the sampled stream elements 1, 2, . . . , s, and for b ∈ [s], let fi(b) be the frequency of items with
hash id i restricted to the ﬁrst b elements of the sampled stream. Let ¯fi(b) denote the value of T2[i, j] · ε−1
after the procedure Insert has been called for the ﬁrst b items of the sampled stream.
Claim 1. With probability at least 9/10, for all b ∈ [s] such that fi(b) > 100ε−1, ¯fi(b) is within a factor of
4 of fi(b).
Proof. Fix b ∈ [s]. Note that E(cid:2) ¯fi(b)(cid:3) = fi(b) as T2 is incremented with rate ε. Var[ ¯fi(b)] 6 fi/ε, and so by

Chebyshev’s inequality:

Pr[| ¯fi(b) − fi(b)| > fi(b)/2] <

4

fi(b)ε

We now break the stream into chunks, apply this inequality to each chunk and then take a union bound to
conclude. Namely, for any integer t > 0, deﬁne bt to be the ﬁrst b such that 100ε−12t 6 fi(b) < 100ε−12t+1
if such a b exists. Then:

Pr[∃t > 0 : | ¯fi(bt) − fi(bt)| > fi(bt)/2] <Xt

<

1
10

4

100 · 2t−1

So, with probability at least 9/10, every ¯fi(bt) and fi(bt) are within a factor of 2 of each other. Since for
every b > b0, fi(b) is within a factor of 2 from some fi(bt), the claim follows.

Assume the event in Claim 1 henceforth. Now, we are ready to analyze T3 and in particular, ˆfj(x). First
of all, observe that if t < 0 in line 15, at some position b in the stream, then T2[i, j] at that time must be at
most 1000, and so by standard Markov and Chernoﬀ bounds, with probability at least 0.85,

fi(b)(< 4000ε−1,
Assume this event. Then, fi − 4000ε−1 6 Eh ˆfj(x)i 6 fi.

> 100ε−1,

Claim 2.

Var( ˆfj(x)) 6 20000ε−2

if t < 0
if t > 0

(2)

Proof. If the stream element at position b causes an increment in T3 with probability ε2t (in line 17), then
1000 · 2t/2 6 T2[i, j] 6 1000 · 2(t+1)/2, and so, ¯fi(b) 6 1000ε−12(t+1)/2. This must be the case for the highest
b = ¯bt at which the count for i in T3 increments at the t’th slot. The number of such occurrences of i is at
most fi(¯bt) 6 4 ¯fi(¯bt) 6 4000ε−12(t+1)/2 by Claim 1 (which can be applied since fi(b) > 100ε−1 by Equation
2). So:

Var[ ˆfj(x)] 6Xt>0

fi(¯bt)
ε2t

6Xt>0

4000
ε2 2−t/3 6 20000ε−2

Elements inserted with probability 1 obviously do not contribute to the variance.

12

So, conditioning on the events mentioned, the probability that ˆfj(x) deviates from fi by more than

5000ε−1 is at most 1/50. Removing all the conditioning yields what we wanted:

Pr[| ˆfj(x) − fi| > 5000ε−1] 6

1
50

+

3
20

+

1
10

6 0.3

We next bound the space complexity.

The probability that a hashed id i gets counted in table T3 is at most 10−6ε3 ¯f 2

Claim 3. With probability at least 2/3, Algorithm 2 uses O(ε−1 log ϕ−1 + ϕ−1 log n + log log m) bits of
storage, if n = ω(ε−1).
Proof. The expected length of the sampled stream is ℓ = O(ε−2). So, the number of bits stored in T1 is
O(ϕ−1 log n). For T2, note that in lines 13-15, for any given j, T2 is storing a total of εℓ = O(ε−1) elements
in expectation. So, for k > 0, there can be at most O((ε2k)−1) hashed id’s with counts between 2k and 2k+1.
Summing over all k’s and accounting for the empty cells gives O(ε−1) bits of storage, and so the total space
requirement of T2 is O(ε−1 log ϕ−1). .
i (s) from line 15 and our
deﬁnition of ¯fi above. Moreover, from Claim 1, we have that this is at most 16 · 10−6ε3f 2
i (s) if fi > 100ε−1.
Therefore, if fi = 2k · 100ε−1 with k > 0, then the expected value of a cell in T3 with ﬁrst coordinate i is at
most 1600 · 22kε = 2O(k). Taking into account that there are at most O((ε2k)−1) many such id’s i and that
the number of epochs t associated with such an i is at most log(16 · 10−6ε2f 2
i ) = O(log(εfi)) = O(k) (from
line 15), we get that the total space required for T3 is:
O((ε2k)−1) · O(k) · O(k)!
Xk=0

∞

O(log ϕ−1)

Xj=1  O(ε−1) +

= O(ε−1 log ϕ−1)

where the ﬁrst O(ε−1) term inside the summation is for the i’s with fi < 100ε−1. Since we have an expected
space bound, we obtain a worst-case space bound with error probability 1/3 by a Markov bound.

The space required for sampling is an additional O(log log m), using Lemma 1.

We note that the space bound can be made worst case by aborting the algorithm if it tries to use more

space.

The only remaining aspect of Theorem 2 is the time complexity. As observed in Section 3.1, the update
time can be made O(1) per insertion under the standard assumption of the stream being suﬃciently long.
The reporting time can also be made linear in the output by changing the bookkeeping a bit. Instead of
computing ˆfj and ˆf at reporting time, we can maintain them after every insertion. Although this apparently
makes INSERT costlier, this is not true in fact because we can spread the cost over future stream insertions.
The space complexity grows by a constant factor.

3.2 Maximum

By tweaking Algorithm 1 slightly, we get the following result for the ε-Maximum problem.

Theorem 3. Assume the length of the stream is known beforehand. Then there is a randomized one-
pass algorithm A for the ε-Maximum problem which succeeds with probability at least 1 − δ using
O (min{1/ε, n}(log 1/ε + log log 1/δ) + log n + log log m) bits of space. Moreover, the algorithm A has an up-
date time of O(1).

Proof. Instead of maintaining the table T2 in Algorithm 1, we just store the actual id of the item with
maximum frequency in the sampled items.

13

3.3 Minimum

Theorem 4. Assume the length of the stream is known beforehand. Then there is a randomized
one-pass algorithm A for the ε-Minimum problem which succeeds with probability at least 1 − δ using
O ((1/ε) log log(1/εδ) + log log m) bits of space. Moreover, the algorithm A has an update time of O(1).

Overview Pseudocode is provided in Algorithm 3. The idea behind our ε-Minimum problem is as follows.
It is most easily explained by looking at the REPORT(x) procedure starting in line 13. In lines 14-15 we
ask, is the universe size |U| signiﬁcantly larger than 1/ε? Note that if it is, then outputting a random item
from |U| is likely to be a solution. Otherwise |U| is O(1/ε).
The next point is that if the number of distinct elements in the stream were smaller than 1/(ε log(1/ε)),
then we could just store all the items together with their frequencies with O(1/ε) bits of space. Indeed,
we can ﬁrst sample O(1/ε2) stream elements so that all relative frequencies are preserved up to additive ε,
thereby ensuring each frequency can be stored with O(log(1/ε) bits. Also, since the universe size is O(1/ε),
the item identiﬁers can also be stored with O(log(1/ε) bits. So if this part of the algorithm starts taking
up too much space, we stop, and we know the number of distinct elements is at least 1/(ε log(1/ε)), which
means that the minimum frequency is at most O(mε log(1/ε)). This is what is being implemented in steps
9-10 and 18-19 in the algorithm.

We can also ensure the minimum frequency is at least Ω(mε/ log(1/ε)). Indeed, by randomly sampling
O((log(1/ε)/ε) stream elements, and maintaining a bit vector for whether or not each item in the universe
occurs - which we can with O(1/ε) bits of space since |U| = O(1/ε) - any item with frequency at least
Ω(εm/ log(1/ε)) will be sampled and so if there is an entry in the bit vector which is empty, then we can
just output that as our solution. This is what is being implemented in steps 8 and 16-17 of the algorithm.
Finally, we now know that the minimum frequency is at least Ω(mε/ log(1/ε)) and at most O(mε log(1/ε)).
At this point if we randomly sample O((log6 1/ε)/ε) stream elements, then by Chernoﬀ bounds all item
frequencies are preserved up to a relative error factor of (1 ± 1/ log2(1/ε)), and in particular the relative
minimum frequency is guaranteed to be preserved up to an additive ε. At this point we just maintain the
exact counts in the sampled stream but truncate them once they exceed poly(log(1/ε))) bits, since we know
such counts do not correspond to the minimum. Thus we only need O(log log(1/ε)) bits to represent their
counts. This is implemented in step 11 and step 20 of the algorithm.

Proof of Theorem 4. The pseudocode of our ε-Minimum algorithm is in Algorithm 3.
If the size of the
universe |U| is at least 1/((1−δ)ε), then we return an item x chosen from U uniformly at random. Note that
there can be at most 1/ε many items with frequency at least εm. Hence every item x among other remaining
δ/((1−δ)ε) many items has frequency less than εm and thus is a correct output of the instance. Thus the
probability that we answer correctly is at least (1 − δ). From here on, let us assume |U| < 1/((1−δ)ε).
Now, by the value of pj, it follows from the proof of Theorem 1 that we can assume ℓj < |Sj| < 11ℓj
for j = 1, 2, 3 which happens with probability at least (1 − (δ/3)). We ﬁrst show that every item in U with
frequency at least εm is sampled in S1 with probability at least (1 − (δ/6)). For that, let X j
i be the indicator
random variable for the event that the jth sample in S1 is item i where i ∈ U is an item with frequency at
least εm. Let H ⊂ U be the set of items with frequencies at least εm. Then we have the following.

Pr[X j
⇒ Pr[X j

i = 0] = 1 − ε
i = 0 ∀j ∈ S1] 6 (1 − ε)ℓ1 6 exp{−εℓ1} = εδ/6

Now applying union bound we get the following.

Pr[∃i ∈ H, X j

i = 0 ∀j ∈ S1] 6 (1/ε)εδ/6 6 δ/6

Hence with probability at least (1 − (δ/3) − (δ/6)) > (1 − δ), the output at line 17 is correct. Now we show
below that if the frequency of any item x ∈ U is at most ε ln(6/δ)/ln(6/εδ), then x ∈ S1 with probability at least
(1 − (δ/6)).

Pr[x /∈ S1] = (1 − ε ln(6/δ)/ln(6/εδ))ln(6/εδ)/ε 6 δ/6

14

Algorithm 3 for ε-Minimum
Input: A stream S = (xi)i∈[m] ∈ U m of length m over U; let f (x) be the frequency of x ∈ U in S
Output: An item x ∈ U such that f (x) 6 f (y) + εm for every y ∈ U
1: Initialize:

2: ℓ1 ← log(6/εδ)/ε, ℓ2 ← log(6/δ)/ε2, ℓ3 ← log6(6/δε)/ε
3: p1 ← 6ℓ1/m, p2 ← 6ℓ2/m, p3 ← 6ℓ3/m
4: S1,S2,S3 ← ∅
5: B1 ← the bit vector for S1

6:
7: procedure Insert(x)
8:

Put x in S1 with probability p1 by updating the bit vector B1
if the number of distinct items in the stream so far is at most 1/(ε log(1/ε)) then

Pick x with probability p2 and put the id of x in S2 and initialize the corresponding counter to 1

if x /∈ S2 and increment the counter corresponding to x by 1.
xi /∈ S3 and increment the counter corresponding to xi by 1. Truncate counters of S3 at 2 log7(2/εδ).

Pick x with probability p3, put the id of x in S3 and initialize the corresponding counter to 1 if

9:
10:

11:

15:

16:

17:

18:

19:

20:

return an item x from the ﬁrst 1/((1−δ)ε) items in U (ordered arbitrarily) uniformly at random

12:
13: procedure Report( )
14:

if |U| > 1/((1−δ)ε) then

if S1 6= U then

return any item from U \ S1

if the number of distinct items in the stream is at most 1/(ε log(1/ε)) then

return an item in S2 with minimum counter value in S2

return the item with minimum frequency in S3

Hence from here onwards we assume that the frequency of every item in U is at least εm ln(6/δ)/ln(6/εδ).
If the number of distinct elements is at most 1/(ε ln(1/ε)), then line 19 outputs the minimum frequency
item up to an additive factor of εm due to Chernoﬀ bound. Note that we need only O(ln(1/((1−δ)ε))) bits of
space for storing ids. Hence S2 can be stored in space O((1/ε ln(1/ε)) ln(1/((1−δ)ε) ln ln(1/δ)) = O(1/ε ln ln(1/δ)).
Now we can assume that the number of distinct elements is at least 1/(ε ln(1/ε)). Hence if f (t) is the
frequency of the item t with minimum frequency, then we have mε/ln(1/ε) 6 f (t) 6 mε ln(1/ε).

Let fi be the frequency of item i ∈ U, ei be the counter value of i in S3, and ˆfi = eim/ℓ3. Now again by

applying Chernoﬀ bound we have the following for any ﬁxed i ∈ U.

Pr[|fi − ˆfi| > fi/ln2(1/ε)] 6 2 exp{−ℓ3fi/(m ln4(1/ε))}
6 2 exp{−fi ln2(6/εδ)/(εm)}
6 εδ/6.

Now applying union bound we get the following using the fact that |U| 6 1/ε(1−δ).

Pr[∀i ∈ U,|fi − ˆfi| 6 fi/ln2(1/ε)] > 1 − δ/6
Again by applying Chernoﬀ bound and union bound we get the following.

Pr[∀i ∈ U with fi > 2mε ln(1/ε),|fi − ˆfi| 6 fi/2] > 1 − δ/6

Hence the items with frequency more than 2mε ln(1/ε) are approximated up to a multiplicative factor of 1/2
from below in S3. The counters of these items may be truncated. The other items with frequency at most
2mε ln(1/ε) are be approximated up to (1 ± 1/ln2(1/ε)) relative error and thus up to an additive error of εm/3.

15

The counters of these items would not get truncated. Hence the item with minimum counter value in S3 is
the item with minimum frequency up to an additive εm.
We need O(ln(1/εδ)) bits of space for the bit vector B1 for the set S1. We need O(ln2(1/εδ)) bits of space
for the set S2 and O((1/ε) ln ln(1/εδ)) bits of space for the set S3 (by the choice of truncation threshold). We
need an additional O (ln ln m) bits of space for sampling using Lemma 1. Moreover, using the data structure
of Section 3.3 of [DLOM02] Algorithm 3 can be performed in O(1) time. Alternatively, we may also use the
strategy described in Section 3.1 of spreading update operations over several insertions to make the cost per
insertion be O(1).

3.4 Borda and Maximin

ε + log log 1

Theorem 5. Assume the length of the stream is known beforehand. Then there is a randomized one-
pass algorithm A for (ε, ϕ)-List Borda problem which succeeds with probability at least 1 − δ using
O(cid:0)n(cid:0)log n + log 1
Proof. Let ℓ = 6ε−2 log(6nδ−1) and p = 6ℓ/m. On each insertion of a vote v, select v with probability p and
store for every i ∈ [n], the number of candidates that candidate i beats in the vote v. Keep these exact
counts in a counter of length n.
Then it follows from the proof of Theorem 1 that ℓ 6 |S| 6 11ℓ with probability at least (1 − δ/3).
Moreover, from a straightforward application of the Chernoﬀ bound (see [DB15]), it follows that if ˆs(i)
denotes the Borda score of candidate i restricted to the sampled votes, then:

δ(cid:1) + log log m(cid:1) bits of space.

Pr(cid:20)∀i ∈ [n],(cid:12)(cid:12)(cid:12)(cid:12)

m
|S|

ˆs(i) − s(i)(cid:12)(cid:12)(cid:12)(cid:12)

< εmn(cid:21) > 1 − δ

The space complexity for exactly storing the counts is O(n log(nℓ)) = O(n(log n + log ε−1 + log log δ−1))

and the space for sampling the votes is O(log log m) by Lemma 1.

Theorem 6. Assume the length of the stream is known beforehand. Then there is a randomized one-
pass algorithm A for (ε, ϕ)-List maximin problem which succeeds with probability at least 1 − δ using
O(cid:0)nε−2 log2 n + nε−2 log n log δ−1 + log log m(cid:1) bits of space.
Proof. Let ℓ = (8/ε2) ln(6n/δ) and p = 6ℓ/m. We put the current vote in a set S with probability p. Then
it follows from the proof of Theorem 1 that ℓ 6 |S| 6 11ℓ with probability at least (1 − δ/3). Suppose
|S| = ℓ1; let S = {vi : i ∈ [ℓ1]} be the set of votes sampled. Let DE(x, y) be the total number of votes
in which x beats y and DS(x, y)) be the number of such votes in S. Then by the choice of ℓ and the
Chernoﬀ bound (see [DB15]), it follows that |DS(x, y)m/ℓ1 − DE (x, y)| 6 εm/2 for every pair of candidates
x, y ∈ U. Note that each vote can be stored in O(n log n) bits of space. Hence simply ﬁnding DS(x, y)
for every x, y ∈ U by storing S and returning all the items with maximin score at least (ϕ − ε/2)ℓ1 in S
requires O(cid:0)nε−2 log n(log n + log δ−1) + log log m(cid:1) bits of memory, with the additive O(log log m) due to
Lemma 1.

3.5 Unknown stream length

Now we consider the case when the length of the stream is not known beforehand. We present below an
algorithm for (ε, ϕ)-List heavy hitters and ε-Maximum problems in the setting where the length of the
stream is not known beforehand.

Theorem 7. There is a randomized one-pass algorithm for (ε, ϕ)-List heavy hitters and ε-Maximum

problems with space complexity O(cid:0)ε−1 log ε−1 + ϕ−1 log n + log log m(cid:1) bits and update time O(1) even when

the length of the stream is not known beforehand.

16

Proof. We describe below a randomized one-pass algorithm for the (8ε, ϕ)-List heavy hitters problem.
We may assume that the length of the stream is at least 1/ε2; otherwise, we use the algorithm in Theorem 1
and get the result. Now we guess the length of the stream to be 1/ε2, but run an instance I1 of Algorithm 1
with ℓ = log(6/δ)/ε3 at line 2. By the choice of the size of the sample (which is Θ(log(1/δ)/ε3)), I1 outputs
correctly with probability at least (1 − δ), if the length of the stream is in [1/ε2, 1/ε3]. If the length of the
stream exceeds 1/ε2, we run another instance I2 of Algorithm 1 with ℓ = log(6/δ)/ε3 at line 2. Again by
the choice of the size of the sample, I2 outputs correctly with probability at least (1 − δ), if the length
of the stream is in [1/ε3, 1/ε4]. If the stream length exceeds 1/ε3, we discard I1, free the space it uses, and
run an instance I3 of Algorithm 1 with ℓ = log(6/δ)/ε3 at line 2 and so on. At any point of time, we have
at most two instances of Algorithm 1 running. When the stream ends, we return the output of the older
of the instances we are currently running. We use the approximate counting method of Morris [Mor78]
to approximately count the length of the stream. We know that the Morris counter outputs correctly with
probability (1− 2−k/2) using O(log log m+ k) bits of space at any point in time [Fla85]. Also, since the Morris
counter increases only when an item is read, it outputs correctly up to a factor of four at every position if it
outputs correctly at positions 1, 2, 4, . . . , 2⌊log2 m⌋; call this event E. Then we have Pr(E) > 1− δ by choosing
k = 2 log2(log2 m/δ) and applying union bound over the positions 1, 2, 4, . . . , 2⌊log2 m⌋. The correctness of the
algorithm follows from the correctness of Algorithm 1 and the fact that we are discarding at most εm many
items in the stream (by discarding a run of an instance of Algorithm 1). The space complexity and the O(1)
update time of the algorithm follow from Theorem 1, the choice of k above, and the fact that we have at
most two instances of Algorithm 1 currently running at any point of time.

The algorithm for the ε-Maximum problem is same as the algorithm above except we use the algorithm

in Theorem 3 instead of Algorithm 1.

Note that this proof technique does not seem to apply to our optimal Algorithm 2. Similarly to Theorem 7,

we get the following result for the other problems.

Theorem 8. There are randomized one-pass algorithms for ε-Minimum, (ε, ϕ)-Borda, and (ε, ϕ)-Maximin

δ(cid:1) + log log m(cid:1),
problems with space complexity O ((1/ε) log log(1/εδ) + log log m), O(cid:0)n(cid:0)log n + log 1
and O(cid:0)nε−2 log2 n + nε−2 log n log(1/δ) + log log m(cid:1) bits respectively even when the length of the stream is

not known beforehand. Moreover, the update time for ε-Minimum is O(1).

ε + log log 1

4 Hardness

In this section, we prove space complexity lower bounds for the ε-Heavy hitters, ε-Minimum, ε-Borda,
and ε-maximin problems. We present reductions from certain communication problems for proving space
complexity lower bounds. Let us ﬁrst introduce those communication problems with necessary results.

4.1 Communication Complexity

Deﬁnition 10. ( Indexingm,t)
Let t and m be positive integers. Alice is given a string x = (x1,··· , xt) ∈ [m]t. Bob is given an index i ∈ [t].
Bob has to output xi.

The following is a well known result [KN97].

Lemma 5. R1-way

δ

(Indexingm,t) = Ω(t log m) for constant δ ∈ (0, 1).

[SW15] deﬁnes a communication problem called Perm, which we generalize to ε-Perm as follows.

Deﬁnition 11. (ε-Perm)
Alice is given a permutation σ over [n] which is partitioned into 1/ε many contiguous blocks. Bob is given an
index i ∈ [n] and has to output the block in σ where i belongs.

17

Our lower bound for ε-Perm matches the lower bound for Perm in Lemma 1 in [SW15] when ε = 1/n.

δ

(ε − Perm) = Ω(n log(1/ε)), for any constant δ < 1/10.

For the proof, the reader may ﬁnd useful some information theory facts described in Appendix A.
Lemma 6. R1-way
Proof. Let us assume σ, the permutation Alice has, is uniformly distributed over the set of all permutations.
Let τj denotes the block the item j is in for j ∈ [n], τ = (τ1, . . . , τn), and τ<j = (τ1, . . . , τj−1). Let M (τ ) be
Alice’s message to Bob, which is a random variable depending on the randomness of σ and the private coin
tosses of Alice. Then we have R1−way(ε − Perm) > H(M (τ )) > I(M (τ ); τ ). Hence it is enough to lower
bound I(M (τ ); τ ). Then we have the following by chain rule.

I(M (τ ); τ ) =

I(M (τ ); τj|τ<j)

n

n

=

Xj=1
Xj=1
Xj=1
= H(τ ) −

>

n

n

Xj=1
H(τj|M (τ ))

n

Xj=1

H(τj|τ<j) − H(τj|M (τ ), τ<j)

H(τj|τ<j) −

H(τj|M (τ ))

The number of ways to partition n items into 1/ε blocks is n!/((εn)!)(1/ε) which is Ω((n/e)n/(εn/e)n). Hence we
have H(τ ) = n log(1/ε). Now we consider H(τj|M (τ )). By the correctness of the algorithm, Fano’s inequality,
we have H(τj|M (τ )) 6 H(δ) + (1/10) log2((1/ε) − 1) 6 (1/2) log(1/ε). Hence we have the following.

I(M (τ ); τ ) > (n/2) log(1/ε)

Finally, we consider the Greater-than problem.

Deﬁnition 12. ( Greater-thann)
Alice is given an integer x ∈ [n] and Bob is given an integer y ∈ [n], y 6= x. Bob has to output 1 if x > y and
0 otherwise.

The following result is due to [Smi88, MNSW98]. We provide a simple proof of it that seems to be

δ

(Greater-thann) = Ω(log n), for every δ < 1/4.

missing5 in the literature.
Lemma 7. R1-way
Proof. We reduce the Augmented-indexing2,⌈log n⌉+1 problem to the Greater-thann problem thereby
proving the result. Alice runs the Greater-thann protocol with its input number whose representation in
binary is a = (x1x2 ··· x⌈log n⌉1)2. Bob participates in the Greater-thann protocol with its input number
whose representation in binary is b = (x1x2 ··· xi−11

)2. Now xi = 1 if and only if a > b.

(⌈log n⌉−i+1) 0′s

0 ··· 0
| {z }

4.2 Reductions

We observe that a trivial Ω((1/ϕ) log n) bits lower bound for (ε, ϕ)-List heavy hitters, (ε, ϕ)-List borda,
(ε, ϕ)-List maximin follows from the fact that any algorithm may need to output 1/ϕ many items from the
universe. Also, there is a trivial Ω(n log n) lower bound for (ε, ϕ)-List borda and (ε, ϕ)-List maximin
because each stream item is a permutation on [n], hence requiring Ω(n log n) bits to read.

We show now a space complexity lower bound of Ω( 1

ε log 1

ϕ ) bits for the ε-Heavy hitters problem.

5A similar proof appears in [KNR99] but theirs gives a weaker lower bound.

18

Theorem 9. Suppose the size of universe n is at least 1/4ε(ϕ−ε) and that ϕ > 2ε. Any randomized one
pass (ε, ϕ)-Heavy hitters algorithm with success probability at least (1 − δ) must use Ω((1/ε) log 1/ϕ) bits
of space, for constant δ ∈ (0, 1).
Proof. Consider the Indexing1/2(ϕ−ε),1/2ε problem where Alice is given a string x = (x1, x2,··· , x1/ε) ∈
[1/2(ϕ−ε)]1/2ε and Bob is given an index i ∈ [1/2ε]. We assume ϕ > 2ε. The stream we generate is over
[1/2(ϕ−ε)] × [1/2ε] ⊆ U (this is possible since |U| > 1/(4ε(ϕ−ε))).
Let m be a large positive integer. Alice generates a stream of length m/2 by inserting εm copies of (xj , j)
for each j ∈ [1/2ε]. Alice now sends the memory content of the algorithm to Bob. Bob resumes the run of
the algorithm by generating another stream of length m/2 by inserting (ϕ − ε)m copies of (j, i) for each
j ∈ [1/2(ϕ−ε)]. The length of the stream is m, the frequency of the item (xi, i) is ϕm, while the frequency of
every other item is (ϕ − ε)m or εm. Hence from the output of the (ε, ϕ)-Heavy hitters algorithm, Bob
knows i with probability at least (1−δ). Now the result follows from Lemma 5, since 1

ϕ−ε > 1

ε log 1

ε log 1
ϕ .

We now use the same idea as in the proof of Theorem 9 to prove an Ω( 1

ε log 1

ε ) space complexity lower

bound for the ε-Maximum problem.

ε2 . Any randomized one pass ε-Maximum algorithm
ε ) bits of space, for constant δ ∈ (0, 1).

Theorem 10. Suppose the size of universe n is at least 1
with success probability at least (1 − δ) must use Ω( 1
ε log 1
Proof. Consider the Indexing1/ε,1/ε problem where Alice is given a string x = (x1, x2,··· , x1/ε) ∈ [1/ε]1/ε
and Bob is given an index i ∈ [1/ε]. The stream we generate is over [1/ε] × [1/ε] ⊆ U (this is possible since
|U| > 1
ε2 ). Let m be a large positive integer. Alice generates a stream of length m/2 in such a way that the
frequency of every item in {(xj , j) : j ∈ [1/ε]} is at least ⌊εm/2⌋ and the frequency of any other item is 0.
Alice now sends the memory content of the algorithm to Bob. Bob resumes the run of the algorithm by
generating another stream of length m/2 in such a way that the frequency of every item in {(j, i) : j ∈ [1/ε]}
is at least ⌊εm/2⌋ and the frequency of any other item is 0. The frequency of the item (xi, i) is at least ⌊εm⌋
where as the frequency of every other item is at most ⌊εm/2⌋. Hence the ε/5-Maximum algorithm must
output (xi, i) with probability at least (1 − δ). Now the result follows from Lemma 5.

For ε-Minimum, we prove a space complexity lower bound of Ω(1/ε) bits.

Theorem 11. Suppose the universe size n is at least 1/ε. Then any randomized one pass ε-Minimum
algorithm must use Ω(1/ε) bits of space.

Proof. We reduce from Indexing2,5/ε to ε-Minimum thereby proving the result. Let the inputs to Alice and
Bob in Indexing2,5/ε be (x1, . . . , x5/ε) ∈ {0, 1}5/ε and an index i ∈ [5/ε] respectively. Alice and Bob generate
a stream S over the universe [(5/ε) + 1]. Alice puts two copies of item j in S for every j ∈ U with xj = 1 and
runs the ε-Minimum algorithm. Alice now sends the memory content of the algorithm to Bob. Bob resumes
the run of the algorithm by putting two copies of every item in U \ {i, (5/ε) + 1} in the stream S. Bob also
puts one copy of (5/ε)+1 in S. Suppose the size of the support of (x1, . . . , x5/ε) be ℓ. Since 1/(2ℓ+(2/ε)−1) > ε/5,
we have the following. If xi = 0, then the ε-Minimum algorithm must output i with probability at least
(1 − δ). If xi = 1, then the ε-Minimum algorithm must output (5/ε) + 1 with probability at least (1 − δ).
Now the result follows from Lemma 5.

We show next a Ω(n log(1/ε)) bits space complexity lower bound for ε-Borda.

Theorem 12. Any one pass algorithm for ε-Borda must use Ω(n log(1/ε)) bits of space.

Proof. We reduce ε-Perm to ε-Borda. Suppose Alice has a permutation σ over [n] and Bob has an index
i ∈ [n]. The item set of our reduced election is U = [n] ⊔ D, where D = {d1, d2, . . . , d2n}. Alice generates a
vote v over the item set U from σ as follows. The vote v is B1 ≻ B2 ≻ ··· ≻ B1/ε where Bj for j = 1, . . . , 1/ε
is deﬁned as follows.

Bj = d(j−1)2εn+1 ≻ d(j−1)2εn+2 ≻ ··· ≻ d(2j−1)εn

≻ σjεn+1 ≻ ··· ≻ σ(j+1)εn ≻ d(2j−1)ε+1 ≻ ··· ≻ d2jεn

19

Alice runs the ε-Borda algorithm with the vote v and sends the memory content to Bob. Let D−i =
D \ {i}, −−→D−i be an arbitrary but ﬁxed ordering of the items in D−i, and ←−−D−i be the reverse ordering of −−→D−i.
Bob resumes the algorithm by generating two votes each of the form i ≻ −−→D−i and i ≻ ←−−D−i. Let us call the
resulting election E. The number of votes m in E is 5. The Borda score of the item i is at least 12n. The
Borda score of every item x ∈ U is at most 9n. Hence for ε < 1/15, the ε-Borda algorithm must output the
item i. Moreover, it follows from the construction of v that an εmn additive approximation of the Borda
score of the item i reveals the block where i belongs in the ε-Perm instance.

We next give a nearly-tight lower bound for the ε-maximin problem.

Theorem 13. Any one-pass algorithm for ε-maximin requires Ω(n/ε2) memory bits of storage.
Proof. We reduce from Indexing. Let γ = 1/ε2. Suppose Alice has a string y of length (n−γ)·γ, partitioned
into n − γ blocks of length γ each. Bob has an index ℓ = i + (j − γ − 1) · γ where i ∈ [γ], j ∈ {γ + 1, . . . , n}.
The Indexing problem is to return yℓ for which there is a Ω(|y|) = Ω(n/ε2) lower bound (Lemma 5).
The initial part of the reduction follows the construction in the proof of Theorem 6 in [VWWZ15], which
we encapsulate in the following lemma.
Lemma 8 (Theorem 6 in [VWWZ15]). Given y, Alice can construct a matrix P ∈ {0, 1}n×γ using public
randomness, such that if P i and P j are the i’th and j’th rows of P respectively, then with probability at least
2/3, ∆(P i, P j) > γ

2 + √γ if yℓ = 1 and ∆(a, b) 6 γ

2 − √γ if yℓ = 0.

Let Alice construct P according to Lemma 8 and then adjoin the bitwise complement of the matrix P
below P to form the matrix P ′ ∈ {0, 1}2n×γ; note that each column of P ′ has exactly n 1’s and n 0’s. Now,
we interpret each row of P as a candidate and each column of P as a vote in the following way: for each
v ∈ [γ], vote v has the candidates in {c : P ′
c,v = 1} in ascending order in the top n positions and the rest of
the candidates in ascending order in the bottom n positions. Alice inserts these γ votes into the stream and
sends the state of the ε-Maximin algorithm to Bob as well as the Hamming weight of each row in P ′. Bob
inserts γ more votes, in each of which candidate i comes ﬁrst, candidate j comes second, and the rest of the
2n − 2 candidates are in arbitrary order.
Note that because of Bob’s votes, the maximin score of j is the number of votes among the ones casted
by Alice in which j defeats i. Since i < j, in those columns v where Pi,v = Pj,v, candidate i beats
candidate j. Thus, the set of votes in which j defeats i is {v | Pi,v = 0, Pj,v = 1}. The size of this set is
2(cid:0)∆(P i, P j) + |P j| − |P i|(cid:1). Therefore, if Bob can estimate the maximin score of j upto √γ/4 additive error,
he can ﬁnd ∆(P i, P j) upto √γ/2 additive error as Bob knows |P i| and |P j|. This is enough, by Lemma 8,

to solve the Indexing problem with probability at least 2/3.

1

Finally, we show a space complexity lower bound that depends on the length of the stream m.

Theorem 14. Any one pass algorithm for ε-Heavy hitters, ε-Minimum, ε-Borda, and ε-maximin must
use Ω(log log m) memory bits, even if the stream is over a universe of size 2, for every ε < 1
4 .

Proof. It is enough to prove the result only for ε-Heavy hitters since the other three problems reduce
to ε-Heavy hitters for a universe of size 2. Suppose we have a randomized one pass ε-Heavy hitters
algorithm which uses s(m) bits of space. Using this algorithm, we will show a communication protocol for
the Greater-thanm problem whose communication complexity is s(2m) thereby proving the statement.
The universal set is U = {0, 1}. Alice generates a stream of 2x many copies of the item 1. Alice now sends
the memory content of the algorithm. Bob resumes the run of the algorithm by generating a stream of 2y
many copies of the item 0. If x > y, then the item 1 is the only ε-winner; whereas if x < y, then the item 0
is the only ε-winner.

Acknowledgments

We would like to thank Jelani Nelson for a helpful conversation which led us to discover an error in a previous
version of the paper.

20

References

[ABW03] Arvind Arasu, Shivnath Babu, and Jennifer Widom. CQL: A language for continuous queries
over streams and relations. In Database Programming Languages, 9th International Workshop,
DBPL 2003, Potsdam, Germany, September 6-8, 2003, Revised Papers, pages 1–19, 2003.

[AM01] Javed A Aslam and Mark Montague. Models for metasearch. In Proceedings of the 24th annual
international ACM SIGIR conference on Research and development in information retrieval,
pages 276–284. ACM, 2001.

[AS94] Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in
large databases. In VLDB’94, Proceedings of 20th International Conference on Very Large Data
Bases, September 12-15, 1994, Santiago de Chile, Chile, pages 487–499, 1994.

[AT05] Gediminas Adomavicius and Alexander Tuzhilin. Toward the next generation of recommender
systems: A survey of the state-of-the-art and possible extensions. Knowledge and Data Engi-
neering, IEEE Transactions on, 17(6):734–749, 2005.

[BB08] Daniel K Blandford and Guy E Blelloch. Compact dictionaries for variable-length keys and data

with applications. ACM Transactions on Algorithms (TALG), 4(2):17, 2008.

[BCE+15] Felix Brandt, Vincent Conitzer, Ulle Endriss, J´erˆome Lang, and Ariel Procaccia. Handbook of

computational social choice, 2015.

[BCIW16] Vladimir Braverman, Stephen R. Chestnut, Nikita Ivkin, and David P. Woodruﬀ.
Preprint at

in insertion streams.

Beating countsketch for heavy hitters
http://arxiv.org/abs/1511.00661. To appear in STOC ‘16.

2016.

[BGS01] Philippe Bonnet, Johannes Gehrke, and Praveen Seshadri. Towards sensor database systems. In
Mobile Data Management, Second International Conference, MDM 2001, Hong Kong, China,
January 8-10, 2001, Proceedings, pages 3–14, 2001.

[BICS10] Radu Berinde, Piotr Indyk, Graham Cormode, and Martin J. Strauss. Space-optimal heavy

hitters with strong error bounds. ACM Trans. Database Syst., 35(4):26, 2010.

[BR99] Kevin S. Beyer and Raghu Ramakrishnan. Bottom-up computation of sparse and iceberg cubes.
In SIGMOD 1999, Proceedings ACM SIGMOD International Conference on Management of
Data, June 1-3, 1999, Philadelphia, Pennsylvania, USA., pages 359–370, 1999.

[CCFC04] Moses Charikar, Kevin Chen, and Martin Farach-Colton. Finding frequent items in data streams.

Theoretical Computer Science, 312(1):3–15, 2004.

[CFM09] Yousra Chabchoub, Christine Fricker, and Hanene Mohamed. Analysis of a bloom ﬁlter algo-
rithm via the supermarket model. In 21st International Teletraﬃc Congress, ITC 2009, Paris,
France, September 15-17, 2009, pages 1–8, 2009.

[CH08] Graham Cormode and Marios Hadjieleftheriou. Finding frequent items in data streams. Pro-

ceedings of the VLDB Endowment, 1(2):1530–1541, 2008.

[CKMS08] Graham Cormode, Flip Korn, S. Muthukrishnan, and Divesh Srivastava. Finding hierarchical

heavy hitters in streaming data. TKDD, 1(4), 2008.

[CM05] Graham Cormode and S Muthukrishnan. An improved data stream summary: the count-min

sketch and its applications. Journal of Algorithms, 55(1):58–75, 2005.

21

[Cor12] Graham Cormode. Sketch techniques for massive data. In Graham Cormode, Minos Garofalakis,
Peter J. Haas, and Chris Jermaine, editors, Synopses for Massive Data: Samples, Histograms,
Wavelets, Sketches, volume 4 of Foundations and Trends in Databases, pages 1–294. Now Pub-
lishers Inc., Hanover, MA, USA, January 2012.

[CP06] Ben Carterette and Desislava Petkova. Learning a ranking from pairwise preferences. In Pro-
ceedings of the 29th annual international ACM SIGIR conference on Research and development
in information retrieval, pages 629–630. ACM, 2006.

[CP11] Ioannis Caragiannis and Ariel D. Procaccia. Voting almost maximizes social welfare despite

limited communication. Artiﬁcial Intelligence, 175(910):1655 – 1671, 2011.

[CRT06] E. J. Candes, J. Romberg, and T. Tao. Stable signal recovery from incomplete and inaccurate

measurements. Communications on Pure and Applied Mathematics, 59:1207–1223, 2006.

[CS05] Vincent Conitzer and Tuomas Sandholm. Communication complexity of common voting rules.

In Proceedings of the 6th ACM conference on Electronic commerce, pages 78–87. ACM, 2005.

[CT12] Thomas M Cover and Joy A Thomas. Elements of information theory. John Wiley & Sons,

2012.

[DB15] Palash Dey and Arnab Bhattacharyya. Sample complexity for winner prediction in elections.
In Proceeding of the 14th International Conference on Autonomous Systems and Multiagent
Systems (AAMAS-15), 2015.

[DHKP97] Martin Dietzfelbinger, Torben Hagerup, Jyrki Katajainen, and Martti Penttonen. A reliable

randomized algorithm for the closest-pair problem. Journal of Algorithms, 25(1):19–51, 1997.

[DKW56] A Dvoretzky, J Kiefer, and J Wolfowitz. Asymptotic minimax character of the sample distri-
bution function and of the classical multinomial estimator. Annals of Mathematical Statistics,
27(3):642 – 669, 1956.

[DLOM02] Erik D Demaine, Alejandro L´opez-Ortiz, and J Ian Munro. Frequency estimation of internet

packet streams with limited space. In AlgorithmsESA 2002, pages 348–360. Springer, 2002.

[EV03] Cristian Estan and George Varghese. New directions in traﬃc measurement and accounting:
Focusing on the elephants, ignoring the mice. ACM Trans. Comput. Syst., 21(3):270–313, 2003.

[Fla85] Philippe Flajolet. Approximate counting: a detailed analysis. BIT Numerical Mathematics,

25(1):113–134, 1985.

[FSG+98] Min Fang, Narayanan Shivakumar, Hector Garcia-Molina, Rajeev Motwani, and Jeﬀrey D.
Ullman. Computing iceberg queries eﬃciently. In VLDB’98, Proceedings of 24rd International
Conference on Very Large Data Bases, August 24-27, 1998, New York City, New York, USA,
pages 299–310, 1998.

[GSTV07] Anna C. Gilbert, Martin J. Strauss, Joel A. Tropp, and Roman Vershynin. One sketch for all:
fast algorithms for compressed sensing. In Proceedings of the 39th Annual ACM Symposium on
Theory of Computing, San Diego, California, USA, June 11-13, 2007, pages 237–246, 2007.

[HHS94] Tin Kam Ho, Jonathan J Hull, and Sargur N Srihari. Decision combination in multiple classiﬁer
systems. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 16(1):66–75, 1994.

[Hid99] Christian Hidber. Online association rule mining. In SIGMOD 1999, Proceedings ACM SIGMOD
International Conference on Management of Data, June 1-3, 1999, Philadelphia, Pennsylvania,
USA., pages 145–156, 1999.

22

[HKTR04] Jonathan L Herlocker, Joseph A Konstan, Loren G Terveen, and John T Riedl. Evaluating col-
laborative ﬁltering recommender systems. ACM Transactions on Information Systems (TOIS),
22(1):5–53, 2004.

[HPDW01] Jiawei Han, Jian Pei, Guozhu Dong, and Ke Wang. Eﬃcient computation of iceberg cubes
with complex measures. In Proceedings of the 2001 ACM SIGMOD international conference on
Management of data, Santa Barbara, CA, USA, May 21-24, 2001, pages 1–12, 2001.

[HPY00] Jiawei Han, Jian Pei, and Yiwen Yin. Mining frequent patterns without candidate generation.
In Proceedings of the 2000 ACM SIGMOD International Conference on Management of Data,
May 16-18, 2000, Dallas, Texas, USA., pages 1–12, 2000.

[HSST05] John Hershberger, Nisheeth Shrivastava, Subhash Suri, and Csaba D. T´oth. Space complexity
of hierarchical heavy hitters in multi-dimensional data streams. In Proceedings of the Twenty-
fourth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, June
13-15, 2005, Baltimore, Maryland, USA, pages 338–347, 2005.

[JMP+14] Albert Jiang, Leandro Soriano Marcolino, Ariel D Procaccia, Tuomas Sandholm, Nisarg Shah,
and Milind Tambe. Diverse randomized agents vote to win. In Advances in Neural Information
Processing Systems, pages 2573–2581, 2014.

[KN97] Eyal Kushilevitz and Noam Nisan. Communication Complexity. Cambridge University Press,

New York, NY, USA, 1997.

[KNR99] Ilan Kremer, Noam Nisan, and Dana Ron. On randomized one-round communication complexity.

Computational Complexity, 8(1):21–49, 1999.

[KSP03] Richard M Karp, Scott Shenker, and Christos H Papadimitriou. A simple algorithm for ﬁnding
frequent elements in streams and bags. ACM Transactions on Database Systems (TODS),
28(1):51–55, 2003.

[KTW11] Peter Kellner, Joe Twyman, and Anthony Wells. Polling voting intentions. In Political Com-

munication in Britain, pages 94–108. Springer, 2011.

[KX06] Abhishek Kumar and Jun (Jim) Xu. Sketch guided sampling - using on-line estimates of ﬂow
size for adaptive data collection.
In INFOCOM 2006. 25th IEEE International Conference
on Computer Communications, Joint Conference of the IEEE Computer and Communications
Societies, 23-29 April 2006, Barcelona, Catalunya, Spain, 2006.

[Li14] Hang Li. Learning to rank for information retrieval and natural language processing. Synthesis

Lectures on Human Language Technologies, 7(3):1–121, 2014.

[LN06] Alessandra Lumini and Loris Nanni. Detector of image orientation based on borda count.

Pattern Recognition Letters, 27(3):180–186, 2006.

[LNNT16] Kasper Green

Optimal

and Mikkel Tho-
Abstract at

rup.
http://ita.ucsd.edu/workshop/16/files/abstract/abstract_3738.txt, 2016.

Larsen,
space heavy hitters with fast update and query.

Jelani Nelson,

Huy

Le Nguyen,

[LRSC01] Charles E Leiserson, Ronald L Rivest, Cliﬀord Stein, and Thomas H Cormen. Introduction to

algorithms. The MIT press, 5:2–2, 2001.

[MAE05] Ahmed Metwally, Divyakant Agrawal, and Amr El Abbadi. Eﬃcient computation of frequent
and top-k elements in data streams. In Proceedings of the 10th International Conference on
Database Theory, ICDT’05, pages 398–412, Berlin, Heidelberg, 2005. Springer-Verlag.

23

[MBG04] Am´elie Marian, Nicolas Bruno, and Luis Gravano. Evaluating top-k queries over web-accessible

databases. ACM Trans. Database Syst., 29(2):319–362, 2004.

[MG82] Jayadev Misra and David Gries. Finding repeated elements. Sci. Comput. Program., 2(2):143–

152, 1982.

[MG09] Md Maruf Monwar and Marina L Gavrilova. Multimodal biometric system using rank-level
fusion approach. Systems, Man, and Cybernetics, Part B: Cybernetics, IEEE Transactions on,
39(4):867–878, 2009.

[MM02] Gurmeet Singh Manku and Rajeev Motwani. Approximate frequency counts over data streams.
In Proceedings of the 28th international conference on Very Large Data Bases, pages 346–357.
VLDB Endowment, 2002.

[MNSW98] Peter Bro Miltersen, Noam Nisan, Shmuel Safra, and Avi Wigderson. On data structures and

asymmetric communication complexity. J. Comput. Syst. Sci., 57(1):37–49, 1998.

[Moo81] J. Strother Moore. Journal of Algorithms, June 1981. p. 208–209.

[Mor78] Robert Morris. Counting large numbers of events in small registers. Communications of the

ACM, 21(10):840–842, 1978.

[MPC12] Andrew Mao, Ariel D. Procaccia, and Yiling Chen. Social Choice for Human Computation. In

Proceedings of the Fourth Workshop on Human Computation (HCOMP-12), 2012.

[MPC13] Andrew Mao, Ariel D. Procaccia, and Yiling Chen. Better Human Computation Through
Principled Voting. In Proceedings of of the 27th Conference on Artiﬁcial Intelligence (AAAI’13),
2013.

[MR91] D.J. Mullen and B. Roth. Decision making: Its logic and practice. Savage, MD: Rowman and

Littleﬁeld Publishers, Inc., 1991.

[Mut05] Shanmugavelayutham Muthukrishnan. Data streams: Algorithms and applications. Now Pub-

lishers Inc, 2005.

[MYCC07] Nikos Mamoulis, Man Lung Yiu, Kit Hung Cheng, and David W. Cheung. Eﬃcient top-k

aggregation of ranked inputs. ACM Trans. Database Syst., 32(3):19, 2007.

[NC06] Rabia Nuray and Fazli Can. Automatic ranking of information retrieval systems using data

fusion. Information Processing & Management, 42(3):595–614, 2006.

[Nel12] Jelani Nelson. Sketching and streaming algorithms for processing massive data. XRDS: Cross-

roads, The ACM Magazine for Students, 19(1):14–19, 2012.

[PPR15] Adarsh Prasad, Harsh Pareek, and Pradeep Ravikumar. Distributional rank aggregation, and an
axiomatic analysis. In Proceedings of the 32nd International Conference on Machine Learning
(ICML-15), pages 2104–2112, 2015.

[RV97] Paul Resnick and Hal R Varian. Recommender systems. Communications of the ACM, 40(3):56–

58, 1997.

[SBAS04] Nisheeth Shrivastava, Chiranjeeb Buragohain, Divyakant Agrawal, and Subhash Suri. Medians
and beyond: new aggregation techniques for sensor networks. In Proceedings of the 2nd In-
ternational Conference on Embedded Networked Sensor Systems, SenSys 2004, Baltimore, MD,
USA, November 3-5, 2004, pages 239–249, 2004.

[Smi88] D. Smirnov. Shannon’s information methods for lower bounds for probabilistic communication

complexity. Master’s thesis, Moscow University, 1988.

24

[SON95] Ashok Savasere, Edward Omiecinski, and Shamkant B. Navathe. An eﬃcient algorithm for
mining association rules in large databases.
In VLDB’95, Proceedings of 21th International
Conference on Very Large Data Bases, September 11-15, 1995, Zurich, Switzerland., pages
432–444, 1995.

[SW15] Xiaoming Sun and David P. Woodruﬀ. Tight bounds for graph problems in insertion streams. In
Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques,
APPROX/RANDOM 2015, August 24-26, 2015, Princeton, NJ, USA, pages 435–448, 2015.

[Toi96] Hannu Toivonen. Sampling large databases for association rules.

In VLDB’96, Proceedings
of 22th International Conference on Very Large Data Bases, September 3-6, 1996, Mumbai
(Bombay), India, pages 134–145, 1996.

[VWWZ15] Dirk Van Gucht, Ryan Williams, David P Woodruﬀ, and Qin Zhang. The communication
complexity of distributed set-joins with applications to matrix multiplication. In Proceedings of
the 34th ACM Symposium on Principles of Database Systems, pages 199–212. ACM, 2015.

[VZ14] Maksims N Volkovs and Richard S Zemel. New learning methods for supervised and unsu-
pervised preference aggregation. The Journal of Machine Learning Research, 15(1):1135–1176,
2014.

[WL04] Gang Wang and Frederick H Lochovsky. Feature selection with conditional mutual information
maximin in text categorization. In Proceedings of the thirteenth ACM international conference
on Information and knowledge management, pages 342–349. ACM, 2004.

[Xia12] Lirong Xia. Computing the margin of victory for various voting rules. In Proceedings of the

13th ACM Conference on Electronic Commerce, pages 982–999. ACM, 2012.

[Yao79] Andrew Chi-Chih Yao. Some complexity questions related to distributive computing (prelimi-
nary report). In Proceedings of the eleventh annual ACM symposium on Theory of computing,
pages 209–213. ACM, 1979.

25

Appendix A

Information Theory Facts
For a discrete random variable X with possible values {x1, x2, . . . , xn}, the Shannon entropy of X is deﬁned
as H(X) = −Pn
i=1 Pr(X = xi) log2 Pr(X = xi). Let Hb(p) = −p log2 p−(1−p) log2(1−p) denote the binary
entropy function when p ∈ (0, 1). For two random variables X and Y with possible values {x1, x2, . . . , xn} and
{y1, y2, . . . , ym}, respectively, the conditional entropy of X given Y is deﬁned as H(X | Y ) =Pi,j Pr(X =
Pr(X=xi,Y =yj ) . Let I(X; Y ) = H(X) − H(X | Y ) = H(Y ) − H(Y | X) denote the mutual
xi, Y = yj) log2
information between two random variables X, Y . Let I(X; Y | Z) denote the mutual information between
two random variables X, Y conditioned on Z, i.e., I(X; Y | Z) = H(X | Z) − H(X | Y, Z). The following
summarizes several basic properties of entropy and mutual information.

Pr(Y =yj)

Proposition 1. Let X, Y, Z, W be random variables.

1. If X takes value in {1, 2, . . . , m}, then H(X) ∈ [0, log m].
2. H(X) > H(X | Y ) and I(X; Y ) = H(X) − H(X | Y ) > 0.
3. If X and Z are independent, then we have I(X; Y | Z) > I(X; Y ). Similarly, if X, Z are independent

given W , then I(X; Y | Z, W ) > I(X; Y | W ).
4. (Chain rule of mutual information) I(X, Y ; Z) = I(X; Z) + I(Y ; Z | X). More generally,
any random variables X1, X2, . . . , Xn, Y , I(X1, . . . , Xn; Y ) = Pn
I(X, Y ; Z | W ) > I(X; Z | W ).
5. (Fano’s inequality) Let X be a random variable chosen from domain X according to distribution µX ,
and Y be a random variable chosen from domain Y according to distribution µY . For any reconstruction
function g : Y → X with error δg,

for
i=1 I(Xi; Y | X1, . . . , Xi−1). Thus,

Hb(δg) + δg log(|X| − 1) > H(X | Y ).
We refer readers to [CT12] for a nice introduction to information theory.

Appendix B

We remark that the algorithm in Lemma 1 has optimal space complexity as shown in Proposition 2 below
which may be of independent interest.

Proposition 2. [⋆] Any algorithm that chooses an item from a set of size n with probability p for 0 < p 6 1
n ,
in unit cost RAM model must use Ω(log log m) bits of memory.

Proof. The algorithm generates t bits uniformly at random (the number of bits it generates uniformly at
random may also depend on the outcome of the previous random bits) and ﬁnally picks an item from the
say x. Consider a run R of the algorithm where it chooses the item x with smallest number of random bits
getting generated; say it generates t random bits in this run R. This means that in any other run of the
algorithm where the item x is chosen, the algorithm must generate at least t many random bits. Let the
random bits generated in R be r1,··· , rt. Let si be the memory content of the algorithm immediately after
it generates ith random bit, for i ∈ [t], in the run R. First notice that if t < log2 n, then the probability
with which the item x is chosen is more than 1
n , which would be a contradiction. Hence, t > log2 n. Now
we claim that all the si’s must be diﬀerent. Indeed otherwise, let us assume si = sj for some i < j. Then
the algorithm chooses the item x after generating t − (j − i) many random bits (which is strictly less than
t) when the random bits being generated are r1,··· , ri, rj+1,··· , rt. This contradicts the assumption that
the run R we started with chooses the item x with smallest number of random bits generated.

26

