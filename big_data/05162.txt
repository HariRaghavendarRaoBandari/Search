A (Basis for a) Philosophy of a Theory of Fuzzy Computation

Apostolos Syropoulos

Xanthi, Greece

Abstract

6
1
0
2

 
r
a

 

M
6
1

 
 
]

H
O
.
s
c
[
 
 

1
v
2
6
1
5
0

.

3
0
6
1
:
v
i
X
r
a

Vagueness is a linguistic phenomenon as well as a property of physical objects. Fuzzy set theory is
a mathematical model of vagueness that has been used to deﬁne vague models of computation. The
prominent model of vague computation is the fuzzy Turing machine. This conceptual computing
device gives an idea of what computing under vagueness means, nevertheless, it is not the most
natural model. Based on the properties of this and other models of vague computing, it is aimed to
formulate a basis for a philosophy of a theory of fuzzy computation.

1

Introduction

Following Raymond Turner [37], who starts his entry on the Philosophy of Computer Science in the
Stanford Encyclopedia of Philosophy by quoting Stewart Shapiro [30, p. 525] in order to explain in a
nutshell what is the philosophy of computer science, I will use the same excerpt from Shapiro’s paper
to give a general idea of what a philosophy of fuzzy computation should be. More speciﬁcally, given an
arbitrary ﬁeld of study X, Shapiro notes that

. . . the main purpose of a given ﬁeld of study is to contribute to knowledge, the philosophy of
X is, at least in part, a branch of epistemology. Its purpose is to provide an account of the
goals, methodology, and subject matter of X.

Before attempting to give an account of the goals and methodology of a theory of fuzzy computation, it
is necessary to explain what is the subject matter of fuzzy computation. And before explaining what is
fuzzy computation, it is absolutely necessary to explain why fuzzy computation does matter. In diﬀerent
words, why should we consider fuzzy computation as something important? Naturally, when it is made
clear why fuzzy computing matters, then it would not be easy for anyone to argue that the theory of fuzzy
computation should not be part of a general theory of computation. By admitting the omnipresence of
vagueness, then it does make sense to argue that a theory of fuzzy computation is a general theory and,
consequently, the ordinary theory of computation is a special case of this theory.

Unfortunately, the term fuzzy computation is considered to be a collective term that describes fuzzy
arithmetic, fuzzy databases, fuzzy web searches, etc. However, these might be considered as applications
of fuzzy computation, but they do not form the body of a theory of fuzzy computation. For example,
a fuzzy database operates in a non-vague environment and is supposed to handle vague data. Clearly,
this is quite useful, but it is far from being a vague computation. In fact, to say that a fuzzy database is
vague computing is is like saying that a simulator of a quantum computer is can achieve exactly what
a real quantum computer can. A theory of fuzzy computation should propose methods to compute in
a vague environment (e.g., conceptual computing devices that operate in an environment, where, for
instance, one cannot precisely measure the position of particles, and their operations are vague) that
“realize” vagueness using fuzzy set theory. A theory of fuzzy computation could be also used to examine
whether there are limits to what can be computed. Since Turing machines are the archetypal conceptual
computing device, they have been used as a basis to deﬁne fuzzy conceptual computing devices.

Any new theory should not ignore predictions and results delivered by older theories. For example,
consider the general theory of relativity. This theory predicted things that were predicted by Newton’s
theory of gravity, nevertheless, it was able to make predictions about things where Newton’s theory
failed. Thus, a theory of fuzzy computation should enrich current theories by incorporating vagueness
into them.

1

Plan of the paper Before providing an account of the goals and methodology of fuzzy computation,
it is necessary to explain what is vagueness, in general, and fuzziness, in particular, and then to give an
overview of fuzzy Turing machines.

2 What is Vagueness?

In the English language the word fuzzy is a synonym of the word vague. Typically, the term vague is
used to denote something uncertain, imprecise or ambiguous. Nevertheless, it is widely accepted that a
term is vague to the extent that it has borderline cases, that is, cases in which it seems impossible either
to apply or not to apply this term. The Sorites Paradox, which was introduced by Eubulides of Miletus,
is a typical example of an argument that shows what it is meant by borderline cases. Also, the paradox
is one of the so called little-by-little arguments. The term sorites derives from the Greek word for heap.
The paradox is about the number of grains of wheat that makes a heap. All agree that a single grain
of wheat does not comprise a heap. The same applies for two grains of wheat as they do not comprise
a heap, etc. However, there is a point where the number of grains becomes large enough to be called a
heap, but there is no general agreement as to where this occurs.

Bertrand Russell [28] was perhaps the ﬁrst thinker who gave a deﬁnition of vagueness:

Per contra, a representation is vague when the relation of the representing system to the
represented system is not one-one, but one-many.

Based on this deﬁnition, one can conclude that a photograph that is so smudged, it might equally
represent Brown or Jones or Robinson, is actually a vague photograph. Building on Russell’s ideas, Max
Black [7] had argued that most scientiﬁc theories, and of course any theory of computation should not
excluded, are “ostensibly expressed in terms of objects never encountered in experience.” Thus, one could
argue that the Turing machine is an idealization of some real-world system. Consequently, the important
question is whether it does correspond to anything real. I plan not to answer this question here so do
not expect an answer in what follows. Black [7] proposed as a deﬁnition of vagueness the one given by
Charles Sanders Peirce:

A proposition is vague when there are possible states of things concerning which it is in-
trinsically uncertain whether, had they been contemplated by the speaker, he would have
regarded them as excluded or allowed by the proposition. By intrinsically uncertain we mean
not uncertain in consequence of any ignorance of the interpreter, but because the speaker’s
habits of language were indeterminate.

According to this deﬁnition, vagueness is a linguistic phenomenon, but also real life objects exhibit some
sort vagueness. For instance, clouds are deﬁnitely vague objects as one cannot precisely specify their
boundaries. In addition, the “orbit” of an electron is a cloud with no precise boundaries. However, I
will say more on vague objects on page 7. Readers interested in a general discussion of vagueness should
consult a book like [11]. As far it regards the linguistic phenomenon, one could argue that although the
term dirty is a linguistic term, still when it refers to cloths and the eﬀort needed to clean them, the term
ceases to be just a linguistic term and describes a real-world situation. Furthermore, washing machines
that employ these “linguistic” terms to clean our cloths by making reasonable use of energy, water, and
detergent are not some imaginary things, but real appliances available to everyone. Of course, one could
argue further that there is no vagueness at all and we can precisely describe dirt using some sort of scale.
Indeed, but then we are talking about degrees of dirtiness, something that is chieﬂy modeled with fuzzy
sets. For a more detailed discussion of these and other arguments against vagueness see [35].
It is widely accepted that there are (at least) three diﬀerent expressions of vagueness [32]:

Many-valued Logics and Fuzzy Logic Borderline statements are assigned truth-values that are be-

tween absolute truth and absolute falsehood (see [31] for a book-length discussion of this idea).

Supervaluationism The idea that borderline statements lack a truth value.

Contextualism The truth value of a proposition depends on its context (i.e., a person may be tall

relative to American men but short relative to NBA players).

2

There is a fourth, more recent, expression of vagueness that is based on the use of paraconsistent logics [11,
16]. In what follows, I will discuss only models of vague computation where vagueness is described using
fuzzy set theory. Therefore, it is necessary to outline the corresponding ideas.

3 Fuzzy Set Theory in a Nutshell

Fuzzy set theory was introduced by Lotﬁ Askar Zadeh [41] as an extension of ordinary set theory. Zadeh
deﬁned fuzzy sets by generalizing the membership relationship. In particular, given a universe X, he
deﬁned a fuzzy subset of X to be an object that is characterized by a function A : X → [0, 1]. Any value
A(x) speciﬁes the degree to which an element x belongs to A. Let me now present the basic operations
between fuzzy subsets.

Assume that A, B : X → [0, 1] are two fuzzy subsets of X. Then, their union and their intersection

are deﬁned as follows:

and

(A ∪ B)(x) = max{A(x), B(X)}

(A ∩ B)(x) = min{A(x), B(X)}.

Also, if ¯A is the complement of the fuzzy subset A, then ¯A(x) = 1 − A(x). More generally, it is quite
possible to use functions other than min and max to deﬁne the intersection and the union of fuzzy
subsets. These functions are known in the literature as t-norms and t-conorms, respectively.

Deﬁnition 3.1 A t-norm is a binary operation ∗ : [0, 1]×[0, 1] → [0, 1] that satisﬁes at least the following
conditions for all a, b, c ∈ [0, 1]:

Boundary condition a ∗ 1 = a and a ∗ 0 = 0.

Monotonicity b ≤ c implies a ∗ b ≤ a ∗ c.

Commutativity a ∗ b = b ∗ a.

Associativity a ∗ (b ∗ c) = (a ∗ b) ∗ c.

Deﬁnition 3.2 A t-conorm is a binary operation ⋆ : [0, 1] × [0, 1] → [0, 1] that satisﬁes at least the
following conditions for all a, b, c ∈ [0, 1]:

Boundary condition a ⋆ 0 = a and a ⋆ 1 = 1.

Monotonicity b ≤ c implies a ⋆ b ≤ a ⋆ c.

Commutativity a ⋆ b = b ⋆ a.

Associativity a ⋆ (b ⋆ c) = (a ⋆ b) ⋆ c.

For more information on t-norms and t-conorms see [17] or any other textbook on fuzzy set theory.

4 The Subject Matter

Essentially, the classical theory of computation started with the publication of Alan Turing’s On Com-
putable Numbers, with an application to the Entscheidungsproblem [36]. Turing’s paper introduced a
conceptual computing device, that now bears his name, which was devised in order to solve the Entschei-
dungsproblem, that is, a problem that was put forth by David Hilbert in 1928. Roughly speaking, the
Entscheidungsproblem asks if it is possible to ﬁnd a method that will take as input a description of a
formal language and a statement in the language and produce as output either True or False according
to whether the statement is true or false.

The Turing machine is a very simple conceptual computing device that consists of an inﬁnite tape,
which is divided into writable cells, a scanning head that can read the contents of a cell or print something

3

to a cell, and the so-called controlling device, which is a lookup table that controls the behavior of the
machine. Initially, one writes the input data into the cells of the tape, and then sets the machine into
motion. The machine delivers a result if it stops after some ﬁnite amount of time. This simple machine
is surprisingly powerful and it can be used to compute many functions and numbers. Not so surprisingly,
the Turing machine is considered as the cornerstone of the (classical) theory of computation.

When introducing a new model of computation, it is almost customary to introduced some sort
of Turing machine that accommodates the central idea behind the new model of computation. For
example, in order to introduce probabilistic computing, Eugene Santos [29] introduced a probabilistic
Turing machine. The same principle applies to quantum computing [15]. However, not all Turing machine
counterparts are very helpful. For instance, in quantum computing it is common to use quantum circuits
in various theoretical studies because they are more expressive in describing quantum algorithms.

The ﬁrst steps towards the deﬁnition of a fuzzy Turing machine have been made by the inventor of
fuzzy set theory Zadeh [40]. Unfortunately, Zadeh did not provide a deﬁnition of a fuzzy Turing machine
or of a fuzzy algorithm. One could say that he actually described what a fuzzy algorithm might be and,
in a sense, speculated about the properties of a fuzzy Turing machine. However, his work prompted
other researchers to investigate the notions of fuzzy Turing machines and fuzzy algorithms (see [35] for
a comprehensive account of all these formulations). Although, fuzzy Turing machines are not the only
model of fuzzy computation and, to some extend, not the most natural one, still it has been studied
thoroughly and thus it makes sense to give the deﬁnition of a fuzzy Turing machine.

The deﬁnition that follows was proposed Jiˇr´ı Wiedermann [39] and I consider it the most complete

and general deﬁnition of a fuzzy Turing machine:

Deﬁnition 4.1 A nondeterministic fuzzy Turing machine with a unidirectional tape is a nonuple

F = (Q, T, I, ∆,

, q0, qf , µ, ∗),

where:

• Q is a ﬁnite set of states;

• T is a ﬁnite set of tape symbols;

• I is a set of input symbols, where I ⊆ T ;

• ∆ is a transition relation and it is a subset of Q × T × Q × T × {L, N, R}. Each action that the
machines takes is associated with an element δ ∈ ∆. In particular, for δ = (qi, ti, qi+1, ti+1, d) this
means that when the machine is in state qi and the current symbol that has been read is ti, then the
machine will enter state qi+1, the symbol ti+1 will be printed on the current cell and the scanning
head will move according to the value of d, that is, if d is L, N , or R, then the head will move one
cell to the left, will not move, or it will move one cell to the right, respectively.

• ∈ T \ I is the blank symbol;

• q0 and qf are the initial and the ﬁnal state, respectively;

• µ : ∆ → [0, 1] is a fuzzy relation on ∆; and

• ∗ is a t-norm.

In order to fully understand how this conceptual machine works, it is necessary to present a few

additional notions.

Deﬁnition 4.2 When µ is partial function from Q × T to Q × T × {L, N, R} and T is a fuzzy subset of
Q, then the resulting machine is called a deterministic fuzzy Turing machine.

A conﬁguration gives the position of the scanning head, of what is printed on the tape, and the
current state of the machine. If Si and Si+1 are two conﬁgurations, then Si ⊢α Si+1 means that Si+1 is
reachable in one step from Si with a plausibility degree that is equal to α if and only if there is a δ ∈ ∆
such that µ(δ) = α and by which the machine goes from Si to Si+1. When a machine starts with input

4

some string w, the characters of the string are printed on the tape starting from the leftmost cell; the
scanning head is placed atop the leftmost cell, and the machine enters state q0. If

S0 ⊢α0 S1 ⊢α1 S2 ⊢α2 · · · ⊢αn−1 Sn,

then Sn is reachable from S0 in n steps. Assume that Sn is reachable from S0 in n steps, then the
plausibility degree of this computational path is

D(cid:0)(S0, S1, . . . , Sn)(cid:1) = (cid:26) 1,

D(cid:0)(S0, S1, . . . , Sn−1)(cid:1) ∗ αn−1, n > 0

n = 0

Obviously, the value that is computed with this formula depends on the speciﬁc path that is chosen.
Since the machine is nondeterministic, it is quite possible that some conﬁguration Sn can be reached via
diﬀerent computational paths. Therefore, when a machine starts from S0 and ﬁnishes at Sn in n steps,
the plausibility degree of this computational path, which is called a computation, should be equal to the
maximum of all possible computation paths:

In diﬀerent words, the plausibility degree of the computation is equal to the plausibility degree of the
computational path that is most likely to happen.

d(Sn) = maxhD(cid:0)(S0, S1, . . . , Sn)(cid:1)i.

Assume that a machine starts from conﬁguration S0 with input the string w. Then, a computational
path S0, S1, . . . , Sm is an accepting path of conﬁgurations if the state of Sm is qf . In addition, the string
w is accepted with degree equal to d(Sm).

Deﬁnition 4.3 Assume that F is a fuzzy nondeterministic Turing machine. Then, an input string w is
accepted with plausibility degree e(w) by F if and only if:

• there is an accepting conﬁguration from the initial conﬁguration S0 on input w;

• e(w) = maxS(cid:8)d(S) | S is an accepting conﬁguration reachable from S0(cid:9).

Also,

Deﬁnition 4.4 The fuzzy language accepted by some machine F is the fuzzy set that is deﬁned as
follows:

L(F ) = n(cid:0)w, e(w)(cid:1) (cid:12)(cid:12)(cid:12)

w is accepted by F with plausibility degree e(w)o.

It is quite possible that a Turing machine might not write on its tape the symbol 1 but something
that looks like it. Then, when reading this symbol the machine might have trouble deciding whether it
is an 1 or not. Obviously, this a very intresting idea but it might happen because the read-write head is
defective. If this happens randomly, then it should be necessary to include this “feature” in our analysis.
However, this is an open problem at the moment.

Another model of fuzzy computation, more close to the idea of vagueness, are fuzzy P systems
(see [35] for an up-to-date and thorough presentation of fuzzy P systems and other similar fuzzy models
of computation). P system have been introduced by Gheorghe P˘aun [22]. Roughly, a P system is a model
of computation that is based on the functionality of the cell. To the best of my knowledge, any cell
has a membrane that surrounds it, separates its interior from its environment, regulates what goes in
and out, etc. Inside the membrane, the cytoplasm takes up most of the cell volume. Various organelles
(i.e., specialized subunits within a cell that have a speciﬁc function) are “ﬂoating” inside the cytoplasm.
Just like a cell, a P system is enveloped in a porous membrane that allows objects to move in and out.
Inside a P system there is an indeﬁnite number of nested compartments, that is, compartments that
may contain other compartments, etc., each of them enveloped by a porous membrane. Also, there is a
designated compartment called the output compartment. In addition, each compartment, may contain
“solid,” possibly repeated objects, that is, a multiset of objects, while it is associated with a set of
multiset rewriting rules. The system operates in discrete time and these rules specify what changes can
possible happen inside a compartment at each tick of the clock. In general, compartments cannot be
deleted while objects may be multiplied, deleted, or introduced in a compartment. Computation stops
when no rule is applicable and the result of the computation equals the number of objects that have been
accumulated in the output compartment. Now, a fuzzy P system is one where the multisets of objects
are replaced by fuzzy multisets:

5

Deﬁnition 4.5 Assume that M : X → N characterizes a multiset M . Then, a fuzzy multi-subset of M
is a structure A that is characterized by a function A : X → N × [0, 1] such that if M (x) = n, then
A(x) = (n, i). In addition, the expression A(x) = (n, i) denotes that the degree to which each of the n
copies of x belong to A is i.

The cardinality of such a set is given by the following formula:

where Am(a) = n and Aµ(a) = i.

card A = Xa∈A

Am(a)Aµ(a),

Corollary 4.1 The result of a computation delivered by a fuzzy P system is a positive real number.

5 Goals and Methodology

Philosophical questions regarding the distinction between hardware and software and other similar ques-
tions are essentially the same when it comes to a philosophy of fuzzy computation. However, the important
question here is where vagueness comes into the picture when one deals with real computers? In diﬀerent
words, is the hardware we use today non-exact or non-well-deﬁned so that it is justiﬁed to see vagueness
come into play?

It should not surprise anyone the fact that modern computers consume electricity that might be
ﬂuctuating. Typically, machines can cope with some small ﬂuctuations of electricity because, among
others, they have been designed to operate within a speciﬁc range of voltage. These ﬂuctuations of
electricity and other similar phenomena (e.g., noise in communication) are some sort of vague phenomena
and, therefore, a raison d’ˆetre for vagueness. However, we intensionally choose to ignore this sort of
vagueness and assume that our systems are exact when they are roughly exact. Of course this happens
because those who built the ﬁrst computers where not interested in vagueness and imprecision but rather
in exactness and precision. Thus, one can safely conclude that there is some sort of vagueness in hardware.
The next big question is how can we make use of this vagueness? Or, going one step further, what would
make a computer vague?

Before trying to answer this question, it is necessary to see whether it actually makes sense to expect
to see the construction of a vague computer. Martin Davis [10] speculated that John von Neumann
was aware of Turing’s work and that he has used it in the construction of ENIAC. Of course this is an
arbitrary conclusion, as is based on a speculation. After all, Konrad Zuse’s Z3 computer [27] was not
build on ideas borrowed from Turing although he was a contemporary of Turing too. As far it regards
modern computers, it is known that interaction (see [34]) is a notion “alien” to the Turing model of
computation. This implies that the construction of a vague computing machine should not be necessarily
based on the properties of a fuzzy Turing machine. However, this remark is quite important because of
a crucial theoretical result.

Although some authors stubbornly insist that modern computers are actually universal Turing ma-
chines [23], Selim G. Akl [2, 3] denies the existence of universal machines by arguing that only a machine
that can perform an inﬁnite number of operations per step can be classiﬁed as a universal machine.
Even if one dismisses Akl’s position, still Yong Ming Li [19] has proved that there is no universal fuzzy
Turing machine. Interestingly, Li [18] has also concluded that there is a restricted form of a universal
fuzzy Turing machine. However, it seems that this conclusion is somehow a biased one, mainly because
people cannot accept that there is no universal fuzzy Turing machine. Thus if we accept that every
real computing device is a realization of some universal conceptual computing device, one could not
build a real machine based on the properties of the fuzzy Turing machine. This means that one should
seek inspiration to other models of vague computation, provided there are universal versions of these
models. Alternatively, one could just ignore this “requirement” and try nevertheless to build a machine.
Surprisingly, based on remarks about the “fuzziness” of quantum mechanics (e.g., see [4, 25, 26]), one
could argue that quantum computers are actually vague computers, provided one replaces probability
theory with with possibility theory or any other theory derived from fuzzy set theory. However, even if
this would be proved to be a fallacy, which is very unlikely, there is another way out—Vague computing
devices should make use of vagueness as is manifested in the molecular, atomic or subatomic level. Since

6

it is quite possible that some (?) readers may ﬁnd almost absurd the idea that vagueness exists at the
quantum level, I would like to present an example that hopefully sheds light on this idea. The following
example, which was originally presented by E. J. Lowe [20], shows that vagueness exists in the subatomic
level:

Suppose (to keep matters simple) that in an ionization chamber a free electron a is captured
by a certain atom to form a negative ion which, a short time later, reverts to a neutral state
by releasing an electron b. As I understand it, according to currently accepted quantum-
mechanical principles there may simply be no objective fact of the matter as to whether or
not a is identical with b. It should be emphasized that what is being proposed here is not
merely that we may well have no way of telling whether or not a and b are identical,which
would imply only an epistemic indeterminacy. It is well known that the sort of indeterminacy
presupposed by orthodox interpretations of quantum theory is more than merely epistemic—
it is ontic. The key feature of the example is that in such an interaction electron a and other
electrons in the outer shell of the relevant atom enter an ‘entangled’ or ‘superposed’ state in
which the number of electrons present is determinate but the identity of any one of them with
a is not, thus rendering likewise indeterminate the identity of a with the released electron b.

The idea behind this example is that “identity statements represented by ‘a = b’ are ‘ontically’ indeter-
minate in the quantum mechanical context”.1 In diﬀerent words, in the quantum mechanical context a
is equal to b to some degree, which is one of the fundamental ideas behind fuzzy set theory. Based on
this observation, it should be clear that a vague computer should make use of vagueness as is manifested
in nature.

A vague computer should be able to run programs. Clearly, such a computing device should be able
to run conventional programs, since, as expected, all vague models of computation would be far more
general than their crisp counterparts. Forget for a moment the connection between vague and quantum
computation and assume that there are no vague computers available at this moment. Then, does it make
sense to talk about vague programs and vague programming languages today? The answer is emphat-
ically yes and here is the rationale. Today, quantum computers are not widely available yet, still there
are quantum programming languages, like Quipper [14], which can be used to create quantum programs.
Such programming languages are implemented using conventional methodologies and techniques (e.g.,
Quipper is written in Haskell) and programs expressed in these languages run on conventional hardware.
Similarly, one can design and implement a vague programming language using a conventional program-
ming language so that vague programs run on conventional hardware. However, one should note that
since quantum computers are more powerful than conventional machines (e.g., they can compute true
random numbers [24] whereas von Neumann machines can compute only pseudo-random number), it is
of course impossible to use this extra power when working with such quantum programming languages.
And of course this applies to vague programming languages too, provided that vague machines have
similar capabilities.

Zadeh [40] has speculated about the form of commands in a vague programming language. Thus,
according to Zadeh, a typical command of such a language would be “set y approximately equal to 10 if
x is approximately equal to 5.” Ever since a number of vague programming languages have been designed
and implemented. RASP [12] was an extension of BASIC that provided basic operations for fuzzy sets
but it did not include commands similar to the ones suggested by Zadeh’s. The FLISP [33] programming
language, an extension of LISP, provided facilities to input and process fuzzy data. For example, in order
to enter the fuzzy set

Q = 0.3/2 + 0.9/3 + 1/4 + 0.8/5 + 0.5/6

where f /d means that d ∈f Q, one had to enter the following commands:

(SETQ U ’( 0 1 2 3 4 5 6 7 8 9))
(FSETQ Q ((U) (FSET ((2@0.3)(6@0.5)(5@0.8)(3@-0.9)(4@1)))))

HALO [9] was a LISP-like language that employed many Pascal-like and C-like structures. In addition,
the logical operations as well as some other operations are fuzzy. The assignment statement of the
languages L and XL [1] allowed users to assign fuzzy numbers to variables. In addition, XL included a

1Steven French and Dcio Krause. Quantum Vagueness. Erkenntnis, 59, pp. 97–124, 2003.

7

fuzzy repetition construct. Fril++ [6] is an object-oriented language where an object can be an instance
of a class to some degree. This is a particularly interesting idea and implies that two instances of some
class can be equal to some degree. And it would be quite interesting to see how one could implement this
idea in a way similar to Java’s equals() method. Fuzzy Arden Syntax is programming language that
has been designed “to provide an easy means of processing vague or uncertain data, which frequently
appears in medicine” [38]. One can deﬁne fuzzy sets very easily:

U:= fuzzy set (2,0.3), (6,0.5), (5,0.8), (3,-0.9), (4,1);

The language allows commands that are reminiscent of Zadeh’s “commands”:

TempatureList:= read {temperature} where

it occurred within the past 24 hours
fuzzified by 4 hours;

And of course, there is a fuzzy λ-calculus [5] where each term is associated with a degree and the b-
reduction is redeﬁned. I suppose the authors meant β-reduction, but that is just an educated guess. . . The
notion of “approximately equal” can be introduced in a language by means of an extended assignment
operator (e.g., ~=) and an extended equality operator (e.g., ~==). Thus, a command like

x ~= y

would mean that x is actually assigned a compound value like y ± δy, where the δy should be implemen-
tation dependent or the user should be able to conﬁgure the compiler accordingly. In a sense, x would
an interval and not just a point.

The languages that were brieﬂy reviewed can be roughly divided into two categories: those that allow
the use of fuzzy sets and those that implement some basic principle of fuzzy set theory (e.g., similarity
of objects). The languages that implement some sort of similarity with degree are closer to the spirit
of vagueness. In general, fuzzy programming languages should provide facilities for the deﬁnition and
manipulation of fuzzy sets. In addition, they should provide control structures that can handle fuzzy
logical expression. Also, it is necessary to provide facilities to express similarities between structures.

In the previous section, I stated that Turing devised his (automatic) machine in order to solve the
Entscheidungsproblem. This is a bit inaccurate. The truth is that Turing, devised his machine and then
he devised the universal Turing machine with which he gave his answer to Entscheidungsproblem. In
modern computer parlance, Turing essentially proved that it is not possible to tell whether a program
that is not responding has entered a vicious circle or not. This problem is known as the halting prob-
lem. By showing that the halting problem is as hard as the Entscheidungsproblem, he proved that the
Entscheidungsproblem is unsolvable, or better it is Turing unsolvable. Turing went one step further and
made a bold statement—if a number or a function is computable, then it must be computable by a
Turing machine. This statement is now known as the Church-Turing thesis.

Clearly fuzzy Turing machines form an extension of the classical archetypal conceptual computing
device. Therefore, they should compute as many numbers and/or functions as their classical counterpart.
The important question is whether these machines are more powerful than their classical counterparts.
Jiˇr´ı Wiedermann [39] has shown that fuzzy Turing machines are more powerful than ordinary Turing
machines. In diﬀerent words, fuzzy Turing machines are hypercomputers [34]. Despite this fact2 it is
not clear at all what are the computational limits of these machines. After all, for each conceptual and
logically consistent computing device there is a limit to what it can achieve. For example, Toby Ord and
Tien D. Kieu [21] have argued that every logically consistent computing device cannot solve its halting
problem. Since there are no universal fuzzy Turing machines, it makes no sense to talk about their halting
problem, nevertheless, it does make sense to try to ﬁnd their computational limits.

Mark Changizi [8] assumes the validity of three theses or hypotheses: the Church-Turing thesis, the

Programs-in-Head hypothesis, and the Any-Algorithm hypothesis. These hypotheses state:

Programs-in-Head Hypothesis For most natural language predicates P and their natural
language negation ‘¬P ’, their interpretations are determined by you using programs in the
head.

2See [35] for a discussion of various attacks to this result.

8

Any-Algorithm Hypothesis You are free to choose from the set of all algorithms when
interpreting natural language predicates or their natural language negations.

Changizi argues that these hypotheses together with the Church-Turing thesis imply the omnipresence
of vagueness in language. Of course, it is not know if the Church-Turing thesis is valid and hypercompu-
tation implies that it is not. Next, the two hypotheses are based on the assumption that mechanism is
valid, which is equally problematic. In [34] I have argued against mechanism so I will not repeat these
arguments here. What is even more problematic is that vagueness is restricted into language and because
of Changizi’s arguments any language is mostly vague. However, on a place with no intelligent beings
there is no language and os no vagueness! Ergo, vagueness is not something real. And this is the reason
I have tried to establish that vagueness is a fundamental property of the physical world and notr some
human invention.

6 Conclusions

Fuzzy computing is a new branch of (theoretical) computer science that is not fully developed. There
are a number of open questions regarding fuzzy conceptual computing devices and their capabilities.
The answers to these questions greatly depends on one’s philosophical prejudices. I have tried to brieﬂy
present the ﬁeld of fuzzy computation and to discuss these open problems based on my own prejudices.
In summary, there is no universal fuzzy Turing machine and it seems universality has nothing to do
with vague computing devices. However, this should not pose an obstacle in the construction of vague
computers, which should be based on vagueness as it appears at the particle level. Also, it seems that
vague computing devices will be more powerful than their classical counterparts, but the upper bound
of their computational power has not been determined yet.

References

[1] abnd Jos´e-Luis P´erez-de-la Cruz, R. M.-B., Conejo, R., and Clares, B. A family of fuzzy

programming languages. Fuzzy Sets and Systems 87 (1997), 167–179.

[2] Akl, S. G. Three Counterexamples to Dispel the Myth of the Universal Computer. Parallel

Processing Letters 16 (2006), 381–403.

[3] Akl, S. G. Even Accelerating Machines are Not Universal. International Journal of Unconventional

Computing 3 (2007), 105–121.

[4] Alex Granik and H.J.Caulfield. Fuzziness in Quantum Mechanics. arXiv:quant-ph/0107054v1,

2001.

[5] Alvarez, D. S., and Skarmeta, A. F. G. A fuzzy language. Fuzzy Sets and Systems 141 (2004),

335–390.

[6] Baldwin, J., Martin, T., and Vargas-Vera, M. Fril++ a Language for Object-Oriented
Programming with Uncertainty. In Fuzzy Logic in Artiﬁcial Intelligence, A. L. Ralescu and J. G.
Shanahan, Eds., vol. 1566 of Lecture Notes in Computer Science. Springer Berlin Heidelberg, 1999,
pp. 62–78.

[7] Black, M. Vagueness. An Exercise in Logical Analysis. Philosophy of Science 4, 4 (1937), 427–455.

[8] Changizi, M. A. The Brain from 25,000 Feet, vol. 317 of Synthese Library. Springer Netherlands,

2003.

[9] Clark, D. F. HALO–a fuzzy programming language. Fuzzy Sets and Systems 44 (1991), 199–208.

[10] Davis, M. Mathematical Logic and the Origin of Modern Computing. In The Universal Turing Ma-
chine: A Half-Century Survey, R. Herken, Ed. Verlag Kammerer & Unverzagt, Hamburg, Germany,
1988, pp. 149–174.

9

[11] Dietz, R., and Moruzzi, S., Eds. Cuts and Clouds: Vaguenesss, its Nature and its Logic. Oxford

University Press, Oxford, UK, 2010.

[12] Djakovic, D. D. RASP–A Language with Operations on Fuzzy Set. Computer Languages 13, 3–4

(1988), 143–147.

[13] French, S., and Krause, D. Quantum Vagueness. Erkenntnis 59 (2003), 97–124.

[14] Green, A. S., Lumsdaine, P. L., Ross, N. J., Selinger, P., and Valiron, B. An introduction
to quantum programming in quipper. In Reversible Computation, G. W. Dueck and D. M. Miller,
Eds., vol. 7948 of Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2013, pp. 110–124.

[15] Hirvensalo, M. Quantum Computing, 2nd ed. Springer-Verlag, Berlin, 2004.

[16] Hyde, D., and Colyvan, M. Paraconsistent Vagueness: Why Not? The Australasian Journal of

Logic 6 (2008), 107–121.

[17] Klir, G. J., and Yuan, B. Fuzzy Sets and Fuzzy Logic : Theory and Applications. Prentice Hall

(Sd), 1995.

[18] Li, Y. Approximation and universality of fuzzy turing machines. Science in China Series F:

Information Sciences 51, 10 (2008), 1445–1465.

[19] Li, Yongming. Some Results of Fuzzy Turing Machines. In Proceedings of the 6th World Congress

in Intelligent Control and Automation. IEEE, 2006, pp. 3406–3409.

[20] Lowe, E. J. Vague Identity and Quantum Indeterminacy. Analysis 54, 2 (1994), 110–114.

[21] Ord, T., and Kieu, T. D. The Diagonal Method and Hypercomputation. The British Journal

for the Philosophy of Science 56, 1 (2005), 147–156.

[22] P˘aun, G. Membrane Computing: An Introduction. Springer-Verlag, Berlin, Germany, EU, 2002.

[23] Petzold, C. The Annotated Turing: A Guided Tour Through Alan Turing’s Historic Paper on

Computability and the Turing Machine. Wiley Publishing, Inc., Indianapolis, IN, USA, 2008.

[24] Pironio, S. and Ac´ın, A. and Massar, S. and de la Giroday, A. Boyer and Matsukevich,
D. N. and Maunz, P. and Olmschenk, S. and Hayes, D. and Luo, L. and Manning, T.
A. and Monroe, C. Random numbers certiﬁed by Bells theorem. Nature 464 (2010), 1021–1024.

[25] Pykacz, J. Towards many-valued/fuzzy interpretation of quantum mechanics. International Jour-

nal of General Systems 40, 1 (2011), 11–21.

[26] Pykacz, J., DHooghe, B., and Zapatrin, R. R. Quantum Computers as Fuzzy Computers. In
Fuzzy Days 2001, B. Reusch, Ed., vol. 2206 of Lecture Notes in Computer Science. Springer, Berlin,
Germany, EU, 2001, pp. 526—535.

[27] Rojas, R., Darius, F., Goktekin, C., and Heyne, G. The Reconstruction of Konrad Zuse’s

Z3. IEEE Annals of the History of Computing 27, 3 (2005), 23–32.

[28] Russell, B. Vagueness. Australasian Journal of Philosophy 1, 2 (1923), 84–92.

[29] Santos, E. S. Computability by Probabilistic Turing Machines. Transactions of the American

Mathematical Society 159 (1971), 165–184.

[30] Shapiro, S. Mathematics and reality. Philosophy of Science 50, 4 (1983), 523–548.

[31] Smith, N. J. J. Vagueness and Degrees of Truth. Oxford University Press, 2008.

[32] Sorensen, R. Vagueness.

In The Stanford Encyclopedia of Philosophy, E. N. Zalta, Ed., fall

2008 ed. 2008.

[33] Sosnowski, Z. A. FLISP–A language for processing fuzzy data. Fuzzy Sets and Systems 37, 1

(1990), 23–32.

10

[34] Syropoulos, A. Hypercomputation: Computing Beyond the Church-Turing Barrier. Springer New

York, Inc., Secaucus, NJ, USA, 2008.

[35] Syropoulos, A. Theory of Fuzzy Computation. IFSR International Series on Systems Science and

Engineering. Springer, New York, 2014.

[36] Turing, A. M. On Computable Numbers, with an application to the Entscheidungsproblem.

Proceedings of the London Mathematical Society 42 (1936), 230–265.

[37] Turner,

R.

fall

The
ed.

Stan-
2013.

In
2013
ford
http://plato.stanford.edu/archives/fall2013/entries/computer-science/.

computer
Zalta,

science.
Ed.,

philosophy

of

Encyclopedia

Philosophy,

E.

N.

The
of

[38] Vetterlein, T., Mandl, H., and Adlassnig, K.-P. Fuzzy Arden Syntax: A fuzzy programming

language for medicine. Artiﬁcial Intelligence in Medicine 49 (2010), 1–10.

[39] Wiedermann, J. Characterizing the super-Turing computing power and eﬃciency of classical fuzzy

Turing machines. Theoretical Computer Science 317 (2004), 61–69.

[40] Zadeh, L. A. Fuzzy Algorithms. Information and Control 12 (1968), 94–102.

[41] Zadeh, L. A. Discussion: Probability Theory and Fuzzy Logic Are Complementary Rather Than

Competitive. Technometrics 37, 3 (1995), 271–276.

11

