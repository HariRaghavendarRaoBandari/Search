Accelerating Data Regeneration for Distributed

Storage Systems with Heterogeneous Link

Capacities

Yan Wang, Xunrui Yin, Dongsheng Wei, Xin Wang, Member, IEEE, Yucheng He, Member, IEEE

1

6
1
0
2

 
r
a

 

M
6
1

 
 
]

C
D
.
s
c
[
 
 

1
v
3
6
1
5
0

.

3
0
6
1
:
v
i
X
r
a

Abstract—Distributed storage systems provide large-scale re-
liable data storage services by spreading redundancy across a
large group of storage nodes. In such a large system, node
failures take place on a regular basis. When a storage node
breaks down, a replacement node is expected to regenerate the
redundant data as soon as possible in order to maintain the same
level of redundancy. Previous results have been mainly focused
on the minimization of network trafﬁc in regeneration. However,
in practical networks, where link capacities vary in a wide range,
minimizing network trafﬁc does not always yield the minimum
regeneration time. In this paper, we investigate two approaches
to the problem of minimizing regeneration time in networks with
heterogeneous link capacities. The ﬁrst approach is to download
different amounts of repair data from the helping nodes ac-
cording to the link capacities. The second approach generalizes
the conventional star-structured regeneration topology to tree-
structured topologies so that we can utilize the links between
helping nodes with bypassing low-capacity links. Simulation
results show that the ﬂexible tree-structured regeneration scheme
that combines the advantages of both approaches can achieve a
substantial reduction in the regeneration time.

Index Terms—Regenerating codes, heterogeneity, distributed

storage systems, erasure codes, fault tolerance.

I. INTRODUCTION

Large-scale distributed storage systems are widely used
today to provide reliable data storage services, by spreading
data redundancy over a large number of storage nodes. Users
can access their data anytime and anywhere. Such application
scenarios include large data centers such as Google File
Systems, Total Recall, OceanStore and peer-to-peer storage
systems Wuala.

In distributed storage systems, the level of redundancy is
usually described by parameters (n, k), where n is the number
of storage nodes holding coded blocks of a ﬁle, and k indicates
that the ﬁle can be reconstructed from any k out of the n
storage nodes. For example, we can use an (n, k) maximum
distance separable (MDS) code to encode a ﬁle of size M into
n blocks of equal size M/k, and disseminate them to n storage
nodes with each holding one block. Then, the original ﬁle

Y. Wang is with the School of Software, East China Jiao Tong University,
Nanchang, China. The main work was done when she was with the School
of Computer Science, Fudan University, email:ywangc11@fudan.edu.cn

X. Yin is with Department of Computer Science, University of Calgary,

Canada.

University.

D. Wei and X. Wang are with the School of Computer Science, Fudan

Y. He is with the School of Information Science and Engineering, Huaqiao

University, Xiamen, China.

This paper was presented in part at IEEE INFOCOM 2014.

can be reconstructed from any k storage nodes. In literature,
the ability to reconstruct the ﬁle from any k storage nodes is
usually referred to as the MDS property [1].

In such big systems, nodes fail frequently, and the failures
should be handled on a routine basis. After a node fails or
leaves the system, the reliability degrades, and the protected
data becomes vulnerable. To maintain the same level of
redundancy, it is important to regenerate the lost data at a
replacement node, called newcomer, as soon as possible [2].
In this work, we focus our attention on how to minimize
regeneration time in the regeneration process.

An intuitive way to achieve a minimized regeneration time
is to minimize the total amount of data transferred for regen-
eration, which is called repair bandwidth. In this direction,
Dimakis et al. proposed Regenerating Codes to achieve the
minimum repair bandwidth [3]. For simplicity, they assumed
that each surviving node participating in the regeneration,
called provider, sends the same amount of repair data to the
newcomer. In this paper, we focus on the regenerating codes
with functional repair, where the regenerated data may be
different from the lost data. We will use the term repair trafﬁc
to denote the amount of repair data transmitted from each
provider to the newcomer.

Under the assumption of uniform repair trafﬁc, Demakis
et al. derived the minimum repair bandwidth to maintain the
MDS property. They found that there is a trade-off between
repair bandwidth and storage efﬁciency, with two extremal
cases: 1) the minimum-storage regenerating (MSR) point
where each node stores the minimum amount of data, and
2) the minimum-bandwidth regenerating (MBR) point where
the storage efﬁciency is sacriﬁced for achieving the minimum
repair bandwidth.

In practice, minimum repair bandwidth does not always
result in minimum regeneration time, especially in hetero-
geneous networks where link capacities vary in a wide
range. The heterogeneous networks are commonly deployed
for distributed storage systems. For example, within a data
center, servers are usually placed in racks, and the servers
in the same rack may enjoy a much larger bandwidth than
those located in different racks [4]. Meanwhile, the available
bandwidths among servers are distinct because of different
background trafﬁc, even if the link capacities are the same
[5]. The difference of link bandwidths becomes even larger
when using multiple geo-distributed data centers to safeguard
users’ data from the failure of an entire data center, which
is a conventional practice for large companies, e.g. Google.

In these networks, the regeneration time depends not only on
the repair bandwidth, but also on the bandwidths of bottleneck
links between providers and the newcomer. Thus, in this work,
we will also consider nonuniform repair trafﬁc in order for
the amount of transmitted repair data to match the available
bandwidth over heterogeneous links.

There are, in general, two approaches for accelerating the
regeneration process in heterogeneous networks. The ﬁrst is
to drop the assumption of uniform repair trafﬁc. Instead,
the repair trafﬁc would better be dynamically determined
according to the end-to-end available bandwidth from each
provider to the newcomer. The idea is to let providers with
larger end-to-end available bandwidths transmit more repair
data for reducing in turn the amount of data transmitted
through bottleneck links. This approach requires a new form of
restriction on the repair trafﬁc to maintain the MDS property.
For example, Shah et al. [6] developed a regenerating scheme
that supports non-uniform repair trafﬁc with two newly intro-
duced parameters βmax and γ. While the repair trafﬁc can be
dynamically determined for each provider in each regeneration
process, it requires that the provider transmits at most an
amount of βmax repair data and the total amount of repair
data from all the providers must be no less than γ, so that the
MDS property can be preserved.

The second approach is to utilize the inter-provider links to
bypass bottleneck links between providers and the newcomer.
This idea was ﬁrst proposed by Li et al. [7]. They designed a
tree-structured regeneration scheme (called RCTREE), where
the tree has the newcomer as the root and has providers as
intermediate and leaf nodes, and the repair data reach the
newcomer along the branches of the tree. In addition, they
allowed the repair data to be encoded at the intermediate nodes
of the tree to further reduce the regeneration time. However,
because of insufﬁcient amount of repair data transmitted,
RCTREE cannot maintain the MDS property.

In this paper, we study the problem of minimizing re-
generation time in heterogeneous networks while maintaining
the MDS property. Our contributions include two parts as
described below.

First, we propose a regenerating scheme supporting non-
uniform repair trafﬁc. Compared with previous studies, our
scheme has the advantage of choosing the repair trafﬁc
according to the set of largest available bandwidths while
maintaining the MDS property, and thus achieves the best
possible regeneration time among the schemes those are based
on dynamic determination of repair trafﬁc. We introduce the
feasible region to generalize the restrictions on the repair
trafﬁc for the MDS property. For the MSR case, we study
the structure and the uniqueness of maximal feasible regions
and then ﬁnd their optimal solution. For the non-MSR case,
we construct a heuristic feasible region with which the repair
trafﬁc can be dynamically determined by solving a linear
programming problem for each round of repair. We refer to
this regeneration scheme as ﬂexible regeneration (FR).

Second, we reconsider the tree-structured regeneration ap-
proach with regenerating codes, because the previous tree-
structured regeneration scheme [7] cannot preserve the MDS
property in the repair process. We develop the information

2

ﬂow graph method from [3]. Using this method, we derive the
minimum amount of data to be transmitted on each link in a
given regeneration tree, and formulate the problem of building
an optimal regeneration tree to minimize the regeneration time.
Unfortunately, we ﬁnd this problem NP-complete, mainly be-
cause the information ﬂow on each link exhibits a correlation
with the number of providers using this link. We thus propose a
heuristic algorithm, called Tree-structured Regeneration (TR),
to ﬁnd a near-optimal regeneration tree. Furthermore, we
propose a Flexible Tree-structured Regeneration (FTR) scheme
by combining TR with FR.

These ideas can be illustrated with the example shown in
Fig. 1. Consider the overlay network shown in Fig. 1(a), where
v0 is the newcomer, and v1, v2, v3, v4 are the d = 4 providers.
The bandwidths are labeled on the links, which range from
5Mbps to 70Mbps. We assume that the redundancy is coded
as an (n = 5, k = 2)-MDS code, such that any 2 out of 5
storage nodes are able to reconstruct the ﬁle. Suppose that the
size of the original ﬁle is equal to M = 480Mb, and each
storage node stores α = M/k = 240Mb.

M

Fig. 1(b) shows the conventional

regeneration scheme
(STAR)[3] which uses the star-structured topology: v0 receives
data directly from the four providers. In order to regenerate
the lost data at v0 using the regenerating code, an amount of
k(d−k+1) = 80Mb data need to be downloaded from each
β =
provider. Thus, the regeneration time of STAR is determined
by the slowest transmission which takes
10M bps = 8 seconds.
Fig. 1(c) shows the STAR-based ﬂexible regeneration (FR)
scheme, where each provider is allowed to generate a different
amount of coded data. We ﬁnd that the MDS property can
be maintained if providers v1, v2, v3, v4 generate and send
β1 = 150Mb, β2 = 150Mb, β3 = 60Mb, β4 = 30Mb,
respectively. As a result, the regeneration time of FR is reduced
to max{

10M bps} = 3 seconds.

70M bps ,

50M bps ,

20M bps ,

β4

β2

β3

β1

β

β

β

2β

70M bps ,

50M bps ,

The regeneration trees used by TR and FTR are shown
in Fig. 1(d) and (e), respectively. They coincide with the
same tree in this example. In TR, each provider generates
β = 80M b coded data with its local storage. Accord-
the minimum amount of data trans-
ing to our analysis,
ferred on edge (v1, v0) is at
it costs TR
least 2β. Thus,
max{
35M bps} = 4 seconds to ac-
20M bps ,
complish the regeneration. With FTR, each provider may gen-
erate different amount of repair data. The solution given by our
FTR algorithm is that providers v1, v2, v3, v4 generate β1 =
133.33Mb, β2 = 133.33Mb, β3 = 53.33Mb, β4 = 53.33Mb,
respectively. The amount of data ﬂow transmitted on the link
(v1, v0) is β1 + β4 = 186.67Mb, and the regeneration time is
max{ β1+β4
70M bps ,

35M bps} = 2.67 seconds.

To evaluate the performances of our schemes, we implement
these regeneration schemes and carry out simulations with
practical link capacities. Simulation results show that, depend-
ing on heterogeneous link capacities, our proposed schemes
can reduce the regeneration time by 10% ∼ 90%, compared
with the conventional STAR-structured regeneration scheme.
The remainder of the paper is organized as follows. In
Section II, we formulate the process of data regeneration in
distributed storage systems and introduce the random linear
coding and information ﬂow graph, which is the theoretical

50M bps ,

20M bps ,

β2

β3

β4

β

3

Fig. 1. Examples for tree regeneration schemes: STAR, FR, TR and FTR. The parameters are n = 5, d = 4, k = 2, M = 480Mb, α = M/k = 240Mb,
β = α
d−k+1 = 80Mb. The lengths of the blocks indicate the amount of repair data generated from each provider. The regeneration time of STAR, FR, TR
and FTR is 8s, 4s, 3s and 2.67s, respectively.

tool applied in the analysis. In Section III, we study the
ﬂexible regeneration. In Section IV, we reconsider the tree-
structured regeneration scheme by analyzing the corresponding
information ﬂow graph. In Section V, we propose a ﬂexible
scheme based on tree-structured regeneration. In Section VI,
we evaluate the performance of our three proposed regen-
eration schemes. Finally, we introduce the related works in
Section VII, and conclude the paper by Section VIII.

II. PROBLEM FORMULATION

From this section, we expand the unit from ’bit’ to ’block’
that comprises a speciﬁc length of bits for describing the
variables M, α, β, and βi.

Assume that a ﬁle is divided into M blocks and encoded into
nα blocks of equal length. The coded blocks are disseminated
to n storage nodes, with each node holding α blocks. The
reliability requirement is formalized as the MDS property,
which requires that the ﬁle can be reconstructed by accessing
any k storage nodes. After a storage node fails, the newcomer
accesses d providers to regenerate α blocks. With regenerating
codes, each provider generates β coded blocks by encoding the
local α blocks and directly transmits them to the newcomer.
We use a complete graph G(V, E) to represent the overlay
network consisting of the d providers and the newcomer
[7]. The d provider-to-newcomer ﬂows form a star topology
centered at the newcomer. For any two nodes u, v ∈ V , let
c(u, v) denote the link capacity from u to v. For a speciﬁc
regeneration process, let f (u, v) denote the number of blocks
transmitted over the link (u, v). We assume that the coding
operations are streamlined with the data transmission, which
dominates the regeneration time. Notice that in real-world
overlay networks, the end-to-end links usually have different
capacities, which may vary in one or two orders of magnitude

[8]. The regeneration time can be simply represented as

max

|(u, v) ∈ E

(cid:26) f (u, v)

c(u, v)

(cid:27)

The challenge is how to minimize the regeneration time
without violating the MDS property. The regeneration process
based on the star topology may suffer from a bottleneck
caused by the lowest link capacity between the providers and
the newcomer. In general, we can utilize two approaches to
accelerate the regeneration process in heterogeneous networks.
The ﬁrst is to generate a different amount of repair data from
each provider according to its outgoing link capacity. The
second is to utilize the links between providers to by-pass
links of low capacities.

Therefore, a regeneration scheme can be decomposed into
two parts: 1) an algorithm that ﬂexibly determines the repair
ﬂows f (u, v), (u, v) ∈ E, while assuring that the newcomer
obtains enough information to regenerate the desired data; 2)
a set of codes indicating how to encode the blocks and how to
reconstruct the ﬁle. For the latter part, we employ the random
linear network codes, with which we are able to utilize the
information ﬂow graph technique [3] to simplify the problem.

A. Random linear network coding and information ﬂow graph
Dimakis et al. [3] proposed the information ﬂow graph
technique to analyze the minimum repair bandwidth for main-
taining the MDS property. Speciﬁcally,
the
information ﬂow graph in the following way. For each storage
node u, create two nodes uin (in-node) and uout (out-node)
and a link of capacity α from uin to uout. Create a source node
s and for each initial storage node u, add a link from s to uin
with inﬁnite capacity. For a storage node v regenerated by
accessing d providers, add d links from the out-nodes of the d
providers to the in-node of newcomer v, each with capacity β.

they construct

50Mbps70Mbps35Mbps10Mbps10Mbps20Mbps15Mbps30Mbps5Mbps25Mbpsv1v4v3v0v2v1v4v3v0v2v1v4v3v0v2v1v4v3v2v0β1β2β3β450Mbps70Mbps10Mbps20Mbpsv1v4v3v0v250Mbps70Mbps35Mbps20Mbpsv1v4v3v0v2v1v4v3v250Mbps70Mbps35Mbps20Mbpsv0Mbps60Mbps50Mbps15Mbps20Mbps602Mbps50Mbps35Mbps20Mbps6041Mbps50Mbps35Mbps20124350Mbps70Mbps10Mbps20Mbpsv1v4v3v0v2124350Mbps70Mbps10Mbps20Mbpsv1v4v3v0v250Mbps70Mbps35Mbps20Mbpsv1v4v3v0v2v1v4v3v250Mbps70Mbps35Mbps20Mbpsv050Mbps70Mbps10Mbps20Mbpsv1v4v3v0v2(a)(d)(e)(b)(c)12431243For the purpose of proposal in this paper, we assume various
link capacities βi between the providers and the newcomer. If
a data collector(DC) connects to k storage nodes to reconstruct
the ﬁle, add k links of inﬁnite capacity from the out-nodes of
these storage nodes to the data collector.
In the distribution process, the original ﬁle is divided into M
blocks aj(j = 1, 2,··· , M ) of equal length, and is encoded
into nα blocks bi(i = 1, 2,··· , nα). These coded blocks
are then evenly distributed to n storage nodes. With linear
codes, each coded block bi is a linear combination of blocks
a1, a2,··· , aM , i.e.,

 =





b1
b2
...
bnα

c1,1
c2,1
...
cnα,1

c1,2
c2,2
...
cnα,2

···
···
...
···

c1,M
c2,M
...

cnα,M





a1
a2
...
aM



For the MDS property, we have to carefully choose the
combination coefﬁcients ci,j so that the original blocks aj
can be reconstructed from any k storage nodes. A possi-
ble encoding method is to utilize Reed-Solomon codes [9],
e.g., setting the generator matrix [ci,j] to be a Vandermonde
matrix. For ease of implementation, the combination coefﬁ-
cients ci,1, ci,2,··· , ci,M for any speciﬁc coded block bi =
j=1 ci,jaj are transmitted and stored together with block bi.
For simplicity, we use (cid:126)c = (c1, c2,··· , cM ) to denote the row
vector of combination coefﬁcients, which is also called the
coding vector of block b.

(cid:80)M

In the regeneration process, we employ a random linear net-
work coding scheme as the regenerating code to facilitate the
regeneration of coded blocks at the newcomer. Without loss of
generality, each provider vi generates and transmits βi coded
blocks b(r)
as random linear combinations of
its local α blocks bi,1, bi,2,··· , bi,α as follows

i,2 ,··· , b(r)

i,1 , b(r)

i,βi

 =





b(r)
i,1
b(r)
i,2
...
b(r)
i,βi

c(r)
1,1
c(r)
2,1
...
c(r)
βi,1

c(r)
1,2
c(r)
2,2
...
c(r)
βi,2

···
···
...
···

c(r)
1,α
c(r)
2,α
...
c(r)
βi,α







bi,1
bi,2
...
bi,α

where i = 1, 2,··· , d, and the coefﬁcients c(r)
i,j are randomly
chosen from the ﬁnite ﬁeld of the linear regenerating code
such that the coefﬁcient matrix [c(r)

i,j ] has rank βi.

To complete the regeneration process, the newcomer re-
i=1 βi blocks and generates its own α blocks

by

ceives γ = (cid:80)d
 =


2

1

b(cid:48)
b(cid:48)
...
b(cid:48)

α



1,1

2,1

c(cid:48)
c(cid:48)
...

c(cid:48)

1,2

2,2

c(cid:48)
c(cid:48)
...

c(cid:48)

α,1

α,2



···
···
...
···

c(cid:48)
c(cid:48)

1,γ

2,γ

...

c(cid:48)

α,γ





b(r)
1,1
...
b(r)
1,β1
b(r)
2,1
...
b(r)
2,β2...
b(r)
d,βd

4

where the coefﬁcient matrix [c(cid:48)
cient matrices [c(r)
be noted that the coding vectors of the blocks b(cid:48)
similarly generated and stored at the newcomer.

i,j] is obtained from the coefﬁ-
i,j ] for the linear regenerating code. It should
i are also

1 , b(cid:48)(cid:48)

2 ,··· , b(cid:48)(cid:48)

In the reconstruction process, the data collector collects kα
blocks b(cid:48)(cid:48)
kα from k storage nodes, whose coding
vectors form a kα-by-M matrix [c(cid:48)(cid:48)
i,j]. As long as the matrix
has rank M, we can reconstruct the original ﬁle from these
coded blocks (as required by the MDS property [1]) by solving
the following linear equation:
c(cid:48)(cid:48)
c(cid:48)(cid:48)
...

 =

c(cid:48)(cid:48)
c(cid:48)(cid:48)
...











c(cid:48)(cid:48)
c(cid:48)(cid:48)
...

2,M

1,M

1,2

2,2

2,1

1,1

c(cid:48)(cid:48)

c(cid:48)(cid:48)

kα,1

kα,2

c(cid:48)(cid:48)

kα,M

1

2

b(cid:48)(cid:48)
b(cid:48)(cid:48)
...
b(cid:48)(cid:48)

kα

···
···
...
···

a1
a2
...
aM

With the information ﬂow graph, Dimakis et al. proved the

following result [3]:

Lemma 1: In the information ﬂow graph constructed ac-
cording to the repair history of a distributed storage system,
if the max-ﬂow from s to a data collector is no less than the
ﬁle size M, then with random linear codes over ﬁeld F, the
data collector can recover the ﬁle with probability arbitrarily
close to 1 as |F| → ∞.

III. STAR-STRUCTURED REGENERATION WITH FLEXIBLE

REPAIR TRAFFIC

We ﬁrst consider the approach of utilizing ﬂexible non-
uniform repair trafﬁc to accelerate the regeneration process
with heterogeneous link capacities. Generalizing the set of
repair trafﬁc that preserves the MDS property as the “feasible
region”, we characterize the structure of maximal feasible
regions and derive the ﬂexible regeneration scheme whose fea-
sible region subsumes the feasible region of previous studies.
Speciﬁcally, for a regeneration process, let βi denote the
repair trafﬁc, i.e., the number of blocks transmitted from the
i-th provider to the newcomer, and let βββ = (β1, β2,··· , βd)
denote the repair bandwidth in terms of the vector of repair
trafﬁc. For each round of repair, if we have multiple choices
of βββ, then we say that ‘ﬂexible repair trafﬁc is supported’. Let
D denote the set of possible choices of βββ. We call D ⊂ Rd a
feasible region, if the MDS property is maintained as long as
βββ is chosen from D.

With a given feasible region, minimizing the regeneration

time in each round of repair is equivalent to solving:

βββ∈D max
min
i=1,··· ,d

βi

c(vi, v0)

(1)

where vi is the i-th provider and v0 is the newcomer. The link
capacities c(vi, v0) may be simply written as ci.

According to the analysis of feasible regions in the follow-
ing subsection, we can see that a maximal feasible region is
actually a convex polytope, which makes problem (1) a linear
programming problem and solvable in polynomial time.

5

Fig. 2. An example of the information ﬂow graph when k = 3, d = 4, where βββi denotes the repair bandwidth in the repair when the node xi
newcomer. Without loss of generality, we suppose that the elements of βββi are sorted such that βi

1 ≤ βi

2 ≤ βi

3 ≤ βi

We can see that the min-cut equals(cid:80)k

j=1 min{σj (βββ9−j ), α} in this ﬁgure.

4, i = 0, 1, 2, and let σj (βββi) =(cid:80)d−k+j

in acts as the
l .
βi

l=1

A. Structure of a maximal feasible region

In the information ﬂow graph,

the capacities of links
entering a newcomer’s in-node represent the amount of in-
formation downloaded from each provider. Therefore, with
ﬂexible repair trafﬁc, we set the corresponding link capacities
as βi, i = 1,··· , d, instead of β. With this minor difference
from the conventional information ﬂow graph, it can be seen
that Lemma 1 still holds.

In order to convert the MDS property into constraints on
the feasible region, we analyze the min-cuts of the information
ﬂow graph:
Lemma 2: If in each round of repair, the newcomer accesses
d providers with the repair bandwidth βββ ∈ D. Then in the
corresponding information ﬂow graph, the min-cut between s
and any data collector DC satisﬁes

min-cut(s, DC) ≥ k(cid:88)

(cid:26)

min

βββ∈D σj(βββ), α
min

j=1

(2)

(cid:27)

Here σj(βββ) is deﬁned as the sum of the d − k + j smallest
numbers of β1, β2, . . . , βd. This bound can be matched with
equality.
Proof: Let (U, ¯U ) denote a cut separating DC and s such
that DC ∈ U and s ∈ ¯U, respectively. Then U must contain
at least k storage nodes. Consider each of the ﬁrst k nodes of
U in the topological sorting. If it is an input node, the set of
repair links will be included in the cut. If it is an output node,
the storage link of capacity α will be included. As illustrated
in Fig. 2, it can be veriﬁed that the equality of (2) can be
achieved when there are k cascading repairs, each of which
includes the newcomers in previous rounds as helper nodes.

(cid:27)

(cid:26)

k(cid:88)

j=1

k storage nodes sufﬁce to reconstruct the original ﬁle, while
allowing a newcomer to connect to any set of d providers,
then the following condition must be satisﬁed:

M C(D, α) =

min

βββ∈D σj(βββ), α
min

≥ M.

(3)

We refer to this condition as the min-cut condition. A set D ⊂
Rd is a feasible region if and only if it satisﬁes the min-cut
condition.

Larger feasible region means more ﬂexibility in ﬁnding the
suitable repair bandwidth. Therefore, we only need to consider
the maximal feasible regions. The following theorem shows
that a maximal feasible region can be described by a k-tuple
(x1, x2,··· , xk).
Theorem 1: A maximal feasible region D can be written in

the following form:

D = {βββ |σj(βββ) ≥ xj,

where 0 ≤ x1 ≤ ··· ≤ xk ≤ α and(cid:80)k

j = 1, . . . , k},

j=1 xj ≥ M.

Proof: Let D(cid:48) be a feasible region satisfying the min-
cut condition in (3). As the sequence minβββ∈D(cid:48) σj(βββ) is non-
decreasing for j = 1, . . . , k, we let i be the largest integer
such that minβββ∈D(cid:48) σk−i+1(βββ) ≥ α. Thus the min-cut of an
information ﬂow graph under D(cid:48) is

k−i(cid:88)

j=1

βββ∈D(cid:48) σj(βββ) + iα ≥ M.

min

As the bound of the min-cut (2) can be matched with
equality, we use M C(D, α) to represent the minimum min-
cut of all possible information ﬂow graphs with a given region
D and the storage per node α. If we want to ensure that any

where

xj =

If D(cid:48) cannot be rewritten in the required form, we construct

another feasible region D(cid:48)(cid:48) ⊃ D(cid:48) as

D(cid:48)(cid:48) = {βββ|σj(βββ) ≥ xj, j = 1,··· , k}

(cid:40) min

βββ∈D(cid:48) σj(βββ),
α,

j = 1, . . . , k − i,
j = k − i + 1, . . . , k.

DC∞∞∞∞∞∞ d-2∞∞k=3repair reconstructionstorage nodeSsourceDCdata collector d-1DC∞∞∞k=3 To repair u1 To repair u2 To repair u320Mbps60Mbps50Mbps35Mbps30Mbps25Mbps10Mbps15Mbps45Mbps40Mbpsv1v3v4v0v220Mbps60Mbps50Mbps35Mbps30Mbps25Mbps10Mbps15Mbps45Mbps40Mbpsv1v3v4v0v250Mbps60Mbps35Mbps10Mbps15Mbps20Mbps15Mbps30Mbps5Mbps25Mbpsv1v4v3v0v220Mbps60Mbps50Mbps35Mbps30Mbps25Mbps10Mbps15Mbps45Mbps40Mbpsv1v3v4v0v2inx1inx2inx3inx4inx5Soutx1outx2outx3outx4outx5inx6inx7inx8outx6outx7outx8inixoutix)(63616263647172738182748384)(72)(810 ≤ x1 ≤ ··· ≤ xk ≤ α and (cid:80)k

Since D(cid:48) satisﬁes the min-cut condition, we can deduce that
j=1 xj ≥ M. Thus, D(cid:48)(cid:48) is
of the required form. To complete the proof, it is sufﬁcient to
show that D(cid:48)(cid:48) is maximal and satisﬁes the min-cut condition.
From the construction, we have D(cid:48) ⊂ D(cid:48)(cid:48), since for any
βββ ∈ D(cid:48) it must hold that σj(βββ) ≥ xj. As D(cid:48) is a maximal
feasible region, we conclude D(cid:48)(cid:48) is maximal. We can verify
that D(cid:48)(cid:48) also satisﬁes the min-cut condition:

M C(D(cid:48)(cid:48), α) =

min

βββ∈D(cid:48)(cid:48) σj(βββ), α
min

(cid:26)

(cid:27)

j=1

k(cid:88)
k−i(cid:88)
≥ k−i(cid:88)
k−i(cid:88)

j=1

j=1

=

=

j=1

βββ∈D(cid:48)(cid:48) σj(βββ) + iα
min

xj + iα

βββ∈D(cid:48) σj(βββ) + iα ≥ M

min

B. The optimal feasible region for α = M/k

For the MSR case where the minimum storage α = M/k,
we ﬁnd that there exists one maximum feasible region, which
minimizes the regeneration time for any link capacity settings.
Theorem 2: For the case of α = M/k, any feasible region

is a subset of the maximum feasible region
D∗ = {βββ|σ1(βββ) ≥ M/k}

Proof: First, it can be seen that for any set D

βββ∈D σ1(βββ) ≤ min

βββ∈D σ2(βββ) ≤ . . . ≤ min

min

βββ∈D σk(βββ)

because for any j = 1, 2,··· , k − 1

βββ∈D σj+1(βββ) = σj+1(βββ(cid:48)) ≥ σj(βββ(cid:48)) ≥ min

min

βββ∈D σj(βββ),

where βββ(cid:48) is the repair bandwidth that minimizes σj+1(βββ(cid:48)).
Thus, we have

M C(D∗, α) ≥ k min

βββ∈D∗ σ1(βββ) ≥ M
which means that D∗ is indeed a feasible region.

On the other hand, for any feasible region D and any βββ ∈ D,

if σ1(βββ) < M/k, then

M C(D, α) < M/k + (k − 1)α = M

which contradicts the min-cut condition in (3). Thus, we must
have σ1(βββ) ≥ M/k and hence βββ ∈ D∗.
As a conclusion, when using the MSR codes, we can set
the feasible region to be D∗ and in each round of repair, we
determine the repair bandwidth βββ by solving the optimization
problem (1), which is reduced to:

min
βββ∈D∗
subject to:

βi
ci

max
i=1,··· ,d
σ1(βββ) ≥ M/k

(4)

6

where ci is the link capacity from the i-th provider vi to the
newcomer v0.
Without loss of generality, we may assume c1 ≤ c2 ≤ ··· ≤
cd. Then the optimal solution βββ∗ to problem (4) can be solved
explicitly as follows



cjM

k(cid:80)d−k+1
k(cid:80)d−k+1

cd−k+1M

i=1

i=1

ci

ci

β∗
j =

if 1 ≤ j ≤ d − k + 1

if d − k + 1 < j ≤ d

C. The feasible region for α > M/k

For the case of α > M/k, we ﬁnd out that there does
not exist a maximum feasible region for any α > M/k and
k ≥ 3 (Please refer to appendix for a detailed proof). In
other words, the optimal feasible region depends on the link
capacities. While regenerating data for a new node, we still do
not know the link capacities of helper nodes that will join when
future failures occur, so we cannot determine the conditions
for the optimal solution. Here we use an example to explain
this statement.

Example 1: Set n = 5, k = 3, d = 4, M = 12, and α = 6,

and consider the following two feasible regions:

D1 = {βββ|σ1(βββ) ≥ 1, σ2(βββ) ≥ 5, σ3(βββ) ≥ 6},
D2 = {βββ|σ1(βββ) ≥ 2, σ2(βββ) ≥ 4, σ3(βββ) ≥ 6}.

We ﬁnd two different repair bandwidths, βββ1 = (0, 1, 4, 4) ∈
D1\D2 and βββ2 = (0, 2, 2, 2) ∈ D2\D1. If the corresponding
link capacities ci are given as (1, 1, 4, 4), the regeneration
times for βββ1 and βββ2 are 1 second and 2 seconds, respec-
tively. Under this capacity setting, D1 is a better solution.
However, with another setting of link capacities (1, 2, 2, 2),
the regeneration times are then changed to 2 seconds and
1 second, respectively. Feasible region D2 outperforms D1
in this setting. According to our previous analysis, D1,D2
are both maximal feasible regions and there does not exist a
feasible region including both of them. Thus it is unable to
minimize the regeneration times for both the above capacity
settings simultaneously.

From this example, we can conclude that,

in order to
minimize the regeneration time, knowledge on the provider-
to-newcomer link capacities for the next rounds of repairs
is necessary, which is impractical in real-world distributed
storage systems. Therefore, we propose a heuristic feasible
region instead:
D∗ = {βββ | σj(βββ) ≥ min{(d − k + j)β, α}, j = 1,··· , k}
where β is the amount of data downloaded from each provider
in the conventional regenerating scheme, which can be cal-
culated according to the optimal tradeoff between storage α
i=1 βi from βββ [3]. It can be
seen that the repair trafﬁc of conventional regenerating scheme
βββ = (β,··· , β) belongs to D∗. Therefore, with this feasible
region, the regeneration time will never be worse than the
conventional regenerating scheme.
With the feasible region D∗, we can determine the amount
of data to be downloaded from each provider in each round of

and the total repair bandwidth(cid:80)d

repair by solving the linear programming problem (1). In case
that the solution βββ = (β1,··· , βd) takes on fractional values,
its components can be rounded up to their nearest integers.
Note that we may choose large M to make the rounding error
negligible.

IV. TREE-STRUCTURED REGENERATION WITH CONSTANT

REPAIR TRAFFIC

Li et al. [7] ﬁrst proposed a tree-structured regeneration
scheme which transmits the regeneration trafﬁc along a care-
fully selected tree spanning all the providers. However, as
shown in the appendix, this method cannot maintain the MDS
property. In this section, we reconsider the problem of optimiz-
ing the regeneration time for tree-structured regeneration and
maintaining the MDS property featured by entire distributed
storage systems.
A tree-structured regeneration solution has two parts: the
regeneration tree T ⊂ E and the number of blocks f (u, v)
transmitted on each link of the tree. In the following sub-
sections, we ﬁrst study the minimum f (u, v) in a given
regeneration tree to preserve the MDS property. Thereafter, we
show that the problem of building an optimal regeneration tree
is NP-hard. Finally, we conclude this section with a heuristic
algorithm for constructing a regeneration tree.

A. The minimum f (u, v) for a given regeneration tree

As the conventional information ﬂow graph is originally
constructed for the star topology, we ﬁrst generalize it to the
tree topology for regeneration.

To construct the information ﬂow graph for tree-structured
regeneration,
instead of simply adding d links from the
providers’ out-nodes to the newcomer’s in-node, we rather add
links according to the regeneration tree T and the number of
blocks f (u, v) transmitted on each link of the tree. During the
regeneration, if provider u transmits f (u, w) blocks to provider
w, we add a link from uout to wout with capacity f (u, w),
whereas if provider u transmits f (u, v) blocks directly to the
newcomer v, we add a link from uout to vin with capacity
f (u, v). For example, Fig. 3(a) shows a regeneration tree
consisting of three providers u1, u2, u3 and a newcomer v,
and Fig. 3(b) presents the corresponding part of information
ﬂow graph.

7

(a) regeneration tree

(b) corresponding part of information ﬂow graph

Fig. 3. An example of the part of the generalized information ﬂow graph for
a regeneration tree consisting of three providers u1, u2, u3 (i.e., d = 3) and
a newcomer v.

separates the data collector DC from the source, where U is
the set of nodes containing DC. Then U must contain at least
k “out” nodes. Label the k corresponding storage nodes as
u1, u2,··· , uk in a topological order, such that ui is a provider
in regenerating uj only if i < j. Fig. 4 demonstrates the min-
cut in an information ﬂow graph for a series of tree-structured
regeneration processes for d = 4 and k = 3, where ui is a
provider with respect to uj for 1 ≤ i < j ≤ 3, and U contains
all the in-nodes and out-nodes of u1, u2, u3.
i /∈ U,
then the i-th set contains only one link (uin
); otherwise,
the i-th set contains all the cut-links introduced in the repair
of node ui. According to our scheme, a link (u, v) has ﬂow
rate muβ only if the subtree rooted at u has mu nodes. For
repairing ui, as there are at most i − 1 providers in U, there
are at least d − i + 1 providers in ¯U. Thus the total ﬂow rate
of the i-th set is no less than min{(d − i + 1)β, α}.

We divide the cut links into k sets as follows: if uin

i , uout

i

With the generalized information ﬂow graph, we are able to
determine the minimum ﬂow f (u, v) on each link that ensures
the MDS property.

Theorem 3: For a given regeneration tree T rooted at the
newcomer, in order to preserve the MDS property, the mini-
mum number of blocks transmitted on each link (u, v) ∈ T
is

min{muβ, α}

regenerating scheme, which satisﬁes (cid:80)k

where mu is the number of nodes in the subtree rooted at u,
and β is the number of blocks transmitted in the conventional
i=1 min{(d − i +
1)β, α} = M.
Proof: The key is to compute the min-cut of the general-
ized information ﬂow graph. Let [U, ¯U ] denote a min-cut that

Fig. 4. An example of min-cut in an information ﬂow graph in the tree-
structured regeneration, where d = 4, and k = 3. The dashed line shows the
min-cut and the bold links are the cut-links.

u1f(u2,v)f(u1,u2)f(u3,u2)αααu3u2vαf(u2,v)f(u1,u2)f(u3,u2)2inu2outu1inu1outu3inu3outuinvoutvu1f(u2,v)f(u1,u2)f(u3,u2)αααu3u2vαf(u2,v)f(u1,u2)f(u3,u2)inu2outu2inu1outu1inu3outu3invoutvu1f(u2,v)f(u1,u2)f(u3,u2)u3u2vαf(u2,v)f(u1,u2)f(u3,u2)invoutvαinu1outu1αinu3outu3αinu2outu2inu2α∞∞∞k=3αinu1outu1inu3outu3outu2α To repair u1 To repair u2 To repair u3DCoutv1outv2outv3outv4CutS∞∞∞∞∞cut [U, ¯U ] must be no less than(cid:80)k

Sum up the volumes of the cut links. The total volume of the
i=1 min{(d− i + 1)β, α} =
M. Thus, if f (u, v) ≥ min{muβ, α}, DC can construct the
ﬁle by assessing any k storage nodes.

To show that we cannot further reduce f (u, v), we need to
show that the min-cut with the minimum volume M is achiev-
able. According to the information ﬂow graph constructed in
the proof, we can know that such a min-cut is achievable if we
require each provider to provide β blocks, which means that
the solution min{muβ, α} is optimal for a given regeneration
tree.

B. Construction of the optimal regeneration tree

With the knowledge of how much information to be trans-
mitted on each link, the remaining task is to build an opti-
mal regeneration tree T to minimize the regeneration time.
However, we ﬁnd that the optimal regeneration tree (ORT)
problem is NP-hard. To demonstrate this, we start with the
formal deﬁnition of the ORT problem.
Deﬁnition 1: For a given overlay network G(V, E) with link
capacities c(u, v), (u, v) ∈ E, the optimal regeneration tree
problem is to ﬁnd a spanning tree T such that the regeneration
c(u,v) |(u, v) ∈ T} is minimized, where f (u, v) =
time max{ f (u,v)
min{muβ, α} and mu is the number of nodes in the subtree
rooted at u ∈ V .

To study the complexity of the ORT problem, it is equivalent
to restating this optimization problem as a decision problem,
which aims to determine whether the regeneration time of an
optimal regeneration tree is no more than 1. The following
theorem shows that this problem is NP-hard.
Theorem 4: The ORT problem is NP-hard.

Proof: We ﬁrst show that ORT ∈ NP. Suppose we are
given a graph G = (V, E). The certiﬁcate we choose is the
optimal regeneration tree T . The veriﬁcation algorithm checks,
for each edge (u, v) ∈ T , that f (u,v)
c(u,v) ≤ 1. This veriﬁcation
can be performed in polynomial time.
We now prove that the ORT problem is NP-hard by re-
duction from the VERTEX-COVER problem, which is known
to be NP-complete. In particular, given an undirected graph
G = (V, E) and an integer k, the VERTEX-COVER problem
asks whether all edges can be “covered” by k nodes, where
node u ∈ V can cover edge e ∈ E only if they are
adjacent. For an instance of the VERTEX-COVER problem,
we construct a regeneration scenario in an overlay network
G(cid:48) = (V (cid:48), E(cid:48)), such that the regeneration time is less than 1
if and only if G has a vertex cover of size k.
We construct G(cid:48) in the following way. G(cid:48) has four layers of
nodes. The ﬁrst layer has only one node that is the root t. The
second layer has two nodes, node a and node b. Both a and b
are connected to the root. The link capacity of edge (a, t) is
k+|E|+1 and the link capacity of edge (b, t) is unlimited. The
nodes in the third layer correspond to the vertices in graph G,
all of them are connected to both a and b. The link capacity
of each edge connected to a is unlimited, whereas the link
capacity of each edge connected to b is 1. The nodes in the
last layer correspond to the edges in graph G. Each node in the
last layer is connected to two nodes in the third layer by the

8

corresponding edges in graph G. The edges, which connect the
last layer nodes to the third layer nodes, each have an unlimited
capacity. Links that are not mentioned in the construction are
supposed to have zero capacity.
From the construction above, graph G(cid:48) can be constructed
from G in polynomial time. Fig. 5 shows an example of this
reduction for the VERTEX-COVER problem with k = 2,
where Fig. 5(a) is an instance of G, and Fig. 5(b) is the graph
G(cid:48) constructed from G.

(a)

(b)

Fig. 5. Reduction of the VERTEX-COVER problem to the ORT problem for
k = 2: (a) An undirected graph G = (V, E); (b) The graph G(cid:48) produced by
the reduction procedure.

We next show that this transformation of G into G(cid:48) is a
reduction. First, suppose that G has a vertex cover set V (cid:48) ⊆ V ,
where |V (cid:48)| = k. We claim that we can ﬁnd a tree whose
regeneration time is no more than 1. This tree is constructed
according to the vertex cover as follows. For each node ei of
the fourth layer, let its parent be vj which covers the edge
ei in the vertex cover of G. For each node vi of the third
layer, if it belongs to the vertex cover V (cid:48), let its parent be a;
otherwise, let its parent be b. Finally, let the parent of a and
b be the root. It can be veriﬁed that the regeneration time is
exactly equal to 1.
Conversely, suppose that G(cid:48) has a tree whose regeneration
time is no more than 1. Then, we claim that the edges of
G can be covered by no more than k nodes. Let V (cid:48) ⊆ V
be the set of nodes that correspond to children of node a in
the regeneration tree. First, V (cid:48) is a vertex cover of G. If it is
not the case, some nodes in the fourth layer will have to be
connected to the root through b, causing some ﬂow entering
b larger than 1 and the regeneration time less than 1. Second,
we show that |V (cid:48)| ≤ k. As all the |E| nodes in the fourth layer
must transmit their data to the newcomer through a, there will

v1v2v3v4e1e2e3e4v1v2v3v4e1e2e3e4abK+|E|+11111t∞v1v2v3v4e1e2e3e4abK+|E|+11111t∞CoreAggTORTOR1234AggTOR56n1040100v1v2v3v4e1e2e3e4v1v2v3v4e1e2e3e4abk+|E|+11111t∞v1v2v3v4e1e2e3e4abk+|E|+11111t∞CoreAggTORTOR1234AggTOR56n1040100be at least |V (cid:48)| + |E| + 1 nodes transferring data from node
a to root t. Because the capacity of link (a, t) is k + |E| + 1
and the regeneration time is no more than 1, we conclude that
|V (cid:48)| ≤ k.

C. The heuristic algorithm for constructing the optimal regen-
eration tree

In this subsection, we propose a heuristic algorithm to solve
the ORT problem since it is NP-hard as mentioned above.
The algorithm is inspired by Prim’s algorithm [10] for the
maximum weighted spanning tree problem. We start from a
tree containing only the newcomer as the root and iteratively
add the remaining nodes to the tree until it spans all the
providers. In each iteration, we try all possible positions for
each remaining provider and choose the best position to add
the corresponding provider into the regeneration tree. The
details are shown in Algorithm 1, where v0 represents the
root for the newcomer, and (v(cid:48), u(cid:48)) records the best positions.

Algorithm 1 Find a regeneration tree T for a given network
G(V, E).
1: Input: Network topology G(V, E), link capacities c(u, v),

storage amount α, repair trafﬁc β

Compute the regeneration time max{ f (u,v)
(u, v) ∈ T ∪ {(v, u)}} for tree T ∪ {(v, u)}
If the regeneration time is better than previous
choices, update (v(cid:48), u(cid:48)) ← (v, u)

c(u,v)

|

2: Output: Regeneration tree T
3: T ← v0
4: A ← V − {v0}
5: while A (cid:54)= ∅ do
6:
7:
8:

for all u ∈ T do

for all v ∈ A do

9:

end for

10:
11:
12:
13:
14: end while

end for
T ← T ∪ {(v(cid:48), u(cid:48))}
A ← A − {v}

The most time-consuming step is to test all possible posi-
tions for each provider, which has no more than |V |2 choices.
Each test takes a linear time of order O(|V |) to compute the
regeneration time. Thus, the algorithm runs in polynomial time
of order O(|V |3).

V. TREE-STRUCTURED REGENERATION WITH FLEXIBLE

END-TO-END TRAFFIC

In Sections III and IV, we have discussed two independent
approaches to reduce the regeneration time: 1) allowing non-
uniform end-to-end repair trafﬁc; 2) allowing tree-structured
regeneration topology. In this section, we propose a Flexible
Tree-structured Regeneration (FTR) scheme, which combines
the advantages of the two approaches to further reduce the
regeneration time.

We present the logic ﬂow of the proposed FTR scheme in
three steps. First, we analyze the restrictions on the amount of
repair data generated by each provider to maintain the MDS

9

property. Second, for a given regeneration tree, we calculate
the optimal regeneration time based on the analysis in the
ﬁrst step. Finally, as we are able to determine which one of
two trees results in a faster regeneration, we obtain a heuristic
algorithm based on local searching.

A. A sufﬁcient condition for the MDS property

Roughly stated, to maintain the MDS property under a
ﬂexible trafﬁc strategy, if the providers connected to low-
capacity links generate less coded blocks, then the providers
connected to high-capacity links will have to generate more
coded blocks. Let βi denote the amount of repair trafﬁc, i.e.,
the number of coded blocks generated by the i-th provider.
Our ﬁrst task is to analyze the explicit restrictions on βi that
ensures the MDS property.

As analyzed in Section IV, during the tree-structured regen-
eration, an intermediate node needs to re-encode the received
blocks from its children only when the number of received
blocks plus the number of blocks generated by itself is larger
than α. In this case, the intermediate node transmits only α
coded blocks. Thus, for a regeneration tree T , the number of
coded blocks transmitted on each link (u, v) ∈ T will be

 (cid:88)

vi∈S(u)



f (u, v) = min

βi, α

where u denotes an intermediate node, v denotes the parent
of u in the tree, S(u) denotes the set of nodes in the subtree
rooted at u, and βi indicates the number of coded blocks
generated at vi and transmitted to u. The following theorem
provides a sufﬁcient condition for the MDS property.
regeneration, we choose βi, i = 1, 2,··· , d, that satisfy
βil ≥ min{(d − k + j)β, α} ∀j = 1, 2,··· , k

Theorem 5: The MDS property is maintained if in each

d−k+j(cid:88)

l=1

where β is again the number of coded blocks generated
by a provider in the conventional regenerating scheme, and
(i1, i2,··· , id) is a permutation of (1, 2,··· , d) such that
βi1 ≤ βi2 ≤ ··· ≤ βid.
∈ U) has volume of at least M.

Proof: We need to prove that any min-cut [U, ¯U ] (DC

As the link capacity from a storage node to the data collector
DC is set to be inﬁnity in the information ﬂow graph, we only
need to consider the case that U contains at least k storage
nodes. Let v1, v2,··· , vk be the ﬁrst k storage nodes of U
in the topological order. For j = 1, 2,··· , k, if the in-node
of vj is in the cut, all the links connected to vj will also be
included in the cut. However, if only the out-node of vj is in
the cut, the link from the in-node to the out-node of vj that
has capacity α will be included.

Following the way we determine the ﬂow on the regenera-
tion tree, for the j-th storage node vj, the number of providers
not in U will be at least d− j + 1, and hence the total capacity
of the cut links to vj will be at least

d−k+j(cid:88)

l=1

βil ≥ min{(d − k + j)β, α}

Therefore, the volume of the cut [U, ¯U ] will be no less than
M, which ensures the MDS property.

B. Determination of the optimal regeneration time for a given
tree

To support the non-uniform end-to-end repair trafﬁc for
a tree-structured regeneration, we introduce a parameter cx
to denote the end-to-end capacity from provider x to the
newcomer v0, where x may not be directly connected to v0.
Let t denote the regeneration time. For a given regeneration
tree T , the maximum amount of data transmitted in t seconds
x∈S(u) tcx if we do not perform
encoding at the intermediate node u. However, Theorem 5
x∈S(u) tcx > α, we may encode the repair
data at the intermediate node u and transmit only α blocks to
node v. Therefore, we obtain the constraints on link capacities
as follows

through link (u, v) is (cid:80)
shows that if (cid:80)

tc(u, v) ≥ min

∀(u, v) ∈ T

α,

(cid:88)

tcx

x∈S(u)

 ,

Combining the constraints on the link capacities and the MDS
property, we can write the optimal regeneration time as the
following optimization problem:

subject to:

min t

(cid:88)

α,

(5)

 , ∀(u, v) ∈ T (6)

tcx

tc(u, v) ≥ min
tσ1(ccc) ≥ (d − k + 1)β

x∈S(u)

(7)
where ccc = {cu | u ∈ V − v0}, and σ1(ccc) is, just like in (2),
deﬁned as the sum of the d− k + 1 smallest components of ccc.

C. The heuristic algorithm

Upon examining the linear programming (LP) problem in
(5), we ﬁnd that the optimal t is achieved by taking equality
in the constraint (7) as

(d − k + 1)β

σ1(ccc)

t =

10

the value

Note that

(u, v) ∈ T , and it is in fact a threshold on (cid:80)

ασ1(ccc)
(d−k+1)β is independent of links
x∈S(u) cx.
We may decompose the constraint (10) into two parts by
enumerating the number of links with capacity no less than the
threshold. Denote this number by i. Then the feasible region
given by (10) can be divided into d + 1 parts, with ccc in the
(i + 1)-th part (0 ≤ i ≤ d) satisfying:

(cid:80)

no less than the threshold;

1) there are exactly i links, of which each has a capacity
2) for each of the rest d − i links, its capacity c(u, v) ≥
x∈S(u) cx.
For each i, we run Algorithm 2 to ﬁnd a candidate re-
generation tree with i links having capacity no less than the
ασ1(ccc)
(d−k+1)β and ﬁnally pick up the best candidate as
threshold
our regeneration tree.

Algorithm 2 A heuristic algorithm for Flexible Tree-structured
Regeneration
1: Input: V, i, k, assuming v0 ∈ V is the newcomer.
2: Output: A regeneration tree T that spans V , and a capacity
allocation ccc = (cu, u ∈ V − v0) to maximize the sum of
smallest m elements in ccc under constraints P1 and P2

3: Initialize: T ← ∅, V (cid:48) ← {v0}
4: for i(cid:48) = 1 to i do
5:

Among the links in the cut [V (cid:48), V − V (cid:48)], ﬁnd the link
(u, v) with the largest capacity (assuming v ∈ V (cid:48), u /∈
V (cid:48)).
T ← T ∪ {(u, v)}
V (cid:48) ← V (cid:48) ∪ {u}

6:
7:
8: end for
9: Let d(cid:48) = d − i = |V − V (cid:48)|, m = d − k + 1
10: for each u ∈ V − V (cid:48) do
11:

Let v(cid:48) be the node maximizing c(u, v) among nodes
v ∈ V (cid:48)
cu ← c(u, v(cid:48))
T ← T ∪ {(u, v(cid:48))}

12:
13:
14: end for
15: repeat
16:
17:
18:
19:
20:
21:
22:

Sort ccc in ascending order cu1 ≤ cu2 ≤ ··· cud(cid:48) ;
For each j > m, set cuj to cum
for each u ∈ V − V (cid:48) do

Let (u, v) ∈ T be the link leaving u
for each v(cid:48) (cid:54)= v do

T (cid:48)(cid:48) ← T − (u, v) + (u, v(cid:48))
if ccc is feasible in T (cid:48)(cid:48) and ∃1 ≤ i ≤ m, cui can be
increased then
increase cui
straints P1 and P2
T ← T (cid:48)(cid:48)
break;

to maximum possible under con-

24:
25:
26:
27:
28:
29: until T is not updated in the last loop

end if
end for

end for

Algorithm 2 ﬁnds the candidate tree in two steps. First,
through lines 3–8, we ﬁnd a connected subtree containing i
links so that the smallest link capacity of i links is maximized.

(8)

(9)

Substituting (8) into the problem (5), we can convert the ob-
jective from minimizing the regeneration time to maximizing
σ1(ccc) :

23:

subject to:

c(u, v) ≥ min

max σ1(ccc)

 ασ1(ccc)

(d − k + 1)β

,

(cid:88)

cx

x∈S(u)

 , ∀ (u, v) ∈ T

(10)
As there are an exponential number of different regeneration
trees, we cannot enumerate all of them to ﬁnd the optimal tree.
Instead, we further study the structure of the LP problem (9)
to perform a local search.

After the ﬁrst step, V (cid:48) is the set of i providers connected to
the newcomer by the subtree. In the second step, we connect
the rest d(cid:48) = d − i providers to the newcomer through a
local search (lines 10–14), where we start from an initial
regeneration tree, and during each iteration of the loop from
line 15 to line 29, we check if we can get a better regeneration
tree by a pivot operation that cuts off a subtree and connects
it to some other node.

Note that for the case i = 0, lines 10–14 will set the
initial regeneration tree as the star topology. Therefore, the
regeneration tree returned by FTR is always no worse than
the FR solution.

VI. EVALUATION

In this section, we present simulation results to verify the
effectiveness of our proposed schemes: Flexible Regeneration
(FR), Tree-structured Regeneration (TR), and Flexible Tree-
structured Regeneration (FTR). Our most concern is the regen-
eration time, which is measured as the time that the newcomer
spends on regenerating the coded blocks. In the evaluation of
the regeneration time, we ignore the encoding time on each
provider and the decoding time on the newcomer, because the
encoding and decoding operations can be performed simulta-
neously during the transmission of repair data [7].

For default settings, we use the same experiment setup as
[7], where redundant data is produced using an (n = 20, k =
5)-MDS code. The original ﬁle size is set to be M = 1GB. The
link capacities between the storage nodes obey the uniform
distribution within the range [10Mbps,120Mbps], which is
obtained from the measurement of real-world networks [8].

A. Effect of the number of providers d

The number of providers d is a key parameter for regenera-
tion in distributed storage systems. In the STAR topology, the
total repair bandwidth consumed in the regeneration process
decreases as d grows [3]. In the case of one node failure,
the theoretical optimal value of d is n − 1 for achieving a
minimum repair bandwidth, although accessing a large number
of providers will introduce extra communication overheads.
On the other hand, all feasible values of d may appear in
practice. In the evaluation, we vary d from k + 1 to n − 1,
in order to ﬁnd out how this factor affects the performance of
each regeneration scheme.

We consider the MSR point, where each node stores α =
M/k = 200MB. Fig. 6 presents the simulation results on
performance improvements of the FR, TR, and FTR schemes
with respect to the STAR scheme, where all possible values
of d are considered, and the uniform capacity distribution is
within the range [10Mbps,120Mbps]. Note that the regener-
ation schemes (STAR) proposed by Dimakis et al. in [3] is
implemented as a benchmark. For convenience, the traditional
STAR schemes based on uniform repair trafﬁc are simply
referred to as ‘STAR’ below.

In Fig. 6(a), we normalize the regeneration times of FR,
TR and FTR by the regeneration time of STAR to show the
relative improvement. In most cases, our schemes reduce the
regeneration time by 50% ∼ 70% compared with STAR.

11

We note that the regeneration times of both STAR and the
three proposed regeneration schemes all decrease as d grows
because of the reduction of total amount of repair data.
Meanwhile, the regeneration times of our schemes reduce
faster than that of STAR. This is because the star topology
has a large chance to include a low capacitated provider-to-
newcomer link when d is large. However, the bottleneck effect
can be alleviated by FR and the tree topology.

An interesting observation is that FR outperforms TR for
large d values, but on the contrary, TR outperforms FR when
d is small. The reason is that, in order to bypass the bottleneck
link with a tree topology, the intermediate provider nodes have
to transmit more data. This effect can only be recovered by
raising the minimum capacity for links connected to a big
number of participating providers.

In Fig. 6(b), we examine the total repair bandwidth con-
sumption for the FR, TR, and FTR schemes, where again
the repair bandwidth is normalized by that for STAR. As a
tradeoff, our schemes all sacriﬁce the repair bandwidth for
reducing the regeneration time. However, it is not surprising
that tree-structured regeneration has higher repair bandwidth
consumption than STAR-structured regeneration. For example,
in a regeneration tree the amount of repair data is counted
twice if it is transmitted to the newcomer by two hops.

As a conclusion, FTR is always advantageous than both
FR and TR in any case, which is promised by the design of
FTR. When d is large, however, FR has a regeneration time
almost as good as FTR, but enjoys a slightly smaller repair
bandwidth.

B. Effect of the bandwidth variance

In order to show the impacts of network bandwidth variance
on the regeneration time, we run simulations with 5 different
link capacity distributions: U1[0.3, 120]Mbps, U2[3, 120]Mbps,
U3[30, 120]Mbps, U4[60, 120]Mbps, U5[90, 120]Mbps. Fig. 7
shows the results with the number of providers d ﬁxed at 10.
The performances of our schemes are better when the vari-
ance of network bandwidth is large. For uniform distribution
U1[0.3, 120]Mbps, FR, TR and FTR all achieve a reduction
of about 90% in the regeneration time compared with the
traditional STAR scheme. When the variance of network
bandwidth becomes small, for example at U4[60, 120]Mbps
and U5[90, 120]Mbps, TR has the same regeneration time
as STAR, but FTR still reduces the regeneration time by
10% ∼ 20%.

C. Effect of the storage capacity per node α

Our tests above focus mainly on the MSR point, which
achieves the optimal storage efﬁciency. However, as shown
by Dimakis et al. [3], the repair bandwidth can be reduced by
storing more data on each storage node. To the other extreme,
the MBR point achieves the minimum repair bandwidth.

To test the effects of the storage capacity per node on our
schemes, we vary the values of α from the MSR point to
the MBR point in the simulations. Fig. 8 shows the results
on regeneration times and repair bandwidths for different α
values. We ﬁnd that the regeneration time in each of our

12

(a) Normalized regeneration time.

(b) Normalized bandwidth consumption.

Fig. 6. Effects of d on the performances of the FR, TR and FTR schemes, in comparison with the STAR scheme based on uniform repair trafﬁc, for n = 20,
k = 5, M = 1GB, and uniform capacity distribution range [10Mbps,120Mbps].

Fig. 7. Effects of network bandwidth on the regeneration time for the FR,
TR, and FTR schemes, where n = 20, k = 5, d = 10, and M = 1GB.

(a) Normalized regeneration time.

scheme does not change much as α varies. This implies that
our previous conclusions for the MSR case also apply to any
non-MSR case with a different storage amount α.

VII. RELATED WORK

Li et al. [11] ﬁrst considered the heterogeneity of network
bandwidth in data regeneration process and proposed a tree-
structured regeneration scheme to reduce the regeneration
time. They also proposed a scheme of building parallel re-
generation trees to further reduce the regeneration time in
the network with asymmetric links [12]. However, they only
discussed the case that the regeneration scheme requires k
providers, which means the minimal regeneration trafﬁc is
equal to the size of original ﬁle M. To further reduce the re-
generation time, they considered the regenerating codes in the
tree-structured regeneration scheme and proposed RCTREE
in [7]. They employ a minimum-storage regenerating (MSR)

(b) Normalized bandwidth consumption.

Fig. 8. Effects of storage amount on the regeneration time for the FR, TR
and FTR schemes, where n = 20, k = 5, d = 10, M = 1GB, and α varies
from the MSR point to the MBR point.

6810121416180.20.30.40.50.60.70.8#providers dRatio of Regeneration Time  FR/STARTR/STARFTR/STAR681012141618201.151.21.251.31.351.41.451.51.551.6#providers dRatio of Bandwidth Consumption  FR/STARTR/STARFTR/STAR2002102202302402502600.340.360.380.40.420.440.46Storage αRegeneration Time Percentage  FR/STARTR/STARFTR/STAR2002102202302402502601.221.241.261.281.31.321.341.36Storage αRatio of Bandwidth Consumption  FR/STARTR/STARFTR/STARd

α

codes in RCTREE, which means that the minimal regeneration
trafﬁc is
k(d−k+1) M bytes. Therefore, for a regeneration with
d−k+1 blocks to its parent
d providers, each provider sends
node. To make sure that the newcomer has enough information
to restore α blocks, it has to receive data directly from at least
d−k +1 providers. The details of how to construct an optimal
regeneration tree can be found in Algorithm 1 of [7]. Although
their algorithm ensures that the degree of newcomer is at least
d − k + 1, the MDS property still cannot be preserved after
data regeneration.

Sun et al. [13] considered the scenario of repairing mul-
tiple data losses, and proposed two algorithms based on
tree-structured regeneration to reduce the regeneration time.
However, they assumed the same amount of data transferred
between providers and newcomer for regenerating codes. Ac-
cording to our analysis, their regeneration schemes also cannot
preserve the MDS property.

Some researches, such as [14], [15], considered the hetero-
geneity of nodes availability and optimized the erasure code
deployment to reduce the data redundancy. Moreover, other
researches, such as [16], [17], [18], [19], [6], jointly considered
the repair-cost and heterogeneity of communication(download)
cost on each links. They ﬂexibly determine the amount of data
to minimize the total repair cost, which is different from the
regeneration time.

Regenerating codes suppose that all storage nodes store the
same amount of data and the newcomer obtains the same
amount of data from each provider. However, the communi-
cation cost of each provider may be different. Akhlaghi et al.
[16] proposed a cost-bandwidth trade-off by introducing two
classes of storage nodes with two different communication
costs. However, the newcomer may only contact a determined
number of providers in each of the two classes, and the amount
of data downloaded from providers in the same class remains
unchanged. Gerami et al. [17] considered the impact of the
network topology and proposed the optimal-cost regenerating
codes with variable link costs of providers with a given net-
work topology. They assumed that, just like for conventional
regenerating codes, newcomer downloads the same amount of
data blocks from each provider.

two repairs at

The generalized repair method with various amount of
information downloaded from each provider was studied by
Soroush Akhlaghi et al. [18], Craig Armstrong et al. [19]
and Nihar B. Shah et al. [6]. Armstrong et al. [19] proposed
necessary conditions for the minimum repair bandwidth of
the ﬁrst
the MSR point. They conjectured
that their result holds for any number of repairs, which has
been proved in this paper. They also generalized their work
to heterogenous storage capacities. Nihar B. Shah et al. [6]
proposed a ﬂexible class of regenerating codes in support of
both ﬂexible reconstruction and ﬂexible regeneration. They
accomplished ﬂexible regeneration with two parameters γ and
βmax, such that the repair bandwidth of each provider can
be ﬂexibly chosen from [0, βmax] as long as the total repair
bandwidth is no less than γ. Their method is generalized in
this paper by introducing the concept of feasible region, which
characterizes the set of feasible repair bandwidth vectors. We
have also compared their work with ours in the evaluation

13

section above.

VIII. CONCLUSION

We have reconsidered the problem of how to reduce the
regeneration time in networks with heterogeneous link ca-
pacities. We have analyzed the minimum amount of data
to be transmitted on each link of the regeneration tree, and
proved that
the problem of building optimal regeneration
tree is NP-complete. Using a proposed heuristic algorithm to
construct a near-optimal regeneration tree, the regeneration
time can further be reduced by allowing non-uniform end-
to-end repair trafﬁc. With the non-uniform end-to-end repair
trafﬁc, we can ﬂexibly determine the amount of coded data
generated by each provider. Simulation results have shown
that our regeneration schemes are able to maintain the MDS
property and reduce the regeneration time by 10% ∼ 90%,
compared with traditional star-structured regenerating codes.
The proposed Flexible Tree-structured Regeneration scheme
performs even better than RCTREE.

APPENDIX A

LOSS OF THE MDS PROPERTY IN RCTREE

Let us employ an example to demonstrate that the RCTREE
scheme is unable to maintain the MDS property. Consider the
overlay network shown in Fig. 1(a). Assume that a ﬁle of size
M = 480Mb is distributed using a (n = 5, k = 2) MDS-code
to the ﬁve storage nodes v1, v2,··· , v5, of which each holds
α = M/k = 240Mb data. The MDS property requires that the
ﬁle can be reconstructed by any two storage nodes. Suppose
that v5 fails, v0 is selected as the newcomer, and v1,··· , v4
are the d = 4 providers. In this example, RCTREE will use
the same regeneration tree as shown in Fig. 1(d), where a ﬁxed
k(d−k+1) = 80Mb is transmitted on each link
amount of β =
M
for regeneration at v0.

Assume that the data collector connects to v0 and v3 to
reconstruct the ﬁle. Fig. 9 shows the information ﬂow graph.
As marked in the ﬁgure, there is a cut of volume 2β + α =
400Mb, which is smaller than the ﬁle size. Therefore, the ﬁle
cannot be reconstructed with storage nodes v3, v0.

To ﬁnd out how frequently the ﬁle reconstruction fails, we
have implemented the RCTREE scheme based on Random
Linear Regenerating Codes (RLRC) and run simulations with
practical parameter values. The ﬁnite ﬁeld GF (216) has been
chosen for RLRC since it is sufﬁciently large such that the
probability that linearly dependent blocks are regenerated is
negligible [20]. Fig. 10 presents the simulation results for four
sets of code parameter settings, showing the probability of
successful ﬁle reconstruction as a function of the number of
repair rounds. From this ﬁgure, we can see that the original
ﬁle can hardly be reconstructed after 5 repair rounds as the
number of original storage nodes becomes in turn smaller than
k.

From these results, we may state that the problem of op-
timizing regeneration time with heterogeneous link capacities
should be solved with a satisfaction to the MDS property.

14

theorem, it is sufﬁcient to show that in the i-th group, where
1 ≤ i ≤ k−2 and M−iα > 0, there does not exist a maximum
region. Note that we call a feasible region maximum, if it
includes all feasible regions. A feasible region D is maximal,
if adding any vector βββ ∈ Rd\D to D makes it infeasible.
We prove this by contradiction. If there exists a maximum
region Dmax in the i-th group, it must contain all the vectors
βββ satisfying the following constraints:

k−i(cid:88)

σj(βββ) ≥ M − iα

j=1
σk−i(βββ) < α
σk−i+1(βββ) ≥ α
∀j : βj ≤ α.

Then it is sufﬁcient to prove that Dmax does not satisfy the
min-cut condition.
Pick up a βββ ∈ Dmax and assume that β1 ≤ β2 ≤ ··· ≤ βd
without loss of generality. Under this assumption, σj(βββ) =
β1 + ··· + βd−k+j. If
σj(βββ) > M − iα, we construct βββ0
as follows:

j=1

k−i(cid:88)
(cid:26) tβj

α

β0
j =

if 1 ≤ j ≤ d − i
if d − i + 1 ≤ j ≤ d

(cid:80)k−i
where t = M−iα
k−i(cid:88)

j=1 σj (βββ)

. Therefore,

k−i(cid:88)

σj(βββ0) = t

σj(βββ) = M − iα

j=1

j=1

σk−i(βββ0) < σk−i(βββ) < α
σk−i+1(βββ0) ≥ α
j ≤ α.

∀j : β0

Thus, βββ0 ∈ Dmax. Let m be the minimum integer such that
σm(βββ0) > 0. As M − iα > 0, we have m ≤ k − i. Thus, it is
in turn sufﬁcient to prove

k−i(cid:88)

j=1

k−i(cid:88)

j=1

min

βββ∈Dmax

σj(βββ) <

σj(βββ0) = M − iα.

βββ∈Dmax

Because min

σj(βββ) ≤ σj(βββ0), we will

show that
σm(βββ) < σm(βββ0) to complete the proof. Due to the
min
βββ∈Dmax
deﬁnition of m, we have β1 = β2 = ··· = βd−k+m−1 = 0,
and βd−k+m > 0. Then we construct βββ(cid:48) as follows:

 β0

β(cid:48)
j =

j − 
j + (k − i)
β0
β0
j

if j = d − k + m
if j = d − k + k − i
otherwise

where 0 <  < min{ α−σk−i(βββ0)

k−i−1

d−k+m}.

, β0

Fig. 9. An example of RCTREE and the corresponding information ﬂow
graph. The parameters are n = 5, d = 4, k = 2, M = 480Mb, α = M/k =
240Mb, β= M
k(d−k+1) = 80Mb. A min-cut with capacity 2β + α = 400Mb
is illustrated by the red dashed line, implying that a DC can not reconstruct
the original ﬁle by connecting with {v3, v0}.

Fig. 10.
successfully reconstructing the original ﬁle.

Impacts of the number of repair rounds on the probability of

THE MAXIMAL FEASIBLE REGION FOR THE NON-MSR

APPENDIX B

CASE

Theorem 6: For the non-MSR case of α > M/k and k ≥ 3,

there does not exist a maximum feasible region D.
Proof: Recall that σj(βββ) is deﬁned as the sum of the
d − k + j smallest components of the repair bandwidth βββ =
(β1, β2,··· , βd). For a feasible region D, it always holds that
βββ∈D σj(βββ) for j = 1,··· , d − 1. Let i denote
βββ∈D σj+1(βββ) ≥ min
min
the number of terms min

βββ∈D σj(βββ) ≥ α, i.e.,

βββ∈D σk−i(βββ) < α ∧ min

βββ∈D σk−i+1(βββ) ≥ α,

min

where i must range from 1 to k, since σk(βββ) must be no less
than α for a successful repair. Therefore, all feasible regions
can be partitioned into k groups by the value of i, and for
α > M/k, every group is non-empty. In order to prove this

SDC∞∞∞∞∞∞∞k=2αααααCutSsourceDCdata collectorstorage noderegenerationtrafficinv1outv1inv2outv2inv3outv3inv4outv4inv5outv5inv0outv0inivoutiv0102030405060708090100−0.100.10.20.30.40.50.60.70.8Repair roundsPr [data is available]MSR, bandwidth = [0.3,120]Mbps  [n = 10, d = 8, k = 6][n = 10, d = 9, k = 6][n = 10, d = 8, k = 7][n = 11, d = 8, k = 6]15

[17] M. Gerami, M. Xiao, and M. Skoglund, “Optimal-cost Repair in Multi-
hop Distributed Storage Systems,” in Proc. of IEEE International
Symposium on Information Theory (ISIT), 2011, pp. 1437–1441.

[18] S. Akhlaghi, A. Kiani, and M. Ghanavati, “A fundamental trade-off
between the download cost and repair bandwidth in distributed storage
systems,” in Proceedings of IEEE International Symposium on Network
Coding (NetCod), 2010.

[19] C. Armstrong and A. Vardy, “Distributed storage with communication
costs,” in Proceedings of Annual Allerton Conference on Communica-
tion, Control, and Computing (Allerton), 2011.

[20] A. Duminuco and E. Biersack, “A practical study of regenerating codes
for peer-to-peer backup systems,” in 29th IEEE International Conference
on Distributed Computing Systems(ICDCS’09).

IEEE, 2009.

k−i−1(cid:88)

(σj(βββ0) − )

σj(βββ0) +

+σk−i(βββ0) + (k − i − 1)

j=m

σj(βββ0) = M − iα

m−1(cid:88)
≥ k−i(cid:88)

j=1

j=1

Therefore,

k−i(cid:88)

j=1

σj(βββ(cid:48)) =

σk−i(βββ(cid:48)) = σk−i(βββ0) + (k − i − 1) < α

σk−i+1(βββ(cid:48)) = σk−i+1(βββ0) + (k − i − 1) ≥ α

∀j : β(cid:48)

j ≤ α,

which means βββ(cid:48) ∈ Dmax and min
β∈Dmax
σm(β0) − .

σm(βββ) ≤ σm(βββ(cid:48)) =

REFERENCES

[1] P. P. C. L. Yuchong Hu, Henry C. H. Chen and Y. Tang, “Nccloud:
applying network coding for the storage repair in a cloud-of-clouds,”
in Proceedings of USSENIX Conference on File and Storage Technolo-
gies(FAST), 2012.

[2] S. Ghemawat, H. Gobioff, and S.-T. Leung, “The google ﬁle system,” in
ACM SIGOPS Operating Systems Review, vol. 37, no. 5. ACM, 2003,
pp. 29–43.

[3] A. G. Dimakis, P. B. Godfrey, M. J. W. Y. Wu, and K. Ramchandran,
“Network Coding for Distributed Storage System,” IEEE Transactions
on Information Theory, vol. 56, no. 9, pp. 4539–4551, 2010.

[4] B. Gast´on, J. Pujol, and M. Villanueva, “A realistic distributed storage

system: the rack model,” arXiv preprint arXiv:1302.5657, 2013.

[5] T. Benson, A. Akella, and D. A. Maltz, “Network trafﬁc characteristics
of data centers in the wild,” in Proceedings of the 10th ACM SIGCOMM
conference on Internet measurement, ser. IMC ’10. ACM, 2010, pp.
267–280.

[6] N. Shah, K. V. Rashmi, and P. Kumar, “A ﬂexible class of regenerating
codes for distributed storage,” in Proceedings of IEEE International
Symposium on Information Theory Proceedings (ISIT), 2010.

[7] J. Li, S. Yang, X. Wang, and B. Li, “Tree-structured Data Regeneration
in Distributed Storage Systems with Regenerating Codes,” in Proceed-
ings of IEEE Conference on Computer Communications (INFOCOM),
2010.

[8] S.-J. Lee, P. Sharma, S. Banerjee, S. Basu, and R. Fonseca, “Measuring
bandwidth between planetlab nodes,” in Passive and Active Network
Measurement. Springer, 2005, pp. 292–305.

[9] I. Reed and G. Solomon, “Polynomial Codes over Certain Finite Fields,”
Journal of the Society for Industrial and Applied Mathematics, vol. 8,
no. 2, pp. 300–304, 1960.

[10] R. C. Prim, “Shortest connection networks and some generalizations,”

Bell system technical journal, vol. 36, no. 6, pp. 1389–1401, 1957.

[11] J. Li, S. Yang, X. Wang, X. Xue, and B. Li, “Tree-structured data
regeneration with network coding in distributed storage systems,” in Pro-
ceedings of 17th International Workshop on Quality of Service(IWQoS),
2009.

[12] J. Li, S. Yang, and X. Wang, “Building parallel regeneration trees
in distributed storage systems with asymmetric links,” in 2010 6th
International Conference on Collaborative Computing: Networking,
Applications and Worksharing (CollaborateCom), 2010.

[13] W. Sun, Y. Wang, and X. Pei, “Tree-structured parallel regeneration
for multiple data losses in distributed storage systems based on erasure
codes,” Communications, China, vol. 10, no. 4, pp. 113–125, 2013.

[14] L. Pamies-Juarez, P. Garcia-Lopez,

and M. Sanchez-Artigas,
“Heterogeneity-aware erasure codes for peer-to-peer storage systems,”
in International Conference on Parallel Processing (ICPP), 2009.

[15] G. Xu, S. Lin, G. Wang, X. Liu, K. Shi, and H. Zhang, “Hero:
Heterogeneity-aware erasure coded redundancy optimal allocation for
reliable storage in distributed networks,” in International Performance
Computing and Communications Conference (IPCCC), 2012.

[16] S. Akhlaghi, A. Kiani, and M. R. Ghanavati, “Cost-bandwidth Tradeoff
in Distributed Storage Systems,” Computer Communications, vol. 33,
no. 17, pp. 2105–2115, 2010.

